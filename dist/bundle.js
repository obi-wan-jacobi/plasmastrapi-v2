/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "aa93ab5a6751cf02ae00";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus("idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				/*globals chunkId */
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (!module || module.hot._selfAccepted) continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		hotCurrentHash = hotUpdateNewHash;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = [moduleId];
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./src/app/main.ts")(__webpack_require__.s = "./src/app/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@turf/bbox/index.js":
/*!******************************************!*\
  !*** ./node_modules/@turf/bbox/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    meta_1.coordEach(geojson, function (coord) {
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
exports.default = bbox;


/***/ }),

/***/ "./node_modules/@turf/bearing/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@turf/bearing/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Takes two {@link Point|points} and finds the geographic bearing between them,
 * i.e. the angle measured in degrees from the north line (0 degrees)
 *
 * @name bearing
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984]);
 * var point2 = turf.point([-75.534, 39.123]);
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2]
 * point1.properties['marker-color'] = '#f00'
 * point2.properties['marker-color'] = '#0f0'
 * point1.properties.bearing = bearing
 */
function bearing(start, end, options) {
    if (options === void 0) { options = {}; }
    // Reverse calculation
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    var coordinates1 = invariant_1.getCoord(start);
    var coordinates2 = invariant_1.getCoord(end);
    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);
    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return helpers_1.radiansToDegrees(Math.atan2(a, b));
}
/**
 * Calculates Final Bearing
 *
 * @private
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @returns {number} bearing
 */
function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}
exports.default = bearing;


/***/ }),

/***/ "./node_modules/@turf/boolean-contains/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@turf/boolean-contains/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
var bbox_1 = __importDefault(__webpack_require__(/*! @turf/bbox */ "./node_modules/@turf/bbox/index.js"));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(/*! @turf/boolean-point-in-polygon */ "./node_modules/@turf/boolean-point-in-polygon/index.js"));
var boolean_point_on_line_1 = __importDefault(__webpack_require__(/*! @turf/boolean-point-on-line */ "./node_modules/@turf/boolean-point-on-line/index.js"));
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Boolean-contains returns True if the second geometry is completely contained by the first geometry.
 * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)
 * must not intersect the exterior of the primary (geometry a).
 * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.
 *
 * @name booleanContains
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 * var point = turf.point([1, 2]);
 *
 * turf.booleanContains(line, point);
 * //=true
 */
function booleanContains(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = invariant_1.getType(feature1);
    var type2 = invariant_1.getType(feature2);
    var coords1 = invariant_1.getCoords(feature1);
    var coords2 = invariant_1.getCoords(feature2);
    switch (type1) {
        case "Point":
            switch (type2) {
                case "Point":
                    return compareCoords(coords1, coords2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch (type2) {
                case "Point":
                    return isPointInMultiPoint(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch (type2) {
                case "Point":
                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointOnLine(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch (type2) {
                case "Point":
                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });
                case "LineString":
                    return isLineInPoly(geom1, geom2);
                case "Polygon":
                    return isPolyInPoly(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
exports.default = booleanContains;
function isPointInMultiPoint(multiPoint, pt) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isPointInMultiPoint = isPointInMultiPoint;
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
        var coord2 = _a[_i];
        var matchFound = false;
        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
            var coord1 = _c[_b];
            if (compareCoords(coord2, coord1)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;
function isMultiPointOnLine(lineString, multiPoint) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default(coord, lineString)) {
            return false;
        }
    }
    if (haveFoundInteriorPoint) {
        return true;
    }
    return false;
}
exports.isMultiPointOnLine = isMultiPointOnLine;
function isMultiPointInPoly(polygon, multiPoint) {
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInPoly = isMultiPointInPoly;
function isLineOnLine(lineString1, lineString2) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
        var coords = _a[_i];
        if (boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {
            return false;
        }
    }
    return haveFoundInteriorPoint;
}
exports.isLineOnLine = isLineOnLine;
function isLineInPoly(polygon, linestring) {
    var output = false;
    var i = 0;
    var polyBbox = bbox_1.default(polygon);
    var lineBbox = bbox_1.default(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    for (i; i < linestring.coordinates.length - 1; i++) {
        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if (boolean_point_in_polygon_1.default({ type: "Point", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isLineInPoly = isLineInPoly;
/**
 * Is Polygon2 in Polygon1
 * Only takes into account outer rings
 *
 * @private
 * @param {Geometry|Feature<Polygon>} feature1 Polygon1
 * @param {Geometry|Feature<Polygon>} feature2 Polygon2
 * @returns {boolean} true/false
 */
function isPolyInPoly(feature1, feature2) {
    // Handle Nulls
    if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
    }
    var poly1Bbox = bbox_1.default(feature1);
    var poly2Bbox = bbox_1.default(feature2);
    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
    }
    var coords = invariant_1.getGeom(feature2).coordinates;
    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
        var ring = coords_1[_i];
        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
            var coord = ring_1[_a];
            if (!boolean_point_in_polygon_1.default(coord, feature1)) {
                return false;
            }
        }
    }
    return true;
}
exports.isPolyInPoly = isPolyInPoly;
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) {
        return false;
    }
    if (bbox1[2] < bbox2[2]) {
        return false;
    }
    if (bbox1[1] > bbox2[1]) {
        return false;
    }
    if (bbox1[3] < bbox2[3]) {
        return false;
    }
    return true;
}
exports.doBBoxOverlap = doBBoxOverlap;
/**
 * compareCoords
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {boolean} true/false if coord pairs match
 */
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
exports.compareCoords = compareCoords;
function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
exports.getMidpoint = getMidpoint;


/***/ }),

/***/ "./node_modules/@turf/boolean-overlap/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@turf/boolean-overlap/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var line_overlap_1 = __webpack_require__(/*! @turf/line-overlap */ "./node_modules/@turf/line-overlap/index.js");
var line_intersect_1 = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js");
var GeojsonEquality = __webpack_require__(/*! geojson-equality */ "./node_modules/geojson-equality/index.js");
/**
 * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry
 * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,
 * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.
 *
 * @name booleanOverlap
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input
 * @returns {boolean} true/false
 * @example
 * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);
 * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);
 * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);
 *
 * turf.booleanOverlap(poly1, poly2)
 * //=true
 * turf.booleanOverlap(poly2, poly3)
 * //=false
 */
function booleanOverlap(feature1, feature2) {
    // validation
    if (!feature1)
        throw new Error('feature1 is required');
    if (!feature2)
        throw new Error('feature2 is required');
    var type1 = invariant_1.getType(feature1);
    var type2 = invariant_1.getType(feature2);
    if (type1 !== type2)
        throw new Error('features must be of the same type');
    if (type1 === 'Point')
        throw new Error('Point geometry not supported');
    // features must be not equal
    var equality = new GeojsonEquality({ precision: 6 });
    if (equality.compare(feature1, feature2))
        return false;
    var overlap = 0;
    switch (type1) {
        case 'MultiPoint':
            var coords1 = meta_1.coordAll(feature1);
            var coords2 = meta_1.coordAll(feature2);
            coords1.forEach(function (coord1) {
                coords2.forEach(function (coord2) {
                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1])
                        overlap++;
                });
            });
            break;
        case 'LineString':
        case 'MultiLineString':
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_overlap_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
        case 'Polygon':
        case 'MultiPolygon':
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_intersect_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
    }
    return overlap > 0;
}
exports.default = booleanOverlap;


/***/ }),

/***/ "./node_modules/@turf/boolean-point-in-polygon/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@turf/boolean-point-in-polygon/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
 * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 *
 * @name booleanPointInPolygon
 * @param {Coord} point input point
 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * turf.booleanPointInPolygon(pt, poly);
 * //= true
 */
function booleanPointInPolygon(point, polygon, options) {
    if (options === void 0) { options = {}; }
    // validation
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    var pt = invariant_1.getCoord(point);
    var geom = invariant_1.getGeom(polygon);
    var type = geom.type;
    var bbox = polygon.bbox;
    var polys = geom.coordinates;
    // Quick elimination if point is not inside bbox
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    // normalize to multipolygon
    if (type === "Polygon") {
        polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) {
                insidePoly = true;
            }
        }
    }
    return insidePoly;
}
exports.default = booleanPointInPolygon;
/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @returns {boolean} inRing
 */
function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
        if (onBoundary) {
            return !ignoreBoundary;
        }
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
}
/**
 * inBBox
 *
 * @private
 * @param {Position} pt point [x,y]
 * @param {BBox} bbox BBox [west, south, east, north]
 * @returns {boolean} true/false if point is inside BBox
 */
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] &&
        bbox[1] <= pt[1] &&
        bbox[2] >= pt[0] &&
        bbox[3] >= pt[1];
}


/***/ }),

/***/ "./node_modules/@turf/boolean-point-on-line/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@turf/boolean-point-on-line/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Returns true if a point is on a line. Accepts a optional parameter to ignore the
 * start and end vertices of the linestring.
 *
 * @name booleanPointOnLine
 * @param {Coord} pt GeoJSON Point
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
 * @returns {boolean} true/false
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
 * //=true
 */
function booleanPointOnLine(pt, line, options) {
    if (options === void 0) { options = {}; }
    // Normalize inputs
    var ptCoords = invariant_1.getCoord(pt);
    var lineCoords = invariant_1.getCoords(line);
    // Main
    for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {
            return true;
        }
    }
    return false;
}
// See http://stackoverflow.com/a/4833823/1979085
/**
 * @private
 * @param {Position} lineSegmentStart coord pair of start of line
 * @param {Position} lineSegmentEnd coord pair of end of line
 * @param {Position} pt coord pair of point to check
 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.
 * If true which end to ignore.
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {
    var x = pt[0];
    var y = pt[1];
    var x1 = lineSegmentStart[0];
    var y1 = lineSegmentStart[1];
    var x2 = lineSegmentEnd[0];
    var y2 = lineSegmentEnd[1];
    var dxc = pt[0] - x1;
    var dyc = pt[1] - y1;
    var dxl = x2 - x1;
    var dyl = y2 - y1;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    }
    else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    }
    else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    }
    else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
exports.default = booleanPointOnLine;


/***/ }),

/***/ "./node_modules/@turf/destination/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@turf/destination/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
function destination(origin, distance, bearing, options) {
    if (options === void 0) { options = {}; }
    // Handle input
    var coordinates1 = invariant_1.getCoord(origin);
    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
    var bearingRad = helpers_1.degreesToRadians(bearing);
    var radians = helpers_1.lengthToRadians(distance, options.units);
    // Main
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = helpers_1.radiansToDegrees(longitude2);
    var lat = helpers_1.radiansToDegrees(latitude2);
    return helpers_1.point([lng, lat], options.properties);
}
exports.default = destination;


/***/ }),

/***/ "./node_modules/@turf/distance/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@turf/distance/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord} from origin point
 * @param {Coord} to destination point
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
    if (options === void 0) { options = {}; }
    var coordinates1 = invariant_1.getCoord(from);
    var coordinates2 = invariant_1.getCoord(to);
    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));
    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) +
        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
exports.default = distance;


/***/ }),

/***/ "./node_modules/@turf/helpers/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@turf/helpers/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.370,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.370,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, options) {
    if (options === void 0) { options = {}; }
    switch (type) {
        case "Point": return point(coordinates).geometry;
        case "LineString": return lineString(coordinates).geometry;
        case "Polygon": return polygon(coordinates).geometry;
        case "MultiPoint": return multiPoint(coordinates).geometry;
        case "MultiLineString": return multiLineString(coordinates).geometry;
        case "MultiPolygon": return multiPolygon(coordinates).geometry;
        default: throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
// Deprecated methods
function radians2degrees() {
    throw new Error("method has been renamed to `radiansToDegrees`");
}
exports.radians2degrees = radians2degrees;
function degrees2radians() {
    throw new Error("method has been renamed to `degreesToRadians`");
}
exports.degrees2radians = degrees2radians;
function distanceToDegrees() {
    throw new Error("method has been renamed to `lengthToDegrees`");
}
exports.distanceToDegrees = distanceToDegrees;
function distanceToRadians() {
    throw new Error("method has been renamed to `lengthToRadians`");
}
exports.distanceToRadians = distanceToRadians;
function radiansToDistance() {
    throw new Error("method has been renamed to `radiansToLength`");
}
exports.radiansToDistance = radiansToDistance;
function bearingToAngle() {
    throw new Error("method has been renamed to `bearingToAzimuth`");
}
exports.bearingToAngle = bearingToAngle;
function convertDistance() {
    throw new Error("method has been renamed to `convertLength`");
}
exports.convertDistance = convertDistance;


/***/ }),

/***/ "./node_modules/@turf/invariant/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@turf/invariant/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;


/***/ }),

/***/ "./node_modules/@turf/line-intersect/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@turf/line-intersect/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var line_segment_1 = __importDefault(__webpack_require__(/*! @turf/line-segment */ "./node_modules/@turf/line-segment/index.js"));
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var geojson_rbush_1 = __importDefault(__webpack_require__(/*! geojson-rbush */ "./node_modules/geojson-rbush/index.js"));
/**
 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
 *
 * @name lineIntersect
 * @param {GeoJSON} line1 any LineString or Polygon
 * @param {GeoJSON} line2 any LineString or Polygon
 * @returns {FeatureCollection<Point>} point(s) that intersect both
 * @example
 * var line1 = turf.lineString([[126, -11], [129, -21]]);
 * var line2 = turf.lineString([[123, -18], [131, -14]]);
 * var intersects = turf.lineIntersect(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, intersects]
 */
function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    // First, normalize geometries to features
    // Then, handle simple 2-vertex segments
    if (line1.type === "LineString") {
        line1 = helpers_1.feature(line1);
    }
    if (line2.type === "LineString") {
        line2 = helpers_1.feature(line2);
    }
    if (line1.type === "Feature" &&
        line2.type === "Feature" &&
        line1.geometry !== null &&
        line2.geometry !== null &&
        line1.geometry.type === "LineString" &&
        line2.geometry.type === "LineString" &&
        line1.geometry.coordinates.length === 2 &&
        line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) {
            results.push(intersect);
        }
        return helpers_1.featureCollection(results);
    }
    // Handles complex GeoJSON Geometries
    var tree = geojson_rbush_1.default();
    tree.load(line_segment_1.default(line2));
    meta_1.featureEach(line_segment_1.default(line1), function (segment) {
        meta_1.featureEach(tree.search(segment), function (match) {
            var intersect = intersects(segment, match);
            if (intersect) {
                // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                var key = invariant_1.getCoords(intersect).join(",");
                if (!unique[key]) {
                    unique[key] = true;
                    results.push(intersect);
                }
            }
        });
    });
    return helpers_1.featureCollection(results);
}
/**
 * Find a point that intersects LineStrings with two coordinates each
 *
 * @private
 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
 * @returns {Feature<Point>} intersecting GeoJSON Point
 */
function intersects(line1, line2) {
    var coords1 = invariant_1.getCoords(line1);
    var coords2 = invariant_1.getCoords(line2);
    if (coords1.length !== 2) {
        throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
        throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x1 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));
    if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
            return null;
        }
        return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + (uA * (x2 - x1));
        var y = y1 + (uA * (y2 - y1));
        return helpers_1.point([x, y]);
    }
    return null;
}
exports.default = lineIntersect;


/***/ }),

/***/ "./node_modules/@turf/line-overlap/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/line-overlap/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var geojson_rbush_1 = __webpack_require__(/*! geojson-rbush */ "./node_modules/geojson-rbush/index.js");
var line_segment_1 = __webpack_require__(/*! @turf/line-segment */ "./node_modules/@turf/line-segment/index.js");
var nearest_point_on_line_1 = __webpack_require__(/*! @turf/nearest-point-on-line */ "./node_modules/@turf/nearest-point-on-line/index.js");
var boolean_point_on_line_1 = __webpack_require__(/*! @turf/boolean-point-on-line */ "./node_modules/@turf/boolean-point-on-line/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var equal = __webpack_require__(/*! deep-equal */ "./node_modules/deep-equal/index.js");
/**
 * Takes any LineString or Polygon and returns the overlapping lines between both features.
 *
 * @name lineOverlap
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)
 * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
 * @example
 * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);
 * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);
 *
 * var overlapping = turf.lineOverlap(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, overlapping]
 */
function lineOverlap(line1, line2, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options))
        throw new Error('options is invalid');
    var tolerance = options.tolerance || 0;
    // Containers
    var features = [];
    // Create Spatial Index
    var tree = geojson_rbush_1.default();
    // To-Do -- HACK way to support typescript
    var line = line_segment_1.default(line1);
    tree.load(line);
    var overlapSegment;
    // Line Intersection
    // Iterate over line segments
    meta_1.segmentEach(line2, function (segment) {
        var doesOverlaps = false;
        // Iterate over each segments which falls within the same bounds
        meta_1.featureEach(tree.search(segment), function (match) {
            if (doesOverlaps === false) {
                var coordsSegment = invariant_1.getCoords(segment).sort();
                var coordsMatch = invariant_1.getCoords(match).sort();
                // Segment overlaps feature
                if (equal(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    // Overlaps already exists - only append last coordinate of segment
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                    // Match segments which don't share nodes (Issue #901)
                }
                else if ((tolerance === 0) ?
                    boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) :
                    nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance &&
                        nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                }
                else if ((tolerance === 0) ?
                    boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) :
                    nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance &&
                        nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {
                    // Do not define (doesOverlap = true) since more matches can occur within the same segment
                    // doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, match);
                    else
                        overlapSegment = match;
                }
            }
        });
        // Segment doesn't overlap - add overlaps to results & reset
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            overlapSegment = undefined;
        }
    });
    // Add last segment if exists
    if (overlapSegment)
        features.push(overlapSegment);
    return helpers_1.featureCollection(features);
}
/**
 * Concat Segment
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<LineString>} segment 2-vertex LineString
 * @returns {Feature<LineString>} concat linestring
 */
function concatSegment(line, segment) {
    var coords = invariant_1.getCoords(segment);
    var lineCoords = invariant_1.getCoords(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;
    if (equal(coords[0], start))
        geom.unshift(coords[1]);
    else if (equal(coords[0], end))
        geom.push(coords[1]);
    else if (equal(coords[1], start))
        geom.unshift(coords[0]);
    else if (equal(coords[1], end))
        geom.push(coords[0]);
    return line;
}
exports.default = lineOverlap;


/***/ }),

/***/ "./node_modules/@turf/line-segment/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/line-segment/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
/**
 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a
 * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
 *
 * @name lineSegment
 * @param {GeoJSON} geojson GeoJSON Polygon or LineString
 * @returns {FeatureCollection<LineString>} 2-vertex line segments
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 * var segments = turf.lineSegment(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, segments]
 */
function lineSegment(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    var results = [];
    meta_1.flattenEach(geojson, function (feature) {
        lineSegmentFeature(feature, results);
    });
    return helpers_1.featureCollection(results);
}
/**
 * Line Segment
 *
 * @private
 * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
 * @param {Array} results push to results
 * @returns {void}
 */
function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
        switch (geometry.type) {
            case "Polygon":
                coords = invariant_1.getCoords(geometry);
                break;
            case "LineString":
                coords = [invariant_1.getCoords(geometry)];
        }
        coords.forEach(function (coord) {
            var segments = createSegments(coord, geojson.properties);
            segments.forEach(function (segment) {
                segment.id = results.length;
                results.push(segment);
            });
        });
    }
}
/**
 * Create Segments from LineString coordinates
 *
 * @private
 * @param {Array<Array<number>>} coords LineString coordinates
 * @param {*} properties GeoJSON properties
 * @returns {Array<Feature<LineString>>} line segments
 */
function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function (previousCoords, currentCoords) {
        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}
/**
 * Create BBox between two coordinates (faster than @turf/bbox)
 *
 * @private
 * @param {Array<number>} coords1 Point coordinate
 * @param {Array<number>} coords2 Point coordinate
 * @returns {BBox} [west, south, east, north]
 */
function bbox(coords1, coords2) {
    var x1 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = (x1 < x2) ? x1 : x2;
    var south = (y1 < y2) ? y1 : y2;
    var east = (x1 > x2) ? x1 : x2;
    var north = (y1 > y2) ? y1 : y2;
    return [west, south, east, north];
}
exports.default = lineSegment;


/***/ }),

/***/ "./node_modules/@turf/meta/index.js":
/*!******************************************!*\
  !*** ./node_modules/@turf/meta/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var helpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    if (geomType === 'MultiPoint') multiFeatureIndex++;
                }
                if (geomType === 'LineString') multiFeatureIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') multiFeatureIndex++;
                    if (geomType === 'Polygon') geometryIndex++;
                }
                if (geomType === 'Polygon') multiFeatureIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    geometryIndex = 0;
                    for (k = 0; k < coords[j].length; k++) {
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        geometryIndex++;
                    }
                    multiFeatureIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');

    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
            break;
        case 'Polygon':
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find SegmentIndex
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
    }
    throw new Error('geojson is invalid');
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find Coord Index
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
        return helpers.point(coords, properties, options);
    case 'MultiPoint':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        return helpers.point(coords[multiFeatureIndex], properties, options);
    case 'LineString':
        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
        return helpers.point(coords[coordIndex], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error('geojson is invalid');
}

exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.coordAll = coordAll;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.findSegment = findSegment;
exports.findPoint = findPoint;


/***/ }),

/***/ "./node_modules/@turf/nearest-point-on-line/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@turf/nearest-point-on-line/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var bearing_1 = __webpack_require__(/*! @turf/bearing */ "./node_modules/@turf/bearing/index.js");
var distance_1 = __webpack_require__(/*! @turf/distance */ "./node_modules/@turf/distance/index.js");
var destination_1 = __webpack_require__(/*! @turf/destination */ "./node_modules/@turf/destination/index.js");
var line_intersect_1 = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
 *
 * @name nearestPointOnLine
 * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
 * @param {Geometry|Feature<Point>|number[]} pt point to snap from
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
 * @example
 * var line = turf.lineString([
 *     [-77.031669, 38.878605],
 *     [-77.029609, 38.881946],
 *     [-77.020339, 38.884084],
 *     [-77.025661, 38.885821],
 *     [-77.021884, 38.889563],
 *     [-77.019824, 38.892368]
 * ]);
 * var pt = turf.point([-77.037076, 38.884017]);
 *
 * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line, pt, snapped];
 * snapped.properties['marker-color'] = '#00f';
 */
function nearestPointOnLine(lines, pt, options) {
    if (options === void 0) { options = {}; }
    var closestPt = helpers_1.point([Infinity, Infinity], {
        dist: Infinity
    });
    var length = 0.0;
    meta_1.flattenEach(lines, function (line) {
        var coords = invariant_1.getCoords(line);
        for (var i = 0; i < coords.length - 1; i++) {
            //start
            var start = helpers_1.point(coords[i]);
            start.properties.dist = distance_1.default(pt, start, options);
            //stop
            var stop_1 = helpers_1.point(coords[i + 1]);
            stop_1.properties.dist = distance_1.default(pt, stop_1, options);
            // sectionLength
            var sectionLength = distance_1.default(start, stop_1, options);
            //perpendicular
            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
            var direction = bearing_1.default(start, stop_1);
            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);
            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);
            var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
            var intersectPt = null;
            if (intersect.features.length > 0) {
                intersectPt = intersect.features[0];
                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);
                intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);
            }
            if (start.properties.dist < closestPt.properties.dist) {
                closestPt = start;
                closestPt.properties.index = i;
                closestPt.properties.location = length;
            }
            if (stop_1.properties.dist < closestPt.properties.dist) {
                closestPt = stop_1;
                closestPt.properties.index = i + 1;
                closestPt.properties.location = length + sectionLength;
            }
            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = intersectPt;
                closestPt.properties.index = i;
            }
            // update length
            length += sectionLength;
        }
    });
    return closestPt;
}
exports.default = nearestPointOnLine;


/***/ }),

/***/ "./node_modules/affine-hull/aff.js":
/*!*****************************************!*\
  !*** ./node_modules/affine-hull/aff.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = affineHull

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")

function linearlyIndependent(points, d) {
  var nhull = new Array(d+1)
  for(var i=0; i<points.length; ++i) {
    nhull[i] = points[i]
  }
  for(var i=0; i<=points.length; ++i) {
    for(var j=points.length; j<=d; ++j) {
      var x = new Array(d)
      for(var k=0; k<d; ++k) {
        x[k] = Math.pow(j+1-i, k)
      }
      nhull[j] = x
    }
    var o = orient.apply(void 0, nhull)
    if(o) {
      return true
    }
  }
  return false
}

function affineHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  }
  if(n === 1) {
    return [0]
  }
  var d = points[0].length
  var frame = [ points[0] ]
  var index = [ 0 ]
  for(var i=1; i<n; ++i) {
    frame.push(points[i])
    if(!linearlyIndependent(frame, d)) {
      frame.pop()
      continue
    }
    index.push(i)
    if(index.length === d+1) {
      return index
    }
  }
  return index
}

/***/ }),

/***/ "./node_modules/bit-twiddle/twiddle.js":
/*!*********************************************!*\
  !*** ./node_modules/bit-twiddle/twiddle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

 "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}



/***/ }),

/***/ "./node_modules/convex-hull/ch.js":
/*!****************************************!*\
  !*** ./node_modules/convex-hull/ch.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var convexHull1d = __webpack_require__(/*! ./lib/ch1d */ "./node_modules/convex-hull/lib/ch1d.js")
var convexHull2d = __webpack_require__(/*! ./lib/ch2d */ "./node_modules/convex-hull/lib/ch2d.js")
var convexHullnd = __webpack_require__(/*! ./lib/chnd */ "./node_modules/convex-hull/lib/chnd.js")

module.exports = convexHull

function convexHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  } else if(n === 1) {
    return [[0]]
  }
  var d = points[0].length
  if(d === 0) {
    return []
  } else if(d === 1) {
    return convexHull1d(points)
  } else if(d === 2) {
    return convexHull2d(points)
  }
  return convexHullnd(points, d)
}

/***/ }),

/***/ "./node_modules/convex-hull/lib/ch1d.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/ch1d.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHull1d

function convexHull1d(points) {
  var lo = 0
  var hi = 0
  for(var i=1; i<points.length; ++i) {
    if(points[i][0] < points[lo][0]) {
      lo = i
    }
    if(points[i][0] > points[hi][0]) {
      hi = i
    }
  }
  if(lo < hi) {
    return [[lo], [hi]]
  } else if(lo > hi) {
    return [[hi], [lo]]
  } else {
    return [[lo]]
  }
}

/***/ }),

/***/ "./node_modules/convex-hull/lib/ch2d.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/ch2d.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHull2D

var monotoneHull = __webpack_require__(/*! monotone-convex-hull-2d */ "./node_modules/monotone-convex-hull-2d/index.js")

function convexHull2D(points) {
  var hull = monotoneHull(points)
  var h = hull.length
  if(h <= 2) {
    return []
  }
  var edges = new Array(h)
  var a = hull[h-1]
  for(var i=0; i<h; ++i) {
    var b = hull[i]
    edges[i] = [a,b]
    a = b
  }
  return edges
}


/***/ }),

/***/ "./node_modules/convex-hull/lib/chnd.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/chnd.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHullnD

var ich = __webpack_require__(/*! incremental-convex-hull */ "./node_modules/incremental-convex-hull/ich.js")
var aff = __webpack_require__(/*! affine-hull */ "./node_modules/affine-hull/aff.js")

function permute(points, front) {
  var n = points.length
  var npoints = new Array(n)
  for(var i=0; i<front.length; ++i) {
    npoints[i] = points[front[i]]
  }
  var ptr = front.length
  for(var i=0; i<n; ++i) {
    if(front.indexOf(i) < 0) {
      npoints[ptr++] = points[i]
    }
  }
  return npoints
}

function invPermute(cells, front) {
  var nc = cells.length
  var nf = front.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var x = c[j]
      if(x < nf) {
        c[j] = front[x]
      } else {
        x = x - nf
        for(var k=0; k<nf; ++k) {
          if(x >= front[k]) {
            x += 1
          }
        }
        c[j] = x
      }
    }
  }
  return cells
}

function convexHullnD(points, d) {
  try {
    return ich(points, true)
  } catch(e) {
    //If point set is degenerate, try to find a basis and rerun it
    var ah = aff(points)
    if(ah.length <= d) {
      //No basis, no try
      return []
    }
    var npoints = permute(points, ah)
    var nhull   = ich(npoints, true)
    return invPermute(nhull, ah)
  }
}

/***/ }),

/***/ "./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(/*! ./lib/keys.js */ "./node_modules/deep-equal/lib/keys.js");
var isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ "./node_modules/deep-equal/lib/is_arguments.js");

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),

/***/ "./node_modules/deep-equal/lib/is_arguments.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),

/***/ "./node_modules/deep-equal/lib/keys.js":
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/geojson-area/index.js":
/*!********************************************!*\
  !*** ./node_modules/geojson-area/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wgs84 = __webpack_require__(/*! wgs84 */ "./node_modules/wgs84/index.js");

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

/***/ }),

/***/ "./node_modules/geojson-equality/index.js":
/*!************************************************!*\
  !*** ./node_modules/geojson-equality/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//index.js
var deepEqual = __webpack_require__(/*! deep-equal */ "./node_modules/deep-equal/index.js");

var Equality = function(opt) {
  this.precision = opt && opt.precision ? opt.precision : 17;
  this.direction = opt && opt.direction ? opt.direction : false;
  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
};

Equality.prototype.compare = function(g1,g2) {
  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;

  switch(g1.type) {
  case 'Point':
    return this.compareCoord(g1.coordinates, g2.coordinates);
    break;
  case 'LineString':
    return this.compareLine(g1.coordinates, g2.coordinates,0,false);
    break;
  case 'Polygon':
    return this.comparePolygon(g1,g2);
    break;
  case 'Feature':
    return this.compareFeature(g1, g2);
  default:
    if (g1.type.indexOf('Multi') === 0) {
      var context = this;
      var g1s = explode(g1);
      var g2s = explode(g2);
      return g1s.every(function(g1part) {
        return this.some(function(g2part) {
          return context.compare(g1part,g2part);
        });
      },g2s);
    }
  }
  return false;
};

function explode(g) {
  return g.coordinates.map(function(part) {
    return {
      type: g.type.replace('Multi', ''),
      coordinates: part}
  });
}
//compare length of coordinates/array
function sameLength(g1,g2) {
   return g1.hasOwnProperty('coordinates') ?
    g1.coordinates.length === g2.coordinates.length
    : g1.length === g2.length;
}

// compare the two coordinates [x,y]
Equality.prototype.compareCoord = function(c1,c2) {
  if (c1.length !== c2.length) {
    return false;
  }

  for (var i=0; i < c1.length; i++) {
    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
      return false;
    }
  }
  return true;
};

Equality.prototype.compareLine = function(path1,path2,ind,isPoly) {
  if (!sameLength(path1,path2)) return false;
  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
  if (isPoly && !this.compareCoord(p1[0],p2[0])) {
    // fix start index of both to same point
    p2 = this.fixStartIndex(p2,p1);
    if(!p2) return;
  }
  // for linestring ind =0 and for polygon ind =1
  var sameDirection = this.compareCoord(p1[ind],p2[ind]);
  if (this.direction || sameDirection
  ) {
    return this.comparePath(p1, p2);
  } else {
    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])
    ) {
      return this.comparePath(p1.slice().reverse(), p2);
    }
    return false;
  }
};
Equality.prototype.fixStartIndex = function(sourcePath,targetPath) {
  //make sourcePath first point same as of targetPath
  var correctPath,ind = -1;
  for (var i=0; i< sourcePath.length; i++) {
    if(this.compareCoord(sourcePath[i],targetPath[0])) {
      ind = i;
      break;
    }
  }
  if (ind >= 0) {
    correctPath = [].concat(
      sourcePath.slice(ind,sourcePath.length),
      sourcePath.slice(1,ind+1));
  }
  return correctPath;
};
Equality.prototype.comparePath = function (p1,p2) {
  var cont = this;
  return p1.every(function(c,i) {
    return cont.compareCoord(c,this[i]);
  },p2);
};

Equality.prototype.comparePolygon = function(g1,g2) {
  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {
    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);
    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);
    var cont = this;
    return holes1.every(function(h1) {
      return this.some(function(h2) {
        return cont.compareLine(h1,h2,1,true);
      });
    },holes2);
  } else {
    return false;
  }
};

Equality.prototype.compareFeature = function(g1,g2) {
  if (
    g1.id !== g2.id ||
    !this.objectComparator(g1.properties, g2.properties) ||
    !this.compareBBox(g1,g2)
  ) {
    return false;
  }
  return this.compare(g1.geometry, g2.geometry);
};

Equality.prototype.compareBBox = function(g1,g2) {
  if (
    (!g1.bbox && !g2.bbox) || 
    (
      g1.bbox && g2.bbox &&
      this.compareCoord(g1.bbox, g2.bbox)
    )
  )  {
    return true;
  }
  return false;
};
Equality.prototype.removePseudo = function(path) {
  //TODO to be implement
  return path;
};

function objectComparator(obj1, obj2) {
  return deepEqual(obj1, obj2, {strict: true});
}

module.exports = Equality;


/***/ }),

/***/ "./node_modules/geojson-normalize/index.js":
/*!*************************************************!*\
  !*** ./node_modules/geojson-normalize/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = normalize;

var types = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featurecollection'
};

/**
 * Normalize a GeoJSON feature into a FeatureCollection.
 *
 * @param {object} gj geojson data
 * @returns {object} normalized geojson data
 */
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}


/***/ }),

/***/ "./node_modules/geojson-random/index.js":
/*!**********************************************!*\
  !*** ./node_modules/geojson-random/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
    throw new Error('call .point() or .polygon() instead');
};

function position(bbox) {
    if (bbox) return coordInBBBOX(bbox);
    else return [lon(), lat()];
}

module.exports.position = position;

module.exports.point = function(count, bbox) {
    var features = [];
    for (i = 0; i < count; i++) {
        features.push(feature(bbox ? point(position(bbox)) : point()));
    }
    return collection(features);
};

module.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {
    if (typeof num_vertices !== 'number') num_vertices = 10;
    if (typeof max_radial_length !== 'number') max_radial_length = 10;
    var features = [];
    for (i = 0; i < count; i++) {
        var vertices = [],
            circle_offsets = Array.apply(null,
                new Array(num_vertices + 1)).map(Math.random);

        circle_offsets.forEach(sumOffsets);
        circle_offsets.forEach(scaleOffsets);
        vertices[vertices.length - 1] = vertices[0]; // close the ring

        // center the polygon around something
        vertices = vertices.map(vertexToCoordinate(position(bbox)));
        features.push(feature(polygon([vertices])));
    }

    function sumOffsets(cur, index, arr) {
        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;
    }

    function scaleOffsets(cur, index) {
        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
        var radial_scaler = Math.random();
        vertices.push([
            radial_scaler * max_radial_length * Math.sin(cur),
            radial_scaler * max_radial_length * Math.cos(cur)
        ]);
    }

    return collection(features);
};


function vertexToCoordinate(hub) {
    return function(cur, index) { return [cur[0] + hub[0], cur[1] + hub[1]]; };
}

function rnd() { return Math.random() - 0.5; }
function lon() { return rnd() * 360; }
function lat() { return rnd() * 180; }

function point(coordinates) {
    return {
        type: 'Point',
        coordinates: coordinates || [lon(), lat()]
    };
}

function coordInBBBOX(bbox) {
    return [
        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],
        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];
}

function pointInBBBOX() {
    return {
        type: 'Point',
        coordinates: [lon(), lat()]
    };
}

function polygon(coordinates) {
    return {
        type: 'Polygon',
        coordinates: coordinates
    };
}

function feature(geom) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: {}
    };
}

function collection(f) {
    return {
        type: 'FeatureCollection',
        features: f
    };
}


/***/ }),

/***/ "./node_modules/geojson-rbush/index.js":
/*!*********************************************!*\
  !*** ./node_modules/geojson-rbush/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rbush = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
var helpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var meta = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var turfBBox = __webpack_require__(/*! @turf/bbox */ "./node_modules/@turf/bbox/index.js").default;
var featureEach = meta.featureEach;
var coordEach = meta.coordEach;
var polygon = helpers.polygon;
var featureCollection = helpers.featureCollection;

/**
 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
 *
 * @name rbush
 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
 * @returns {RBush} GeoJSON RBush
 * @example
 * var geojsonRbush = require('geojson-rbush').default;
 * var tree = geojsonRbush();
 */
function geojsonRbush(maxEntries) {
    var tree = rbush(maxEntries);
    /**
     * [insert](https://github.com/mourner/rbush#data-format)
     *
     * @param {Feature} feature insert single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     * tree.insert(poly)
     */
    tree.insert = function (feature) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.insert.call(this, feature);
    };

    /**
     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
     *
     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polys = turf.polygons([
     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],
     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
     * ]);
     * tree.load(polys);
     */
    tree.load = function (features) {
        var load = [];
        // Load an Array of Features
        if (Array.isArray(features)) {
            features.forEach(function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        } else {
            // Load a FeatureCollection
            featureEach(features, function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        }
        return rbush.prototype.load.call(this, load);
    };

    /**
     * [remove](https://github.com/mourner/rbush#removing-data)
     *
     * @param {Feature} feature remove single GeoJSON Feature
     * @param {Function} equals Pass a custom equals function to compare by value for removal.
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.remove(poly);
     */
    tree.remove = function (feature, equals) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.remove.call(this, feature, equals);
    };

    /**
     * [clear](https://github.com/mourner/rbush#removing-data)
     *
     * @returns {RBush} GeoJSON Rbush
     * @example
     * tree.clear()
     */
    tree.clear = function () {
        return rbush.prototype.clear.call(this);
    };

    /**
     * [search](https://github.com/mourner/rbush#search)
     *
     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON
     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.search(poly);
     */
    tree.search = function (geojson) {
        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
        return featureCollection(features);
    };

    /**
     * [collides](https://github.com/mourner/rbush#collisions)
     *
     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON
     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.collides(poly);
     */
    tree.collides = function (geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
    };

    /**
     * [all](https://github.com/mourner/rbush#search)
     *
     * @returns {FeatureCollection} all the features in RBush
     * @example
     * tree.all()
     */
    tree.all = function () {
        var features = rbush.prototype.all.call(this);
        return featureCollection(features);
    };

    /**
     * [toJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @returns {any} export data as JSON object
     * @example
     * var exported = tree.toJSON()
     */
    tree.toJSON = function () {
        return rbush.prototype.toJSON.call(this);
    };

    /**
     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @param {any} json import previously exported data
     * @returns {RBush} GeoJSON RBush
     * @example
     * var exported = {
     *   "children": [
     *     {
     *       "type": "Feature",
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [110, 50]
     *       },
     *       "properties": {},
     *       "bbox": [110, 50, 110, 50]
     *     }
     *   ],
     *   "height": 1,
     *   "leaf": true,
     *   "minX": 110,
     *   "minY": 50,
     *   "maxX": 110,
     *   "maxY": 50
     * }
     * tree.fromJSON(exported)
     */
    tree.fromJSON = function (json) {
        return rbush.prototype.fromJSON.call(this, json);
    };

    /**
     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
     *
     * @private
     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from
     * @returns {Object} converted to {minX, minY, maxX, maxY}
     */
    tree.toBBox = function (geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];
        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);
        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);
        else throw new Error('invalid geojson')

        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
}

module.exports = geojsonRbush;
module.exports.default = geojsonRbush;


/***/ }),

/***/ "./node_modules/incremental-convex-hull/ich.js":
/*!*****************************************************!*\
  !*** ./node_modules/incremental-convex-hull/ich.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//High level idea:
// 1. Use Clarkson's incremental construction to find convex hull
// 2. Point location in triangulation by jump and walk

module.exports = incrementalConvexHull

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")
var compareCell = __webpack_require__(/*! simplicial-complex */ "./node_modules/simplicial-complex/topology.js").compareCells

function compareInt(a, b) {
  return a - b
}

function Simplex(vertices, adjacent, boundary) {
  this.vertices = vertices
  this.adjacent = adjacent
  this.boundary = boundary
  this.lastVisited = -1
}

Simplex.prototype.flip = function() {
  var t = this.vertices[0]
  this.vertices[0] = this.vertices[1]
  this.vertices[1] = t
  var u = this.adjacent[0]
  this.adjacent[0] = this.adjacent[1]
  this.adjacent[1] = u
}

function GlueFacet(vertices, cell, index) {
  this.vertices = vertices
  this.cell = cell
  this.index = index
}

function compareGlue(a, b) {
  return compareCell(a.vertices, b.vertices)
}

function bakeOrient(d) {
  var code = ["function orient(){var tuple=this.tuple;return test("]
  for(var i=0; i<=d; ++i) {
    if(i > 0) {
      code.push(",")
    }
    code.push("tuple[", i, "]")
  }
  code.push(")}return orient")
  var proc = new Function("test", code.join(""))
  var test = orient[d+1]
  if(!test) {
    test = orient
  }
  return proc(test)
}

var BAKED = []

function Triangulation(dimension, vertices, simplices) {
  this.dimension = dimension
  this.vertices = vertices
  this.simplices = simplices
  this.interior = simplices.filter(function(c) {
    return !c.boundary
  })

  this.tuple = new Array(dimension+1)
  for(var i=0; i<=dimension; ++i) {
    this.tuple[i] = this.vertices[i]
  }

  var o = BAKED[dimension]
  if(!o) {
    o = BAKED[dimension] = bakeOrient(dimension)
  }
  this.orient = o
}

var proto = Triangulation.prototype

//Degenerate situation where we are on boundary, but coplanar to face
proto.handleBoundaryDegeneracy = function(cell, point) {
  var d = this.dimension
  var n = this.vertices.length - 1
  var tuple = this.tuple
  var verts = this.vertices

  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate
  var toVisit = [ cell ]
  cell.lastVisited = -n
  while(toVisit.length > 0) {
    cell = toVisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited <= -n) {
        continue
      }
      var nv = neighbor.vertices
      for(var j=0; j<=d; ++j) {
        var vv = nv[j]
        if(vv < 0) {
          tuple[j] = point
        } else {
          tuple[j] = verts[vv]
        }
      }
      var o = this.orient()
      if(o > 0) {
        return neighbor
      }
      neighbor.lastVisited = -n
      if(o === 0) {
        toVisit.push(neighbor)
      }
    }
  }
  return null
}

proto.walk = function(point, random) {
  //Alias local properties
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple

  //Compute initial jump cell
  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)
  var cell = this.interior[ initIndex ]

  //Start walking
outerLoop:
  while(!cell.boundary) {
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent

    for(var i=0; i<=d; ++i) {
      tuple[i] = verts[cellVerts[i]]
    }
    cell.lastVisited = n

    //Find farthest adjacent cell
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(neighbor.lastVisited >= n) {
        continue
      }
      var prev = tuple[i]
      tuple[i] = point
      var o = this.orient()
      tuple[i] = prev
      if(o < 0) {
        cell = neighbor
        continue outerLoop
      } else {
        if(!neighbor.boundary) {
          neighbor.lastVisited = n
        } else {
          neighbor.lastVisited = -n
        }
      }
    }
    return
  }

  return cell
}

proto.addPeaks = function(point, cell) {
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple
  var interior = this.interior
  var simplices = this.simplices

  //Walking finished at boundary, time to add peaks
  var tovisit = [ cell ]

  //Stretch initial boundary cell into a peak
  cell.lastVisited = n
  cell.vertices[cell.vertices.indexOf(-1)] = n
  cell.boundary = false
  interior.push(cell)

  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done
  var glueFacets = []

  //Do a traversal of the boundary walking outward from starting peak
  while(tovisit.length > 0) {
    //Pop off peak and walk over adjacent cells
    var cell = tovisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    var indexOfN = cellVerts.indexOf(n)
    if(indexOfN < 0) {
      continue
    }

    for(var i=0; i<=d; ++i) {
      if(i === indexOfN) {
        continue
      }

      //For each boundary neighbor of the cell
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited >= n) {
        continue
      }

      var nv = neighbor.vertices

      //Test if neighbor is a peak
      if(neighbor.lastVisited !== -n) {      
        //Compute orientation of p relative to each boundary peak
        var indexOfNeg1 = 0
        for(var j=0; j<=d; ++j) {
          if(nv[j] < 0) {
            indexOfNeg1 = j
            tuple[j] = point
          } else {
            tuple[j] = verts[nv[j]]
          }
        }
        var o = this.orient()

        //Test if neighbor cell is also a peak
        if(o > 0) {
          nv[indexOfNeg1] = n
          neighbor.boundary = false
          interior.push(neighbor)
          tovisit.push(neighbor)
          neighbor.lastVisited = n
          continue
        } else {
          neighbor.lastVisited = -n
        }
      }

      var na = neighbor.adjacent

      //Otherwise, replace neighbor with new face
      var vverts = cellVerts.slice()
      var vadj = cellAdj.slice()
      var ncell = new Simplex(vverts, vadj, true)
      simplices.push(ncell)

      //Connect to neighbor
      var opposite = na.indexOf(cell)
      if(opposite < 0) {
        continue
      }
      na[opposite] = ncell
      vadj[indexOfN] = neighbor

      //Connect to cell
      vverts[i] = -1
      vadj[i] = cell
      cellAdj[i] = ncell

      //Flip facet
      ncell.flip()

      //Add to glue list
      for(var j=0; j<=d; ++j) {
        var uu = vverts[j]
        if(uu < 0 || uu === n) {
          continue
        }
        var nface = new Array(d-1)
        var nptr = 0
        for(var k=0; k<=d; ++k) {
          var vv = vverts[k]
          if(vv < 0 || k === j) {
            continue
          }
          nface[nptr++] = vv
        }
        glueFacets.push(new GlueFacet(nface, ncell, j))
      }
    }
  }

  //Glue boundary facets together
  glueFacets.sort(compareGlue)

  for(var i=0; i+1<glueFacets.length; i+=2) {
    var a = glueFacets[i]
    var b = glueFacets[i+1]
    var ai = a.index
    var bi = b.index
    if(ai < 0 || bi < 0) {
      continue
    }
    a.cell.adjacent[a.index] = b.cell
    b.cell.adjacent[b.index] = a.cell
  }
}

proto.insert = function(point, random) {
  //Add point
  var verts = this.vertices
  verts.push(point)

  var cell = this.walk(point, random)
  if(!cell) {
    return
  }

  //Alias local properties
  var d = this.dimension
  var tuple = this.tuple

  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary
  for(var i=0; i<=d; ++i) {
    var vv = cell.vertices[i]
    if(vv < 0) {
      tuple[i] = point
    } else {
      tuple[i] = verts[vv]
    }
  }
  var o = this.orient(tuple)
  if(o < 0) {
    return
  } else if(o === 0) {
    cell = this.handleBoundaryDegeneracy(cell, point)
    if(!cell) {
      return
    }
  }

  //Add peaks
  this.addPeaks(point, cell)
}

//Extract all boundary cells
proto.boundary = function() {
  var d = this.dimension
  var boundary = []
  var cells = this.simplices
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.boundary) {
      var bcell = new Array(d)
      var cv = c.vertices
      var ptr = 0
      var parity = 0
      for(var j=0; j<=d; ++j) {
        if(cv[j] >= 0) {
          bcell[ptr++] = cv[j]
        } else {
          parity = j&1
        }
      }
      if(parity === (d&1)) {
        var t = bcell[0]
        bcell[0] = bcell[1]
        bcell[1] = t
      }
      boundary.push(bcell)
    }
  }
  return boundary
}

function incrementalConvexHull(points, randomSearch) {
  var n = points.length
  if(n === 0) {
    throw new Error("Must have at least d+1 points")
  }
  var d = points[0].length
  if(n <= d) {
    throw new Error("Must input at least d+1 points")
  }

  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process
  var initialSimplex = points.slice(0, d+1)

  //Make sure initial simplex is positively oriented
  var o = orient.apply(void 0, initialSimplex)
  if(o === 0) {
    throw new Error("Input not in general position")
  }
  var initialCoords = new Array(d+1)
  for(var i=0; i<=d; ++i) {
    initialCoords[i] = i
  }
  if(o < 0) {
    initialCoords[0] = 1
    initialCoords[1] = 0
  }

  //Create initial topological index, glue pointers together (kind of messy)
  var initialCell = new Simplex(initialCoords, new Array(d+1), false)
  var boundary = initialCell.adjacent
  var list = new Array(d+2)
  for(var i=0; i<=d; ++i) {
    var verts = initialCoords.slice()
    for(var j=0; j<=d; ++j) {
      if(j === i) {
        verts[j] = -1
      }
    }
    var t = verts[0]
    verts[0] = verts[1]
    verts[1] = t
    var cell = new Simplex(verts, new Array(d+1), true)
    boundary[i] = cell
    list[i] = cell
  }
  list[d+1] = initialCell
  for(var i=0; i<=d; ++i) {
    var verts = boundary[i].vertices
    var adj = boundary[i].adjacent
    for(var j=0; j<=d; ++j) {
      var v = verts[j]
      if(v < 0) {
        adj[j] = initialCell
        continue
      }
      for(var k=0; k<=d; ++k) {
        if(boundary[k].vertices.indexOf(v) < 0) {
          adj[j] = boundary[k]
        }
      }
    }
  }

  //Initialize triangles
  var triangles = new Triangulation(d, initialSimplex, list)

  //Insert remaining points
  var useRandom = !!randomSearch
  for(var i=d+1; i<n; ++i) {
    triangles.insert(points[i], useRandom)
  }
  
  //Extract boundary cells
  return triangles.boundary()
}

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.4.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2019-05-01T21:04Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var document = window.document;

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};




	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.4.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android <=4.0 only
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a global context
	globalEval: function( code, options ) {
		DOMEval( code, { nonce: options && options.nonce } );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android <=4.0 only
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.4
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2019-04-08
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\0-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" + ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) &&

				// Support: IE 8 only
				// Exclude object elements
				(nodeType !== 1 || context.nodeName.toLowerCase() !== "object") ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 && rdescend.test( selector ) ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rcssescape, fcssescape );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[i] = "#" + nid + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement("fieldset");

	try {
		return !!fn( el );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}
		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
						inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = (elem.ownerDocument || elem).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( preferredDoc !== document &&
		(subWindow = document.defaultView) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( el ) {
		el.className = "i";
		return !el.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( el ) {
		el.appendChild( document.createComment("") );
		return !el.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID filter and find
	if ( support.getById ) {
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode("id");
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( (elem = elems[i++]) ) {
						node = elem.getAttributeNode("id");
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( el ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll(":enabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll(":disabled").length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( el ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return (sel + "").replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( (oldCache = uniqueCache[ key ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( el ) {
	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement("fieldset") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( el ) {
	return el.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( typeof elem.contentDocument !== "undefined" ) {
			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};




function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE <=9 only
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE <=9 only
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		// Make a writable jQuery.Event from the native event object
		var event = jQuery.event.fix( nativeEvent );

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	/* eslint-disable max-len */

	// See https://github.com/eslint/eslint/issues/3229
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([a-z][^\/\0>\x20\t\r\n\f]*)[^>]*)\/>/gi,

	/* eslint-enable */

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								} );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Fall back to offsetWidth/offsetHeight when value is "auto"
	// This happens for inline elements with no explicit setting (gh-3571)
	// Support: Android <=4.1 - 4.3 only
	// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
	// Support: IE 9-11 only
	// Also use offsetWidth/offsetHeight for when box sizing is unreliable
	// We use getClientRects() to check for hidden/disconnected.
	// In those cases, the computed value can be trusted to be border-box
	if ( ( !support.boxSizingReliable() && isBorderBox ||
		val === "auto" ||
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = Date.now();

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce++ ) + uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url, options ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	}
} );

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){ true?e(exports):undefined}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.message=t}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;e>n;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;o>n;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;2>t;t++)for(var e=0;3>e;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){}function ci(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function fi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function gi(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];gi.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function di(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function pi(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function vi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function mi(){this._isMarked=!1;var t=arguments[0];vi.call(this,t)}function yi(){this.vertexMap=new te}function xi(){this._isStart=!1;var t=arguments[0];mi.call(this,t)}function Ei(){yi.apply(this)}function Ii(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Ei}function Ni(){this.items=new I,this.subnode=new Array(4).fill(null)}function Ci(){}function Si(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=0>e||0>1/e,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;1>r&&i>0;)i--,r*=2;0>=i&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function wi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Li(){Ni.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function Ri(){}function Ti(){Ni.apply(this)}function Pi(){this.root=null,this.minExtent=1,this.root=new Ti}function bi(t){this.geometryFactory=t||new ie}function Oi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new bi(this.geometryFactory)}function _i(){this.parser=new bi(this.geometryFactory)}function Mi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Di(t){return[t.x,t.y]}function Ai(t){this.geometryFactory=t||new ie}function Fi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Fi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Gi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function qi(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Bi(){if(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Bi.CAP_ROUND,this.joinStyle=Bi.JOIN_ROUND,this.mitreLimit=Bi.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Bi.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Vi(){this.array_=[]}function ki(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new zi}function Yi(){this.inputLine=null,
this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function Ui(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function Xi(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Bi.JOIN_ROUND&&(this.closingSegLengthFactor=Xi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function Hi(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function Wi(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function ji(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function Ki(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function Zi(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function Qi(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function Ji(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function $i(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,0>=e)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function tr(){this.tempEnv1=new C,this.selectedSegment=new ce}function er(){this.index=null;var t=arguments[0];this.index=t}function nr(){tr.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function ir(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function rr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function sr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Bi,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function or(){this.comps=null;var t=arguments[0];this.comps=t}function ar(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];ar.call(this,t,ar.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function ur(){this.pts=null;var t=arguments[0];this.pts=t}function lr(){this.locations=null;var t=arguments[0];this.locations=t}function hr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];hr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function cr(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function fr(){this._isMarked=!1,this._isVisited=!1,this.data=null}function gr(){fr.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function dr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function pr(){if(fr.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function vr(){this.outEdges=new I,this.sorted=!1}function mr(){if(fr.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];mr.call(this,t,new vr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function yr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function xr(){this.nodeMap=new rt}function Er(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new xr}function Ir(){Er.apply(this)}function Nr(){this.graph=new Ir,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function Cr(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function Sr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function wr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Lr(){}function Rr(){Er.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function Tr(){if(this.lineStringAdder=new Pr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)Tr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function Pr(){this.p=null;var t=arguments[0];this.p=t}function br(){}function Or(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];Or.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function _r(){Pn.apply(this)}function Mr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Dr(){Nn.apply(this)}function Ar(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Dr),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Fr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Gr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function qr(){this._isDone=!1}function Br(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function zr(){qr.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function Vr(){qr.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function kr(){qr.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Gr(this.rectEnv)}function Yr(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Ar(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Ar(this.arg)}}function Ur(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=Ur.extractFactory(t),this.inputGeoms=t}function Xr(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function Hr(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function Wr(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function jr(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function Kr(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function Zr(){this.items=new I,this.subnode=[null,null]}function Qr(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function Jr(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function $r(){Zr.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function ts(){Zr.apply(this)}function es(){this.root=null,this.minExtent=1,this.root=new ts}function ns(){}function is(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new Qr;var t=arguments[0];this.ring=t,this.buildIndex()}function rs(){tr.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function ss(){this.nodes=new xn(new Dr)}function os(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new ss,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function as(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function us(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];us.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function ls(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Pi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}Array.prototype.fill||(Array.prototype.fill=function(t){for(var e=Object(this),n=parseInt(e.length,10),i=arguments[1],r=parseInt(i,10)||0,s=0>r?Math.max(n+r,0):Math.min(r,n),o=arguments[2],a=void 0===o?n:parseInt(o,10)||0,u=0>a?Math.max(n+a,0):Math.min(a,n);u>s;s++)e[s]=t;return e}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return 0>t?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x!==t.x?!1:this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return n.equalsWithTolerance(this.x,e.x,i)?!!n.equalsWithTolerance(this.y,e.y,i):!1}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g?this.equals2D(t):!1},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(t){if(t instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return e>t?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return this.array_.push(t),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(0>t||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;i>n;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){throw new E},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function t(){for(var t=I.prototype.clone.call(this),e=0;e<this.size();e++)t.add(e,this.get(e).copy());return t},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(v>f){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return this.isNull()||e.isNull()?!1:e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.isNull()||t.isNull()?!1:!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return e>t?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];s>r?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),a>o?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return l>u?!1:a>h?!1:(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),l>u?!1:!(a>h))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return r>e&&(r=e),r>n&&(r=n),r>i&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return e>t?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return r>i?r:i>s?s:i}},T.wrap=function(t,e){return 0>t?e- -t%e:t%e},T.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){
return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){return this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return 32>=t&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;a>=u;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(0>l)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(0>g&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return 0>t?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _(-this.hi,-this.lo)},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&20>=t?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(0>i)r="0."+_.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(n>e){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):e}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var f=s,g=o-a-u;if(0===g)f=s;else if(g>0){var d=_.TEN.pow(g);f=s.divide(d)}else if(0>g){var d=_.TEN.pow(-g);f=s.multiply(d)}return i?f.negate():f},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return e>=10*r&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;e>i;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(1>=i)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(0>=s)return M.signum(o);i=r+s}else{if(!(0>r))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:0>t?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;e+r>o;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null===t?!1:this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null===t?!1:this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return t.length<4?!1:!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(0>n)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,!1);return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;n>=i;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;a>n;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;0>n&&(i=0),e>=t.length&&(i=0),e>n&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;n>=o;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return this.contains(t)?!1:(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(0>n)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),0>i)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return 0>i?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;i>n;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;o>u&&a>u;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return o>u?1:a>u?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){
return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;e>i;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;r>u;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(t){if(!(t instanceof Et))throw t;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;r>s;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e?!0:3>=e?!1:t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y)},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;n>o;o++)for(var a=0;s>a;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;n>s;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;n>=i;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;r>s;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;e>r;r++){r>0&&i.append(" ");for(var s=0;n>s;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(3>=n)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;n>s;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return this.isEmpty()?!1:this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?this.isEmpty()&&t.isEmpty()?!0:this.isEmpty()!==t.isEmpty()?!1:this.equal(t.getCoordinate(),this.getCoordinate(),e):!1}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;5>n;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;4>=n;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;a>l&&u>l;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return a>l?1:u>l?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return this.isEmpty()?!0:St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){if(t instanceof bt)return e.createLinearRing(this.editCoordinates(t.getCoordinates(),t));if(t instanceof St)return e.createLineString(this.editCoordinates(t.getCoordinates(),t));if(t instanceof Lt){var n=this.editCoordinates(t.getCoordinates(),t);return n.length>0?e.createPoint(n[0]):e.createPoint()}return t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),2>i?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({delete:kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(-1!==t.search("EMPTY")&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t)},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){
return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;u>a;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;r>i;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return this.isInteriorIntersection(0)?!0:!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=c>a?a:c,p=o>h?o:h,v=f>u?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||0>r&&0>s)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||0>o&&0>a)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return s>o&&(s=o,r=e),o=he.distancePointLine(n,t,e),s>o&&(s=o,r=n),o=he.distancePointLine(i,t,e),s>o&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?i>=e||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):-i>=e?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):i>0?i>=-e?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),t>0){if(!(n>0))return r;if(!(n>=t))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,0>i)return-r;if(i>e)return r;if(t>n+n){if(i+i>e)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,0>e)return r;if(e>i)return-r;if(n>t+t){if(e+e>i)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;s>a&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(3>u)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;u-1>i;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(0>l||l>1||0>u||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(1>=e)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;e>o;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(3>e)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;e>=s;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,0>a&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);n>s&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(0>=h)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):0>=e&&0>=n?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(0>=r&&0>=s)return null;var o=this.project(i.p0);0>r&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return 0>s&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(0>=i)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),i>s&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),i>s&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),i>s&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&1>e)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return i>n?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(t){if(!(t instanceof w))throw t}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(0>=o)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return 0>e?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L?this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])):!1},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):!1},isEquals:function(t,e){return t!==e?!1:fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},toString:function(){for(var t=new P("123456789"),e=0;3>e;e++)for(var n=0;3>n;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;3>e;e++)for(var n=0;3>n;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?0===this.matrix[L.INTERIOR][L.INTERIOR]:!1},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE?!0:e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)?!0:e===lt.SYM_FALSE&&t===lt.FALSE?!0:e===lt.SYM_P&&t===lt.P?!0:e===lt.SYM_L&&t===lt.L?!0:e===lt.SYM_A&&t===lt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(0>t||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i])}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates()},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);
if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return l>u?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&4>i&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;n>i;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;n>i;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&n>o&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return t.length<=1?!1:t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,!0),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);e>i&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;s>r;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function t(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var e=arguments[0],t=0,n=e.getChildBoundables().iterator();n.hasNext();){var i=n.next();i instanceof Ge?t+=this.size(i):i instanceof Me&&(t+=1)}return t}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n?(t.getChildBoundables().remove(n),!0):!1},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),-1===n&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),this.getIntersectsOp().intersects(this.root.getBounds(),t)?this.remove(t,this.root,e):!1}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:e>t?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;e>s;s++){i[s]=new I;for(var o=0;r.hasNext()&&n>o;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return e>t?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return 0>t?-1:t>0?1:0>e?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0!==this.segmentIndex||this._isInterior?this.segmentIndex===t:!0},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i?(n[0]=t.segmentIndex+1,!0):!1},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);
o>e&&this.computeSelect(t,e,o,i),n>o&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);h>t&&(c>i&&this.computeOverlapsInternal(t,h,n,i,c,s),r>c&&this.computeOverlapsInternal(t,h,n,c,r,s)),e>h&&(c>i&&this.computeOverlapsInternal(h,e,n,i,c,s),r>c&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=e>t?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e?!0:e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return this.findAllIntersections?!1:null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;return t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection()?(this._isValid=!1,null):void 0},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;2>e;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;2>n;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;2>n;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(-999!==this.depth[t]&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function t(){for(var t=!0,e=0;2>e;e++)this.label.isArea(e)&&this.label.getLocation(e,cn.LEFT)===L.INTERIOR&&this.label.getLocation(e,cn.RIGHT)===L.INTERIOR||(t=!1);return t},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return t.equals(n)?he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i):!1},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,!0),r=new In(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(1>=e,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?he.isPointInRing(t,e.getCoordinates()):!1},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();
f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(1>e)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;a>h;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;2>s;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null===this.label?!1:this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null===e?!1:this.isBoundaryPointInternal(t,e[0])?!0:!!this.isBoundaryPointInternal(t,e[1])},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;e>s;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return s>r?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist?!0:this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return n>e?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);d>r&&(p>a&&this.computeIntersectsForChain(r,d,o,a,p,l),u>p&&this.computeIntersectsForChain(r,d,o,p,u,l)),s>d&&(p>a&&this.computeIntersectsForChain(d,s,o,a,p,l),u>p&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;2>t;t++)for(var e=0;3>e;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;2>t;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),0>e&&(e=0);for(var n=1;3>n;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;2>e;e++)for(var n=1;3>n;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return this.label.isArea()?3!==this.pts.length?!1:!!this.pts[0].equals(this.pts[2]):!1},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,!0,!1);s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return this.isCovered(t,this.resultLineList)?!0:!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),
this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;2>r;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(t){if(!(t instanceof l))throw t;i=t}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(t){throw t instanceof l?i:t}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function t(){if(arguments[0]instanceof ft){var e=arguments[0];if(e.isEmpty())return e;for(var t=e.getGeometryN(0),n=1;n<e.getNumGeometries();n++)e.getGeometryN(n).getEnvelopeInternal().getWidth()>t.getEnvelopeInternal().getWidth()&&(t=e.getGeometryN(n));return t}if(arguments[0]instanceof B){var i=arguments[0];return i instanceof ft?this.widestGeometry(i):i}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{interfaces_:function(){return[]},getClass:function(){return hi}}),hi.toDegrees=function(t){return 180*t/Math.PI},hi.normalize=function(t){for(;t>Math.PI;)t-=hi.PI_TIMES_2;for(;t<=-Math.PI;)t+=hi.PI_TIMES_2;return t},hi.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},hi.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},hi.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return 0>a},hi.interiorAngle=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return Math.abs(r-i)},hi.normalizePositive=function(t){if(0>t){for(;0>t;)t+=hi.PI_TIMES_2;t>=hi.PI_TIMES_2&&(t=0)}else{for(;t>=hi.PI_TIMES_2;)t-=hi.PI_TIMES_2;0>t&&(t=0)}return t},hi.angleBetween=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return hi.diff(i,r)},hi.diff=function(t,e){var n=null;return n=e>t?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},hi.toRadians=function(t){return t*Math.PI/180},hi.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?hi.COUNTERCLOCKWISE:0>n?hi.CLOCKWISE:hi.NONE},hi.angleBetweenOriented=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n),s=r-i;return s<=-Math.PI?s+hi.PI_TIMES_2:s>Math.PI?s-hi.PI_TIMES_2:s},hi.PI_TIMES_2=2*Math.PI,hi.PI_OVER_2=Math.PI/2,hi.PI_OVER_4=Math.PI/4,hi.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,hi.CLOCKWISE=he.CLOCKWISE,hi.NONE=he.COLLINEAR,e(ci.prototype,{area:function(){return ci.area(this.p0,this.p1,this.p2)},signedArea:function(){return ci.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return ci.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return ci.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return ci.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return ci.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return ci.area3D(this.p0,this.p1,this.p2)},centroid:function(){return ci.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return ci.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},ci.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},ci.det=function(t,e,n,i){return t*i-e*n},ci.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},ci.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},ci.isAcute=function(t,e,n){return hi.isAcute(t,e,n)&&hi.isAcute(e,n,t)?!!hi.isAcute(n,t,e):!1},ci.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*ci.det(s,o,a,u),h=ci.det(o,s*s+o*o,u,a*a+u*u),c=ci.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},ci.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},ci.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},ci.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},ci.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},ci.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(fi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=fi.lowestPoint(t),r=fi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=fi.pointWithMinAngleWithSegment(t,i,r);if(hi.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(hi.isObtuse(o,i,r))i=o;else{if(!hi.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=ci.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return fi}}),fi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;0>u&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;n>h&&(n=h,i=o)}}return i},fi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},fi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=hi.angleBetween(e,a,n);i>u&&(i=u,s=a)}}return s},e(gi.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=gi.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=gi.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),n>u&&(n=u);var l=gi.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),s>l&&(s=l)}var h=gi.computeSegmentForLine(-t,-e,o),c=gi.computeSegmentForLine(-t,-e,s),f=gi.computeSegmentForLine(-e,t,i),g=gi.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return gi}}),gi.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},gi.computeC=function(t,e,n){return t*n.y-e*n.x},gi.getMinimumDiameter=function(t){return new gi(t).getDiameter()},gi.getMinimumRectangle=function(t){return new gi(t).getMinimumRectangle()},gi.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MinimumBoundingCircle:fi,MinimumDiameter:gi});e(di.prototype,{getResultGeometry:function(){return new pi(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>=t)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return di}}),di.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;a>l;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},di.densify=function(t,e){var n=new di(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(pi,xe),e(pi.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=di.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return pi}}),di.DensifyTransformer=pi;var fo=Object.freeze({Densifier:di});e(vi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function t(){var t=0,e=this;do t++,e=e.oNext();while(e!==this);return t},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:o>s?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},vi.create=function(t,e){var n=new vi(t),i=new vi(e);return n.init(i),n},h(mi,vi),e(mi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return mi}}),mi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},mi.isMarked=function(t){return t.isMarked()},mi.setMark=function(t,e){t.setMark(e)},mi.markBoth=function(t){t.mark(),t.sym().mark()},mi.mark=function(t){t.mark()},e(yi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return vi.init(n,i),n},createEdge:function(t){return new vi(t)},addEdge:function(t,e){if(!yi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(xi,mi),e(xi.prototype,{setStart:function(){this._isStart=!0},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return xi}}),h(Ei,yi),e(Ei.prototype,{createEdge:function(t){return new xi(t)},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,mi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,mi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do mi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();mi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();mi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Ii}}),Ii.dissolve=function(t){var e=new Ii;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Ii});e(Ni.prototype,{hasChildren:function(){for(var t=0;4>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;4>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;4>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;4>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function t(){var t=!0;this.items.isEmpty()||(t=!1);for(var e=0;4>e;e++)null!==this.subnode[e]&&(this.subnode[e].isEmpty()||(t=!1));return t},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ni}}),Ni.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},Ci.exponent=function(t){return Si(64,t)-1023},Ci.powerOf2=function(t){return Math.pow(2,t)},e(wi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=wi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=Ci.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=Ci.exponent(i)+1;return r},h(Li,Ni),e(Li.prototype,{find:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Li(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ni.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.createNode=function(t){var e=new wi(t),n=new Li(e.getEnvelope(),e.getLevel());return n},Li.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Li.createNode(n);return null!==t&&i.insertNode(t),i},e(Ri.prototype,{interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=Ci.exponent(r);return s<=Ri.MIN_BINARY_EXPONENT},Ri.MIN_BINARY_EXPONENT=-50,h(Ti,Ni),e(Ti.prototype,{insert:function(t,e){var n=Ni.getSubnodeIndex(t,Ti.origin.x,Ti.origin.y);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Li.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=Ri.isZeroWidth(e.getMinX(),e.getMaxX()),r=Ri.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ti.origin=new g(0,0),e(Pi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Pi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),
t},remove:function(t,e){var n=Pi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Pi}}),Pi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Pi.serialVersionUID=-0x678b60c967a25400;var po=Object.freeze({Quadtree:Pi}),vo=Object.freeze({STRtree:ke}),mo=Object.freeze({quadtree:po,strtree:vo}),yo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(bi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!xo[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==yo.indexOf(n)?xo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?xo[n].apply(this,[e.geometries]):xo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Eo[e])throw new Error("Geometry is not supported");return Eo[e].apply(this,[t])}});var xo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!xo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=xo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function t(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];t.push(new g(i[0],i[1]))}return t},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=xo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=xo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=xo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(xo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Eo={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Eo.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Eo.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Eo.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Eo.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Eo[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Oi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;n>e;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;n>e;e++)this.reducePrecision(t.geometries[e])}}),e(_i.prototype,{write:function(t){return this.parser.write(t)}}),e(Mi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;n>e;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;r>i;i++)this.reducePrecision(t.geometries[i])}}),e(Ai.prototype,{read:function(t){return t instanceof ol.geom.Point?this.convertFromPoint(t):t instanceof ol.geom.LineString?this.convertFromLineString(t):t instanceof ol.geom.LinearRing?this.convertFromLinearRing(t):t instanceof ol.geom.Polygon?this.convertFromPolygon(t):t instanceof ol.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof ol.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof ol.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof ol.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Di)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Di));return new ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new ol.geom.MultiPoint(t.getCoordinates().map(Di))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new ol.geom.GeometryCollection(e)}});var Io=Object.freeze({GeoJSONReader:Oi,GeoJSONWriter:_i,OL3Parser:Ai,WKTReader:Mi,WKTWriter:se});e(Fi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Fi}});var No=Object.freeze({MCIndexNoder:nn,ScaledNoder:Fi,SegmentString:be});e(Gi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return i.hasIntersection()?i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):this.hasNonEndpointIntersection(e)?!1:!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e):!0},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new qi(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,t.isEmpty()?!0:t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):t instanceof ft?this.isSimpleGeometryCollection(t):!0},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Gi}}),e(qi.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return qi}}),Gi.EndpointInfo=qi,e(Bi.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Bi.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Bi.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),0>=t&&(this.quadrantSegments=1),this.joinStyle!==Bi.JOIN_ROUND&&(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=0>t?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Bi}}),Bi.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Bi.CAP_ROUND=1,Bi.CAP_FLAT=2,Bi.CAP_SQUARE=3,Bi.JOIN_ROUND=1,Bi.JOIN_MITRE=2,Bi.JOIN_BEVEL=3,Bi.DEFAULT_QUADRANT_SEGMENTS=8,Bi.DEFAULT_MITRE_LIMIT=5,Bi.DEFAULT_SIMPLIFY_FACTOR=.01,e(zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return 0>n&&(n=this.getRightmostSideOfSegment(t,e-1)),0>n&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(0>e||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return zi}}),Vi.prototype.addLast=function(t){this.array_.push(t)},Vi.prototype.removeFirst=function(){return this.array_.shift()},Vi.prototype.isEmpty=function(){return 0===this.array_.length},e(ki.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Vi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return ki}}),e(Yi.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return this.isConcave(r,s,o)&&this.isShallow(r,s,o,i)?this.isShallowSampled(r,s,t,n,i):!1},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=Yi.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return i>o},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/Yi.NUM_PTS_TO_CHECK);0>=s&&(s=1);for(var o=n;i>o;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function t(e,n,i){var r=he.computeOrientation(e,n,i),t=r===this.angleOrientation;return t},simplify:function(t){this.distanceTol=Math.abs(t),0>t&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===Yi.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return i>r},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==Yi.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return Yi}}),Yi.simplify=function(t,e){var n=new Yi(t);return n.simplify(e)},Yi.INIT=0,Yi.DELETE=1,Yi.KEEP=1,Yi.NUM_PTS_TO_CHECK=10,e(Ui.prototype,{getCoordinates:function(){var t=this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return Ui}}),Ui.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(Xi.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Bi.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Bi.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=0>=i?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof w))throw t;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?h>=a&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1)},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=hi.angle(r,this.seg0.p0),o=(hi.angle(r,this.seg1.p1),hi.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=hi.normalize(s+a),l=hi.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(1>a)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;o>h;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new Ui,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL||this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return Xi}}),Xi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,Xi.MAX_CLOSING_SEG_LEN_FACTOR=80,e(Hi.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=0>e,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=Yi.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;s>=o;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=Yi.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;r>=s;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=Yi.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:e.createCircle(t);break;case Bi.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,0>e&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=0>e;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Hi.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new Xi(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return Hi}}),Hi.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(Wi.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new ji(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return ji}}),Wi.DepthSegment=ji,e(Ki.prototype,{addPoint:function(t){if(this.distance<=0)return null;
var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new ci(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return 0>e;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return 0>e&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return Ki}}),e(Zi.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(Zi.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return Zi}}),Zi.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(Qi.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=Qi.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(Qi.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new Wi(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new ki;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new Zi(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new Hi(n,this.bufParams),r=new Ki(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return Qi}}),Qi.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},Qi.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(Ji.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+Ji.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return Ji}}),Ji.fact=new ie,e($i.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=$i.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.isProper()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.isProper()?!0:(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.isProper()?!0:(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),this.li.isProper()?!0:n&&i?!0:t.equals(this.pt)?!0:!!e.equals(this.pt))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return this.intersects(n,i)?(t.addIntersection(this.getCoordinate(),e),!0):!1},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.SAFE_ENV_EXPANSION_FACTOR=.75,e(tr.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return tr}}),e(er.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new nr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return er}}),h(nr,tr),e(nr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return nr}}),er.HotPixelSnapAction=nr,e(ir.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return ir}}),e(rr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new Ji(e);try{n.checkValid()}catch(t){if(!(t instanceof S))throw t;t.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new ir(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new $i(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new er(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new $i(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return rr}}),e(sr.prototype,{bufferFixedPrecision:function(t){var e=new Fi(new rr(new ee(1)),t.getScale()),n=new Qi(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=sr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof sn))throw t;this.saveException=t}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var e=arguments[0],n=sr.precisionScaleFactor(this.argGeom,this.distance,e),i=new ee(n);this.bufferFixedPrecision(i)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new Qi(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(t){if(!(t instanceof l))throw t;this.saveException=t}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return sr}}),sr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new sr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new sr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Bi&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new sr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new sr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},sr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},sr.CAP_ROUND=Bi.CAP_ROUND,sr.CAP_BUTT=Bi.CAP_FLAT,sr.CAP_FLAT=Bi.CAP_FLAT,sr.CAP_SQUARE=Bi.CAP_SQUARE,sr.MAX_PRECISION_DIGITS=12;var Co=Object.freeze({BufferOp:sr,BufferParameters:Bi});e(or.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return or}}),or.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return or.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new or(n)),n}},e(ar.prototype,{isInsideArea:function(){return this.segIndex===ar.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.INSIDE_AREA=-1,e(ur.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return ur}}),ur.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):ur.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new ur(n)),n}},e(lr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new ar(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return lr}}),lr.getLocations=function(t){var e=new I;return t.apply(new lr(e)),e},e(hr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=or.getPolygons(this.geom[e]);if(r.size()>0){var s=lr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof ar&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new ar(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=ur.getPoints(this.geom[0]),r=ur.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new ar(t,s,u),n[1]=new ar(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new ar(l,s,v[0]),c[1]=new ar(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new ar(r,0,r.getCoordinate()),n[1]=new ar(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return hr}}),hr.distance=function(t,e){var n=new hr(t,e);return n.distance()},hr.isWithinDistance=function(t,e,n){var i=new hr(t,e,n);return i.distance()<=n},hr.nearestPoints=function(t,e){var n=new hr(t,e);return n.nearestPoints()};var So=Object.freeze({DistanceOp:hr});e(cr.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return cr}}),e(fr.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return fr}}),fr.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},fr.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},fr.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(gr,fr),e(gr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return gr}}),gr.toEdges=function(t){for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(dr,gr),e(dr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return dr}}),h(pr,fr),e(pr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof mr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return pr}}),e(vr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof gr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return 0>s&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return vr}}),h(mr,fr),e(mr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return mr}}),mr.getEdgesBetween=function(t,e){var n=gr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=gr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(yr,pr),e(yr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return yr}}),e(xr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return xr}}),e(Er.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof gr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof mr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof pr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof gr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof mr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof pr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof gr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Er}}),h(Ir,Er),e(Ir.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new dr(r,s,e[1],!0),a=new dr(s,r,e[e.length-2],!1),u=new yr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return Ir}}),e(Nr.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;fr.setMarked(this.graph.nodeIterator(),!1),fr.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new cr(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){
var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Nr}});var wo=Object.freeze({LineMerger:Nr}),Lo=Object.freeze({OverlayOp:ii});h(Cr,gr),e(Cr.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,pr),e(Sr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();wr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),this.ringPts.length<=3?!1:(this.getRing(),this.ring.isValid())},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return this._isHole?!this.hasShell():!1},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof wr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return wr}}),wr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},wr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},wr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Lr.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Lr}}),wr.EnvelopeComparator=Lr,h(Rr,Er),e(Rr.prototype,{findEdgeRing:function(t){var e=new wr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Rr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],!0),a=new Cr(s,r,e[e.length-2],!1),u=new Sr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Rr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Rr.label(this.dirEdges,-1);var t=Rr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Rr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Rr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Rr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Rr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Rr}}),Rr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=wr.findDirEdgesInRing(r);Rr.label(s,n),n++}}return e},Rr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Rr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Rr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Rr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Rr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Rr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Rr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Rr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(Tr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new wr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(Tr.findDisjointShells(this.shellList),n=!1),this.polyList=Tr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Rr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return Tr}}),Tr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},Tr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},Tr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();Tr.assignHoleToShell(i,e)}},Tr.assignHoleToShell=function(t,e){var n=wr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},Tr.findDisjointShells=function(t){Tr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(Pr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return Pr}}),Tr.LineStringAdder=Pr;var Ro=Object.freeze({Polygonizer:Tr});e(br.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return br}}),h(Or,En),e(Or.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;2>r;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return Or}}),h(_r,Pn),e(_r.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new Or(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,yn),e(Mr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return Mr}}),h(Dr,Nn),e(Dr.prototype,{createNode:function(t){return new Mr(t,new _r)},interfaces_:function(){return[]},getClass:function(){return Dr}}),e(Ar.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new br,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Ar}}),e(Fr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return this.rectEnv.contains(t.getEnvelopeInternal())?!this.isContainedInBoundary(t):!1},interfaces_:function(){return[]},getClass:function(){return Fr}}),Fr.contains=function(t,e){var n=new Fr(t);return n.contains(e)},e(Gr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Gr}}),e(qr.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return qr}}),e(Br.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new zr(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new Vr(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new kr(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return Br}}),Br.intersects=function(t,e){var n=new Br(t);return n.intersects(e)},h(zr,qr),e(zr.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return zr}}),h(Vr,qr),e(Vr.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;4>i;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return Vr}}),h(kr,qr),e(kr.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return kr}}),h(Yr,ti),e(Yr.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return Yr}}),Yr.covers=function(t,e){return t.getEnvelopeInternal().covers(e.getEnvelopeInternal())?t.isRectangle()?!0:Yr.relate(t,e).isCovers():!1},Yr.intersects=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?t.isRectangle()?Br.intersects(t,e):e.isRectangle()?Br.intersects(e,t):Yr.relate(t,e).isIntersects():!1},Yr.touches=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isTouches(t.getDimension(),e.getDimension()):!1},Yr.within=function(t,e){return e.contains(t)},Yr.coveredBy=function(t,e){return Yr.covers(e,t)},Yr.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yr(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return Yr.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new Yr(a,u,l),i=n.getIntersectionMatrix();return i}}},Yr.overlaps=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isOverlaps(t.getDimension(),e.getDimension()):!1},Yr.disjoint=function(t,e){return!t.intersects(e)},Yr.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Yr.relate(t,e)},Yr.crosses=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isCrosses(t.getDimension(),e.getDimension()):!1},Yr.contains=function(t,e){return t.getEnvelopeInternal().contains(e.getEnvelopeInternal())?t.isRectangle()?Fr.contains(t,e):Yr.relate(t,e).isContains():!1};var To=Object.freeze({RelateOp:Yr});e(Ur.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return Ur}}),Ur.combine=function(){if(1===arguments.length){var t=arguments[0],e=new Ur(t);return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new Ur(Ur.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new Ur(Ur.createList(r,s,o));return e.combine()}},Ur.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Ur.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(Xr.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),Ur.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.union=function(t,e){var n=new Xr(t,e);return n.union()},e(Hr.prototype,{filter:function(t){-1!==this.sortIndex&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return Hr}}),Hr.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Hr.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new Hr(i,r)),r}},e(Wr.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=Ur.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(Wr.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(1>=i-n){var r=Wr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(Wr.getGeometry(e,n),Wr.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return Wr.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=Ur.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return Wr}}),Wr.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=or.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},Wr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Wr.union=function(t){var e=new Wr(t);return e.union()},Wr.STRTREE_NODE_CAPACITY=4,e(jr.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),Hr.extract(i,B.SORTINDEX_POLYGON,this.polygons),Hr.extract(i,B.SORTINDEX_LINESTRING,this.lines),Hr.extract(i,B.SORTINDEX_POINT,this.points)}},union:function t(){if(null===this.geomFact)return null;var e=null;if(this.points.size()>0){var n=this.geomFact.buildGeometry(this.points);e=this.unionNoOpt(n)}var i=null;if(this.lines.size()>0){var r=this.geomFact.buildGeometry(this.lines);i=this.unionNoOpt(r)}var s=null;this.polygons.size()>0&&(s=Wr.union(this.polygons));var o=this.unionWithNull(i,s),t=null;return t=null===e?o:null===o?e:Xr.union(e,o),null===t?this.geomFact.createGeometryCollection():t},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new jr(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new jr(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new jr(i,r);return e.union()}};var Po=Object.freeze({UnaryUnionOp:jr});e(Kr.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=Kr.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),
!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return Kr}}),Kr.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(Zr.prototype,{hasChildren:function(){for(var t=0;2>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;2>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;2>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;2>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return Zr}}),Zr.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(Qr.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof Qr){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return Qr}}),e(Jr.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=Jr.computeLevel(t),this.interval=new Qr,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=Ci.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Jr}}),Jr.computeLevel=function(t){var e=t.getWidth(),n=Ci.exponent(e)+1;return n},h($r,Zr),e($r.prototype,{getInterval:function(){return this.interval},find:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=Zr.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new Qr(e,n),r=new $r(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return $r}}),$r.createNode=function(t){var e=new Jr(t),n=new $r(e.getInterval(),e.getLevel());return n},$r.createExpanded=function(t,e){var n=new Qr(e);null!==t&&n.expandToInclude(t.interval);var i=$r.createNode(n);return null!==t&&i.insert(t),i},h(ts,Zr),e(ts.prototype,{insert:function(t,e){var n=Zr.getSubnodeIndex(t,ts.origin);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=$r.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=Ri.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.origin=0,e(es.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=es.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new Qr(t,t))}if(arguments[0]instanceof Qr){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=es.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return es}}),es.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new Qr(n,i))},e(ns.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return ns}}),e(is.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&0>=o||o>0&&0>=r)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),n>0&&this.crossings++)},buildIndex:function(){this.tree=new es;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new rs(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[ns]},getClass:function(){return is}}),h(rs,tr),e(rs.prototype,{select:function(){if(1!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return rs}}),is.MCSelecter=rs,e(ss.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new br,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return ss}}),e(os.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return os}}),e(as.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=ls.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return as}}),e(us.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return us.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return us}}),us.ERROR=0,us.REPEATED_POINT=1,us.HOLE_OUTSIDE_SHELL=2,us.NESTED_HOLES=3,us.DISCONNECTED_INTERIOR=4,us.SELF_INTERSECTION=5,us.RING_SELF_INTERSECTION=6,us.NESTED_SHELLS=7,us.DUPLICATE_RINGS=8,us.TOO_FEW_POINTS=9,us.INVALID_COORDINATE=10,us.RING_NOT_CLOSED=11,us.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(ls.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!ls.isValid(t[e]))return this.validErr=new us(us.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new as(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new us(us.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new os(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new us(us.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new us(us.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=ls.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=ls.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new Kr(t);e.isInteriorsConnected()||(this.validErr=new us(us.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new us(us.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new is(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=ls.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new us(us.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){return t.hasTooFewPoints()?(this.validErr=new us(us.TOO_FEW_POINTS,t.getInvalidPoint()),null):void 0},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=ls.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new us(us.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new us(us.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new us(us.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},ls.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new ls(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return r.isNaN(n.x)?!1:r.isInfinite(n.x)?!1:r.isNaN(n.y)?!1:!r.isInfinite(n.y)}};var bo=Object.freeze({IsValidOp:ls}),Oo=Object.freeze({BoundaryOp:dt,IsSimpleOp:Gi,buffer:Co,distance:So,linemerge:wo,overlay:Lo,polygonize:Ro,relate:To,union:Po,valid:bo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,!1),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=t.getFactory().createGeometry(n)),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var _o=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;e>r;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;e>r;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return this.hasBadOutputIntersection(n)?!0:!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;n>a;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;n>i;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Mo=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=ci.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=ci.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return 0>=o},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;
return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(i){if(!(i instanceof w))throw i;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(i)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,-this.p.x)},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:0>s?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return r>s&&(r=s),s=this.distance(e,this),r>s&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return this.equalsOriented(t)?!0:!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},delete:function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv.delete(e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return t.equals(this.frameVertex[0])?!0:t.equals(this.frameVertex[1])?!0:!!t.equals(this.frameVertex[2])},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},delete:function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t.delete(),e.delete(),n.delete(),i.delete()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=ci.circumcentre(e,n,i),s=new Ts(r),o=0;3>o;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;3>e;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=o>r,u=s>=o;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;o>a;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(s>d){var p=d;(null===u||l>p)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,!1);return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Do=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return this.getEnvelopeInternal().equals(t.getEnvelopeInternal())?Yr.relate(this,t).isEquals(this.getDimension(),t.getDimension()):!1},union:function(){if(0===arguments.length)return jr.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return ls.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return Yr.covers(this,t)},coveredBy:function(t){return Yr.coveredBy(this,t)},touches:function(t){return Yr.touches(this,t)},intersects:function(t){return Yr.intersects(this,t)},within:function(t){return Yr.within(this,t)},overlaps:function(t){return Yr.overlaps(this,t)},disjoint:function(t){return Yr.disjoint(this,t)},crosses:function(t){return Yr.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return sr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return sr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return sr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;t>n;n++)e[n]=arguments[n];return Yr.relate.apply(Yr,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return Yr.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Gi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return n>e?!1:hr.isWithinDistance(this,t,e)},distance:function(t){return hr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Ao="1.1.2 (248dab8)";t.version=Ao,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.index=mo,t.io=Io,t.noding=No,t.operation=Oo,t.precision=_o,t.simplify=Mo,t.triangulate=Do});


/***/ }),

/***/ "./node_modules/monotone-convex-hull-2d/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/monotone-convex-hull-2d/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = monotoneConvexHull2D

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")[3]

function monotoneConvexHull2D(points) {
  var n = points.length

  if(n < 3) {
    var result = new Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = i
    }

    if(n === 2 &&
       points[0][0] === points[1][0] &&
       points[0][1] === points[1][1]) {
      return [0]
    }

    return result
  }

  //Sort point indices along x-axis
  var sorted = new Array(n)
  for(var i=0; i<n; ++i) {
    sorted[i] = i
  }
  sorted.sort(function(a,b) {
    var d = points[a][0]-points[b][0]
    if(d) {
      return d
    }
    return points[a][1] - points[b][1]
  })

  //Construct upper and lower hulls
  var lower = [sorted[0], sorted[1]]
  var upper = [sorted[0], sorted[1]]

  for(var i=2; i<n; ++i) {
    var idx = sorted[i]
    var p   = points[idx]

    //Insert into lower list
    var m = lower.length
    while(m > 1 && orient(
        points[lower[m-2]], 
        points[lower[m-1]], 
        p) <= 0) {
      m -= 1
      lower.pop()
    }
    lower.push(idx)

    //Insert into upper list
    m = upper.length
    while(m > 1 && orient(
        points[upper[m-2]], 
        points[upper[m-1]], 
        p) >= 0) {
      m -= 1
      upper.pop()
    }
    upper.push(idx)
  }

  //Merge lists together
  var result = new Array(upper.length + lower.length - 2)
  var ptr    = 0
  for(var i=0, nl=lower.length; i<nl; ++i) {
    result[ptr++] = lower[i]
  }
  for(var j=upper.length-2; j>0; --j) {
    result[ptr++] = upper[j]
  }

  //Return result
  return result
}

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./node_modules/robust-orientation/orientation.js":
/*!********************************************************!*\
  !*** ./node_modules/robust-orientation/orientation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var twoProduct = __webpack_require__(/*! two-product */ "./node_modules/two-product/two-product.js")
var robustSum = __webpack_require__(/*! robust-sum */ "./node_modules/robust-sum/robust-sum.js")
var robustScale = __webpack_require__(/*! robust-scale */ "./node_modules/robust-scale/robust-scale.js")
var robustSubtract = __webpack_require__(/*! robust-subtract */ "./node_modules/robust-subtract/robust-diff.js")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  var args = []
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos, determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)))
    }
    args.push("m" + i)
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "orientation" + n + "Exact"
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("")
  var proc = new Function("sum", "prod", "scale", "sub", code)
  return proc(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) { 
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy) 
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()

/***/ }),

/***/ "./node_modules/robust-scale/robust-scale.js":
/*!***************************************************!*\
  !*** ./node_modules/robust-scale/robust-scale.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var twoProduct = __webpack_require__(/*! two-product */ "./node_modules/two-product/two-product.js")
var twoSum = __webpack_require__(/*! two-sum */ "./node_modules/two-sum/two-sum.js")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/robust-subtract/robust-diff.js":
/*!*****************************************************!*\
  !*** ./node_modules/robust-subtract/robust-diff.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/robust-sum/robust-sum.js":
/*!***********************************************!*\
  !*** ./node_modules/robust-sum/robust-sum.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/simplicial-complex/topology.js":
/*!*****************************************************!*\
  !*** ./node_modules/simplicial-complex/topology.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 "use restrict";

var bits      = __webpack_require__(/*! bit-twiddle */ "./node_modules/bit-twiddle/twiddle.js")
  , UnionFind = __webpack_require__(/*! union-find */ "./node_modules/union-find/index.js")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents


/***/ }),

/***/ "./node_modules/simplify-js/simplify.js":
/*!**********************************************!*\
  !*** ./node_modules/simplify-js/simplify.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return simplify; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}

})();


/***/ }),

/***/ "./node_modules/turf-along/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-along/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var measureDistance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");

/**
 * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.
 *
 * @name along
 * @param {Feature<LineString>} line input line
 * @param {number} distance distance along the line
 * @param {String} [units=miles] can be degrees, radians, miles, or kilometers
 * @return {Feature<Point>} Point `distance` `units` along the line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var along = turf.along(line, 1, 'miles');
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, along]
 * };
 *
 * //=result
 */
module.exports = function (line, distance, units) {
    var coords;
    if (line.type === 'Feature') coords = line.geometry.coordinates;
    else if (line.type === 'LineString') coords = line.coordinates;
    else throw new Error('input must be a LineString Feature or Geometry');

    var travelled = 0;
    for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) break;
        else if (travelled >= distance) {
            var overshot = distance - travelled;
            if (!overshot) return point(coords[i]);
            else {
                var direction = bearing(coords[i], coords[i - 1]) - 180;
                var interpolated = destination(coords[i], overshot, direction, units);
                return interpolated;
            }
        } else {
            travelled += measureDistance(coords[i], coords[i + 1], units);
        }
    }
    return point(coords[coords.length - 1]);
};


/***/ }),

/***/ "./node_modules/turf-area/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-area/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var geometryArea = __webpack_require__(/*! geojson-area */ "./node_modules/geojson-area/index.js").geometry;

/**
 * Takes a one or more features and returns their area
 * in square meters.
 *
 * @param {(Feature|FeatureCollection)} input input features
 * @return {Number} area in square meters
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-67.031021, 10.458102],
 *           [-67.031021, 10.53372],
 *           [-66.929397, 10.53372],
 *           [-66.929397, 10.458102],
 *           [-67.031021, 10.458102]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-66.919784, 10.397325],
 *           [-66.919784, 10.513467],
 *           [-66.805114, 10.513467],
 *           [-66.805114, 10.397325],
 *           [-66.919784, 10.397325]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 *
 * var area = turf.area(polygons);
 *
 * //=area
 */
function area(input) {
    if (input.type === 'FeatureCollection') {
        for (var i = 0, sum = 0; i < input.features.length; i++) {
            if (input.features[i].geometry) {
                sum += geometryArea(input.features[i].geometry);
            }
        }
        return sum;
    } else if (input.type === 'Feature') {
        return geometryArea(input.geometry);
    } else {
        return geometryArea(input);
    }
}
module.exports = area;


/***/ }),

/***/ "./node_modules/turf-bbox-polygon/index.js":
/*!*************************************************!*\
  !*** ./node_modules/turf-bbox-polygon/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;

/**
 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
 *
 * @name bboxPolygon
 * @param {Array<number>} bbox an Array of bounding box coordinates in the form: ```[xLow, yLow, xHigh, yHigh]```
 * @return {Feature<Polygon>} a Polygon representation of the bounding box
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //=poly
 */

module.exports = function (bbox) {
    var lowLeft = [bbox[0], bbox[1]];
    var topLeft = [bbox[0], bbox[3]];
    var topRight = [bbox[2], bbox[3]];
    var lowRight = [bbox[2], bbox[1]];

    return polygon([[
        lowLeft,
        lowRight,
        topRight,
        topLeft,
        lowLeft
    ]]);
};


/***/ }),

/***/ "./node_modules/turf-bbox/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-bbox/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {(Feature|FeatureCollection)} geojson input features
 * @return {Array<number>} the bounding box of `input` given
 * as an array in WSEN order (west, south, east, north)
 * @example
 * var input = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.175329, 22.2524]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.170007, 22.267969]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.200649, 22.274641]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.186744, 22.265745]
 *       }
 *     }
 *   ]
 * };
 *
 * var bbox = turf.bbox(input);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * var resultFeatures = input.features.concat(bboxPolygon);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (geojson) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
    each(geojson, function (coord) {
        if (bbox[0] > coord[0]) bbox[0] = coord[0];
        if (bbox[1] > coord[1]) bbox[1] = coord[1];
        if (bbox[2] < coord[0]) bbox[2] = coord[0];
        if (bbox[3] < coord[1]) bbox[3] = coord[1];
    });
    return bbox;
};


/***/ }),

/***/ "./node_modules/turf-bearing/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-bearing/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point|points} and finds the geographic bearing between them.
 *
 * @name bearing
 * @param {Feature<Point>} start starting Point
 * @param {Feature<Point>} end ending Point
 * @returns {Number} bearing in decimal degrees
 * @example
 * var point1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#f00'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var point2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#0f0'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [point1, point2]
 * };
 *
 * //=points
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //=bearing
 */
module.exports = function (start, end) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);

    var lon1 = degrees2radians * coordinates1[0];
    var lon2 = degrees2radians * coordinates2[0];
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

    var bearing = radians2degrees * Math.atan2(a, b);

    return bearing;
};


/***/ }),

/***/ "./node_modules/turf-bezier/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-bezier/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var Spline = __webpack_require__(/*! ./spline.js */ "./node_modules/turf-bezier/spline.js");

/**
 * Takes a {@link LineString|line} and returns a curved version
 * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
 * algorithm.
 *
 * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
 *
 * @name bezier
 * @param {Feature<LineString>} line input LineString
 * @param {Number} [resolution=10000] time in milliseconds between points
 * @param {Number} [sharpness=0.85] a measure of how curvy the path should be between splines
 * @returns {Feature<LineString>} curved line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {
 *     "stroke": "#f00"
 *   },
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-76.091308, 18.427501],
 *       [-76.695556, 18.729501],
 *       [-76.552734, 19.40443],
 *       [-74.61914, 19.134789],
 *       [-73.652343, 20.07657],
 *       [-73.157958, 20.210656]
 *     ]
 *   }
 * };
 *
 * var curved = turf.bezier(line);
 * curved.properties = { stroke: '#0f0' };
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, curved]
 * };
 *
 * //=result
 */
module.exports = function (line, resolution, sharpness) {
    var lineOut = linestring([]);

    lineOut.properties = line.properties;

    var spline = new Spline({
        points: line.geometry.coordinates.map(function (pt) {
            return {x: pt[0], y: pt[1]};
        }),
        duration: resolution,
        sharpness: sharpness
    });

    for (var i = 0; i < spline.duration; i += 10) {
        var pos = spline.pos(i);
        if (Math.floor(i / 100) % 2 === 0) {
            lineOut.geometry.coordinates.push([pos.x, pos.y]);
        }
    }

    return lineOut;
};


/***/ }),

/***/ "./node_modules/turf-bezier/spline.js":
/*!********************************************!*\
  !*** ./node_modules/turf-bezier/spline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable */

 /**
   * BezierSpline
   * https://github.com/leszekr/bezier-spline-js
   *
   * @private
   * @copyright
   * Copyright (c) 2013 Leszek Rybicki
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
var Spline = function (options) {
    this.points = options.points || [];
    this.duration = options.duration || 10000;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    // this is to ensure compatibility with the 2d version
    for (var i = 0; i < this.length; i++) this.points[i].z = this.points[i].z || 0;
    for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2,
            z: (p1.z + p2.z) / 2
        });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (var i = 0; i < this.centers.length - 1; i++) {
        var p1 = this.centers[i];
        var p2 = this.centers[i + 1];
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([{
            x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)},
            {
                x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)}]);
    }
    this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
};

  /*
    Caches an array of equidistant (more or less) points on the curve.
  */
Spline.prototype.cacheSteps = function (mindist) {
    var steps = [];
    var laststep = this.pos(0);
    steps.push(0);
    for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
            steps.push(t);
            laststep = step;
        }
    }
    return steps;
};

  /*
    returns angle and speed in the given point in the curve
  */
Spline.prototype.vector = function (t) {
    var p1 = this.pos(t + 10);
    var p2 = this.pos(t - 10);
    return {
        angle:180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed:Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
    };
};

  /*
    Gets the position of the point, given time.

    WARNING: The speed is not constant. The time it takes between control points is constant.

    For constant speed, use Spline.steps[i];
  */
Spline.prototype.pos = function (time) {

    function bezier(t, p1, c1, c2, p2) {
        var B = function (t) {
            var t2 = t * t, t3 = t2 * t;
            return [(t3), (3 * t2 * (1 - t)), (3 * t * (1 - t) * (1 - t)), ((1 - t) * (1 - t) * (1 - t))];
        };
        var b = B(t);
        var pos = {
            x : p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
            y : p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
            z : p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
        };
        return pos;
    }
    var t = time - this.delay;
    if (t < 0) t = 0;
    if (t > this.duration) t = this.duration - 1;
    //t = t-this.delay;
    var t2 = (t) / this.duration;
    if (t2 >= 1) return this.points[this.length - 1];

    var n = Math.floor((this.points.length - 1) * t2);
    var t1 = (this.length - 1) * t2 - n;
    return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
};

module.exports = Spline;


/***/ }),

/***/ "./node_modules/turf-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circles-circumference
// radians = degrees * (pi/180)
// https://github.com/bjornharrtell/jsts/blob/master/examples/buffer.html

var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");
var featureCollection = helpers.featureCollection;
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
var normalize = __webpack_require__(/*! geojson-normalize */ "./node_modules/geojson-normalize/index.js");

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * @name buffer
 * @param {(Feature|FeatureCollection)} feature input to be buffered
 * @param {number} distance distance to draw the buffer
 * @param {string} unit any of the options supported by turf units
 * @return {FeatureCollection<Polygon>|FeatureCollection<MultiPolygon>|Polygon|MultiPolygon} buffered features
 *
 * @example
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-90.548630, 14.616599]
 *   }
 * };
 * var unit = 'miles';
 *
 * var buffered = turf.buffer(pt, 500, unit);
 * var result = turf.featurecollection([buffered, pt]);
 *
 * //=result
 */

module.exports = function (feature, radius, units) {

    var degrees = helpers.distanceToDegrees(radius, units);
    var fc = normalize(feature);
    var buffered = normalize(featureCollection(fc.features.map(function (f) {
        return bufferOp(f, degrees);
    })));

    if (buffered.features.length > 1) return buffered;
    else if (buffered.features.length === 1) return buffered.features[0];
};

function bufferOp(feature, radius) {
    var reader = new jsts.io.GeoJSONReader();
    var geom = reader.read(feature.geometry);
    var buffered = geom.buffer(radius);
    var writer = new jsts.io.GeoJSONWriter();
    buffered = writer.write(buffered);

    return {
        type: 'Feature',
        geometry: buffered,
        properties: {}
    };
}


/***/ }),

/***/ "./node_modules/turf-center/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-center/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js"),
    point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a {@link FeatureCollection} and returns the absolute center point of all features.
 *
 * @name center
 * @param {FeatureCollection} features input features
 * @return {Feature<Point>} a Point feature at the
 * absolute center point of all input features
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.522259, 35.4691]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.502754, 35.463455]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508269, 35.463245]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.516809, 35.465779]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.515372, 35.467072]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.509363, 35.463053]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.511123, 35.466601]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.518547, 35.469327]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.519706, 35.469659]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.517839, 35.466998]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508678, 35.464942]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.514914, 35.463453]
 *       }
 *     }
 *   ]
 * };
 *
 * var centerPt = turf.center(features);
 * centerPt.properties['marker-size'] = 'large';
 * centerPt.properties['marker-color'] = '#000';
 *
 * var resultFeatures = features.features.concat(centerPt);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (layer) {
    var ext = bbox(layer);
    var x = (ext[0] + ext[2]) / 2;
    var y = (ext[1] + ext[3]) / 2;
    return point([x, y]);
};


/***/ }),

/***/ "./node_modules/turf-centroid/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-centroid/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes one or more features and calculates the centroid using
 * the mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating
 * the centroid of a set of polygons.
 *
 * @name centroid
 * @param {(Feature|FeatureCollection)} features input features
 * @return {Feature<Point>} the centroid of the input features
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [105.818939,21.004714],
 *       [105.818939,21.061754],
 *       [105.890007,21.061754],
 *       [105.890007,21.004714],
 *       [105.818939,21.004714]
 *     ]]
 *   }
 * };
 *
 * var centroidPt = turf.centroid(poly);
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [poly, centroidPt]
 * };
 *
 * //=result
 */
module.exports = function (features) {
    var xSum = 0, ySum = 0, len = 0;
    each(features, function (coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return point([xSum / len, ySum / len]);
};


/***/ }),

/***/ "./node_modules/turf-collect/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-collect/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");

/**
 * Joins attributes FeatureCollection of polygons with a FeatureCollection of
 * points. Given an `inProperty` on points and an `outProperty` for polygons,
 * this finds every point that lies within each polygon, collects the `inProperty`
 * values from those points, and adds them as an array to `outProperty` on the
 * polygon.
 *
 * @name collect
 * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate
 * @param {FeatureCollection<Point>} points points to be aggregated
 * @param {string} inProperty property to be nested from
 * @param {string} outProperty property to be nested into
 * @return {FeatureCollection<Polygon>} polygons with properties listed based on `outField`
 * @example
 * var poly1 = polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);
 * var poly2 = polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);
 * var polyFC = featurecollection([poly1, poly2]);
 * var pt1 = point([5,5], {population: 200});
 * var pt2 = point([1,3], {population: 600});
 * var pt3 = point([14,2], {population: 100});
 * var pt4 = point([13,1], {population: 200});
 * var pt5 = point([19,7], {population: 300});
 * var ptFC = featurecollection([pt1, pt2, pt3, pt4, pt5]);
 * var aggregated = aggregate(polyFC, ptFC, 'population', 'values');
 *
 * aggregated.features[0].properties.values // => [200, 600]);
 */
module.exports = function collect(polygons, points, inProperty, outProperty) {
    polygons.features.forEach(function (poly) {
        var values = points.features.filter(function (pt) {
            return inside(pt, poly);
        }).map(function (pt) {
            return pt.properties[inProperty];
        });

        if (!poly.properties) {
            poly.properties = {};
        }

        poly.properties[outProperty] = values;
    });

    return polygons;
};


/***/ }),

/***/ "./node_modules/turf-combine/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-combine/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js");

/**
 * Combines a {@link FeatureCollection} of {@link Point},
 * {@link LineString}, or {@link Polygon} features
 * into {@link MultiPoint}, {@link MultiLineString}, or
 * {@link MultiPolygon} features.
 *
 * @name combine
 * @param {FeatureCollection<(Point|LineString|Polygon)>} fc a FeatureCollection of any type
 * @return {FeatureCollection<(MultiPoint|MultiLineString|MultiPolygon)>} a FeatureCollection of corresponding type to input
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.026432, 47.49134]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.074497, 47.509548]
 *       }
 *     }
 *   ]
 * };
 *
 * var combined = turf.combine(fc);
 *
 * //=combined
 */

module.exports = function (fc) {
    var groups = {
        MultiPoint: {coordinates: [], properties: []},
        MultiLineString: {coordinates: [], properties: []},
        MultiPolygon: {coordinates: [], properties: []}
    };

    var multiMapping = Object.keys(groups).reduce(function (memo, item) {
        memo[item.replace('Multi', '')] = item;
        return memo;
    }, {});

    function addToGroup(feature, key, multi) {
        if (!multi) {
            groups[key].coordinates.push(feature.geometry.coordinates);
        } else {
            groups[key].coordinates = groups[key].coordinates.concat(feature.geometry.coordinates);
        }
        groups[key].properties.push(feature.properties);
    }

    meta.featureEach(fc, function (feature) {
        if (!feature.geometry) return;
        if (groups[feature.geometry.type]) {
            addToGroup(feature, feature.geometry.type, true);
        } else if (multiMapping[feature.geometry.type]) {
            addToGroup(feature, multiMapping[feature.geometry.type], false);
        }
    });

    return {
        type: 'FeatureCollection',
        features: Object.keys(groups)
            .filter(function (key) {
                return groups[key].coordinates.length;
            })
            .sort()
            .map(function (key) {
                return {
                    type: 'Feature',
                    properties: {
                        collectedProperties: groups[key].properties
                    },
                    geometry: {
                        type: key,
                        coordinates: groups[key].coordinates
                    }
                };
            })
    };
};


/***/ }),

/***/ "./node_modules/turf-concave/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-concave/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 1. run tin on points
// 2. calculate lenth of all edges and area of all triangles
// 3. remove triangles that fail the max length test
// 4. buffer the results slightly
// 5. merge the results
var tin = __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js");
var union = __webpack_require__(/*! turf-union */ "./node_modules/turf-union/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a set of {@link Point|points} and returns a concave hull polygon.
 *
 * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
 *
 * @param {FeatureCollection<Point>} points input points
 * @param {number} maxEdge the size of an edge necessary for part of the
 * hull to become concave (in miles)
 * @param {string} units used for maxEdge distance (miles or kilometers)
 * @returns {Feature<Polygon>} a concave hull
 * @throws {Error} if maxEdge parameter is missing
 * @throws {Error} if units parameter is missing
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.601226, 44.642643]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.591442, 44.651436]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.580799, 44.648749]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.573589, 44.641788]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.587665, 44.64533]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.595218, 44.64765]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.concave(points, 1, 'miles');
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
function concave(points, maxEdge, units) {
    if (typeof maxEdge !== 'number') throw new Error('maxEdge parameter is required');
    if (typeof units !== 'string') throw new Error('units parameter is required');

    var tinPolys = tin(points);
    var filteredPolys = tinPolys.features.filter(filterTriangles);
    tinPolys.features = filteredPolys;

    function filterTriangles(triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance(pt1, pt2, units);
        var dist2 = distance(pt2, pt3, units);
        var dist3 = distance(pt1, pt3, units);
        return (dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge);
    }

    return merge(tinPolys);
}

function merge(polygons) {
    var merged = JSON.parse(JSON.stringify(polygons.features[0])),
        features = polygons.features;

    for (var i = 0, len = features.length; i < len; i++) {
        var poly = features[i];
        if (poly.geometry) {
            merged = union(merged, poly);
        }
    }
    return merged;
}

module.exports = concave;


/***/ }),

/***/ "./node_modules/turf-convex/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-convex/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach,
    convexHull = __webpack_require__(/*! convex-hull */ "./node_modules/convex-hull/ch.js"),
    polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;

/**
 * Takes a set of {@link Point|points} and returns a
 * [convex hull](http://en.wikipedia.org/wiki/Convex_hull) polygon.
 *
 * Internally this uses
 * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that
 * implements a [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
 *
 * @name convex
 * @param {FeatureCollection<Point>} featurecollection input points
 * @returns {Feature<Polygon>} a convex hull
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.404052, 43.8424511]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.579833, 43.659924]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.360107, 43.516688]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.14038, 43.588348]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.convex(points);
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (featurecollection) {
    var points = [];
    each(featurecollection, function (coord) { points.push(coord); });
    var hull = convexHull(points);
    if (hull.length > 0) {
        var ring = [];
        for (var i = 0; i < hull.length; i++) {
            ring.push(points[hull[i][0]]);
        }
        ring.push(points[hull[hull.length - 1][1]]);
        return polygon([ring]);
    }
    return undefined;
};


/***/ }),

/***/ "./node_modules/turf-destination/index.js":
/*!************************************************!*\
  !*** ./node_modules/turf-destination/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");
var point = helpers.point;
var distanceToRadians = helpers.distanceToRadians;

/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Feature<Point>} from starting point
 * @param {number} distance distance from the starting point
 * @param {number} bearing ranging from -180 to 180
 * @param {String} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<Point>} destination point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var distance = 50;
 * var bearing = 90;
 * var units = 'miles';
 *
 * var destination = turf.destination(point, distance, bearing, units);
 * destination.properties['marker-color'] = '#f00';
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [point, destination]
 * };
 *
 * //=result
 */
module.exports = function (from, distance, bearing, units) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(from);
    var longitude1 = degrees2radians * coordinates1[0];
    var latitude1 = degrees2radians * coordinates1[1];
    var bearing_rad = degrees2radians * bearing;

    var radians = distanceToRadians(distance, units);

    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) *
        Math.sin(radians) * Math.cos(latitude1),
        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));

    return point([radians2degrees * longitude2, radians2degrees * latitude2]);
};


/***/ }),

/***/ "./node_modules/turf-difference/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-difference/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Finds the difference between two {@link Polygon|polygons} by clipping the second
 * polygon from the first.
 *
 * @name difference
 * @param {Feature<Polygon>} poly1 input Polygon feaure
 * @param {Feature<Polygon>} poly2 Polygon feature to difference from `poly1`
 * @return {Feature<Polygon>} a Polygon feature showing the area of `poly1` excluding the area of `poly2`
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.738586, -23.596711],
 *       [-46.738586, -23.458207],
 *       [-46.560058, -23.458207],
 *       [-46.560058, -23.596711],
 *       [-46.738586, -23.596711]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.650009, -23.631314],
 *       [-46.650009, -23.5237],
 *       [-46.509246, -23.5237],
 *       [-46.509246, -23.631314],
 *       [-46.650009, -23.631314]
 *     ]]
 *   }
 * };
 *
 * var differenced = turf.difference(poly1, poly2);
 * differenced.properties.fill = '#f00';
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * //=polygons
 *
 * //=differenced
 */

module.exports = function (p1, p2) {
    var poly1 = JSON.parse(JSON.stringify(p1));
    var poly2 = JSON.parse(JSON.stringify(p2));
    if (poly1.type !== 'Feature') {
        poly1 = {
            type: 'Feature',
            properties: {},
            geometry: poly1
        };
    }
    if (poly2.type !== 'Feature') {
        poly2 = {
            type: 'Feature',
            properties: {},
            geometry: poly2
        };
    }

    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(poly1.geometry));
    var b = reader.read(JSON.stringify(poly2.geometry));
    var differenced = a.difference(b);

    if (differenced.isEmpty()) return undefined;

    var writer = new jsts.io.GeoJSONWriter();
    var geojsonGeometry = writer.write(differenced);

    poly1.geometry = differenced;

    return {
        type: 'Feature',
        properties: poly1.properties,
        geometry: geojsonGeometry
    };
};


/***/ }),

/***/ "./node_modules/turf-distance/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-distance/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
var radiansToDistance = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").radiansToDistance;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians,
 * miles, or kilometers. This uses the
 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
 * to account for global curvature.
 *
 * @name distance
 * @param {Feature<Point>} from origin point
 * @param {Feature<Point>} to destination point
 * @param {String} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Number} distance between the two points
 * @example
 * var from = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var to = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 * var units = "miles";
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [from, to]
 * };
 *
 * //=points
 *
 * var distance = turf.distance(from, to, units);
 *
 * //=distance
 */
module.exports = function (from, to, units) {
    var degrees2radians = Math.PI / 180;
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];

    var a = Math.pow(Math.sin(dLat / 2), 2) +
          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
};


/***/ }),

/***/ "./node_modules/turf-envelope/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-envelope/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js");
var bboxPolygon = __webpack_require__(/*! turf-bbox-polygon */ "./node_modules/turf-bbox-polygon/index.js");

/**
 * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
 *
 * @name envelope
 * @param {FeatureCollection} fc input features
 * @return {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location A"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.343, 39.984]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location B"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.833, 39.284]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location C"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.534, 39.123]
 *       }
 *     }
 *   ]
 * };
 *
 * var enveloped = turf.envelope(fc);
 *
 * var resultFeatures = fc.features.concat(enveloped);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (features) {
    return bboxPolygon(bbox(features));
};


/***/ }),

/***/ "./node_modules/turf-explode/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-explode/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a feature or set of features and returns all positions as
 * {@link Point|points}.
 *
 * @name explode
 * @param {(Feature|FeatureCollection)} geojson input features
 * @return {FeatureCollection<point>} points representing the exploded input features
 * @throws {Error} if it encounters an unknown geometry type
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [177.434692, -17.77517],
 *       [177.402076, -17.779093],
 *       [177.38079, -17.803937],
 *       [177.40242, -17.826164],
 *       [177.438468, -17.824857],
 *       [177.454948, -17.796746],
 *       [177.434692, -17.77517]
 *     ]]
 *   }
 * };
 *
 * var points = turf.explode(poly);
 *
 * //=poly
 *
 * //=points
 */
module.exports = function (geojson) {
    var points = [];
    each(geojson, function (coord) {
        points.push(point(coord));
    });
    return featureCollection(points);
};


/***/ }),

/***/ "./node_modules/turf-flip/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-flip/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coordEach = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;

/**
 * Takes input features and flips all of their coordinates
 * from `[x, y]` to `[y, x]`.
 *
 * @name flip
 * @param {(Feature|FeatureCollection)} input input features
 * @returns {(Feature|FeatureCollection)} a feature or set of features of the same type as `input` with flipped coordinates
 * @example
 * var serbia = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [20.566406, 43.421008]
 *   }
 * };
 *
 * //=serbia
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //=saudiArabia
 */
module.exports = function flip(input) {
    // ensure that we don't modify features in-place and changes to the
    // output do not change the previous feature, including changes to nested
    // properties.
    input = JSON.parse(JSON.stringify(input));

    coordEach(input, function (coord) {
        coord.reverse();
    });
    return input;
};


/***/ }),

/***/ "./node_modules/turf-grid/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-grid/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-point */ "./node_modules/turf-point/index.js");

/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Point} features in a grid.
 *
 * @module turf/grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} depth how many cells to output
 * @return {FeatureCollection} grid as FeatureCollection with {@link Point} features
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var depth = 10;
 *
 * var grid = turf.grid(extent, depth);
 *
 * //=grid
 */
module.exports = function(extents, depth) {
  var xmin = extents[0];
  var ymin = extents[1];
  var xmax = extents[2];
  var ymax = extents[3];
  var interval = (xmax - xmin) / depth;
  var coords = [];
  var fc = {
    type: 'FeatureCollection',
    features: []
  };

  for (var x=0; x<=depth; x++){
    for (var y=0;y<=depth; y++){
      fc.features.push(point([(x * interval) + xmin, (y * interval) + ymin]));
    }
  }
  return fc;
}


/***/ }),

/***/ "./node_modules/turf-helpers/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-helpers/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} properties properties
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties) {
    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

module.exports.feature = feature;

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {number[]} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object=} properties an Object that is used as the {@link Feature}'s
 * properties
 * @returns {Feature<Point>} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
module.exports.point = function (coordinates, properties) {
    if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    return feature({
        type: 'Point',
        coordinates: coordinates.slice()
    }, properties);
};

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object=} properties a properties object
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
module.exports.polygon = function (coordinates, properties) {

    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *	[-21.964416, 64.148203],
 *	[-21.956176, 64.141316],
 *	[-21.93901, 64.135924],
 *	[-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *	[-21.929054, 64.127985],
 *	[-21.912918, 64.134726],
 *	[-21.916007, 64.141016],
 * 	[-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
module.exports.lineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featureCollection(features);
 *
 * //=fc
 */
module.exports.featureCollection = function (features) {
    return {
        type: 'FeatureCollection',
        features: features
    };
};

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 *
 */
module.exports.multiLineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 *
 */
module.exports.multiPoint = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties);
};


/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]);
 *
 * //=multiPoly
 *
 */
module.exports.multiPolygon = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<GeometryCollection>} a geometrycollection feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometrycollection([[0,0],[10,10]]);
 *
 * //=collection
 */
module.exports.geometryCollection = function (geometries, properties) {
    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties);
};

var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    kilometers: 6373,
    kilometres: 6373
};

/*
 * Convert a distance measurement from radians to a more friendly unit.
 *
 * @name radiansToDistance
 * @param {number} distance in radians across the sphere
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
module.exports.radiansToDistance = function (radians, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return radians * factor;
};

/*
 * Convert a distance measurement from a real-world unit into radians
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
module.exports.distanceToRadians = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return distance / factor;
};

/*
 * Convert a distance measurement from a real-world unit into degrees
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
module.exports.distanceToDegrees = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return (distance / factor) * 57.2958;
};


/***/ }),

/***/ "./node_modules/turf-hex-grid/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-hex-grid/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

//Precompute cosines and sines of angles used in hexagon creation
// for performance gain
var cosines = [];
var sines = [];
for (var i = 0; i < 6; i++) {
    var angle = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle));
    sines.push(Math.sin(angle));
}

/**
 * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped
 * hexagons ({@link Polygon} features) aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
 *
 * @name hexGrid
 * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of cell in specified units
 * @param {string} units used in calculating cellWidth ('miles' or 'kilometers')
 * @param {boolean} triangles whether to return as triangles instead of hexagons
 * @return {FeatureCollection<Polygon>} a hexagonal grid
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellWidth = 50;
 * var units = 'miles';
 *
 * var hexgrid = turf.hexGrid(bbox, cellWidth, units);
 *
 * //=hexgrid
 */
module.exports = function hexGrid(bbox, cellSize, units, triangles) {
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var radius = cellWidth / 2;

    var hex_width = radius * 2;
    var hex_height = Math.sqrt(3) / 2 * cellHeight;

    var box_width = bbox[2] - bbox[0];
    var box_height = bbox[3] - bbox[1];

    var x_interval = 3 / 4 * hex_width;
    var y_interval = hex_height;

    var x_span = box_width / (hex_width - radius / 2);
    var x_count = Math.ceil(x_span);
    if (Math.round(x_span) === x_count) {
        x_count++;
    }

    var x_adjust = ((x_count * x_interval - radius / 2) - box_width) / 2 - radius / 2;

    var y_count = Math.ceil(box_height / hex_height);

    var y_adjust = (box_height - y_count * hex_height) / 2;

    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }

    var fc = featurecollection([]);
    for (var x = 0; x < x_count; x++) {
        for (var y = 0; y <= y_count; y++) {

            var isOdd = x % 2 === 1;
            if (y === 0 && isOdd) {
                continue;
            }

            if (y === 0 && hasOffsetY) {
                continue;
            }

            var center_x = x * x_interval + bbox[0] - x_adjust;
            var center_y = y * y_interval + bbox[1] + y_adjust;

            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (triangles) {
                fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));
            } else {
                fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));
            }
        }
    }

    return fc;
};

//Center should be [x, y]
function hexagon(center, rx, ry) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
    }
    //first and last vertex must be the same
    vertices.push(vertices[0]);
    return polygon([vertices]);
}

//Center should be [x, y]
function hexTriangles(center, rx, ry) {
    var triangles = [];
    for (var i = 0; i < 6; i++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([
            center[0] + rx * cosines[i],
            center[1] + ry * sines[i]
        ]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push(polygon([vertices]));
    }
    return triangles;
}


/***/ }),

/***/ "./node_modules/turf-inside/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-inside/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var invariant = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js");

// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
 * be convex or concave. The function accounts for holes.
 *
 * @name inside
 * @param {Feature<Point>} point input point
 * @param {Feature<(Polygon|MultiPolygon)>} polygon input polygon or multipolygon
 * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#f00"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.467285, 40.75766]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.873779, 40.647303]
 *   }
 * };
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-112.074279, 40.52215],
 *       [-112.074279, 40.853293],
 *       [-111.610107, 40.853293],
 *       [-111.610107, 40.52215],
 *       [-112.074279, 40.52215]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, poly]
 * };
 *
 * //=features
 *
 * var isInside1 = turf.inside(pt1, poly);
 * //=isInside1
 *
 * var isInside2 = turf.inside(pt2, poly);
 * //=isInside2
 */
module.exports = function input(point, polygon) {
    var pt = invariant.getCoord(point);
    var polys = polygon.geometry.coordinates;
    // normalize to multipolygon
    if (polygon.geometry.type === 'Polygon') polys = [polys];

    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0])) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k])) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) insidePoly = true;
        }
    }
    return insidePoly;
};

// pt is [x,y] and ring is [[x,y], [x,y],..]
function inRing(pt, ring) {
    var isInside = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0], yi = ring[i][1];
        var xj = ring[j][0], yj = ring[j][1];
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
        if (intersect) isInside = !isInside;
    }
    return isInside;
}


/***/ }),

/***/ "./node_modules/turf-intersect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-intersect/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Takes two {@link Polygon|polygons} and finds their intersection. If they share a border, returns the border; if they don't intersect, returns undefined.
 *
 * @name intersect
 * @param {Feature<Polygon>} poly1 the first polygon
 * @param {Feature<Polygon>} poly2 the second polygon
 * @return {(Feature<Polygon>|undefined|Feature<MultiLineString>)} if `poly1` and `poly2` overlap, returns a Polygon feature representing the area they overlap; if `poly1` and `poly2` do not overlap, returns `undefined`; if `poly1` and `poly2` share a border, a MultiLineString of the locations where their borders are shared
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-122.801742, 45.48565],
 *       [-122.801742, 45.60491],
 *       [-122.584762, 45.60491],
 *       [-122.584762, 45.48565],
 *       [-122.801742, 45.48565]
 *     ]]
 *   }
 * }
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-122.520217, 45.535693],
 *       [-122.64038, 45.553967],
 *       [-122.720031, 45.526554],
 *       [-122.669906, 45.507309],
 *       [-122.723464, 45.446643],
 *       [-122.532577, 45.408574],
 *       [-122.487258, 45.477466],
 *       [-122.520217, 45.535693]
 *     ]]
 *   }
 * }
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var intersection = turf.intersect(poly1, poly2);
 *
 * //=polygons
 *
 * //=intersection
 */
module.exports = function intersect(poly1, poly2) {
    var geom1, geom2;
    if (poly1.type === 'Feature') geom1 = poly1.geometry;
    else geom1 = poly1;
    if (poly2.type === 'Feature') geom2 = poly2.geometry;
    else geom2 = poly2;
    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(geom1));
    var b = reader.read(JSON.stringify(geom2));
    var intersection = a.intersection(b);

    if (intersection.isEmpty()) {
        return undefined;
    }

    var writer = new jsts.io.GeoJSONWriter();

    var geojsonGeometry = writer.write(intersection);
    return {
        type: 'Feature',
        properties: {},
        geometry: geojsonGeometry
    };
};


/***/ }),

/***/ "./node_modules/turf-invariant/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-invariant/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Unwrap a coordinate from a Feature with a Point geometry, a Point
 * geometry, or a single coordinate.
 *
 * @param {*} obj any value
 * @returns {Array<number>} a coordinate
 */
function getCoord(obj) {
    if (Array.isArray(obj) &&
        typeof obj[0] === 'number' &&
        typeof obj[1] === 'number') {
        return obj;
    } else if (obj) {
        if (obj.type === 'Feature' &&
            obj.geometry &&
            obj.geometry.type === 'Point' &&
            Array.isArray(obj.geometry.coordinates)) {
            return obj.geometry.coordinates;
        } else if (obj.type === 'Point' &&
            Array.isArray(obj.coordinates)) {
            return obj.coordinates;
        }
    }
    throw new Error('A coordinate, feature, or point geometry is required');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @alias geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias collectionOf
 * @param {FeatureCollection} featurecollection a featurecollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featurecollection, type, name) {
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featurecollection || featurecollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featurecollection.features.length; i++) {
        var feature = featurecollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

module.exports.geojsonType = geojsonType;
module.exports.collectionOf = collectionOf;
module.exports.featureOf = featureOf;
module.exports.getCoord = getCoord;


/***/ }),

/***/ "./node_modules/turf-isolines/conrec.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-isolines/conrec.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable */

/*
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */


  module.exports = Conrec;

  var EPSILON = 1e-10;

  function pointsEqual(a, b) {
      var x = a.x - b.x, y = a.y - b.y;
      return x * x + y * y < EPSILON;
  }

  function reverseList(list) {
      var pp = list.head;

      while (pp) {
      // swap prev/next pointers
          var temp = pp.next;
          pp.next = pp.prev;
          pp.prev = temp;

      // continue through the list
          pp = temp;
      }

    // swap head/tail pointers
      var temp = list.head;
      list.head = list.tail;
      list.tail = temp;
  }

  function ContourBuilder(level) {
      this.level = level;
      this.s = null;
      this.count = 0;
  }
  ContourBuilder.prototype.remove_seq = function (list) {
    // if list is the first item, static ptr s is updated
      if (list.prev) {
          list.prev.next = list.next;
      } else {
          this.s = list.next;
      }

      if (list.next) {
          list.next.prev = list.prev;
      }
      --this.count;
  };
  ContourBuilder.prototype.addSegment = function (a, b) {
      var ss = this.s;
      var ma = null;
      var mb = null;
      var prependA = false;
      var prependB = false;

      while (ss) {
          if (ma == null) {
        // no match for a yet
              if (pointsEqual(a, ss.head.p)) {
                  ma = ss;
                  prependA = true;
              } else if (pointsEqual(a, ss.tail.p)) {
                  ma = ss;
              }
          }
          if (mb == null) {
        // no match for b yet
              if (pointsEqual(b, ss.head.p)) {
                  mb = ss;
                  prependB = true;
              } else if (pointsEqual(b, ss.tail.p)) {
                  mb = ss;
              }
          }
      // if we matched both no need to continue searching
          if (mb != null && ma != null) {
              break;
          } else {
              ss = ss.next;
          }
      }

    // c is the case selector based on which of ma and/or mb are set
      var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

      switch (c) {
      case 0:   // both unmatched, add as new sequence
          var aa = {p: a, prev: null};
          var bb = {p: b, next: null};
          aa.next = bb;
          bb.prev = aa;

        // create sequence element and push onto head of main list. The order
        // of items in this list is unimportant
          ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
          if (this.s) {
              this.s.prev = ma;
          }
          this.s = ma;

          ++this.count;    // not essential - tracks number of unmerged sequences
          break;

      case 1:   // a matched, b did not - thus b extends sequence ma
          var pp = {p: b};

          if (prependA) {
              pp.next = ma.head;
              pp.prev = null;
              ma.head.prev = pp;
              ma.head = pp;
          } else {
              pp.next = null;
              pp.prev = ma.tail;
              ma.tail.next = pp;
              ma.tail = pp;
          }
          break;

      case 2:   // b matched, a did not - thus a extends sequence mb
          var pp = {p: a};

          if (prependB) {
              pp.next = mb.head;
              pp.prev = null;
              mb.head.prev = pp;
              mb.head = pp;
          } else {
              pp.next = null;
              pp.prev = mb.tail;
              mb.tail.next = pp;
              mb.tail = pp;
          }
          break;

      case 3:   // both matched, can merge sequences
        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

          if (ma === mb) {
              var pp = {p: ma.tail.p, next: ma.head, prev: null};
              ma.head.prev = pp;
              ma.head = pp;
              ma.closed = true;
              break;
          }

        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
        // one sequence needs to be reversed
          switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
          case 0:   // tail-tail
            // reverse ma and append to mb
              reverseList(ma);
            // fall through to head/tail case
          case 1:   // head-tail
            // ma is appended to mb and ma discarded
              mb.tail.next = ma.head;
              ma.head.prev = mb.tail;
              mb.tail = ma.tail;

            //discard ma sequence record
              this.remove_seq(ma);
              break;

          case 3:   // head-head
            // reverse ma and append mb to it
              reverseList(ma);
            // fall through to tail/head case
          case 2:   // tail-head
            // mb is appended to ma and mb is discarded
              ma.tail.next = mb.head;
              mb.head.prev = ma.tail;
              ma.tail = mb.tail;

            //discard mb sequence record
              this.remove_seq(mb);
              break;
          }
      }
  };

  /*
   * Implements CONREC.
   *
   * @private
   * @param {function} drawContour function for drawing contour.  Defaults to a
   *                               custom "contour builder", which populates the
   *                               contours property.
   */
  function Conrec(drawContour) {
      if (!drawContour) {
          var c = this;
          c.contours = {};
      /**
       * drawContour - interface for implementing the user supplied method to
       * render the countours.
       *
       * Draws a line between the start and end coordinates.
       *
       * @private
       * @param startX    - start coordinate for X
       * @param startY    - start coordinate for Y
       * @param endX      - end coordinate for X
       * @param endY      - end coordinate for Y
       * @param contourLevel - Contour level for line.
       */
          this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {
              var cb = c.contours[k];
              if (!cb) {
                  cb = c.contours[k] = new ContourBuilder(contourLevel);
              }
              cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
          };
          this.contourList = function () {
              var l = [];
              var a = c.contours;
              for (var k in a) {
                  var s = a[k].s;
                  var level = a[k].level;
                  while (s) {
                      var h = s.head;
                      var l2 = [];
                      l2.level = level;
                      l2.k = k;
                      while (h && h.p) {
                          l2.push(h.p);
                          h = h.next;
                      }
                      l.push(l2);
                      s = s.next;
                  }
              }
              l.sort(function (a, b) { return a.k - b.k; });
              return l;
          };
      } else {
          this.drawContour = drawContour;
      }
      this.h  = new Array(5);
      this.sh = new Array(5);
      this.xh = new Array(5);
      this.yh = new Array(5);
  }

  /*
   * contour is a contouring subroutine for rectangularily spaced data
   *
   * It emits calls to a line drawing subroutine supplied by the user which
   * draws a contour map corresponding to real*4data on a randomly spaced
   * rectangular grid. The coordinates emitted are in the same units given in
   * the x() and y() arrays.
   *
   * Any number of contour levels may be specified but they must be in order of
   * increasing value.
   *
   *
   * @param {number[][]} d - matrix of data to contour
   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
   *
   *             The following two, one dimensional arrays (x and y) contain
   *             the horizontal and vertical coordinates of each sample points.
   * @param {number[]} x  - data matrix column coordinates
   * @param {number[]} y  - data matrix row coordinates
   * @param {number} nc   - number of contour levels
   * @param {number[]} z  - contour levels in increasing order.
   */
  Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {
      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
      var drawContour = this.drawContour;
      this.contours = {};

      var xsect = function (p1, p2) {
          return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
      };

      var ysect = function (p1, p2) {
          return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
      };
      var m1;
      var m2;
      var m3;
      var case_value;
      var dmin;
      var dmax;
      var x1 = 0.0;
      var x2 = 0.0;
      var y1 = 0.0;
      var y2 = 0.0;

    // The indexing of im and jm should be noted as it has to start from zero
    // unlike the fortran counter part
      var im = [0, 1, 1, 0];
      var jm = [0, 0, 1, 1];

    // Note that castab is arranged differently from the FORTRAN code because
    // Fortran and C/C++ arrays are transposed of each other, in this case
    // it is more tricky as castab is in 3 dimensions
      var castab = [
          [
        [0, 0, 8], [0, 2, 5], [7, 6, 9]
          ],
          [
        [0, 3, 4], [1, 3, 1], [4, 3, 0]
          ],
          [
        [9, 6, 7], [5, 2, 0], [8, 0, 0]
          ]
      ];

      for (var j = (jub - 1); j >= jlb; j--) {
          for (var i = ilb; i <= iub - 1; i++) {
              var temp1, temp2;
              temp1 = Math.min(d[i][j], d[i][j + 1]);
              temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);
              dmin  = Math.min(temp1, temp2);
              temp1 = Math.max(d[i][j], d[i][j + 1]);
              temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);
              dmax  = Math.max(temp1, temp2);

              if (dmax >= z[0] && dmin <= z[nc - 1]) {
                  for (var k = 0; k < nc; k++) {
                      if (z[k] >= dmin && z[k] <= dmax) {
                          for (var m = 4; m >= 0; m--) {
                            if (m > 0) {
                  // The indexing of im and jm should be noted as it has to
                  // start from zero
                              h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];
                              xh[m] = x[i + im[m - 1]];
                              yh[m] = y[j + jm[m - 1]];
                          } else {
                              h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                              xh[0] = 0.5 * (x[i] + x[i + 1]);
                              yh[0] = 0.5 * (y[j] + y[j + 1]);
                          }
                            if (h[m] > EPSILON) {
                              sh[m] = 1;
                          } else if (h[m] < -EPSILON) {
                            sh[m] = -1;
                        } else
                  sh[m] = 0;
                        }
              //
              // Note: at this stage the relative heights of the corners and the
              // centre are in the h array, and the corresponding coordinates are
              // in the xh and yh arrays. The centre of the box is indexed by 0
              // and the 4 corners by 1 to 4 as shown below.
              // Each triangle is then indexed by the parameter m, and the 3
              // vertices of each triangle are indexed by parameters m1,m2,and
              // m3.
              // It is assumed that the centre of the box is always vertex 2
              // though this isimportant only when all 3 vertices lie exactly on
              // the same contour level, in which case only the side of the box
              // is drawn.
              //
              //
              //      vertex 4 +-------------------+ vertex 3
              //               | \               / |
              //               |   \    m-3    /   |
              //               |     \       /     |
              //               |       \   /       |
              //               |  m=2    X   m=2   |       the centre is vertex 0
              //               |       /   \       |
              //               |     /       \     |
              //               |   /    m=1    \   |
              //               | /               \ |
              //      vertex 1 +-------------------+ vertex 2
              //
              //
              //
              //               Scan each triangle in the box
              //
                          for (m = 1; m <= 4; m++) {
                            m1 = m;
                            m2 = 0;
                            if (m != 4) {
                              m3 = m + 1;
                          } else {
                              m3 = 1;
                          }
                            case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                            if (case_value != 0) {
                              switch (case_value) {
                            case 1: // Line between vertices 1 and 2
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xh[m2];
                                y2 = yh[m2];
                                break;
                            case 2: // Line between vertices 2 and 3
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xh[m3];
                                y2 = yh[m3];
                                break;
                            case 3: // Line between vertices 3 and 1
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xh[m1];
                                y2 = yh[m1];
                                break;
                            case 4: // Line between vertex 1 and side 2-3
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 5: // Line between vertex 2 and side 3-1
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 6: //  Line between vertex 3 and side 1-2
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            case 7: // Line between sides 1-2 and 2-3
                                x1 = xsect(m1, m2);
                                y1 = ysect(m1, m2);
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 8: // Line between sides 2-3 and 3-1
                                x1 = xsect(m2, m3);
                                y1 = ysect(m2, m3);
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 9: // Line between sides 3-1 and 1-2
                                x1 = xsect(m3, m1);
                                y1 = ysect(m3, m1);
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            default:
                                break;
                            }
                  // Put your processing code here and comment out the printf
                  //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                              drawContour(x1, y1, x2, y2, z[k], k);
                          }
                        }
                      }
                  }
              }
          }
      }
  };


/***/ }),

/***/ "./node_modules/turf-isolines/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-isolines/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//https://github.com/jasondavies/conrec.js
//http://stackoverflow.com/questions/263305/drawing-a-topographical-map
var tin = __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js");
var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var grid = __webpack_require__(/*! turf-grid */ "./node_modules/turf-grid/index.js");
var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js");
var planepoint = __webpack_require__(/*! turf-planepoint */ "./node_modules/turf-planepoint/index.js");
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var square = __webpack_require__(/*! turf-square */ "./node_modules/turf-square/index.js");
var Conrec = __webpack_require__(/*! ./conrec */ "./node_modules/turf-isolines/conrec.js");

/**
 * Takes {@link Point|points} with z-values and an array of
 * value breaks and generates [isolines](http://en.wikipedia.org/wiki/Isoline).
 *
 * @name isolines
 * @param {FeatureCollection<Point>} points input points
 * @param {string} z the property name in `points` from which z-values will be pulled
 * @param {number} resolution resolution of the underlying grid
 * @param {Array<number>} breaks where to draw contours
 * @returns {FeatureCollection<LineString>} isolines
 * @example
 * // create random points with random
 * // z-values in their properties
 * var points = turf.random('point', 100, {
 *   bbox: [0, 30, 20, 50]
 * });
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = Math.random() * 10;
 * }
 * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * var isolined = turf.isolines(points, 'z', 15, breaks);
 * //=isolined
 */
module.exports = function (points, z, resolution, breaks) {
    var tinResult = tin(points, z);
    var bboxBBox = bbox(points);
    var squareBBox = square(bboxBBox);
    var gridResult = grid(squareBBox, resolution);
    var data = [];

    for (var i = 0; i < gridResult.features.length; i++) {
        var pt = gridResult.features[i];
        for (var j = 0; j < tinResult.features.length; j++) {
            var triangle = tinResult.features[j];
            if (inside(pt, triangle)) {
                pt.properties = {};
                pt.properties[z] = planepoint(pt, triangle);
            }
        }
    }

    var depth = Math.sqrt(gridResult.features.length);
    for (var x = 0; x < depth; x++) {
        var xGroup = gridResult.features.slice(x * depth, (x + 1) * depth);
        var xFlat = [];

        for (var g = 0; g < xGroup.length; g++) {
            if (xGroup[g].properties) {
                xFlat.push(xGroup[g].properties[z]);
            } else {
                xFlat.push(0);
            }
        }
        data.push(xFlat);
    }
    var interval = (squareBBox[2] - squareBBox[0]) / depth;
    var xCoordinates = [];
    var yCoordinates = [];
    for (var d = 0; d < depth; d++) {
        xCoordinates.push(d * interval + squareBBox[0]);
        yCoordinates.push(d * interval + squareBBox[1]);
    }

    var c = new Conrec();
    c.contour(data, 0, resolution, 0, resolution, xCoordinates, yCoordinates, breaks.length, breaks);
    var contourList = c.contourList();

    var fc = featurecollection([]);
    contourList.forEach(function (c) {
        if (c.length > 2) {
            var polyCoordinates = [];
            c.forEach(function (coord) {
                polyCoordinates.push([coord.x, coord.y]);
            });
            var poly = linestring(polyCoordinates);
            poly.properties = {};
            poly.properties[z] = c.level;

            fc.features.push(poly);
        }
    });

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-kinks/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-kinks/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Takes a {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.
 *
 * @name kinks
 * @param {Feature<Polygon>|Polygon} polygon input polygon
 * @returns {FeatureCollection<Point>} self-intersections
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-12.034835, 8.901183],
 *       [-12.060413, 8.899826],
 *       [-12.03638, 8.873199],
 *       [-12.059383, 8.871418],
 *       [-12.034835, 8.901183]
 *     ]]
 *   }
 * };
 *
 * var kinks = turf.kinks(poly);
 *
 * var resultFeatures = kinks.intersections.features.concat(poly);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

module.exports = function (polyIn) {
    var poly;
    var results = {
        type: 'FeatureCollection',
        features: []
    };
    if (polyIn.type === 'Feature') {
        poly = polyIn.geometry;
    } else {
        poly = polyIn;
    }
    poly.coordinates.forEach(function (ring1) {
        poly.coordinates.forEach(function (ring2) {
            for (var i = 0; i < ring1.length - 1; i++) {
                for (var k = 0; k < ring2.length - 1; k++) {
                    // don't check adjacent sides of a given ring, since of course they intersect in a vertex.
                    if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {
                        continue;
                    }

                    var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1],
                        ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);
                    if (intersection) {
                        results.features.push(point([intersection[0], intersection[1]]));
                    }
                }
            }
        });
    });
    return results;
};


// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2,
        result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/turf-line-distance/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-line-distance/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a {@link LineString|line} and measures its length in the specified units.
 *
 * @name lineDistance
 * @param {Feature<LineString>} line line to measure
 * @param {String} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Number} length of the input line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var length = turf.lineDistance(line, 'miles');
 *
 * //=line
 *
 * //=length
 */
module.exports = function lineDistance(line, units) {
    if (line.type === 'FeatureCollection') {
        return line.features.reduce(function (memo, feature) {
            return memo + lineDistance(feature, units);
        }, 0);
    }

    var geometry = line.type === 'Feature' ? line.geometry : line;
    var d, i;

    if (geometry.type === 'LineString') {
        return length(geometry.coordinates, units);
    } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        d = 0;
        for (i = 0; i < geometry.coordinates.length; i++) {
            d += length(geometry.coordinates[i], units);
        }
        return d;
    } else if (line.type === 'MultiPolygon') {
        d = 0;
        for (i = 0; i < geometry.coordinates.length; i++) {
            for (var j = 0; j < geometry.coordinates[i].length; j++) {
                d += length(geometry.coordinates[i][j], units);
            }
        }
        return d;
    } else {
        throw new Error('input must be a LineString, MultiLineString, ' +
            'Polygon, or MultiPolygon Feature or Geometry (or a FeatureCollection ' +
            'containing only those types)');
    }

};

function length(coords, units) {
    var travelled = 0;
    var prevCoords = point(coords[0]);
    var curCoords = point(coords[0]);
    var temp;
    for (var i = 1; i < coords.length; i++) {
        curCoords.geometry.coordinates = coords[i];
        travelled += distance(prevCoords, curCoords, units);
        temp = prevCoords;
        prevCoords = curCoords;
        curCoords = temp;
    }
    return travelled;
}


/***/ }),

/***/ "./node_modules/turf-line-slice/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-line-slice/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var pointOnLine = __webpack_require__(/*! turf-point-on-line */ "./node_modules/turf-point-on-line/index.js");

/**
 * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
 * and returns a subsection of the line in-between those points.
 * The start & stop points don't need to fall exactly on the line.
 *
 * This can be useful for extracting only the part of a route between waypoints.
 *
 * @name lineSlice
 * @param {Feature<Point>} point1 starting point
 * @param {Feature<Point>} point2 stopping point
 * @param {Feature<LineString>|LineString} line line to slice
 * @return {Feature<LineString>} sliced line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var start = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.029609, 38.881946]
 *   }
 * };
 * var stop = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.021884, 38.889563]
 *   }
 * };
 *
 * var sliced = turf.lineSlice(start, stop, line);
 *
 * //=line
 *
 * //=sliced
 */

module.exports = function lineSlice(startPt, stopPt, line) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    var startVertex = pointOnLine(line, startPt);
    var stopVertex = pointOnLine(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
    } else {
        ends = [stopVertex, startVertex];
    }
    var clipLine = linestring([ends[0].geometry.coordinates], {});
    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
        clipLine.geometry.coordinates.push(coords[i]);
    }
    clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);
    return clipLine;
};


/***/ }),

/***/ "./node_modules/turf-meta/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-meta/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
    var i, j, k, g, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        isGeometryCollection,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            coords = geometry.coordinates;

            wrapShrink = (excludeWrapCoord &&
                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                1 : 0;

            if (geometry.type === 'Point') {
                callback(coords);
            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                for (j = 0; j < coords.length; j++) callback(coords[j]);
            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++)
                        callback(coords[j][k]);
            } else if (geometry.type === 'MultiPolygon') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++)
                            callback(coords[j][k][l]);
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}
module.exports.coordEach = coordEach;

/**
 * Reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @return {*} combined value
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
    coordEach(layer, function (coord) {
        memo = callback(memo, coord);
    }, excludeWrapCoord);
    return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
    var i;
    switch (layer.type) {
    case 'FeatureCollection':
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
    case 'Feature':
        callback(layer.properties);
        break;
    }
}
module.exports.propEach = propEach;

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @return {*} combined value
 */
function propReduce(layer, callback, memo) {
    propEach(layer, function (prop) {
        memo = callback(memo, prop);
    });
    return memo;
}
module.exports.propReduce = propReduce;

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var feature = { type: 'Feature', geometry: null, properties: {} };
 * featureEach(feature, function(feature) {
 *   // feature == feature
 * });
 */
function featureEach(layer, callback) {
    if (layer.type === 'Feature') {
        callback(layer);
    } else if (layer.type === 'FeatureCollection') {
        for (var i = 0; i < layer.features.length; i++) {
            callback(layer.features[i]);
        }
    }
}
module.exports.featureEach = featureEach;

/**
 * Get all coordinates from any GeoJSON object, returning an array of coordinate
 * arrays.
 * @param {Object} layer any GeoJSON object
 * @return {Array<Array<Number>>} coordinate position array
 */
function coordAll(layer) {
    var coords = [];
    coordEach(layer, function (coord) {
        coords.push(coord);
    });
    return coords;
}
module.exports.coordAll = coordAll;


/***/ }),

/***/ "./node_modules/turf-midpoint/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-midpoint/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes two {@link Point|points} and returns a point midway between them.
 * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
 *
 * @name midpoint
 * @param {Feature<Point>} from first point
 * @param {Feature<Point>} to second point
 * @return {Feature<Point>} a point midway between `pt1` and `pt2`
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [144.834823, -37.771257]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [145.14244, -37.830937]
 *   }
 * };
 *
 * var midpointed = turf.midpoint(pt1, pt2);
 * midpointed.properties['marker-color'] = '#f00';
 *
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, midpointed]
 * };
 *
 * //=result
 */
module.exports = function (from, to) {
    var dist = distance(from, to, 'miles');
    var heading = bearing(from, to);
    var midpoint = destination(from, dist / 2, heading, 'miles');

    return midpoint;
};


/***/ }),

/***/ "./node_modules/turf-nearest/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-nearest/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a reference {@link Point|point} and a FeatureCollection of Features
 * with Point geometries and returns the
 * point from the FeatureCollection closest to the reference. This calculation
 * is geodesic.
 *
 * @name nearest
 * @param {Feature<Point>} targetPoint the reference point
 * @param {FeatureCollection<Point>} points against input point set
 * @return {Feature<Point>} the closest point in the set to the reference point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [28.965797, 41.010086]
 *   }
 * };
 * var against = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.973865, 41.011122]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.948459, 41.024204]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.938674, 41.013324]
 *       }
 *     }
 *   ]
 * };
 *
 * var nearest = turf.nearest(point, against);
 * nearest.properties['marker-color'] = '#f00';
 *
 * var resultFeatures = against.features.concat(point);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (targetPoint, points) {
    var nearestPoint, minDist = Infinity;
    for (var i = 0; i < points.features.length; i++) {
        var distanceToPoint = distance(targetPoint, points.features[i], 'miles');
        if (distanceToPoint < minDist) {
            nearestPoint = points.features[i];
            minDist = distanceToPoint;
        }
    }
    return nearestPoint;
};


/***/ }),

/***/ "./node_modules/turf-planepoint/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-planepoint/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Takes a triangular plane as a {@link Polygon}
 * and a {@link Point} within that triangle and returns the z-value
 * at that point. The Polygon needs to have properties `a`, `b`, and `c`
 * that define the values at its three corners.
 *
 * @name planepoint
 * @param {Feature<Point>} point the Point for which a z-value will be calculated
 * @param {Feature<Polygon>} triangle a Polygon feature with three vertices
 * @return {Number} the z-value for `interpolatedPoint`
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.3221, 39.529]
 *   }
 * };
 * var point = turf.point([-75.3221, 39.529]);
 * // triangle is a polygon with "a", "b",
 * // and "c" values representing
 * // the values of the coordinates in order.
 * var triangle = {
 *   "type": "Feature",
 *   "properties": {
 *     "a": 11,
 *     "b": 122,
 *     "c": 44
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-75.1221, 39.57],
 *       [-75.58, 39.18],
 *       [-75.97, 39.86],
 *       [-75.1221, 39.57]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [triangle, point]
 * };
 *
 * var zValue = turf.planepoint(point, triangle);
 *
 * //=features
 *
 * //=zValue
 */
module.exports = function (point, triangle) {
    var x = point.geometry.coordinates[0],
        y = point.geometry.coordinates[1],
        x1 = triangle.geometry.coordinates[0][0][0],
        y1 = triangle.geometry.coordinates[0][0][1],
        z1 = triangle.properties.a,
        x2 = triangle.geometry.coordinates[0][1][0],
        y2 = triangle.geometry.coordinates[0][1][1],
        z2 = triangle.properties.b,
        x3 = triangle.geometry.coordinates[0][2][0],
        y3 = triangle.geometry.coordinates[0][2][1],
        z3 = triangle.properties.c;

    var z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) -
      z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) /
      ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) -
       (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));

    return z;
};


/***/ }),

/***/ "./node_modules/turf-point-grid/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-point-grid/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
/**
 * Takes a bounding box and a cell depth and returns a set of {@link Point|points} in a grid.
 *
 * @name pointGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize the distance across each cell
 * @param {string} [units=kilometers] used in calculating cellWidth, can be degrees, radians, miles, or kilometers
 * @return {FeatureCollection<Point>} grid of points
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var cellWidth = 3;
 * var units = 'miles';
 *
 * var grid = turf.pointGrid(extent, cellWidth, units);
 *
 * //=grid
 */
module.exports = function pointGrid(bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            fc.features.push(point([currentX, currentY]));

            currentY += cellHeight;
        }
        currentX += cellWidth;
    }

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-point-on-line/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-point-on-line/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");

/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.
 *
 * @name pointOnLine
 * @param {Feature<LineString>} line line to snap to
 * @param {Feature<Point>} point point to snap from
 * @return {Feature<Point>} closest point on the `line` to `point`
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.037076, 38.884017]
 *   }
 * };
 *
 * var snapped = turf.pointOnLine(line, pt);
 * snapped.properties['marker-color'] = '#00f'
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, pt, snapped]
 * };
 *
 * //=result
 */

module.exports = function (line, pt) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    return pointOnLine(pt, coords);
};

function pointOnLine(pt, coords) {
    var units = 'miles';
    var closestPt = point([Infinity, Infinity], {
        dist: Infinity
    });
    for (var i = 0; i < coords.length - 1; i++) {
        var start = point(coords[i]);
        var stop = point(coords[i + 1]);
        //start
        start.properties.dist = distance(pt, start, units);
        //stop
        stop.properties.dist = distance(pt, stop, units);
        //perpendicular
        var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
        var direction = bearing(start, stop);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
        var intersect = lineIntersects(
        perpendicularPt1.geometry.coordinates[0],
        perpendicularPt1.geometry.coordinates[1],
        perpendicularPt2.geometry.coordinates[0],
        perpendicularPt2.geometry.coordinates[1],
        start.geometry.coordinates[0],
        start.geometry.coordinates[1],
        stop.geometry.coordinates[0],
        stop.geometry.coordinates[1]
        );
        var intersectPt;
        if (intersect) {
            intersectPt = point(intersect);
            intersectPt.properties.dist = distance(pt, intersectPt, units);
        }

        if (start.properties.dist < closestPt.properties.dist) {
            closestPt = start;
            closestPt.properties.index = i;
        }
        if (stop.properties.dist < closestPt.properties.dist) {
            closestPt = stop;
            closestPt.properties.index = i;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
            closestPt = intersectPt;
            closestPt.properties.index = i;
        }
    }

    return closestPt;
}

// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2;
    var result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/turf-point-on-surface/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/turf-point-on-surface/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var centroid = __webpack_require__(/*! turf-center */ "./node_modules/turf-center/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var explode = __webpack_require__(/*! turf-explode */ "./node_modules/turf-explode/index.js");

/**
 * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.
 *
 * * Given a {@link Polygon}, the point will be in the area of the polygon
 * * Given a {@link LineString}, the point will be along the string
 * * Given a {@link Point}, the point will the same as the input
 *
 * @param {(Feature|FeatureCollection)} fc any feature or set of features
 * @returns {Feature} a point on the surface of `input`
 * @example
 * // create a random polygon
 * var polygon = turf.random('polygon');
 *
 * //=polygon
 *
 * var pointOnPolygon = turf.pointOnSurface(polygon);
 *
* var resultFeatures = polygon.features.concat(pointOnPolygon);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
 *
 * //=result
 */
function pointOnSurface(fc) {
    // normalize
    if (fc.type !== 'FeatureCollection') {
        if (fc.type !== 'Feature') {
            fc = {
                type: 'Feature',
                geometry: fc,
                properties: {}
            };
        }
        fc = featureCollection([fc]);
    }

    //get centroid
    var cent = centroid(fc);

    // check to see if centroid is on surface
    var onSurface = false;
    var i = 0;
    while (!onSurface && i < fc.features.length) {
        var geom = fc.features[i].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === 'Point') {
            if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
        cent.geometry.coordinates[1] === geom.coordinates[1]) {
                onSurface = true;
            }
        } else if (geom.type === 'MultiPoint') {
            var onMultiPoint = false;
            k = 0;
            while (!onMultiPoint && k < geom.coordinates.length) {
                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
          cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                    onSurface = true;
                    onMultiPoint = true;
                }
                k++;
            }
        } else if (geom.type === 'LineString') {
            k = 0;
            while (!onLine && k < geom.coordinates.length - 1) {
                x = cent.geometry.coordinates[0];
                y = cent.geometry.coordinates[1];
                x1 = geom.coordinates[k][0];
                y1 = geom.coordinates[k][1];
                x2 = geom.coordinates[k + 1][0];
                y2 = geom.coordinates[k + 1][1];
                if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                    onLine = true;
                    onSurface = true;
                }
                k++;
            }
        } else if (geom.type === 'MultiLineString') {
            var j = 0;
            while (j < geom.coordinates.length) {
                onLine = false;
                k = 0;
                var line = geom.coordinates[j];
                while (!onLine && k < line.length - 1) {
                    x = cent.geometry.coordinates[0];
                    y = cent.geometry.coordinates[1];
                    x1 = line[k][0];
                    y1 = line[k][1];
                    x2 = line[k + 1][0];
                    y2 = line[k + 1][1];
                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                        onLine = true;
                        onSurface = true;
                    }
                    k++;
                }
                j++;
            }
        } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
            var f = {
                type: 'Feature',
                geometry: geom,
                properties: {}
            };
            if (inside(cent, f)) {
                onSurface = true;
            }
        }
        i++;
    }
    if (onSurface) {
        return cent;
    } else {
        var vertices = featureCollection([]);
        for (i = 0; i < fc.features.length; i++) {
            vertices.features = vertices.features.concat(explode(fc.features[i]).features);
        }
        var closestVertex;
        var closestDistance = Infinity;
        for (i = 0; i < vertices.features.length; i++) {
            var dist = distance(cent, vertices.features[i], 'miles');
            if (dist < closestDistance) {
                closestDistance = dist;
                closestVertex = vertices.features[i];
            }
        }
        return closestVertex;
    }
}

function pointOnSegment(x, y, x1, y1, x2, y2) {
    var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
    if (ab === ap + pb) {
        return true;
    }
}

module.exports = pointOnSurface;


/***/ }),

/***/ "./node_modules/turf-point/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-point/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @module turf/point
 * @category helper
 * @param {number} longitude position west to east in decimal degrees
 * @param {number} latitude position south to north in decimal degrees
 * @param {Object} properties an Object that is used as the {@link Feature}'s
 * properties
 * @return {Point} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
var isArray = Array.isArray || function(arg) {
  return Object.prototype.toString.call(arg) === '[object Array]';
};
module.exports = function(coordinates, properties) {
  if (!isArray(coordinates)) throw new Error('Coordinates must be an array');
  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: coordinates
    },
    properties: properties || {}
  };
};


/***/ }),

/***/ "./node_modules/turf-random/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-random/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var random = __webpack_require__(/*! geojson-random */ "./node_modules/geojson-random/index.js");

/**
 * Generates random {@link GeoJSON} data, including {@link Point|Points} and {@link Polygon|Polygons}, for testing
 * and experimentation.
 *
 * @name random
 * @param {String} [type='point'] type of features desired: 'points' or 'polygons'
 * @param {Number} [count=1] how many geometries should be generated.
 * @param {Object} options options relevant to the feature desired. Can include:
 * @param {Array<number>} options.bbox a bounding box inside of which geometries
 * are placed. In the case of {@link Point} features, they are guaranteed to be within this bounds,
 * while {@link Polygon} features have their centroid within the bounds.
 * @param {Number} [options.num_vertices=10] options.vertices the number of vertices added
 * to polygon features.
 * @param {Number} [options.max_radial_length=10] the total number of decimal
 * degrees longitude or latitude that a polygon can extent outwards to
 * from its center.
 * @return {FeatureCollection} generated random features
 * @example
 * var points = turf.random('points', 100, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=points
 *
 * var polygons = turf.random('polygons', 4, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=polygons
 */
module.exports = function (type, count, options) {
    options = options || {};
    count = count || 1;
    switch (type) {
    case 'point':
    case 'points':
    case undefined:
        return random.point(count, options.bbox);
    case 'polygon':
    case 'polygons':
        return random.polygon(
                count,
                options.num_vertices,
                options.max_radial_length,
                options.bbox);
    default:
        throw new Error('Unknown type given: valid options are points and polygons');
    }
};


/***/ }),

/***/ "./node_modules/turf-sample/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-sample/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array
var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
 *
 * @name sample
 * @param {FeatureCollection} featurecollection set of input features
 * @param {number} num number of features to select
 * @return {FeatureCollection} a FeatureCollection with `n` features
 * @example
 * var points = turf.random('points', 1000);
 *
 * //=points
 *
 * var sample = turf.sample(points, 10);
 *
 * //=sample
 */
module.exports = function (featurecollection, num) {
    var outFC = featureCollection(getRandomSubarray(featurecollection.features, num));
    return outFC;
};

function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
    while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}


/***/ }),

/***/ "./node_modules/turf-simplify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-simplify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var simplify = __webpack_require__(/*! simplify-js */ "./node_modules/simplify-js/simplify.js");

// supported GeoJSON geometries, used to check whether to wrap in simpleFeature()
var supportedTypes = ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Takes a {@link LineString} or {@link Polygon} and returns a simplified version. Internally uses [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.
 *
 * @name simplify
 * @param {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} feature feature to be simplified
 * @param {number} tolerance simplification tolerance
 * @param {boolean} highQuality whether or not to spend more time to create
 * a higher-quality simplification with a different algorithm
 * @return {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} a simplified feature
 * @example
  * var feature = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-70.603637, -33.399918],
 *       [-70.614624, -33.395332],
 *       [-70.639343, -33.392466],
 *       [-70.659942, -33.394759],
 *       [-70.683975, -33.404504],
 *       [-70.697021, -33.419406],
 *       [-70.701141, -33.434306],
 *       [-70.700454, -33.446339],
 *       [-70.694274, -33.458369],
 *       [-70.682601, -33.465816],
 *       [-70.668869, -33.472117],
 *       [-70.646209, -33.473835],
 *       [-70.624923, -33.472117],
 *       [-70.609817, -33.468107],
 *       [-70.595397, -33.458369],
 *       [-70.587158, -33.442901],
 *       [-70.587158, -33.426283],
 *       [-70.590591, -33.414248],
 *       [-70.594711, -33.406224],
 *       [-70.603637, -33.399918]
 *     ]]
 *   }
 * };

 * var tolerance = 0.01;
 *
 * var simplified = turf.simplify(
 *  feature, tolerance, false);
 *
 * //=feature
 *
 * //=simplified
 */
module.exports = function (feature, tolerance, highQuality) {
    if (feature.type === 'Feature') {
        return simpleFeature(
            simplifyHelper(feature, tolerance, highQuality),
            feature.properties);
    } else if (feature.type === 'FeatureCollection') {
        return {
            type: 'FeatureCollection',
            features: feature.features.map(function (f) {
                var simplified = simplifyHelper(f, tolerance, highQuality);

                // we create simpleFeature here because it doesn't apply to GeometryCollection
                // so we can't create it at simplifyHelper()
                if (supportedTypes.indexOf(simplified.type) > -1) {
                    return simpleFeature(simplified, f.properties);
                } else {
                    return simplified;
                }
            })
        };
    } else if (feature.type === 'GeometryCollection') {
        return {
            type: 'GeometryCollection',
            geometries: feature.geometries.map(function (g) {
                if (supportedTypes.indexOf(g.type) > -1) {
                    return simplifyHelper({
                        type: 'Feature',
                        geometry: g
                    }, tolerance, highQuality);
                }
                return g;
            })
        };
    } else {
        return feature;
    }
};


function simplifyHelper(feature, tolerance, highQuality) {
    if (feature.geometry.type === 'LineString') {
        return {
            type: 'LineString',
            coordinates: simplifyLine(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiLineString') {
        return {
            type: 'MultiLineString',
            coordinates: feature.geometry.coordinates.map(function (lines) {
                return simplifyLine(lines, tolerance, highQuality);
            })
        };
    } else if (feature.geometry.type === 'Polygon') {
        return {
            type: 'Polygon',
            coordinates: simplifyPolygon(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiPolygon') {
        return {
            type: 'MultiPolygon',
            coordinates: feature.geometry.coordinates.map(function (rings) {
                return simplifyPolygon(rings, tolerance, highQuality);
            })
        };
    } else {
        // unsupported geometry type supplied
        return feature;
    }
}

/*
* returns true if ring's first coordinate is the same as its last
*/
function checkValidity(ring) {
    if (ring.length < 3) {
        return false;
    //if the last point is the same as the first, it's not a triangle
    } else if (ring.length === 3 &&
      ((ring[2][0] === ring[0][0]) && (ring[2][1] === ring[0][1]))) {
        return false;
    } else {
        return true;
    }
}

function simpleFeature(geom, properties) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: properties
    };
}

function simplifyLine(coordinates, tolerance, highQuality) {
    return simplify(coordinates.map(function (coord) {
        return {x: coord[0], y: coord[1]};
    }), tolerance, highQuality).map(function (coords) {
        return [coords.x, coords.y];
    });
}

function simplifyPolygon(coordinates, tolerance, highQuality) {
    return coordinates.map(function (ring) {
        var pts = ring.map(function (coord) {
            return {x: coord[0], y: coord[1]};
        });
        if (pts.length < 4) {
            throw new Error('Invalid polygon');
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
            return [coords.x, coords.y];
        });
        //remove 1 percent of tolerance until enough points to make a triangle
        while (!checkValidity(simpleRing)) {
            tolerance -= tolerance * 0.01;
            simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
                return [coords.x, coords.y];
            });
        }
        if (
            (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0]) ||
                (simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1])) {
            simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
    });
}


/***/ }),

/***/ "./node_modules/turf-square-grid/index.js":
/*!************************************************!*\
  !*** ./node_modules/turf-square-grid/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and a cell depth and returns a set of square {@link Polygon|polygons} in a grid.
 *
 * @name squareGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize width of each cell
 * @param {string} units units to use for cellWidth
 * @return {FeatureCollection<Polygon>} grid a grid of polygons
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var squareGrid = turf.squareGrid(extent, cellWidth, units);
 *
 * //=squareGrid
 */
module.exports = function squareGrid(bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            var cellPoly = polygon([[
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
            ]]);
            fc.features.push(cellPoly);

            currentY += cellHeight;
        }
        currentX += cellWidth;
    }

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-square/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-square/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and calculates the minimum square bounding box that
 * would contain the input.
 *
 * @name square
 * @param {Array<number>} bbox a bounding box
 * @return {Array<number>} a square surrounding `bbox`
 * @example
 * var bbox = [-20,-20,-15,0];
 *
 * var squared = turf.square(bbox);
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     turf.bboxPolygon(bbox),
 *     turf.bboxPolygon(squared)
 *   ]
 * };
 *
 * //=features
 */
module.exports = function (bbox) {
    var horizontalDistance = distance(bbox.slice(0, 2), [bbox[2], bbox[1]], 'miles');
    var verticalDistance = distance(bbox.slice(0, 2), [bbox[0], bbox[3]], 'miles');
    if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (bbox[1] + bbox[3]) / 2;
        return [
            bbox[0],
            verticalMidpoint - ((bbox[2] - bbox[0]) / 2),
            bbox[2],
            verticalMidpoint + ((bbox[2] - bbox[0]) / 2)
        ];
    } else {
        var horizontalMidpoint = (bbox[0] + bbox[2]) / 2;
        return [
            horizontalMidpoint - ((bbox[3] - bbox[1]) / 2),
            bbox[1],
            horizontalMidpoint + ((bbox[3] - bbox[1]) / 2),
            bbox[3]
        ];
    }
};


/***/ }),

/***/ "./node_modules/turf-tag/index.js":
/*!****************************************!*\
  !*** ./node_modules/turf-tag/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and performs a spatial join.
 *
 * @name tag
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @param {string} field property in `polygons` to add to joined Point features
 * @param {string} outField property in `points` in which to store joined property from `polygons
 * @return {FeatureCollection<Point>} points with `containingPolyId` property containing values from `polyId`
 * @example
 * var bbox = [0, 0, 10, 10];
 * // create a triangular grid of polygons
 * var triangleGrid = turf.triangleGrid(bbox, 50, 'miles');
 * triangleGrid.features.forEach(function(f) {
 *   f.properties.fill = '#' +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16);
 *   f.properties.stroke = 0;
 *   f.properties['fill-opacity'] = 1;
 * });
 * var randomPoints = turf.random('point', 30, {
 *   bbox: bbox
 * });
 * var both = turf.featurecollection(
 *   triangleGrid.features.concat(randomPoints.features));
 *
 * //=both
 *
 * var tagged = turf.tag(randomPoints, triangleGrid,
 *                       'fill', 'marker-color');
 *
 * //=tagged
 */
module.exports = function (points, polygons, field, outField) {
    // prevent mutations
    points = JSON.parse(JSON.stringify(points));
    polygons = JSON.parse(JSON.stringify(polygons));
    points.features.forEach(function (pt) {
        if (!pt.properties) {
            pt.properties = {};
        }
        polygons.features.forEach(function (poly) {
            if (pt.properties[outField] === undefined) {
                var isInside = inside(pt, poly);
                if (isInside) {
                    pt.properties[outField] = poly.properties[field];
                }
            }
        });
    });
    return points;
};


/***/ }),

/***/ "./node_modules/turf-tesselate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-tesselate/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var earcut = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");

/**
 * Tesselates a {@link Feature<Polygon>} into a {@link FeatureCollection<Polygon>} of triangles
 * using [earcut](https://github.com/mapbox/earcut).
 *
 * @name tesselate
 * @param {Feature<Polygon>} polygon the polygon to tesselate
 * @returns {FeatureCollection<Polygon>} a geometrycollection feature
 * @example
 * var polygon = {"type":"Feature","id":"USA-CA","properties":{"name":"California"},"geometry":{"type":"Polygon","coordinates":[[[-123.233256,42.006186],[-122.378853,42.011663],[-121.037003,41.995232],[-120.001861,41.995232],[-119.996384,40.264519],[-120.001861,38.999346],[-118.71478,38.101128],[-117.498899,37.21934],[-116.540435,36.501861],[-115.85034,35.970598],[-114.634459,35.00118],[-114.634459,34.87521],[-114.470151,34.710902],[-114.333228,34.448009],[-114.136058,34.305608],[-114.256551,34.174162],[-114.415382,34.108438],[-114.535874,33.933176],[-114.497536,33.697668],[-114.524921,33.54979],[-114.727567,33.40739],[-114.661844,33.034958],[-114.524921,33.029481],[-114.470151,32.843265],[-114.524921,32.755634],[-114.72209,32.717295],[-116.04751,32.624187],[-117.126467,32.536556],[-117.24696,32.668003],[-117.252437,32.876127],[-117.329114,33.122589],[-117.471515,33.297851],[-117.7837,33.538836],[-118.183517,33.763391],[-118.260194,33.703145],[-118.413548,33.741483],[-118.391641,33.840068],[-118.566903,34.042715],[-118.802411,33.998899],[-119.218659,34.146777],[-119.278905,34.26727],[-119.558229,34.415147],[-119.875891,34.40967],[-120.138784,34.475393],[-120.472878,34.448009],[-120.64814,34.579455],[-120.609801,34.858779],[-120.670048,34.902595],[-120.631709,35.099764],[-120.894602,35.247642],[-120.905556,35.450289],[-121.004141,35.461243],[-121.168449,35.636505],[-121.283465,35.674843],[-121.332757,35.784382],[-121.716143,36.195153],[-121.896882,36.315645],[-121.935221,36.638785],[-121.858544,36.6114],[-121.787344,36.803093],[-121.929744,36.978355],[-122.105006,36.956447],[-122.335038,37.115279],[-122.417192,37.241248],[-122.400761,37.361741],[-122.515777,37.520572],[-122.515777,37.783465],[-122.329561,37.783465],[-122.406238,38.15042],[-122.488392,38.112082],[-122.504823,37.931343],[-122.701993,37.893004],[-122.937501,38.029928],[-122.97584,38.265436],[-123.129194,38.451652],[-123.331841,38.566668],[-123.44138,38.698114],[-123.737134,38.95553],[-123.687842,39.032208],[-123.824765,39.366301],[-123.764519,39.552517],[-123.85215,39.831841],[-124.109566,40.105688],[-124.361506,40.259042],[-124.410798,40.439781],[-124.158859,40.877937],[-124.109566,41.025814],[-124.158859,41.14083],[-124.065751,41.442061],[-124.147905,41.715908],[-124.257444,41.781632],[-124.213628,42.000709],[-123.233256,42.006186]]]}};
 *
 * var triangles = turf.tesselate(polygon);
 *
 * //=triangles
 */

module.exports = function (poly) {
    if (!poly.geometry || (poly.geometry.type !== 'Polygon' && poly.geometry.type !== 'MultiPolygon')) {
        throw new Error('input must be a Polygon or MultiPolygon');
    }

    var fc = {type: 'FeatureCollection', features: []};

    if (poly.geometry.type === 'Polygon') {
        fc.features = processPolygon(poly.geometry.coordinates);
    } else {
        poly.geometry.coordinates.forEach(function (coordinates) {
            fc.features = fc.features.concat(processPolygon(coordinates));
        });
    }

    return fc;
};

function processPolygon(coordinates) {
    var data = flattenCoords(coordinates);
    var dim = 2;
    var result = earcut(data.vertices, data.holes, dim);

    var features = [];
    var vertices = [];

    result.forEach(function (vert, i) {
        var index = result[i];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
    });

    for (var i = 0; i < vertices.length; i += 3) {
        var coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push(polygon([coords]));
    }

    return features;
}

function flattenCoords(data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }

    return result;
}


/***/ }),

/***/ "./node_modules/turf-tin/index.js":
/*!****************************************!*\
  !*** ./node_modules/turf-tin/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//http://en.wikipedia.org/wiki/Delaunay_triangulation
//https://github.com/ironwallaby/delaunay
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a set of {@link Point|points} and the name of a z-value property and
 * creates a [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
 * or a TIN for short, returned as a collection of Polygons. These are often used
 * for developing elevation contour maps or stepped heat visualizations.
 *
 * This triangulates the points, as well as adds properties called `a`, `b`,
 * and `c` representing the value of the given `propertyName` at each of
 * the points that represent the corners of the triangle.
 *
 * @name tin
 * @param {FeatureCollection<Point>} points input points
 * @param {String=} z name of the property from which to pull z values
 * This is optional: if not given, then there will be no extra data added to the derived triangles.
 * @return {FeatureCollection<Polygon>} TIN output
 * @example
 * // generate some random point data
 * var points = turf.random('points', 30, {
 *   bbox: [50, 30, 70, 50]
 * });
 * //=points
 * // add a random property to each point between 0 and 9
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = ~~(Math.random() * 9);
 * }
 * var tin = turf.tin(points, 'z')
 * for (var i = 0; i < tin.features.length; i++) {
 *   var properties  = tin.features[i].properties;
 *   // roughly turn the properties of each
 *   // triangle into a fill color
 *   // so we can visualize the result
 *   properties.fill = '#' + properties.a +
 *     properties.b + properties.c;
 * }
 * //=tin
 */
module.exports = function (points, z) {
    //break down points
    return featurecollection(triangulate(points.features.map(function (p) {
        var point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1]
        };
        if (z) point.z = p.properties[z];
        return point;
    })).map(function (triangle) {
        return polygon([[
        [triangle.a.x, triangle.a.y],
        [triangle.b.x, triangle.b.y],
        [triangle.c.x, triangle.c.y],
        [triangle.a.x, triangle.a.y]
        ]], {
            a: triangle.a.z,
            b: triangle.b.z,
            c: triangle.c.z
        });
    }));
};

function Triangle(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;

    var A = b.x - a.x,
        B = b.y - a.y,
        C = c.x - a.x,
        D = c.y - a.y,
        E = A * (a.x + b.x) + B * (a.y + b.y),
        F = C * (a.x + c.x) + D * (a.y + c.y),
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
        minx, miny, dx, dy;

    // If the points of the triangle are collinear, then just find the
    // extremes and use the midpoint as the center of the circumcircle.
    if (Math.abs(G) < 0.000001) {
        minx = Math.min(a.x, b.x, c.x);
        miny = Math.min(a.y, b.y, c.y);
        dx = (Math.max(a.x, b.x, c.x) - minx) * 0.5;
        dy = (Math.max(a.y, b.y, c.y) - miny) * 0.5;

        this.x = minx + dx;
        this.y = miny + dy;
        this.r = dx * dx + dy * dy;
    } else {
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }
}

function byX(a, b) {
    return b.x - a.x;
}

function dedup(edges) {
    var j = edges.length,
        a, b, i, m, n;

    outer:
  while (j) {
      b = edges[--j];
      a = edges[--j];
      i = j;
      while (i) {
          n = edges[--i];
          m = edges[--i];
          if ((a === m && b === n) || (a === n && b === m)) {
              edges.splice(j, 2);
              edges.splice(i, 2);
              j -= 2;
              continue outer;
          }
      }
  }
}

function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3)
        return [];

    // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.
    vertices.sort(byX);

    var i = vertices.length - 1,
        xmin = vertices[i].x,
        xmax = vertices[0].x,
        ymin = vertices[i].y,
        ymax = ymin;

    while (i--) {
        if (vertices[i].y < ymin)
            ymin = vertices[i].y;
        if (vertices[i].y > ymax)
            ymax = vertices[i].y;
    }

    //Find a supertriangle, which is a triangle that surrounds all the
    //vertices. This is used like something of a sentinel value to remove
    //cases in the main algorithm, and is removed before we return any
    // results.

    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)
    var dx = xmax - xmin,
        dy = ymax - ymin,
        dmax = (dx > dy) ? dx : dy,
        xmid = (xmax + xmin) * 0.5,
        ymid = (ymax + ymin) * 0.5,
        open = [
            new Triangle({
                x: xmid - 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }, {
                x: xmid,
                y: ymid + 20 * dmax,
                __sentinel: true
            }, {
                x: xmid + 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }
        )],
        closed = [],
        edges = [],
        j, a, b;

    // Incrementally add each vertex to the mesh.
    i = vertices.length;
    while (i--) {
        // For each open triangle, check to see if the current point is
        // inside it's circumcircle. If it is, remove the triangle and add
        // it's edges to an edge list.
        edges.length = 0;
        j = open.length;
        while (j--) {
            // If this point is to the right of this triangle's circumcircle,
            // then this triangle should never get checked again. Remove it
            // from the open list, add it to the closed list, and skip.
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }

            // If not, skip this triangle.
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r)
                continue;

            // Remove the triangle and add it's edges to the edge list.
            edges.push(
        open[j].a, open[j].b,
        open[j].b, open[j].c,
        open[j].c, open[j].a
      );
            open.splice(j, 1);
        }

        // Remove any doubled edges.
        dedup(edges);

        // Add a new triangle for each edge.
        j = edges.length;
        while (j) {
            b = edges[--j];
            a = edges[--j];
            open.push(new Triangle(a, b, vertices[i]));
        }
    }

    // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.
    Array.prototype.push.apply(closed, open);

    i = closed.length;
    while (i--)
        if (closed[i].a.__sentinel ||
      closed[i].b.__sentinel ||
      closed[i].c.__sentinel)
            closed.splice(i, 1);

    return closed;
}


/***/ }),

/***/ "./node_modules/turf-triangle-grid/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-triangle-grid/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
 *
 * @name triangleGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of each cell
 * @param {string} units units to use for cellWidth
 * @return {FeatureCollection<Polygon>} grid of polygons
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var triangleGrid = turf.triangleGrid(extent, cellWidth, units);
 *
 * //=triangleGrid
 */
module.exports = function (bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var xi = 0;
    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            if (xi % 2 === 0 && yi % 2 === 0) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            } else if (xi % 2 === 0 && yi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 0 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 1 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return fc;
};



/***/ }),

/***/ "./node_modules/turf-union/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-union/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// look here for help http://svn.osgeo.org/grass/grass/branches/releasebranch_6_4/vector/v.overlay/main.c
//must be array of polygons

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html

var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Takes two {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {Feature<Polygon>} poly1 input polygon
 * @param {Feature<Polygon>} poly2 another input polygon
 * @return {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.574787, 35.594087],
 *       [-82.574787, 35.615581],
 *       [-82.545261, 35.615581],
 *       [-82.545261, 35.594087],
 *       [-82.574787, 35.594087]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.560024, 35.585153],
 *       [-82.560024, 35.602602],
 *       [-82.52964, 35.602602],
 *       [-82.52964, 35.585153],
 *       [-82.560024, 35.585153]
 *     ]]
 *   }
 * };
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var union = turf.union(poly1, poly2);
 *
 * //=polygons
 *
 * //=union
 */
module.exports = function (poly1, poly2) {
    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(poly1.geometry));
    var b = reader.read(JSON.stringify(poly2.geometry));
    var union = a.union(b);
    var writer = new jsts.io.GeoJSONWriter();

    union = writer.write(union);
    return {
        type: 'Feature',
        geometry: union,
        properties: poly1.properties
    };
};


/***/ }),

/***/ "./node_modules/turf-within/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-within/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and returns the points that fall within the polygons.
 *
 * @name within
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @return {FeatureCollection<Point>} points that land within at least one polygon
 * @example
 * var searchWithin = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-46.653,-23.543],
 *           [-46.634,-23.5346],
 *           [-46.613,-23.543],
 *           [-46.614,-23.559],
 *           [-46.631,-23.567],
 *           [-46.653,-23.560],
 *           [-46.653,-23.543]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6318, -23.5523]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6246, -23.5325]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6062, -23.5513]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.663, -23.554]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.643, -23.557]
 *       }
 *     }
 *   ]
 * };
 *
 * var ptsWithin = turf.within(points, searchWithin);
 *
 * //=points
 *
 * //=searchWithin
 *
 * //=ptsWithin
 */
module.exports = function (points, polygons) {
    var pointsWithin = featureCollection([]);
    for (var i = 0; i < polygons.features.length; i++) {
        for (var j = 0; j < points.features.length; j++) {
            var isInside = inside(points.features[j], polygons.features[i]);
            if (isInside) {
                pointsWithin.features.push(points.features[j]);
            }
        }
    }
    return pointsWithin;
};


/***/ }),

/***/ "./node_modules/turf/index.js":
/*!************************************!*\
  !*** ./node_modules/turf/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*eslint global-require: 0*/

/**
 * Turf is a modular geospatial analysis engine written in JavaScript. It performs geospatial
 * processing tasks with GeoJSON data and can be run on a server or in a browser.
 *
 * @module turf
 * @summary Geospatial analysis for JavaScript
 */
module.exports = {
    isolines: __webpack_require__(/*! turf-isolines */ "./node_modules/turf-isolines/index.js"),
    convex: __webpack_require__(/*! turf-convex */ "./node_modules/turf-convex/index.js"),
    within: __webpack_require__(/*! turf-within */ "./node_modules/turf-within/index.js"),
    concave: __webpack_require__(/*! turf-concave */ "./node_modules/turf-concave/index.js"),
    difference: __webpack_require__(/*! turf-difference */ "./node_modules/turf-difference/index.js"),
    collect: __webpack_require__(/*! turf-collect */ "./node_modules/turf-collect/index.js"),
    flip: __webpack_require__(/*! turf-flip */ "./node_modules/turf-flip/index.js"),
    simplify: __webpack_require__(/*! turf-simplify */ "./node_modules/turf-simplify/index.js"),
    bezier: __webpack_require__(/*! turf-bezier */ "./node_modules/turf-bezier/index.js"),
    tag: __webpack_require__(/*! turf-tag */ "./node_modules/turf-tag/index.js"),
    sample: __webpack_require__(/*! turf-sample */ "./node_modules/turf-sample/index.js"),
    envelope: __webpack_require__(/*! turf-envelope */ "./node_modules/turf-envelope/index.js"),
    square: __webpack_require__(/*! turf-square */ "./node_modules/turf-square/index.js"),
    midpoint: __webpack_require__(/*! turf-midpoint */ "./node_modules/turf-midpoint/index.js"),
    buffer: __webpack_require__(/*! turf-buffer */ "./node_modules/turf-buffer/index.js"),
    center: __webpack_require__(/*! turf-center */ "./node_modules/turf-center/index.js"),
    centroid: __webpack_require__(/*! turf-centroid */ "./node_modules/turf-centroid/index.js"),
    combine: __webpack_require__(/*! turf-combine */ "./node_modules/turf-combine/index.js"),
    distance: __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js"),
    explode: __webpack_require__(/*! turf-explode */ "./node_modules/turf-explode/index.js"),
    bbox: __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js"),
    tesselate: __webpack_require__(/*! turf-tesselate */ "./node_modules/turf-tesselate/index.js"),
    bboxPolygon: __webpack_require__(/*! turf-bbox-polygon */ "./node_modules/turf-bbox-polygon/index.js"),
    inside: __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js"),
    intersect: __webpack_require__(/*! turf-intersect */ "./node_modules/turf-intersect/index.js"),
    nearest: __webpack_require__(/*! turf-nearest */ "./node_modules/turf-nearest/index.js"),
    planepoint: __webpack_require__(/*! turf-planepoint */ "./node_modules/turf-planepoint/index.js"),
    random: __webpack_require__(/*! turf-random */ "./node_modules/turf-random/index.js"),
    tin: __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js"),
    union: __webpack_require__(/*! turf-union */ "./node_modules/turf-union/index.js"),
    bearing: __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js"),
    destination: __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js"),
    kinks: __webpack_require__(/*! turf-kinks */ "./node_modules/turf-kinks/index.js"),
    pointOnSurface: __webpack_require__(/*! turf-point-on-surface */ "./node_modules/turf-point-on-surface/index.js"),
    area: __webpack_require__(/*! turf-area */ "./node_modules/turf-area/index.js"),
    along: __webpack_require__(/*! turf-along */ "./node_modules/turf-along/index.js"),
    lineDistance: __webpack_require__(/*! turf-line-distance */ "./node_modules/turf-line-distance/index.js"),
    lineSlice: __webpack_require__(/*! turf-line-slice */ "./node_modules/turf-line-slice/index.js"),
    pointOnLine: __webpack_require__(/*! turf-point-on-line */ "./node_modules/turf-point-on-line/index.js"),
    pointGrid: __webpack_require__(/*! turf-point-grid */ "./node_modules/turf-point-grid/index.js"),
    squareGrid: __webpack_require__(/*! turf-square-grid */ "./node_modules/turf-square-grid/index.js"),
    triangleGrid: __webpack_require__(/*! turf-triangle-grid */ "./node_modules/turf-triangle-grid/index.js"),
    hexGrid: __webpack_require__(/*! turf-hex-grid */ "./node_modules/turf-hex-grid/index.js")
};

var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");

module.exports.point = helpers.point;
module.exports.polygon = helpers.polygon;
module.exports.lineString = helpers.lineString;
module.exports.multiPoint = helpers.multiPoint;
module.exports.multiPolygon = helpers.multiPolygon;
module.exports.multiLineString = helpers.multiLineString;
module.exports.feature = helpers.feature;
module.exports.featureCollection = helpers.featureCollection;
module.exports.geometryCollection = helpers.geometryCollection;


/***/ }),

/***/ "./node_modules/two-product/two-product.js":
/*!*************************************************!*\
  !*** ./node_modules/two-product/two-product.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}

/***/ }),

/***/ "./node_modules/two-sum/two-sum.js":
/*!*****************************************!*\
  !*** ./node_modules/two-sum/two-sum.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}

/***/ }),

/***/ "./node_modules/union-find/index.js":
/*!******************************************!*\
  !*** ./node_modules/union-find/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([bth[buf[i++]], bth[buf[i++]], 
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]], '-',
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]],
	bth[buf[i++]], bth[buf[i++]]]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/wgs84/index.js":
/*!*************************************!*\
  !*** ./node_modules/wgs84/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;


/***/ }),

/***/ "./src/app/App.ts":
/*!************************!*\
  !*** ./src/app/App.ts ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return App; });
class App {
    constructor({ viewport, mouse, keyboard, game }) {
        this.viewport = viewport;
        this.mouse = mouse;
        this.keyboard = keyboard;
        this.engine = game;
        this.__onLoop = () => undefined;
    }
    onLoop(onLoop) {
        this.__onLoop = onLoop;
    }
    once() {
        this.viewport.refresh();
        this.mouse.once();
        this.keyboard.once();
        this.engine.once();
        this.engine.draw();
        this.__onLoop();
    }
    start() {
        setInterval(this.once.bind(this), 1000 / 240);
    }
}


/***/ }),

/***/ "./src/app/components.ts":
/*!*******************************!*\
  !*** ./src/app/components.ts ***!
  \*******************************/
/*! exports provided: RivetComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RivetComponent", function() { return RivetComponent; });
/* harmony import */ var _engine_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/Component */ "./src/engine/Component.ts");

class RivetComponent extends _engine_Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}


/***/ }),

/***/ "./src/app/entities/Wire.ts":
/*!**********************************!*\
  !*** ./src/app/entities/Wire.ts ***!
  \**********************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Wire; });
/* harmony import */ var _engine_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/Entity */ "./src/engine/Entity.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _engine_geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../engine/geometry */ "./src/engine/geometry.ts");



class Wire extends _engine_Entity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ input, output }) {
        super(arguments[0]);
        this.input = input;
        this.output = output;
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
        this.updatePose();
        this.updateShape();
    }
    high() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'GREEN' });
    }
    low() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'RED' });
    }
    off() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
    }
    updatePose() {
        const inPose = this.input.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
        const outPose = this.output.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
        const x = (inPose.x + outPose.x) / 2;
        const y = (inPose.y + outPose.y) / 2;
        const a = Math.atan2(inPose.y - outPose.y, inPose.x - outPose.x);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({ x, y, a });
    }
    updateShape() {
        const inPose = this.input.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
        const outPose = this.output.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
        const length = Object(_engine_geometry__WEBPACK_IMPORTED_MODULE_2__["getEuclideanDistanceBetweenPoints"])(inPose, outPose);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Shape"])({ points: [
                { x: length / 2, y: 2 },
                { x: -length / 2, y: 2 },
                { x: -length / 2, y: -2 },
                { x: length / 2, y: -2 },
            ] });
    }
    $destroy() {
        super.$destroy();
        this.input.wires.delete(this.id);
        this.output.wires.delete(this.id);
    }
}


/***/ }),

/***/ "./src/app/entities/editor.ts":
/*!************************************!*\
  !*** ./src/app/entities/editor.ts ***!
  \************************************/
/*! exports provided: ToolButton, GateCreatorButton, AndGateCreatorButton, NandGateCreatorButton, OrGateCreatorButton, XorGateCreatorButton, GateDestructorButton, WireDestructorButton, GateMask, BuildArea */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolButton", function() { return ToolButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateCreatorButton", function() { return GateCreatorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AndGateCreatorButton", function() { return AndGateCreatorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NandGateCreatorButton", function() { return NandGateCreatorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrGateCreatorButton", function() { return OrGateCreatorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XorGateCreatorButton", function() { return XorGateCreatorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateDestructorButton", function() { return GateDestructorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireDestructorButton", function() { return WireDestructorButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateMask", function() { return GateMask; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BuildArea", function() { return BuildArea; });
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _gates__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./gates */ "./src/app/entities/gates.ts");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./tools */ "./src/app/entities/tools.ts");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./ui */ "./src/app/entities/ui.ts");





class ToolButton extends _ui__WEBPACK_IMPORTED_MODULE_4__["Button"] {
    constructor({ x, y, src }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_0__["ImageRenderingProfile"])({ src });
    }
    $click() {
        this.$engine.entities.forEvery(_tools__WEBPACK_IMPORTED_MODULE_3__["ToolHandle"])((handle) => {
            handle.$destroy();
        });
        this.$disable();
    }
}
class GateCreatorButton extends ToolButton {
    constructor({ GateCtor }) {
        super(arguments[0]);
        this.__GateCtor = GateCtor;
    }
    $click() {
        super.$click();
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_3__["GateCreatorHandle"], {
            GateCtor: this.__GateCtor,
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
        });
    }
}
class AndGateCreatorButton extends GateCreatorButton {
    constructor() {
        super(Object.assign({ GateCtor: _gates__WEBPACK_IMPORTED_MODULE_2__["AndGate"], src: './AndGate.png' }, arguments[0]));
    }
}
class NandGateCreatorButton extends GateCreatorButton {
    constructor() {
        super(Object.assign({ GateCtor: _gates__WEBPACK_IMPORTED_MODULE_2__["NandGate"], src: './NandGate.png' }, arguments[0]));
    }
}
class OrGateCreatorButton extends GateCreatorButton {
    constructor() {
        super(Object.assign({ GateCtor: _gates__WEBPACK_IMPORTED_MODULE_2__["OrGate"], src: './OrGate.png' }, arguments[0]));
    }
}
class XorGateCreatorButton extends GateCreatorButton {
    constructor() {
        super(Object.assign({ GateCtor: _gates__WEBPACK_IMPORTED_MODULE_2__["XorGate"], src: './XorGate.png' }, arguments[0]));
    }
}
class GateDestructorButton extends ToolButton {
    constructor() {
        super(Object.assign({ src: './TRASHCAN.png' }, arguments[0]));
    }
    $click() {
        super.$click();
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_3__["GateDestructorHandle"], {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
        });
    }
}
class WireDestructorButton extends ToolButton {
    constructor() {
        super(Object.assign({ src: './CUTTER_CLOSED.png' }, arguments[0]));
    }
    $click() {
        super.$click();
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_3__["WireDestructorHandle"], {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
        });
    }
}
class GateMask extends _engine_entities__WEBPACK_IMPORTED_MODULE_1__["InteractiveElement"] {
    constructor({ x, y }) {
        super(Object.assign({ width: 40, height: 40 }, arguments[0]));
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_0__["ShapeRenderingProfile"])({ colour: 'LIGHTBLUE' });
    }
}
class BuildArea extends _ui__WEBPACK_IMPORTED_MODULE_4__["Panel"] {
    constructor() {
        super(arguments[0]);
        this.inputs = [];
        this.outputs = [];
    }
    init() {
        this.__initInputs();
        this.__initOutputs();
    }
    __initInputs() {
        const pose = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Pose"]);
        const { width, height } = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Shape"]).points.map((p) => ({ width: 2 * p.x, height: 2 * p.y }))[0];
        const horizontalSpacer = width / (this.inputs.length + 1);
        const verticalSpacer = 20;
        let cursor = 1;
        for (const input of this.inputs) {
            input.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Pose"])({
                x: pose.x - width / 2 + cursor * horizontalSpacer,
                y: pose.y - height / 2 + verticalSpacer,
                a: 0,
            });
            cursor++;
        }
    }
    __initOutputs() {
        const pose = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Pose"]);
        const { width, height } = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Shape"]).points.map((p) => ({ width: 2 * p.x, height: 2 * p.y }))[0];
        const horizontalSpacer = width / (this.outputs.length + 1);
        const verticalSpacer = 20;
        let cursor = 1;
        for (const output of this.outputs) {
            output.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_0__["Pose"])({
                x: pose.x - width / 2 + cursor * horizontalSpacer,
                y: pose.y + height / 2 - verticalSpacer,
                a: 0,
            });
            cursor++;
        }
    }
}


/***/ }),

/***/ "./src/app/entities/gates.ts":
/*!***********************************!*\
  !*** ./src/app/entities/gates.ts ***!
  \***********************************/
/*! exports provided: Gate, AndGate, NandGate, OrGate, XorGate */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Gate", function() { return Gate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AndGate", function() { return AndGate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NandGate", function() { return NandGate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrGate", function() { return OrGate; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XorGate", function() { return XorGate; });
/* harmony import */ var _enums_STATE__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../enums/STATE */ "./src/app/enums/STATE.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _terminals__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./terminals */ "./src/app/entities/terminals.ts");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools */ "./src/app/entities/tools.ts");





class Gate extends _engine_entities__WEBPACK_IMPORTED_MODULE_2__["InteractiveElement"] {
    constructor({ x, y, src }) {
        super(Object.assign({ width: 30, height: 30 }, arguments[0]));
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].OFF;
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ImageRenderingProfile"])({ src });
        this.input = this.$engine.entities.create(_terminals__WEBPACK_IMPORTED_MODULE_3__["InputTerminal"], { gate: this, x, y: y + 30 });
        this.output = this.$engine.entities.create(_terminals__WEBPACK_IMPORTED_MODULE_3__["OutputTerminal"], { x, y: y - 30 });
    }
    once() { return; }
    get isHigh() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].HIGH;
    }
    get isLow() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].LOW;
    }
    get isOff() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].OFF;
    }
    high() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].HIGH;
        this.input.high();
        this.output.high();
    }
    low() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].LOW;
        this.input.low();
        this.output.low();
    }
    off() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_0__["STATE"].OFF;
        this.input.off();
        this.output.off();
    }
    $mousedown() {
        const handle = this.$engine.entities.find(_tools__WEBPACK_IMPORTED_MODULE_4__["ToolHandle"])(() => true);
        if (handle) {
            return;
        }
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_4__["GatePlacerHandle"], {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
            gate: this,
        });
    }
    move(pose) {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])(pose);
        this.input.move({
            x: pose.x,
            y: pose.y + 30,
            a: 0,
        });
        this.output.move({
            x: pose.x,
            y: pose.y - 30,
            a: 0,
        });
    }
    $destroy() {
        this.input.$destroy();
        this.output.$destroy();
        return super.$destroy();
    }
}
class AndGate extends Gate {
    constructor() {
        super(Object.assign({ src: './AndGate.png' }, arguments[0]));
    }
    once() {
        if (!this.input.wires.length) {
            return this.off();
        }
        const wires = this.input.wires.toArray();
        for (const wire of wires) {
            if (wire.output.isLow) {
                return this.low();
            }
        }
        if (wires.find((wire) => wire.output.isHigh)) {
            this.high();
        }
        else {
            this.off();
        }
    }
}
class NandGate extends Gate {
    constructor() {
        super(Object.assign({ src: './NandGate.png' }, arguments[0]));
    }
    once() {
        if (!this.input.wires.length) {
            return this.off();
        }
        const wires = this.input.wires.toArray();
        for (const wire of wires) {
            if (wire.output.isLow) {
                return this.high();
            }
        }
        if (wires.find((wire) => wire.output.isHigh)) {
            this.low();
        }
        else {
            this.off();
        }
    }
}
class OrGate extends Gate {
    constructor() {
        super(Object.assign({ src: './OrGate.png' }, arguments[0]));
    }
    once() {
        // if (!this.input.wires.length) {
        //     this.off();
        //     return;
        // }
        // for (const wire of this.input.wires) {
        //     if (wire.output.isLow) {
        //         this.high();
        //         return;
        //     }
        // }
        // this.low();
    }
}
class XorGate extends Gate {
    constructor() {
        super(Object.assign({ src: './XorGate.png' }, arguments[0]));
    }
    once() {
        // if (!this.input.wires.length) {
        //     this.off();
        //     return;
        // }
        // for (const wire of this.input.wires) {
        //     if (wire.output.isLow) {
        //         this.high();
        //         return;
        //     }
        // }
        // this.low();
    }
}


/***/ }),

/***/ "./src/app/entities/machines.ts":
/*!**************************************!*\
  !*** ./src/app/entities/machines.ts ***!
  \**************************************/
/*! exports provided: PowerSupply, Machine, MachinePart, HorizontalThreadedAxle, VerticalThreadedAxle, Actuator, Sensor, TouchSensor, TouchActivator, Claw, ClawMachine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PowerSupply", function() { return PowerSupply; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Machine", function() { return Machine; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MachinePart", function() { return MachinePart; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HorizontalThreadedAxle", function() { return HorizontalThreadedAxle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VerticalThreadedAxle", function() { return VerticalThreadedAxle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Actuator", function() { return Actuator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sensor", function() { return Sensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchSensor", function() { return TouchSensor; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TouchActivator", function() { return TouchActivator; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Claw", function() { return Claw; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClawMachine", function() { return ClawMachine; });
/* harmony import */ var _engine_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/Entity */ "./src/engine/Entity.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../components */ "./src/app/components.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _terminals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./terminals */ "./src/app/entities/terminals.ts");





class PowerSupply extends _terminals__WEBPACK_IMPORTED_MODULE_4__["OutputTerminal"] {
    constructor() {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Label"])({
            text: 'power',
            fontSize: 20,
            offset: { x: 15, y: 7 },
        });
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
    }
}
class Machine extends _engine_Entity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ x, y }) {
        super(arguments[0]);
        this.inputs = [];
        this.outputs = [];
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({ x, y, a: 0 });
    }
    once() { return; }
    off() { return; }
    $destroy() {
        super.$destroy();
        this.inputs.forEach((input) => input.$destroy());
        this.outputs.forEach((output) => output.$destroy());
    }
}
class MachinePart extends _engine_Entity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ x, y, shape }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({ x, y, a: 0 });
        if (shape) {
            this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Shape"])(shape);
            this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE', fillStyle: 'BLACK' });
        }
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 0, y: 0, a: 0 });
    }
}
class HorizontalThreadedAxle extends MachinePart {
    constructor({ x, y, width, height }) {
        super(arguments[0]);
        this.__threads = [];
        for (let i = 0, L = width / 10; i < L; i++) {
            const thread = this.$engine.entities.create(MachinePart, {
                x: x - width / 2 + i * 10 + 5,
                y,
            });
            thread.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                src: [
                    './threaded-axle-1.png',
                    './threaded-axle-2.png',
                    './threaded-axle-3.png',
                    './threaded-axle-4.png',
                    './threaded-axle-5.png',
                    './threaded-axle-6.png',
                    './threaded-axle-7.png',
                    './threaded-axle-8.png',
                    './threaded-axle-9.png',
                    './threaded-axle-10.png',
                ],
                frame: 0,
                speed: 1,
                cooldown: 0,
                width: 10,
                height,
                isPaused: true,
            });
            this.__threads.push(thread);
        }
    }
    left() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: false,
                isReversed: false,
            });
        });
    }
    right() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: false,
                isReversed: true,
            });
        });
    }
    off() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: true,
            });
        });
    }
    step(poseStep) {
        this.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        });
    }
    $destroy() {
        super.$destroy();
        this.__threads.forEach((thread) => {
            thread.$destroy();
        });
    }
}
class VerticalThreadedAxle extends MachinePart {
    constructor({ x, y, width, height }) {
        super(arguments[0]);
        this.__threads = [];
        for (let i = 0, L = height / 10; i < L; i++) {
            const thread = this.$engine.entities.create(MachinePart, {
                x,
                y: y - height / 2 + i * 10 + 5,
            });
            thread.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                src: [
                    './threaded-axle-1.png',
                    './threaded-axle-2.png',
                    './threaded-axle-3.png',
                    './threaded-axle-4.png',
                    './threaded-axle-5.png',
                    './threaded-axle-6.png',
                    './threaded-axle-7.png',
                    './threaded-axle-8.png',
                    './threaded-axle-9.png',
                    './threaded-axle-10.png',
                ],
                frame: 0,
                speed: 1,
                cooldown: 0,
                width: 10,
                height: width,
                isPaused: true,
                rotate: -Math.PI / 2,
            });
            this.__threads.push(thread);
        }
    }
    up() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: false,
                isReversed: true,
            });
        });
    }
    down() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: false,
                isReversed: false,
            });
        });
    }
    off() {
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])({
                isPaused: true,
            });
        });
    }
    step(poseStep) {
        this.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__threads.forEach((thread) => {
            thread.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        });
    }
    $destroy() {
        super.$destroy();
        this.__threads.forEach((thread) => {
            thread.$destroy();
        });
    }
}
class Actuator extends _terminals__WEBPACK_IMPORTED_MODULE_4__["InputTerminal"] {
    constructor({ label }) {
        super(Object.assign({ x: 0, y: 0 }, arguments[0]));
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Label"])({
            text: label,
            fontSize: 20,
            offset: { x: 15, y: 7 },
        });
    }
}
class Sensor extends MachinePart {
    constructor({ x, y, shape, label }) {
        super(arguments[0]);
        this.output = this.$engine.entities.create(_terminals__WEBPACK_IMPORTED_MODULE_4__["OutputTerminal"], { x: 0, y: 0 });
        this.output.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Label"])({
            text: label,
            fontSize: 20,
            offset: { x: 15, y: 7 },
        });
        this.output.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
    }
    get isHigh() {
        return this.output.isHigh;
    }
    get isLow() {
        return this.output.isLow;
    }
    get isOff() {
        return this.output.isOff;
    }
    once() {
        const target = this.$engine.entities.find(TouchActivator)((activator) => {
            return Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entitiesTouch"])(this, activator);
        });
        if (target) {
            this.output.high();
        }
        else {
            this.output.low();
        }
    }
    $destroy() {
        super.$destroy();
        this.output.$destroy();
    }
}
class TouchSensor extends Sensor {
}
class TouchActivator extends MachinePart {
}
class Claw extends Machine {
    constructor({ x, y }) {
        super(arguments[0]);
        this.inputs = [];
        this.outputs = [];
        this.__wrist = this.$engine.entities.create(MachinePart, {
            x, y: y - 15, shape: { points: [
                    { x: 10, y: 5 },
                    { x: -10, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ] },
        });
        this.__palm = this.$engine.entities.create(TouchActivator, {
            x, y: y + 10, shape: { points: [
                    { x: 10, y: 10 },
                    { x: -10, y: 10 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                ] },
        });
        this.__leftHub = this.$engine.entities.create(TouchActivator, {
            x: x - 52, y: y + 10, shape: { points: [
                    { x: 2, y: 10 },
                    { x: -2, y: 10 },
                    { x: -2, y: -10 },
                    { x: 2, y: -10 },
                ] },
        });
        this.__leftThread = this.$engine.entities.create(HorizontalThreadedAxle, {
            x: x - 30, y: y + 10, width: 40, height: 20,
        });
        this.__rightThread = this.$engine.entities.create(HorizontalThreadedAxle, {
            x: x + 30, y: y + 10, width: 40, height: 20,
        });
        this.__leftTooth = this.$engine.entities.create(TouchSensor, {
            x: x - 40, y: y + 10, shape: { points: [
                    { x: 10, y: 60 },
                    { x: -0, y: 60 },
                    { x: -0, y: 20 },
                    { x: -10, y: 20 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                ] },
            label: 'left-tooth',
        });
        this.__leftTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ zIndex: 1 });
        this.__rightTooth = this.$engine.entities.create(TouchSensor, {
            x: x + 40, y: y + 10, shape: { points: [
                    { x: 0, y: 20 },
                    { x: 0, y: 60 },
                    { x: -10, y: 60 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                    { x: 10, y: 20 },
                ] },
            label: 'right-tooth',
        });
        this.__rightTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ zIndex: 1 });
        this.__openMotor = this.$engine.entities.create(Actuator, {
            label: 'open',
        });
        this.__closeMotor = this.$engine.entities.create(Actuator, {
            label: 'close',
        });
        this.inputs = [this.__openMotor, this.__closeMotor];
        this.outputs = [this.__leftTooth.output, this.__rightTooth.output];
    }
    once() {
        if (this.__leftTooth.isHigh && this.__rightTooth.isHigh && this.__closeMotor.isHigh) {
            return this.off();
        }
        if (this.__openMotor.isHigh && this.__closeMotor.isHigh) {
            return this.off();
        }
        if (this.__openMotor.isHigh && this.__leftTooth.isHigh && !this.__rightTooth.isHigh) {
            return this.off();
        }
        if (this.__closeMotor.isHigh) {
            this.__leftThread.right();
            this.__rightThread.left();
            const leftToothPose = this.__leftTooth.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            const rightToothPose = this.__rightTooth.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            this.__leftTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
                x: leftToothPose.x + 1,
            });
            this.__rightTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
                x: rightToothPose.x - 1,
            });
        }
        if (this.__openMotor.isHigh) {
            this.__leftThread.left();
            this.__rightThread.right();
            const leftToothPose = this.__leftTooth.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            const rightToothPose = this.__rightTooth.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            this.__leftTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
                x: leftToothPose.x - 1,
            });
            this.__rightTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
                x: rightToothPose.x + 1,
            });
        }
    }
    off() {
        this.__leftThread.off();
        this.__rightThread.off();
    }
    step(poseStep) {
        this.__wrist.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__palm.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__leftHub.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__leftThread.step(poseStep);
        this.__rightThread.step(poseStep);
        this.__leftTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
        this.__rightTooth.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])(poseStep);
    }
}
class ClawMachine extends Machine {
    constructor({ x, y }) {
        super(arguments[0]);
        this.__horizontalRail = this.$engine.entities.create(HorizontalThreadedAxle, { x, y, width: 300, height: 20 });
        this.__carriage = this.$engine.entities.create(TouchActivator, {
            x: x - 130, y,
            shape: { points: [
                    { x: 20, y: 30 },
                    { x: -20, y: 30 },
                    { x: -20, y: -30 },
                    { x: 20, y: -30 },
                ] },
        });
        this.__carriage.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE', fillStyle: 'BLACK', zIndex: 1 });
        this.__verticalRail = this.$engine.entities.create(VerticalThreadedAxle, {
            x: x - 130, y, width: 20, height: 200,
        });
        this.__leftSensor = this.$engine.entities.create(TouchSensor, {
            x: x - 170, y,
            shape: { points: [
                    { x: 20, y: 20 },
                    { x: -20, y: 20 },
                    { x: -20, y: -20 },
                    { x: 20, y: -20 },
                ] },
            label: 'left-sensor',
        });
        this.__leftSensor.$add(_components__WEBPACK_IMPORTED_MODULE_2__["RivetComponent"])({
            colour: 'WHITE', radius: 3,
        });
        this.__rightSensor = this.$engine.entities.create(TouchSensor, {
            x: x + 170, y,
            shape: { points: [
                    { x: 20, y: 20 },
                    { x: -20, y: 20 },
                    { x: -20, y: -20 },
                    { x: 20, y: -20 },
                ] },
            label: 'right-sensor',
        });
        this.__rightSensor.$add(_components__WEBPACK_IMPORTED_MODULE_2__["RivetComponent"])({
            colour: 'WHITE', radius: 3,
        });
        this.__topSensor = this.$engine.entities.create(TouchSensor, {
            x: x - 130, y: y - 105,
            shape: { points: [
                    { x: 20, y: 5 },
                    { x: -20, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ] },
            label: 'top-sensor',
        });
        this.__bottomSensor = this.$engine.entities.create(TouchSensor, {
            x: x - 130, y: y + 105,
            shape: { points: [
                    { x: 20, y: 5 },
                    { x: -20, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ] },
            label: 'bottom-sensor',
        });
        this.__leftMotor = this.$engine.entities.create(Actuator, {
            label: 'move-left',
        });
        this.__rightMotor = this.$engine.entities.create(Actuator, {
            label: 'move-right',
        });
        this.__topMotor = this.$engine.entities.create(Actuator, {
            label: 'move-up',
        });
        this.__bottomMotor = this.$engine.entities.create(Actuator, {
            label: 'move-down',
        });
        this.__claw = this.$engine.entities.create(Claw, {
            x: x - 130, y: y + 130,
        });
        this.inputs = [
            this.__leftMotor,
            this.__rightMotor,
            this.__topMotor,
            this.__bottomMotor,
        ].concat(this.__claw.inputs);
        this.outputs = [
            this.__leftSensor.output,
            this.__rightSensor.output,
            this.__topSensor.output,
            this.__bottomSensor.output,
        ].concat(this.__claw.outputs);
    }
    once() {
        this.__updateHorizontalState();
        this.__updateVerticalState();
    }
    off() {
        this.__offX();
        this.__offY();
    }
    __updateHorizontalState() {
        if (this.__leftMotor.isHigh && this.__rightMotor.isHigh) {
            return this.__offX();
        }
        if (this.__leftMotor.isLow && this.__rightMotor.isLow) {
            return this.__offX();
        }
        if (this.__leftMotor.isHigh) {
            if (this.__leftSensor.isHigh) {
                return this.__offX();
            }
            return this.__left();
        }
        if (this.__rightMotor.isHigh) {
            if (this.__rightSensor.isHigh) {
                return this.__offX();
            }
            return this.__right();
        }
        return this.__offX();
    }
    __updateVerticalState() {
        if (this.__topMotor.isHigh && this.__bottomMotor.isHigh) {
            return this.__offY();
        }
        if (this.__topMotor.isLow && this.__bottomMotor.isLow) {
            return this.__offY();
        }
        if (this.__topMotor.isHigh) {
            if (this.__bottomSensor.isHigh) {
                return this.__offY();
            }
            return this.__up();
        }
        if (this.__bottomMotor.isHigh) {
            if (this.__topSensor.isHigh) {
                return this.__offY();
            }
            return this.__down();
        }
        return this.__offY();
    }
    __left() {
        this.__carriage.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: -1 });
        this.__verticalRail.step({ x: -1 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: -1 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: -1 });
        this.__horizontalRail.left();
        this.__claw.step({ x: -1 });
    }
    __right() {
        this.__carriage.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 1 });
        this.__verticalRail.step({ x: 1 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 1 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 1 });
        this.__horizontalRail.right();
        this.__claw.step({ x: 1 });
    }
    __up() {
        this.__verticalRail.step({ y: -1 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: -1 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: -1 });
        this.__verticalRail.up();
        this.__claw.step({ y: -1 });
    }
    __down() {
        this.__verticalRail.step({ y: 1 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: 1 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: 1 });
        this.__verticalRail.down();
        this.__claw.step({ y: 1 });
    }
    __offX() {
        this.__carriage.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 0 });
        this.__verticalRail.step({ x: 0 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 0 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ x: 0 });
        this.__horizontalRail.off();
        this.__claw.step({ x: 0 });
    }
    __offY() {
        this.__verticalRail.step({ y: 0 });
        this.__topSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: 0 });
        this.__bottomSensor.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])({ y: 0 });
        this.__verticalRail.off();
        this.__claw.step({ y: 0 });
    }
}


/***/ }),

/***/ "./src/app/entities/scenes.ts":
/*!************************************!*\
  !*** ./src/app/entities/scenes.ts ***!
  \************************************/
/*! exports provided: SceneArea, SceneButton, PlayButton, StopButton */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneArea", function() { return SceneArea; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneButton", function() { return SceneButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlayButton", function() { return PlayButton; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StopButton", function() { return StopButton; });
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./editor */ "./src/app/entities/editor.ts");
/* harmony import */ var _gates__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./gates */ "./src/app/entities/gates.ts");
/* harmony import */ var _machines__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./machines */ "./src/app/entities/machines.ts");
/* harmony import */ var _systems__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../systems */ "./src/app/systems.ts");
/* harmony import */ var _terminals__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./terminals */ "./src/app/entities/terminals.ts");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./tools */ "./src/app/entities/tools.ts");
/* harmony import */ var _ui__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./ui */ "./src/app/entities/ui.ts");







class SceneArea extends _ui__WEBPACK_IMPORTED_MODULE_6__["Panel"] {
}
class SceneButton extends _ui__WEBPACK_IMPORTED_MODULE_6__["Button"] {
    $click() {
        this.$engine.entities.forEvery(SceneButton)((button) => {
            button.$enable();
        });
        this.$disable();
    }
}
class PlayButton extends SceneButton {
    constructor() {
        super(Object.assign({ label: 'play' }, arguments[0]));
    }
    $click() {
        super.$click();
        this.$engine.entities.forEvery(_tools__WEBPACK_IMPORTED_MODULE_5__["ToolHandle"])((handle) => {
            handle.$destroy();
        });
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_0__["ToolButton"])((button) => {
            button.$disable();
        });
        this.$engine.entities.forEvery(_gates__WEBPACK_IMPORTED_MODULE_1__["Gate"])((gate) => {
            gate.$disable();
        });
        this.$engine.entities.forEvery(_terminals__WEBPACK_IMPORTED_MODULE_4__["Terminal"])((terminal) => {
            terminal.$disable();
        });
        this.$engine.entities.forEvery(_machines__WEBPACK_IMPORTED_MODULE_2__["PowerSupply"])((power) => {
            power.high();
        });
        this.$engine.add(_systems__WEBPACK_IMPORTED_MODULE_3__["ActuatorSystem"]);
        this.$engine.add(_systems__WEBPACK_IMPORTED_MODULE_3__["SensorSystem"]);
        this.$engine.add(_systems__WEBPACK_IMPORTED_MODULE_3__["GateSystem"]);
        this.$engine.add(_systems__WEBPACK_IMPORTED_MODULE_3__["MachineSystem"]);
    }
}
class StopButton extends SceneButton {
    constructor() {
        super(Object.assign({ label: 'stop' }, arguments[0]));
        this.$disable();
    }
    $click() {
        super.$click();
        this.$engine.remove(_systems__WEBPACK_IMPORTED_MODULE_3__["ActuatorSystem"]);
        this.$engine.remove(_systems__WEBPACK_IMPORTED_MODULE_3__["SensorSystem"]);
        this.$engine.remove(_systems__WEBPACK_IMPORTED_MODULE_3__["GateSystem"]);
        this.$engine.remove(_systems__WEBPACK_IMPORTED_MODULE_3__["MachineSystem"]);
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_0__["ToolButton"])((button) => {
            button.$enable();
        });
        this.$engine.entities.forEvery(_terminals__WEBPACK_IMPORTED_MODULE_4__["Terminal"])((terminal) => {
            terminal.$enable();
            terminal.off();
        });
        this.$engine.entities.forEvery(_gates__WEBPACK_IMPORTED_MODULE_1__["Gate"])((gate) => {
            gate.$enable();
            gate.off();
        });
        this.$engine.entities.forEvery(_machines__WEBPACK_IMPORTED_MODULE_2__["Machine"])((machine) => {
            machine.off();
        });
    }
}


/***/ }),

/***/ "./src/app/entities/terminals.ts":
/*!***************************************!*\
  !*** ./src/app/entities/terminals.ts ***!
  \***************************************/
/*! exports provided: Terminal, InputTerminal, OutputTerminal */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Terminal", function() { return Terminal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputTerminal", function() { return InputTerminal; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutputTerminal", function() { return OutputTerminal; });
/* harmony import */ var _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/concretes/Dictionary */ "./src/framework/concretes/Dictionary.ts");
/* harmony import */ var _enums_STATE__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../enums/STATE */ "./src/app/enums/STATE.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _tools__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./tools */ "./src/app/entities/tools.ts");





class Terminal extends _engine_entities__WEBPACK_IMPORTED_MODULE_3__["InteractiveElement"] {
    constructor({ x, y, src }) {
        super(Object.assign({ width: 20, height: 20 }, arguments[0]));
        this.wires = new _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].OFF;
        this.__src = src;
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_2__["ImageRenderingProfile"])({ src });
    }
    get isHigh() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].HIGH;
    }
    get isLow() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].LOW;
    }
    get isOff() {
        return this.__state === _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].OFF;
    }
    high() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].HIGH;
        const label = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"]);
        if (label) {
            this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"])(Object.assign(label, {
                colour: 'GREEN',
            }));
        }
    }
    low() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].LOW;
        const label = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"]);
        if (label) {
            this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"])(Object.assign(label, {
                colour: 'RED',
            }));
        }
    }
    off() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_1__["STATE"].OFF;
        const label = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"]);
        if (label) {
            this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Label"])(Object.assign(label, {
                colour: 'WHITE',
            }));
        }
    }
    move(pose) {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"])(pose);
        this.wires.forEach((wire) => {
            wire.updatePose();
            wire.updateShape();
        });
    }
    $mouseenter() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["ImageRenderingProfile"])({ src: './Terminal_hovered.png' });
    }
    $mouseleave() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_2__["ImageRenderingProfile"])({ src: this.__src });
    }
    $destroy() {
        this.wires.forEach((wire) => {
            wire.$destroy();
        });
        return super.$destroy();
    }
}
class InputTerminal extends Terminal {
    constructor({ gate, x, y }) {
        super(Object.assign({ src: './Terminal_in.png' }, arguments[0]));
        this.$gate = gate;
    }
    $mousedown() {
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_4__["OutputTerminalHandle"], {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
            input: this,
        });
    }
}
class OutputTerminal extends Terminal {
    constructor({ x, y }) {
        super(Object.assign({ src: './Terminal_out.png' }, arguments[0]));
    }
    $mousedown() {
        this.$engine.entities.create(_tools__WEBPACK_IMPORTED_MODULE_4__["InputTerminalHandle"], {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
            output: this,
        });
    }
    high() {
        super.high();
        this.wires.forEach((wire) => wire.high());
    }
    low() {
        super.low();
        this.wires.forEach((wire) => wire.low());
    }
    off() {
        super.off();
        this.wires.forEach((wire) => wire.off());
    }
}


/***/ }),

/***/ "./src/app/entities/tools.ts":
/*!***********************************!*\
  !*** ./src/app/entities/tools.ts ***!
  \***********************************/
/*! exports provided: ToolHandle, GateCreatorHandle, GateDestructorHandle, WireDestructorHandle, GatePlacerHandle, OutputTerminalHandle, InputTerminalHandle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ToolHandle", function() { return ToolHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateCreatorHandle", function() { return GateCreatorHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateDestructorHandle", function() { return GateDestructorHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireDestructorHandle", function() { return WireDestructorHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GatePlacerHandle", function() { return GatePlacerHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutputTerminalHandle", function() { return OutputTerminalHandle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputTerminalHandle", function() { return InputTerminalHandle; });
/* harmony import */ var _Wire__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Wire */ "./src/app/entities/Wire.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _editor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./editor */ "./src/app/entities/editor.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _gates__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./gates */ "./src/app/entities/gates.ts");
/* harmony import */ var _terminals__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./terminals */ "./src/app/entities/terminals.ts");






class ToolHandle extends _engine_entities__WEBPACK_IMPORTED_MODULE_3__["InteractiveElement"] {
    constructor({ x, y }) {
        super(Object.assign({ width: 10, height: 10 }, arguments[0]));
    }
    $mousemove() {
        this.$mutate(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
            a: 0,
        });
    }
    $click() {
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_2__["BuildArea"])((area) => {
            if (Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityContainsPoint"])(area, this.$engine.mouse)) {
                this.action();
            }
        });
        this.$destroy();
    }
    action() { return; }
}
class GateCreatorHandle extends ToolHandle {
    constructor({ GateCtor, x, y }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'YELLOW' });
        this.__GateCtor = GateCtor;
    }
    action() {
        this.$engine.entities.create(this.__GateCtor, {
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
        });
    }
    $destroy() {
        super.$destroy();
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_2__["GateCreatorButton"])((button) => {
            button.$enable();
        });
    }
}
class GateDestructorHandle extends ToolHandle {
    constructor({ x, y }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'ORANGE' });
    }
    action() {
        const target = this.$engine.entities.find(_gates__WEBPACK_IMPORTED_MODULE_4__["Gate"])((gate) => {
            return Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityContainsPoint"])(gate, this.$engine.mouse);
        });
        if (target) {
            target.$destroy();
        }
    }
    $destroy() {
        super.$destroy();
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_2__["GateDestructorButton"])((button) => {
            button.$enable();
        });
    }
}
class WireDestructorHandle extends ToolHandle {
    constructor({ x, y }) {
        super(arguments[0]);
        this.points = [];
        this.__isCuttingActive = false;
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'RED' });
    }
    $mousedown() {
        this.__isCuttingActive = true;
    }
    $mousemove() {
        super.$mousemove();
        if (!this.__isCuttingActive) {
            return;
        }
        this.points.push({
            x: this.$engine.mouse.x,
            y: this.$engine.mouse.y,
        });
    }
    $destroy() {
        super.$destroy();
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_2__["WireDestructorButton"])((button) => {
            button.$enable();
        });
        this.$engine.entities.forEvery(_Wire__WEBPACK_IMPORTED_MODULE_0__["default"])((wire) => {
            if (Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityTouchesLine"])(wire, this.points)) {
                wire.$destroy();
            }
        });
    }
}
class GatePlacerHandle extends ToolHandle {
    constructor({ x, y, gate }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'LIGHTBLUE' });
        this.gate = gate;
    }
    $mousemove() {
        this.$engine.entities.forEvery(_editor__WEBPACK_IMPORTED_MODULE_2__["BuildArea"])((area) => {
            if (!Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityContainsPoint"])(area, this.$engine.mouse)) {
                this.$destroy();
                return;
            }
            super.$mousemove();
            this.gate.move({
                x: this.$engine.mouse.x,
                y: this.$engine.mouse.y,
                a: 0,
            });
        });
    }
}
class OutputTerminalHandle extends ToolHandle {
    constructor({ x, y, input }) {
        super(arguments[0]);
        this.input = input;
    }
    action() {
        const target = this.$engine.entities.find(_terminals__WEBPACK_IMPORTED_MODULE_5__["OutputTerminal"])((terminal) => {
            return Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityContainsPoint"])(terminal, this.$engine.mouse);
        });
        if (target) {
            const wire = this.$engine.entities.create(_Wire__WEBPACK_IMPORTED_MODULE_0__["default"], {
                input: this.input,
                output: target,
            });
            this.input.wires.write({
                key: wire.id,
                value: wire,
            });
            target.wires.write({
                key: wire.id,
                value: wire,
            });
        }
    }
}
class InputTerminalHandle extends ToolHandle {
    constructor({ x, y, output }) {
        super(arguments[0]);
        this.output = output;
    }
    action() {
        const target = this.$engine.entities.find(_terminals__WEBPACK_IMPORTED_MODULE_5__["InputTerminal"])((terminal) => {
            return Object(_engine_entities__WEBPACK_IMPORTED_MODULE_3__["entityContainsPoint"])(terminal, this.$engine.mouse);
        });
        if (target) {
            const wire = this.$engine.entities.create(_Wire__WEBPACK_IMPORTED_MODULE_0__["default"], {
                input: target,
                output: this.output,
            });
            this.output.wires.write({
                key: wire.id,
                value: wire,
            });
            target.wires.write({
                key: wire.id,
                value: wire,
            });
        }
    }
}


/***/ }),

/***/ "./src/app/entities/ui.ts":
/*!********************************!*\
  !*** ./src/app/entities/ui.ts ***!
  \********************************/
/*! exports provided: Button, Panel */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Button", function() { return Button; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Panel", function() { return Panel; });
/* harmony import */ var _engine_Entity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../engine/Entity */ "./src/engine/Entity.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../engine/entities */ "./src/engine/entities.ts");



class Button extends _engine_entities__WEBPACK_IMPORTED_MODULE_2__["InteractiveElement"] {
    constructor({ x, y, label }) {
        super(Object.assign({ width: 40, height: 40 }, arguments[0]));
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
        if (label) {
            this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Label"])({
                fontSize: 10,
                text: label,
                offset: { x: -10, y: 4 },
            });
        }
    }
    $enable() {
        super.$enable();
        const rendering = this.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"]);
        this.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ opacity: 1 });
    }
    $disable() {
        super.$disable();
        this.$patch(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ opacity: 0.2 });
    }
}
class Panel extends _engine_Entity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ x, y, width, height }) {
        super(arguments[0]);
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({ x, y, a: 0 });
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["Shape"])({ points: [
                { x: width / 2, y: height / 2 },
                { x: -width / 2, y: height / 2 },
                { x: -width / 2, y: -height / 2 },
                { x: width / 2, y: -height / 2 },
            ] });
        this.$add(_engine_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])({ colour: 'WHITE' });
    }
}


/***/ }),

/***/ "./src/app/enums/STATE.ts":
/*!********************************!*\
  !*** ./src/app/enums/STATE.ts ***!
  \********************************/
/*! exports provided: STATE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE", function() { return STATE; });
var STATE;
(function (STATE) {
    // tslint:disable-next-line:naming-convention
    STATE[STATE["HIGH"] = 0] = "HIGH";
    // tslint:disable-next-line:naming-convention
    STATE[STATE["LOW"] = 1] = "LOW";
    // tslint:disable-next-line:naming-convention
    STATE[STATE["OFF"] = 2] = "OFF";
})(STATE || (STATE = {}));


/***/ }),

/***/ "./src/app/main.ts":
/*!*************************!*\
  !*** ./src/app/main.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ "./src/app/App.ts");
/* harmony import */ var _engine_Engine__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../engine/Engine */ "./src/engine/Engine.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasKeyboardAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasKeyboardAdaptor */ "./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasMouseAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasMouseAdaptor */ "./src/html5-canvas/HTML5CanvasMouseAdaptor.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasViewportAdaptor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasViewportAdaptor */ "./src/html5-canvas/HTML5CanvasViewportAdaptor.ts");
/* harmony import */ var _entities_editor__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./entities/editor */ "./src/app/entities/editor.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_6___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_6__);
/* harmony import */ var _entities_machines__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./entities/machines */ "./src/app/entities/machines.ts");
/* harmony import */ var _entities_scenes__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./entities/scenes */ "./src/app/entities/scenes.ts");
/* harmony import */ var _systems__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./systems */ "./src/app/systems.ts");










const canvas = jquery__WEBPACK_IMPORTED_MODULE_6___default()('#app-target').get(0);
canvas.focus();
canvas.width = 1280;
canvas.height = 680;
const viewport = new _html5_canvas_HTML5CanvasViewportAdaptor__WEBPACK_IMPORTED_MODULE_4__["HTML5CanvasViewportAdaptor"](canvas);
const mouse = new _html5_canvas_HTML5CanvasMouseAdaptor__WEBPACK_IMPORTED_MODULE_3__["default"](canvas);
const keyboard = new _html5_canvas_HTML5CanvasKeyboardAdaptor__WEBPACK_IMPORTED_MODULE_2__["default"](canvas);
const game = new _engine_Engine__WEBPACK_IMPORTED_MODULE_1__["default"](viewport);
const app = new _App__WEBPACK_IMPORTED_MODULE_0__["default"]({
    viewport,
    mouse,
    keyboard,
    game,
});
const propagateMouseInput = (mouseEvent) => game.mouse = mouseEvent;
mouse.handler({
    mouseenter: propagateMouseInput,
    mousemove: propagateMouseInput,
    mouseleave: propagateMouseInput,
    mousedown: propagateMouseInput,
    mouseup: propagateMouseInput,
    click: propagateMouseInput,
    none: propagateMouseInput,
});
const propagateKeyboardInput = (keyboardEvent) => game.keyboard = keyboardEvent;
keyboard.handler({
    keydown: propagateKeyboardInput,
    keypress: propagateKeyboardInput,
    keyup: propagateKeyboardInput,
});
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["GateMaskSystem"]);
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["WireDestructorHandleSystem"]);
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["InputTerminalHandleSystem"]);
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["OutputTerminalHandleSystem"]);
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["TerminalWireSystem"]);
game.add(_systems__WEBPACK_IMPORTED_MODULE_9__["RivetSystem"]);
app.start();
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["AndGateCreatorButton"], { x: 30, y: 30 });
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["NandGateCreatorButton"], { x: 80, y: 30 });
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["OrGateCreatorButton"], { x: 130, y: 30 });
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["XorGateCreatorButton"], { x: 180, y: 30 });
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["WireDestructorButton"], { x: 720, y: 30 });
app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["GateDestructorButton"], { x: 770, y: 30 });
const editor = app.engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_5__["BuildArea"], { x: 400, y: 340, width: 800, height: 560 });
app.engine.entities.create(_entities_scenes__WEBPACK_IMPORTED_MODULE_8__["PlayButton"], { x: 1200, y: 30 });
app.engine.entities.create(_entities_scenes__WEBPACK_IMPORTED_MODULE_8__["StopButton"], { x: 1250, y: 30 });
app.engine.entities.create(_entities_scenes__WEBPACK_IMPORTED_MODULE_8__["SceneArea"], { x: 1040, y: 340, width: 440, height: 560 });
const claw = app.engine.entities.create(_entities_machines__WEBPACK_IMPORTED_MODULE_7__["ClawMachine"], { x: 1040, y: 340 });
const power = app.engine.entities.create(_entities_machines__WEBPACK_IMPORTED_MODULE_7__["PowerSupply"], { x: 0, y: 0 });
editor.inputs = claw.inputs;
editor.outputs = [power].concat(claw.outputs);
editor.init();
[
    './threaded-axle-1.png',
    './threaded-axle-2.png',
    './threaded-axle-3.png',
    './threaded-axle-4.png',
    './threaded-axle-5.png',
    './threaded-axle-6.png',
    './threaded-axle-7.png',
    './threaded-axle-8.png',
    './threaded-axle-9.png',
    './threaded-axle-10.png',
].forEach((src) => {
    app.engine.viewport.load(src);
});


/***/ }),

/***/ "./src/app/systems.ts":
/*!****************************!*\
  !*** ./src/app/systems.ts ***!
  \****************************/
/*! exports provided: GateMaskSystem, WireDestructorHandleSystem, OutputTerminalHandleSystem, InputTerminalHandleSystem, TerminalWireSystem, ActuatorSystem, SensorSystem, GateSystem, MachineSystem, RivetSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateMaskSystem", function() { return GateMaskSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireDestructorHandleSystem", function() { return WireDestructorHandleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OutputTerminalHandleSystem", function() { return OutputTerminalHandleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InputTerminalHandleSystem", function() { return InputTerminalHandleSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TerminalWireSystem", function() { return TerminalWireSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ActuatorSystem", function() { return ActuatorSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SensorSystem", function() { return SensorSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GateSystem", function() { return GateSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MachineSystem", function() { return MachineSystem; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RivetSystem", function() { return RivetSystem; });
/* harmony import */ var _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _entities_Wire__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./entities/Wire */ "./src/app/entities/Wire.ts");
/* harmony import */ var _engine_components__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../engine/components */ "./src/engine/components.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components */ "./src/app/components.ts");
/* harmony import */ var _entities_editor__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entities/editor */ "./src/app/entities/editor.ts");
/* harmony import */ var _engine_entities__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../engine/entities */ "./src/engine/entities.ts");
/* harmony import */ var _entities_gates__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./entities/gates */ "./src/app/entities/gates.ts");
/* harmony import */ var _engine_geometry__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../engine/geometry */ "./src/engine/geometry.ts");
/* harmony import */ var _entities_machines__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./entities/machines */ "./src/app/entities/machines.ts");
/* harmony import */ var _entities_tools__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./entities/tools */ "./src/app/entities/tools.ts");










class GateMaskSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities_editor__WEBPACK_IMPORTED_MODULE_4__["BuildArea"])((area) => {
            if (this.$engine.mouse.name === 'none') {
                return;
            }
            this.$engine.entities.forEvery(_entities_editor__WEBPACK_IMPORTED_MODULE_4__["GateMask"])((mask) => {
                mask.$destroy();
            });
            this.$engine.entities.forEvery(_entities_tools__WEBPACK_IMPORTED_MODULE_9__["GateCreatorHandle"])(() => {
                if (Object(_engine_entities__WEBPACK_IMPORTED_MODULE_5__["entityContainsPoint"])(area, this.$engine.mouse)) {
                    this.$engine.entities.create(_entities_editor__WEBPACK_IMPORTED_MODULE_4__["GateMask"], {
                        x: this.$engine.mouse.x,
                        y: this.$engine.mouse.y,
                    });
                    return;
                }
            });
        });
    }
}
class WireDestructorHandleSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.entities.forEvery(_entities_tools__WEBPACK_IMPORTED_MODULE_9__["WireDestructorHandle"])((handle) => {
            this.$engine.viewport.drawLine({
                points: handle.points,
                rendering: { colour: 'RED' },
            });
        });
    }
}
class OutputTerminalHandleSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.entities.forEvery(_entities_tools__WEBPACK_IMPORTED_MODULE_9__["OutputTerminalHandle"])((handle) => {
            const { shape, rendering } = fromTerminalHandleToWireRendering(handle, handle.input);
            this.$engine.viewport.drawShape({ shape, rendering });
        });
    }
}
class InputTerminalHandleSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.entities.forEvery(_entities_tools__WEBPACK_IMPORTED_MODULE_9__["InputTerminalHandle"])((handle) => {
            const { shape, rendering } = fromTerminalHandleToWireRendering(handle, handle.output);
            this.$engine.viewport.drawShape({ shape, rendering });
        });
    }
}
class TerminalWireSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.entities.forEvery(_entities_gates__WEBPACK_IMPORTED_MODULE_6__["Gate"])((gate) => {
            const gatePose = gate.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
            const inPose = gate.input.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
            const outPose = gate.output.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
            const wire = { points: [
                    { x: 5, y: 5 },
                    { x: -5, y: 5 },
                    { x: -5, y: -5 },
                    { x: 5, y: -5 },
                ] };
            const rendering = { colour: 'WHITE', opacity: 1 };
            this.$engine.viewport.drawShape({
                shape: Object(_engine_geometry__WEBPACK_IMPORTED_MODULE_7__["transformShape"])(wire, {
                    x: (gatePose.x + inPose.x) / 2,
                    y: (gatePose.y + inPose.y) / 2 + 5,
                    a: 0,
                }),
                rendering,
            });
            this.$engine.viewport.drawShape({
                shape: Object(_engine_geometry__WEBPACK_IMPORTED_MODULE_7__["transformShape"])(wire, {
                    x: (gatePose.x + outPose.x) / 2,
                    y: (gatePose.y + outPose.y) / 2 - 5,
                    a: 0,
                }),
                rendering,
            });
        });
    }
}
class ActuatorSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities_Wire__WEBPACK_IMPORTED_MODULE_1__["default"])((wire) => {
            if (wire.input.$gate) {
                return;
            }
            if (wire.output.isHigh) {
                wire.input.high();
            }
            else if (wire.output.isLow) {
                wire.input.low();
            }
            else {
                wire.input.off();
            }
        });
    }
}
class SensorSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities_machines__WEBPACK_IMPORTED_MODULE_8__["Sensor"])((sensor) => {
            sensor.once();
        });
    }
}
class GateSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities_gates__WEBPACK_IMPORTED_MODULE_6__["Gate"])((gate) => {
            gate.once();
        });
    }
}
class MachineSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities_machines__WEBPACK_IMPORTED_MODULE_8__["Machine"])((machine) => {
            machine.once();
        });
    }
}
const fromTerminalHandleToWireRendering = (handle, terminal) => {
    const handlePose = handle.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
    const terminalPose = terminal.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
    const pose = {
        x: (handlePose.x + terminalPose.x) / 2,
        y: (handlePose.y + terminalPose.y) / 2,
        a: Math.atan2(handlePose.y - terminalPose.y, handlePose.x - terminalPose.x),
    };
    const length = Object(_engine_geometry__WEBPACK_IMPORTED_MODULE_7__["getEuclideanDistanceBetweenPoints"])(handlePose, terminalPose);
    const shape = Object(_engine_geometry__WEBPACK_IMPORTED_MODULE_7__["transformShape"])({ points: [
            { x: length / 2, y: 2 },
            { x: -length / 2, y: 2 },
            { x: -length / 2, y: -2 },
            { x: length / 2, y: -2 },
        ] }, pose);
    const rendering = { colour: 'WHITE' };
    return { shape, rendering };
};
class RivetSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_3__["RivetComponent"])((rivet) => {
            const rendering = rivet.copy();
            const pose = rivet.$entity.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Pose"]);
            const corners = rivet.$entity.$copy(_engine_components__WEBPACK_IMPORTED_MODULE_2__["Shape"]).points;
            const points = [
                { x: corners[0].x - 7, y: corners[0].y - 7 },
                { x: corners[1].x + 7, y: corners[1].y - 7 },
                { x: corners[2].x + 7, y: corners[2].y + 7 },
                { x: corners[3].x - 7, y: corners[3].y + 7 },
            ];
            points.forEach((point) => {
                this.$engine.viewport.drawCircle({
                    point: { x: point.x + pose.x, y: point.y + pose.y },
                    radius: rendering.radius,
                    rendering,
                });
            });
        });
    }
}


/***/ }),

/***/ "./src/engine/Component.ts":
/*!*********************************!*\
  !*** ./src/engine/Component.ts ***!
  \*********************************/
/*! exports provided: Component */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Component", function() { return Component; });
/* harmony import */ var _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/abstracts/Unique */ "./src/framework/abstracts/Unique.ts");

class Component extends _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(data) {
        super();
        this.mutate(data);
    }
    inject(entity) {
        this.$entity = entity;
    }
    copy() {
        return this.__clone(this.__data);
    }
    mutate(data) {
        this.__data = this.__clone(data);
    }
    __clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
}


/***/ }),

/***/ "./src/engine/ComponentFactory.ts":
/*!****************************************!*\
  !*** ./src/engine/ComponentFactory.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentFactory; });
/* harmony import */ var _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/concretes/Dictionary */ "./src/framework/concretes/Dictionary.ts");
/* harmony import */ var _framework_concretes_Factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/concretes/Factory */ "./src/framework/concretes/Factory.ts");
/* harmony import */ var _framework_abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/abstracts/Wrapper */ "./src/framework/abstracts/Wrapper.ts");



class ComponentFactory extends _framework_abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor() {
        super(new _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]());
    }
    create(ComponentCtor, arg) {
        let factory = this.unwrap().read(ComponentCtor.name);
        if (!factory) {
            factory = new _framework_concretes_Factory__WEBPACK_IMPORTED_MODULE_1__["default"]();
            this.unwrap().write({
                key: ComponentCtor.name,
                value: factory,
            });
        }
        return factory.create(ComponentCtor, arg);
    }
    destroy(component) {
        return this.unwrap().read(component.constructor.name).destroy(component);
    }
    forEvery(ComponentCtor) {
        const collection = this.unwrap().read(ComponentCtor.name);
        return collection ? collection.forEach.bind(collection) : function () { return; };
    }
}


/***/ }),

/***/ "./src/engine/Engine.ts":
/*!******************************!*\
  !*** ./src/engine/Engine.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Engine; });
/* harmony import */ var _systems_AnimatedImageSystem__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./systems/AnimatedImageSystem */ "./src/engine/systems/AnimatedImageSystem.ts");
/* harmony import */ var _ComponentFactory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./ComponentFactory */ "./src/engine/ComponentFactory.ts");
/* harmony import */ var _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/concretes/Dictionary */ "./src/framework/concretes/Dictionary.ts");
/* harmony import */ var _EntityMaster__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./EntityMaster */ "./src/engine/EntityMaster.ts");
/* harmony import */ var _systems_ImageSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./systems/ImageSystem */ "./src/engine/systems/ImageSystem.ts");
/* harmony import */ var _systems_InteractiveSystem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./systems/InteractiveSystem */ "./src/engine/systems/InteractiveSystem.ts");
/* harmony import */ var _systems_LabelSystem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./systems/LabelSystem */ "./src/engine/systems/LabelSystem.ts");
/* harmony import */ var _systems_PoseStepperSystem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./systems/PoseStepperSystem */ "./src/engine/systems/PoseStepperSystem.ts");
/* harmony import */ var _systems_ShapeSystem__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./systems/ShapeSystem */ "./src/engine/systems/ShapeSystem.ts");









class Engine {
    constructor(viewport) {
        this.viewport = viewport;
        this.components = new _ComponentFactory__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.entities = new _EntityMaster__WEBPACK_IMPORTED_MODULE_3__["default"](this);
        this.__systems = new _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_2__["default"]();
        this.__t = new Date();
        this.__initSystems();
    }
    once() {
        const now = new Date();
        this.delta = now.getTime() - this.__t.getTime();
        this.__t = now;
        this.__systems.forEach((system) => system.once());
        this.entities.once();
    }
    draw() {
        this.__systems.forEach((system) => system.draw());
        this.viewport.once();
    }
    add(SystemCtor) {
        this.__systems.write({
            key: SystemCtor.name,
            value: new SystemCtor(this),
        });
    }
    remove(SystemCtor) {
        this.__systems.delete(SystemCtor.name);
    }
    __initSystems() {
        this.add(_systems_LabelSystem__WEBPACK_IMPORTED_MODULE_6__["default"]);
        this.add(_systems_ShapeSystem__WEBPACK_IMPORTED_MODULE_8__["default"]);
        this.add(_systems_ImageSystem__WEBPACK_IMPORTED_MODULE_4__["default"]);
        this.add(_systems_AnimatedImageSystem__WEBPACK_IMPORTED_MODULE_0__["AnimatedImageSystem"]);
        this.add(_systems_InteractiveSystem__WEBPACK_IMPORTED_MODULE_5__["InteractiveSystem"]);
        this.add(_systems_PoseStepperSystem__WEBPACK_IMPORTED_MODULE_7__["PoseStepperSystem"]);
    }
}


/***/ }),

/***/ "./src/engine/Entity.ts":
/*!******************************!*\
  !*** ./src/engine/Entity.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Entity; });
/* harmony import */ var _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/abstracts/Unique */ "./src/framework/abstracts/Unique.ts");

class Entity extends _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ engine }) {
        super();
        this.$engine = engine;
        this.__data = {};
    }
    $destroy() {
        return this.$engine.entities.destroy(this);
    }
    $add(ComponentCtor) {
        return (data) => {
            if (!this.__data[ComponentCtor.name]) {
                this.__data[ComponentCtor.name] = this.$engine.components.create(ComponentCtor, data);
                this.__data[ComponentCtor.name].inject(this);
            }
            return this.$mutate(ComponentCtor)(data);
        };
    }
    $remove(ComponentCtor) {
        if (!this.__data[ComponentCtor.name]) {
            return;
        }
        delete this.__data[ComponentCtor.name];
        this.$engine.components.destroy(this.__data[ComponentCtor.name]);
    }
    $copy(ComponentCtor) {
        return (this.__data[ComponentCtor.name])
            ? this.__data[ComponentCtor.name].copy()
            : undefined;
    }
    $mutate(ComponentCtor) {
        return (data) => {
            this.__data[ComponentCtor.name].mutate(data);
        };
    }
    $patch(ComponentCtor) {
        return (data) => {
            this.__data[ComponentCtor.name].mutate(Object.assign(this.__data[ComponentCtor.name].copy(), data));
        };
    }
    $forEach(fn) {
        Object.keys(this.__data).forEach((key) => {
            fn(this.__data[key]);
        });
    }
}


/***/ }),

/***/ "./src/engine/EntityMaster.ts":
/*!************************************!*\
  !*** ./src/engine/EntityMaster.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EntityMaster; });
/* harmony import */ var _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../framework/concretes/Dictionary */ "./src/framework/concretes/Dictionary.ts");
/* harmony import */ var _framework_concretes_Factory__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../framework/concretes/Factory */ "./src/framework/concretes/Factory.ts");
/* harmony import */ var _framework_abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../framework/abstracts/Wrapper */ "./src/framework/abstracts/Wrapper.ts");



class EntityMaster extends _framework_abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor(engine) {
        super(new _framework_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]());
        this.creationTargets = [];
        this.destructionTargets = [];
        this.$engine = engine;
    }
    create(EntityCtor, arg) {
        const instance = new EntityCtor(Object.assign({}, arg, { engine: this.$engine }));
        this.creationTargets.push(instance);
        return instance;
    }
    destroy(entity) {
        this.destructionTargets.push(entity);
    }
    forEvery(EntityCtor) {
        const collection = this.unwrap().read(EntityCtor.name);
        return collection ? collection.forEach.bind(collection) : function () { return; };
    }
    first(EntityCtor) {
        const collection = this.unwrap().read(EntityCtor.name);
        return collection ? collection.first.bind(collection) : function () { return; };
    }
    find(EntityCtor) {
        const collection = this.unwrap().read(EntityCtor.name);
        return collection ? collection.find.bind(collection) : function () { return; };
    }
    once() {
        this.__createTargets();
        this.__destroyTargets();
    }
    __createTargets() {
        while (this.creationTargets.length) {
            const instance = this.creationTargets.shift();
            let target = instance;
            while (target) {
                let factory = this.unwrap().read(target.constructor.name);
                if (!factory) {
                    factory = new _framework_concretes_Factory__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    this.unwrap().write({
                        key: target.constructor.name,
                        value: factory,
                    });
                }
                factory.add(instance);
                target = target.__proto__;
            }
        }
    }
    __destroyTargets() {
        while (this.destructionTargets.length) {
            const entity = this.destructionTargets.shift();
            entity.$forEach((component) => {
                this.$engine.components.destroy(component);
            });
            let target = entity;
            while (target) {
                this.unwrap().read(target.constructor.name).destroy(entity);
                target = target.__proto__;
            }
        }
    }
}


/***/ }),

/***/ "./src/engine/KeyboardHandler.ts":
/*!***************************************!*\
  !*** ./src/engine/KeyboardHandler.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyboardHandler; });
class KeyboardHandler {
    constructor() {
        this.keydowns = {};
        this.keypresses = {};
        this.keyups = {};
    }
    keydown(keyboardEvent) {
        this.__handle(keyboardEvent, this.keydowns);
    }
    keypress(keyboardEvent) {
        this.__handle(keyboardEvent, this.keypresses);
    }
    keyup(keyboardEvent) {
        this.__handle(keyboardEvent, this.keyups);
    }
    __handle(keyboardEvent, keys) {
        if (keys[keyboardEvent.key]) {
            keys[keyboardEvent.key](keyboardEvent);
        }
    }
}


/***/ }),

/***/ "./src/engine/abstracts/System.ts":
/*!****************************************!*\
  !*** ./src/engine/abstracts/System.ts ***!
  \****************************************/
/*! exports provided: System */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "System", function() { return System; });
/* harmony import */ var _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../framework/abstracts/Unique */ "./src/framework/abstracts/Unique.ts");

class System extends _framework_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor(engine) {
        super();
        this.$engine = engine;
    }
    once() { return; }
    draw() { return; }
}


/***/ }),

/***/ "./src/engine/components.ts":
/*!**********************************!*\
  !*** ./src/engine/components.ts ***!
  \**********************************/
/*! exports provided: Pose, Shape, Label, ShapeRenderingProfile, ImageRenderingProfile, AnimatedImageRenderingProfile, PoseStepperComponent */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Pose", function() { return Pose; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Label", function() { return Label; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeRenderingProfile", function() { return ShapeRenderingProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageRenderingProfile", function() { return ImageRenderingProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimatedImageRenderingProfile", function() { return AnimatedImageRenderingProfile; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PoseStepperComponent", function() { return PoseStepperComponent; });
/* harmony import */ var _Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Component */ "./src/engine/Component.ts");

class Pose extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class Shape extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class Label extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class ShapeRenderingProfile extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class ImageRenderingProfile extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class AnimatedImageRenderingProfile extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}
class PoseStepperComponent extends _Component__WEBPACK_IMPORTED_MODULE_0__["Component"] {
}


/***/ }),

/***/ "./src/engine/entities.ts":
/*!********************************!*\
  !*** ./src/engine/entities.ts ***!
  \********************************/
/*! exports provided: Interactive, InteractiveElement, entityContainsPoint, entitiesTouch, entityTouchesLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interactive", function() { return Interactive; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InteractiveElement", function() { return InteractiveElement; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityContainsPoint", function() { return entityContainsPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entitiesTouch", function() { return entitiesTouch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityTouchesLine", function() { return entityTouchesLine; });
/* harmony import */ var _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/boolean-contains */ "./node_modules/@turf/boolean-contains/index.js");
/* harmony import */ var _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ "./node_modules/@turf/boolean-point-in-polygon/index.js");
/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Entity */ "./src/engine/Entity.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components */ "./src/engine/components.ts");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ "./src/engine/geometry.ts");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! turf */ "./node_modules/turf/index.js");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(turf__WEBPACK_IMPORTED_MODULE_5__);






const booleanOverlaps = __webpack_require__(/*! @turf/boolean-overlap */ "./node_modules/@turf/boolean-overlap/index.js").default;
const lineIntersect = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js").default;
class Interactive extends _Entity__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor({ x, y, a }) {
        super(arguments[0]);
        this.__isDisabled = false;
        this.__isHovered = false;
        this.$add(_components__WEBPACK_IMPORTED_MODULE_3__["Pose"])({ x, y, a });
    }
    $enable() {
        this.__isDisabled = false;
    }
    $disable() {
        this.__isDisabled = true;
    }
    $once() {
        if (this.__isDisabled) {
            return;
        }
        if (this.$engine.mouse.name === 'none') {
            return;
        }
        if (!entityContainsPoint(this, this.$engine.mouse)) {
            if (this.$engine.mouse.name === 'mousemove') {
                this['$mousemove']();
            }
            if (this.__isHovered) {
                this.__isHovered = false;
                this.$mouseleave();
            }
            return;
        }
        if (!this.__isHovered) {
            this.__isHovered = true;
            this.$mouseenter();
        }
        this[`$${this.$engine.mouse.name}`]();
    }
    $mouseenter() { return; }
    $mouseleave() { return; }
    $mousemove() { return; }
    $mousedown() { return; }
    $mouseup() { return; }
    $click() { return; }
}
class InteractiveElement extends Interactive {
    constructor({ x, y, width, height }) {
        super(Object.assign({ a: 0 }, arguments[0]));
        this.$add(_components__WEBPACK_IMPORTED_MODULE_3__["Shape"])({ points: [
                { x: width / 2, y: height / 2 },
                { x: -width / 2, y: height / 2 },
                { x: -width / 2, y: -height / 2 },
                { x: width / 2, y: -height / 2 },
            ] });
    }
}
const entityContainsPoint = (entity, point) => {
    const shape = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Shape"]), entity.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Pose"]));
    return _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1___default()(turf__WEBPACK_IMPORTED_MODULE_5___default.a.point([point.x, point.y]), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape));
};
const entitiesTouch = (entity1, entity2) => {
    const shape1 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity1.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Shape"]), entity1.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Pose"]));
    const shape2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity2.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Shape"]), entity2.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Pose"]));
    return _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2)) ||
        _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1)) ||
        booleanOverlaps(Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2)) ||
        booleanOverlaps(Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1));
};
const entityTouchesLine = (entity, points) => {
    const shape = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Shape"]), entity.$copy(_components__WEBPACK_IMPORTED_MODULE_3__["Pose"]));
    const polygon = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape);
    const line = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromPointsToGeoJSON"])(points);
    return lineIntersect(polygon, line).features.length > 0;
};


/***/ }),

/***/ "./src/engine/geometry.ts":
/*!********************************!*\
  !*** ./src/engine/geometry.ts ***!
  \********************************/
/*! exports provided: rotatePointAboutOrigin, transformShape, translateShape, fromPointsToGeoJSON, fromShapeToGeoJSON, fromGeoJSONCoordinatesToShapes, fromShapeToBoundary, getEuclideanDistanceBetweenPoints */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotatePointAboutOrigin", function() { return rotatePointAboutOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformShape", function() { return transformShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "translateShape", function() { return translateShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPointsToGeoJSON", function() { return fromPointsToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromShapeToGeoJSON", function() { return fromShapeToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromGeoJSONCoordinatesToShapes", function() { return fromGeoJSONCoordinatesToShapes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromShapeToBoundary", function() { return fromShapeToBoundary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEuclideanDistanceBetweenPoints", function() { return getEuclideanDistanceBetweenPoints; });
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! turf */ "./node_modules/turf/index.js");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(turf__WEBPACK_IMPORTED_MODULE_0__);

const rotatePointAboutOrigin = ({ point, orientation }) => {
    const s = Math.sin(orientation);
    const c = Math.cos(orientation);
    return {
        x: point.x * c - point.y * s,
        y: point.x * s + point.y * c,
    };
};
const transformShape = (shape, pose) => {
    const points = shape.points.map((point) => rotatePointAboutOrigin({ point, orientation: pose.a }));
    return translateShape({ shape: { points }, position: pose });
};
const translateShape = ({ shape, position }) => {
    const points = shape.points.map((point) => {
        return {
            x: point.x + position.x,
            y: point.y + position.y,
        };
    });
    return { points };
};
const fromPointsToGeoJSON = (points) => {
    return turf__WEBPACK_IMPORTED_MODULE_0___default.a.lineString(points.map((point) => [point.x, point.y]));
};
const fromShapeToGeoJSON = (shape) => {
    return turf__WEBPACK_IMPORTED_MODULE_0___default.a.polygon([
        shape.points.map((vertex) => [vertex.x, vertex.y]).concat([[shape.points[0].x, shape.points[0].y]]),
    ]);
};
const fromGeoJSONCoordinatesToShapes = (geoJSON) => {
    if (!geoJSON) {
        return [];
    }
    if (geoJSON.geometry.type === 'Polygon') {
        return geoJSON.geometry.coordinates.map((points) => {
            return { points: points.map((vertex) => ({ x: vertex[0], y: vertex[1] })) };
        });
    }
    if (geoJSON.geometry.type === 'MultiPolygon') {
        const shapes = [];
        geoJSON.geometry.coordinates.forEach((polygon) => {
            shapes.push(polygon.map((points) => {
                return { points: points.map((vertex) => ({ x: vertex[0], y: vertex[1] })) };
            })[0]);
        });
        return shapes;
    }
    return [];
};
const fromShapeToBoundary = (shape) => {
    const geojson = fromShapeToGeoJSON(shape);
    const bbox = turf__WEBPACK_IMPORTED_MODULE_0___default.a.bbox(geojson);
    return {
        minX: bbox[0],
        minY: bbox[1],
        maxX: bbox[2],
        maxY: bbox[3],
    };
};
const getEuclideanDistanceBetweenPoints = (p1, p2) => {
    return Math.sqrt(Math.pow((p2.x - p1.x), 2) + Math.pow(p2.y - p1.y, 2));
};


/***/ }),

/***/ "./src/engine/systems/AnimatedImageSystem.ts":
/*!***************************************************!*\
  !*** ./src/engine/systems/AnimatedImageSystem.ts ***!
  \***************************************************/
/*! exports provided: AnimatedImageSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimatedImageSystem", function() { return AnimatedImageSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components */ "./src/engine/components.ts");


class AnimatedImageSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])((profile) => {
            const data = profile.copy();
            if (data.cooldown === data.speed) {
                data.cooldown = 0;
                if (data.isReversed) {
                    data.frame--;
                }
                else {
                    data.frame++;
                }
                if (data.frame > data.src.length - 1) {
                    data.frame = 0;
                }
                if (data.frame < 0) {
                    data.frame = data.src.length - 1;
                }
            }
            else if (!data.isPaused) {
                data.cooldown++;
            }
            profile.$entity.$mutate(_components__WEBPACK_IMPORTED_MODULE_1__["AnimatedImageRenderingProfile"])(data);
            this.$engine.viewport.drawImage({
                pose: profile.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]),
                rendering: Object.assign(data, {
                    src: data.src[data.frame],
                }),
            });
        });
    }
}


/***/ }),

/***/ "./src/engine/systems/ImageSystem.ts":
/*!*******************************************!*\
  !*** ./src/engine/systems/ImageSystem.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components */ "./src/engine/components.ts");


class ImageSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_1__["ImageRenderingProfile"])((rendering) => {
            this.$engine.viewport.drawImage({
                pose: rendering.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]),
                rendering: rendering.copy(),
            });
        });
    }
}


/***/ }),

/***/ "./src/engine/systems/InteractiveSystem.ts":
/*!*************************************************!*\
  !*** ./src/engine/systems/InteractiveSystem.ts ***!
  \*************************************************/
/*! exports provided: InteractiveSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InteractiveSystem", function() { return InteractiveSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _entities__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../entities */ "./src/engine/entities.ts");


class InteractiveSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.entities.forEvery(_entities__WEBPACK_IMPORTED_MODULE_1__["Interactive"])((target) => {
            target.$once();
        });
    }
}


/***/ }),

/***/ "./src/engine/systems/LabelSystem.ts":
/*!*******************************************!*\
  !*** ./src/engine/systems/LabelSystem.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components */ "./src/engine/components.ts");


class LabelSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_1__["Label"])((label) => {
            this.$engine.viewport.drawLabel({
                pose: label.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]),
                label: label.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Label"]),
            });
        });
    }
}


/***/ }),

/***/ "./src/engine/systems/PoseStepperSystem.ts":
/*!*************************************************!*\
  !*** ./src/engine/systems/PoseStepperSystem.ts ***!
  \*************************************************/
/*! exports provided: PoseStepperSystem */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PoseStepperSystem", function() { return PoseStepperSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components */ "./src/engine/components.ts");


class PoseStepperSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    once() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_1__["PoseStepperComponent"])((stepper) => {
            const step = stepper.copy();
            const pose = stepper.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            stepper.$entity.$mutate(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"])({
                x: pose.x + step.x,
                y: pose.y + step.y,
                a: pose.a + step.a,
            });
        });
    }
}


/***/ }),

/***/ "./src/engine/systems/ShapeSystem.ts":
/*!*******************************************!*\
  !*** ./src/engine/systems/ShapeSystem.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShapeSystem; });
/* harmony import */ var _abstracts_System__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var _components__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../components */ "./src/engine/components.ts");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry */ "./src/engine/geometry.ts");



class ShapeSystem extends _abstracts_System__WEBPACK_IMPORTED_MODULE_0__["System"] {
    draw() {
        this.$engine.components.forEvery(_components__WEBPACK_IMPORTED_MODULE_1__["ShapeRenderingProfile"])((rendering) => {
            const shape = rendering.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Shape"]);
            const pose = rendering.$entity.$copy(_components__WEBPACK_IMPORTED_MODULE_1__["Pose"]);
            this.$engine.viewport.drawShape({
                shape: Object(_geometry__WEBPACK_IMPORTED_MODULE_2__["transformShape"])(shape, pose),
                rendering: rendering.copy(),
            });
        });
    }
}


/***/ }),

/***/ "./src/framework/abstracts/Unique.ts":
/*!*******************************************!*\
  !*** ./src/framework/abstracts/Unique.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Unique; });
const uuidv1 = __webpack_require__(/*! uuid/v1 */ "./node_modules/uuid/v1.js");
class Unique {
    get id() {
        return this.__id;
    }
    static generateUuid() {
        return uuidv1();
    }
    constructor(id) {
        this.__id = id || Unique.generateUuid();
    }
}


/***/ }),

/***/ "./src/framework/abstracts/Wrapper.ts":
/*!********************************************!*\
  !*** ./src/framework/abstracts/Wrapper.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Wrapper; });
class Wrapper {
    constructor(target) {
        this.__target = target;
    }
    unwrap() {
        return this.__target;
    }
}


/***/ }),

/***/ "./src/framework/concretes/Dictionary.ts":
/*!***********************************************!*\
  !*** ./src/framework/concretes/Dictionary.ts ***!
  \***********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Dictionary; });
/* harmony import */ var _abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../abstracts/Wrapper */ "./src/framework/abstracts/Wrapper.ts");

class Dictionary extends _abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super({});
    }
    get length() {
        return Object.keys(this.unwrap()).length;
    }
    read(key) {
        return this.unwrap()[key];
    }
    write({ key, value }) {
        this.unwrap()[key] = value;
    }
    delete(key) {
        delete this.unwrap()[key];
    }
    forEach(fn) {
        Object.keys(this.unwrap()).forEach((key) => {
            if (this.unwrap()[key]) {
                fn(this.unwrap()[key]);
            }
        });
    }
    toArray() {
        return Object.keys(this.unwrap()).map((key) => {
            return this.unwrap()[key];
        }).filter((target) => target !== undefined && target !== null);
    }
}


/***/ }),

/***/ "./src/framework/concretes/Factory.ts":
/*!********************************************!*\
  !*** ./src/framework/concretes/Factory.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Factory; });
/* harmony import */ var _Dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Dictionary */ "./src/framework/concretes/Dictionary.ts");
/* harmony import */ var _abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abstracts/Wrapper */ "./src/framework/abstracts/Wrapper.ts");


class Factory extends _abstracts_Wrapper__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super(new _Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]());
    }
    create(InstanceCtor, data) {
        const instance = new InstanceCtor(data);
        this.add(instance);
        return instance;
    }
    add(instance) {
        this.unwrap().write({
            key: instance.id,
            value: instance,
        });
    }
    destroy(instance) {
        return this.unwrap().delete(instance.id);
    }
    forEach(fn) {
        this.unwrap().forEach(fn);
    }
    first(fn) {
        const first = Object.keys(this.unwrap().unwrap()).find(() => true);
        if (first) {
            fn(this.unwrap().unwrap()[first]);
        }
    }
    find(fn) {
        const keys = Object.keys(this.unwrap().unwrap());
        for (const key of keys) {
            const target = this.unwrap().unwrap()[key];
            if (fn(target)) {
                return target;
            }
        }
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts":
/*!********************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTML5CanvasKeyboardAdapter; });
/* harmony import */ var _engine_KeyboardHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/KeyboardHandler */ "./src/engine/KeyboardHandler.ts");

class HTML5CanvasKeyboardAdapter {
    constructor(canvas) {
        this.__canvas = canvas;
        this.__buffer = [];
        this.__handler = new _engine_KeyboardHandler__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.__bindKeyboardEvents();
    }
    once() {
        const input = this.__buffer.shift();
        if (input) {
            this.__handler[input.name](input);
        }
    }
    handler(handler) {
        this.__handler = handler;
    }
    __bindKeyboardEvents() {
        [
            'keydown',
            'keypress',
            'keyup',
        ]
            .forEach((key) => {
            const canvas = this.__canvas;
            canvas[`on${key}`] = (ke) => {
                this.__buffer.push({
                    name: key,
                    key: ke.key,
                });
            };
        });
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasMouseAdaptor.ts":
/*!*****************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasMouseAdaptor.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTML5CanvasMouseAdaptor; });
const __defaultHandler = {
    mouseenter: (mouseEvent) => undefined,
    mousemove: (mouseEvent) => undefined,
    mouseleave: (mouseEvent) => undefined,
    mousedown: (mouseEvent) => undefined,
    mouseup: (mouseEvent) => undefined,
    click: (mouseEvent) => undefined,
    none: () => undefined,
};
class HTML5CanvasMouseAdaptor {
    constructor(canvas) {
        this.__canvas = canvas;
        this.__buffer = [];
        this.__handler = __defaultHandler;
        this.__bindMouseEvents();
    }
    once() {
        const event = this.__buffer.shift();
        if (event) {
            this.__handler[event.name](event);
        }
        else {
            this.__handler.none({
                name: 'none',
                x: 0,
                y: 0,
                isCtrlDown: false,
                isShiftDown: false,
            });
        }
    }
    handler(handler) {
        this.__handler = handler;
    }
    __bindMouseEvents() {
        [
            'mouseenter',
            'mousemove',
            'mouseleave',
            'mousedown',
            'mouseup',
            'click',
        ]
            .forEach((key) => {
            const canvas = this.__canvas;
            canvas[`on${key}`] = (ev) => {
                const boundingClientRect = this.__canvas.getBoundingClientRect();
                this.__buffer.push({
                    name: ev.type,
                    x: ev.clientX - boundingClientRect.left,
                    y: ev.clientY - boundingClientRect.top,
                    isCtrlDown: ev.ctrlKey,
                    isShiftDown: ev.shiftKey,
                });
            };
        });
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasViewportAdaptor.ts":
/*!********************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasViewportAdaptor.ts ***!
  \********************************************************/
/*! exports provided: HTML5CanvasViewportAdaptor */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HTML5CanvasViewportAdaptor", function() { return HTML5CanvasViewportAdaptor; });
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function Atomic(target, key, descriptor) {
    const fn = descriptor.value;
    descriptor.value = function () {
        this.ctx.save();
        fn.call(this, ...arguments);
        this.ctx.restore();
    };
}
class HTML5CanvasViewportAdaptor {
    constructor(canvas) {
        this.__imageBuffer = {};
        this.__zBuffer = [];
        this.ctx = canvas.getContext('2d');
        this.width = canvas.clientWidth;
        this.height = canvas.clientHeight;
    }
    load(src) {
        if (!this.__imageBuffer[src]) {
            this.__imageBuffer[src] = new Image();
            this.__imageBuffer[src].src = src;
        }
        return this.__imageBuffer[src];
    }
    refresh() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
    once() {
        const zBuffer = this.__zBuffer.map((target) => {
            if (!target.payload.rendering) {
                target.payload.rendering = { zIndex: 0 };
                return target;
            }
            if (!target.payload.rendering.zIndex) {
                target.payload.rendering.zIndex = 0;
                return target;
            }
            return target;
        });
        const zOrdered = zBuffer.sort((a, b) => a.payload.rendering.zIndex - b.payload.rendering.zIndex);
        zOrdered.forEach((target) => {
            this[`__${target.method}`](target.payload);
        });
        this.__zBuffer = [];
    }
    drawImage({ pose, rendering }) {
        this.__zBuffer.push({ method: 'drawImage', payload: arguments[0] });
    }
    drawShape({ shape, rendering }) {
        this.__zBuffer.push({ method: 'drawShape', payload: arguments[0] });
    }
    drawLine({ points, rendering }) {
        this.__zBuffer.push({ method: 'drawLine', payload: arguments[0] });
    }
    drawLabel({ pose, label }) {
        this.__zBuffer.push({ method: 'drawLabel', payload: arguments[0] });
    }
    drawCircle({ point, radius, rendering }) {
        this.__zBuffer.push({ method: 'drawCircle', payload: arguments[0] });
    }
    __drawImage({ pose, rendering }) {
        const image = this.load(rendering.src);
        this.ctx.translate(pose.x, pose.y);
        if (rendering.rotate) {
            this.ctx.rotate(rendering.rotate);
        }
        this.ctx.drawImage(image, -(rendering.width || image.width) / 2, -(rendering.height || image.height) / 2, rendering.width || image.width, rendering.height || image.height);
    }
    __drawShape({ shape, rendering }) {
        if (rendering.opacity) {
            this.ctx.globalAlpha = rendering.opacity;
        }
        this.ctx.strokeStyle = rendering.colour;
        this.ctx.beginPath();
        shape.points.forEach((p) => {
            this.ctx.lineTo(p.x, p.y);
        });
        if (rendering.fillStyle) {
            this.ctx.fillStyle = rendering.fillStyle;
            this.ctx.fill();
        }
        this.ctx.closePath();
        this.ctx.stroke();
    }
    __drawLine({ points, rendering }) {
        this.ctx.strokeStyle = rendering.colour;
        this.ctx.beginPath();
        points.forEach((p) => {
            this.ctx.lineTo(p.x, p.y);
        });
        this.ctx.stroke();
    }
    __drawLabel({ pose, label }) {
        this.ctx.fillStyle = label.colour || 'white';
        this.ctx.font = `${label.fontSize}px Arial`;
        this.ctx.fillText(label.text, pose.x + label.offset.x, pose.y + label.offset.y);
    }
    __drawCircle({ point, radius, rendering }) {
        this.ctx.strokeStyle = rendering.colour || 'white';
        this.ctx.beginPath();
        this.ctx.arc(point.x, point.y, radius, 0, 2 * Math.PI);
        this.ctx.stroke();
    }
}
__decorate([
    Atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawImage", null);
__decorate([
    Atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawShape", null);
__decorate([
    Atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawLine", null);
__decorate([
    Atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawLabel", null);
__decorate([
    Atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawCircle", null);


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jib3gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2JlYXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jvb2xlYW4tY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jvb2xlYW4tb3ZlcmxhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvYm9vbGVhbi1wb2ludC1pbi1wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9ib29sZWFuLXBvaW50LW9uLWxpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Rlc3RpbmF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvaW52YXJpYW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9saW5lLWludGVyc2VjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvbGluZS1vdmVybGFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9saW5lLXNlZ21lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL21ldGEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL25lYXJlc3QtcG9pbnQtb24tbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWZmaW5lLWh1bGwvYWZmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaXQtdHdpZGRsZS90d2lkZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb252ZXgtaHVsbC9jaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29udmV4LWh1bGwvbGliL2NoMWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2xpYi9jaDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb252ZXgtaHVsbC9saWIvY2huZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW9qc29uLWVxdWFsaXR5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW9qc29uLW5vcm1hbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1yYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb2pzb24tcmJ1c2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWNvbnZleC1odWxsL2ljaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbm90b25lLWNvbnZleC1odWxsLTJkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9xdWlja3NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcm9idXN0LXNjYWxlL3JvYnVzdC1zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcm9idXN0LXN1YnRyYWN0L3JvYnVzdC1kaWZmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yb2J1c3Qtc3VtL3JvYnVzdC1zdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC90b3BvbG9neS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYWxvbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYXJlYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iYm94LXBvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYmJveC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iZWFyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWJlemllci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iZXppZXIvc3BsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1jZW50ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY2VudHJvaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY29sbGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1jb21iaW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWNvbmNhdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY29udmV4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWRlc3RpbmF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWRpZmZlcmVuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZGlzdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZW52ZWxvcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZXhwbG9kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1mbGlwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1oZXgtZ3JpZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1pbnNpZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaW50ZXJzZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWludmFyaWFudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1pc29saW5lcy9jb25yZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaXNvbGluZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYta2lua3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbGluZS1kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1saW5lLXNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLW1ldGEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbWlkcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbmVhcmVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1wbGFuZXBvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXBvaW50LWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtcG9pbnQtb24tbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1wb2ludC1vbi1zdXJmYWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXBvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXJhbmRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1zYW1wbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc2ltcGxpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc3F1YXJlLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc3F1YXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXRhZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi10ZXNzZWxhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtdGluL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXRyaWFuZ2xlLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtdW5pb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtd2l0aGluL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d28tcHJvZHVjdC90d28tcHJvZHVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdvLXN1bS90d28tc3VtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmlvbi1maW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dnczg0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvQXBwLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvY29tcG9uZW50cy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2VudGl0aWVzL1dpcmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9lbnRpdGllcy9lZGl0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9lbnRpdGllcy9nYXRlcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2VudGl0aWVzL21hY2hpbmVzLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZW50aXRpZXMvc2NlbmVzLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZW50aXRpZXMvdGVybWluYWxzLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZW50aXRpZXMvdG9vbHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9lbnRpdGllcy91aS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2VudW1zL1NUQVRFLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvbWFpbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL3N5c3RlbXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9Db21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9Db21wb25lbnRGYWN0b3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvRW5naW5lLnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvRW50aXR5LnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvRW50aXR5TWFzdGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvS2V5Ym9hcmRIYW5kbGVyLnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvYWJzdHJhY3RzL1N5c3RlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZW5naW5lL2NvbXBvbmVudHMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9lbnRpdGllcy50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZW5naW5lL2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvc3lzdGVtcy9BbmltYXRlZEltYWdlU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvc3lzdGVtcy9JbWFnZVN5c3RlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZW5naW5lL3N5c3RlbXMvSW50ZXJhY3RpdmVTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9zeXN0ZW1zL0xhYmVsU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvc3lzdGVtcy9Qb3NlU3RlcHBlclN5c3RlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZW5naW5lL3N5c3RlbXMvU2hhcGVTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9hYnN0cmFjdHMvVW5pcXVlLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvYWJzdHJhY3RzL1dyYXBwZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9jb25jcmV0ZXMvRGljdGlvbmFyeS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2NvbmNyZXRlcy9GYWN0b3J5LnRzIiwid2VicGFjazovLy8uL3NyYy9odG1sNS1jYW52YXMvSFRNTDVDYW52YXNLZXlib2FyZEFkYXB0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2h0bWw1LWNhbnZhcy9IVE1MNUNhbnZhc01vdXNlQWRhcHRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaHRtbDUtY2FudmFzL0hUTUw1Q2FudmFzVmlld3BvcnRBZGFwdG9yLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQTZCO0FBQzdCLHFDQUE2QjtBQUM3QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBcUIsZ0JBQWdCO0FBQ3JDO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsNkJBQXFCLGdCQUFnQjtBQUNyQztBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxhQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0EsYUFBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLGFBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUFrQiw4QkFBOEI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLGVBQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQW9CLDJCQUEyQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBTztBQUNQO0FBQ0E7O0FBRUE7QUFD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QUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDbERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QjtBQUM1Qiw0QkFBNEIsY0FBYztBQUMxQyw0QkFBNEIsY0FBYztBQUMxQyw0QkFBNEIsY0FBYztBQUMxQztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGNBQWMsT0FBTztBQUNyQjtBQUNBLGtCQUFrQixHQUFHO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUNBQXlDLFNBQVM7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsZUFBZSxrQkFBa0I7QUFDakM7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDs7QUFFQSxpQ0FBaUMsK0JBQStCOztBQUVoRTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsa0RBQWtEOztBQUVsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFlBQVk7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQSwyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixLQUFLO0FBQ3JCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEM7Ozs7Ozs7Ozs7O0FDN2JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUEsTUFBTSxLQUEwQjs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0Esa0JBQWtCLGtDQUFrQztBQUNwRCxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsU0FBUyxTQUFTO0FBQ2xCO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsU0FBUyxZQUFZO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsU0FBUztBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsSUFBSTs7QUFFcEI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0Esd0NBQXdDLElBQUk7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYSx5QkFBeUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxVQUFVO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxjQUFjO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxnQ0FBZ0MsTUFBTTtBQUN0QztBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsRUFBRTtBQUMvQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsNERBQTREOztBQUU1RDtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDs7QUFFN0Q7QUFDQTtBQUNBO0FBQ0EsMENBQTBDOztBQUUxQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdFQUFnRTs7QUFFaEU7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDOztBQUU3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCO0FBQzNCO0FBQ0EsV0FBVyxRQUFRO0FBQ25CLFdBQVcsTUFBTTtBQUNqQixXQUFXLE1BQU07QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUEsQ0FBQzs7OztBQUlEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztBQUVBLFFBQVEsR0FBRztBQUNYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBOzs7O0FBSUE7O0FBRUE7O0FBRUE7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGdCQUFnQixTQUFTO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBOztBQUVBLGNBQWMsU0FBUztBQUN2QjtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEOzs7QUFHQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCLDBCQUEwQix3QkFBd0I7O0FBRWxEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLDBDQUEwQztBQUMxQyxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsRUFBRTtBQUNGOztBQUVBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLE9BQU87QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0Esc0JBQXNCOztBQUV0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUUsZ0JBQWdCO0FBQ2xCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxXQUFXOztBQUVYOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDtBQUNwRDs7QUFFQTtBQUNBOztBQUVBLGNBQWMsc0JBQXNCO0FBQ3BDO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLCtEQUErRDtBQUMvRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFVBQVUsY0FBYzs7QUFFeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixtQkFBbUI7QUFDcEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQix1Q0FBdUM7QUFDakU7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLHVEQUF1RDtBQUM5RTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSywrQ0FBK0M7QUFDcEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDLGNBQWM7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVELGNBQWMscUNBQXFDO0FBQ25EOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQyxPQUFPO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsOEJBQThCOztBQUU5QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFF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a0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxhQUFhOztBQUViO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSixpREFBaUQsMEJBQTBCO0FBQzNFOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLDJCQUEyQjtBQUMzQjtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBLGlDQUFpQztBQUNqQztBQUNBOztBQUVBLElBQUk7QUFDSjs7QUFFQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQSxXQUFXLFNBQVM7QUFDcEI7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7OztBQUdBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLDJDQUEyQztBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsS0FBSztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUscUNBQXFDOztBQUVwRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFF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Rzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLDJCQUEyQjs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGtDQUFrQzs7QUFFbEM7QUFDQSxzQkFBc0I7QUFDdEIsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDs7QUFFQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHVCQUF1QjtBQUNsQyxXQUFXLHlCQUF5QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQjtBQUMvQixhQUFhLHVDQUF1QztBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSixHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFD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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUMzSlk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDM0phOztBQUViLGdCQUFnQixtQkFBTyxDQUFDLDBEQUFhO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixNQUFNO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBLDZCQUE2QixNQUFNO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsTUFBTTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQzVHO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7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QixFQUFFLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNuRSxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsc0VBQXFCLEVBQUUsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3BFLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxvRUFBbUIsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDbkUsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLHFFQUFvQixFQUFFLEVBQUUsQ0FBQyxFQUFFLEdBQUcsRUFBRSxDQUFDLEVBQUUsRUFBRSxFQUFFLENBQUMsQ0FBQztBQUNwRSxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMscUVBQW9CLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxFQUFFLEVBQUUsQ0FBQyxDQUFDO0FBQ3BFLEdBQUcsQ0FBQyxNQUFNLENBQUMsUUFBUSxDQUFDLE1BQU0sQ0FBQyxxRUFBb0IsRUFBRSxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFDLENBQUM7QUFDcEUsTUFBTSxNQUFNLEdBQUcsR0FBRyxDQUFDLE1BQU0sQ0FBQyxRQUFRLENBQUMsTUFBTSxDQUFDLDBEQUFTLEVBQUUsRUFBRSxDQUFDLEVBQUUsR0FBRyxFQUFFLENBQUMsRUFBRSxHQUFHLEVBQUUsS0FBSyxFQUFFLEdBQUcsRUFBRSxNQUFNLEVBQUUsR0FBRyxFQUFFLENBQUMsQ0FBQztBQUVsRyxHQUFHLENBQUMsTUFBTSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsMkRBQVUsRUFBRSxFQUFFLENBQUMsRUFBRSxJQUFJLEVBQUUsQ0FBQyxFQUFFLEVBQUUsRUFBRSxDQUFD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REMsTUFBTTs2REFjTjtBQUdEO0lBREMsTUFBTTs2REFnQk47QUFHRDtJQURDLE1BQU07NERBUU47QUFHRDtJQURDLE1BQU07NkRBS047QUFHRDtJQURDLE1BQU07OERBUU4iLCJmaWxlIjoiYnVuZGxlLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0ZnVuY3Rpb24gaG90RGlzcG9zZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0ZGVsZXRlIGluc3RhbGxlZENodW5rc1tjaHVua0lkXTtcbiBcdH1cbiBcdHZhciBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayA9IHdpbmRvd1tcIndlYnBhY2tIb3RVcGRhdGVcIl07XG4gXHR3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdID0gLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiB3ZWJwYWNrSG90VXBkYXRlQ2FsbGJhY2soY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHtcbiBcdFx0aG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpO1xuIFx0XHRpZiAocGFyZW50SG90VXBkYXRlQ2FsbGJhY2spIHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdH0gO1xuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHR2YXIgc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNjcmlwdFwiKTtcbiBcdFx0c2NyaXB0LmNoYXJzZXQgPSBcInV0Zi04XCI7XG4gXHRcdHNjcmlwdC5zcmMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgY2h1bmtJZCArIFwiLlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzXCI7XG4gXHRcdGlmIChudWxsKSBzY3JpcHQuY3Jvc3NPcmlnaW4gPSBudWxsO1xuIFx0XHRkb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG4gXHR9XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90RG93bmxvYWRNYW5pZmVzdChyZXF1ZXN0VGltZW91dCkge1xuIFx0XHRyZXF1ZXN0VGltZW91dCA9IHJlcXVlc3RUaW1lb3V0IHx8IDEwMDAwO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSwgcmVqZWN0KSB7XG4gXHRcdFx0aWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChuZXcgRXJyb3IoXCJObyBicm93c2VyIHN1cHBvcnRcIikpO1xuIFx0XHRcdH1cbiBcdFx0XHR0cnkge1xuIFx0XHRcdFx0dmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiBcdFx0XHRcdHZhciByZXF1ZXN0UGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18ucCArIFwiXCIgKyBob3RDdXJyZW50SGFzaCArIFwiLmhvdC11cGRhdGUuanNvblwiO1xuIFx0XHRcdFx0cmVxdWVzdC5vcGVuKFwiR0VUXCIsIHJlcXVlc3RQYXRoLCB0cnVlKTtcbiBcdFx0XHRcdHJlcXVlc3QudGltZW91dCA9IHJlcXVlc3RUaW1lb3V0O1xuIFx0XHRcdFx0cmVxdWVzdC5zZW5kKG51bGwpO1xuIFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0cmV0dXJuIHJlamVjdChlcnIpO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXF1ZXN0Lm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0aWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkgcmV0dXJuO1xuIFx0XHRcdFx0aWYgKHJlcXVlc3Quc3RhdHVzID09PSAwKSB7XG4gXHRcdFx0XHRcdC8vIHRpbWVvdXRcbiBcdFx0XHRcdFx0cmVqZWN0KFxuIFx0XHRcdFx0XHRcdG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIHRpbWVkIG91dC5cIilcbiBcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDQwNCkge1xuIFx0XHRcdFx0XHQvLyBubyB1cGRhdGUgYXZhaWxhYmxlXG4gXHRcdFx0XHRcdHJlc29sdmUoKTtcbiBcdFx0XHRcdH0gZWxzZSBpZiAocmVxdWVzdC5zdGF0dXMgIT09IDIwMCAmJiByZXF1ZXN0LnN0YXR1cyAhPT0gMzA0KSB7XG4gXHRcdFx0XHRcdC8vIG90aGVyIGZhaWx1cmVcbiBcdFx0XHRcdFx0cmVqZWN0KG5ldyBFcnJvcihcIk1hbmlmZXN0IHJlcXVlc3QgdG8gXCIgKyByZXF1ZXN0UGF0aCArIFwiIGZhaWxlZC5cIikpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0Ly8gc3VjY2Vzc1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdHZhciB1cGRhdGUgPSBKU09OLnBhcnNlKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiBcdFx0XHRcdFx0fSBjYXRjaCAoZSkge1xuIFx0XHRcdFx0XHRcdHJlamVjdChlKTtcbiBcdFx0XHRcdFx0XHRyZXR1cm47XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0cmVzb2x2ZSh1cGRhdGUpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHR2YXIgaG90QXBwbHlPblVwZGF0ZSA9IHRydWU7XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50SGFzaCA9IFwiYWE5M2FiNWE2NzUxY2YwMmFlMDBcIjtcbiBcdHZhciBob3RSZXF1ZXN0VGltZW91dCA9IDEwMDAwO1xuIFx0dmFyIGhvdEN1cnJlbnRNb2R1bGVEYXRhID0ge307XG4gXHR2YXIgaG90Q3VycmVudENoaWxkTW9kdWxlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudFBhcmVudHMgPSBbXTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCA9IFtdO1xuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIG1lID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdGlmICghbWUpIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fO1xuIFx0XHR2YXIgZm4gPSBmdW5jdGlvbihyZXF1ZXN0KSB7XG4gXHRcdFx0aWYgKG1lLmhvdC5hY3RpdmUpIHtcbiBcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdKSB7XG4gXHRcdFx0XHRcdGlmIChpbnN0YWxsZWRNb2R1bGVzW3JlcXVlc3RdLnBhcmVudHMuaW5kZXhPZihtb2R1bGVJZCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLnB1c2gobW9kdWxlSWQpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHJlcXVlc3Q7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAobWUuY2hpbGRyZW4uaW5kZXhPZihyZXF1ZXN0KSA9PT0gLTEpIHtcbiBcdFx0XHRcdFx0bWUuY2hpbGRyZW4ucHVzaChyZXF1ZXN0KTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XHRcIltITVJdIHVuZXhwZWN0ZWQgcmVxdWlyZShcIiArXG4gXHRcdFx0XHRcdFx0cmVxdWVzdCArXG4gXHRcdFx0XHRcdFx0XCIpIGZyb20gZGlzcG9zZWQgbW9kdWxlIFwiICtcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZFxuIFx0XHRcdFx0KTtcbiBcdFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fKHJlcXVlc3QpO1xuIFx0XHR9O1xuIFx0XHR2YXIgT2JqZWN0RmFjdG9yeSA9IGZ1bmN0aW9uIE9iamVjdEZhY3RvcnkobmFtZSkge1xuIFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG4gXHRcdFx0XHRlbnVtZXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX19bbmFtZV07XG4gXHRcdFx0XHR9LFxuIFx0XHRcdFx0c2V0OiBmdW5jdGlvbih2YWx1ZSkge1xuIFx0XHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdID0gdmFsdWU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fTtcbiBcdFx0fTtcbiBcdFx0Zm9yICh2YXIgbmFtZSBpbiBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKF9fd2VicGFja19yZXF1aXJlX18sIG5hbWUpICYmXG4gXHRcdFx0XHRuYW1lICE9PSBcImVcIiAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJ0XCJcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShmbiwgbmFtZSwgT2JqZWN0RmFjdG9yeShuYW1lKSk7XG4gXHRcdFx0fVxuIFx0XHR9XG4gXHRcdGZuLmUgPSBmdW5jdGlvbihjaHVua0lkKSB7XG4gXHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJyZWFkeVwiKSBob3RTZXRTdGF0dXMoXCJwcmVwYXJlXCIpO1xuIFx0XHRcdGhvdENodW5rc0xvYWRpbmcrKztcbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXy5lKGNodW5rSWQpLnRoZW4oZmluaXNoQ2h1bmtMb2FkaW5nLCBmdW5jdGlvbihlcnIpIHtcbiBcdFx0XHRcdGZpbmlzaENodW5rTG9hZGluZygpO1xuIFx0XHRcdFx0dGhyb3cgZXJyO1xuIFx0XHRcdH0pO1xuXG4gXHRcdFx0ZnVuY3Rpb24gZmluaXNoQ2h1bmtMb2FkaW5nKCkge1xuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZy0tO1xuIFx0XHRcdFx0aWYgKGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIpIHtcbiBcdFx0XHRcdFx0aWYgKCFob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRpZiAoaG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJiBob3RXYWl0aW5nRmlsZXMgPT09IDApIHtcbiBcdFx0XHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH07XG4gXHRcdGZuLnQgPSBmdW5jdGlvbih2YWx1ZSwgbW9kZSkge1xuIFx0XHRcdGlmIChtb2RlICYgMSkgdmFsdWUgPSBmbih2YWx1ZSk7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18udCh2YWx1ZSwgbW9kZSAmIH4xKTtcbiBcdFx0fTtcbiBcdFx0cmV0dXJuIGZuO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdENyZWF0ZU1vZHVsZShtb2R1bGVJZCkge1xuIFx0XHR2YXIgaG90ID0ge1xuIFx0XHRcdC8vIHByaXZhdGUgc3R1ZmZcbiBcdFx0XHRfYWNjZXB0ZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9kZWNsaW5lZERlcGVuZGVuY2llczoge30sXG4gXHRcdFx0X3NlbGZBY2NlcHRlZDogZmFsc2UsXG4gXHRcdFx0X3NlbGZEZWNsaW5lZDogZmFsc2UsXG4gXHRcdFx0X2Rpc3Bvc2VIYW5kbGVyczogW10sXG4gXHRcdFx0X21haW46IGhvdEN1cnJlbnRDaGlsZE1vZHVsZSAhPT0gbW9kdWxlSWQsXG5cbiBcdFx0XHQvLyBNb2R1bGUgQVBJXG4gXHRcdFx0YWN0aXZlOiB0cnVlLFxuIFx0XHRcdGFjY2VwdDogZnVuY3Rpb24oZGVwLCBjYWxsYmFjaykge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZBY2NlcHRlZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcImZ1bmN0aW9uXCIpIGhvdC5fc2VsZkFjY2VwdGVkID0gZGVwO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBbaV1dID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBdID0gY2FsbGJhY2sgfHwgZnVuY3Rpb24oKSB7fTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRlY2xpbmU6IGZ1bmN0aW9uKGRlcCkge1xuIFx0XHRcdFx0aWYgKGRlcCA9PT0gdW5kZWZpbmVkKSBob3QuX3NlbGZEZWNsaW5lZCA9IHRydWU7XG4gXHRcdFx0XHRlbHNlIGlmICh0eXBlb2YgZGVwID09PSBcIm9iamVjdFwiKVxuIFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGRlcC5sZW5ndGg7IGkrKylcbiBcdFx0XHRcdFx0XHRob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcFtpXV0gPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBob3QuX2RlY2xpbmVkRGVwZW5kZW5jaWVzW2RlcF0gPSB0cnVlO1xuIFx0XHRcdH0sXG4gXHRcdFx0ZGlzcG9zZTogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdGhvdC5fZGlzcG9zZUhhbmRsZXJzLnB1c2goY2FsbGJhY2spO1xuIFx0XHRcdH0sXG4gXHRcdFx0YWRkRGlzcG9zZUhhbmRsZXI6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdHJlbW92ZURpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0dmFyIGlkeCA9IGhvdC5fZGlzcG9zZUhhbmRsZXJzLmluZGV4T2YoY2FsbGJhY2spO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuXG4gXHRcdFx0Ly8gTWFuYWdlbWVudCBBUElcbiBcdFx0XHRjaGVjazogaG90Q2hlY2ssXG4gXHRcdFx0YXBwbHk6IGhvdEFwcGx5LFxuIFx0XHRcdHN0YXR1czogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0aWYgKCFsKSByZXR1cm4gaG90U3RhdHVzO1xuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZFN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzLnB1c2gobCk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVTdGF0dXNIYW5kbGVyOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHR2YXIgaWR4ID0gaG90U3RhdHVzSGFuZGxlcnMuaW5kZXhPZihsKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90U3RhdHVzSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcblxuIFx0XHRcdC8vaW5oZXJpdCBmcm9tIHByZXZpb3VzIGRpc3Bvc2UgY2FsbFxuIFx0XHRcdGRhdGE6IGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXVxuIFx0XHR9O1xuIFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSB1bmRlZmluZWQ7XG4gXHRcdHJldHVybiBob3Q7XG4gXHR9XG5cbiBcdHZhciBob3RTdGF0dXNIYW5kbGVycyA9IFtdO1xuIFx0dmFyIGhvdFN0YXR1cyA9IFwiaWRsZVwiO1xuXG4gXHRmdW5jdGlvbiBob3RTZXRTdGF0dXMobmV3U3RhdHVzKSB7XG4gXHRcdGhvdFN0YXR1cyA9IG5ld1N0YXR1cztcbiBcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBob3RTdGF0dXNIYW5kbGVycy5sZW5ndGg7IGkrKylcbiBcdFx0XHRob3RTdGF0dXNIYW5kbGVyc1tpXS5jYWxsKG51bGwsIG5ld1N0YXR1cyk7XG4gXHR9XG5cbiBcdC8vIHdoaWxlIGRvd25sb2FkaW5nXG4gXHR2YXIgaG90V2FpdGluZ0ZpbGVzID0gMDtcbiBcdHZhciBob3RDaHVua3NMb2FkaW5nID0gMDtcbiBcdHZhciBob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdEF2YWlsYWJsZUZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90RGVmZXJyZWQ7XG5cbiBcdC8vIFRoZSB1cGRhdGUgaW5mb1xuIFx0dmFyIGhvdFVwZGF0ZSwgaG90VXBkYXRlTmV3SGFzaDtcblxuIFx0ZnVuY3Rpb24gdG9Nb2R1bGVJZChpZCkge1xuIFx0XHR2YXIgaXNOdW1iZXIgPSAraWQgKyBcIlwiID09PSBpZDtcbiBcdFx0cmV0dXJuIGlzTnVtYmVyID8gK2lkIDogaWQ7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdENoZWNrKGFwcGx5KSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwiaWRsZVwiKSB7XG4gXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2hlY2soKSBpcyBvbmx5IGFsbG93ZWQgaW4gaWRsZSBzdGF0dXNcIik7XG4gXHRcdH1cbiBcdFx0aG90QXBwbHlPblVwZGF0ZSA9IGFwcGx5O1xuIFx0XHRob3RTZXRTdGF0dXMoXCJjaGVja1wiKTtcbiBcdFx0cmV0dXJuIGhvdERvd25sb2FkTWFuaWZlc3QoaG90UmVxdWVzdFRpbWVvdXQpLnRoZW4oZnVuY3Rpb24odXBkYXRlKSB7XG4gXHRcdFx0aWYgKCF1cGRhdGUpIHtcbiBcdFx0XHRcdGhvdFNldFN0YXR1cyhcImlkbGVcIik7XG4gXHRcdFx0XHRyZXR1cm4gbnVsbDtcbiBcdFx0XHR9XG4gXHRcdFx0aG90UmVxdWVzdGVkRmlsZXNNYXAgPSB7fTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXAgPSB7fTtcbiBcdFx0XHRob3RBdmFpbGFibGVGaWxlc01hcCA9IHVwZGF0ZS5jO1xuIFx0XHRcdGhvdFVwZGF0ZU5ld0hhc2ggPSB1cGRhdGUuaDtcblxuIFx0XHRcdGhvdFNldFN0YXR1cyhcInByZXBhcmVcIik7XG4gXHRcdFx0dmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiBcdFx0XHRcdGhvdERlZmVycmVkID0ge1xuIFx0XHRcdFx0XHRyZXNvbHZlOiByZXNvbHZlLFxuIFx0XHRcdFx0XHRyZWplY3Q6IHJlamVjdFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHRob3RVcGRhdGUgPSB7fTtcbiBcdFx0XHR2YXIgY2h1bmtJZCA9IFwibWFpblwiO1xuIFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1sb25lLWJsb2Nrc1xuIFx0XHRcdHtcbiBcdFx0XHRcdC8qZ2xvYmFscyBjaHVua0lkICovXG4gXHRcdFx0XHRob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0XHR9XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aG90U3RhdHVzID09PSBcInByZXBhcmVcIiAmJlxuIFx0XHRcdFx0aG90Q2h1bmtzTG9hZGluZyA9PT0gMCAmJlxuIFx0XHRcdFx0aG90V2FpdGluZ0ZpbGVzID09PSAwXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdFx0fVxuIFx0XHRcdHJldHVybiBwcm9taXNlO1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RBZGRVcGRhdGVDaHVuayhjaHVua0lkLCBtb3JlTW9kdWxlcykge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdIHx8ICFob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSlcbiBcdFx0XHRyZXR1cm47XG4gXHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gZmFsc2U7XG4gXHRcdGZvciAodmFyIG1vZHVsZUlkIGluIG1vcmVNb2R1bGVzKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb3JlTW9kdWxlcywgbW9kdWxlSWQpKSB7XG4gXHRcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9yZU1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRpZiAoLS1ob3RXYWl0aW5nRmlsZXMgPT09IDAgJiYgaG90Q2h1bmtzTG9hZGluZyA9PT0gMCkge1xuIFx0XHRcdGhvdFVwZGF0ZURvd25sb2FkZWQoKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RFbnN1cmVVcGRhdGVDaHVuayhjaHVua0lkKSB7XG4gXHRcdGlmICghaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0pIHtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXNNYXBbY2h1bmtJZF0gPSB0cnVlO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdGhvdFJlcXVlc3RlZEZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0XHRob3RXYWl0aW5nRmlsZXMrKztcbiBcdFx0XHRob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpO1xuIFx0XHR9XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdFVwZGF0ZURvd25sb2FkZWQoKSB7XG4gXHRcdGhvdFNldFN0YXR1cyhcInJlYWR5XCIpO1xuIFx0XHR2YXIgZGVmZXJyZWQgPSBob3REZWZlcnJlZDtcbiBcdFx0aG90RGVmZXJyZWQgPSBudWxsO1xuIFx0XHRpZiAoIWRlZmVycmVkKSByZXR1cm47XG4gXHRcdGlmIChob3RBcHBseU9uVXBkYXRlKSB7XG4gXHRcdFx0Ly8gV3JhcCBkZWZlcnJlZCBvYmplY3QgaW4gUHJvbWlzZSB0byBtYXJrIGl0IGFzIGEgd2VsbC1oYW5kbGVkIFByb21pc2UgdG9cbiBcdFx0XHQvLyBhdm9pZCB0cmlnZ2VyaW5nIHVuY2F1Z2h0IGV4Y2VwdGlvbiB3YXJuaW5nIGluIENocm9tZS5cbiBcdFx0XHQvLyBTZWUgaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDY1NjY2XG4gXHRcdFx0UHJvbWlzZS5yZXNvbHZlKClcbiBcdFx0XHRcdC50aGVuKGZ1bmN0aW9uKCkge1xuIFx0XHRcdFx0XHRyZXR1cm4gaG90QXBwbHkoaG90QXBwbHlPblVwZGF0ZSk7XG4gXHRcdFx0XHR9KVxuIFx0XHRcdFx0LnRoZW4oXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKHJlc3VsdCkge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmUocmVzdWx0KTtcbiBcdFx0XHRcdFx0fSxcbiBcdFx0XHRcdFx0ZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0KGVycik7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdCk7XG4gXHRcdH0gZWxzZSB7XG4gXHRcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIGlkKSkge1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaCh0b01vZHVsZUlkKGlkKSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHRcdGRlZmVycmVkLnJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseShvcHRpb25zKSB7XG4gXHRcdGlmIChob3RTdGF0dXMgIT09IFwicmVhZHlcIilcbiBcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXCJhcHBseSgpIGlzIG9ubHkgYWxsb3dlZCBpbiByZWFkeSBzdGF0dXNcIik7XG4gXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG4gXHRcdHZhciBjYjtcbiBcdFx0dmFyIGk7XG4gXHRcdHZhciBqO1xuIFx0XHR2YXIgbW9kdWxlO1xuIFx0XHR2YXIgbW9kdWxlSWQ7XG5cbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbihpZCkge1xuIFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXG4gXHRcdFx0XHRcdGlkOiBpZFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuIFx0XHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAoIW1vZHVsZSB8fCBtb2R1bGUuaG90Ll9zZWxmQWNjZXB0ZWQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0aWYgKG1vZHVsZS5ob3QuX3NlbGZEZWNsaW5lZCkge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1kZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9tYWluKSB7XG4gXHRcdFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJ1bmFjY2VwdGVkXCIsXG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBtb2R1bGUucGFyZW50cy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHR2YXIgcGFyZW50SWQgPSBtb2R1bGUucGFyZW50c1tpXTtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudCA9IGluc3RhbGxlZE1vZHVsZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRpZiAoIXBhcmVudCkgY29udGludWU7XG4gXHRcdFx0XHRcdGlmIChwYXJlbnQuaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdFx0dHlwZTogXCJkZWNsaW5lZFwiLFxuIFx0XHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0XHRcdHBhcmVudElkOiBwYXJlbnRJZFxuIFx0XHRcdFx0XHRcdH07XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKG91dGRhdGVkTW9kdWxlcy5pbmRleE9mKHBhcmVudElkKSAhPT0gLTEpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0pXG4gXHRcdFx0XHRcdFx0XHRvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0gPSBbXTtcbiBcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF0sIFttb2R1bGVJZF0pO1xuIFx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGRlbGV0ZSBvdXRkYXRlZERlcGVuZGVuY2llc1twYXJlbnRJZF07XG4gXHRcdFx0XHRcdG91dGRhdGVkTW9kdWxlcy5wdXNoKHBhcmVudElkKTtcbiBcdFx0XHRcdFx0cXVldWUucHVzaCh7XG4gXHRcdFx0XHRcdFx0Y2hhaW46IGNoYWluLmNvbmNhdChbcGFyZW50SWRdKSxcbiBcdFx0XHRcdFx0XHRpZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0fSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuXG4gXHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdHR5cGU6IFwiYWNjZXB0ZWRcIixcbiBcdFx0XHRcdG1vZHVsZUlkOiB1cGRhdGVNb2R1bGVJZCxcbiBcdFx0XHRcdG91dGRhdGVkTW9kdWxlczogb3V0ZGF0ZWRNb2R1bGVzLFxuIFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXM6IG91dGRhdGVkRGVwZW5kZW5jaWVzXG4gXHRcdFx0fTtcbiBcdFx0fVxuXG4gXHRcdGZ1bmN0aW9uIGFkZEFsbFRvU2V0KGEsIGIpIHtcbiBcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGIubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdHZhciBpdGVtID0gYltpXTtcbiBcdFx0XHRcdGlmIChhLmluZGV4T2YoaXRlbSkgPT09IC0xKSBhLnB1c2goaXRlbSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gYXQgYmVnaW4gYWxsIHVwZGF0ZXMgbW9kdWxlcyBhcmUgb3V0ZGF0ZWRcbiBcdFx0Ly8gdGhlIFwib3V0ZGF0ZWRcIiBzdGF0dXMgY2FuIHByb3BhZ2F0ZSB0byBwYXJlbnRzIGlmIHRoZXkgZG9uJ3QgYWNjZXB0IHRoZSBjaGlsZHJlblxuIFx0XHR2YXIgb3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSB7fTtcbiBcdFx0dmFyIG91dGRhdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHR2YXIgYXBwbGllZFVwZGF0ZSA9IHt9O1xuXG4gXHRcdHZhciB3YXJuVW5leHBlY3RlZFJlcXVpcmUgPSBmdW5jdGlvbiB3YXJuVW5leHBlY3RlZFJlcXVpcmUoKSB7XG4gXHRcdFx0Y29uc29sZS53YXJuKFxuIFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgKyByZXN1bHQubW9kdWxlSWQgKyBcIikgdG8gZGlzcG9zZWQgbW9kdWxlXCJcbiBcdFx0XHQpO1xuIFx0XHR9O1xuXG4gXHRcdGZvciAodmFyIGlkIGluIGhvdFVwZGF0ZSkge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdG1vZHVsZUlkID0gdG9Nb2R1bGVJZChpZCk7XG4gXHRcdFx0XHQvKiogQHR5cGUge1RPRE99ICovXG4gXHRcdFx0XHR2YXIgcmVzdWx0O1xuIFx0XHRcdFx0aWYgKGhvdFVwZGF0ZVtpZF0pIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0gZ2V0QWZmZWN0ZWRTdHVmZihtb2R1bGVJZCk7XG4gXHRcdFx0XHR9IGVsc2Uge1xuIFx0XHRcdFx0XHRyZXN1bHQgPSB7XG4gXHRcdFx0XHRcdFx0dHlwZTogXCJkaXNwb3NlZFwiLFxuIFx0XHRcdFx0XHRcdG1vZHVsZUlkOiBpZFxuIFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0LyoqIEB0eXBlIHtFcnJvcnxmYWxzZX0gKi9cbiBcdFx0XHRcdHZhciBhYm9ydEVycm9yID0gZmFsc2U7XG4gXHRcdFx0XHR2YXIgZG9BcHBseSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvRGlzcG9zZSA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGNoYWluSW5mbyA9IFwiXCI7XG4gXHRcdFx0XHRpZiAocmVzdWx0LmNoYWluKSB7XG4gXHRcdFx0XHRcdGNoYWluSW5mbyA9IFwiXFxuVXBkYXRlIHByb3BhZ2F0aW9uOiBcIiArIHJlc3VsdC5jaGFpbi5qb2luKFwiIC0+IFwiKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdHN3aXRjaCAocmVzdWx0LnR5cGUpIHtcbiBcdFx0XHRcdFx0Y2FzZSBcInNlbGYtZGVjbGluZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRlY2xpbmVkKSBvcHRpb25zLm9uRGVjbGluZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlRGVjbGluZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBvZiBzZWxmIGRlY2xpbmU6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2YgZGVjbGluZWQgZGVwZW5kZW5jeTogXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5tb2R1bGVJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0XCIgaW4gXCIgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdHJlc3VsdC5wYXJlbnRJZCArXG4gXHRcdFx0XHRcdFx0XHRcdFx0Y2hhaW5JbmZvXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwidW5hY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uVW5hY2NlcHRlZCkgb3B0aW9ucy5vblVuYWNjZXB0ZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRpZiAoIW9wdGlvbnMuaWdub3JlVW5hY2NlcHRlZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIFwiICsgbW9kdWxlSWQgKyBcIiBpcyBub3QgYWNjZXB0ZWRcIiArIGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcImFjY2VwdGVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25BY2NlcHRlZCkgb3B0aW9ucy5vbkFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0ZG9BcHBseSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkaXNwb3NlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGlzcG9zZWQpIG9wdGlvbnMub25EaXNwb3NlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvRGlzcG9zZSA9IHRydWU7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGRlZmF1bHQ6XG4gXHRcdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiVW5leGNlcHRpb24gdHlwZSBcIiArIHJlc3VsdC50eXBlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChhYm9ydEVycm9yKSB7XG4gXHRcdFx0XHRcdGhvdFNldFN0YXR1cyhcImFib3J0XCIpO1xuIFx0XHRcdFx0XHRyZXR1cm4gUHJvbWlzZS5yZWplY3QoYWJvcnRFcnJvcik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoZG9BcHBseSkge1xuIFx0XHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSA9IGhvdFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGFkZEFsbFRvU2V0KG91dGRhdGVkTW9kdWxlcywgcmVzdWx0Lm91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdFx0XHRcdGZvciAobW9kdWxlSWQgaW4gcmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0XHRcdFx0aWYgKFxuIFx0XHRcdFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXMsXG4gXHRcdFx0XHRcdFx0XHRcdG1vZHVsZUlkXG4gXHRcdFx0XHRcdFx0XHQpXG4gXHRcdFx0XHRcdFx0KSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoIW91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSlcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdID0gW107XG4gXHRcdFx0XHRcdFx0XHRhZGRBbGxUb1NldChcbiBcdFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdLFxuIFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQub3V0ZGF0ZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdXG4gXHRcdFx0XHRcdFx0XHQpO1xuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvRGlzcG9zZSkge1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIFtyZXN1bHQubW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSB3YXJuVW5leHBlY3RlZFJlcXVpcmU7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gU3RvcmUgc2VsZiBhY2NlcHRlZCBvdXRkYXRlZCBtb2R1bGVzIHRvIHJlcXVpcmUgdGhlbSBsYXRlciBieSB0aGUgbW9kdWxlIHN5c3RlbVxuIFx0XHR2YXIgb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzID0gW107XG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRtb2R1bGVJZCA9IG91dGRhdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRpZiAoXG4gXHRcdFx0XHRpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXSAmJlxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uaG90Ll9zZWxmQWNjZXB0ZWQgJiZcbiBcdFx0XHRcdC8vIHJlbW92ZWQgc2VsZi1hY2NlcHRlZCBtb2R1bGVzIHNob3VsZCBub3QgYmUgcmVxdWlyZWRcbiBcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdICE9PSB3YXJuVW5leHBlY3RlZFJlcXVpcmVcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5wdXNoKHtcbiBcdFx0XHRcdFx0bW9kdWxlOiBtb2R1bGVJZCxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG4gXHRcdE9iamVjdC5rZXlzKGhvdEF2YWlsYWJsZUZpbGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rSWQpIHtcbiBcdFx0XHRpZiAoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XG4gXHRcdFx0XHRob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0fVxuIFx0XHR9KTtcblxuIFx0XHR2YXIgaWR4O1xuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcbiBcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuIFx0XHRcdHZhciBkYXRhID0ge307XG5cbiBcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuIFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xuIFx0XHRcdFx0Y2IoZGF0YSk7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XG5cbiBcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cbiBcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cbiBcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuIFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG4gXHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG4gXHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cbiBcdFx0dmFyIGRlcGVuZGVuY3k7XG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcbiBcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcbiBcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XG5cbiBcdFx0aG90Q3VycmVudEhhc2ggPSBob3RVcGRhdGVOZXdIYXNoO1xuXG4gXHRcdC8vIGluc2VydCBuZXcgY29kZVxuIFx0XHRmb3IgKG1vZHVsZUlkIGluIGFwcGxpZWRVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGFwcGxpZWRVcGRhdGUsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0bW9kdWxlc1ttb2R1bGVJZF0gPSBhcHBsaWVkVXBkYXRlW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBjYWxsIGFjY2VwdCBoYW5kbGVyc1xuIFx0XHR2YXIgZXJyb3IgPSBudWxsO1xuIFx0XHRmb3IgKG1vZHVsZUlkIGluIG91dGRhdGVkRGVwZW5kZW5jaWVzKSB7XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG91dGRhdGVkRGVwZW5kZW5jaWVzLCBtb2R1bGVJZClcbiBcdFx0XHQpIHtcbiBcdFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdFx0aWYgKG1vZHVsZSkge1xuIFx0XHRcdFx0XHRtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyA9IG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0dmFyIGNhbGxiYWNrcyA9IFtdO1xuIFx0XHRcdFx0XHRmb3IgKGkgPSAwOyBpIDwgbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRkZXBlbmRlbmN5ID0gbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV07XG4gXHRcdFx0XHRcdFx0Y2IgPSBtb2R1bGUuaG90Ll9hY2NlcHRlZERlcGVuZGVuY2llc1tkZXBlbmRlbmN5XTtcbiBcdFx0XHRcdFx0XHRpZiAoY2IpIHtcbiBcdFx0XHRcdFx0XHRcdGlmIChjYWxsYmFja3MuaW5kZXhPZihjYikgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0XHRcdGNhbGxiYWNrcy5wdXNoKGNiKTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IGNhbGxiYWNrcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdFx0XHRcdGNiID0gY2FsbGJhY2tzW2ldO1xuIFx0XHRcdFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRcdFx0XHRjYihtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcyk7XG4gXHRcdFx0XHRcdFx0fSBjYXRjaCAoZXJyKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0b3B0aW9ucy5vbkVycm9yZWQoe1xuIFx0XHRcdFx0XHRcdFx0XHRcdHR5cGU6IFwiYWNjZXB0LWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZGVwZW5kZW5jeUlkOiBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tpXSxcbiBcdFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTG9hZCBzZWxmIGFjY2VwdGVkIG1vZHVsZXNcbiBcdFx0Zm9yIChpID0gMDsgaSA8IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcy5sZW5ndGg7IGkrKykge1xuIFx0XHRcdHZhciBpdGVtID0gb3V0ZGF0ZWRTZWxmQWNjZXB0ZWRNb2R1bGVzW2ldO1xuIFx0XHRcdG1vZHVsZUlkID0gaXRlbS5tb2R1bGU7XG4gXHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyMjtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxuIFx0XHRpZiAoZXJyb3IpIHtcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gXHRcdH1cblxuIFx0XHRob3RTZXRTdGF0dXMoXCJpZGxlXCIpO1xuIFx0XHRyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24ocmVzb2x2ZSkge1xuIFx0XHRcdHJlc29sdmUob3V0ZGF0ZWRNb2R1bGVzKTtcbiBcdFx0fSk7XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoXCIuL3NyYy9hcHAvbWFpbi50c1wiKShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FwcC9tYWluLnRzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIGZlYXR1cmVzLCBjYWxjdWxhdGVzIHRoZSBiYm94IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXG4gKlxuICogQG5hbWUgYmJveFxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0JCb3h9IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtbLTc0LCA0MF0sIFstNzgsIDQyXSwgWy04MiwgMzVdXSk7XG4gKiB2YXIgYmJveCA9IHR1cmYuYmJveChsaW5lKTtcbiAqIHZhciBiYm94UG9seWdvbiA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIGJib3hQb2x5Z29uXVxuICovXG5mdW5jdGlvbiBiYm94KGdlb2pzb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIG1ldGFfMS5jb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGlmIChyZXN1bHRbMF0gPiBjb29yZFswXSkge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFsxXSA+IGNvb3JkWzFdKSB7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSBjb29yZFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0WzJdIDwgY29vcmRbMF0pIHtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRbM10gPCBjb29yZFsxXSkge1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYmJveDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCJAdHVyZi9oZWxwZXJzXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG4vKipcbiAqIFRha2VzIHR3byB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgZmluZHMgdGhlIGdlb2dyYXBoaWMgYmVhcmluZyBiZXR3ZWVuIHRoZW0sXG4gKiBpLmUuIHRoZSBhbmdsZSBtZWFzdXJlZCBpbiBkZWdyZWVzIGZyb20gdGhlIG5vcnRoIGxpbmUgKDAgZGVncmVlcylcbiAqXG4gKiBAbmFtZSBiZWFyaW5nXG4gKiBAcGFyYW0ge0Nvb3JkfSBzdGFydCBzdGFydGluZyBQb2ludFxuICogQHBhcmFtIHtDb29yZH0gZW5kIGVuZGluZyBQb2ludFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbmFsPWZhbHNlXSBjYWxjdWxhdGVzIHRoZSBmaW5hbCBiZWFyaW5nIGlmIHRydWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGJlYXJpbmcgaW4gZGVjaW1hbCBkZWdyZWVzLCBiZXR3ZWVuIC0xODAgYW5kIDE4MCBkZWdyZWVzIChwb3NpdGl2ZSBjbG9ja3dpc2UpXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50MSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICogdmFyIHBvaW50MiA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10pO1xuICpcbiAqIHZhciBiZWFyaW5nID0gdHVyZi5iZWFyaW5nKHBvaW50MSwgcG9pbnQyKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbcG9pbnQxLCBwb2ludDJdXG4gKiBwb2ludDEucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCdcbiAqIHBvaW50Mi5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjMGYwJ1xuICogcG9pbnQxLnByb3BlcnRpZXMuYmVhcmluZyA9IGJlYXJpbmdcbiAqL1xuZnVuY3Rpb24gYmVhcmluZyhzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyBSZXZlcnNlIGNhbGN1bGF0aW9uXG4gICAgaWYgKG9wdGlvbnMuZmluYWwgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUZpbmFsQmVhcmluZyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGludmFyaWFudF8xLmdldENvb3JkKHN0YXJ0KTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmQoZW5kKTtcbiAgICB2YXIgbG9uMSA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMVswXSk7XG4gICAgdmFyIGxvbjIgPSBoZWxwZXJzXzEuZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMF0pO1xuICAgIHZhciBsYXQxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgbGF0MiA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMlsxXSk7XG4gICAgdmFyIGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgICB2YXIgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgICAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuICAgIHJldHVybiBoZWxwZXJzXzEucmFkaWFuc1RvRGVncmVlcyhNYXRoLmF0YW4yKGEsIGIpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBGaW5hbCBCZWFyaW5nXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q29vcmR9IHN0YXJ0IHN0YXJ0aW5nIFBvaW50XG4gKiBAcGFyYW0ge0Nvb3JkfSBlbmQgZW5kaW5nIFBvaW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBiZWFyaW5nXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUZpbmFsQmVhcmluZyhzdGFydCwgZW5kKSB7XG4gICAgLy8gU3dhcCBzdGFydCAmIGVuZFxuICAgIHZhciBiZWFyID0gYmVhcmluZyhlbmQsIHN0YXJ0KTtcbiAgICBiZWFyID0gKGJlYXIgKyAxODApICUgMzYwO1xuICAgIHJldHVybiBiZWFyO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYmVhcmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmJveF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAdHVyZi9iYm94XCIpKTtcbnZhciBib29sZWFuX3BvaW50X2luX3BvbHlnb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1pbi1wb2x5Z29uXCIpKTtcbnZhciBib29sZWFuX3BvaW50X29uX2xpbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1vbi1saW5lXCIpKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG4vKipcbiAqIEJvb2xlYW4tY29udGFpbnMgcmV0dXJucyBUcnVlIGlmIHRoZSBzZWNvbmQgZ2VvbWV0cnkgaXMgY29tcGxldGVseSBjb250YWluZWQgYnkgdGhlIGZpcnN0IGdlb21ldHJ5LlxuICogVGhlIGludGVyaW9ycyBvZiBib3RoIGdlb21ldHJpZXMgbXVzdCBpbnRlcnNlY3QgYW5kLCB0aGUgaW50ZXJpb3IgYW5kIGJvdW5kYXJ5IG9mIHRoZSBzZWNvbmRhcnkgKGdlb21ldHJ5IGIpXG4gKiBtdXN0IG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVyaW9yIG9mIHRoZSBwcmltYXJ5IChnZW9tZXRyeSBhKS5cbiAqIEJvb2xlYW4tY29udGFpbnMgcmV0dXJucyB0aGUgZXhhY3Qgb3Bwb3NpdGUgcmVzdWx0IG9mIHRoZSBgQHR1cmYvYm9vbGVhbi13aXRoaW5gLlxuICpcbiAqIEBuYW1lIGJvb2xlYW5Db250YWluc1xuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPGFueT59IGZlYXR1cmUxIEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPGFueT59IGZlYXR1cmUyIEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbWzEsIDFdLCBbMSwgMl0sIFsxLCAzXSwgWzEsIDRdXSk7XG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFsxLCAyXSk7XG4gKlxuICogdHVyZi5ib29sZWFuQ29udGFpbnMobGluZSwgcG9pbnQpO1xuICogLy89dHJ1ZVxuICovXG5mdW5jdGlvbiBib29sZWFuQ29udGFpbnMoZmVhdHVyZTEsIGZlYXR1cmUyKSB7XG4gICAgdmFyIGdlb20xID0gaW52YXJpYW50XzEuZ2V0R2VvbShmZWF0dXJlMSk7XG4gICAgdmFyIGdlb20yID0gaW52YXJpYW50XzEuZ2V0R2VvbShmZWF0dXJlMik7XG4gICAgdmFyIHR5cGUxID0gaW52YXJpYW50XzEuZ2V0VHlwZShmZWF0dXJlMSk7XG4gICAgdmFyIHR5cGUyID0gaW52YXJpYW50XzEuZ2V0VHlwZShmZWF0dXJlMik7XG4gICAgdmFyIGNvb3JkczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMoZmVhdHVyZTEpO1xuICAgIHZhciBjb29yZHMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGZlYXR1cmUyKTtcbiAgICBzd2l0Y2ggKHR5cGUxKSB7XG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlMikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUNvb3Jkcyhjb29yZHMxLCBjb29yZHMyKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZWF0dXJlMiBcIiArIHR5cGUyICsgXCIgZ2VvbWV0cnkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZTIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUG9pbnRJbk11bHRpUG9pbnQoZ2VvbTEsIGdlb20yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNdWx0aVBvaW50SW5NdWx0aVBvaW50KGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIgKyB0eXBlMiArIFwiIGdlb21ldHJ5IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGdlb20yLCBnZW9tMSwgeyBpZ25vcmVFbmRWZXJ0aWNlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNMaW5lT25MaW5lKGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTXVsdGlQb2ludE9uTGluZShnZW9tMSwgZ2VvbTIpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZlYXR1cmUyIFwiICsgdHlwZTIgKyBcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlMikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChnZW9tMiwgZ2VvbTEsIHsgaWdub3JlQm91bmRhcnk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTGluZUluUG9seShnZW9tMSwgZ2VvbTIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1BvbHlJblBvbHkoZ2VvbTEsIGdlb20yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNdWx0aVBvaW50SW5Qb2x5KGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIgKyB0eXBlMiArIFwiIGdlb21ldHJ5IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZWF0dXJlMSBcIiArIHR5cGUxICsgXCIgZ2VvbWV0cnkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuQ29udGFpbnM7XG5mdW5jdGlvbiBpc1BvaW50SW5NdWx0aVBvaW50KG11bHRpUG9pbnQsIHB0KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG91dHB1dCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtdWx0aVBvaW50LmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ29vcmRzKG11bHRpUG9pbnQuY29vcmRpbmF0ZXNbaV0sIHB0LmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmlzUG9pbnRJbk11bHRpUG9pbnQgPSBpc1BvaW50SW5NdWx0aVBvaW50O1xuZnVuY3Rpb24gaXNNdWx0aVBvaW50SW5NdWx0aVBvaW50KG11bHRpUG9pbnQxLCBtdWx0aVBvaW50Mikge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtdWx0aVBvaW50Mi5jb29yZGluYXRlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvb3JkMiA9IF9hW19pXTtcbiAgICAgICAgdmFyIG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IG11bHRpUG9pbnQxLmNvb3JkaW5hdGVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkMSA9IF9jW19iXTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlQ29vcmRzKGNvb3JkMiwgY29vcmQxKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2hGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRJbk11bHRpUG9pbnQgPSBpc011bHRpUG9pbnRJbk11bHRpUG9pbnQ7XG5mdW5jdGlvbiBpc011bHRpUG9pbnRPbkxpbmUobGluZVN0cmluZywgbXVsdGlQb2ludCkge1xuICAgIHZhciBoYXZlRm91bmRJbnRlcmlvclBvaW50ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG11bHRpUG9pbnQuY29vcmRpbmF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IF9hW19pXTtcbiAgICAgICAgaWYgKGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmQsIGxpbmVTdHJpbmcsIHsgaWdub3JlRW5kVmVydGljZXM6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGhhdmVGb3VuZEludGVyaW9yUG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChjb29yZCwgbGluZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGF2ZUZvdW5kSW50ZXJpb3JQb2ludCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRPbkxpbmUgPSBpc011bHRpUG9pbnRPbkxpbmU7XG5mdW5jdGlvbiBpc011bHRpUG9pbnRJblBvbHkocG9seWdvbiwgbXVsdGlQb2ludCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtdWx0aVBvaW50LmNvb3JkaW5hdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29vcmQgPSBfYVtfaV07XG4gICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChjb29yZCwgcG9seWdvbiwgeyBpZ25vcmVCb3VuZGFyeTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRJblBvbHkgPSBpc011bHRpUG9pbnRJblBvbHk7XG5mdW5jdGlvbiBpc0xpbmVPbkxpbmUobGluZVN0cmluZzEsIGxpbmVTdHJpbmcyKSB7XG4gICAgdmFyIGhhdmVGb3VuZEludGVyaW9yUG9pbnQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbGluZVN0cmluZzIuY29vcmRpbmF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBfYVtfaV07XG4gICAgICAgIGlmIChib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KHsgdHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogY29vcmRzIH0sIGxpbmVTdHJpbmcxLCB7IGlnbm9yZUVuZFZlcnRpY2VzOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBoYXZlRm91bmRJbnRlcmlvclBvaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoeyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBjb29yZHMgfSwgbGluZVN0cmluZzEsIHsgaWdub3JlRW5kVmVydGljZXM6IGZhbHNlIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhdmVGb3VuZEludGVyaW9yUG9pbnQ7XG59XG5leHBvcnRzLmlzTGluZU9uTGluZSA9IGlzTGluZU9uTGluZTtcbmZ1bmN0aW9uIGlzTGluZUluUG9seShwb2x5Z29uLCBsaW5lc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcG9seUJib3ggPSBiYm94XzEuZGVmYXVsdChwb2x5Z29uKTtcbiAgICB2YXIgbGluZUJib3ggPSBiYm94XzEuZGVmYXVsdChsaW5lc3RyaW5nKTtcbiAgICBpZiAoIWRvQkJveE92ZXJsYXAocG9seUJib3gsIGxpbmVCYm94KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaTsgaSA8IGxpbmVzdHJpbmcuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBtaWRQb2ludCA9IGdldE1pZHBvaW50KGxpbmVzdHJpbmcuY29vcmRpbmF0ZXNbaV0sIGxpbmVzdHJpbmcuY29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICAgICAgaWYgKGJvb2xlYW5fcG9pbnRfaW5fcG9seWdvbl8xLmRlZmF1bHQoeyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBtaWRQb2ludCB9LCBwb2x5Z29uLCB7IGlnbm9yZUJvdW5kYXJ5OiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMuaXNMaW5lSW5Qb2x5ID0gaXNMaW5lSW5Qb2x5O1xuLyoqXG4gKiBJcyBQb2x5Z29uMiBpbiBQb2x5Z29uMVxuICogT25seSB0YWtlcyBpbnRvIGFjY291bnQgb3V0ZXIgcmluZ3NcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPFBvbHlnb24+fSBmZWF0dXJlMSBQb2x5Z29uMVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPFBvbHlnb24+fSBmZWF0dXJlMiBQb2x5Z29uMlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQb2x5SW5Qb2x5KGZlYXR1cmUxLCBmZWF0dXJlMikge1xuICAgIC8vIEhhbmRsZSBOdWxsc1xuICAgIGlmIChmZWF0dXJlMS50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBmZWF0dXJlMS5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmZWF0dXJlMi50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBmZWF0dXJlMi5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwb2x5MUJib3ggPSBiYm94XzEuZGVmYXVsdChmZWF0dXJlMSk7XG4gICAgdmFyIHBvbHkyQmJveCA9IGJib3hfMS5kZWZhdWx0KGZlYXR1cmUyKTtcbiAgICBpZiAoIWRvQkJveE92ZXJsYXAocG9seTFCYm94LCBwb2x5MkJib3gpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IGludmFyaWFudF8xLmdldEdlb20oZmVhdHVyZTIpLmNvb3JkaW5hdGVzO1xuICAgIGZvciAodmFyIF9pID0gMCwgY29vcmRzXzEgPSBjb29yZHM7IF9pIDwgY29vcmRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gY29vcmRzXzFbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHJpbmdfMSA9IHJpbmc7IF9hIDwgcmluZ18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gcmluZ18xW19hXTtcbiAgICAgICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChjb29yZCwgZmVhdHVyZTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1BvbHlJblBvbHkgPSBpc1BvbHlJblBvbHk7XG5mdW5jdGlvbiBkb0JCb3hPdmVybGFwKGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MVswXSA+IGJib3gyWzBdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJib3gxWzJdIDwgYmJveDJbMl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmJveDFbMV0gPiBiYm94MlsxXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVszXSA8IGJib3gyWzNdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmRvQkJveE92ZXJsYXAgPSBkb0JCb3hPdmVybGFwO1xuLyoqXG4gKiBjb21wYXJlQ29vcmRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9zaXRpb259IHBhaXIxIHBvaW50IFt4LHldXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwYWlyMiBwb2ludCBbeCx5XVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2UgaWYgY29vcmQgcGFpcnMgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gY29tcGFyZUNvb3JkcyhwYWlyMSwgcGFpcjIpIHtcbiAgICByZXR1cm4gcGFpcjFbMF0gPT09IHBhaXIyWzBdICYmIHBhaXIxWzFdID09PSBwYWlyMlsxXTtcbn1cbmV4cG9ydHMuY29tcGFyZUNvb3JkcyA9IGNvbXBhcmVDb29yZHM7XG5mdW5jdGlvbiBnZXRNaWRwb2ludChwYWlyMSwgcGFpcjIpIHtcbiAgICByZXR1cm4gWyhwYWlyMVswXSArIHBhaXIyWzBdKSAvIDIsIChwYWlyMVsxXSArIHBhaXIyWzFdKSAvIDJdO1xufVxuZXhwb3J0cy5nZXRNaWRwb2ludCA9IGdldE1pZHBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgaW52YXJpYW50XzEgPSByZXF1aXJlKFwiQHR1cmYvaW52YXJpYW50XCIpO1xudmFyIGxpbmVfb3ZlcmxhcF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtb3ZlcmxhcFwiKTtcbnZhciBsaW5lX2ludGVyc2VjdF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtaW50ZXJzZWN0XCIpO1xudmFyIEdlb2pzb25FcXVhbGl0eSA9IHJlcXVpcmUoXCJnZW9qc29uLWVxdWFsaXR5XCIpO1xuLyoqXG4gKiBDb21wYXJlcyB0d28gZ2VvbWV0cmllcyBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGVpciBpbnRlcnNlY3Rpb24gc2V0IHJlc3VsdHMgaW4gYSBnZW9tZXRyeVxuICogZGlmZmVyZW50IGZyb20gYm90aCBidXQgb2YgdGhlIHNhbWUgZGltZW5zaW9uLiBJdCBhcHBsaWVzIHRvIFBvbHlnb24vUG9seWdvbiwgTGluZVN0cmluZy9MaW5lU3RyaW5nLFxuICogTXVsdGlwb2ludC9NdWx0aXBvaW50LCBNdWx0aUxpbmVTdHJpbmcvTXVsdGlMaW5lU3RyaW5nIGFuZCBNdWx0aVBvbHlnb24vTXVsdGlQb2x5Z29uLlxuICpcbiAqIEBuYW1lIGJvb2xlYW5PdmVybGFwXG4gKiBAcGFyYW0gIHtHZW9tZXRyeXxGZWF0dXJlPExpbmVTdHJpbmd8TXVsdGlMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlQb2x5Z29uPn0gZmVhdHVyZTEgaW5wdXRcbiAqIEBwYXJhbSAge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmd8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBmZWF0dXJlMiBpbnB1dFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSB0dXJmLnBvbHlnb24oW1tbMCwwXSxbMCw1XSxbNSw1XSxbNSwwXSxbMCwwXV1dKTtcbiAqIHZhciBwb2x5MiA9IHR1cmYucG9seWdvbihbW1sxLDFdLFsxLDZdLFs2LDZdLFs2LDFdLFsxLDFdXV0pO1xuICogdmFyIHBvbHkzID0gdHVyZi5wb2x5Z29uKFtbWzEwLDEwXSxbMTAsMTVdLFsxNSwxNV0sWzE1LDEwXSxbMTAsMTBdXV0pO1xuICpcbiAqIHR1cmYuYm9vbGVhbk92ZXJsYXAocG9seTEsIHBvbHkyKVxuICogLy89dHJ1ZVxuICogdHVyZi5ib29sZWFuT3ZlcmxhcChwb2x5MiwgcG9seTMpXG4gKiAvLz1mYWxzZVxuICovXG5mdW5jdGlvbiBib29sZWFuT3ZlcmxhcChmZWF0dXJlMSwgZmVhdHVyZTIpIHtcbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKCFmZWF0dXJlMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlMSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghZmVhdHVyZTIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmVhdHVyZTIgaXMgcmVxdWlyZWQnKTtcbiAgICB2YXIgdHlwZTEgPSBpbnZhcmlhbnRfMS5nZXRUeXBlKGZlYXR1cmUxKTtcbiAgICB2YXIgdHlwZTIgPSBpbnZhcmlhbnRfMS5nZXRUeXBlKGZlYXR1cmUyKTtcbiAgICBpZiAodHlwZTEgIT09IHR5cGUyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZScpO1xuICAgIGlmICh0eXBlMSA9PT0gJ1BvaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgLy8gZmVhdHVyZXMgbXVzdCBiZSBub3QgZXF1YWxcbiAgICB2YXIgZXF1YWxpdHkgPSBuZXcgR2VvanNvbkVxdWFsaXR5KHsgcHJlY2lzaW9uOiA2IH0pO1xuICAgIGlmIChlcXVhbGl0eS5jb21wYXJlKGZlYXR1cmUxLCBmZWF0dXJlMikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgb3ZlcmxhcCA9IDA7XG4gICAgc3dpdGNoICh0eXBlMSkge1xuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgICAgIHZhciBjb29yZHMxID0gbWV0YV8xLmNvb3JkQWxsKGZlYXR1cmUxKTtcbiAgICAgICAgICAgIHZhciBjb29yZHMyID0gbWV0YV8xLmNvb3JkQWxsKGZlYXR1cmUyKTtcbiAgICAgICAgICAgIGNvb3JkczEuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQxKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzMi5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkMVswXSA9PT0gY29vcmQyWzBdICYmIGNvb3JkMVsxXSA9PT0gY29vcmQyWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICBtZXRhXzEuc2VnbWVudEVhY2goZmVhdHVyZTEsIGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgICAgICAgICAgIG1ldGFfMS5zZWdtZW50RWFjaChmZWF0dXJlMiwgZnVuY3Rpb24gKHNlZ21lbnQyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX292ZXJsYXBfMS5kZWZhdWx0KHNlZ21lbnQxLCBzZWdtZW50MikuZmVhdHVyZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBtZXRhXzEuc2VnbWVudEVhY2goZmVhdHVyZTEsIGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgICAgICAgICAgIG1ldGFfMS5zZWdtZW50RWFjaChmZWF0dXJlMiwgZnVuY3Rpb24gKHNlZ21lbnQyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX2ludGVyc2VjdF8xLmRlZmF1bHQoc2VnbWVudDEsIHNlZ21lbnQyKS5mZWF0dXJlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwKys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxhcCA+IDA7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuT3ZlcmxhcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbiVFMiU4MCU5M29kZF9ydWxlXG4vLyBtb2RpZmllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gd2hpY2ggd2FzIG1vZGlmaWVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGEge0BsaW5rIFBvbHlnb259IG9yIHtAbGluayBNdWx0aVBvbHlnb259IGFuZCBkZXRlcm1pbmVzIGlmIHRoZSBwb2ludFxuICogcmVzaWRlcyBpbnNpZGUgdGhlIHBvbHlnb24uIFRoZSBwb2x5Z29uIGNhbiBiZSBjb252ZXggb3IgY29uY2F2ZS4gVGhlIGZ1bmN0aW9uIGFjY291bnRzIGZvciBob2xlcy5cbiAqXG4gKiBAbmFtZSBib29sZWFuUG9pbnRJblBvbHlnb25cbiAqIEBwYXJhbSB7Q29vcmR9IHBvaW50IGlucHV0IHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBwb2x5Z29uIGlucHV0IHBvbHlnb24gb3IgbXVsdGlwb2x5Z29uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlQm91bmRhcnk9ZmFsc2VdIFRydWUgaWYgcG9seWdvbiBib3VuZGFyeSBzaG91bGQgYmUgaWdub3JlZCB3aGVuIGRldGVybWluaW5nIGlmXG4gKiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBwb2x5Z29uIG90aGVyd2lzZSBmYWxzZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIFBvaW50IGlzIGluc2lkZSB0aGUgUG9seWdvbjsgYGZhbHNlYCBpZiB0aGUgUG9pbnQgaXMgbm90IGluc2lkZSB0aGUgUG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYucG9pbnQoWy03NywgNDRdKTtcbiAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbXG4gKiAgIFstODEsIDQxXSxcbiAqICAgWy04MSwgNDddLFxuICogICBbLTcyLCA0N10sXG4gKiAgIFstNzIsIDQxXSxcbiAqICAgWy04MSwgNDFdXG4gKiBdXSk7XG4gKlxuICogdHVyZi5ib29sZWFuUG9pbnRJblBvbHlnb24ocHQsIHBvbHkpO1xuICogLy89IHRydWVcbiAqL1xuZnVuY3Rpb24gYm9vbGVhblBvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2ludCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFwb2x5Z29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvbHlnb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHZhciBwdCA9IGludmFyaWFudF8xLmdldENvb3JkKHBvaW50KTtcbiAgICB2YXIgZ2VvbSA9IGludmFyaWFudF8xLmdldEdlb20ocG9seWdvbik7XG4gICAgdmFyIHR5cGUgPSBnZW9tLnR5cGU7XG4gICAgdmFyIGJib3ggPSBwb2x5Z29uLmJib3g7XG4gICAgdmFyIHBvbHlzID0gZ2VvbS5jb29yZGluYXRlcztcbiAgICAvLyBRdWljayBlbGltaW5hdGlvbiBpZiBwb2ludCBpcyBub3QgaW5zaWRlIGJib3hcbiAgICBpZiAoYmJveCAmJiBpbkJCb3gocHQsIGJib3gpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5vcm1hbGl6ZSB0byBtdWx0aXBvbHlnb25cbiAgICBpZiAodHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgcG9seXMgPSBbcG9seXNdO1xuICAgIH1cbiAgICB2YXIgaW5zaWRlUG9seSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seXMubGVuZ3RoICYmICFpbnNpZGVQb2x5OyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIG91dGVyIHJpbmcgZmlyc3RcbiAgICAgICAgaWYgKGluUmluZyhwdCwgcG9seXNbaV1bMF0sIG9wdGlvbnMuaWdub3JlQm91bmRhcnkpKSB7XG4gICAgICAgICAgICB2YXIgaW5Ib2xlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgayA9IDE7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdGhlIHBvaW50IGluIGFueSBvZiB0aGUgaG9sZXNcbiAgICAgICAgICAgIHdoaWxlIChrIDwgcG9seXNbaV0ubGVuZ3RoICYmICFpbkhvbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5SaW5nKHB0LCBwb2x5c1tpXVtrXSwgIW9wdGlvbnMuaWdub3JlQm91bmRhcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5Ib2xlKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUG9seSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZVBvbHk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuUG9pbnRJblBvbHlnb247XG4vKipcbiAqIGluUmluZ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHB0IFt4LHldXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSByaW5nIFtbeCx5XSwgW3gseV0sLi5dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZUJvdW5kYXJ5IGlnbm9yZUJvdW5kYXJ5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaW5SaW5nXG4gKi9cbmZ1bmN0aW9uIGluUmluZyhwdCwgcmluZywgaWdub3JlQm91bmRhcnkpIHtcbiAgICB2YXIgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICBpZiAocmluZ1swXVswXSA9PT0gcmluZ1tyaW5nLmxlbmd0aCAtIDFdWzBdICYmIHJpbmdbMF1bMV0gPT09IHJpbmdbcmluZy5sZW5ndGggLSAxXVsxXSkge1xuICAgICAgICByaW5nID0gcmluZy5zbGljZSgwLCByaW5nLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHJpbmdbaV1bMF07XG4gICAgICAgIHZhciB5aSA9IHJpbmdbaV1bMV07XG4gICAgICAgIHZhciB4aiA9IHJpbmdbal1bMF07XG4gICAgICAgIHZhciB5aiA9IHJpbmdbal1bMV07XG4gICAgICAgIHZhciBvbkJvdW5kYXJ5ID0gKHB0WzFdICogKHhpIC0geGopICsgeWkgKiAoeGogLSBwdFswXSkgKyB5aiAqIChwdFswXSAtIHhpKSA9PT0gMCkgJiZcbiAgICAgICAgICAgICgoeGkgLSBwdFswXSkgKiAoeGogLSBwdFswXSkgPD0gMCkgJiYgKCh5aSAtIHB0WzFdKSAqICh5aiAtIHB0WzFdKSA8PSAwKTtcbiAgICAgICAgaWYgKG9uQm91bmRhcnkpIHtcbiAgICAgICAgICAgIHJldHVybiAhaWdub3JlQm91bmRhcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiBwdFsxXSkgIT09ICh5aiA+IHB0WzFdKSkgJiZcbiAgICAgICAgICAgIChwdFswXSA8ICh4aiAtIHhpKSAqIChwdFsxXSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzSW5zaWRlO1xufVxuLyoqXG4gKiBpbkJCb3hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb3NpdGlvbn0gcHQgcG9pbnQgW3gseV1cbiAqIEBwYXJhbSB7QkJveH0gYmJveCBCQm94IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBwb2ludCBpcyBpbnNpZGUgQkJveFxuICovXG5mdW5jdGlvbiBpbkJCb3gocHQsIGJib3gpIHtcbiAgICByZXR1cm4gYmJveFswXSA8PSBwdFswXSAmJlxuICAgICAgICBiYm94WzFdIDw9IHB0WzFdICYmXG4gICAgICAgIGJib3hbMl0gPj0gcHRbMF0gJiZcbiAgICAgICAgYmJveFszXSA+PSBwdFsxXTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgcG9pbnQgaXMgb24gYSBsaW5lLiBBY2NlcHRzIGEgb3B0aW9uYWwgcGFyYW1ldGVyIHRvIGlnbm9yZSB0aGVcbiAqIHN0YXJ0IGFuZCBlbmQgdmVydGljZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gKlxuICogQG5hbWUgYm9vbGVhblBvaW50T25MaW5lXG4gKiBAcGFyYW0ge0Nvb3JkfSBwdCBHZW9KU09OIFBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgR2VvSlNPTiBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRW5kVmVydGljZXM9ZmFsc2VdIHdoZXRoZXIgdG8gaWdub3JlIHRoZSBzdGFydCBhbmQgZW5kIHZlcnRpY2VzLlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB0dXJmLnBvaW50KFswLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbWy0xLCAtMV0sWzEsIDFdLFsxLjUsIDIuMl1dKTtcbiAqIHZhciBpc1BvaW50T25MaW5lID0gdHVyZi5ib29sZWFuUG9pbnRPbkxpbmUocHQsIGxpbmUpO1xuICogLy89dHJ1ZVxuICovXG5mdW5jdGlvbiBib29sZWFuUG9pbnRPbkxpbmUocHQsIGxpbmUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIE5vcm1hbGl6ZSBpbnB1dHNcbiAgICB2YXIgcHRDb29yZHMgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChwdCk7XG4gICAgdmFyIGxpbmVDb29yZHMgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobGluZSk7XG4gICAgLy8gTWFpblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGlnbm9yZUJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUVuZFZlcnRpY2VzKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlnbm9yZUJvdW5kYXJ5ID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGxpbmVDb29yZHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIGlnbm9yZUJvdW5kYXJ5ID0gXCJlbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIGkgKyAxID09PSBsaW5lQ29vcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVCb3VuZGFyeSA9IFwiYm90aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BvaW50T25MaW5lU2VnbWVudChsaW5lQ29vcmRzW2ldLCBsaW5lQ29vcmRzW2kgKyAxXSwgcHRDb29yZHMsIGlnbm9yZUJvdW5kYXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4MzM4MjMvMTk3OTA4NVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb3NpdGlvbn0gbGluZVNlZ21lbnRTdGFydCBjb29yZCBwYWlyIG9mIHN0YXJ0IG9mIGxpbmVcbiAqIEBwYXJhbSB7UG9zaXRpb259IGxpbmVTZWdtZW50RW5kIGNvb3JkIHBhaXIgb2YgZW5kIG9mIGxpbmVcbiAqIEBwYXJhbSB7UG9zaXRpb259IHB0IGNvb3JkIHBhaXIgb2YgcG9pbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IGV4Y2x1ZGVCb3VuZGFyeSB3aGV0aGVyIHRoZSBwb2ludCBpcyBhbGxvd2VkIHRvIGZhbGwgb24gdGhlIGxpbmUgZW5kcy5cbiAqIElmIHRydWUgd2hpY2ggZW5kIHRvIGlnbm9yZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnRPbkxpbmVTZWdtZW50KGxpbmVTZWdtZW50U3RhcnQsIGxpbmVTZWdtZW50RW5kLCBwdCwgZXhjbHVkZUJvdW5kYXJ5KSB7XG4gICAgdmFyIHggPSBwdFswXTtcbiAgICB2YXIgeSA9IHB0WzFdO1xuICAgIHZhciB4MSA9IGxpbmVTZWdtZW50U3RhcnRbMF07XG4gICAgdmFyIHkxID0gbGluZVNlZ21lbnRTdGFydFsxXTtcbiAgICB2YXIgeDIgPSBsaW5lU2VnbWVudEVuZFswXTtcbiAgICB2YXIgeTIgPSBsaW5lU2VnbWVudEVuZFsxXTtcbiAgICB2YXIgZHhjID0gcHRbMF0gLSB4MTtcbiAgICB2YXIgZHljID0gcHRbMV0gLSB5MTtcbiAgICB2YXIgZHhsID0geDIgLSB4MTtcbiAgICB2YXIgZHlsID0geTIgLSB5MTtcbiAgICB2YXIgY3Jvc3MgPSBkeGMgKiBkeWwgLSBkeWMgKiBkeGw7XG4gICAgaWYgKGNyb3NzICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNsdWRlQm91bmRhcnkpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4bCkgPj0gTWF0aC5hYnMoZHlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGR4bCA+IDAgPyB4MSA8PSB4ICYmIHggPD0geDIgOiB4MiA8PSB4ICYmIHggPD0geDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8PSB5ICYmIHkgPD0geTIgOiB5MiA8PSB5ICYmIHkgPD0geTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4Y2x1ZGVCb3VuZGFyeSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeGwpID49IE1hdGguYWJzKGR5bCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkeGwgPiAwID8geDEgPCB4ICYmIHggPD0geDIgOiB4MiA8PSB4ICYmIHggPCB4MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHlsID4gMCA/IHkxIDwgeSAmJiB5IDw9IHkyIDogeTIgPD0geSAmJiB5IDwgeTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4Y2x1ZGVCb3VuZGFyeSA9PT0gXCJlbmRcIikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHhsKSA+PSBNYXRoLmFicyhkeWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZHhsID4gMCA/IHgxIDw9IHggJiYgeCA8IHgyIDogeDIgPCB4ICYmIHggPD0geDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8PSB5ICYmIHkgPCB5MiA6IHkyIDwgeSAmJiB5IDw9IHkxO1xuICAgIH1cbiAgICBlbHNlIGlmIChleGNsdWRlQm91bmRhcnkgPT09IFwiYm90aFwiKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeGwpID49IE1hdGguYWJzKGR5bCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkeGwgPiAwID8geDEgPCB4ICYmIHggPCB4MiA6IHgyIDwgeCAmJiB4IDwgeDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8IHkgJiYgeSA8IHkyIDogeTIgPCB5ICYmIHkgPCB5MTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYm9vbGVhblBvaW50T25MaW5lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCJAdHVyZi9oZWxwZXJzXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBjYWxjdWxhdGVzIHRoZSBsb2NhdGlvbiBvZiBhIGRlc3RpbmF0aW9uIHBvaW50IGdpdmVuIGEgZGlzdGFuY2UgaW5cbiAqIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzOyBhbmQgYmVhcmluZyBpbiBkZWdyZWVzLlxuICogVGhpcyB1c2VzIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpIHRvIGFjY291bnQgZm9yIGdsb2JhbCBjdXJ2YXR1cmUuXG4gKlxuICogQG5hbWUgZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7Q29vcmR9IG9yaWdpbiBzdGFydGluZyBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgcmFuZ2luZyBmcm9tIC0xODAgdG8gMTgwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51bml0cz0na2lsb21ldGVycyddIG1pbGVzLCBraWxvbWV0ZXJzLCBkZWdyZWVzLCBvciByYWRpYW5zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIHByb3BlcnRpZXMgdG8gUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gZGVzdGluYXRpb24gcG9pbnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciBkaXN0YW5jZSA9IDUwO1xuICogdmFyIGJlYXJpbmcgPSA5MDtcbiAqIHZhciBvcHRpb25zID0ge3VuaXRzOiAnbWlsZXMnfTtcbiAqXG4gKiB2YXIgZGVzdGluYXRpb24gPSB0dXJmLmRlc3RpbmF0aW9uKHBvaW50LCBkaXN0YW5jZSwgYmVhcmluZywgb3B0aW9ucyk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW3BvaW50LCBkZXN0aW5hdGlvbl1cbiAqIGRlc3RpbmF0aW9uLnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyNmMDAnO1xuICogcG9pbnQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnIzBmMCc7XG4gKi9cbmZ1bmN0aW9uIGRlc3RpbmF0aW9uKG9yaWdpbiwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIEhhbmRsZSBpbnB1dFxuICAgIHZhciBjb29yZGluYXRlczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChvcmlnaW4pO1xuICAgIHZhciBsb25naXR1ZGUxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzBdKTtcbiAgICB2YXIgbGF0aXR1ZGUxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgYmVhcmluZ1JhZCA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGJlYXJpbmcpO1xuICAgIHZhciByYWRpYW5zID0gaGVscGVyc18xLmxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgb3B0aW9ucy51bml0cyk7XG4gICAgLy8gTWFpblxuICAgIHZhciBsYXRpdHVkZTIgPSBNYXRoLmFzaW4oTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguY29zKHJhZGlhbnMpICtcbiAgICAgICAgTWF0aC5jb3MobGF0aXR1ZGUxKSAqIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MoYmVhcmluZ1JhZCkpO1xuICAgIHZhciBsb25naXR1ZGUyID0gbG9uZ2l0dWRlMSArIE1hdGguYXRhbjIoTWF0aC5zaW4oYmVhcmluZ1JhZCkgKiBNYXRoLnNpbihyYWRpYW5zKSAqIE1hdGguY29zKGxhdGl0dWRlMSksIE1hdGguY29zKHJhZGlhbnMpIC0gTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguc2luKGxhdGl0dWRlMikpO1xuICAgIHZhciBsbmcgPSBoZWxwZXJzXzEucmFkaWFuc1RvRGVncmVlcyhsb25naXR1ZGUyKTtcbiAgICB2YXIgbGF0ID0gaGVscGVyc18xLnJhZGlhbnNUb0RlZ3JlZXMobGF0aXR1ZGUyKTtcbiAgICByZXR1cm4gaGVscGVyc18xLnBvaW50KFtsbmcsIGxhdF0sIG9wdGlvbnMucHJvcGVydGllcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZXN0aW5hdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbi8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuLy9odHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB7QGxpbmsgUG9pbnR8cG9pbnRzfSBpbiBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVycy5cbiAqIFRoaXMgdXNlcyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKSB0byBhY2NvdW50IGZvciBnbG9iYWwgY3VydmF0dXJlLlxuICpcbiAqIEBuYW1lIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0Nvb3JkfSBmcm9tIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtDb29yZH0gdG8gZGVzdGluYXRpb24gcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXRzPSdraWxvbWV0ZXJzJ10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZyb20gPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciB0byA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10pO1xuICogdmFyIG9wdGlvbnMgPSB7dW5pdHM6ICdtaWxlcyd9O1xuICpcbiAqIHZhciBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICpcbiAqIC8vYWRkVG9NYXBcbiAqIHZhciBhZGRUb01hcCA9IFtmcm9tLCB0b107XG4gKiBmcm9tLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqIHRvLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjb29yZGluYXRlczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChmcm9tKTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmQodG8pO1xuICAgIHZhciBkTGF0ID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoKGNvb3JkaW5hdGVzMlsxXSAtIGNvb3JkaW5hdGVzMVsxXSkpO1xuICAgIHZhciBkTG9uID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoKGNvb3JkaW5hdGVzMlswXSAtIGNvb3JkaW5hdGVzMVswXSkpO1xuICAgIHZhciBsYXQxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgbGF0MiA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMlsxXSk7XG4gICAgdmFyIGEgPSBNYXRoLnBvdyhNYXRoLnNpbihkTGF0IC8gMiksIDIpICtcbiAgICAgICAgTWF0aC5wb3coTWF0aC5zaW4oZExvbiAvIDIpLCAyKSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0Mik7XG4gICAgcmV0dXJuIGhlbHBlcnNfMS5yYWRpYW5zVG9MZW5ndGgoMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKSwgb3B0aW9ucy51bml0cyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkaXN0YW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnNcbiAqL1xuLyoqXG4gKiBFYXJ0aCBSYWRpdXMgdXNlZCB3aXRoIHRoZSBIYXJ2ZXNpbmUgZm9ybXVsYSBhbmQgYXBwcm94aW1hdGVzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBFYXJ0aC5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0cy5lYXJ0aFJhZGl1cyA9IDYzNzEwMDguODtcbi8qKlxuICogVW5pdCBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBlYXJ0aCByYWRpdXMuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDEwMCxcbiAgICBjZW50aW1ldHJlczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDEwMCxcbiAgICBkZWdyZWVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTExMzI1LFxuICAgIGZlZXQ6IGV4cG9ydHMuZWFydGhSYWRpdXMgKiAzLjI4MDg0LFxuICAgIGluY2hlczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDM5LjM3MCxcbiAgICBraWxvbWV0ZXJzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgICBraWxvbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgICBtZXRlcnM6IGV4cG9ydHMuZWFydGhSYWRpdXMsXG4gICAgbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzLFxuICAgIG1pbGVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTYwOS4zNDQsXG4gICAgbWlsbGltZXRlcnM6IGV4cG9ydHMuZWFydGhSYWRpdXMgKiAxMDAwLFxuICAgIG1pbGxpbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzICogMTAwMCxcbiAgICBuYXV0aWNhbG1pbGVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTg1MixcbiAgICByYWRpYW5zOiAxLFxuICAgIHlhcmRzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMS4wOTM2LFxufTtcbi8qKlxuICogVW5pdHMgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLnVuaXRzRmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogMTAwLFxuICAgIGNlbnRpbWV0cmVzOiAxMDAsXG4gICAgZGVncmVlczogMSAvIDExMTMyNSxcbiAgICBmZWV0OiAzLjI4MDg0LFxuICAgIGluY2hlczogMzkuMzcwLFxuICAgIGtpbG9tZXRlcnM6IDEgLyAxMDAwLFxuICAgIGtpbG9tZXRyZXM6IDEgLyAxMDAwLFxuICAgIG1ldGVyczogMSxcbiAgICBtZXRyZXM6IDEsXG4gICAgbWlsZXM6IDEgLyAxNjA5LjM0NCxcbiAgICBtaWxsaW1ldGVyczogMTAwMCxcbiAgICBtaWxsaW1ldHJlczogMTAwMCxcbiAgICBuYXV0aWNhbG1pbGVzOiAxIC8gMTg1MixcbiAgICByYWRpYW5zOiAxIC8gZXhwb3J0cy5lYXJ0aFJhZGl1cyxcbiAgICB5YXJkczogMSAvIDEuMDkzNixcbn07XG4vKipcbiAqIEFyZWEgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIHNxdWFyZSBtZXRlci5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hcmVhRmFjdG9ycyA9IHtcbiAgICBhY3JlczogMC4wMDAyNDcxMDUsXG4gICAgY2VudGltZXRlcnM6IDEwMDAwLFxuICAgIGNlbnRpbWV0cmVzOiAxMDAwMCxcbiAgICBmZWV0OiAxMC43NjM5MTA0MTcsXG4gICAgaW5jaGVzOiAxNTUwLjAwMzEwMDAwNixcbiAgICBraWxvbWV0ZXJzOiAwLjAwMDAwMSxcbiAgICBraWxvbWV0cmVzOiAwLjAwMDAwMSxcbiAgICBtZXRlcnM6IDEsXG4gICAgbWV0cmVzOiAxLFxuICAgIG1pbGVzOiAzLjg2ZS03LFxuICAgIG1pbGxpbWV0ZXJzOiAxMDAwMDAwLFxuICAgIG1pbGxpbWV0cmVzOiAxMDAwMDAwLFxuICAgIHlhcmRzOiAxLjE5NTk5MDA0Nixcbn07XG4vKipcbiAqIFdyYXBzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGluIGEgR2VvSlNPTiB7QGxpbmsgRmVhdHVyZX0uXG4gKlxuICogQG5hbWUgZmVhdHVyZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgaW5wdXQgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZX0gYSBHZW9KU09OIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvbWV0cnkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNTBdXG4gKiB9O1xuICpcbiAqIHZhciBmZWF0dXJlID0gdHVyZi5mZWF0dXJlKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZlYXQgPSB7IHR5cGU6IFwiRmVhdHVyZVwiIH07XG4gICAgaWYgKG9wdGlvbnMuaWQgPT09IDAgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgICBmZWF0LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgICAgICBmZWF0LmJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgfVxuICAgIGZlYXQucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgZmVhdC5nZW9tZXRyeSA9IGdlb207XG4gICAgcmV0dXJuIGZlYXQ7XG59XG5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuLyoqXG4gKiBDcmVhdGVzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGZyb20gYSBHZW9tZXRyeSBzdHJpbmcgdHlwZSAmIGNvb3JkaW5hdGVzLlxuICogRm9yIEdlb21ldHJ5Q29sbGVjdGlvbiB0eXBlIHVzZSBgaGVscGVycy5nZW9tZXRyeUNvbGxlY3Rpb25gXG4gKlxuICogQG5hbWUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEdlb21ldHJ5IFR5cGVcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHJldHVybnMge0dlb21ldHJ5fSBhIEdlb0pTT04gR2VvbWV0cnlcbiAqIEBleGFtcGxlXG4gKiB2YXIgdHlwZSA9IFwiUG9pbnRcIjtcbiAqIHZhciBjb29yZGluYXRlcyA9IFsxMTAsIDUwXTtcbiAqIHZhciBnZW9tZXRyeSA9IHR1cmYuZ2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMpO1xuICogLy8gPT4gZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZ2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjogcmV0dXJuIHBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgICAgICBjYXNlIFwiUG9seWdvblwiOiByZXR1cm4gcG9seWdvbihjb29yZGluYXRlcykuZ2VvbWV0cnk7XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IHJldHVybiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiByZXR1cm4gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYSBQb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBsb25naXR1ZGUsIGxhdGl0dWRlIHBvc2l0aW9uIChlYWNoIGluIGRlY2ltYWwgZGVncmVlcylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXBvaW50XG4gKi9cbmZ1bmN0aW9uIHBvaW50KGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9pbnQgPSBwb2ludDtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvaW50IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGVhY2ggRmVhdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBQb2ludCBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucG9pbnRzKFtcbiAqICAgWy03NSwgMzldLFxuICogICBbLTgwLCA0NV0sXG4gKiAgIFstNzgsIDUwXVxuICogXSk7XG4gKlxuICogLy89cG9pbnRzXG4gKi9cbmZ1bmN0aW9uIHBvaW50cyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludChjb29yZHMsIHByb3BlcnRpZXMpO1xuICAgIH0pLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9pbnRzID0gcG9pbnRzO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFBvbHlnb259IHtAbGluayBGZWF0dXJlfSBmcm9tIGFuIEFycmF5IG9mIExpbmVhclJpbmdzLlxuICpcbiAqIEBuYW1lIHBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBQb2x5Z29uIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNSwgNTJdLCBbLTQsIDU2XSwgWy0yLCA1MV0sIFstNywgNTRdLCBbLTUsIDUyXV1dLCB7IG5hbWU6ICdwb2x5MScgfSk7XG4gKlxuICogLy89cG9seWdvblxuICovXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvb3JkaW5hdGVzXzEgPSBjb29yZGluYXRlczsgX2kgPCBjb29yZGluYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzXzFbX2ldO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdbcmluZy5sZW5ndGggLSAxXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmlyc3QgcG9pbnQgb2YgUG9seWdvbiBjb250YWlucyB0d28gbnVtYmVyc1xuICAgICAgICAgICAgaWYgKHJpbmdbcmluZy5sZW5ndGggLSAxXVtqXSAhPT0gcmluZ1swXVtqXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvbHlnb24gY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgcG9seWdvbnNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLnBvbHlnb25zKFtcbiAqICAgW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSxcbiAqICAgW1tbLTE1LCA0Ml0sIFstMTQsIDQ2XSwgWy0xMiwgNDFdLCBbLTE3LCA0NF0sIFstMTUsIDQyXV1dLFxuICogXSk7XG4gKlxuICogLy89cG9seWdvbnNcbiAqL1xuZnVuY3Rpb24gcG9seWdvbnMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9seWdvbihjb29yZHMsIHByb3BlcnRpZXMpO1xuICAgIH0pLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9seWdvbnMgPSBwb2x5Z29ucztcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBQb3NpdGlvbnMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IExpbmVTdHJpbmcgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5nMSA9IHR1cmYubGluZVN0cmluZyhbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSwge25hbWU6ICdsaW5lIDEnfSk7XG4gKiB2YXIgbGluZXN0cmluZzIgPSB0dXJmLmxpbmVTdHJpbmcoW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV0sIHtuYW1lOiAnbGluZSAyJ30pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5mdW5jdGlvbiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIHBvc2l0aW9uc1wiKTtcbiAgICB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubGluZVN0cmluZyA9IGxpbmVTdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIExpbmVTdHJpbmcgY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gTGluZVN0cmluZyBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5ncyA9IHR1cmYubGluZVN0cmluZ3MoW1xuICogICBbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSxcbiAqICAgW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV1cbiAqIF0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGxpbmVTdHJpbmdzKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9KSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxpbmVTdHJpbmdzID0gbGluZVN0cmluZ3M7XG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIHtAbGluayBGZWF0dXJlfEZlYXR1cmVzfSBhbmQgY3JlYXRlcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0uXG4gKlxuICogQG5hbWUgZmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RmVhdHVyZVtdfSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IEZlYXR1cmVDb2xsZWN0aW9uIG9mIEZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxvY2F0aW9uQSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0sIHtuYW1lOiAnTG9jYXRpb24gQSd9KTtcbiAqIHZhciBsb2NhdGlvbkIgPSB0dXJmLnBvaW50KFstNzUuODMzLCAzOS4yODRdLCB7bmFtZTogJ0xvY2F0aW9uIEInfSk7XG4gKiB2YXIgbG9jYXRpb25DID0gdHVyZi5wb2ludChbLTc1LjUzNCwgMzkuMTIzXSwge25hbWU6ICdMb2NhdGlvbiBDJ30pO1xuICpcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIGxvY2F0aW9uQSxcbiAqICAgbG9jYXRpb25CLFxuICogICBsb2NhdGlvbkNcbiAqIF0pO1xuICpcbiAqIC8vPWNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBmYyA9IHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiIH07XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgZmMuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iYm94KSB7XG4gICAgICAgIGZjLmJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgfVxuICAgIGZjLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgcmV0dXJuIGZjO1xufVxuZXhwb3J0cy5mZWF0dXJlQ29sbGVjdGlvbiA9IGZlYXR1cmVDb2xsZWN0aW9uO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aUxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lU3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGEgTXVsdGlMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtbWzAsMF0sWzEwLDEwXV1dKTtcbiAqXG4gKiAvLz1tdWx0aUxpbmVcbiAqL1xuZnVuY3Rpb24gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLFxuICAgIH07XG4gICAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm11bHRpTGluZVN0cmluZyA9IG11bHRpTGluZVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9pbnQ+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9pbnQ+fSBhIE11bHRpUG9pbnQgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQdCA9IHR1cmYubXVsdGlQb2ludChbWzAsMF0sWzEwLDEwXV0pO1xuICpcbiAqIC8vPW11bHRpUHRcbiAqL1xuZnVuY3Rpb24gbXVsdGlQb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubXVsdGlQb2ludCA9IG11bHRpUG9pbnQ7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvbHlnb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9seWdvbj59IGEgbXVsdGlwb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtbW1swLDBdLFswLDEwXSxbMTAsMTBdLFsxMCwwXSxbMCwwXV1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5mdW5jdGlvbiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBnZW9tID0ge1xuICAgICAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubXVsdGlQb2x5Z29uID0gbXVsdGlQb2x5Z29uO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+fSBnZW9tZXRyaWVzIGFuIGFycmF5IG9mIEdlb0pTT04gR2VvbWV0cmllc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPEdlb21ldHJ5Q29sbGVjdGlvbj59IGEgR2VvSlNPTiBHZW9tZXRyeUNvbGxlY3Rpb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYuZ2VvbWV0cnkoXCJQb2ludFwiLCBbMTAwLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYuZ2VvbWV0cnkoXCJMaW5lU3RyaW5nXCIsIFtbMTAxLCAwXSwgWzEwMiwgMV1dKTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy8gPT4gY29sbGVjdGlvblxuICovXG5mdW5jdGlvbiBnZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlDb2xsZWN0aW9uO1xuLyoqXG4gKiBSb3VuZCBudW1iZXIgdG8gcHJlY2lzaW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFByZWNpc2lvblxuICogQHJldHVybnMge251bWJlcn0gcm91bmRlZCBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxKVxuICogLy89MTIwXG4gKlxuICogdHVyZi5yb3VuZCgxMjAuNDMyMSwgMilcbiAqIC8vPTEyMC40M1xuICovXG5mdW5jdGlvbiByb3VuZChudW0sIHByZWNpc2lvbikge1xuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAwOyB9XG4gICAgaWYgKHByZWNpc2lvbiAmJiAhKHByZWNpc2lvbiA+PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmVjaXNpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbn1cbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSByYWRpYW5zIHRvIGEgbW9yZSBmcmllbmRseSB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9MZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVycyBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiByYWRpYW5zVG9MZW5ndGgocmFkaWFucywgdW5pdHMpIHtcbiAgICBpZiAodW5pdHMgPT09IHZvaWQgMCkgeyB1bml0cyA9IFwia2lsb21ldGVyc1wiOyB9XG4gICAgdmFyIGZhY3RvciA9IGV4cG9ydHMuZmFjdG9yc1t1bml0c107XG4gICAgaWYgKCFmYWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59XG5leHBvcnRzLnJhZGlhbnNUb0xlbmd0aCA9IHJhZGlhbnNUb0xlbmd0aDtcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoVG9SYWRpYW5zKGRpc3RhbmNlLCB1bml0cykge1xuICAgIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7IHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICB2YXIgZmFjdG9yID0gZXhwb3J0cy5mYWN0b3JzW3VuaXRzXTtcbiAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59XG5leHBvcnRzLmxlbmd0aFRvUmFkaWFucyA9IGxlbmd0aFRvUmFkaWFucztcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0ZXJzLCBraWxvbWV0cmVzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXNcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoVG9EZWdyZWVzKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHJldHVybiByYWRpYW5zVG9EZWdyZWVzKGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpKTtcbn1cbmV4cG9ydHMubGVuZ3RoVG9EZWdyZWVzID0gbGVuZ3RoVG9EZWdyZWVzO1xuLyoqXG4gKiBDb252ZXJ0cyBhbnkgYmVhcmluZyBhbmdsZSBmcm9tIHRoZSBub3J0aCBsaW5lIGRpcmVjdGlvbiAocG9zaXRpdmUgY2xvY2t3aXNlKVxuICogYW5kIHJldHVybnMgYW4gYW5nbGUgYmV0d2VlbiAwLTM2MCBkZWdyZWVzIChwb3NpdGl2ZSBjbG9ja3dpc2UpLCAwIGJlaW5nIHRoZSBub3J0aCBsaW5lXG4gKlxuICogQG5hbWUgYmVhcmluZ1RvQXppbXV0aFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgYW5nbGUsIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKi9cbmZ1bmN0aW9uIGJlYXJpbmdUb0F6aW11dGgoYmVhcmluZykge1xuICAgIHZhciBhbmdsZSA9IGJlYXJpbmcgJSAzNjA7XG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBhbmdsZTtcbn1cbmV4cG9ydHMuYmVhcmluZ1RvQXppbXV0aCA9IGJlYXJpbmdUb0F6aW11dGg7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIHJhZGlhbnMgdG8gZGVncmVlc1xuICpcbiAqIEBuYW1lIHJhZGlhbnNUb0RlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXMgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICovXG5mdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICB2YXIgZGVncmVlcyA9IHJhZGlhbnMgJSAoMiAqIE1hdGguUEkpO1xuICAgIHJldHVybiBkZWdyZWVzICogMTgwIC8gTWF0aC5QSTtcbn1cbmV4cG9ydHMucmFkaWFuc1RvRGVncmVlcyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIGRlZ3JlZXMgdG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRlZ3JlZXNUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICUgMzYwO1xuICAgIHJldHVybiByYWRpYW5zICogTWF0aC5QSSAvIDE4MDtcbn1cbmV4cG9ydHMuZGVncmVlc1RvUmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnM7XG4vKipcbiAqIENvbnZlcnRzIGEgbGVuZ3RoIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIG9mIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRMZW5ndGgobGVuZ3RoLCBvcmlnaW5hbFVuaXQsIGZpbmFsVW5pdCkge1xuICAgIGlmIChvcmlnaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBvcmlnaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmICghKGxlbmd0aCA+PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnNUb0xlbmd0aChsZW5ndGhUb1JhZGlhbnMobGVuZ3RoLCBvcmlnaW5hbFVuaXQpLCBmaW5hbFVuaXQpO1xufVxuZXhwb3J0cy5jb252ZXJ0TGVuZ3RoID0gY29udmVydExlbmd0aDtcbi8qKlxuICogQ29udmVydHMgYSBhcmVhIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBraWxvbWV0ZXJzLCBraWxvbWV0cmVzLCBtZXRlcnMsIG1ldHJlcywgY2VudGltZXRyZXMsIG1pbGxpbWV0ZXJzLCBhY3JlcywgbWlsZXMsIHlhcmRzLCBmZWV0LCBpbmNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtVbml0c30gW29yaWdpbmFsVW5pdD1cIm1ldGVyc1wiXSBvZiB0aGUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gY29udmVydEFyZWEoYXJlYSwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHsgb3JpZ2luYWxVbml0ID0gXCJtZXRlcnNcIjsgfVxuICAgIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmICghKGFyZWEgPj0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJlYSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRGYWN0b3IgPSBleHBvcnRzLmFyZWFGYWN0b3JzW29yaWdpbmFsVW5pdF07XG4gICAgaWYgKCFzdGFydEZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yaWdpbmFsIHVuaXRzXCIpO1xuICAgIH1cbiAgICB2YXIgZmluYWxGYWN0b3IgPSBleHBvcnRzLmFyZWFGYWN0b3JzW2ZpbmFsVW5pdF07XG4gICAgaWYgKCFmaW5hbEZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbmFsIHVuaXRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZWEgLyBzdGFydEZhY3RvcikgKiBmaW5hbEZhY3Rvcjtcbn1cbmV4cG9ydHMuY29udmVydEFyZWEgPSBjb252ZXJ0QXJlYTtcbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gICAgcmV0dXJuICFpc05hTihudW0pICYmIG51bSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShudW0pICYmICEvXlxccyokLy50ZXN0KG51bSk7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKipcbiAqIGlzT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBpbnB1dCB2YXJpYWJsZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB0dXJmLmlzT2JqZWN0KHtlbGV2YXRpb246IDEwfSlcbiAqIC8vPXRydWVcbiAqIHR1cmYuaXNPYmplY3QoJ2ZvbycpXG4gKiAvLz1mYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIHJldHVybiAoISFpbnB1dCkgJiYgKGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLyoqXG4gKiBWYWxpZGF0ZSBCQm94XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBCQm94IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgQkJveCBpcyBub3QgdmFsaWRcbiAqIEBleGFtcGxlXG4gKiB2YWxpZGF0ZUJCb3goWy0xODAsIC00MCwgMTEwLCA1MF0pXG4gKiAvLz1PS1xuICogdmFsaWRhdGVCQm94KFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCgnRm9vJylcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3goNSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3gobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3godW5kZWZpbmVkKVxuICogLy89RXJyb3JcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCQm94KGJib3gpIHtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKGJib3gubGVuZ3RoICE9PSA0ICYmIGJib3gubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheSBvZiA0IG9yIDYgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgYmJveC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihudW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3Qgb25seSBjb250YWluIG51bWJlcnNcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVCQm94ID0gdmFsaWRhdGVCQm94O1xuLyoqXG4gKiBWYWxpZGF0ZSBJZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIElkIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgSWQgaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVJZChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoJ0ZvbycpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZCg1KVxuICogLy89T0tcbiAqIHZhbGlkYXRlSWQobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSWQoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluZGV4T2YodHlwZW9mIGlkKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlSWQgPSB2YWxpZGF0ZUlkO1xuLy8gRGVwcmVjYXRlZCBtZXRob2RzXG5mdW5jdGlvbiByYWRpYW5zMmRlZ3JlZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHJhZGlhbnNUb0RlZ3JlZXNgXCIpO1xufVxuZXhwb3J0cy5yYWRpYW5zMmRlZ3JlZXMgPSByYWRpYW5zMmRlZ3JlZXM7XG5mdW5jdGlvbiBkZWdyZWVzMnJhZGlhbnMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZ3JlZXNUb1JhZGlhbnNgXCIpO1xufVxuZXhwb3J0cy5kZWdyZWVzMnJhZGlhbnMgPSBkZWdyZWVzMnJhZGlhbnM7XG5mdW5jdGlvbiBkaXN0YW5jZVRvRGVncmVlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBgbGVuZ3RoVG9EZWdyZWVzYFwiKTtcbn1cbmV4cG9ydHMuZGlzdGFuY2VUb0RlZ3JlZXMgPSBkaXN0YW5jZVRvRGVncmVlcztcbmZ1bmN0aW9uIGRpc3RhbmNlVG9SYWRpYW5zKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGBsZW5ndGhUb1JhZGlhbnNgXCIpO1xufVxuZXhwb3J0cy5kaXN0YW5jZVRvUmFkaWFucyA9IGRpc3RhbmNlVG9SYWRpYW5zO1xuZnVuY3Rpb24gcmFkaWFuc1RvRGlzdGFuY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHJhZGlhbnNUb0xlbmd0aGBcIik7XG59XG5leHBvcnRzLnJhZGlhbnNUb0Rpc3RhbmNlID0gcmFkaWFuc1RvRGlzdGFuY2U7XG5mdW5jdGlvbiBiZWFyaW5nVG9BbmdsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBgYmVhcmluZ1RvQXppbXV0aGBcIik7XG59XG5leHBvcnRzLmJlYXJpbmdUb0FuZ2xlID0gYmVhcmluZ1RvQW5nbGU7XG5mdW5jdGlvbiBjb252ZXJ0RGlzdGFuY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGNvbnZlcnRMZW5ndGhgXCIpO1xufVxuZXhwb3J0cy5jb252ZXJ0RGlzdGFuY2UgPSBjb252ZXJ0RGlzdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIkB0dXJmL2hlbHBlcnNcIik7XHJcbi8qKlxyXG4gKiBVbndyYXAgYSBjb29yZGluYXRlIGZyb20gYSBQb2ludCBGZWF0dXJlLCBHZW9tZXRyeSBvciBhIHNpbmdsZSBjb29yZGluYXRlLlxyXG4gKlxyXG4gKiBAbmFtZSBnZXRDb29yZFxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj58R2VvbWV0cnk8UG9pbnQ+fEZlYXR1cmU8UG9pbnQ+fSBjb29yZCBHZW9KU09OIFBvaW50IG9yIGFuIEFycmF5IG9mIG51bWJlcnNcclxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBwdCA9IHR1cmYucG9pbnQoWzEwLCAxMF0pO1xyXG4gKlxyXG4gKiB2YXIgY29vcmQgPSB0dXJmLmdldENvb3JkKHB0KTtcclxuICogLy89IFsxMCwgMTBdXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb29yZChjb29yZCkge1xyXG4gICAgaWYgKCFjb29yZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIGlzIHJlcXVpcmVkXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkKSkge1xyXG4gICAgICAgIGlmIChjb29yZC50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBjb29yZC5nZW9tZXRyeSAhPT0gbnVsbCAmJiBjb29yZC5nZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29vcmQudHlwZSA9PT0gXCJQb2ludFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5jb29yZGluYXRlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb29yZCkgJiYgY29vcmQubGVuZ3RoID49IDIgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRbMF0pICYmICFBcnJheS5pc0FycmF5KGNvb3JkWzFdKSkge1xyXG4gICAgICAgIHJldHVybiBjb29yZDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIG11c3QgYmUgR2VvSlNPTiBQb2ludCBvciBhbiBBcnJheSBvZiBudW1iZXJzXCIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29vcmQgPSBnZXRDb29yZDtcclxuLyoqXHJcbiAqIFVud3JhcCBjb29yZGluYXRlcyBmcm9tIGEgRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XHJcbiAqXHJcbiAqIEBuYW1lIGdldENvb3Jkc1xyXG4gKiBAcGFyYW0ge0FycmF5PGFueT58R2VvbWV0cnl8RmVhdHVyZX0gY29vcmRzIEZlYXR1cmUsIEdlb21ldHJ5IE9iamVjdCBvciBhbiBBcnJheVxyXG4gKiBAcmV0dXJucyB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXNcclxuICogQGV4YW1wbGVcclxuICogdmFyIHBvbHkgPSB0dXJmLnBvbHlnb24oW1tbMTE5LjMyLCAtOC43XSwgWzExOS41NSwgLTguNjldLCBbMTE5LjUxLCAtOC41NF0sIFsxMTkuMzIsIC04LjddXV0pO1xyXG4gKlxyXG4gKiB2YXIgY29vcmRzID0gdHVyZi5nZXRDb29yZHMocG9seSk7XHJcbiAqIC8vPSBbW1sxMTkuMzIsIC04LjddLCBbMTE5LjU1LCAtOC42OV0sIFsxMTkuNTEsIC04LjU0XSwgWzExOS4zMiwgLTguN11dXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29vcmRzKGNvb3Jkcykge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcbiAgICB9XHJcbiAgICAvLyBGZWF0dXJlXHJcbiAgICBpZiAoY29vcmRzLnR5cGUgPT09IFwiRmVhdHVyZVwiKSB7XHJcbiAgICAgICAgaWYgKGNvb3Jkcy5nZW9tZXRyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEdlb21ldHJ5XHJcbiAgICAgICAgaWYgKGNvb3Jkcy5jb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkcyBtdXN0IGJlIEdlb0pTT04gRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XCIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29vcmRzID0gZ2V0Q29vcmRzO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIGNvb3JkaW5hdGVzIGNvbnRhaW5zIGEgbnVtYmVyXHJcbiAqXHJcbiAqIEBuYW1lIGNvbnRhaW5zTnVtYmVyXHJcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgR2VvSlNPTiBDb29yZGluYXRlc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBBcnJheSBjb250YWlucyBhIG51bWJlclxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnNOdW1iZXIoY29vcmRpbmF0ZXMpIHtcclxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxICYmIGhlbHBlcnNfMS5pc051bWJlcihjb29yZGluYXRlc1swXSkgJiYgaGVscGVyc18xLmlzTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pICYmIGNvb3JkaW5hdGVzWzBdLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBjb250YWluc051bWJlcihjb29yZGluYXRlc1swXSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IG9ubHkgY29udGFpbiBudW1iZXJzXCIpO1xyXG59XHJcbmV4cG9ydHMuY29udGFpbnNOdW1iZXIgPSBjb250YWluc051bWJlcjtcclxuLyoqXHJcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIEdlb0pTT04gb2JqZWN0cyBmb3IgVHVyZi5cclxuICpcclxuICogQG5hbWUgZ2VvanNvblR5cGVcclxuICogQHBhcmFtIHtHZW9KU09OfSB2YWx1ZSBhbnkgR2VvSlNPTiBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VvanNvblR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcclxuICAgIGlmICghdHlwZSB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgYW5kIG5hbWUgcmVxdWlyZWRcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICsgbmFtZSArIFwiOiBtdXN0IGJlIGEgXCIgKyB0eXBlICsgXCIsIGdpdmVuIFwiICsgdmFsdWUudHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZW9qc29uVHlwZSA9IGdlb2pzb25UeXBlO1xyXG4vKipcclxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmV9IGlucHV0cyBmb3IgVHVyZi5cclxuICogSW50ZXJuYWxseSB0aGlzIHVzZXMge0BsaW5rIGdlb2pzb25UeXBlfSB0byBqdWRnZSBnZW9tZXRyeSB0eXBlcy5cclxuICpcclxuICogQG5hbWUgZmVhdHVyZU9mXHJcbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBhIGZlYXR1cmUgd2l0aCBhbiBleHBlY3RlZCBnZW9tZXRyeSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cclxuICogQHRocm93cyB7RXJyb3J9IGVycm9yIGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGZlYXR1cmVPZihmZWF0dXJlLCB0eXBlLCBuYW1lKSB7XHJcbiAgICBpZiAoIWZlYXR1cmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmZWF0dXJlIHBhc3NlZFwiKTtcclxuICAgIH1cclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5mZWF0dXJlT2YoKSByZXF1aXJlcyBhIG5hbWVcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWZlYXR1cmUgfHwgZmVhdHVyZS50eXBlICE9PSBcIkZlYXR1cmVcIiB8fCAhZmVhdHVyZS5nZW9tZXRyeSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCIsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZFwiKTtcclxuICAgIH1cclxuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICsgbmFtZSArIFwiOiBtdXN0IGJlIGEgXCIgKyB0eXBlICsgXCIsIGdpdmVuIFwiICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZlYXR1cmVPZiA9IGZlYXR1cmVPZjtcclxuLyoqXHJcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gaW5wdXRzIGZvciBUdXJmLlxyXG4gKiBJbnRlcm5hbGx5IHRoaXMgdXNlcyB7QGxpbmsgZ2VvanNvblR5cGV9IHRvIGp1ZGdlIGdlb21ldHJ5IHR5cGVzLlxyXG4gKlxyXG4gKiBAbmFtZSBjb2xsZWN0aW9uT2ZcclxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmVhdHVyZUNvbGxlY3Rpb24gYSBGZWF0dXJlQ29sbGVjdGlvbiBmb3Igd2hpY2ggZmVhdHVyZXMgd2lsbCBiZSBqdWRnZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKGZlYXR1cmVDb2xsZWN0aW9uLCB0eXBlLCBuYW1lKSB7XHJcbiAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmVhdHVyZUNvbGxlY3Rpb24gcGFzc2VkXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLmNvbGxlY3Rpb25PZigpIHJlcXVpcmVzIGEgbmFtZVwiKTtcclxuICAgIH1cclxuICAgIGlmICghZmVhdHVyZUNvbGxlY3Rpb24gfHwgZmVhdHVyZUNvbGxlY3Rpb24udHlwZSAhPT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBcIiArIG5hbWUgKyBcIiwgRmVhdHVyZUNvbGxlY3Rpb24gcmVxdWlyZWRcIik7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBfYVtfaV07XHJcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gXCJGZWF0dXJlXCIgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBcIiArIG5hbWUgKyBcIiwgRmVhdHVyZSB3aXRoIGdlb21ldHJ5IHJlcXVpcmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCI6IG11c3QgYmUgYSBcIiArIHR5cGUgKyBcIiwgZ2l2ZW4gXCIgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvbGxlY3Rpb25PZiA9IGNvbGxlY3Rpb25PZjtcclxuLyoqXHJcbiAqIEdldCBHZW9tZXRyeSBmcm9tIEZlYXR1cmUgb3IgR2VvbWV0cnkgT2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmUgb3IgR2VvbWV0cnkgT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtHZW9tZXRyeXxudWxsfSBHZW9KU09OIEdlb21ldHJ5IE9iamVjdFxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgZ2VvanNvbiBpcyBub3QgYSBGZWF0dXJlIG9yIEdlb21ldHJ5IE9iamVjdFxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcG9pbnQgPSB7XHJcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDQwXVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiB2YXIgZ2VvbSA9IHR1cmYuZ2V0R2VvbShwb2ludClcclxuICogLy89e1widHlwZVwiOiBcIlBvaW50XCIsIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNDBdfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2VvbShnZW9qc29uKSB7XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xyXG4gICAgICAgIHJldHVybiBnZW9qc29uLmdlb21ldHJ5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdlb2pzb247XHJcbn1cclxuZXhwb3J0cy5nZXRHZW9tID0gZ2V0R2VvbTtcclxuLyoqXHJcbiAqIEdldCBHZW9KU09OIG9iamVjdCdzIHR5cGUsIEdlb21ldHJ5IHR5cGUgaXMgcHJpb3JpdGl6ZS5cclxuICpcclxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIEdlb0pTT04gb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cImdlb2pzb25cIl0gbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gZGlzcGxheSBpbiBlcnJvciBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEdlb0pTT04gdHlwZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcG9pbnQgPSB7XHJcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDQwXVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiB2YXIgZ2VvbSA9IHR1cmYuZ2V0VHlwZShwb2ludClcclxuICogLy89XCJQb2ludFwiXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlKGdlb2pzb24sIG5hbWUpIHtcclxuICAgIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBcIkZlYXR1cmVDb2xsZWN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBnZW9qc29uLmdlb21ldHJ5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb2pzb24uZ2VvbWV0cnkudHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZW9qc29uLnR5cGU7XHJcbn1cclxuZXhwb3J0cy5nZXRUeXBlID0gZ2V0VHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG52YXIgbGluZV9zZWdtZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkB0dXJmL2xpbmUtc2VnbWVudFwiKSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgZ2VvanNvbl9yYnVzaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJnZW9qc29uLXJidXNoXCIpKTtcbi8qKlxuICogVGFrZXMgYW55IExpbmVTdHJpbmcgb3IgUG9seWdvbiBHZW9KU09OIGFuZCByZXR1cm5zIHRoZSBpbnRlcnNlY3RpbmcgcG9pbnQocykuXG4gKlxuICogQG5hbWUgbGluZUludGVyc2VjdFxuICogQHBhcmFtIHtHZW9KU09OfSBsaW5lMSBhbnkgTGluZVN0cmluZyBvciBQb2x5Z29uXG4gKiBAcGFyYW0ge0dlb0pTT059IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50KHMpIHRoYXQgaW50ZXJzZWN0IGJvdGhcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZTEgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMjYsIC0xMV0sIFsxMjksIC0yMV1dKTtcbiAqIHZhciBsaW5lMiA9IHR1cmYubGluZVN0cmluZyhbWzEyMywgLTE4XSwgWzEzMSwgLTE0XV0pO1xuICogdmFyIGludGVyc2VjdHMgPSB0dXJmLmxpbmVJbnRlcnNlY3QobGluZTEsIGxpbmUyKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZTEsIGxpbmUyLCBpbnRlcnNlY3RzXVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0KGxpbmUxLCBsaW5lMikge1xuICAgIHZhciB1bmlxdWUgPSB7fTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIC8vIEZpcnN0LCBub3JtYWxpemUgZ2VvbWV0cmllcyB0byBmZWF0dXJlc1xuICAgIC8vIFRoZW4sIGhhbmRsZSBzaW1wbGUgMi12ZXJ0ZXggc2VnbWVudHNcbiAgICBpZiAobGluZTEudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgbGluZTEgPSBoZWxwZXJzXzEuZmVhdHVyZShsaW5lMSk7XG4gICAgfVxuICAgIGlmIChsaW5lMi50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICBsaW5lMiA9IGhlbHBlcnNfMS5mZWF0dXJlKGxpbmUyKTtcbiAgICB9XG4gICAgaWYgKGxpbmUxLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmXG4gICAgICAgIGxpbmUyLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5ICE9PSBudWxsICYmXG4gICAgICAgIGxpbmUyLmdlb21ldHJ5ICE9PSBudWxsICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiICYmXG4gICAgICAgIGxpbmUyLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICBsaW5lMi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGludGVyc2VjdHMobGluZTEsIGxpbmUyKTtcbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBlcnNfMS5mZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlcyBjb21wbGV4IEdlb0pTT04gR2VvbWV0cmllc1xuICAgIHZhciB0cmVlID0gZ2VvanNvbl9yYnVzaF8xLmRlZmF1bHQoKTtcbiAgICB0cmVlLmxvYWQobGluZV9zZWdtZW50XzEuZGVmYXVsdChsaW5lMikpO1xuICAgIG1ldGFfMS5mZWF0dXJlRWFjaChsaW5lX3NlZ21lbnRfMS5kZWZhdWx0KGxpbmUxKSwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgbWV0YV8xLmZlYXR1cmVFYWNoKHRyZWUuc2VhcmNoKHNlZ21lbnQpLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBpbnRlcnNlY3RzKHNlZ21lbnQsIG1hdGNoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBwb2ludHMgaHR0cHM6Ly9naXRodWIuY29tL1R1cmZqcy90dXJmL2lzc3Vlcy82ODhcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGludGVyc2VjdCkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbnRlcnNlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlbHBlcnNfMS5mZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbn1cbi8qKlxuICogRmluZCBhIHBvaW50IHRoYXQgaW50ZXJzZWN0cyBMaW5lU3RyaW5ncyB3aXRoIHR3byBjb29yZGluYXRlcyBlYWNoXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZTEgR2VvSlNPTiBMaW5lU3RyaW5nIChNdXN0IG9ubHkgY29udGFpbiAyIGNvb3JkaW5hdGVzKVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lMiBHZW9KU09OIExpbmVTdHJpbmcgKE11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXMpXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGludGVyc2VjdGluZyBHZW9KU09OIFBvaW50XG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdHMobGluZTEsIGxpbmUyKSB7XG4gICAgdmFyIGNvb3JkczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobGluZTEpO1xuICAgIHZhciBjb29yZHMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGxpbmUyKTtcbiAgICBpZiAoY29vcmRzMS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPGludGVyc2VjdHM+IGxpbmUxIG11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXNcIik7XG4gICAgfVxuICAgIGlmIChjb29yZHMyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8aW50ZXJzZWN0cz4gbGluZTIgbXVzdCBvbmx5IGNvbnRhaW4gMiBjb29yZGluYXRlc1wiKTtcbiAgICB9XG4gICAgdmFyIHgxID0gY29vcmRzMVswXVswXTtcbiAgICB2YXIgeTEgPSBjb29yZHMxWzBdWzFdO1xuICAgIHZhciB4MiA9IGNvb3JkczFbMV1bMF07XG4gICAgdmFyIHkyID0gY29vcmRzMVsxXVsxXTtcbiAgICB2YXIgeDMgPSBjb29yZHMyWzBdWzBdO1xuICAgIHZhciB5MyA9IGNvb3JkczJbMF1bMV07XG4gICAgdmFyIHg0ID0gY29vcmRzMlsxXVswXTtcbiAgICB2YXIgeTQgPSBjb29yZHMyWzFdWzFdO1xuICAgIHZhciBkZW5vbSA9ICgoeTQgLSB5MykgKiAoeDIgLSB4MSkpIC0gKCh4NCAtIHgzKSAqICh5MiAtIHkxKSk7XG4gICAgdmFyIG51bWVBID0gKCh4NCAtIHgzKSAqICh5MSAtIHkzKSkgLSAoKHk0IC0geTMpICogKHgxIC0geDMpKTtcbiAgICB2YXIgbnVtZUIgPSAoKHgyIC0geDEpICogKHkxIC0geTMpKSAtICgoeTIgLSB5MSkgKiAoeDEgLSB4MykpO1xuICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgICBpZiAobnVtZUEgPT09IDAgJiYgbnVtZUIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdUEgPSBudW1lQSAvIGRlbm9tO1xuICAgIHZhciB1QiA9IG51bWVCIC8gZGVub207XG4gICAgaWYgKHVBID49IDAgJiYgdUEgPD0gMSAmJiB1QiA+PSAwICYmIHVCIDw9IDEpIHtcbiAgICAgICAgdmFyIHggPSB4MSArICh1QSAqICh4MiAtIHgxKSk7XG4gICAgICAgIHZhciB5ID0geTEgKyAodUEgKiAoeTIgLSB5MSkpO1xuICAgICAgICByZXR1cm4gaGVscGVyc18xLnBvaW50KFt4LCB5XSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbGluZUludGVyc2VjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdlb2pzb25fcmJ1c2hfMSA9IHJlcXVpcmUoXCJnZW9qc29uLXJidXNoXCIpO1xudmFyIGxpbmVfc2VnbWVudF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtc2VnbWVudFwiKTtcbnZhciBuZWFyZXN0X3BvaW50X29uX2xpbmVfMSA9IHJlcXVpcmUoXCJAdHVyZi9uZWFyZXN0LXBvaW50LW9uLWxpbmVcIik7XG52YXIgYm9vbGVhbl9wb2ludF9vbl9saW5lXzEgPSByZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1vbi1saW5lXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbnZhciBtZXRhXzEgPSByZXF1aXJlKFwiQHR1cmYvbWV0YVwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuLyoqXG4gKiBUYWtlcyBhbnkgTGluZVN0cmluZyBvciBQb2x5Z29uIGFuZCByZXR1cm5zIHRoZSBvdmVybGFwcGluZyBsaW5lcyBiZXR3ZWVuIGJvdGggZmVhdHVyZXMuXG4gKlxuICogQG5hbWUgbGluZU92ZXJsYXBcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUxIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXSBUb2xlcmFuY2UgZGlzdGFuY2UgdG8gbWF0Y2ggb3ZlcmxhcHBpbmcgbGluZSBzZWdtZW50cyAoaW4ga2lsb21ldGVycylcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gbGluZXMocykgdGhhdCBhcmUgb3ZlcmxhcHBpbmcgYmV0d2VlbiBib3RoIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUxID0gdHVyZi5saW5lU3RyaW5nKFtbMTE1LCAtMzVdLCBbMTI1LCAtMzBdLCBbMTM1LCAtMzBdLCBbMTQ1LCAtMzVdXSk7XG4gKiB2YXIgbGluZTIgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMTUsIC0yNV0sIFsxMjUsIC0zMF0sIFsxMzUsIC0zMF0sIFsxNDUsIC0yNV1dKTtcbiAqXG4gKiB2YXIgb3ZlcmxhcHBpbmcgPSB0dXJmLmxpbmVPdmVybGFwKGxpbmUxLCBsaW5lMik7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUxLCBsaW5lMiwgb3ZlcmxhcHBpbmddXG4gKi9cbmZ1bmN0aW9uIGxpbmVPdmVybGFwKGxpbmUxLCBsaW5lMiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgLy8gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghaGVscGVyc18xLmlzT2JqZWN0KG9wdGlvbnMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgaXMgaW52YWxpZCcpO1xuICAgIHZhciB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAwO1xuICAgIC8vIENvbnRhaW5lcnNcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAvLyBDcmVhdGUgU3BhdGlhbCBJbmRleFxuICAgIHZhciB0cmVlID0gZ2VvanNvbl9yYnVzaF8xLmRlZmF1bHQoKTtcbiAgICAvLyBUby1EbyAtLSBIQUNLIHdheSB0byBzdXBwb3J0IHR5cGVzY3JpcHRcbiAgICB2YXIgbGluZSA9IGxpbmVfc2VnbWVudF8xLmRlZmF1bHQobGluZTEpO1xuICAgIHRyZWUubG9hZChsaW5lKTtcbiAgICB2YXIgb3ZlcmxhcFNlZ21lbnQ7XG4gICAgLy8gTGluZSBJbnRlcnNlY3Rpb25cbiAgICAvLyBJdGVyYXRlIG92ZXIgbGluZSBzZWdtZW50c1xuICAgIG1ldGFfMS5zZWdtZW50RWFjaChsaW5lMiwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGRvZXNPdmVybGFwcyA9IGZhbHNlO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBzZWdtZW50cyB3aGljaCBmYWxscyB3aXRoaW4gdGhlIHNhbWUgYm91bmRzXG4gICAgICAgIG1ldGFfMS5mZWF0dXJlRWFjaCh0cmVlLnNlYXJjaChzZWdtZW50KSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoZG9lc092ZXJsYXBzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHNTZWdtZW50ID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKHNlZ21lbnQpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzTWF0Y2ggPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobWF0Y2gpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAvLyBTZWdtZW50IG92ZXJsYXBzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoY29vcmRzU2VnbWVudCwgY29vcmRzTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvZXNPdmVybGFwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJsYXBzIGFscmVhZHkgZXhpc3RzIC0gb25seSBhcHBlbmQgbGFzdCBjb29yZGluYXRlIG9mIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBzZWdtZW50cyB3aGljaCBkb24ndCBzaGFyZSBub2RlcyAoSXNzdWUgIzkwMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHRvbGVyYW5jZSA9PT0gMCkgP1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGNvb3Jkc1NlZ21lbnRbMF0sIG1hdGNoKSAmJiBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGNvb3Jkc1NlZ21lbnRbMV0sIG1hdGNoKSA6XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfcG9pbnRfb25fbGluZV8xLmRlZmF1bHQobWF0Y2gsIGNvb3Jkc1NlZ21lbnRbMF0pLnByb3BlcnRpZXMuZGlzdCA8PSB0b2xlcmFuY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfcG9pbnRfb25fbGluZV8xLmRlZmF1bHQobWF0Y2gsIGNvb3Jkc1NlZ21lbnRbMV0pLnByb3BlcnRpZXMuZGlzdCA8PSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9lc092ZXJsYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodG9sZXJhbmNlID09PSAwKSA/XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmRzTWF0Y2hbMF0sIHNlZ21lbnQpICYmIGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmRzTWF0Y2hbMV0sIHNlZ21lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdF9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChzZWdtZW50LCBjb29yZHNNYXRjaFswXSkucHJvcGVydGllcy5kaXN0IDw9IHRvbGVyYW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmVhcmVzdF9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChzZWdtZW50LCBjb29yZHNNYXRjaFsxXSkucHJvcGVydGllcy5kaXN0IDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgZGVmaW5lIChkb2VzT3ZlcmxhcCA9IHRydWUpIHNpbmNlIG1vcmUgbWF0Y2hlcyBjYW4gb2NjdXIgd2l0aGluIHRoZSBzYW1lIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc092ZXJsYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBTZWdtZW50ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2VnbWVudCBkb2Vzbid0IG92ZXJsYXAgLSBhZGQgb3ZlcmxhcHMgdG8gcmVzdWx0cyAmIHJlc2V0XG4gICAgICAgIGlmIChkb2VzT3ZlcmxhcHMgPT09IGZhbHNlICYmIG92ZXJsYXBTZWdtZW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKG92ZXJsYXBTZWdtZW50KTtcbiAgICAgICAgICAgIG92ZXJsYXBTZWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGxhc3Qgc2VnbWVudCBpZiBleGlzdHNcbiAgICBpZiAob3ZlcmxhcFNlZ21lbnQpXG4gICAgICAgIGZlYXR1cmVzLnB1c2gob3ZlcmxhcFNlZ21lbnQpO1xuICAgIHJldHVybiBoZWxwZXJzXzEuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xufVxuLyoqXG4gKiBDb25jYXQgU2VnbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgTGluZVN0cmluZ1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBzZWdtZW50IDItdmVydGV4IExpbmVTdHJpbmdcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjb25jYXQgbGluZXN0cmluZ1xuICovXG5mdW5jdGlvbiBjb25jYXRTZWdtZW50KGxpbmUsIHNlZ21lbnQpIHtcbiAgICB2YXIgY29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKHNlZ21lbnQpO1xuICAgIHZhciBsaW5lQ29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGxpbmUpO1xuICAgIHZhciBzdGFydCA9IGxpbmVDb29yZHNbMF07XG4gICAgdmFyIGVuZCA9IGxpbmVDb29yZHNbbGluZUNvb3Jkcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZ2VvbSA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgaWYgKGVxdWFsKGNvb3Jkc1swXSwgc3RhcnQpKVxuICAgICAgICBnZW9tLnVuc2hpZnQoY29vcmRzWzFdKTtcbiAgICBlbHNlIGlmIChlcXVhbChjb29yZHNbMF0sIGVuZCkpXG4gICAgICAgIGdlb20ucHVzaChjb29yZHNbMV0pO1xuICAgIGVsc2UgaWYgKGVxdWFsKGNvb3Jkc1sxXSwgc3RhcnQpKVxuICAgICAgICBnZW9tLnVuc2hpZnQoY29vcmRzWzBdKTtcbiAgICBlbHNlIGlmIChlcXVhbChjb29yZHNbMV0sIGVuZCkpXG4gICAgICAgIGdlb20ucHVzaChjb29yZHNbMF0pO1xuICAgIHJldHVybiBsaW5lO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbGluZU92ZXJsYXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIDItdmVydGV4IHtAbGluayBMaW5lU3RyaW5nfSBzZWdtZW50cyBmcm9tIGFcbiAqIHtAbGluayBMaW5lU3RyaW5nfChNdWx0aSlMaW5lU3RyaW5nfSBvciB7QGxpbmsgUG9seWdvbnwoTXVsdGkpUG9seWdvbn0uXG4gKlxuICogQG5hbWUgbGluZVNlZ21lbnRcbiAqIEBwYXJhbSB7R2VvSlNPTn0gZ2VvanNvbiBHZW9KU09OIFBvbHlnb24gb3IgTGluZVN0cmluZ1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSAyLXZlcnRleCBsaW5lIHNlZ21lbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICogdmFyIHNlZ21lbnRzID0gdHVyZi5saW5lU2VnbWVudChwb2x5Z29uKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbcG9seWdvbiwgc2VnbWVudHNdXG4gKi9cbmZ1bmN0aW9uIGxpbmVTZWdtZW50KGdlb2pzb24pIHtcbiAgICBpZiAoIWdlb2pzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBtZXRhXzEuZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgbGluZVNlZ21lbnRGZWF0dXJlKGZlYXR1cmUsIHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWxwZXJzXzEuZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59XG4vKipcbiAqIExpbmUgU2VnbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29uPn0gZ2VvanNvbiBMaW5lIG9yIHBvbHlnb24gZmVhdHVyZVxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyBwdXNoIHRvIHJlc3VsdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBsaW5lU2VnbWVudEZlYXR1cmUoZ2VvanNvbiwgcmVzdWx0cykge1xuICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgIGlmIChnZW9tZXRyeSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgY29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY29vcmRzID0gW2ludmFyaWFudF8xLmdldENvb3JkcyhnZW9tZXRyeSldO1xuICAgICAgICB9XG4gICAgICAgIGNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY3JlYXRlU2VnbWVudHMoY29vcmQsIGdlb2pzb24ucHJvcGVydGllcyk7XG4gICAgICAgICAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5pZCA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBTZWdtZW50cyBmcm9tIExpbmVTdHJpbmcgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRzIExpbmVTdHJpbmcgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7Kn0gcHJvcGVydGllcyBHZW9KU09OIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtBcnJheTxGZWF0dXJlPExpbmVTdHJpbmc+Pn0gbGluZSBzZWdtZW50c1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWdtZW50cyhjb29yZHMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBjb29yZHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3Jkcykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGhlbHBlcnNfMS5saW5lU3RyaW5nKFtwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3Jkc10sIHByb3BlcnRpZXMpO1xuICAgICAgICBzZWdtZW50LmJib3ggPSBiYm94KHByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRzKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb29yZHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xufVxuLyoqXG4gKiBDcmVhdGUgQkJveCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyAoZmFzdGVyIHRoYW4gQHR1cmYvYmJveClcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZHMxIFBvaW50IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRzMiBQb2ludCBjb29yZGluYXRlXG4gKiBAcmV0dXJucyB7QkJveH0gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqL1xuZnVuY3Rpb24gYmJveChjb29yZHMxLCBjb29yZHMyKSB7XG4gICAgdmFyIHgxID0gY29vcmRzMVswXTtcbiAgICB2YXIgeTEgPSBjb29yZHMxWzFdO1xuICAgIHZhciB4MiA9IGNvb3JkczJbMF07XG4gICAgdmFyIHkyID0gY29vcmRzMlsxXTtcbiAgICB2YXIgd2VzdCA9ICh4MSA8IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIHNvdXRoID0gKHkxIDwgeTIpID8geTEgOiB5MjtcbiAgICB2YXIgZWFzdCA9ICh4MSA+IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIG5vcnRoID0gKHkxID4geTIpID8geTEgOiB5MjtcbiAgICByZXR1cm4gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBsaW5lU2VnbWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBjYWxsYmFjayBjb29yZEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBjb29yZEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRcbiAqICAgLy89Y29vcmRJbmRleFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChnZW9qc29uLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAgIC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIEdlb0pTT05cbiAgICBpZiAoZ2VvanNvbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBqLCBrLCBsLCBnZW9tZXRyeSwgc3RvcEcsIGNvb3JkcyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIHdyYXBTaHJpbmsgPSAwLFxuICAgICAgICBjb29yZEluZGV4ID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIHR5cGUgPSBnZW9qc29uLnR5cGUsXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSB0eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSB0eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gICAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gICAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAgIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gICAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKHZhciBmZWF0dXJlSW5kZXggPSAwOyBmZWF0dXJlSW5kZXggPCBzdG9wOyBmZWF0dXJlSW5kZXgrKykge1xuICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IChpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5IDpcbiAgICAgICAgICAgIChpc0ZlYXR1cmUgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbikpO1xuICAgICAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IChnZW9tZXRyeU1heWJlQ29sbGVjdGlvbikgPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyA6IGZhbHNlO1xuICAgICAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xuXG4gICAgICAgIGZvciAodmFyIGdlb21JbmRleCA9IDA7IGdlb21JbmRleCA8IHN0b3BHOyBnZW9tSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUluZGV4ID0gMDtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ2VvbUluZGV4XSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBnZW9tZXRyeVxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgdmFyIGdlb21UeXBlID0gZ2VvbWV0cnkudHlwZTtcblxuICAgICAgICAgICAgd3JhcFNocmluayA9IChleGNsdWRlV3JhcENvb3JkICYmIChnZW9tVHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21UeXBlID09PSAnTXVsdGlQb2x5Z29uJykpID8gMSA6IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZ2VvbVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09ICdNdWx0aVBvaW50JykgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnTGluZVN0cmluZycpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnUG9seWdvbicpIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnUG9seWdvbicpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBjb29yZHNbal1ba10ubGVuZ3RoIC0gd3JhcFNocmluazsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXVtsXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkRWFjaChnZW9tZXRyeS5nZW9tZXRyaWVzW2pdLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9tZXRyeSBUeXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKClcbiAqXG4gKiBAbmFtZSBjb29yZFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeXxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50Q29vcmQ7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgZXhjbHVkZVdyYXBDb29yZCkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGNvb3JkRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAgIGlmIChjb29yZEluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudENvb3JkO1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpO1xuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wRWFjaFxuICpcbiAqIEBjYWxsYmFjayBwcm9wRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBwcm9wRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYucHJvcEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLCBpKSA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICBjYWxsYmFjayhnZW9qc29uLnByb3BlcnRpZXMsIDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHByb3BSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7Kn0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCBpbnRvIGEgc2luZ2xlIHZhbHVlLFxuICogc2ltaWxhciB0byBob3cgQXJyYXkucmVkdWNlIHdvcmtzLiBIb3dldmVyLCBpbiB0aGlzIGNhc2Ugd2UgbGF6aWx5IHJ1blxuICogdGhlIHJlZHVjdGlvbiwgc28gYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgaXMgdW5uZWNlc3NhcnkuXG4gKlxuICogQG5hbWUgcHJvcFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5wcm9wUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudFByb3BlcnRpZXNcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBwcm9wRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudFByb3BlcnRpZXM7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmVhdHVyZUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNhbGxiYWNrKGdlb2pzb24sIDApO1xuICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb2pzb24uZmVhdHVyZXNbaV0sIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5mZWF0dXJlUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudEZlYXR1cmVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhbnkgR2VvSlNPTiBvYmplY3QuXG4gKlxuICogQG5hbWUgY29vcmRBbGxcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZSBwb3NpdGlvbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdmFyIGNvb3JkcyA9IHR1cmYuY29vcmRBbGwoZmVhdHVyZXMpO1xuICogLy89IFtbMjYsIDM3XSwgWzM2LCA1M11dXG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGdlb2pzb24pIHtcbiAgICB2YXIgY29vcmRzID0gW107XG4gICAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGosIGcsIGdlb21ldHJ5LCBzdG9wRyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgICAgZmVhdHVyZUJCb3gsXG4gICAgICAgIGZlYXR1cmVJZCxcbiAgICAgICAgZmVhdHVyZUluZGV4ID0gMCxcbiAgICAgICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgaXNGZWF0dXJlID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gICAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gICAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAgIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gICAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG5cbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uKSk7XG4gICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24ucHJvcGVydGllcyA6IHt9KSk7XG4gICAgICAgIGZlYXR1cmVCQm94ID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmJib3ggOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uYmJveCA6IHVuZGVmaW5lZCkpO1xuICAgICAgICBmZWF0dXJlSWQgPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uaWQgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uaWQgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSAoZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24pID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicgOiBmYWxzZTtcbiAgICAgICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbnVsbCBHZW9tZXRyeVxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG51bGwsIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb21ldHJ5IFR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGluY3JlYXNlIGBmZWF0dXJlSW5kZXhgIHBlciBlYWNoIGZlYXR1cmVcbiAgICAgICAgZmVhdHVyZUluZGV4Kys7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBnZW9tUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZ2VvbVJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogICByZXR1cm4gY3VycmVudEdlb21ldHJ5XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZ2VvbVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgZ2VvbUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEdlb21ldHJ5O1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmbGF0dGVuRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IGZsYXR0ZW5lZCBmZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5FYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlbkVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmbGF0dGVuRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAgIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBwcm9wZXJ0aWVzLCBiYm94LCBpZCkge1xuICAgICAgICAvLyBDYWxsYmFjayBmb3Igc2luZ2xlIGdlb21ldHJ5XG4gICAgICAgIHZhciB0eXBlID0gKGdlb21ldHJ5ID09PSBudWxsKSA/IG51bGwgOiBnZW9tZXRyeS50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhoZWxwZXJzLmZlYXR1cmUoZ2VvbWV0cnksIHByb3BlcnRpZXMsIHtiYm94OiBiYm94LCBpZDogaWR9KSwgZmVhdHVyZUluZGV4LCAwKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZW9tVHlwZTtcblxuICAgICAgICAvLyBDYWxsYmFjayBmb3IgbXVsdGktZ2VvbWV0cnlcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgICAgZ2VvbVR5cGUgPSAnUG9pbnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICBnZW9tVHlwZSA9ICdMaW5lU3RyaW5nJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgZ2VvbVR5cGUgPSAnUG9seWdvbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDsgbXVsdGlGZWF0dXJlSW5kZXggPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IG11bHRpRmVhdHVyZUluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbbXVsdGlGZWF0dXJlSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGdlb20gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZ2VvbVR5cGUsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soaGVscGVycy5mZWF0dXJlKGdlb20sIHByb3BlcnRpZXMpLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlblJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlblJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIG11bHRpRmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIDItdmVydGV4IGxpbmUgc2VnbWVudCBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICpcbiAqIC8vIEl0ZXJhdGUgb3ZlciBHZW9KU09OIGJ5IDItdmVydGV4IHNlZ21lbnRzXG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIC8vPXNlZ21lbnRJbmRleFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciB0b3RhbCA9IDA7XG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0b3RhbCsrO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IDA7XG5cbiAgICAgICAgLy8gRXhjbHVkZSBudWxsIEdlb21ldHJpZXNcbiAgICAgICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5KSByZXR1cm47XG4gICAgICAgIC8vIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50JykgcmV0dXJuO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIDItdmVydGV4IGxpbmUgc2VnbWVudHNcbiAgICAgICAgdmFyIHByZXZpb3VzQ29vcmRzO1xuICAgICAgICB2YXIgcHJldmlvdXNGZWF0dXJlSW5kZXggPSAwO1xuICAgICAgICB2YXIgcHJldmlvdXNNdWx0aUluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXZHZW9tSW5kZXggPSAwO1xuICAgICAgICBpZiAoY29vcmRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleENvb3JkLCBtdWx0aVBhcnRJbmRleENvb3JkLCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAgICAgICAvLyBTaW11bGF0aW5nIGEgbWV0YS5jb29yZFJlZHVjZSgpIHNpbmNlIGByZWR1Y2VgIG9wZXJhdGlvbnMgY2Fubm90IGJlIHN0b3BwZWQgYnkgcmV0dXJuaW5nIGBmYWxzZWBcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0Nvb3JkcyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmVJbmRleCA+IHByZXZpb3VzRmVhdHVyZUluZGV4IHx8IG11bHRpUGFydEluZGV4Q29vcmQgPiBwcmV2aW91c011bHRpSW5kZXggfHwgZ2VvbWV0cnlJbmRleCA+IHByZXZHZW9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0Nvb3JkcyA9IGN1cnJlbnRDb29yZDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0ZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c011bHRpSW5kZXggPSBtdWx0aVBhcnRJbmRleENvb3JkO1xuICAgICAgICAgICAgICAgIHByZXZHZW9tSW5kZXggPSBnZW9tZXRyeUluZGV4O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50ID0gaGVscGVycy5saW5lU3RyaW5nKFtwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3JkXSwgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCsrO1xuICAgICAgICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgICAgIH0pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBzZWdtZW50UmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSAyLXZlcnRleCBsaW5lIHNlZ21lbnQgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgY3VycmVudEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dKTtcbiAqXG4gKiAvLyBJdGVyYXRlIG92ZXIgR2VvSlNPTiBieSAyLXZlcnRleCBzZWdtZW50c1xuICogdHVyZi5zZWdtZW50UmVkdWNlKHBvbHlnb24sIGZ1bmN0aW9uIChwcmV2aW91c1NlZ21lbnQsIGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAqICAgLy89IHByZXZpb3VzU2VnbWVudFxuICogICAvLz0gY3VycmVudFNlZ21lbnRcbiAqICAgLy89IGZlYXR1cmVJbmRleFxuICogICAvLz0gbXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89IGdlb21ldHJ5SW5kZXhcbiAqICAgLy89IHNlZ21lbnRJbmV4XG4gKiAgIHJldHVybiBjdXJyZW50U2VnbWVudFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciBpbml0aWFsVmFsdWUgPSAwXG4gKiB2YXIgdG90YWwgPSB0dXJmLnNlZ21lbnRSZWR1Y2UocG9seWdvbiwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUpIHtcbiAqICAgICBwcmV2aW91c1ZhbHVlKys7XG4gKiAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gKiB9LCBpbml0aWFsVmFsdWUpO1xuICovXG5mdW5jdGlvbiBzZWdtZW50UmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHNlZ21lbnRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gICAgICAgIGlmIChzdGFydGVkID09PSBmYWxzZSAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRTZWdtZW50O1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVFYWNoXG4gKlxuICogQGNhbGxiYWNrIGxpbmVFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudExpbmUgVGhlIGN1cnJlbnQgTGluZVN0cmluZ3xMaW5lYXJSaW5nIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWRcbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBsaW5lIG9yIHJpbmcgY29vcmRpbmF0ZXMgaW4gTGluZVN0cmluZywgUG9seWdvbiwgTXVsdGlMaW5lU3RyaW5nLCBNdWx0aVBvbHlnb24gRmVhdHVyZXMgb3IgR2VvbWV0cmllcyxcbiAqIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBsaW5lRWFjaFxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPExpbmVTdHJpbmd8UG9seWdvbnxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29uPn0gZ2VvanNvbiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgIFtbMjYsIDM3XSwgWzM1LCA0NV1dLFxuICogICBbWzM2LCA1M10sIFszOCwgNTBdLCBbNDEsIDU1XV1cbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZUVhY2gobXVsdGlMaW5lLCBmdW5jdGlvbiAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudExpbmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBsaW5lRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAgIC8vIHZhbGlkYXRpb25cbiAgICBpZiAoIWdlb2pzb24pIHRocm93IG5ldyBFcnJvcignZ2VvanNvbiBpcyByZXF1aXJlZCcpO1xuXG4gICAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgIHZhciBjb29yZHMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgMCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICBmb3IgKHZhciBnZW9tZXRyeUluZGV4ID0gMDsgZ2VvbWV0cnlJbmRleCA8IGNvb3Jkcy5sZW5ndGg7IGdlb21ldHJ5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhoZWxwZXJzLmxpbmVTdHJpbmcoY29vcmRzW2dlb21ldHJ5SW5kZXhdLCBmZWF0dXJlLnByb3BlcnRpZXMpLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBsaW5lUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBsaW5lUmVkdWNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbXG4gKiAgIHR1cmYucG9seWdvbihbW1sxMiw0OF0sWzIsNDFdLFsyNCwzOF0sWzEyLDQ4XV0sIFtbOSw0NF0sWzEzLDQxXSxbMTMsNDVdLFs5LDQ0XV1dKSxcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzUsIDVdLCBbMCwgMF0sIFsyLCAyXSwgWzQsIDRdLCBbNSwgNV1dXSlcbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZVJlZHVjZShtdWx0aVBvbHksIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50TGluZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGxpbmVFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudExpbmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgMi12ZXJ0ZXggTGluZVN0cmluZyBTZWdtZW50IGZyb20gYSBHZW9KU09OIHVzaW5nIGBAdHVyZi9tZXRhYCBpbmRleGVzLlxuICpcbiAqIE5lZ2F0aXZlIGluZGV4ZXMgYXJlIHBlcm1pdHRlZC5cbiAqIFBvaW50ICYgTXVsdGlQb2ludCB3aWxsIGFsd2F5cyByZXR1cm4gbnVsbC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gQW55IEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmVhdHVyZUluZGV4PTBdIEZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleD0wXSBNdWx0aS1GZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZ2VvbWV0cnlJbmRleD0wXSBHZW9tZXRyeSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNlZ21lbnRJbmRleD0wXSBTZWdtZW50IEluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIFByb3BlcnRpZXMgdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QkJveH0gW29wdGlvbnMuYmJveD17fV0gVHJhbnNsYXRlIEJCb3ggdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IDItdmVydGV4IEdlb0pTT04gRmVhdHVyZSBMaW5lU3RyaW5nXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lKTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWzEwLCAxMF0sIFs1MCwgMzBdXT4+XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCBvZiAybmQgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogMX0pO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIExhc3QgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogLTEsIHNlZ21lbnRJbmRleDogLTF9KTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWy01MCwgLTMwXSwgWy0zMCwgLTQwXV0+PlxuICovXG5mdW5jdGlvbiBmaW5kU2VnbWVudChnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghaGVscGVycy5pc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIGlzIGludmFsaWQnKTtcbiAgICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gICAgdmFyIGdlb21ldHJ5SW5kZXggPSBvcHRpb25zLmdlb21ldHJ5SW5kZXggfHwgMDtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gb3B0aW9ucy5zZWdtZW50SW5kZXggfHwgMDtcblxuICAgIC8vIEZpbmQgRmVhdHVyZUluZGV4XG4gICAgdmFyIHByb3BlcnRpZXMgPSBvcHRpb25zLnByb3BlcnRpZXM7XG4gICAgdmFyIGdlb21ldHJ5O1xuXG4gICAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgIGlmIChmZWF0dXJlSW5kZXggPCAwKSBmZWF0dXJlSW5kZXggPSBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCArIGZlYXR1cmVJbmRleDtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLnByb3BlcnRpZXM7XG4gICAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzO1xuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb247XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VvanNvbiBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBTZWdtZW50SW5kZXhcbiAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLmxpbmVTdHJpbmcoW2Nvb3Jkc1tzZWdtZW50SW5kZXhdLCBjb29yZHNbc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHNbZ2VvbWV0cnlJbmRleF0ubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMubGluZVN0cmluZyhbY29vcmRzW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgICByZXR1cm4gaGVscGVycy5saW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgICByZXR1cm4gaGVscGVycy5saW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZW9qc29uIGlzIGludmFsaWQnKTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgUG9pbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29vcmRJbmRleD0wXSBDb29yZCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBQb2ludFxuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIFBvaW50XG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFsxMCwgMTBdPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIHRoZSAybmQgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0xMCwgLTEwXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIGxhc3QgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBjb29yZEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbLTMwLCAtNDBdPj5cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFoZWxwZXJzLmlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgaXMgaW52YWxpZCcpO1xuICAgIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICAgIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IG9wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXggfHwgMDtcbiAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICAgIHZhciBjb29yZEluZGV4ID0gb3B0aW9ucy5jb29yZEluZGV4IHx8IDA7XG5cbiAgICAvLyBGaW5kIEZlYXR1cmVJbmRleFxuICAgIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xuICAgIHZhciBnZW9tZXRyeTtcblxuICAgIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5wcm9wZXJ0aWVzO1xuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgQ29vcmQgSW5kZXhcbiAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3JkcywgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgICByZXR1cm4gaGVscGVycy5wb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3Jkc1tjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbZ2VvbWV0cnlJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMucG9pbnQoY29vcmRzW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgICByZXR1cm4gaGVscGVycy5wb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCAtIGNvb3JkSW5kZXg7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gaXMgaW52YWxpZCcpO1xufVxuXG5leHBvcnRzLmNvb3JkRWFjaCA9IGNvb3JkRWFjaDtcbmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcbmV4cG9ydHMucHJvcEVhY2ggPSBwcm9wRWFjaDtcbmV4cG9ydHMucHJvcFJlZHVjZSA9IHByb3BSZWR1Y2U7XG5leHBvcnRzLmZlYXR1cmVFYWNoID0gZmVhdHVyZUVhY2g7XG5leHBvcnRzLmZlYXR1cmVSZWR1Y2UgPSBmZWF0dXJlUmVkdWNlO1xuZXhwb3J0cy5jb29yZEFsbCA9IGNvb3JkQWxsO1xuZXhwb3J0cy5nZW9tRWFjaCA9IGdlb21FYWNoO1xuZXhwb3J0cy5nZW9tUmVkdWNlID0gZ2VvbVJlZHVjZTtcbmV4cG9ydHMuZmxhdHRlbkVhY2ggPSBmbGF0dGVuRWFjaDtcbmV4cG9ydHMuZmxhdHRlblJlZHVjZSA9IGZsYXR0ZW5SZWR1Y2U7XG5leHBvcnRzLnNlZ21lbnRFYWNoID0gc2VnbWVudEVhY2g7XG5leHBvcnRzLnNlZ21lbnRSZWR1Y2UgPSBzZWdtZW50UmVkdWNlO1xuZXhwb3J0cy5saW5lRWFjaCA9IGxpbmVFYWNoO1xuZXhwb3J0cy5saW5lUmVkdWNlID0gbGluZVJlZHVjZTtcbmV4cG9ydHMuZmluZFNlZ21lbnQgPSBmaW5kU2VnbWVudDtcbmV4cG9ydHMuZmluZFBvaW50ID0gZmluZFBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmVhcmluZ18xID0gcmVxdWlyZShcIkB0dXJmL2JlYXJpbmdcIik7XG52YXIgZGlzdGFuY2VfMSA9IHJlcXVpcmUoXCJAdHVyZi9kaXN0YW5jZVwiKTtcbnZhciBkZXN0aW5hdGlvbl8xID0gcmVxdWlyZShcIkB0dXJmL2Rlc3RpbmF0aW9uXCIpO1xudmFyIGxpbmVfaW50ZXJzZWN0XzEgPSByZXF1aXJlKFwiQHR1cmYvbGluZS1pbnRlcnNlY3RcIik7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIkB0dXJmL2hlbHBlcnNcIik7XG52YXIgaW52YXJpYW50XzEgPSByZXF1aXJlKFwiQHR1cmYvaW52YXJpYW50XCIpO1xuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGEge0BsaW5rIExpbmVTdHJpbmd9IGFuZCBjYWxjdWxhdGVzIHRoZSBjbG9zZXN0IFBvaW50IG9uIHRoZSAoTXVsdGkpTGluZVN0cmluZy5cbiAqXG4gKiBAbmFtZSBuZWFyZXN0UG9pbnRPbkxpbmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZz59IGxpbmVzIGxpbmVzIHRvIHNuYXAgdG9cbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxQb2ludD58bnVtYmVyW119IHB0IHBvaW50IHRvIHNuYXAgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudW5pdHM9J2tpbG9tZXRlcnMnXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gY2xvc2VzdCBwb2ludCBvbiB0aGUgYGxpbmVgIHRvIGBwb2ludGAuIFRoZSBwcm9wZXJ0aWVzIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhyZWUgdmFsdWVzOiBgaW5kZXhgOiBjbG9zZXN0IHBvaW50IHdhcyBmb3VuZCBvbiBudGggbGluZSBwYXJ0LCBgZGlzdGA6IGRpc3RhbmNlIGJldHdlZW4gcHQgYW5kIHRoZSBjbG9zZXN0IHBvaW50LCBgbG9jYXRpb25gOiBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSBiZXR3ZWVuIHN0YXJ0IGFuZCB0aGUgY2xvc2VzdCBwb2ludC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbXG4gKiAgICAgWy03Ny4wMzE2NjksIDM4Ljg3ODYwNV0sXG4gKiAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgWy03Ny4wMjU2NjEsIDM4Ljg4NTgyMV0sXG4gKiAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqIF0pO1xuICogdmFyIHB0ID0gdHVyZi5wb2ludChbLTc3LjAzNzA3NiwgMzguODg0MDE3XSk7XG4gKlxuICogdmFyIHNuYXBwZWQgPSB0dXJmLm5lYXJlc3RQb2ludE9uTGluZShsaW5lLCBwdCwge3VuaXRzOiAnbWlsZXMnfSk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIHB0LCBzbmFwcGVkXTtcbiAqIHNuYXBwZWQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnIzAwZic7XG4gKi9cbmZ1bmN0aW9uIG5lYXJlc3RQb2ludE9uTGluZShsaW5lcywgcHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjbG9zZXN0UHQgPSBoZWxwZXJzXzEucG9pbnQoW0luZmluaXR5LCBJbmZpbml0eV0sIHtcbiAgICAgICAgZGlzdDogSW5maW5pdHlcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gMC4wO1xuICAgIG1ldGFfMS5mbGF0dGVuRWFjaChsaW5lcywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGludmFyaWFudF8xLmdldENvb3JkcyhsaW5lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvL3N0YXJ0XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBoZWxwZXJzXzEucG9pbnQoY29vcmRzW2ldKTtcbiAgICAgICAgICAgIHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlXzEuZGVmYXVsdChwdCwgc3RhcnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy9zdG9wXG4gICAgICAgICAgICB2YXIgc3RvcF8xID0gaGVscGVyc18xLnBvaW50KGNvb3Jkc1tpICsgMV0pO1xuICAgICAgICAgICAgc3RvcF8xLnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlXzEuZGVmYXVsdChwdCwgc3RvcF8xLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHNlY3Rpb25MZW5ndGhcbiAgICAgICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoID0gZGlzdGFuY2VfMS5kZWZhdWx0KHN0YXJ0LCBzdG9wXzEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy9wZXJwZW5kaWN1bGFyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0RGlzdGFuY2UgPSBNYXRoLm1heChzdGFydC5wcm9wZXJ0aWVzLmRpc3QsIHN0b3BfMS5wcm9wZXJ0aWVzLmRpc3QpO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGJlYXJpbmdfMS5kZWZhdWx0KHN0YXJ0LCBzdG9wXzEpO1xuICAgICAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJQdDEgPSBkZXN0aW5hdGlvbl8xLmRlZmF1bHQocHQsIGhlaWdodERpc3RhbmNlLCBkaXJlY3Rpb24gKyA5MCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgcGVycGVuZGljdWxhclB0MiA9IGRlc3RpbmF0aW9uXzEuZGVmYXVsdChwdCwgaGVpZ2h0RGlzdGFuY2UsIGRpcmVjdGlvbiAtIDkwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBsaW5lX2ludGVyc2VjdF8xLmRlZmF1bHQoaGVscGVyc18xLmxpbmVTdHJpbmcoW3BlcnBlbmRpY3VsYXJQdDEuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBlcnBlbmRpY3VsYXJQdDIuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdKSwgaGVscGVyc18xLmxpbmVTdHJpbmcoW3N0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdG9wXzEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdKSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0UHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdC5mZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQgPSBpbnRlcnNlY3QuZmVhdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0ID0gZGlzdGFuY2VfMS5kZWZhdWx0KHB0LCBpbnRlcnNlY3RQdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5sb2NhdGlvbiA9IGxlbmd0aCArIGRpc3RhbmNlXzEuZGVmYXVsdChzdGFydCwgaW50ZXJzZWN0UHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMubG9jYXRpb24gPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcF8xLnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQgPSBzdG9wXzE7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMuaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5sb2NhdGlvbiA9IGxlbmd0aCArIHNlY3Rpb25MZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UHQgJiYgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0IDwgY2xvc2VzdFB0LnByb3BlcnRpZXMuZGlzdCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQdCA9IGludGVyc2VjdFB0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsZW5ndGhcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWN0aW9uTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQdDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG5lYXJlc3RQb2ludE9uTGluZTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmZmluZUh1bGxcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpXG5cbmZ1bmN0aW9uIGxpbmVhcmx5SW5kZXBlbmRlbnQocG9pbnRzLCBkKSB7XG4gIHZhciBuaHVsbCA9IG5ldyBBcnJheShkKzEpXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIG5odWxsW2ldID0gcG9pbnRzW2ldXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8PXBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGZvcih2YXIgaj1wb2ludHMubGVuZ3RoOyBqPD1kOyArK2opIHtcbiAgICAgIHZhciB4ID0gbmV3IEFycmF5KGQpXG4gICAgICBmb3IodmFyIGs9MDsgazxkOyArK2spIHtcbiAgICAgICAgeFtrXSA9IE1hdGgucG93KGorMS1pLCBrKVxuICAgICAgfVxuICAgICAgbmh1bGxbal0gPSB4XG4gICAgfVxuICAgIHZhciBvID0gb3JpZW50LmFwcGx5KHZvaWQgMCwgbmh1bGwpXG4gICAgaWYobykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFmZmluZUh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgaWYobiA9PT0gMSkge1xuICAgIHJldHVybiBbMF1cbiAgfVxuICB2YXIgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgdmFyIGZyYW1lID0gWyBwb2ludHNbMF0gXVxuICB2YXIgaW5kZXggPSBbIDAgXVxuICBmb3IodmFyIGk9MTsgaTxuOyArK2kpIHtcbiAgICBmcmFtZS5wdXNoKHBvaW50c1tpXSlcbiAgICBpZighbGluZWFybHlJbmRlcGVuZGVudChmcmFtZSwgZCkpIHtcbiAgICAgIGZyYW1lLnBvcCgpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpbmRleC5wdXNoKGkpXG4gICAgaWYoaW5kZXgubGVuZ3RoID09PSBkKzEpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn0iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb252ZXhIdWxsMWQgPSByZXF1aXJlKCcuL2xpYi9jaDFkJylcbnZhciBjb252ZXhIdWxsMmQgPSByZXF1aXJlKCcuL2xpYi9jaDJkJylcbnZhciBjb252ZXhIdWxsbmQgPSByZXF1aXJlKCcuL2xpYi9jaG5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsXG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0gZWxzZSBpZihuID09PSAxKSB7XG4gICAgcmV0dXJuIFtbMF1dXG4gIH1cbiAgdmFyIGQgPSBwb2ludHNbMF0ubGVuZ3RoXG4gIGlmKGQgPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfSBlbHNlIGlmKGQgPT09IDEpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDFkKHBvaW50cylcbiAgfSBlbHNlIGlmKGQgPT09IDIpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDJkKHBvaW50cylcbiAgfVxuICByZXR1cm4gY29udmV4SHVsbG5kKHBvaW50cywgZClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwxZFxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMWQocG9pbnRzKSB7XG4gIHZhciBsbyA9IDBcbiAgdmFyIGhpID0gMFxuICBmb3IodmFyIGk9MTsgaTxwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihwb2ludHNbaV1bMF0gPCBwb2ludHNbbG9dWzBdKSB7XG4gICAgICBsbyA9IGlcbiAgICB9XG4gICAgaWYocG9pbnRzW2ldWzBdID4gcG9pbnRzW2hpXVswXSkge1xuICAgICAgaGkgPSBpXG4gICAgfVxuICB9XG4gIGlmKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gW1tsb10sIFtoaV1dXG4gIH0gZWxzZSBpZihsbyA+IGhpKSB7XG4gICAgcmV0dXJuIFtbaGldLCBbbG9dXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbW2xvXV1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwyRFxuXG52YXIgbW9ub3RvbmVIdWxsID0gcmVxdWlyZSgnbW9ub3RvbmUtY29udmV4LWh1bGwtMmQnKVxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMkQocG9pbnRzKSB7XG4gIHZhciBodWxsID0gbW9ub3RvbmVIdWxsKHBvaW50cylcbiAgdmFyIGggPSBodWxsLmxlbmd0aFxuICBpZihoIDw9IDIpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgZWRnZXMgPSBuZXcgQXJyYXkoaClcbiAgdmFyIGEgPSBodWxsW2gtMV1cbiAgZm9yKHZhciBpPTA7IGk8aDsgKytpKSB7XG4gICAgdmFyIGIgPSBodWxsW2ldXG4gICAgZWRnZXNbaV0gPSBbYSxiXVxuICAgIGEgPSBiXG4gIH1cbiAgcmV0dXJuIGVkZ2VzXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsbkRcblxudmFyIGljaCA9IHJlcXVpcmUoJ2luY3JlbWVudGFsLWNvbnZleC1odWxsJylcbnZhciBhZmYgPSByZXF1aXJlKCdhZmZpbmUtaHVsbCcpXG5cbmZ1bmN0aW9uIHBlcm11dGUocG9pbnRzLCBmcm9udCkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIG5wb2ludHMgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8ZnJvbnQubGVuZ3RoOyArK2kpIHtcbiAgICBucG9pbnRzW2ldID0gcG9pbnRzW2Zyb250W2ldXVxuICB9XG4gIHZhciBwdHIgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoZnJvbnQuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgIG5wb2ludHNbcHRyKytdID0gcG9pbnRzW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBucG9pbnRzXG59XG5cbmZ1bmN0aW9uIGludlBlcm11dGUoY2VsbHMsIGZyb250KSB7XG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgbmYgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgeCA9IGNbal1cbiAgICAgIGlmKHggPCBuZikge1xuICAgICAgICBjW2pdID0gZnJvbnRbeF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4IC0gbmZcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8bmY7ICsraykge1xuICAgICAgICAgIGlmKHggPj0gZnJvbnRba10pIHtcbiAgICAgICAgICAgIHggKz0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjW2pdID0geFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2VsbHNcbn1cblxuZnVuY3Rpb24gY29udmV4SHVsbG5EKHBvaW50cywgZCkge1xuICB0cnkge1xuICAgIHJldHVybiBpY2gocG9pbnRzLCB0cnVlKVxuICB9IGNhdGNoKGUpIHtcbiAgICAvL0lmIHBvaW50IHNldCBpcyBkZWdlbmVyYXRlLCB0cnkgdG8gZmluZCBhIGJhc2lzIGFuZCByZXJ1biBpdFxuICAgIHZhciBhaCA9IGFmZihwb2ludHMpXG4gICAgaWYoYWgubGVuZ3RoIDw9IGQpIHtcbiAgICAgIC8vTm8gYmFzaXMsIG5vIHRyeVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHZhciBucG9pbnRzID0gcGVybXV0ZShwb2ludHMsIGFoKVxuICAgIHZhciBuaHVsbCAgID0gaWNoKG5wb2ludHMsIHRydWUpXG4gICAgcmV0dXJuIGludlBlcm11dGUobmh1bGwsIGFoKVxuICB9XG59IiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKG91dGVyTm9kZSkge1xuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xuICAgICAgICBmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcbiAgICB9XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpICogaW52U2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYik7XG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgaWYgKChlcXVhbHMocDEsIHExKSAmJiBlcXVhbHMocDIsIHEyKSkgfHxcbiAgICAgICAgKGVxdWFscyhwMSwgcTIpICYmIGVxdWFscyhwMiwgcTEpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGFyZWEocDEsIHExLCBwMikgPiAwICE9PSBhcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxuICAgICAgICAgICBhcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gYXJlYShwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gbnVsbDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgdmFyIGFyZWEgPSAwLCBpO1xuICAgIHN3aXRjaCAoXy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXMpO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhICs9IHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgXy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBnZW9tZXRyeShfLmdlb21ldHJpZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb2x5Z29uQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgaWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1swXSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFwcHJveGltYXRlIGFyZWEgb2YgdGhlIHBvbHlnb24gd2VyZSBpdCBwcm9qZWN0ZWQgb250b1xuICogICAgIHRoZSBlYXJ0aC4gIE5vdGUgdGhhdCB0aGlzIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSBpZiByaW5nIGlzIG9yaWVudGVkXG4gKiAgICAgY2xvY2t3aXNlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqXG4gKiBSZWZlcmVuY2U6XG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqICAgICBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiAgICAgTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDcgaHR0cDovL3Rycy1uZXcuanBsLm5hc2EuZ292L2RzcGFjZS9oYW5kbGUvMjAxNC80MDQwOVxuICpcbiAqIFJldHVybnM6XG4gKiB7ZmxvYXR9IFRoZSBhcHByb3hpbWF0ZSBzaWduZWQgZ2VvZGVzaWMgYXJlYSBvZiB0aGUgcG9seWdvbiBpbiBzcXVhcmVcbiAqICAgICBtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcmluZ0FyZWEoY29vcmRzKSB7XG4gICAgdmFyIHAxLCBwMiwgcDMsIGxvd2VySW5kZXgsIG1pZGRsZUluZGV4LCB1cHBlckluZGV4LFxuICAgIGFyZWEgPSAwLFxuICAgIGNvb3Jkc0xlbmd0aCA9IGNvb3Jkcy5sZW5ndGg7XG5cbiAgICBpZiAoY29vcmRzTGVuZ3RoID4gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAyKSB7Ly8gaSA9IE4tMlxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gY29vcmRzTGVuZ3RoIC0xO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAxKSB7Ly8gaSA9IE4tMVxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGkgPSAwIHRvIE4tM1xuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gaSsxO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBpKzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tsb3dlckluZGV4XTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW21pZGRsZUluZGV4XTtcbiAgICAgICAgICAgIHAzID0gY29vcmRzW3VwcGVySW5kZXhdO1xuICAgICAgICAgICAgYXJlYSArPSAoIHJhZChwM1swXSkgLSByYWQocDFbMF0pICkgKiBNYXRoLnNpbiggcmFkKHAyWzFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhID0gYXJlYSAqIHdnczg0LlJBRElVUyAqIHdnczg0LlJBRElVUyAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIHJhZChfKSB7XG4gICAgcmV0dXJuIF8gKiBNYXRoLlBJIC8gMTgwO1xufSIsIi8vaW5kZXguanNcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBFcXVhbGl0eSA9IGZ1bmN0aW9uKG9wdCkge1xuICB0aGlzLnByZWNpc2lvbiA9IG9wdCAmJiBvcHQucHJlY2lzaW9uID8gb3B0LnByZWNpc2lvbiA6IDE3O1xuICB0aGlzLmRpcmVjdGlvbiA9IG9wdCAmJiBvcHQuZGlyZWN0aW9uID8gb3B0LmRpcmVjdGlvbiA6IGZhbHNlO1xuICB0aGlzLnBzZXVkb05vZGUgPSBvcHQgJiYgb3B0LnBzZXVkb05vZGUgPyBvcHQucHNldWRvTm9kZSA6IGZhbHNlO1xuICB0aGlzLm9iamVjdENvbXBhcmF0b3IgPSBvcHQgJiYgb3B0Lm9iamVjdENvbXBhcmF0b3IgPyBvcHQub2JqZWN0Q29tcGFyYXRvciA6IG9iamVjdENvbXBhcmF0b3I7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChnMS50eXBlICE9PSBnMi50eXBlIHx8ICFzYW1lTGVuZ3RoKGcxLGcyKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaChnMS50eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlQ29vcmQoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzKTtcbiAgICBicmVhaztcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZUxpbmUoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzLDAsZmFsc2UpO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9seWdvbihnMSxnMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVGZWF0dXJlKGcxLCBnMik7XG4gIGRlZmF1bHQ6XG4gICAgaWYgKGcxLnR5cGUuaW5kZXhPZignTXVsdGknKSA9PT0gMCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgdmFyIGcxcyA9IGV4cGxvZGUoZzEpO1xuICAgICAgdmFyIGcycyA9IGV4cGxvZGUoZzIpO1xuICAgICAgcmV0dXJuIGcxcy5ldmVyeShmdW5jdGlvbihnMXBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbihnMnBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wYXJlKGcxcGFydCxnMnBhcnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sZzJzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZXhwbG9kZShnKSB7XG4gIHJldHVybiBnLmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGcudHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwYXJ0fVxuICB9KTtcbn1cbi8vY29tcGFyZSBsZW5ndGggb2YgY29vcmRpbmF0ZXMvYXJyYXlcbmZ1bmN0aW9uIHNhbWVMZW5ndGgoZzEsZzIpIHtcbiAgIHJldHVybiBnMS5oYXNPd25Qcm9wZXJ0eSgnY29vcmRpbmF0ZXMnKSA/XG4gICAgZzEuY29vcmRpbmF0ZXMubGVuZ3RoID09PSBnMi5jb29yZGluYXRlcy5sZW5ndGhcbiAgICA6IGcxLmxlbmd0aCA9PT0gZzIubGVuZ3RoO1xufVxuXG4vLyBjb21wYXJlIHRoZSB0d28gY29vcmRpbmF0ZXMgW3gseV1cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlQ29vcmQgPSBmdW5jdGlvbihjMSxjMikge1xuICBpZiAoYzEubGVuZ3RoICE9PSBjMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpPTA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjMVtpXS50b0ZpeGVkKHRoaXMucHJlY2lzaW9uKSAhPT0gYzJbaV0udG9GaXhlZCh0aGlzLnByZWNpc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUxpbmUgPSBmdW5jdGlvbihwYXRoMSxwYXRoMixpbmQsaXNQb2x5KSB7XG4gIGlmICghc2FtZUxlbmd0aChwYXRoMSxwYXRoMikpIHJldHVybiBmYWxzZTtcbiAgdmFyIHAxID0gdGhpcy5wc2V1ZG9Ob2RlID8gcGF0aDEgOiB0aGlzLnJlbW92ZVBzZXVkbyhwYXRoMSk7XG4gIHZhciBwMiA9IHRoaXMucHNldWRvTm9kZSA/IHBhdGgyIDogdGhpcy5yZW1vdmVQc2V1ZG8ocGF0aDIpO1xuICBpZiAoaXNQb2x5ICYmICF0aGlzLmNvbXBhcmVDb29yZChwMVswXSxwMlswXSkpIHtcbiAgICAvLyBmaXggc3RhcnQgaW5kZXggb2YgYm90aCB0byBzYW1lIHBvaW50XG4gICAgcDIgPSB0aGlzLmZpeFN0YXJ0SW5kZXgocDIscDEpO1xuICAgIGlmKCFwMikgcmV0dXJuO1xuICB9XG4gIC8vIGZvciBsaW5lc3RyaW5nIGluZCA9MCBhbmQgZm9yIHBvbHlnb24gaW5kID0xXG4gIHZhciBzYW1lRGlyZWN0aW9uID0gdGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltpbmRdKTtcbiAgaWYgKHRoaXMuZGlyZWN0aW9uIHx8IHNhbWVEaXJlY3Rpb25cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVBhdGgocDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltwMi5sZW5ndGggLSAoMStpbmQpXSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQYXRoKHAxLnNsaWNlKCkucmV2ZXJzZSgpLCBwMik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5maXhTdGFydEluZGV4ID0gZnVuY3Rpb24oc291cmNlUGF0aCx0YXJnZXRQYXRoKSB7XG4gIC8vbWFrZSBzb3VyY2VQYXRoIGZpcnN0IHBvaW50IHNhbWUgYXMgb2YgdGFyZ2V0UGF0aFxuICB2YXIgY29ycmVjdFBhdGgsaW5kID0gLTE7XG4gIGZvciAodmFyIGk9MDsgaTwgc291cmNlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGlmKHRoaXMuY29tcGFyZUNvb3JkKHNvdXJjZVBhdGhbaV0sdGFyZ2V0UGF0aFswXSkpIHtcbiAgICAgIGluZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGluZCA+PSAwKSB7XG4gICAgY29ycmVjdFBhdGggPSBbXS5jb25jYXQoXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKGluZCxzb3VyY2VQYXRoLmxlbmd0aCksXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKDEsaW5kKzEpKTtcbiAgfVxuICByZXR1cm4gY29ycmVjdFBhdGg7XG59O1xuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmVQYXRoID0gZnVuY3Rpb24gKHAxLHAyKSB7XG4gIHZhciBjb250ID0gdGhpcztcbiAgcmV0dXJuIHAxLmV2ZXJ5KGZ1bmN0aW9uKGMsaSkge1xuICAgIHJldHVybiBjb250LmNvbXBhcmVDb29yZChjLHRoaXNbaV0pO1xuICB9LHAyKTtcbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlUG9seWdvbiA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmICh0aGlzLmNvbXBhcmVMaW5lKGcxLmNvb3JkaW5hdGVzWzBdLGcyLmNvb3JkaW5hdGVzWzBdLDEsdHJ1ZSkpIHtcbiAgICB2YXIgaG9sZXMxID0gZzEuY29vcmRpbmF0ZXMuc2xpY2UoMSxnMS5jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHZhciBob2xlczIgPSBnMi5jb29yZGluYXRlcy5zbGljZSgxLGcyLmNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdmFyIGNvbnQgPSB0aGlzO1xuICAgIHJldHVybiBob2xlczEuZXZlcnkoZnVuY3Rpb24oaDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oaDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQuY29tcGFyZUxpbmUoaDEsaDIsMSx0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0saG9sZXMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlRmVhdHVyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChcbiAgICBnMS5pZCAhPT0gZzIuaWQgfHxcbiAgICAhdGhpcy5vYmplY3RDb21wYXJhdG9yKGcxLnByb3BlcnRpZXMsIGcyLnByb3BlcnRpZXMpIHx8XG4gICAgIXRoaXMuY29tcGFyZUJCb3goZzEsZzIpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcy5jb21wYXJlKGcxLmdlb21ldHJ5LCBnMi5nZW9tZXRyeSk7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUJCb3ggPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAoXG4gICAgKCFnMS5iYm94ICYmICFnMi5iYm94KSB8fCBcbiAgICAoXG4gICAgICBnMS5iYm94ICYmIGcyLmJib3ggJiZcbiAgICAgIHRoaXMuY29tcGFyZUNvb3JkKGcxLmJib3gsIGcyLmJib3gpXG4gICAgKVxuICApICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5yZW1vdmVQc2V1ZG8gPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vVE9ETyB0byBiZSBpbXBsZW1lbnRcbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RDb21wYXJhdG9yKG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChvYmoxLCBvYmoyLCB7c3RyaWN0OiB0cnVlfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxpdHk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxudmFyIHR5cGVzID0ge1xuICAgIFBvaW50OiAnZ2VvbWV0cnknLFxuICAgIE11bHRpUG9pbnQ6ICdnZW9tZXRyeScsXG4gICAgTGluZVN0cmluZzogJ2dlb21ldHJ5JyxcbiAgICBNdWx0aUxpbmVTdHJpbmc6ICdnZW9tZXRyeScsXG4gICAgUG9seWdvbjogJ2dlb21ldHJ5JyxcbiAgICBNdWx0aVBvbHlnb246ICdnZW9tZXRyeScsXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiAnZ2VvbWV0cnknLFxuICAgIEZlYXR1cmU6ICdmZWF0dXJlJyxcbiAgICBGZWF0dXJlQ29sbGVjdGlvbjogJ2ZlYXR1cmVjb2xsZWN0aW9uJ1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBHZW9KU09OIGZlYXR1cmUgaW50byBhIEZlYXR1cmVDb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnaiBnZW9qc29uIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3R9IG5vcm1hbGl6ZWQgZ2VvanNvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShnaikge1xuICAgIGlmICghZ2ogfHwgIWdqLnR5cGUpIHJldHVybiBudWxsO1xuICAgIHZhciB0eXBlID0gdHlwZXNbZ2oudHlwZV07XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZ2VvbWV0cnknKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZmVhdHVyZXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnalxuICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmZWF0dXJlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbZ2pdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZmVhdHVyZWNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbCAucG9pbnQoKSBvciAucG9seWdvbigpIGluc3RlYWQnKTtcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGJib3gpIHtcbiAgICBpZiAoYmJveCkgcmV0dXJuIGNvb3JkSW5CQkJPWChiYm94KTtcbiAgICBlbHNlIHJldHVybiBbbG9uKCksIGxhdCgpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbihjb3VudCwgYmJveCkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShiYm94ID8gcG9pbnQocG9zaXRpb24oYmJveCkpIDogcG9pbnQoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbihmZWF0dXJlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gZnVuY3Rpb24oY291bnQsIG51bV92ZXJ0aWNlcywgbWF4X3JhZGlhbF9sZW5ndGgsIGJib3gpIHtcbiAgICBpZiAodHlwZW9mIG51bV92ZXJ0aWNlcyAhPT0gJ251bWJlcicpIG51bV92ZXJ0aWNlcyA9IDEwO1xuICAgIGlmICh0eXBlb2YgbWF4X3JhZGlhbF9sZW5ndGggIT09ICdudW1iZXInKSBtYXhfcmFkaWFsX2xlbmd0aCA9IDEwO1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICAgICAgY2lyY2xlX29mZnNldHMgPSBBcnJheS5hcHBseShudWxsLFxuICAgICAgICAgICAgICAgIG5ldyBBcnJheShudW1fdmVydGljZXMgKyAxKSkubWFwKE1hdGgucmFuZG9tKTtcblxuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHN1bU9mZnNldHMpO1xuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHNjYWxlT2Zmc2V0cyk7XG4gICAgICAgIHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aCAtIDFdID0gdmVydGljZXNbMF07IC8vIGNsb3NlIHRoZSByaW5nXG5cbiAgICAgICAgLy8gY2VudGVyIHRoZSBwb2x5Z29uIGFyb3VuZCBzb21ldGhpbmdcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAodmVydGV4VG9Db29yZGluYXRlKHBvc2l0aW9uKGJib3gpKSk7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShwb2x5Z29uKFt2ZXJ0aWNlc10pKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VtT2Zmc2V0cyhjdXIsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgYXJyW2luZGV4XSA9IChpbmRleCA+IDApID8gY3VyICsgYXJyW2luZGV4IC0gMV0gOiBjdXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVPZmZzZXRzKGN1ciwgaW5kZXgpIHtcbiAgICAgICAgY3VyID0gY3VyICogMiAqIE1hdGguUEkgLyBjaXJjbGVfb2Zmc2V0c1tjaXJjbGVfb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJhZGlhbF9zY2FsZXIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgIHJhZGlhbF9zY2FsZXIgKiBtYXhfcmFkaWFsX2xlbmd0aCAqIE1hdGguc2luKGN1ciksXG4gICAgICAgICAgICByYWRpYWxfc2NhbGVyICogbWF4X3JhZGlhbF9sZW5ndGggKiBNYXRoLmNvcyhjdXIpXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn07XG5cblxuZnVuY3Rpb24gdmVydGV4VG9Db29yZGluYXRlKGh1Yikge1xuICAgIHJldHVybiBmdW5jdGlvbihjdXIsIGluZGV4KSB7IHJldHVybiBbY3VyWzBdICsgaHViWzBdLCBjdXJbMV0gKyBodWJbMV1dOyB9O1xufVxuXG5mdW5jdGlvbiBybmQoKSB7IHJldHVybiBNYXRoLnJhbmRvbSgpIC0gMC41OyB9XG5mdW5jdGlvbiBsb24oKSB7IHJldHVybiBybmQoKSAqIDM2MDsgfVxuZnVuY3Rpb24gbGF0KCkgeyByZXR1cm4gcm5kKCkgKiAxODA7IH1cblxuZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfHwgW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb29yZEluQkJCT1goYmJveCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIChNYXRoLnJhbmRvbSgpICogKGJib3hbMl0gLSBiYm94WzBdKSkgKyBiYm94WzBdLFxuICAgICAgICAoTWF0aC5yYW5kb20oKSAqIChiYm94WzNdIC0gYmJveFsxXSkpICsgYmJveFsxXV07XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5CQkJPWCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlKGdlb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb24oZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBmXG4gICAgfTtcbn1cbiIsInZhciByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpO1xudmFyIHR1cmZCQm94ID0gcmVxdWlyZSgnQHR1cmYvYmJveCcpLmRlZmF1bHQ7XG52YXIgZmVhdHVyZUVhY2ggPSBtZXRhLmZlYXR1cmVFYWNoO1xudmFyIGNvb3JkRWFjaCA9IG1ldGEuY29vcmRFYWNoO1xudmFyIHBvbHlnb24gPSBoZWxwZXJzLnBvbHlnb247XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIEdlb0pTT04gaW1wbGVtZW50YXRpb24gb2YgW1JCdXNoXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyYnVzaCkgc3BhdGlhbCBpbmRleC5cbiAqXG4gKiBAbmFtZSByYnVzaFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhFbnRyaWVzPTldIGRlZmluZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gYSB0cmVlIG5vZGUuIDkgKHVzZWQgYnkgZGVmYXVsdCkgaXMgYVxuICogcmVhc29uYWJsZSBjaG9pY2UgZm9yIG1vc3QgYXBwbGljYXRpb25zLiBIaWdoZXIgdmFsdWUgbWVhbnMgZmFzdGVyIGluc2VydGlvbiBhbmQgc2xvd2VyIHNlYXJjaCwgYW5kIHZpY2UgdmVyc2EuXG4gKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvanNvblJidXNoID0gcmVxdWlyZSgnZ2VvanNvbi1yYnVzaCcpLmRlZmF1bHQ7XG4gKiB2YXIgdHJlZSA9IGdlb2pzb25SYnVzaCgpO1xuICovXG5mdW5jdGlvbiBnZW9qc29uUmJ1c2gobWF4RW50cmllcykge1xuICAgIHZhciB0cmVlID0gcmJ1c2gobWF4RW50cmllcyk7XG4gICAgLyoqXG4gICAgICogW2luc2VydF0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjZGF0YS1mb3JtYXQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgaW5zZXJ0IHNpbmdsZSBHZW9KU09OIEZlYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSk7XG4gICAgICogdHJlZS5pbnNlcnQocG9seSlcbiAgICAgKi9cbiAgICB0cmVlLmluc2VydCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZlYXR1cmUnKTtcbiAgICAgICAgZmVhdHVyZS5iYm94ID0gZmVhdHVyZS5iYm94ID8gZmVhdHVyZS5iYm94IDogdHVyZkJCb3goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgZmVhdHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtsb2FkXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNidWxrLWluc2VydGluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxBcnJheTxGZWF0dXJlPn0gZmVhdHVyZXMgbG9hZCBlbnRpcmUgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHlzID0gdHVyZi5wb2x5Z29ucyhbXG4gICAgICogICAgIFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSxcbiAgICAgKiAgICAgW1tbLTkzLCAzMl0sIFstODMsIDMyXSwgWy04MywgMzldLCBbLTkzLCAzOV0sIFstOTMsIDMyXV1dXG4gICAgICogXSk7XG4gICAgICogdHJlZS5sb2FkKHBvbHlzKTtcbiAgICAgKi9cbiAgICB0cmVlLmxvYWQgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIGxvYWQgPSBbXTtcbiAgICAgICAgLy8gTG9hZCBhbiBBcnJheSBvZiBGZWF0dXJlc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmZWF0dXJlcycpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuYmJveCA9IGZlYXR1cmUuYmJveCA/IGZlYXR1cmUuYmJveCA6IHR1cmZCQm94KGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGxvYWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTG9hZCBhIEZlYXR1cmVDb2xsZWN0aW9uXG4gICAgICAgICAgICBmZWF0dXJlRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmZWF0dXJlcycpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuYmJveCA9IGZlYXR1cmUuYmJveCA/IGZlYXR1cmUuYmJveCA6IHR1cmZCQm94KGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGxvYWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIGxvYWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbcmVtb3ZlXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyZW1vdmluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIHJlbW92ZSBzaW5nbGUgR2VvSlNPTiBGZWF0dXJlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxzIFBhc3MgYSBjdXN0b20gZXF1YWxzIGZ1bmN0aW9uIHRvIGNvbXBhcmUgYnkgdmFsdWUgZm9yIHJlbW92YWwuXG4gICAgICogQHJldHVybnMge1JCdXNofSBHZW9KU09OIFJCdXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IHR1cmYucG9seWdvbihbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV0pO1xuICAgICAqXG4gICAgICogdHJlZS5yZW1vdmUocG9seSk7XG4gICAgICovXG4gICAgdHJlZS5yZW1vdmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZXF1YWxzKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZlYXR1cmUnKTtcbiAgICAgICAgZmVhdHVyZS5iYm94ID0gZmVhdHVyZS5iYm94ID8gZmVhdHVyZS5iYm94IDogdHVyZkJCb3goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgZmVhdHVyZSwgZXF1YWxzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2NsZWFyXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyZW1vdmluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1JCdXNofSBHZW9KU09OIFJidXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cmVlLmNsZWFyKClcbiAgICAgKi9cbiAgICB0cmVlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtzZWFyY2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI3NlYXJjaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QkJveHxGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIHNlYXJjaCB3aXRoIEdlb0pTT05cbiAgICAgKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGFsbCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gR2VvSlNPTi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSk7XG4gICAgICpcbiAgICAgKiB0cmVlLnNlYXJjaChwb2x5KTtcbiAgICAgKi9cbiAgICB0cmVlLnNlYXJjaCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHJidXNoLnByb3RvdHlwZS5zZWFyY2guY2FsbCh0aGlzLCB0aGlzLnRvQkJveChnZW9qc29uKSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtjb2xsaWRlc10oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjY29sbGlzaW9ucylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QkJveHxGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGNvbGxpZGVzIHdpdGggR2VvSlNPTlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgaXRlbXMgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBHZW9KU09OLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IHR1cmYucG9seWdvbihbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV0pO1xuICAgICAqXG4gICAgICogdHJlZS5jb2xsaWRlcyhwb2x5KTtcbiAgICAgKi9cbiAgICB0cmVlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGdlb2pzb24pIHtcbiAgICAgICAgcmV0dXJuIHJidXNoLnByb3RvdHlwZS5jb2xsaWRlcy5jYWxsKHRoaXMsIHRoaXMudG9CQm94KGdlb2pzb24pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2FsbF0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjc2VhcmNoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhbGwgdGhlIGZlYXR1cmVzIGluIFJCdXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cmVlLmFsbCgpXG4gICAgICovXG4gICAgdHJlZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHJidXNoLnByb3RvdHlwZS5hbGwuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW3RvSlNPTl0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjZXhwb3J0LWFuZC1pbXBvcnQpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7YW55fSBleHBvcnQgZGF0YSBhcyBKU09OIG9iamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGV4cG9ydGVkID0gdHJlZS50b0pTT04oKVxuICAgICAqL1xuICAgIHRyZWUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbZnJvbUpTT05dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI2V4cG9ydC1hbmQtaW1wb3J0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGpzb24gaW1wb3J0IHByZXZpb3VzbHkgZXhwb3J0ZWQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGV4cG9ydGVkID0ge1xuICAgICAqICAgXCJjaGlsZHJlblwiOiBbXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gICAgICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICAgICAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTEwLCA1MF1cbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAgICAgKiAgICAgICBcImJib3hcIjogWzExMCwgNTAsIDExMCwgNTBdXG4gICAgICogICAgIH1cbiAgICAgKiAgIF0sXG4gICAgICogICBcImhlaWdodFwiOiAxLFxuICAgICAqICAgXCJsZWFmXCI6IHRydWUsXG4gICAgICogICBcIm1pblhcIjogMTEwLFxuICAgICAqICAgXCJtaW5ZXCI6IDUwLFxuICAgICAqICAgXCJtYXhYXCI6IDExMCxcbiAgICAgKiAgIFwibWF4WVwiOiA1MFxuICAgICAqIH1cbiAgICAgKiB0cmVlLmZyb21KU09OKGV4cG9ydGVkKVxuICAgICAqL1xuICAgIHRyZWUuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmZyb21KU09OLmNhbGwodGhpcywganNvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIEdlb0pTT04gdG8ge21pblgsIG1pblksIG1heFgsIG1heFl9IHNjaGVtYVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0JCb3h8RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBmZWF0dXJlKHMpIHRvIHJldHJpZXZlIEJCb3ggZnJvbVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbnZlcnRlZCB0byB7bWluWCwgbWluWSwgbWF4WCwgbWF4WX1cbiAgICAgKi9cbiAgICB0cmVlLnRvQkJveCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBpZiAoZ2VvanNvbi5iYm94KSBiYm94ID0gZ2VvanNvbi5iYm94O1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pICYmIGdlb2pzb24ubGVuZ3RoID09PSA0KSBiYm94ID0gZ2VvanNvbjtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShnZW9qc29uKSAmJiBnZW9qc29uLmxlbmd0aCA9PT0gNikgYmJveCA9IFtnZW9qc29uWzBdLCBnZW9qc29uWzFdLCBnZW9qc29uWzNdLCBnZW9qc29uWzRdXTtcbiAgICAgICAgZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIGJib3ggPSB0dXJmQkJveChnZW9qc29uKTtcbiAgICAgICAgZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSBiYm94ID0gdHVyZkJCb3goZ2VvanNvbik7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdlb2pzb24nKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBiYm94WzBdLFxuICAgICAgICAgICAgbWluWTogYmJveFsxXSxcbiAgICAgICAgICAgIG1heFg6IGJib3hbMl0sXG4gICAgICAgICAgICBtYXhZOiBiYm94WzNdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29uUmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2VvanNvblJidXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy9IaWdoIGxldmVsIGlkZWE6XG4vLyAxLiBVc2UgQ2xhcmtzb24ncyBpbmNyZW1lbnRhbCBjb25zdHJ1Y3Rpb24gdG8gZmluZCBjb252ZXggaHVsbFxuLy8gMi4gUG9pbnQgbG9jYXRpb24gaW4gdHJpYW5ndWxhdGlvbiBieSBqdW1wIGFuZCB3YWxrXG5cbm1vZHVsZS5leHBvcnRzID0gaW5jcmVtZW50YWxDb252ZXhIdWxsXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgY29tcGFyZUNlbGwgPSByZXF1aXJlKFwic2ltcGxpY2lhbC1jb21wbGV4XCIpLmNvbXBhcmVDZWxsc1xuXG5mdW5jdGlvbiBjb21wYXJlSW50KGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiXG59XG5cbmZ1bmN0aW9uIFNpbXBsZXgodmVydGljZXMsIGFkamFjZW50LCBib3VuZGFyeSkge1xuICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXNcbiAgdGhpcy5hZGphY2VudCA9IGFkamFjZW50XG4gIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeVxuICB0aGlzLmxhc3RWaXNpdGVkID0gLTFcbn1cblxuU2ltcGxleC5wcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMudmVydGljZXNbMF1cbiAgdGhpcy52ZXJ0aWNlc1swXSA9IHRoaXMudmVydGljZXNbMV1cbiAgdGhpcy52ZXJ0aWNlc1sxXSA9IHRcbiAgdmFyIHUgPSB0aGlzLmFkamFjZW50WzBdXG4gIHRoaXMuYWRqYWNlbnRbMF0gPSB0aGlzLmFkamFjZW50WzFdXG4gIHRoaXMuYWRqYWNlbnRbMV0gPSB1XG59XG5cbmZ1bmN0aW9uIEdsdWVGYWNldCh2ZXJ0aWNlcywgY2VsbCwgaW5kZXgpIHtcbiAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzXG4gIHRoaXMuY2VsbCA9IGNlbGxcbiAgdGhpcy5pbmRleCA9IGluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVHbHVlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVDZWxsKGEudmVydGljZXMsIGIudmVydGljZXMpXG59XG5cbmZ1bmN0aW9uIGJha2VPcmllbnQoZCkge1xuICB2YXIgY29kZSA9IFtcImZ1bmN0aW9uIG9yaWVudCgpe3ZhciB0dXBsZT10aGlzLnR1cGxlO3JldHVybiB0ZXN0KFwiXVxuICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGNvZGUucHVzaChcIixcIilcbiAgICB9XG4gICAgY29kZS5wdXNoKFwidHVwbGVbXCIsIGksIFwiXVwiKVxuICB9XG4gIGNvZGUucHVzaChcIil9cmV0dXJuIG9yaWVudFwiKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcInRlc3RcIiwgY29kZS5qb2luKFwiXCIpKVxuICB2YXIgdGVzdCA9IG9yaWVudFtkKzFdXG4gIGlmKCF0ZXN0KSB7XG4gICAgdGVzdCA9IG9yaWVudFxuICB9XG4gIHJldHVybiBwcm9jKHRlc3QpXG59XG5cbnZhciBCQUtFRCA9IFtdXG5cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRpb24oZGltZW5zaW9uLCB2ZXJ0aWNlcywgc2ltcGxpY2VzKSB7XG4gIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlc1xuICB0aGlzLnNpbXBsaWNlcyA9IHNpbXBsaWNlc1xuICB0aGlzLmludGVyaW9yID0gc2ltcGxpY2VzLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuICFjLmJvdW5kYXJ5XG4gIH0pXG5cbiAgdGhpcy50dXBsZSA9IG5ldyBBcnJheShkaW1lbnNpb24rMSlcbiAgZm9yKHZhciBpPTA7IGk8PWRpbWVuc2lvbjsgKytpKSB7XG4gICAgdGhpcy50dXBsZVtpXSA9IHRoaXMudmVydGljZXNbaV1cbiAgfVxuXG4gIHZhciBvID0gQkFLRURbZGltZW5zaW9uXVxuICBpZighbykge1xuICAgIG8gPSBCQUtFRFtkaW1lbnNpb25dID0gYmFrZU9yaWVudChkaW1lbnNpb24pXG4gIH1cbiAgdGhpcy5vcmllbnQgPSBvXG59XG5cbnZhciBwcm90byA9IFRyaWFuZ3VsYXRpb24ucHJvdG90eXBlXG5cbi8vRGVnZW5lcmF0ZSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIG9uIGJvdW5kYXJ5LCBidXQgY29wbGFuYXIgdG8gZmFjZVxucHJvdG8uaGFuZGxlQm91bmRhcnlEZWdlbmVyYWN5ID0gZnVuY3Rpb24oY2VsbCwgcG9pbnQpIHtcbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMVxuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG4gIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXNcblxuICAvL0R1bWIgc29sdXRpb246IEp1c3QgZG8gZGZzIGZyb20gYm91bmRhcnkgY2VsbCB1bnRpbCB3ZSBmaW5kIGFueSBwZWFrLCBvciB0ZXJtaW5hdGVcbiAgdmFyIHRvVmlzaXQgPSBbIGNlbGwgXVxuICBjZWxsLmxhc3RWaXNpdGVkID0gLW5cbiAgd2hpbGUodG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgY2VsbCA9IHRvVmlzaXQucG9wKClcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKCFuZWlnaGJvci5ib3VuZGFyeSB8fCBuZWlnaGJvci5sYXN0VmlzaXRlZCA8PSAtbikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIG52ID0gbmVpZ2hib3IudmVydGljZXNcbiAgICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgICAgdmFyIHZ2ID0gbnZbal1cbiAgICAgICAgaWYodnYgPCAwKSB7XG4gICAgICAgICAgdHVwbGVbal0gPSBwb2ludFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR1cGxlW2pdID0gdmVydHNbdnZdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvID0gdGhpcy5vcmllbnQoKVxuICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgcmV0dXJuIG5laWdoYm9yXG4gICAgICB9XG4gICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IC1uXG4gICAgICBpZihvID09PSAwKSB7XG4gICAgICAgIHRvVmlzaXQucHVzaChuZWlnaGJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxucHJvdG8ud2FsayA9IGZ1bmN0aW9uKHBvaW50LCByYW5kb20pIHtcbiAgLy9BbGlhcyBsb2NhbCBwcm9wZXJ0aWVzXG4gIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlc1xuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG5cbiAgLy9Db21wdXRlIGluaXRpYWwganVtcCBjZWxsXG4gIHZhciBpbml0SW5kZXggPSByYW5kb20gPyAodGhpcy5pbnRlcmlvci5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKXwwIDogKHRoaXMuaW50ZXJpb3IubGVuZ3RoLTEpXG4gIHZhciBjZWxsID0gdGhpcy5pbnRlcmlvclsgaW5pdEluZGV4IF1cblxuICAvL1N0YXJ0IHdhbGtpbmdcbm91dGVyTG9vcDpcbiAgd2hpbGUoIWNlbGwuYm91bmRhcnkpIHtcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuXG4gICAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgICAgdHVwbGVbaV0gPSB2ZXJ0c1tjZWxsVmVydHNbaV1dXG4gICAgfVxuICAgIGNlbGwubGFzdFZpc2l0ZWQgPSBuXG5cbiAgICAvL0ZpbmQgZmFydGhlc3QgYWRqYWNlbnQgY2VsbFxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKG5laWdoYm9yLmxhc3RWaXNpdGVkID49IG4pIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2ID0gdHVwbGVbaV1cbiAgICAgIHR1cGxlW2ldID0gcG9pbnRcbiAgICAgIHZhciBvID0gdGhpcy5vcmllbnQoKVxuICAgICAgdHVwbGVbaV0gPSBwcmV2XG4gICAgICBpZihvIDwgMCkge1xuICAgICAgICBjZWxsID0gbmVpZ2hib3JcbiAgICAgICAgY29udGludWUgb3V0ZXJMb29wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighbmVpZ2hib3IuYm91bmRhcnkpIHtcbiAgICAgICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IC1uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gY2VsbFxufVxuXG5wcm90by5hZGRQZWFrcyA9IGZ1bmN0aW9uKHBvaW50LCBjZWxsKSB7XG4gIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlc1xuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG4gIHZhciBpbnRlcmlvciA9IHRoaXMuaW50ZXJpb3JcbiAgdmFyIHNpbXBsaWNlcyA9IHRoaXMuc2ltcGxpY2VzXG5cbiAgLy9XYWxraW5nIGZpbmlzaGVkIGF0IGJvdW5kYXJ5LCB0aW1lIHRvIGFkZCBwZWFrc1xuICB2YXIgdG92aXNpdCA9IFsgY2VsbCBdXG5cbiAgLy9TdHJldGNoIGluaXRpYWwgYm91bmRhcnkgY2VsbCBpbnRvIGEgcGVha1xuICBjZWxsLmxhc3RWaXNpdGVkID0gblxuICBjZWxsLnZlcnRpY2VzW2NlbGwudmVydGljZXMuaW5kZXhPZigtMSldID0gblxuICBjZWxsLmJvdW5kYXJ5ID0gZmFsc2VcbiAgaW50ZXJpb3IucHVzaChjZWxsKVxuXG4gIC8vUmVjb3JkIGEgbGlzdCBvZiBhbGwgbmV3IGJvdW5kYXJpZXMgY3JlYXRlZCBieSBhZGRlZCBwZWFrcyBzbyB3ZSBjYW4gZ2x1ZSB0aGVtIHRvZ2V0aGVyIHdoZW4gd2UgYXJlIGFsbCBkb25lXG4gIHZhciBnbHVlRmFjZXRzID0gW11cblxuICAvL0RvIGEgdHJhdmVyc2FsIG9mIHRoZSBib3VuZGFyeSB3YWxraW5nIG91dHdhcmQgZnJvbSBzdGFydGluZyBwZWFrXG4gIHdoaWxlKHRvdmlzaXQubGVuZ3RoID4gMCkge1xuICAgIC8vUG9wIG9mZiBwZWFrIGFuZCB3YWxrIG92ZXIgYWRqYWNlbnQgY2VsbHNcbiAgICB2YXIgY2VsbCA9IHRvdmlzaXQucG9wKClcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuICAgIHZhciBpbmRleE9mTiA9IGNlbGxWZXJ0cy5pbmRleE9mKG4pXG4gICAgaWYoaW5kZXhPZk4gPCAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIGlmKGkgPT09IGluZGV4T2ZOKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vRm9yIGVhY2ggYm91bmRhcnkgbmVpZ2hib3Igb2YgdGhlIGNlbGxcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKCFuZWlnaGJvci5ib3VuZGFyeSB8fCBuZWlnaGJvci5sYXN0VmlzaXRlZCA+PSBuKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciBudiA9IG5laWdoYm9yLnZlcnRpY2VzXG5cbiAgICAgIC8vVGVzdCBpZiBuZWlnaGJvciBpcyBhIHBlYWtcbiAgICAgIGlmKG5laWdoYm9yLmxhc3RWaXNpdGVkICE9PSAtbikgeyAgICAgIFxuICAgICAgICAvL0NvbXB1dGUgb3JpZW50YXRpb24gb2YgcCByZWxhdGl2ZSB0byBlYWNoIGJvdW5kYXJ5IHBlYWtcbiAgICAgICAgdmFyIGluZGV4T2ZOZWcxID0gMFxuICAgICAgICBmb3IodmFyIGo9MDsgajw9ZDsgKytqKSB7XG4gICAgICAgICAgaWYobnZbal0gPCAwKSB7XG4gICAgICAgICAgICBpbmRleE9mTmVnMSA9IGpcbiAgICAgICAgICAgIHR1cGxlW2pdID0gcG9pbnRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVwbGVbal0gPSB2ZXJ0c1tudltqXV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG8gPSB0aGlzLm9yaWVudCgpXG5cbiAgICAgICAgLy9UZXN0IGlmIG5laWdoYm9yIGNlbGwgaXMgYWxzbyBhIHBlYWtcbiAgICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgICBudltpbmRleE9mTmVnMV0gPSBuXG4gICAgICAgICAgbmVpZ2hib3IuYm91bmRhcnkgPSBmYWxzZVxuICAgICAgICAgIGludGVyaW9yLnB1c2gobmVpZ2hib3IpXG4gICAgICAgICAgdG92aXNpdC5wdXNoKG5laWdoYm9yKVxuICAgICAgICAgIG5laWdoYm9yLmxhc3RWaXNpdGVkID0gblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPSAtblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuYSA9IG5laWdoYm9yLmFkamFjZW50XG5cbiAgICAgIC8vT3RoZXJ3aXNlLCByZXBsYWNlIG5laWdoYm9yIHdpdGggbmV3IGZhY2VcbiAgICAgIHZhciB2dmVydHMgPSBjZWxsVmVydHMuc2xpY2UoKVxuICAgICAgdmFyIHZhZGogPSBjZWxsQWRqLnNsaWNlKClcbiAgICAgIHZhciBuY2VsbCA9IG5ldyBTaW1wbGV4KHZ2ZXJ0cywgdmFkaiwgdHJ1ZSlcbiAgICAgIHNpbXBsaWNlcy5wdXNoKG5jZWxsKVxuXG4gICAgICAvL0Nvbm5lY3QgdG8gbmVpZ2hib3JcbiAgICAgIHZhciBvcHBvc2l0ZSA9IG5hLmluZGV4T2YoY2VsbClcbiAgICAgIGlmKG9wcG9zaXRlIDwgMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbmFbb3Bwb3NpdGVdID0gbmNlbGxcbiAgICAgIHZhZGpbaW5kZXhPZk5dID0gbmVpZ2hib3JcblxuICAgICAgLy9Db25uZWN0IHRvIGNlbGxcbiAgICAgIHZ2ZXJ0c1tpXSA9IC0xXG4gICAgICB2YWRqW2ldID0gY2VsbFxuICAgICAgY2VsbEFkaltpXSA9IG5jZWxsXG5cbiAgICAgIC8vRmxpcCBmYWNldFxuICAgICAgbmNlbGwuZmxpcCgpXG5cbiAgICAgIC8vQWRkIHRvIGdsdWUgbGlzdFxuICAgICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgICB2YXIgdXUgPSB2dmVydHNbal1cbiAgICAgICAgaWYodXUgPCAwIHx8IHV1ID09PSBuKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmZhY2UgPSBuZXcgQXJyYXkoZC0xKVxuICAgICAgICB2YXIgbnB0ciA9IDBcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWQ7ICsraykge1xuICAgICAgICAgIHZhciB2diA9IHZ2ZXJ0c1trXVxuICAgICAgICAgIGlmKHZ2IDwgMCB8fCBrID09PSBqKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZmFjZVtucHRyKytdID0gdnZcbiAgICAgICAgfVxuICAgICAgICBnbHVlRmFjZXRzLnB1c2gobmV3IEdsdWVGYWNldChuZmFjZSwgbmNlbGwsIGopKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vR2x1ZSBib3VuZGFyeSBmYWNldHMgdG9nZXRoZXJcbiAgZ2x1ZUZhY2V0cy5zb3J0KGNvbXBhcmVHbHVlKVxuXG4gIGZvcih2YXIgaT0wOyBpKzE8Z2x1ZUZhY2V0cy5sZW5ndGg7IGkrPTIpIHtcbiAgICB2YXIgYSA9IGdsdWVGYWNldHNbaV1cbiAgICB2YXIgYiA9IGdsdWVGYWNldHNbaSsxXVxuICAgIHZhciBhaSA9IGEuaW5kZXhcbiAgICB2YXIgYmkgPSBiLmluZGV4XG4gICAgaWYoYWkgPCAwIHx8IGJpIDwgMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgYS5jZWxsLmFkamFjZW50W2EuaW5kZXhdID0gYi5jZWxsXG4gICAgYi5jZWxsLmFkamFjZW50W2IuaW5kZXhdID0gYS5jZWxsXG4gIH1cbn1cblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24ocG9pbnQsIHJhbmRvbSkge1xuICAvL0FkZCBwb2ludFxuICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzXG4gIHZlcnRzLnB1c2gocG9pbnQpXG5cbiAgdmFyIGNlbGwgPSB0aGlzLndhbGsocG9pbnQsIHJhbmRvbSlcbiAgaWYoIWNlbGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vQWxpYXMgbG9jYWwgcHJvcGVydGllc1xuICB2YXIgZCA9IHRoaXMuZGltZW5zaW9uXG4gIHZhciB0dXBsZSA9IHRoaXMudHVwbGVcblxuICAvL0RlZ2VuZXJhdGUgY2FzZTogSWYgcG9pbnQgaXMgY29wbGFuYXIgdG8gY2VsbCwgdGhlbiB3YWxrIHVudGlsIHdlIGZpbmQgYSBub24tZGVnZW5lcmF0ZSBib3VuZGFyeVxuICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgdmFyIHZ2ID0gY2VsbC52ZXJ0aWNlc1tpXVxuICAgIGlmKHZ2IDwgMCkge1xuICAgICAgdHVwbGVbaV0gPSBwb2ludFxuICAgIH0gZWxzZSB7XG4gICAgICB0dXBsZVtpXSA9IHZlcnRzW3Z2XVxuICAgIH1cbiAgfVxuICB2YXIgbyA9IHRoaXMub3JpZW50KHR1cGxlKVxuICBpZihvIDwgMCkge1xuICAgIHJldHVyblxuICB9IGVsc2UgaWYobyA9PT0gMCkge1xuICAgIGNlbGwgPSB0aGlzLmhhbmRsZUJvdW5kYXJ5RGVnZW5lcmFjeShjZWxsLCBwb2ludClcbiAgICBpZighY2VsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy9BZGQgcGVha3NcbiAgdGhpcy5hZGRQZWFrcyhwb2ludCwgY2VsbClcbn1cblxuLy9FeHRyYWN0IGFsbCBib3VuZGFyeSBjZWxsc1xucHJvdG8uYm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgYm91bmRhcnkgPSBbXVxuICB2YXIgY2VsbHMgPSB0aGlzLnNpbXBsaWNlc1xuICB2YXIgbmMgPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBpZihjLmJvdW5kYXJ5KSB7XG4gICAgICB2YXIgYmNlbGwgPSBuZXcgQXJyYXkoZClcbiAgICAgIHZhciBjdiA9IGMudmVydGljZXNcbiAgICAgIHZhciBwdHIgPSAwXG4gICAgICB2YXIgcGFyaXR5ID0gMFxuICAgICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgICBpZihjdltqXSA+PSAwKSB7XG4gICAgICAgICAgYmNlbGxbcHRyKytdID0gY3Zbal1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJpdHkgPSBqJjFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYocGFyaXR5ID09PSAoZCYxKSkge1xuICAgICAgICB2YXIgdCA9IGJjZWxsWzBdXG4gICAgICAgIGJjZWxsWzBdID0gYmNlbGxbMV1cbiAgICAgICAgYmNlbGxbMV0gPSB0XG4gICAgICB9XG4gICAgICBib3VuZGFyeS5wdXNoKGJjZWxsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlcbn1cblxuZnVuY3Rpb24gaW5jcmVtZW50YWxDb252ZXhIdWxsKHBvaW50cywgcmFuZG9tU2VhcmNoKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBoYXZlIGF0IGxlYXN0IGQrMSBwb2ludHNcIilcbiAgfVxuICB2YXIgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgaWYobiA8PSBkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBpbnB1dCBhdCBsZWFzdCBkKzEgcG9pbnRzXCIpXG4gIH1cblxuICAvL0ZJWE1FOiBUaGlzIGNvdWxkIGJlIGRlZ2VuZXJhdGUsIGJ1dCBuZWVkIHRvIHNlbGVjdCBkKzEgbm9uLWNvcGxhbmFyIHBvaW50cyB0byBib290c3RyYXAgcHJvY2Vzc1xuICB2YXIgaW5pdGlhbFNpbXBsZXggPSBwb2ludHMuc2xpY2UoMCwgZCsxKVxuXG4gIC8vTWFrZSBzdXJlIGluaXRpYWwgc2ltcGxleCBpcyBwb3NpdGl2ZWx5IG9yaWVudGVkXG4gIHZhciBvID0gb3JpZW50LmFwcGx5KHZvaWQgMCwgaW5pdGlhbFNpbXBsZXgpXG4gIGlmKG8gPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBub3QgaW4gZ2VuZXJhbCBwb3NpdGlvblwiKVxuICB9XG4gIHZhciBpbml0aWFsQ29vcmRzID0gbmV3IEFycmF5KGQrMSlcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIGluaXRpYWxDb29yZHNbaV0gPSBpXG4gIH1cbiAgaWYobyA8IDApIHtcbiAgICBpbml0aWFsQ29vcmRzWzBdID0gMVxuICAgIGluaXRpYWxDb29yZHNbMV0gPSAwXG4gIH1cblxuICAvL0NyZWF0ZSBpbml0aWFsIHRvcG9sb2dpY2FsIGluZGV4LCBnbHVlIHBvaW50ZXJzIHRvZ2V0aGVyIChraW5kIG9mIG1lc3N5KVxuICB2YXIgaW5pdGlhbENlbGwgPSBuZXcgU2ltcGxleChpbml0aWFsQ29vcmRzLCBuZXcgQXJyYXkoZCsxKSwgZmFsc2UpXG4gIHZhciBib3VuZGFyeSA9IGluaXRpYWxDZWxsLmFkamFjZW50XG4gIHZhciBsaXN0ID0gbmV3IEFycmF5KGQrMilcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIHZhciB2ZXJ0cyA9IGluaXRpYWxDb29yZHMuc2xpY2UoKVxuICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgIGlmKGogPT09IGkpIHtcbiAgICAgICAgdmVydHNbal0gPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdCA9IHZlcnRzWzBdXG4gICAgdmVydHNbMF0gPSB2ZXJ0c1sxXVxuICAgIHZlcnRzWzFdID0gdFxuICAgIHZhciBjZWxsID0gbmV3IFNpbXBsZXgodmVydHMsIG5ldyBBcnJheShkKzEpLCB0cnVlKVxuICAgIGJvdW5kYXJ5W2ldID0gY2VsbFxuICAgIGxpc3RbaV0gPSBjZWxsXG4gIH1cbiAgbGlzdFtkKzFdID0gaW5pdGlhbENlbGxcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIHZhciB2ZXJ0cyA9IGJvdW5kYXJ5W2ldLnZlcnRpY2VzXG4gICAgdmFyIGFkaiA9IGJvdW5kYXJ5W2ldLmFkamFjZW50XG4gICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgdmFyIHYgPSB2ZXJ0c1tqXVxuICAgICAgaWYodiA8IDApIHtcbiAgICAgICAgYWRqW2pdID0gaW5pdGlhbENlbGxcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaz0wOyBrPD1kOyArK2spIHtcbiAgICAgICAgaWYoYm91bmRhcnlba10udmVydGljZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgICBhZGpbal0gPSBib3VuZGFyeVtrXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9Jbml0aWFsaXplIHRyaWFuZ2xlc1xuICB2YXIgdHJpYW5nbGVzID0gbmV3IFRyaWFuZ3VsYXRpb24oZCwgaW5pdGlhbFNpbXBsZXgsIGxpc3QpXG5cbiAgLy9JbnNlcnQgcmVtYWluaW5nIHBvaW50c1xuICB2YXIgdXNlUmFuZG9tID0gISFyYW5kb21TZWFyY2hcbiAgZm9yKHZhciBpPWQrMTsgaTxuOyArK2kpIHtcbiAgICB0cmlhbmdsZXMuaW5zZXJ0KHBvaW50c1tpXSwgdXNlUmFuZG9tKVxuICB9XG4gIFxuICAvL0V4dHJhY3QgYm91bmRhcnkgY2VsbHNcbiAgcmV0dXJuIHRyaWFuZ2xlcy5ib3VuZGFyeSgpXG59IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjQuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTktMDUtMDFUMjE6MDRaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZG9jdW1lbnQgPSB3aW5kb3cuZG9jdW1lbnQ7XG5cbnZhciBnZXRQcm90byA9IE9iamVjdC5nZXRQcm90b3R5cGVPZjtcblxudmFyIHNsaWNlID0gYXJyLnNsaWNlO1xuXG52YXIgY29uY2F0ID0gYXJyLmNvbmNhdDtcblxudmFyIHB1c2ggPSBhcnIucHVzaDtcblxudmFyIGluZGV4T2YgPSBhcnIuaW5kZXhPZjtcblxudmFyIGNsYXNzMnR5cGUgPSB7fTtcblxudmFyIHRvU3RyaW5nID0gY2xhc3MydHlwZS50b1N0cmluZztcblxudmFyIGhhc093biA9IGNsYXNzMnR5cGUuaGFzT3duUHJvcGVydHk7XG5cbnZhciBmblRvU3RyaW5nID0gaGFzT3duLnRvU3RyaW5nO1xuXG52YXIgT2JqZWN0RnVuY3Rpb25TdHJpbmcgPSBmblRvU3RyaW5nLmNhbGwoIE9iamVjdCApO1xuXG52YXIgc3VwcG9ydCA9IHt9O1xuXG52YXIgaXNGdW5jdGlvbiA9IGZ1bmN0aW9uIGlzRnVuY3Rpb24oIG9iaiApIHtcblxuICAgICAgLy8gU3VwcG9ydDogQ2hyb21lIDw9NTcsIEZpcmVmb3ggPD01MlxuICAgICAgLy8gSW4gc29tZSBicm93c2VycywgdHlwZW9mIHJldHVybnMgXCJmdW5jdGlvblwiIGZvciBIVE1MIDxvYmplY3Q+IGVsZW1lbnRzXG4gICAgICAvLyAoaS5lLiwgYHR5cGVvZiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcIm9iamVjdFwiICkgPT09IFwiZnVuY3Rpb25cImApLlxuICAgICAgLy8gV2UgZG9uJ3Qgd2FudCB0byBjbGFzc2lmeSAqYW55KiBET00gbm9kZSBhcyBhIGZ1bmN0aW9uLlxuICAgICAgcmV0dXJuIHR5cGVvZiBvYmogPT09IFwiZnVuY3Rpb25cIiAmJiB0eXBlb2Ygb2JqLm5vZGVUeXBlICE9PSBcIm51bWJlclwiO1xuICB9O1xuXG5cbnZhciBpc1dpbmRvdyA9IGZ1bmN0aW9uIGlzV2luZG93KCBvYmogKSB7XG5cdFx0cmV0dXJuIG9iaiAhPSBudWxsICYmIG9iaiA9PT0gb2JqLndpbmRvdztcblx0fTtcblxuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuNC4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2c7XG5cbmpRdWVyeS5mbiA9IGpRdWVyeS5wcm90b3R5cGUgPSB7XG5cblx0Ly8gVGhlIGN1cnJlbnQgdmVyc2lvbiBvZiBqUXVlcnkgYmVpbmcgdXNlZFxuXHRqcXVlcnk6IHZlcnNpb24sXG5cblx0Y29uc3RydWN0b3I6IGpRdWVyeSxcblxuXHQvLyBUaGUgZGVmYXVsdCBsZW5ndGggb2YgYSBqUXVlcnkgb2JqZWN0IGlzIDBcblx0bGVuZ3RoOiAwLFxuXG5cdHRvQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdH0sXG5cblx0Ly8gR2V0IHRoZSBOdGggZWxlbWVudCBpbiB0aGUgbWF0Y2hlZCBlbGVtZW50IHNldCBPUlxuXHQvLyBHZXQgdGhlIHdob2xlIG1hdGNoZWQgZWxlbWVudCBzZXQgYXMgYSBjbGVhbiBhcnJheVxuXHRnZXQ6IGZ1bmN0aW9uKCBudW0gKSB7XG5cblx0XHQvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBpbiBhIGNsZWFuIGFycmF5XG5cdFx0aWYgKCBudW0gPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiBzbGljZS5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIGp1c3QgdGhlIG9uZSBlbGVtZW50IGZyb20gdGhlIHNldFxuXHRcdHJldHVybiBudW0gPCAwID8gdGhpc1sgbnVtICsgdGhpcy5sZW5ndGggXSA6IHRoaXNbIG51bSBdO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFpc0Z1bmN0aW9uKCB0YXJnZXQgKSApIHtcblx0XHR0YXJnZXQgPSB7fTtcblx0fVxuXG5cdC8vIEV4dGVuZCBqUXVlcnkgaXRzZWxmIGlmIG9ubHkgb25lIGFyZ3VtZW50IGlzIHBhc3NlZFxuXHRpZiAoIGkgPT09IGxlbmd0aCApIHtcblx0XHR0YXJnZXQgPSB0aGlzO1xuXHRcdGktLTtcblx0fVxuXG5cdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXG5cdFx0Ly8gT25seSBkZWFsIHdpdGggbm9uLW51bGwvdW5kZWZpbmVkIHZhbHVlc1xuXHRcdGlmICggKCBvcHRpb25zID0gYXJndW1lbnRzWyBpIF0gKSAhPSBudWxsICkge1xuXG5cdFx0XHQvLyBFeHRlbmQgdGhlIGJhc2Ugb2JqZWN0XG5cdFx0XHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRcdGNvcHkgPSBvcHRpb25zWyBuYW1lIF07XG5cblx0XHRcdFx0Ly8gUHJldmVudCBPYmplY3QucHJvdG90eXBlIHBvbGx1dGlvblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggbmFtZSA9PT0gXCJfX3Byb3RvX19cIiB8fCB0YXJnZXQgPT09IGNvcHkgKSB7XG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZWN1cnNlIGlmIHdlJ3JlIG1lcmdpbmcgcGxhaW4gb2JqZWN0cyBvciBhcnJheXNcblx0XHRcdFx0aWYgKCBkZWVwICYmIGNvcHkgJiYgKCBqUXVlcnkuaXNQbGFpbk9iamVjdCggY29weSApIHx8XG5cdFx0XHRcdFx0KCBjb3B5SXNBcnJheSA9IEFycmF5LmlzQXJyYXkoIGNvcHkgKSApICkgKSB7XG5cdFx0XHRcdFx0c3JjID0gdGFyZ2V0WyBuYW1lIF07XG5cblx0XHRcdFx0XHQvLyBFbnN1cmUgcHJvcGVyIHR5cGUgZm9yIHRoZSBzb3VyY2UgdmFsdWVcblx0XHRcdFx0XHRpZiAoIGNvcHlJc0FycmF5ICYmICFBcnJheS5pc0FycmF5KCBzcmMgKSApIHtcblx0XHRcdFx0XHRcdGNsb25lID0gW107XG5cdFx0XHRcdFx0fSBlbHNlIGlmICggIWNvcHlJc0FycmF5ICYmICFqUXVlcnkuaXNQbGFpbk9iamVjdCggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHt9O1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IHNyYztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29weUlzQXJyYXkgPSBmYWxzZTtcblxuXHRcdFx0XHRcdC8vIE5ldmVyIG1vdmUgb3JpZ2luYWwgb2JqZWN0cywgY2xvbmUgdGhlbVxuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0galF1ZXJ5LmV4dGVuZCggZGVlcCwgY2xvbmUsIGNvcHkgKTtcblxuXHRcdFx0XHQvLyBEb24ndCBicmluZyBpbiB1bmRlZmluZWQgdmFsdWVzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvcHkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGNvcHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIG1vZGlmaWVkIG9iamVjdFxuXHRyZXR1cm4gdGFyZ2V0O1xufTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIFVuaXF1ZSBmb3IgZWFjaCBjb3B5IG9mIGpRdWVyeSBvbiB0aGUgcGFnZVxuXHRleHBhbmRvOiBcImpRdWVyeVwiICsgKCB2ZXJzaW9uICsgTWF0aC5yYW5kb20oKSApLnJlcGxhY2UoIC9cXEQvZywgXCJcIiApLFxuXG5cdC8vIEFzc3VtZSBqUXVlcnkgaXMgcmVhZHkgd2l0aG91dCB0aGUgcmVhZHkgbW9kdWxlXG5cdGlzUmVhZHk6IHRydWUsXG5cblx0ZXJyb3I6IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdFx0dGhyb3cgbmV3IEVycm9yKCBtc2cgKTtcblx0fSxcblxuXHRub29wOiBmdW5jdGlvbigpIHt9LFxuXG5cdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIHByb3RvLCBDdG9yO1xuXG5cdFx0Ly8gRGV0ZWN0IG9idmlvdXMgbmVnYXRpdmVzXG5cdFx0Ly8gVXNlIHRvU3RyaW5nIGluc3RlYWQgb2YgalF1ZXJ5LnR5cGUgdG8gY2F0Y2ggaG9zdCBvYmplY3RzXG5cdFx0aWYgKCAhb2JqIHx8IHRvU3RyaW5nLmNhbGwoIG9iaiApICE9PSBcIltvYmplY3QgT2JqZWN0XVwiICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdHByb3RvID0gZ2V0UHJvdG8oIG9iaiApO1xuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIG5vIHByb3RvdHlwZSAoZS5nLiwgYE9iamVjdC5jcmVhdGUoIG51bGwgKWApIGFyZSBwbGFpblxuXHRcdGlmICggIXByb3RvICkge1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXG5cdFx0Ly8gT2JqZWN0cyB3aXRoIHByb3RvdHlwZSBhcmUgcGxhaW4gaWZmIHRoZXkgd2VyZSBjb25zdHJ1Y3RlZCBieSBhIGdsb2JhbCBPYmplY3QgZnVuY3Rpb25cblx0XHRDdG9yID0gaGFzT3duLmNhbGwoIHByb3RvLCBcImNvbnN0cnVjdG9yXCIgKSAmJiBwcm90by5jb25zdHJ1Y3Rvcjtcblx0XHRyZXR1cm4gdHlwZW9mIEN0b3IgPT09IFwiZnVuY3Rpb25cIiAmJiBmblRvU3RyaW5nLmNhbGwoIEN0b3IgKSA9PT0gT2JqZWN0RnVuY3Rpb25TdHJpbmc7XG5cdH0sXG5cblx0aXNFbXB0eU9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblx0XHR2YXIgbmFtZTtcblxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHQvLyBFdmFsdWF0ZXMgYSBzY3JpcHQgaW4gYSBnbG9iYWwgY29udGV4dFxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucyApIHtcblx0XHRET01FdmFsKCBjb2RlLCB7IG5vbmNlOiBvcHRpb25zICYmIG9wdGlvbnMubm9uY2UgfSApO1xuXHR9LFxuXG5cdGVhY2g6IGZ1bmN0aW9uKCBvYmosIGNhbGxiYWNrICkge1xuXHRcdHZhciBsZW5ndGgsIGkgPSAwO1xuXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggb2JqICkgKSB7XG5cdFx0XHRsZW5ndGggPSBvYmoubGVuZ3RoO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2suY2FsbCggb2JqWyBpIF0sIGksIG9ialsgaSBdICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gb2JqICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBvYmo7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cblxuLy8gUG9wdWxhdGUgdGhlIGNsYXNzMnR5cGUgbWFwXG5qUXVlcnkuZWFjaCggXCJCb29sZWFuIE51bWJlciBTdHJpbmcgRnVuY3Rpb24gQXJyYXkgRGF0ZSBSZWdFeHAgT2JqZWN0IEVycm9yIFN5bWJvbFwiLnNwbGl0KCBcIiBcIiApLFxuZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy40XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDE5LTA0LTA4XG4gKi9cbihmdW5jdGlvbiggd2luZG93ICkge1xuXG52YXIgaSxcblx0c3VwcG9ydCxcblx0RXhwcixcblx0Z2V0VGV4dCxcblx0aXNYTUwsXG5cdHRva2VuaXplLFxuXHRjb21waWxlLFxuXHRzZWxlY3QsXG5cdG91dGVybW9zdENvbnRleHQsXG5cdHNvcnRJbnB1dCxcblx0aGFzRHVwbGljYXRlLFxuXG5cdC8vIExvY2FsIGRvY3VtZW50IHZhcnNcblx0c2V0RG9jdW1lbnQsXG5cdGRvY3VtZW50LFxuXHRkb2NFbGVtLFxuXHRkb2N1bWVudElzSFRNTCxcblx0cmJ1Z2d5UVNBLFxuXHRyYnVnZ3lNYXRjaGVzLFxuXHRtYXRjaGVzLFxuXHRjb250YWlucyxcblxuXHQvLyBJbnN0YW5jZS1zcGVjaWZpYyBkYXRhXG5cdGV4cGFuZG8gPSBcInNpenpsZVwiICsgMSAqIG5ldyBEYXRlKCksXG5cdHByZWZlcnJlZERvYyA9IHdpbmRvdy5kb2N1bWVudCxcblx0ZGlycnVucyA9IDAsXG5cdGRvbmUgPSAwLFxuXHRjbGFzc0NhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0dG9rZW5DYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdGNvbXBpbGVyQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRub25uYXRpdmVTZWxlY3RvckNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0c29ydE9yZGVyID0gZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIDA7XG5cdH0sXG5cblx0Ly8gSW5zdGFuY2UgbWV0aG9kc1xuXHRoYXNPd24gPSAoe30pLmhhc093blByb3BlcnR5LFxuXHRhcnIgPSBbXSxcblx0cG9wID0gYXJyLnBvcCxcblx0cHVzaF9uYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblx0Ly8gVXNlIGEgc3RyaXBwZWQtZG93biBpbmRleE9mIGFzIGl0J3MgZmFzdGVyIHRoYW4gbmF0aXZlXG5cdC8vIGh0dHBzOi8vanNwZXJmLmNvbS90aG9yLWluZGV4b2YtdnMtZm9yLzVcblx0aW5kZXhPZiA9IGZ1bmN0aW9uKCBsaXN0LCBlbGVtICkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGxlbiA9IGxpc3QubGVuZ3RoO1xuXHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0aWYgKCBsaXN0W2ldID09PSBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIC0xO1xuXHR9LFxuXG5cdGJvb2xlYW5zID0gXCJjaGVja2VkfHNlbGVjdGVkfGFzeW5jfGF1dG9mb2N1c3xhdXRvcGxheXxjb250cm9sc3xkZWZlcnxkaXNhYmxlZHxoaWRkZW58aXNtYXB8bG9vcHxtdWx0aXBsZXxvcGVufHJlYWRvbmx5fHJlcXVpcmVkfHNjb3BlZFwiLFxuXG5cdC8vIFJlZ3VsYXIgZXhwcmVzc2lvbnNcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9jc3MzLXNlbGVjdG9ycy8jd2hpdGVzcGFjZVxuXHR3aGl0ZXNwYWNlID0gXCJbXFxcXHgyMFxcXFx0XFxcXHJcXFxcblxcXFxmXVwiLFxuXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCN2YWx1ZS1kZWYtaWRlbnRpZmllclxuXHRpZGVudGlmaWVyID0gXCIoPzpcXFxcXFxcXC58W1xcXFx3LV18W15cXDAtXFxcXHhhMF0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIE9wZXJhdG9yIChjYXB0dXJlIDIpXG5cdFx0XCIqKFsqXiR8IX5dPz0pXCIgKyB3aGl0ZXNwYWNlICtcblx0XHQvLyBcIkF0dHJpYnV0ZSB2YWx1ZXMgbXVzdCBiZSBDU1MgaWRlbnRpZmllcnMgW2NhcHR1cmUgNV0gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXHRcdC8vIFRvIHJlZHVjZSB0aGUgbnVtYmVyIG9mIHNlbGVjdG9ycyBuZWVkaW5nIHRva2VuaXplIGluIHRoZSBwcmVGaWx0ZXIsIHByZWZlciBhcmd1bWVudHM6XG5cdFx0Ly8gMS4gcXVvdGVkIChjYXB0dXJlIDM7IGNhcHR1cmUgNCBvciBjYXB0dXJlIDUpXG5cdFx0XCIoJygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwiKXxcIiArXG5cdFx0Ly8gMi4gc2ltcGxlIChjYXB0dXJlIDYpXG5cdFx0XCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFwoKVtcXFxcXV18XCIgKyBhdHRyaWJ1dGVzICsgXCIpKil8XCIgK1xuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArIHdoaXRlc3BhY2UgKyBcIiskXCIsIFwiZ1wiICksXG5cblx0cmNvbW1hID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqLFwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cdHJjb21iaW5hdG9ycyA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKihbPit+XXxcIiArIHdoaXRlc3BhY2UgKyBcIilcIiArIHdoaXRlc3BhY2UgKyBcIipcIiApLFxuXHRyZGVzY2VuZCA9IG5ldyBSZWdFeHAoIHdoaXRlc3BhY2UgKyBcInw+XCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaHRtbCA9IC9IVE1MJC9pLFxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXG5cdC8vIENTUyBlc2NhcGVzXG5cdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBDU1Mgc3RyaW5nL2lkZW50aWZpZXIgc2VyaWFsaXphdGlvblxuXHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI2NvbW1vbi1zZXJpYWxpemluZy1pZGlvbXNcblx0cmNzc2VzY2FwZSA9IC8oW1xcMC1cXHgxZlxceDdmXXxeLT9cXGQpfF4tJHxbXlxcMC1cXHgxZlxceDdmLVxcdUZGRkZcXHctXS9nLFxuXHRmY3NzZXNjYXBlID0gZnVuY3Rpb24oIGNoLCBhc0NvZGVQb2ludCApIHtcblx0XHRpZiAoIGFzQ29kZVBvaW50ICkge1xuXG5cdFx0XHQvLyBVKzAwMDAgTlVMTCBiZWNvbWVzIFUrRkZGRCBSRVBMQUNFTUVOVCBDSEFSQUNURVJcblx0XHRcdGlmICggY2ggPT09IFwiXFwwXCIgKSB7XG5cdFx0XHRcdHJldHVybiBcIlxcdUZGRkRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udHJvbCBjaGFyYWN0ZXJzIGFuZCAoZGVwZW5kZW50IHVwb24gcG9zaXRpb24pIG51bWJlcnMgZ2V0IGVzY2FwZWQgYXMgY29kZSBwb2ludHNcblx0XHRcdHJldHVybiBjaC5zbGljZSggMCwgLTEgKSArIFwiXFxcXFwiICsgY2guY2hhckNvZGVBdCggY2gubGVuZ3RoIC0gMSApLnRvU3RyaW5nKCAxNiApICsgXCIgXCI7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXIgcG90ZW50aWFsbHktc3BlY2lhbCBBU0NJSSBjaGFyYWN0ZXJzIGdldCBiYWNrc2xhc2gtZXNjYXBlZFxuXHRcdHJldHVybiBcIlxcXFxcIiArIGNoO1xuXHR9LFxuXG5cdC8vIFVzZWQgZm9yIGlmcmFtZXNcblx0Ly8gU2VlIHNldERvY3VtZW50KClcblx0Ly8gUmVtb3ZpbmcgdGhlIGZ1bmN0aW9uIHdyYXBwZXIgY2F1c2VzIGEgXCJQZXJtaXNzaW9uIERlbmllZFwiXG5cdC8vIGVycm9yIGluIElFXG5cdHVubG9hZEhhbmRsZXIgPSBmdW5jdGlvbigpIHtcblx0XHRzZXREb2N1bWVudCgpO1xuXHR9LFxuXG5cdGluRGlzYWJsZWRGaWVsZHNldCA9IGFkZENvbWJpbmF0b3IoXG5cdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gdHJ1ZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiZmllbGRzZXRcIjtcblx0XHR9LFxuXHRcdHsgZGlyOiBcInBhcmVudE5vZGVcIiwgbmV4dDogXCJsZWdlbmRcIiB9XG5cdCk7XG5cbi8vIE9wdGltaXplIGZvciBwdXNoLmFwcGx5KCBfLCBOb2RlTGlzdCApXG50cnkge1xuXHRwdXNoLmFwcGx5KFxuXHRcdChhcnIgPSBzbGljZS5jYWxsKCBwcmVmZXJyZWREb2MuY2hpbGROb2RlcyApKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMFxuXHQvLyBEZXRlY3Qgc2lsZW50bHkgZmFpbGluZyBwdXNoLmFwcGx5XG5cdGFyclsgcHJlZmVycmVkRG9jLmNoaWxkTm9kZXMubGVuZ3RoIF0ubm9kZVR5cGU7XG59IGNhdGNoICggZSApIHtcblx0cHVzaCA9IHsgYXBwbHk6IGFyci5sZW5ndGggP1xuXG5cdFx0Ly8gTGV2ZXJhZ2Ugc2xpY2UgaWYgcG9zc2libGVcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHRwdXNoX25hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKGVscykgKTtcblx0XHR9IDpcblxuXHRcdC8vIFN1cHBvcnQ6IElFPDlcblx0XHQvLyBPdGhlcndpc2UgYXBwZW5kIGRpcmVjdGx5XG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0dmFyIGogPSB0YXJnZXQubGVuZ3RoLFxuXHRcdFx0XHRpID0gMDtcblx0XHRcdC8vIENhbid0IHRydXN0IE5vZGVMaXN0Lmxlbmd0aFxuXHRcdFx0d2hpbGUgKCAodGFyZ2V0W2orK10gPSBlbHNbaSsrXSkgKSB7fVxuXHRcdFx0dGFyZ2V0Lmxlbmd0aCA9IGogLSAxO1xuXHRcdH1cblx0fTtcbn1cblxuZnVuY3Rpb24gU2l6emxlKCBzZWxlY3RvciwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApIHtcblx0dmFyIG0sIGksIGVsZW0sIG5pZCwgbWF0Y2gsIGdyb3VwcywgbmV3U2VsZWN0b3IsXG5cdFx0bmV3Q29udGV4dCA9IGNvbnRleHQgJiYgY29udGV4dC5vd25lckRvY3VtZW50LFxuXG5cdFx0Ly8gbm9kZVR5cGUgZGVmYXVsdHMgdG8gOSwgc2luY2UgY29udGV4dCBkZWZhdWx0cyB0byBkb2N1bWVudFxuXHRcdG5vZGVUeXBlID0gY29udGV4dCA/IGNvbnRleHQubm9kZVR5cGUgOiA5O1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFJldHVybiBlYXJseSBmcm9tIGNhbGxzIHdpdGggaW52YWxpZCBzZWxlY3RvciBvciBjb250ZXh0XG5cdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiIHx8ICFzZWxlY3RvciB8fFxuXHRcdG5vZGVUeXBlICE9PSAxICYmIG5vZGVUeXBlICE9PSA5ICYmIG5vZGVUeXBlICE9PSAxMSApIHtcblxuXHRcdHJldHVybiByZXN1bHRzO1xuXHR9XG5cblx0Ly8gVHJ5IHRvIHNob3J0Y3V0IGZpbmQgb3BlcmF0aW9ucyAoYXMgb3Bwb3NlZCB0byBmaWx0ZXJzKSBpbiBIVE1MIGRvY3VtZW50c1xuXHRpZiAoICFzZWVkICkge1xuXG5cdFx0aWYgKCAoIGNvbnRleHQgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IHByZWZlcnJlZERvYyApICE9PSBkb2N1bWVudCApIHtcblx0XHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdFx0fVxuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmIChtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKSkgKSB7XG5cblx0XHRcdFx0Ly8gSUQgc2VsZWN0b3Jcblx0XHRcdFx0aWYgKCAobSA9IG1hdGNoWzFdKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQoIG0gKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0XHRpZiAoIGVsZW0uaWQgPT09IG0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRWxlbWVudCBjb250ZXh0XG5cdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUsIE9wZXJhLCBXZWJraXRcblx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRpZiAoIG5ld0NvbnRleHQgJiYgKGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICYmXG5cdFx0XHRcdFx0XHRcdGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICkgJiZcblx0XHRcdFx0XHRcdFx0ZWxlbS5pZCA9PT0gbSApIHtcblxuXHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFR5cGUgc2VsZWN0b3Jcblx0XHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbMl0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIChtID0gbWF0Y2hbM10pICYmIHN1cHBvcnQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSAmJlxuXHRcdFx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggbSApICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVGFrZSBhZHZhbnRhZ2Ugb2YgcXVlcnlTZWxlY3RvckFsbFxuXHRcdFx0aWYgKCBzdXBwb3J0LnFzYSAmJlxuXHRcdFx0XHQhbm9ubmF0aXZlU2VsZWN0b3JDYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdICYmXG5cdFx0XHRcdCghcmJ1Z2d5UVNBIHx8ICFyYnVnZ3lRU0EudGVzdCggc2VsZWN0b3IgKSkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KG5vZGVUeXBlICE9PSAxIHx8IGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIikgKSB7XG5cblx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cblx0XHRcdFx0Ly8gcVNBIGNvbnNpZGVycyBlbGVtZW50cyBvdXRzaWRlIGEgc2NvcGluZyByb290IHdoZW4gZXZhbHVhdGluZyBjaGlsZCBvclxuXHRcdFx0XHQvLyBkZXNjZW5kYW50IGNvbWJpbmF0b3JzLCB3aGljaCBpcyBub3Qgd2hhdCB3ZSB3YW50LlxuXHRcdFx0XHQvLyBJbiBzdWNoIGNhc2VzLCB3ZSB3b3JrIGFyb3VuZCB0aGUgYmVoYXZpb3IgYnkgcHJlZml4aW5nIGV2ZXJ5IHNlbGVjdG9yIGluIHRoZVxuXHRcdFx0XHQvLyBsaXN0IHdpdGggYW4gSUQgc2VsZWN0b3IgcmVmZXJlbmNpbmcgdGhlIHNjb3BlIGNvbnRleHQuXG5cdFx0XHRcdC8vIFRoYW5rcyB0byBBbmRyZXcgRHVwb250IGZvciB0aGlzIHRlY2huaXF1ZS5cblx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gMSAmJiByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApICkge1xuXG5cdFx0XHRcdFx0Ly8gQ2FwdHVyZSB0aGUgY29udGV4dCBJRCwgc2V0dGluZyBpdCBmaXJzdCBpZiBuZWNlc3Nhcnlcblx0XHRcdFx0XHRpZiAoIChuaWQgPSBjb250ZXh0LmdldEF0dHJpYnV0ZSggXCJpZFwiICkpICkge1xuXHRcdFx0XHRcdFx0bmlkID0gbmlkLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKG5pZCA9IGV4cGFuZG8pICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gUHJlZml4IGV2ZXJ5IHNlbGVjdG9yIGluIHRoZSBsaXN0XG5cdFx0XHRcdFx0Z3JvdXBzID0gdG9rZW5pemUoIHNlbGVjdG9yICk7XG5cdFx0XHRcdFx0aSA9IGdyb3Vwcy5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBcIiNcIiArIG5pZCArIFwiIFwiICsgdG9TZWxlY3RvciggZ3JvdXBzW2ldICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG5ld1NlbGVjdG9yID0gZ3JvdXBzLmpvaW4oIFwiLFwiICk7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsXG5cdFx0XHRcdFx0XHRuZXdDb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIG5ld1NlbGVjdG9yIClcblx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9IGNhdGNoICggcXNhRXJyb3IgKSB7XG5cdFx0XHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fSBmaW5hbGx5IHtcblx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdGNvbnRleHQucmVtb3ZlQXR0cmlidXRlKCBcImlkXCIgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBbGwgb3RoZXJzXG5cdHJldHVybiBzZWxlY3QoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSwgY29udGV4dCwgcmVzdWx0cywgc2VlZCApO1xufVxuXG4vKipcbiAqIENyZWF0ZSBrZXktdmFsdWUgY2FjaGVzIG9mIGxpbWl0ZWQgc2l6ZVxuICogQHJldHVybnMge2Z1bmN0aW9uKHN0cmluZywgb2JqZWN0KX0gUmV0dXJucyB0aGUgT2JqZWN0IGRhdGEgYWZ0ZXIgc3RvcmluZyBpdCBvbiBpdHNlbGYgd2l0aFxuICpcdHByb3BlcnR5IG5hbWUgdGhlIChzcGFjZS1zdWZmaXhlZCkgc3RyaW5nIGFuZCAoaWYgdGhlIGNhY2hlIGlzIGxhcmdlciB0aGFuIEV4cHIuY2FjaGVMZW5ndGgpXG4gKlx0ZGVsZXRpbmcgdGhlIG9sZGVzdCBlbnRyeVxuICovXG5mdW5jdGlvbiBjcmVhdGVDYWNoZSgpIHtcblx0dmFyIGtleXMgPSBbXTtcblxuXHRmdW5jdGlvbiBjYWNoZSgga2V5LCB2YWx1ZSApIHtcblx0XHQvLyBVc2UgKGtleSArIFwiIFwiKSB0byBhdm9pZCBjb2xsaXNpb24gd2l0aCBuYXRpdmUgcHJvdG90eXBlIHByb3BlcnRpZXMgKHNlZSBJc3N1ZSAjMTU3KVxuXHRcdGlmICgga2V5cy5wdXNoKCBrZXkgKyBcIiBcIiApID4gRXhwci5jYWNoZUxlbmd0aCApIHtcblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuIChjYWNoZVsga2V5ICsgXCIgXCIgXSA9IHZhbHVlKTtcblx0fVxuXHRyZXR1cm4gY2FjaGU7XG59XG5cbi8qKlxuICogTWFyayBhIGZ1bmN0aW9uIGZvciBzcGVjaWFsIHVzZSBieSBTaXp6bGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBtYXJrXG4gKi9cbmZ1bmN0aW9uIG1hcmtGdW5jdGlvbiggZm4gKSB7XG5cdGZuWyBleHBhbmRvIF0gPSB0cnVlO1xuXHRyZXR1cm4gZm47XG59XG5cbi8qKlxuICogU3VwcG9ydCB0ZXN0aW5nIHVzaW5nIGFuIGVsZW1lbnRcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFBhc3NlZCB0aGUgY3JlYXRlZCBlbGVtZW50IGFuZCByZXR1cm5zIGEgYm9vbGVhbiByZXN1bHRcbiAqL1xuZnVuY3Rpb24gYXNzZXJ0KCBmbiApIHtcblx0dmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGVsICk7XG5cdH0gY2F0Y2ggKGUpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cdFx0Ly8gUmVtb3ZlIGZyb20gaXRzIHBhcmVudCBieSBkZWZhdWx0XG5cdFx0aWYgKCBlbC5wYXJlbnROb2RlICkge1xuXHRcdFx0ZWwucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZWwgKTtcblx0XHR9XG5cdFx0Ly8gcmVsZWFzZSBtZW1vcnkgaW4gSUVcblx0XHRlbCA9IG51bGw7XG5cdH1cbn1cblxuLyoqXG4gKiBBZGRzIHRoZSBzYW1lIGhhbmRsZXIgZm9yIGFsbCBvZiB0aGUgc3BlY2lmaWVkIGF0dHJzXG4gKiBAcGFyYW0ge1N0cmluZ30gYXR0cnMgUGlwZS1zZXBhcmF0ZWQgbGlzdCBvZiBhdHRyaWJ1dGVzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYW5kbGVyIFRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGFwcGxpZWRcbiAqL1xuZnVuY3Rpb24gYWRkSGFuZGxlKCBhdHRycywgaGFuZGxlciApIHtcblx0dmFyIGFyciA9IGF0dHJzLnNwbGl0KFwifFwiKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFycltpXSBdID0gaGFuZGxlcjtcblx0fVxufVxuXG4vKipcbiAqIENoZWNrcyBkb2N1bWVudCBvcmRlciBvZiB0d28gc2libGluZ3NcbiAqIEBwYXJhbSB7RWxlbWVudH0gYVxuICogQHBhcmFtIHtFbGVtZW50fSBiXG4gKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIGxlc3MgdGhhbiAwIGlmIGEgcHJlY2VkZXMgYiwgZ3JlYXRlciB0aGFuIDAgaWYgYSBmb2xsb3dzIGJcbiAqL1xuZnVuY3Rpb24gc2libGluZ0NoZWNrKCBhLCBiICkge1xuXHR2YXIgY3VyID0gYiAmJiBhLFxuXHRcdGRpZmYgPSBjdXIgJiYgYS5ub2RlVHlwZSA9PT0gMSAmJiBiLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRhLnNvdXJjZUluZGV4IC0gYi5zb3VyY2VJbmRleDtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdFx0aW5EaXNhYmxlZEZpZWxkc2V0KCBlbGVtICkgPT09IGRpc2FibGVkO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cblx0XHQvLyBUcnkgdG8gd2lubm93IG91dCBlbGVtZW50cyB0aGF0IGNhbid0IGJlIGRpc2FibGVkIGJlZm9yZSB0cnVzdGluZyB0aGUgZGlzYWJsZWQgcHJvcGVydHkuXG5cdFx0Ly8gU29tZSB2aWN0aW1zIGdldCBjYXVnaHQgaW4gb3VyIG5ldCAobGFiZWwsIGxlZ2VuZCwgbWVudSwgdHJhY2spLCBidXQgaXQgc2hvdWxkbid0XG5cdFx0Ly8gZXZlbiBleGlzdCBvbiB0aGVtLCBsZXQgYWxvbmUgaGF2ZSBhIGJvb2xlYW4gdmFsdWUuXG5cdFx0fSBlbHNlIGlmICggXCJsYWJlbFwiIGluIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kaXNhYmxlZCA9PT0gZGlzYWJsZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gUmVtYWluaW5nIGVsZW1lbnRzIGFyZSBuZWl0aGVyIDplbmFibGVkIG5vciA6ZGlzYWJsZWRcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBwb3NpdGlvbmFsc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gZm5cbiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZm4gKSB7XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIGFyZ3VtZW50ICkge1xuXHRcdGFyZ3VtZW50ID0gK2FyZ3VtZW50O1xuXHRcdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKGogPSBtYXRjaEluZGV4ZXNbaV0pIF0gKSB7XG5cdFx0XHRcdFx0c2VlZFtqXSA9ICEobWF0Y2hlc1tqXSA9IHNlZWRbal0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIENoZWNrcyBhIG5vZGUgZm9yIHZhbGlkaXR5IGFzIGEgU2l6emxlIGNvbnRleHRcbiAqIEBwYXJhbSB7RWxlbWVudHxPYmplY3Q9fSBjb250ZXh0XG4gKiBAcmV0dXJucyB7RWxlbWVudHxPYmplY3R8Qm9vbGVhbn0gVGhlIGlucHV0IG5vZGUgaWYgYWNjZXB0YWJsZSwgb3RoZXJ3aXNlIGEgZmFsc3kgdmFsdWVcbiAqL1xuZnVuY3Rpb24gdGVzdENvbnRleHQoIGNvbnRleHQgKSB7XG5cdHJldHVybiBjb250ZXh0ICYmIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGNvbnRleHQ7XG59XG5cbi8vIEV4cG9zZSBzdXBwb3J0IHZhcnMgZm9yIGNvbnZlbmllbmNlXG5zdXBwb3J0ID0gU2l6emxlLnN1cHBvcnQgPSB7fTtcblxuLyoqXG4gKiBEZXRlY3RzIFhNTCBub2Rlc1xuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gZWxlbSBBbiBlbGVtZW50IG9yIGEgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtCb29sZWFufSBUcnVlIGlmZiBlbGVtIGlzIGEgbm9uLUhUTUwgWE1MIG5vZGVcbiAqL1xuaXNYTUwgPSBTaXp6bGUuaXNYTUwgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5hbWVzcGFjZSA9IGVsZW0ubmFtZXNwYWNlVVJJLFxuXHRcdGRvY0VsZW0gPSAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PThcblx0Ly8gQXNzdW1lIEhUTUwgd2hlbiBkb2N1bWVudEVsZW1lbnQgZG9lc24ndCB5ZXQgZXhpc3QsIHN1Y2ggYXMgaW5zaWRlIGxvYWRpbmcgaWZyYW1lc1xuXHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvNDgzM1xuXHRyZXR1cm4gIXJodG1sLnRlc3QoIG5hbWVzcGFjZSB8fCBkb2NFbGVtICYmIGRvY0VsZW0ubm9kZU5hbWUgfHwgXCJIVE1MXCIgKTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgc3ViV2luZG93LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCBwcmVmZXJyZWREb2MgIT09IGRvY3VtZW50ICYmXG5cdFx0KHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3KSAmJiBzdWJXaW5kb3cudG9wICE9PSBzdWJXaW5kb3cgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMSwgRWRnZVxuXHRcdGlmICggc3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRzdWJXaW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggc3ViV2luZG93LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0c3ViV2luZG93LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5jbGFzc05hbWUgPSBcImlcIjtcblx0XHRyZXR1cm4gIWVsLmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRlbC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlQ29tbWVudChcIlwiKSApO1xuXHRcdHJldHVybiAhZWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbW1hdGljYWxseS1zZXQgbmFtZXMsXG5cdC8vIHNvIHVzZSBhIHJvdW5kYWJvdXQgZ2V0RWxlbWVudHNCeU5hbWUgdGVzdFxuXHRzdXBwb3J0LmdldEJ5SWQgPSBhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaWQgPSBleHBhbmRvO1xuXHRcdHJldHVybiAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUgfHwgIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lKCBleHBhbmRvICkubGVuZ3RoO1xuXHR9KTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoXCJpZFwiKSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gIGZ1bmN0aW9uKCBpZCApIHtcblx0XHRcdHZhciBhdHRySWQgPSBpZC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgbm9kZSA9IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZU5vZGUgIT09IFwidW5kZWZpbmVkXCIgJiZcblx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0cmV0dXJuIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gYXR0cklkO1xuXHRcdFx0fTtcblx0XHR9O1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgNiAtIDcgb25seVxuXHRcdC8vIGdldEVsZW1lbnRCeUlkIGlzIG5vdCByZWxpYWJsZSBhcyBhIGZpbmQgc2hvcnRjdXRcblx0XHRFeHByLmZpbmRbXCJJRFwiXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRpZiAoIG5vZGUgJiYgbm9kZS52YWx1ZSA9PT0gaWQgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gRmFsbCBiYWNrIG9uIGdldEVsZW1lbnRzQnlOYW1lXG5cdFx0XHRcdFx0ZWxlbXMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlOYW1lKCBpZCApO1xuXHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtc1tpKytdKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoXCJpZFwiKTtcblx0XHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIFsgZWxlbSBdO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH1cblx0XHR9O1xuXHR9XG5cblx0Ly8gVGFnXG5cdEV4cHIuZmluZFtcIlRBR1wiXSA9IHN1cHBvcnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgP1xuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnICk7XG5cblx0XHRcdC8vIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgZG9uJ3QgaGF2ZSBnRUJUTlxuXHRcdFx0fSBlbHNlIGlmICggc3VwcG9ydC5xc2EgKSB7XG5cdFx0XHRcdHJldHVybiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyApO1xuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0ZnVuY3Rpb24oIHRhZywgY29udGV4dCApIHtcblx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHR0bXAgPSBbXSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGVsZW0gPSByZXN1bHRzW2krK10pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdFx0XHRcdHRtcC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRtcDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdH07XG5cblx0Ly8gQ2xhc3Ncblx0RXhwci5maW5kW1wiQ0xBU1NcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCJbbXNhbGxvd2NhcHR1cmVePScnXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlsqXiRdPVwiICsgd2hpdGVzcGFjZSArIFwiKig/OicnfFxcXCJcXFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gQm9vbGVhbiBhdHRyaWJ1dGVzIGFuZCBcInZhbHVlXCIgYXJlIG5vdCB0cmVhdGVkIGNvcnJlY3RseVxuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbChcIltzZWxlY3RlZF1cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKig/OnZhbHVlfFwiICsgYm9vbGVhbnMgKyBcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWU8MjksIEFuZHJvaWQ8NC40LCBTYWZhcmk8Ny4wKywgaU9TPDcuMCssIFBoYW50b21KUzwxLjkuOCtcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWVsLnF1ZXJ5U2VsZWN0b3JBbGwoXCI6Y2hlY2tlZFwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwiOmNoZWNrZWRcIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIi4jLitbK35dXCIpO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0YXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0XHRcdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nJyBkaXNhYmxlZD0nZGlzYWJsZWQnPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBkaXNhYmxlZD0nZGlzYWJsZWQnPjxvcHRpb24vPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBXaW5kb3dzIDggTmF0aXZlIEFwcHNcblx0XHRcdC8vIFRoZSB0eXBlIGFuZCBuYW1lIGF0dHJpYnV0ZXMgYXJlIHJlc3RyaWN0ZWQgZHVyaW5nIC5pbm5lckhUTUwgYXNzaWdubWVudFxuXHRcdFx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuXHRcdFx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJoaWRkZW5cIiApO1xuXHRcdFx0ZWwuYXBwZW5kQ2hpbGQoIGlucHV0ICkuc2V0QXR0cmlidXRlKCBcIm5hbWVcIiwgXCJEXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBFbmZvcmNlIGNhc2Utc2Vuc2l0aXZpdHkgb2YgbmFtZSBhdHRyaWJ1dGVcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbChcIjplbmFibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBJRSdzIDpkaXNhYmxlZCBzZWxlY3RvciBkb2VzIG5vdCBwaWNrIHVwIHRoZSBjaGlsZHJlbiBvZiBkaXNhYmxlZCBmaWVsZHNldHNcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuZGlzYWJsZWQgPSB0cnVlO1xuXHRcdFx0aWYgKCBlbC5xdWVyeVNlbGVjdG9yQWxsKFwiOmRpc2FibGVkXCIpLmxlbmd0aCAhPT0gMiApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiOmVuYWJsZWRcIiwgXCI6ZGlzYWJsZWRcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSk7XG5cdH1cblxuXHRyYnVnZ3lRU0EgPSByYnVnZ3lRU0EubGVuZ3RoICYmIG5ldyBSZWdFeHAoIHJidWdneVFTQS5qb2luKFwifFwiKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKFwifFwiKSApO1xuXG5cdC8qIENvbnRhaW5zXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblx0aGFzQ29tcGFyZSA9IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiApO1xuXG5cdC8vIEVsZW1lbnQgY29udGFpbnMgYW5vdGhlclxuXHQvLyBQdXJwb3NlZnVsbHkgc2VsZi1leGNsdXNpdmVcblx0Ly8gQXMgaW4sIGFuIGVsZW1lbnQgZG9lcyBub3QgY29udGFpbiBpdHNlbGZcblx0Y29udGFpbnMgPSBoYXNDb21wYXJlIHx8IHJuYXRpdmUudGVzdCggZG9jRWxlbS5jb250YWlucyApID9cblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdHZhciBhZG93biA9IGEubm9kZVR5cGUgPT09IDkgPyBhLmRvY3VtZW50RWxlbWVudCA6IGEsXG5cdFx0XHRcdGJ1cCA9IGIgJiYgYi5wYXJlbnROb2RlO1xuXHRcdFx0cmV0dXJuIGEgPT09IGJ1cCB8fCAhISggYnVwICYmIGJ1cC5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdGFkb3duLmNvbnRhaW5zID9cblx0XHRcdFx0XHRhZG93bi5jb250YWlucyggYnVwICkgOlxuXHRcdFx0XHRcdGEuY29tcGFyZURvY3VtZW50UG9zaXRpb24gJiYgYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYnVwICkgJiAxNlxuXHRcdFx0KSk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKGIgPSBiLnBhcmVudE5vZGUpICkge1xuXHRcdFx0XHRcdGlmICggYiA9PT0gYSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH07XG5cblx0LyogU29ydGluZ1xuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gRG9jdW1lbnQgb3JkZXIgc29ydGluZ1xuXHRzb3J0T3JkZXIgPSBoYXNDb21wYXJlID9cblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBGbGFnIGZvciBkdXBsaWNhdGUgcmVtb3ZhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHQvLyBTb3J0IG9uIG1ldGhvZCBleGlzdGVuY2UgaWYgb25seSBvbmUgaW5wdXQgaGFzIGNvbXBhcmVEb2N1bWVudFBvc2l0aW9uXG5cdFx0dmFyIGNvbXBhcmUgPSAhYS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAtICFiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uO1xuXHRcdGlmICggY29tcGFyZSApIHtcblx0XHRcdHJldHVybiBjb21wYXJlO1xuXHRcdH1cblxuXHRcdC8vIENhbGN1bGF0ZSBwb3NpdGlvbiBpZiBib3RoIGlucHV0cyBiZWxvbmcgdG8gdGhlIHNhbWUgZG9jdW1lbnRcblx0XHRjb21wYXJlID0gKCBhLm93bmVyRG9jdW1lbnQgfHwgYSApID09PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCFzdXBwb3J0LnNvcnREZXRhY2hlZCAmJiBiLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBhICkgPT09IGNvbXBhcmUpICkge1xuXG5cdFx0XHQvLyBDaG9vc2UgdGhlIGZpcnN0IGVsZW1lbnQgdGhhdCBpcyByZWxhdGVkIHRvIG91ciBwcmVmZXJyZWQgZG9jdW1lbnRcblx0XHRcdGlmICggYSA9PT0gZG9jdW1lbnQgfHwgYS5vd25lckRvY3VtZW50ID09PSBwcmVmZXJyZWREb2MgJiYgY29udGFpbnMocHJlZmVycmVkRG9jLCBhKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCBiID09PSBkb2N1bWVudCB8fCBiLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGIpICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0Ly8gRXhpdCBlYXJseSBpZiB0aGUgbm9kZXMgYXJlIGlkZW50aWNhbFxuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0XHRyZXR1cm4gMDtcblx0XHR9XG5cblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdXAgPSBhLnBhcmVudE5vZGUsXG5cdFx0XHRidXAgPSBiLnBhcmVudE5vZGUsXG5cdFx0XHRhcCA9IFsgYSBdLFxuXHRcdFx0YnAgPSBbIGIgXTtcblxuXHRcdC8vIFBhcmVudGxlc3Mgbm9kZXMgYXJlIGVpdGhlciBkb2N1bWVudHMgb3IgZGlzY29ubmVjdGVkXG5cdFx0aWYgKCAhYXVwIHx8ICFidXAgKSB7XG5cdFx0XHRyZXR1cm4gYSA9PT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT09IGRvY3VtZW50ID8gMSA6XG5cdFx0XHRcdGF1cCA/IC0xIDpcblx0XHRcdFx0YnVwID8gMSA6XG5cdFx0XHRcdHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblxuXHRcdC8vIElmIHRoZSBub2RlcyBhcmUgc2libGluZ3MsIHdlIGNhbiBkbyBhIHF1aWNrIGNoZWNrXG5cdFx0fSBlbHNlIGlmICggYXVwID09PSBidXAgKSB7XG5cdFx0XHRyZXR1cm4gc2libGluZ0NoZWNrKCBhLCBiICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlIHdlIG5lZWQgZnVsbCBsaXN0cyBvZiB0aGVpciBhbmNlc3RvcnMgZm9yIGNvbXBhcmlzb25cblx0XHRjdXIgPSBhO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGFwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblx0XHRjdXIgPSBiO1xuXHRcdHdoaWxlICggKGN1ciA9IGN1ci5wYXJlbnROb2RlKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFtpXSA9PT0gYnBbaV0gKSB7XG5cdFx0XHRpKys7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGkgP1xuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwW2ldLCBicFtpXSApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIG5vZGVzIGluIG91ciBkb2N1bWVudCBzb3J0IGZpcnN0XG5cdFx0XHRhcFtpXSA9PT0gcHJlZmVycmVkRG9jID8gLTEgOlxuXHRcdFx0YnBbaV0gPT09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0MDtcblx0fTtcblxuXHRyZXR1cm4gZG9jdW1lbnQ7XG59O1xuXG5TaXp6bGUubWF0Y2hlcyA9IGZ1bmN0aW9uKCBleHByLCBlbGVtZW50cyApIHtcblx0cmV0dXJuIFNpenpsZSggZXhwciwgbnVsbCwgbnVsbCwgZWxlbWVudHMgKTtcbn07XG5cblNpenpsZS5tYXRjaGVzU2VsZWN0b3IgPSBmdW5jdGlvbiggZWxlbSwgZXhwciApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cdFx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0XHQvLyBmcmFnbWVudCBpbiBJRSA5XG5cdFx0XHRcdFx0ZWxlbS5kb2N1bWVudCAmJiBlbGVtLmRvY3VtZW50Lm5vZGVUeXBlICE9PSAxMSApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBleHByLCB0cnVlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIFNpenpsZSggZXhwciwgZG9jdW1lbnQsIG51bGwsIFsgZWxlbSBdICkubGVuZ3RoID4gMDtcbn07XG5cblNpenpsZS5jb250YWlucyA9IGZ1bmN0aW9uKCBjb250ZXh0LCBlbGVtICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBjb250ZXh0ICk7XG5cdH1cblx0cmV0dXJuIGNvbnRhaW5zKCBjb250ZXh0LCBlbGVtICk7XG59O1xuXG5TaXp6bGUuYXR0ciA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXHRcdC8vIERvbid0IGdldCBmb29sZWQgYnkgT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzIChqUXVlcnkgIzEzODA3KVxuXHRcdHZhbCA9IGZuICYmIGhhc093bi5jYWxsKCBFeHByLmF0dHJIYW5kbGUsIG5hbWUudG9Mb3dlckNhc2UoKSApID9cblx0XHRcdGZuKCBlbGVtLCBuYW1lLCAhZG9jdW1lbnRJc0hUTUwgKSA6XG5cdFx0XHR1bmRlZmluZWQ7XG5cblx0cmV0dXJuIHZhbCAhPT0gdW5kZWZpbmVkID9cblx0XHR2YWwgOlxuXHRcdHN1cHBvcnQuYXR0cmlidXRlcyB8fCAhZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKSA6XG5cdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKG5hbWUpKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKHNlbCArIFwiXCIpLnJlcGxhY2UoIHJjc3Nlc2NhcGUsIGZjc3Nlc2NhcGUgKTtcbn07XG5cblNpenpsZS5lcnJvciA9IGZ1bmN0aW9uKCBtc2cgKSB7XG5cdHRocm93IG5ldyBFcnJvciggXCJTeW50YXggZXJyb3IsIHVucmVjb2duaXplZCBleHByZXNzaW9uOiBcIiArIG1zZyApO1xufTtcblxuLyoqXG4gKiBEb2N1bWVudCBzb3J0aW5nIGFuZCByZW1vdmluZyBkdXBsaWNhdGVzXG4gKiBAcGFyYW0ge0FycmF5TGlrZX0gcmVzdWx0c1xuICovXG5TaXp6bGUudW5pcXVlU29ydCA9IGZ1bmN0aW9uKCByZXN1bHRzICkge1xuXHR2YXIgZWxlbSxcblx0XHRkdXBsaWNhdGVzID0gW10sXG5cdFx0aiA9IDAsXG5cdFx0aSA9IDA7XG5cblx0Ly8gVW5sZXNzIHdlICprbm93KiB3ZSBjYW4gZGV0ZWN0IGR1cGxpY2F0ZXMsIGFzc3VtZSB0aGVpciBwcmVzZW5jZVxuXHRoYXNEdXBsaWNhdGUgPSAhc3VwcG9ydC5kZXRlY3REdXBsaWNhdGVzO1xuXHRzb3J0SW5wdXQgPSAhc3VwcG9ydC5zb3J0U3RhYmxlICYmIHJlc3VsdHMuc2xpY2UoIDAgKTtcblx0cmVzdWx0cy5zb3J0KCBzb3J0T3JkZXIgKTtcblxuXHRpZiAoIGhhc0R1cGxpY2F0ZSApIHtcblx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblx0XHQvLyBJZiBubyBub2RlVHlwZSwgdGhpcyBpcyBleHBlY3RlZCB0byBiZSBhbiBhcnJheVxuXHRcdHdoaWxlICggKG5vZGUgPSBlbGVtW2krK10pICkge1xuXHRcdFx0Ly8gRG8gbm90IHRyYXZlcnNlIGNvbW1lbnQgbm9kZXNcblx0XHRcdHJldCArPSBnZXRUZXh0KCBub2RlICk7XG5cdFx0fVxuXHR9IGVsc2UgaWYgKCBub2RlVHlwZSA9PT0gMSB8fCBub2RlVHlwZSA9PT0gOSB8fCBub2RlVHlwZSA9PT0gMTEgKSB7XG5cdFx0Ly8gVXNlIHRleHRDb250ZW50IGZvciBlbGVtZW50c1xuXHRcdC8vIGlubmVyVGV4dCB1c2FnZSByZW1vdmVkIGZvciBjb25zaXN0ZW5jeSBvZiBuZXcgbGluZXMgKGpRdWVyeSAjMTExNTMpXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS50ZXh0Q29udGVudCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLnRleHRDb250ZW50O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cdC8vIERvIG5vdCBpbmNsdWRlIGNvbW1lbnQgb3IgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbiBub2Rlc1xuXG5cdHJldHVybiByZXQ7XG59O1xuXG5FeHByID0gU2l6emxlLnNlbGVjdG9ycyA9IHtcblxuXHQvLyBDYW4gYmUgYWRqdXN0ZWQgYnkgdGhlIHVzZXJcblx0Y2FjaGVMZW5ndGg6IDUwLFxuXG5cdGNyZWF0ZVBzZXVkbzogbWFya0Z1bmN0aW9uLFxuXG5cdG1hdGNoOiBtYXRjaEV4cHIsXG5cblx0YXR0ckhhbmRsZToge30sXG5cblx0ZmluZDoge30sXG5cblx0cmVsYXRpdmU6IHtcblx0XHRcIj5cIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiIFwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIgfSxcblx0XHRcIitcIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCJ+XCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiIH1cblx0fSxcblxuXHRwcmVGaWx0ZXI6IHtcblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbM10gPSAoIG1hdGNoWzNdIHx8IG1hdGNoWzRdIHx8IG1hdGNoWzVdIHx8IFwiXCIgKS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzJdID09PSBcIn49XCIgKSB7XG5cdFx0XHRcdG1hdGNoWzNdID0gXCIgXCIgKyBtYXRjaFszXSArIFwiIFwiO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDQgKTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHQvKiBtYXRjaGVzIGZyb20gbWF0Y2hFeHByW1wiQ0hJTERcIl1cblx0XHRcdFx0MSB0eXBlIChvbmx5fG50aHwuLi4pXG5cdFx0XHRcdDIgd2hhdCAoY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0MyBhcmd1bWVudCAoZXZlbnxvZGR8XFxkKnxcXGQqbihbKy1dXFxkKyk/fC4uLilcblx0XHRcdFx0NCB4bi1jb21wb25lbnQgb2YgeG4reSBhcmd1bWVudCAoWystXT9cXGQqbnwpXG5cdFx0XHRcdDUgc2lnbiBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NiB4IG9mIHhuLWNvbXBvbmVudFxuXHRcdFx0XHQ3IHNpZ24gb2YgeS1jb21wb25lbnRcblx0XHRcdFx0OCB5IG9mIHktY29tcG9uZW50XG5cdFx0XHQqL1xuXHRcdFx0bWF0Y2hbMV0gPSBtYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuXG5cdFx0XHRpZiAoIG1hdGNoWzFdLnNsaWNlKCAwLCAzICkgPT09IFwibnRoXCIgKSB7XG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWzNdICkge1xuXHRcdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIG51bWVyaWMgeCBhbmQgeSBwYXJhbWV0ZXJzIGZvciBFeHByLmZpbHRlci5DSElMRFxuXHRcdFx0XHQvLyByZW1lbWJlciB0aGF0IGZhbHNlL3RydWUgY2FzdCByZXNwZWN0aXZlbHkgdG8gMC8xXG5cdFx0XHRcdG1hdGNoWzRdID0gKyggbWF0Y2hbNF0gPyBtYXRjaFs1XSArIChtYXRjaFs2XSB8fCAxKSA6IDIgKiAoIG1hdGNoWzNdID09PSBcImV2ZW5cIiB8fCBtYXRjaFszXSA9PT0gXCJvZGRcIiApICk7XG5cdFx0XHRcdG1hdGNoWzVdID0gKyggKCBtYXRjaFs3XSArIG1hdGNoWzhdICkgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0Ly8gb3RoZXIgdHlwZXMgcHJvaGliaXQgYXJndW1lbnRzXG5cdFx0XHR9IGVsc2UgaWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFswXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWzZdICYmIG1hdGNoWzJdO1xuXG5cdFx0XHRpZiAoIG1hdGNoRXhwcltcIkNISUxEXCJdLnRlc3QoIG1hdGNoWzBdICkgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBY2NlcHQgcXVvdGVkIGFyZ3VtZW50cyBhcy1pc1xuXHRcdFx0aWYgKCBtYXRjaFszXSApIHtcblx0XHRcdFx0bWF0Y2hbMl0gPSBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiO1xuXG5cdFx0XHQvLyBTdHJpcCBleGNlc3MgY2hhcmFjdGVycyBmcm9tIHVucXVvdGVkIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggdW5xdW90ZWQgJiYgcnBzZXVkby50ZXN0KCB1bnF1b3RlZCApICYmXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdChleGNlc3MgPSB0b2tlbml6ZSggdW5xdW90ZWQsIHRydWUgKSkgJiZcblx0XHRcdFx0Ly8gYWR2YW5jZSB0byB0aGUgbmV4dCBjbG9zaW5nIHBhcmVudGhlc2lzXG5cdFx0XHRcdChleGNlc3MgPSB1bnF1b3RlZC5pbmRleE9mKCBcIilcIiwgdW5xdW90ZWQubGVuZ3RoIC0gZXhjZXNzICkgLSB1bnF1b3RlZC5sZW5ndGgpICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAsIGV4Y2VzcyApO1xuXHRcdFx0XHRtYXRjaFsyXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiB0cnVlOyB9IDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBub2RlTmFtZTtcblx0XHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDTEFTU1wiOiBmdW5jdGlvbiggY2xhc3NOYW1lICkge1xuXHRcdFx0dmFyIHBhdHRlcm4gPSBjbGFzc0NhY2hlWyBjbGFzc05hbWUgKyBcIiBcIiBdO1xuXG5cdFx0XHRyZXR1cm4gcGF0dGVybiB8fFxuXHRcdFx0XHQocGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICsgXCIpXCIgKyBjbGFzc05hbWUgKyBcIihcIiArIHdoaXRlc3BhY2UgKyBcInwkKVwiICkpICYmXG5cdFx0XHRcdGNsYXNzQ2FjaGUoIGNsYXNzTmFtZSwgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHBhdHRlcm4udGVzdCggdHlwZW9mIGVsZW0uY2xhc3NOYW1lID09PSBcInN0cmluZ1wiICYmIGVsZW0uY2xhc3NOYW1lIHx8IHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBlbGVtLmdldEF0dHJpYnV0ZShcImNsYXNzXCIpIHx8IFwiXCIgKTtcblx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSBcIj1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIiE9XCIgPyByZXN1bHQgIT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJePVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPT09IDAgOlxuXHRcdFx0XHRcdG9wZXJhdG9yID09PSBcIio9XCIgPyBjaGVjayAmJiByZXN1bHQuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIkPVwiID8gY2hlY2sgJiYgcmVzdWx0LnNsaWNlKCAtY2hlY2subGVuZ3RoICkgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ+PVwiID8gKCBcIiBcIiArIHJlc3VsdC5yZXBsYWNlKCByd2hpdGVzcGFjZSwgXCIgXCIgKSArIFwiIFwiICkuaW5kZXhPZiggY2hlY2sgKSA+IC0xIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCJ8PVwiID8gcmVzdWx0ID09PSBjaGVjayB8fCByZXN1bHQuc2xpY2UoIDAsIGNoZWNrLmxlbmd0aCArIDEgKSA9PT0gY2hlY2sgKyBcIi1cIiA6XG5cdFx0XHRcdFx0ZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCB0eXBlLCB3aGF0LCBhcmd1bWVudCwgZmlyc3QsIGxhc3QgKSB7XG5cdFx0XHR2YXIgc2ltcGxlID0gdHlwZS5zbGljZSggMCwgMyApICE9PSBcIm50aFwiLFxuXHRcdFx0XHRmb3J3YXJkID0gdHlwZS5zbGljZSggLTQgKSAhPT0gXCJsYXN0XCIsXG5cdFx0XHRcdG9mVHlwZSA9IHdoYXQgPT09IFwib2YtdHlwZVwiO1xuXG5cdFx0XHRyZXR1cm4gZmlyc3QgPT09IDEgJiYgbGFzdCA9PT0gMCA/XG5cblx0XHRcdFx0Ly8gU2hvcnRjdXQgZm9yIDpudGgtKihuKVxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gISFlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRcdH0gOlxuXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gbm9kZVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0Ly8gUmV2ZXJzZSBkaXJlY3Rpb24gZm9yIDpvbmx5LSogKGlmIHdlIGhhdmVuJ3QgeWV0IGRvbmUgc28pXG5cdFx0XHRcdFx0XHRcdFx0c3RhcnQgPSBkaXIgPSB0eXBlID09PSBcIm9ubHlcIiAmJiAhc3RhcnQgJiYgXCJuZXh0U2libGluZ1wiO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRzdGFydCA9IFsgZm9yd2FyZCA/IHBhcmVudC5maXJzdENoaWxkIDogcGFyZW50Lmxhc3RDaGlsZCBdO1xuXG5cdFx0XHRcdFx0XHQvLyBub24teG1sIDpudGgtY2hpbGQoLi4uKSBzdG9yZXMgY2FjaGUgZGF0YSBvbiBgcGFyZW50YFxuXHRcdFx0XHRcdFx0aWYgKCBmb3J3YXJkICYmIHVzZUNhY2hlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFNlZWsgYGVsZW1gIGZyb20gYSBwcmV2aW91c2x5LWNhY2hlZCBpbmRleFxuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0bm9kZSA9IHBhcmVudDtcblx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleCAmJiBjYWNoZVsgMiBdO1xuXHRcdFx0XHRcdFx0XHRub2RlID0gbm9kZUluZGV4ICYmIHBhcmVudC5jaGlsZE5vZGVzWyBub2RlSW5kZXggXTtcblxuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIChub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gVXNlIHByZXZpb3VzbHktY2FjaGVkIGVsZW1lbnQgaW5kZXggaWYgYXZhaWxhYmxlXG5cdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0Ly8gLi4uaW4gYSBnemlwLWZyaWVuZGx5IHdheVxuXHRcdFx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtO1xuXHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdFx0ZGlmZiA9IG5vZGVJbmRleDtcblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHhtbCA6bnRoLWNoaWxkKC4uLilcblx0XHRcdFx0XHRcdFx0Ly8gb3IgOm50aC1sYXN0LWNoaWxkKC4uLikgb3IgOm50aCgtbGFzdCk/LW9mLXR5cGUoLi4uKVxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpZmYgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIFVzZSB0aGUgc2FtZSBsb29wIGFzIGFib3ZlIHRvIHNlZWsgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChkaWZmID0gbm9kZUluZGV4ID0gMCkgfHwgc3RhcnQucG9wKCkpICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCsrZGlmZiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBDYWNoZSB0aGUgaW5kZXggb2YgZWFjaCBlbmNvdW50ZXJlZCBlbGVtZW50XG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggdXNlQ2FjaGUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IG5vZGVbIGV4cGFuZG8gXSB8fCAobm9kZVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQob3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdC8vIEluY29ycG9yYXRlIHRoZSBvZmZzZXQsIHRoZW4gY2hlY2sgYWdhaW5zdCBjeWNsZSBzaXplXG5cdFx0XHRcdFx0XHRkaWZmIC09IGxhc3Q7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZGlmZiA9PT0gZmlyc3QgfHwgKCBkaWZmICUgZmlyc3QgPT09IDAgJiYgZGlmZiAvIGZpcnN0ID49IDAgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBwc2V1ZG8sIGFyZ3VtZW50ICkge1xuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzICkge1xuXHRcdFx0XHRcdFx0dmFyIGlkeCxcblx0XHRcdFx0XHRcdFx0bWF0Y2hlZCA9IGZuKCBzZWVkLCBhcmd1bWVudCApLFxuXHRcdFx0XHRcdFx0XHRpID0gbWF0Y2hlZC5sZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWR4ID0gaW5kZXhPZiggc2VlZCwgbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFtpXSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0pIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXHRcdC8vIFBvdGVudGlhbGx5IGNvbXBsZXggcHNldWRvc1xuXHRcdFwibm90XCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHQvLyBUcmltIHRoZSBzZWxlY3RvciBwYXNzZWQgdG8gY29tcGlsZVxuXHRcdFx0Ly8gdG8gYXZvaWQgdHJlYXRpbmcgbGVhZGluZyBhbmQgdHJhaWxpbmdcblx0XHRcdC8vIHNwYWNlcyBhcyBjb21iaW5hdG9yc1xuXHRcdFx0dmFyIGlucHV0ID0gW10sXG5cdFx0XHRcdHJlc3VsdHMgPSBbXSxcblx0XHRcdFx0bWF0Y2hlciA9IGNvbXBpbGUoIHNlbGVjdG9yLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSApO1xuXG5cdFx0XHRyZXR1cm4gbWF0Y2hlclsgZXhwYW5kbyBdID9cblx0XHRcdFx0bWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGVsZW0sXG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQgPSBtYXRjaGVyKCBzZWVkLCBudWxsLCB4bWwsIFtdICksXG5cdFx0XHRcdFx0XHRpID0gc2VlZC5sZW5ndGg7XG5cblx0XHRcdFx0XHQvLyBNYXRjaCBlbGVtZW50cyB1bm1hdGNoZWQgYnkgYG1hdGNoZXJgXG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0c2VlZFtpXSA9ICEobWF0Y2hlc1tpXSA9IGVsZW0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdGlucHV0WzBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cdFx0XHRcdFx0Ly8gRG9uJ3Qga2VlcCB0aGUgZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdFx0XHRpbnB1dFswXSA9IG51bGw7XG5cdFx0XHRcdFx0cmV0dXJuICFyZXN1bHRzLnBvcCgpO1xuXHRcdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0XCJoYXNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiY29udGFpbnNcIjogbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdFx0dGV4dCA9IHRleHQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuICggZWxlbS50ZXh0Q29udGVudCB8fCBnZXRUZXh0KCBlbGVtICkgKS5pbmRleE9mKCB0ZXh0ICkgPiAtMTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXHRcdFx0Ly8gbGFuZyB2YWx1ZSBtdXN0IGJlIGEgdmFsaWQgaWRlbnRpZmllclxuXHRcdFx0aWYgKCAhcmlkZW50aWZpZXIudGVzdChsYW5nIHx8IFwiXCIpICkge1xuXHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgbGFuZzogXCIgKyBsYW5nICk7XG5cdFx0XHR9XG5cdFx0XHRsYW5nID0gbGFuZy5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBlbGVtTGFuZztcblx0XHRcdFx0ZG8ge1xuXHRcdFx0XHRcdGlmICggKGVsZW1MYW5nID0gZG9jdW1lbnRJc0hUTUwgP1xuXHRcdFx0XHRcdFx0ZWxlbS5sYW5nIDpcblx0XHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKFwieG1sOmxhbmdcIikgfHwgZWxlbS5nZXRBdHRyaWJ1dGUoXCJsYW5nXCIpKSApIHtcblxuXHRcdFx0XHRcdFx0ZWxlbUxhbmcgPSBlbGVtTGFuZy50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW1MYW5nID09PSBsYW5nIHx8IGVsZW1MYW5nLmluZGV4T2YoIGxhbmcgKyBcIi1cIiApID09PSAwO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSB3aGlsZSAoIChlbGVtID0gZWxlbS5wYXJlbnROb2RlKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHQvLyBNaXNjZWxsYW5lb3VzXG5cdFx0XCJ0YXJnZXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgaGFzaCA9IHdpbmRvdy5sb2NhdGlvbiAmJiB3aW5kb3cubG9jYXRpb24uaGFzaDtcblx0XHRcdHJldHVybiBoYXNoICYmIGhhc2guc2xpY2UoIDEgKSA9PT0gZWxlbS5pZDtcblx0XHR9LFxuXG5cdFx0XCJyb290XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY0VsZW07XG5cdFx0fSxcblxuXHRcdFwiZm9jdXNcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAmJiAoIWRvY3VtZW50Lmhhc0ZvY3VzIHx8IGRvY3VtZW50Lmhhc0ZvY3VzKCkpICYmICEhKGVsZW0udHlwZSB8fCBlbGVtLmhyZWYgfHwgfmVsZW0udGFiSW5kZXgpO1xuXHRcdH0sXG5cblx0XHQvLyBCb29sZWFuIHByb3BlcnRpZXNcblx0XHRcImVuYWJsZWRcIjogY3JlYXRlRGlzYWJsZWRQc2V1ZG8oIGZhbHNlICksXG5cdFx0XCJkaXNhYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggdHJ1ZSApLFxuXG5cdFx0XCJjaGVja2VkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0Ly8gSW4gQ1NTMywgOmNoZWNrZWQgc2hvdWxkIHJldHVybiBib3RoIGNoZWNrZWQgYW5kIHNlbGVjdGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0dmFyIG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIChub2RlTmFtZSA9PT0gXCJpbnB1dFwiICYmICEhZWxlbS5jaGVja2VkKSB8fCAobm9kZU5hbWUgPT09IFwib3B0aW9uXCIgJiYgISFlbGVtLnNlbGVjdGVkKTtcblx0XHR9LFxuXG5cdFx0XCJzZWxlY3RlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEFjY2Vzc2luZyB0aGlzIHByb3BlcnR5IG1ha2VzIHNlbGVjdGVkLWJ5LWRlZmF1bHRcblx0XHRcdC8vIG9wdGlvbnMgaW4gU2FmYXJpIHdvcmsgcHJvcGVybHlcblx0XHRcdGlmICggZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jZW1wdHktcHNldWRvXG5cdFx0XHQvLyA6ZW1wdHkgaXMgbmVnYXRlZCBieSBlbGVtZW50ICgxKSBvciBjb250ZW50IG5vZGVzICh0ZXh0OiAzOyBjZGF0YTogNDsgZW50aXR5IHJlZjogNSksXG5cdFx0XHQvLyAgIGJ1dCBub3QgYnkgb3RoZXJzIChjb21tZW50OiA4OyBwcm9jZXNzaW5nIGluc3RydWN0aW9uOiA3OyBldGMuKVxuXHRcdFx0Ly8gbm9kZVR5cGUgPCA2IHdvcmtzIGJlY2F1c2UgYXR0cmlidXRlcyAoMikgZG8gbm90IGFwcGVhciBhcyBjaGlsZHJlblxuXHRcdFx0Zm9yICggZWxlbSA9IGVsZW0uZmlyc3RDaGlsZDsgZWxlbTsgZWxlbSA9IGVsZW0ubmV4dFNpYmxpbmcgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA8IDYgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9LFxuXG5cdFx0XCJwYXJlbnRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gIUV4cHIucHNldWRvc1tcImVtcHR5XCJdKCBlbGVtICk7XG5cdFx0fSxcblxuXHRcdC8vIEVsZW1lbnQvaW5wdXQgdHlwZXNcblx0XHRcImhlYWRlclwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaGVhZGVyLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJpbnB1dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiByaW5wdXRzLnRlc3QoIGVsZW0ubm9kZU5hbWUgKTtcblx0XHR9LFxuXG5cdFx0XCJidXR0b25cIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBuYW1lID09PSBcImlucHV0XCIgJiYgZWxlbS50eXBlID09PSBcImJ1dHRvblwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCI7XG5cdFx0fSxcblxuXHRcdFwidGV4dFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBhdHRyO1xuXHRcdFx0cmV0dXJuIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICYmXG5cdFx0XHRcdGVsZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTw4XG5cdFx0XHRcdC8vIE5ldyBIVE1MNSBhdHRyaWJ1dGUgdmFsdWVzIChlLmcuLCBcInNlYXJjaFwiKSBhcHBlYXIgd2l0aCBlbGVtLnR5cGUgPT09IFwidGV4dFwiXG5cdFx0XHRcdCggKGF0dHIgPSBlbGVtLmdldEF0dHJpYnV0ZShcInR5cGVcIikpID09IG51bGwgfHwgYXR0ci50b0xvd2VyQ2FzZSgpID09PSBcInRleHRcIiApO1xuXHRcdH0sXG5cblx0XHQvLyBQb3NpdGlvbi1pbi1jb2xsZWN0aW9uXG5cdFx0XCJmaXJzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFsgMCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIFsgbGVuZ3RoIC0gMSBdO1xuXHRcdH0pLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHRyZXR1cm4gWyBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50IF07XG5cdFx0fSksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcIm9kZFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwibHRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgP1xuXHRcdFx0XHRhcmd1bWVudCArIGxlbmd0aCA6XG5cdFx0XHRcdGFyZ3VtZW50ID4gbGVuZ3RoID9cblx0XHRcdFx0XHRsZW5ndGggOlxuXHRcdFx0XHRcdGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyAtLWkgPj0gMDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7ICsraSA8IGxlbmd0aDsgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pXG5cdH1cbn07XG5cbkV4cHIucHNldWRvc1tcIm50aFwiXSA9IEV4cHIucHNldWRvc1tcImVxXCJdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAobWF0Y2ggPSByY29tbWEuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRpZiAoIG1hdGNoICkge1xuXHRcdFx0XHQvLyBEb24ndCBjb25zdW1lIHRyYWlsaW5nIGNvbW1hcyBhcyB2YWxpZFxuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaFswXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAodG9rZW5zID0gW10pICk7XG5cdFx0fVxuXG5cdFx0bWF0Y2hlZCA9IGZhbHNlO1xuXG5cdFx0Ly8gQ29tYmluYXRvcnNcblx0XHRpZiAoIChtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApKSApIHtcblx0XHRcdG1hdGNoZWQgPSBtYXRjaC5zaGlmdCgpO1xuXHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0Ly8gQ2FzdCBkZXNjZW5kYW50IGNvbWJpbmF0b3JzIHRvIHNwYWNlXG5cdFx0XHRcdHR5cGU6IG1hdGNoWzBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9KTtcblx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0fVxuXG5cdFx0Ly8gRmlsdGVyc1xuXHRcdGZvciAoIHR5cGUgaW4gRXhwci5maWx0ZXIgKSB7XG5cdFx0XHRpZiAoIChtYXRjaCA9IG1hdGNoRXhwclsgdHlwZSBdLmV4ZWMoIHNvRmFyICkpICYmICghcHJlRmlsdGVyc1sgdHlwZSBdIHx8XG5cdFx0XHRcdChtYXRjaCA9IHByZUZpbHRlcnNbIHR5cGUgXSggbWF0Y2ggKSkpICkge1xuXHRcdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdFx0dG9rZW5zLnB1c2goe1xuXHRcdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXHRcdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdFx0bWF0Y2hlczogbWF0Y2hcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblx0XHRcdC8vIENhY2hlIHRoZSB0b2tlbnNcblx0XHRcdHRva2VuQ2FjaGUoIHNlbGVjdG9yLCBncm91cHMgKS5zbGljZSggMCApO1xufTtcblxuZnVuY3Rpb24gdG9TZWxlY3RvciggdG9rZW5zICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gdG9rZW5zLmxlbmd0aCxcblx0XHRzZWxlY3RvciA9IFwiXCI7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdHNlbGVjdG9yICs9IHRva2Vuc1tpXS52YWx1ZTtcblx0fVxuXHRyZXR1cm4gc2VsZWN0b3I7XG59XG5cbmZ1bmN0aW9uIGFkZENvbWJpbmF0b3IoIG1hdGNoZXIsIGNvbWJpbmF0b3IsIGJhc2UgKSB7XG5cdHZhciBkaXIgPSBjb21iaW5hdG9yLmRpcixcblx0XHRza2lwID0gY29tYmluYXRvci5uZXh0LFxuXHRcdGtleSA9IHNraXAgfHwgZGlyLFxuXHRcdGNoZWNrTm9uRWxlbWVudHMgPSBiYXNlICYmIGtleSA9PT0gXCJwYXJlbnROb2RlXCIsXG5cdFx0ZG9uZU5hbWUgPSBkb25lKys7XG5cblx0cmV0dXJuIGNvbWJpbmF0b3IuZmlyc3QgP1xuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IDpcblxuXHRcdC8vIENoZWNrIGFnYWluc3QgYWxsIGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50c1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgb2xkQ2FjaGUsIHVuaXF1ZUNhY2hlLCBvdXRlckNhY2hlLFxuXHRcdFx0XHRuZXdDYWNoZSA9IFsgZGlycnVucywgZG9uZU5hbWUgXTtcblxuXHRcdFx0Ly8gV2UgY2FuJ3Qgc2V0IGFyYml0cmFyeSBkYXRhIG9uIFhNTCBub2Rlcywgc28gdGhleSBkb24ndCBiZW5lZml0IGZyb20gY29tYmluYXRvciBjYWNoaW5nXG5cdFx0XHRpZiAoIHhtbCApIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0d2hpbGUgKCAoZWxlbSA9IGVsZW1bIGRpciBdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKGVsZW1bIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPDkgb25seVxuXHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIGVsZW0udW5pcXVlSUQgXSB8fCAob3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHRpZiAoIHNraXAgJiYgc2tpcCA9PT0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRlbGVtID0gZWxlbVsgZGlyIF0gfHwgZWxlbTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIChvbGRDYWNoZSA9IHVuaXF1ZUNhY2hlWyBrZXkgXSkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKG5ld0NhY2hlWyAyIF0gPSBvbGRDYWNoZVsgMiBdKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJldXNlIG5ld2NhY2hlIHNvIHJlc3VsdHMgYmFjay1wcm9wYWdhdGUgdG8gcHJldmlvdXMgZWxlbWVudHNcblx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIGtleSBdID0gbmV3Q2FjaGU7XG5cblx0XHRcdFx0XHRcdFx0Ly8gQSBtYXRjaCBtZWFucyB3ZSdyZSBkb25lOyBhIGZhaWwgbWVhbnMgd2UgaGF2ZSB0byBrZWVwIGNoZWNraW5nXG5cdFx0XHRcdFx0XHRcdGlmICggKG5ld0NhY2hlWyAyIF0gPSBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbaV0oIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSA6XG5cdFx0bWF0Y2hlcnNbMF07XG59XG5cbmZ1bmN0aW9uIG11bHRpcGxlQ29udGV4dHMoIHNlbGVjdG9yLCBjb250ZXh0cywgcmVzdWx0cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGNvbnRleHRzLmxlbmd0aDtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0U2l6emxlKCBzZWxlY3RvciwgY29udGV4dHNbaV0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChlbGVtID0gdW5tYXRjaGVkW2ldKSApIHtcblx0XHRcdGlmICggIWZpbHRlciB8fCBmaWx0ZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRuZXdVbm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRpZiAoIG1hcHBlZCApIHtcblx0XHRcdFx0XHRtYXAucHVzaCggaSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG5ld1VubWF0Y2hlZDtcbn1cblxuZnVuY3Rpb24gc2V0TWF0Y2hlciggcHJlRmlsdGVyLCBzZWxlY3RvciwgbWF0Y2hlciwgcG9zdEZpbHRlciwgcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICkge1xuXHRpZiAoIHBvc3RGaWx0ZXIgJiYgIXBvc3RGaWx0ZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmlsdGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbHRlciApO1xuXHR9XG5cdGlmICggcG9zdEZpbmRlciAmJiAhcG9zdEZpbmRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaW5kZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKTtcblx0fVxuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKGZ1bmN0aW9uKCBzZWVkLCByZXN1bHRzLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0dmFyIHRlbXAsIGksIGVsZW0sXG5cdFx0XHRwcmVNYXAgPSBbXSxcblx0XHRcdHBvc3RNYXAgPSBbXSxcblx0XHRcdHByZWV4aXN0aW5nID0gcmVzdWx0cy5sZW5ndGgsXG5cblx0XHRcdC8vIEdldCBpbml0aWFsIGVsZW1lbnRzIGZyb20gc2VlZCBvciBjb250ZXh0XG5cdFx0XHRlbGVtcyA9IHNlZWQgfHwgbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IgfHwgXCIqXCIsIGNvbnRleHQubm9kZVR5cGUgPyBbIGNvbnRleHQgXSA6IGNvbnRleHQsIFtdICksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBhIHBvc3RGaW5kZXIsIG9yIGZpbHRlcmVkIHNlZWQsIG9yIG5vbi1zZWVkIHBvc3RGaWx0ZXIgb3IgcHJlZXhpc3RpbmcgcmVzdWx0cyxcblx0XHRcdFx0cG9zdEZpbmRlciB8fCAoIHNlZWQgPyBwcmVGaWx0ZXIgOiBwcmVleGlzdGluZyB8fCBwb3N0RmlsdGVyICkgP1xuXG5cdFx0XHRcdFx0Ly8gLi4uaW50ZXJtZWRpYXRlIHByb2Nlc3NpbmcgaXMgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0W10gOlxuXG5cdFx0XHRcdFx0Ly8gLi4ub3RoZXJ3aXNlIHVzZSByZXN1bHRzIGRpcmVjdGx5XG5cdFx0XHRcdFx0cmVzdWx0cyA6XG5cdFx0XHRcdG1hdGNoZXJJbjtcblxuXHRcdC8vIEZpbmQgcHJpbWFyeSBtYXRjaGVzXG5cdFx0aWYgKCBtYXRjaGVyICkge1xuXHRcdFx0bWF0Y2hlciggbWF0Y2hlckluLCBtYXRjaGVyT3V0LCBjb250ZXh0LCB4bWwgKTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSBwb3N0RmlsdGVyXG5cdFx0aWYgKCBwb3N0RmlsdGVyICkge1xuXHRcdFx0dGVtcCA9IGNvbmRlbnNlKCBtYXRjaGVyT3V0LCBwb3N0TWFwICk7XG5cdFx0XHRwb3N0RmlsdGVyKCB0ZW1wLCBbXSwgY29udGV4dCwgeG1sICk7XG5cblx0XHRcdC8vIFVuLW1hdGNoIGZhaWxpbmcgZWxlbWVudHMgYnkgbW92aW5nIHRoZW0gYmFjayB0byBtYXRjaGVySW5cblx0XHRcdGkgPSB0ZW1wLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoIChlbGVtID0gdGVtcFtpXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFtpXSBdID0gIShtYXRjaGVySW5bIHBvc3RNYXBbaV0gXSA9IGVsZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRcdC8vIEdldCB0aGUgZmluYWwgbWF0Y2hlck91dCBieSBjb25kZW5zaW5nIHRoaXMgaW50ZXJtZWRpYXRlIGludG8gcG9zdEZpbmRlciBjb250ZXh0c1xuXHRcdFx0XHRcdHRlbXAgPSBbXTtcblx0XHRcdFx0XHRpID0gbWF0Y2hlck91dC5sZW5ndGg7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdC8vIFJlc3RvcmUgbWF0Y2hlckluIHNpbmNlIGVsZW0gaXMgbm90IHlldCBhIGZpbmFsIG1hdGNoXG5cdFx0XHRcdFx0XHRcdHRlbXAucHVzaCggKG1hdGNoZXJJbltpXSA9IGVsZW0pICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIChtYXRjaGVyT3V0ID0gW10pLCB0ZW1wLCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE1vdmUgbWF0Y2hlZCBlbGVtZW50cyBmcm9tIHNlZWQgdG8gcmVzdWx0cyB0byBrZWVwIHRoZW0gc3luY2hyb25pemVkXG5cdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9IG1hdGNoZXJPdXRbaV0pICYmXG5cdFx0XHRcdFx0XHQodGVtcCA9IHBvc3RGaW5kZXIgPyBpbmRleE9mKCBzZWVkLCBlbGVtICkgOiBwcmVNYXBbaV0pID4gLTEgKSB7XG5cblx0XHRcdFx0XHRcdHNlZWRbdGVtcF0gPSAhKHJlc3VsdHNbdGVtcF0gPSBlbGVtKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEFkZCBlbGVtZW50cyB0byByZXN1bHRzLCB0aHJvdWdoIHBvc3RGaW5kZXIgaWYgZGVmaW5lZFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyT3V0ID0gY29uZGVuc2UoXG5cdFx0XHRcdG1hdGNoZXJPdXQgPT09IHJlc3VsdHMgP1xuXHRcdFx0XHRcdG1hdGNoZXJPdXQuc3BsaWNlKCBwcmVleGlzdGluZywgbWF0Y2hlck91dC5sZW5ndGggKSA6XG5cdFx0XHRcdFx0bWF0Y2hlck91dFxuXHRcdFx0KTtcblx0XHRcdGlmICggcG9zdEZpbmRlciApIHtcblx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgcmVzdWx0cywgbWF0Y2hlck91dCwgeG1sICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBtYXRjaGVyT3V0ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Ub2tlbnMoIHRva2VucyApIHtcblx0dmFyIGNoZWNrQ29udGV4dCwgbWF0Y2hlciwgaixcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdGxlYWRpbmdSZWxhdGl2ZSA9IEV4cHIucmVsYXRpdmVbIHRva2Vuc1swXS50eXBlIF0sXG5cdFx0aW1wbGljaXRSZWxhdGl2ZSA9IGxlYWRpbmdSZWxhdGl2ZSB8fCBFeHByLnJlbGF0aXZlW1wiIFwiXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KGNoZWNrQ29udGV4dCA9IGNvbnRleHQpLm5vZGVUeXBlID9cblx0XHRcdFx0XHRtYXRjaENvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0XHRtYXRjaEFueUNvbnRleHQoIGVsZW0sIGNvbnRleHQsIHhtbCApICk7XG5cdFx0XHQvLyBBdm9pZCBoYW5naW5nIG9udG8gZWxlbWVudCAoaXNzdWUgIzI5OSlcblx0XHRcdGNoZWNrQ29udGV4dCA9IG51bGw7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH0gXTtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoIChtYXRjaGVyID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2ldLnR5cGUgXSkgKSB7XG5cdFx0XHRtYXRjaGVycyA9IFsgYWRkQ29tYmluYXRvcihlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlcikgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlciA9IEV4cHIuZmlsdGVyWyB0b2tlbnNbaV0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbaV0ubWF0Y2hlcyApO1xuXG5cdFx0XHQvLyBSZXR1cm4gc3BlY2lhbCB1cG9uIHNlZWluZyBhIHBvc2l0aW9uYWwgbWF0Y2hlclxuXHRcdFx0aWYgKCBtYXRjaGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdC8vIEZpbmQgdGhlIG5leHQgcmVsYXRpdmUgb3BlcmF0b3IgKGlmIGFueSkgZm9yIHByb3BlciBoYW5kbGluZ1xuXHRcdFx0XHRqID0gKytpO1xuXHRcdFx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdFx0XHRpZiAoIEV4cHIucmVsYXRpdmVbIHRva2Vuc1tqXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3Rvcihcblx0XHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0XHR0b2tlbnMuc2xpY2UoIDAsIGkgLSAxICkuY29uY2F0KHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9KVxuXHRcdFx0XHRcdCkucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLFxuXHRcdFx0XHRcdG1hdGNoZXIsXG5cdFx0XHRcdFx0aSA8IGogJiYgbWF0Y2hlckZyb21Ub2tlbnMoIHRva2Vucy5zbGljZSggaSwgaiApICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiBtYXRjaGVyRnJvbVRva2VucyggKHRva2VucyA9IHRva2Vucy5zbGljZSggaiApKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXHRcdFx0XHQvLyBXZSBtdXN0IGFsd2F5cyBoYXZlIGVpdGhlciBzZWVkIGVsZW1lbnRzIG9yIG91dGVybW9zdCBjb250ZXh0XG5cdFx0XHRcdGVsZW1zID0gc2VlZCB8fCBieUVsZW1lbnQgJiYgRXhwci5maW5kW1wiVEFHXCJdKCBcIipcIiwgb3V0ZXJtb3N0ICksXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoZGlycnVucyArPSBjb250ZXh0QmFja3VwID09IG51bGwgPyAxIDogTWF0aC5yYW5kb20oKSB8fCAwLjEpLFxuXHRcdFx0XHRsZW4gPSBlbGVtcy5sZW5ndGg7XG5cblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dCA9PT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKGVsZW0gPSBlbGVtc1tpXSkgIT0gbnVsbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGJ5RWxlbWVudCAmJiBlbGVtICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdGlmICggIWNvbnRleHQgJiYgZWxlbS5vd25lckRvY3VtZW50ICE9PSBkb2N1bWVudCApIHtcblx0XHRcdFx0XHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdFx0XHRcdFx0XHR4bWwgPSAhZG9jdW1lbnRJc0hUTUw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBlbGVtZW50TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQgfHwgZG9jdW1lbnQsIHhtbCkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cdFx0XHRcdFx0Ly8gVGhleSB3aWxsIGhhdmUgZ29uZSB0aHJvdWdoIGFsbCBwb3NzaWJsZSBtYXRjaGVyc1xuXHRcdFx0XHRcdGlmICggKGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtKSApIHtcblx0XHRcdFx0XHRcdG1hdGNoZWRDb3VudC0tO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIExlbmd0aGVuIHRoZSBhcnJheSBmb3IgZXZlcnkgZWxlbWVudCwgbWF0Y2hlZCBvciBub3Rcblx0XHRcdFx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRcdFx0XHR1bm1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBgaWAgaXMgbm93IHRoZSBjb3VudCBvZiBlbGVtZW50cyB2aXNpdGVkIGFib3ZlLCBhbmQgYWRkaW5nIGl0IHRvIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBtYWtlcyB0aGUgbGF0dGVyIG5vbm5lZ2F0aXZlLlxuXHRcdFx0bWF0Y2hlZENvdW50ICs9IGk7XG5cblx0XHRcdC8vIEFwcGx5IHNldCBmaWx0ZXJzIHRvIHVubWF0Y2hlZCBlbGVtZW50c1xuXHRcdFx0Ly8gTk9URTogVGhpcyBjYW4gYmUgc2tpcHBlZCBpZiB0aGVyZSBhcmUgbm8gdW5tYXRjaGVkIGVsZW1lbnRzIChpLmUuLCBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gZXF1YWxzIGBpYCksIHVubGVzcyB3ZSBkaWRuJ3QgdmlzaXQgX2FueV8gZWxlbWVudHMgaW4gdGhlIGFib3ZlIGxvb3AgYmVjYXVzZSB3ZSBoYXZlXG5cdFx0XHQvLyBubyBlbGVtZW50IG1hdGNoZXJzIGFuZCBubyBzZWVkLlxuXHRcdFx0Ly8gSW5jcmVtZW50aW5nIGFuIGluaXRpYWxseS1zdHJpbmcgXCIwXCIgYGlgIGFsbG93cyBgaWAgdG8gcmVtYWluIGEgc3RyaW5nIG9ubHkgaW4gdGhhdFxuXHRcdFx0Ly8gY2FzZSwgd2hpY2ggd2lsbCByZXN1bHQgaW4gYSBcIjAwXCIgYG1hdGNoZWRDb3VudGAgdGhhdCBkaWZmZXJzIGZyb20gYGlgIGJ1dCBpcyBhbHNvXG5cdFx0XHQvLyBudW1lcmljYWxseSB6ZXJvLlxuXHRcdFx0aWYgKCBieVNldCAmJiBpICE9PSBtYXRjaGVkQ291bnQgKSB7XG5cdFx0XHRcdGogPSAwO1xuXHRcdFx0XHR3aGlsZSAoIChtYXRjaGVyID0gc2V0TWF0Y2hlcnNbaisrXSkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlciggdW5tYXRjaGVkLCBzZXRNYXRjaGVkLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHQvLyBSZWludGVncmF0ZSBlbGVtZW50IG1hdGNoZXMgdG8gZWxpbWluYXRlIHRoZSBuZWVkIGZvciBzb3J0aW5nXG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkQ291bnQgPiAwICkge1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggISh1bm1hdGNoZWRbaV0gfHwgc2V0TWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c2V0TWF0Y2hlZFtpXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXHRcdC8vIEdlbmVyYXRlIGEgZnVuY3Rpb24gb2YgcmVjdXJzaXZlIGZ1bmN0aW9ucyB0aGF0IGNhbiBiZSB1c2VkIHRvIGNoZWNrIGVhY2ggZWxlbWVudFxuXHRcdGlmICggIW1hdGNoICkge1xuXHRcdFx0bWF0Y2ggPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHR9XG5cdFx0aSA9IG1hdGNoLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdGNhY2hlZCA9IG1hdGNoZXJGcm9tVG9rZW5zKCBtYXRjaFtpXSApO1xuXHRcdFx0aWYgKCBjYWNoZWRbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0c2V0TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtZW50TWF0Y2hlcnMucHVzaCggY2FjaGVkICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FjaGUgdGhlIGNvbXBpbGVkIGZ1bmN0aW9uXG5cdFx0Y2FjaGVkID0gY29tcGlsZXJDYWNoZSggc2VsZWN0b3IsIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApICk7XG5cblx0XHQvLyBTYXZlIHNlbGVjdG9yIGFuZCB0b2tlbml6YXRpb25cblx0XHRjYWNoZWQuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0fVxuXHRyZXR1cm4gY2FjaGVkO1xufTtcblxuLyoqXG4gKiBBIGxvdy1sZXZlbCBzZWxlY3Rpb24gZnVuY3Rpb24gdGhhdCB3b3JrcyB3aXRoIFNpenpsZSdzIGNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb25zXG4gKiBAcGFyYW0ge1N0cmluZ3xGdW5jdGlvbn0gc2VsZWN0b3IgQSBzZWxlY3RvciBvciBhIHByZS1jb21waWxlZFxuICogIHNlbGVjdG9yIGZ1bmN0aW9uIGJ1aWx0IHdpdGggU2l6emxlLmNvbXBpbGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gY29udGV4dFxuICogQHBhcmFtIHtBcnJheX0gW3Jlc3VsdHNdXG4gKiBAcGFyYW0ge0FycmF5fSBbc2VlZF0gQSBzZXQgb2YgZWxlbWVudHMgdG8gbWF0Y2ggYWdhaW5zdFxuICovXG5zZWxlY3QgPSBTaXp6bGUuc2VsZWN0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgaSwgdG9rZW5zLCB0b2tlbiwgdHlwZSwgZmluZCxcblx0XHRjb21waWxlZCA9IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICYmIHNlbGVjdG9yLFxuXHRcdG1hdGNoID0gIXNlZWQgJiYgdG9rZW5pemUoIChzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yKSApO1xuXG5cdHJlc3VsdHMgPSByZXN1bHRzIHx8IFtdO1xuXG5cdC8vIFRyeSB0byBtaW5pbWl6ZSBvcGVyYXRpb25zIGlmIHRoZXJlIGlzIG9ubHkgb25lIHNlbGVjdG9yIGluIHRoZSBsaXN0IGFuZCBubyBzZWVkXG5cdC8vICh0aGUgbGF0dGVyIG9mIHdoaWNoIGd1YXJhbnRlZXMgdXMgY29udGV4dClcblx0aWYgKCBtYXRjaC5sZW5ndGggPT09IDEgKSB7XG5cblx0XHQvLyBSZWR1Y2UgY29udGV4dCBpZiB0aGUgbGVhZGluZyBjb21wb3VuZCBzZWxlY3RvciBpcyBhbiBJRFxuXHRcdHRva2VucyA9IG1hdGNoWzBdID0gbWF0Y2hbMF0uc2xpY2UoIDAgKTtcblx0XHRpZiAoIHRva2Vucy5sZW5ndGggPiAyICYmICh0b2tlbiA9IHRva2Vuc1swXSkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRcdGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiYgRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImZpZWxkc2V0XCIpICkgJiAxO1xufSk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZShcImhyZWZcIikgPT09IFwiI1wiIDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBkZWZhdWx0VmFsdWUgaW4gcGxhY2Ugb2YgZ2V0QXR0cmlidXRlKFwidmFsdWVcIilcbmlmICggIXN1cHBvcnQuYXR0cmlidXRlcyB8fCAhYXNzZXJ0KGZ1bmN0aW9uKCBlbCApIHtcblx0ZWwuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRlbC5maXJzdENoaWxkLnNldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiLCBcIlwiICk7XG5cdHJldHVybiBlbC5maXJzdENoaWxkLmdldEF0dHJpYnV0ZSggXCJ2YWx1ZVwiICkgPT09IFwiXCI7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHRpZiAoICFpc1hNTCAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiApIHtcblx0XHRcdHJldHVybiBlbGVtLmRlZmF1bHRWYWx1ZTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZ2V0QXR0cmlidXRlTm9kZSB0byBmZXRjaCBib29sZWFucyB3aGVuIGdldEF0dHJpYnV0ZSBsaWVzXG5pZiAoICFhc3NlcnQoZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKFwiZGlzYWJsZWRcIikgPT0gbnVsbDtcbn0pICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHRcdCh2YWwgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIG5hbWUgKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcblx0XHR9XG5cdH0pO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59KSggd2luZG93ICk7XG5cblxuXG5qUXVlcnkuZmluZCA9IFNpenpsZTtcbmpRdWVyeS5leHByID0gU2l6emxlLnNlbGVjdG9ycztcblxuLy8gRGVwcmVjYXRlZFxualF1ZXJ5LmV4cHJbIFwiOlwiIF0gPSBqUXVlcnkuZXhwci5wc2V1ZG9zO1xualF1ZXJ5LnVuaXF1ZVNvcnQgPSBqUXVlcnkudW5pcXVlID0gU2l6emxlLnVuaXF1ZVNvcnQ7XG5qUXVlcnkudGV4dCA9IFNpenpsZS5nZXRUZXh0O1xualF1ZXJ5LmlzWE1MRG9jID0gU2l6emxlLmlzWE1MO1xualF1ZXJ5LmNvbnRhaW5zID0gU2l6emxlLmNvbnRhaW5zO1xualF1ZXJ5LmVzY2FwZVNlbGVjdG9yID0gU2l6emxlLmVzY2FwZTtcblxuXG5cblxudmFyIGRpciA9IGZ1bmN0aW9uKCBlbGVtLCBkaXIsIHVudGlsICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdLFxuXHRcdHRydW5jYXRlID0gdW50aWwgIT09IHVuZGVmaW5lZDtcblxuXHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgJiYgZWxlbS5ub2RlVHlwZSAhPT0gOSApIHtcblx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRpZiAoIHRydW5jYXRlICYmIGpRdWVyeSggZWxlbSApLmlzKCB1bnRpbCApICkge1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdG1hdGNoZWQucHVzaCggZWxlbSApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHNpYmxpbmdzID0gZnVuY3Rpb24oIG4sIGVsZW0gKSB7XG5cdHZhciBtYXRjaGVkID0gW107XG5cblx0Zm9yICggOyBuOyBuID0gbi5uZXh0U2libGluZyApIHtcblx0XHRpZiAoIG4ubm9kZVR5cGUgPT09IDEgJiYgbiAhPT0gZWxlbSApIHtcblx0XHRcdG1hdGNoZWQucHVzaCggbiApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgcm5lZWRzQ29udGV4dCA9IGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dDtcblxuXG5cbmZ1bmN0aW9uIG5vZGVOYW1lKCBlbGVtLCBuYW1lICkge1xuXG4gIHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZS50b0xvd2VyQ2FzZSgpO1xuXG59O1xudmFyIHJzaW5nbGVUYWcgPSAoIC9ePChbYS16XVteXFwvXFwwPjpcXHgyMFxcdFxcclxcblxcZl0qKVtcXHgyMFxcdFxcclxcblxcZl0qXFwvPz4oPzo8XFwvXFwxPnwpJC9pICk7XG5cblxuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggaXNGdW5jdGlvbiggcXVhbGlmaWVyICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gU2luZ2xlIGVsZW1lbnRcblx0aWYgKCBxdWFsaWZpZXIubm9kZVR5cGUgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBlbGVtID09PSBxdWFsaWZpZXIgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEFycmF5bGlrZSBvZiBlbGVtZW50cyAoalF1ZXJ5LCBhcmd1bWVudHMsIEFycmF5KVxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gKCBpbmRleE9mLmNhbGwoIHF1YWxpZmllciwgZWxlbSApID4gLTEgKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEZpbHRlcmVkIGRpcmVjdGx5IGZvciBib3RoIHNpbXBsZSBhbmQgY29tcGxleCBzZWxlY3RvcnNcblx0cmV0dXJuIGpRdWVyeS5maWx0ZXIoIHF1YWxpZmllciwgZWxlbWVudHMsIG5vdCApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0aWYgKCBlbGVtcy5sZW5ndGggPT09IDEgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBlbGVtLCBleHByICkgPyBbIGVsZW0gXSA6IFtdO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVR5cGUgPT09IDE7XG5cdH0gKSApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmaW5kOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGksIHJldCxcblx0XHRcdGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0c2VsZiA9IHRoaXM7XG5cblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5KCBzZWxlY3RvciApLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBqUXVlcnkuY29udGFpbnMoIHNlbGZbIGkgXSwgdGhpcyApICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9ICkgKTtcblx0XHR9XG5cblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggW10gKTtcblxuXHRcdGZvciAoIGkgPSAwOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRqUXVlcnkuZmluZCggc2VsZWN0b3IsIHNlbGZbIGkgXSwgcmV0ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGxlbiA+IDEgPyBqUXVlcnkudW5pcXVlU29ydCggcmV0ICkgOiByZXQ7XG5cdH0sXG5cdGZpbHRlcjogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgZmFsc2UgKSApO1xuXHR9LFxuXHRub3Q6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIHRydWUgKSApO1xuXHR9LFxuXHRpczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiAhIXdpbm5vdyhcblx0XHRcdHRoaXMsXG5cblx0XHRcdC8vIElmIHRoaXMgaXMgYSBwb3NpdGlvbmFsL3JlbGF0aXZlIHNlbGVjdG9yLCBjaGVjayBtZW1iZXJzaGlwIGluIHRoZSByZXR1cm5lZCBzZXRcblx0XHRcdC8vIHNvICQoXCJwOmZpcnN0XCIpLmlzKFwicDpsYXN0XCIpIHdvbid0IHJldHVybiB0cnVlIGZvciBhIGRvYyB3aXRoIHR3byBcInBcIi5cblx0XHRcdHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiAmJiBybmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICkgP1xuXHRcdFx0XHRqUXVlcnkoIHNlbGVjdG9yICkgOlxuXHRcdFx0XHRzZWxlY3RvciB8fCBbXSxcblx0XHRcdGZhbHNlXG5cdFx0KS5sZW5ndGg7XG5cdH1cbn0gKTtcblxuXG4vLyBJbml0aWFsaXplIGEgalF1ZXJ5IG9iamVjdFxuXG5cbi8vIEEgY2VudHJhbCByZWZlcmVuY2UgdG8gdGhlIHJvb3QgalF1ZXJ5KGRvY3VtZW50KVxudmFyIHJvb3RqUXVlcnksXG5cblx0Ly8gQSBzaW1wbGUgd2F5IHRvIGNoZWNrIGZvciBIVE1MIHN0cmluZ3Ncblx0Ly8gUHJpb3JpdGl6ZSAjaWQgb3ZlciA8dGFnPiB0byBhdm9pZCBYU1MgdmlhIGxvY2F0aW9uLmhhc2ggKCM5NTIxKVxuXHQvLyBTdHJpY3QgSFRNTCByZWNvZ25pdGlvbiAoIzExMjkwOiBtdXN0IHN0YXJ0IHdpdGggPClcblx0Ly8gU2hvcnRjdXQgc2ltcGxlICNpZCBjYXNlIGZvciBzcGVlZFxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKykpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoaXNbIG1hdGNoIF0gKSApIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzWyBtYXRjaCBdKCBjb250ZXh0WyBtYXRjaCBdICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIG90aGVyd2lzZSBzZXQgYXMgYXR0cmlidXRlc1xuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdHRoaXMuYXR0ciggbWF0Y2gsIGNvbnRleHRbIG1hdGNoIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0XHRcdC8vIEhBTkRMRTogJCgjaWQpXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKCBtYXRjaFsgMiBdICk7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggaXNGdW5jdGlvbiggc2VsZWN0b3IgKSApIHtcblx0XHRcdHJldHVybiByb290LnJlYWR5ICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRyb290LnJlYWR5KCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBFeGVjdXRlIGltbWVkaWF0ZWx5IGlmIHJlYWR5IGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdHNlbGVjdG9yKCBqUXVlcnkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHRhcmdldHMgPSB0eXBlb2Ygc2VsZWN0b3JzICE9PSBcInN0cmluZ1wiICYmIGpRdWVyeSggc2VsZWN0b3JzICk7XG5cblx0XHQvLyBQb3NpdGlvbmFsIHNlbGVjdG9ycyBuZXZlciBtYXRjaCwgc2luY2UgdGhlcmUncyBubyBfc2VsZWN0aW9uXyBjb250ZXh0XG5cdFx0aWYgKCAhcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvcnMgKSApIHtcblx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zm9yICggY3VyID0gdGhpc1sgaSBdOyBjdXIgJiYgY3VyICE9PSBjb250ZXh0OyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblxuXHRcdFx0XHRcdC8vIEFsd2F5cyBza2lwIGRvY3VtZW50IGZyYWdtZW50c1xuXHRcdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCB0YXJnZXRzID9cblx0XHRcdFx0XHRcdHRhcmdldHMuaW5kZXgoIGN1ciApID4gLTEgOlxuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRcdGN1ci5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGN1ciwgc2VsZWN0b3JzICkgKSApIHtcblxuXHRcdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5jb250ZW50RG9jdW1lbnQgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE1hcCB0dXBsZXMgKHByb2dyZXNzLCBkb25lLCBmYWlsKSB0byBhcmd1bWVudHMgKGRvbmUsIGZhaWwsIHByb2dyZXNzKVxuXHRcdFx0XHRcdFx0XHR2YXIgZm4gPSBpc0Z1bmN0aW9uKCBmbnNbIHR1cGxlWyA0IF0gXSApICYmIGZuc1sgdHVwbGVbIDQgXSBdO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLnByb2dyZXNzKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLm5vdGlmeSB9KVxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5kb25lKGZ1bmN0aW9uKCkgeyBiaW5kIHRvIG5ld0RlZmVyIG9yIG5ld0RlZmVyLnJlc29sdmUgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZmFpbChmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZWplY3QgfSlcblx0XHRcdFx0XHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAxIF0gXSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkID0gZm4gJiYgZm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgJiYgaXNGdW5jdGlvbiggcmV0dXJuZWQucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQucHJvbWlzZSgpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5wcm9ncmVzcyggbmV3RGVmZXIubm90aWZ5IClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmRvbmUoIG5ld0RlZmVyLnJlc29sdmUgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZmFpbCggbmV3RGVmZXIucmVqZWN0ICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXShcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCBvbkZ1bGZpbGxlZCwgb25SZWplY3RlZCwgb25Qcm9ncmVzcyApIHtcblx0XHRcdFx0XHR2YXIgbWF4RGVwdGggPSAwO1xuXHRcdFx0XHRcdGZ1bmN0aW9uIHJlc29sdmUoIGRlcHRoLCBkZWZlcnJlZCwgaGFuZGxlciwgc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdyA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dmFyIHJldHVybmVkLCB0aGVuO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4zLjMuM1xuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBkb3VibGUtcmVzb2x1dGlvbiBhdHRlbXB0c1xuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCA8IG1heERlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkID0gaGFuZGxlci5hcHBseSggdGhhdCwgYXJncyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy4xXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC00OFxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCByZXR1cm5lZCA9PT0gZGVmZXJyZWQucHJvbWlzZSgpICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCBcIlRoZW5hYmxlIHNlbGYtcmVzb2x1dGlvblwiICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb25zIDIuMy4zLjEsIDMuNVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTRcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTc1XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBSZXRyaWV2ZSBgdGhlbmAgb25seSBvbmNlXG5cdFx0XHRcdFx0XHRcdFx0XHR0aGVuID0gcmV0dXJuZWQgJiZcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9uIDIuMy40XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTY0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgY2hlY2sgb2JqZWN0cyBhbmQgZnVuY3Rpb25zIGZvciB0aGVuYWJpbGl0eVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHR5cGVvZiByZXR1cm5lZCA9PT0gXCJvYmplY3RcIiB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHR5cGVvZiByZXR1cm5lZCA9PT0gXCJmdW5jdGlvblwiICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQudGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGEgcmV0dXJuZWQgdGhlbmFibGVcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggdGhlbiApICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFNwZWNpYWwgcHJvY2Vzc29ycyAobm90aWZ5KSBqdXN0IHdhaXQgZm9yIHJlc29sdXRpb25cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoZW4uY2FsbChcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBUaHJvd2VyLCBzcGVjaWFsIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBhbHNvIGhvb2sgaW50byBwcm9ncmVzc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gLi4uYW5kIGRpc3JlZ2FyZCBvbGRlciByZXNvbHV0aW9uIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1heERlcHRoKys7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApLFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmVzb2x2ZSggbWF4RGVwdGgsIGRlZmVycmVkLCBJZGVudGl0eSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBIYW5kbGUgYWxsIG90aGVyIHJldHVybmVkIHZhbHVlc1xuXHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGhhbmRsZXIgIT09IElkZW50aXR5ICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHRoYXQgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgcmV0dXJuZWQgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFByb2Nlc3MgdGhlIHZhbHVlKHMpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIERlZmF1bHQgcHJvY2VzcyBpcyByZXNvbHZlXG5cdFx0XHRcdFx0XHRcdFx0XHRcdCggc3BlY2lhbCB8fCBkZWZlcnJlZC5yZXNvbHZlV2l0aCApKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgbm9ybWFsIHByb2Nlc3NvcnMgKHJlc29sdmUpIGNhdGNoIGFuZCByZWplY3QgZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MgPSBzcGVjaWFsID9cblx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgOlxuXHRcdFx0XHRcdFx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0bWlnaHRUaHJvdygpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayggZSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cHJvY2Vzcy5zdGFja1RyYWNlICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjQuMVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTYxXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gSWdub3JlIHBvc3QtcmVzb2x1dGlvbiBleGNlcHRpb25zXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCArIDEgPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIE9ubHkgc3Vic3RpdHV0ZSBoYW5kbGVycyBwYXNzIG9uIGNvbnRleHRcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIGFuZCBtdWx0aXBsZSB2YWx1ZXMgKG5vbi1zcGVjIGJlaGF2aW9yKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBUaHJvd2VyICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRhcmdzID0gWyBlIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIHRoYXQsIGFyZ3MgKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRcdH07XG5cblx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjFcblx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNTdcblx0XHRcdFx0XHRcdFx0Ly8gUmUtcmVzb2x2ZSBwcm9taXNlcyBpbW1lZGlhdGVseSB0byBkb2RnZSBmYWxzZSByZWplY3Rpb24gZnJvbVxuXHRcdFx0XHRcdFx0XHQvLyBzdWJzZXF1ZW50IGVycm9yc1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRlcHRoICkge1xuXHRcdFx0XHRcdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENhbGwgYW4gb3B0aW9uYWwgaG9vayB0byByZWNvcmQgdGhlIHN0YWNrLCBpbiBjYXNlIG9mIGV4Y2VwdGlvblxuXHRcdFx0XHRcdFx0XHRcdC8vIHNpbmNlIGl0J3Mgb3RoZXJ3aXNlIGxvc3Qgd2hlbiBleGVjdXRpb24gZ29lcyBhc3luY1xuXHRcdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5LkRlZmVycmVkLmdldFN0YWNrSG9vayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSA9IGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0d2luZG93LnNldFRpbWVvdXQoIHByb2Nlc3MgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4galF1ZXJ5LkRlZmVycmVkKCBmdW5jdGlvbiggbmV3RGVmZXIgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25Qcm9ncmVzcyApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUHJvZ3Jlc3MgOlxuXHRcdFx0XHRcdFx0XHRcdFx0SWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIubm90aWZ5V2l0aFxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuYWRkKCAuLi4gKVxuXHRcdFx0XHRcdFx0dHVwbGVzWyAxIF1bIDMgXS5hZGQoXG5cdFx0XHRcdFx0XHRcdHJlc29sdmUoXG5cdFx0XHRcdFx0XHRcdFx0MCxcblx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlcixcblx0XHRcdFx0XHRcdFx0XHRpc0Z1bmN0aW9uKCBvbkZ1bGZpbGxlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uRnVsZmlsbGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5XG5cdFx0XHRcdFx0XHRcdClcblx0XHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMiBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25SZWplY3RlZCApID9cblx0XHRcdFx0XHRcdFx0XHRcdG9uUmVqZWN0ZWQgOlxuXHRcdFx0XHRcdFx0XHRcdFx0VGhyb3dlclxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEFkZCBsaXN0LXNwZWNpZmljIG1ldGhvZHNcblx0XHRqUXVlcnkuZWFjaCggdHVwbGVzLCBmdW5jdGlvbiggaSwgdHVwbGUgKSB7XG5cdFx0XHR2YXIgbGlzdCA9IHR1cGxlWyAyIF0sXG5cdFx0XHRcdHN0YXRlU3RyaW5nID0gdHVwbGVbIDUgXTtcblxuXHRcdFx0Ly8gcHJvbWlzZS5wcm9ncmVzcyA9IGxpc3QuYWRkXG5cdFx0XHQvLyBwcm9taXNlLmRvbmUgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5mYWlsID0gbGlzdC5hZGRcblx0XHRcdHByb21pc2VbIHR1cGxlWyAxIF0gXSA9IGxpc3QuYWRkO1xuXG5cdFx0XHQvLyBIYW5kbGUgc3RhdGVcblx0XHRcdGlmICggc3RhdGVTdHJpbmcgKSB7XG5cdFx0XHRcdGxpc3QuYWRkKFxuXHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXG5cdFx0XHRcdFx0XHQvLyBzdGF0ZSA9IFwicmVzb2x2ZWRcIiAoaS5lLiwgZnVsZmlsbGVkKVxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlamVjdGVkXCJcblx0XHRcdFx0XHRcdHN0YXRlID0gc3RhdGVTdHJpbmc7XG5cdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2NhbGxiYWNrcy5kaXNhYmxlXG5cdFx0XHRcdFx0dHVwbGVzWyAzIC0gaSBdWyAyIF0uZGlzYWJsZSxcblxuXHRcdFx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHQvLyBmdWxmaWxsZWRfaGFuZGxlcnMuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMyBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19jYWxsYmFja3MubG9ja1xuXHRcdFx0XHRcdHR1cGxlc1sgMCBdWyAyIF0ubG9jayxcblxuXHRcdFx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmxvY2tcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gcHJvZ3Jlc3NfaGFuZGxlcnMuZmlyZVxuXHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIHJlamVjdGVkX2hhbmRsZXJzLmZpcmVcblx0XHRcdGxpc3QuYWRkKCB0dXBsZVsgMyBdLmZpcmUgKTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLm5vdGlmeVdpdGgoLi4uKSB9XG5cdFx0XHQvLyBkZWZlcnJlZC5yZXNvbHZlID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlc29sdmVXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0ID0gZnVuY3Rpb24oKSB7IGRlZmVycmVkLnJlamVjdFdpdGgoLi4uKSB9XG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyB1bmRlZmluZWQgOiB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBkZWZlcnJlZC5ub3RpZnlXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZVdpdGggPSBsaXN0LmZpcmVXaXRoXG5cdFx0XHQvLyBkZWZlcnJlZC5yZWplY3RXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdID0gbGlzdC5maXJlV2l0aDtcblx0XHR9ICk7XG5cblx0XHQvLyBNYWtlIHRoZSBkZWZlcnJlZCBhIHByb21pc2Vcblx0XHRwcm9taXNlLnByb21pc2UoIGRlZmVycmVkICk7XG5cblx0XHQvLyBDYWxsIGdpdmVuIGZ1bmMgaWYgYW55XG5cdFx0aWYgKCBmdW5jICkge1xuXHRcdFx0ZnVuYy5jYWxsKCBkZWZlcnJlZCwgZGVmZXJyZWQgKTtcblx0XHR9XG5cblx0XHQvLyBBbGwgZG9uZSFcblx0XHRyZXR1cm4gZGVmZXJyZWQ7XG5cdH0sXG5cblx0Ly8gRGVmZXJyZWQgaGVscGVyXG5cdHdoZW46IGZ1bmN0aW9uKCBzaW5nbGVWYWx1ZSApIHtcblx0XHR2YXJcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5jb21wbGV0ZWQgc3Vib3JkaW5hdGVzXG5cdFx0XHRyZW1haW5pbmcgPSBhcmd1bWVudHMubGVuZ3RoLFxuXG5cdFx0XHQvLyBjb3VudCBvZiB1bnByb2Nlc3NlZCBhcmd1bWVudHNcblx0XHRcdGkgPSByZW1haW5pbmcsXG5cblx0XHRcdC8vIHN1Ym9yZGluYXRlIGZ1bGZpbGxtZW50IGRhdGFcblx0XHRcdHJlc29sdmVDb250ZXh0cyA9IEFycmF5KCBpICksXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cblx0XHRcdC8vIHRoZSBtYXN0ZXIgRGVmZXJyZWRcblx0XHRcdG1hc3RlciA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBjYWxsYmFjayBmYWN0b3J5XG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmVzb2x2ZUNvbnRleHRzWyBpIF0gPSB0aGlzO1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxID8gc2xpY2UuY2FsbCggYXJndW1lbnRzICkgOiB2YWx1ZTtcblx0XHRcdFx0XHRpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRtYXN0ZXIucmVzb2x2ZVdpdGgoIHJlc29sdmVDb250ZXh0cywgcmVzb2x2ZVZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH07XG5cblx0XHQvLyBTaW5nbGUtIGFuZCBlbXB0eSBhcmd1bWVudHMgYXJlIGFkb3B0ZWQgbGlrZSBQcm9taXNlLnJlc29sdmVcblx0XHRpZiAoIHJlbWFpbmluZyA8PSAxICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggc2luZ2xlVmFsdWUsIG1hc3Rlci5kb25lKCB1cGRhdGVGdW5jKCBpICkgKS5yZXNvbHZlLCBtYXN0ZXIucmVqZWN0LFxuXHRcdFx0XHQhcmVtYWluaW5nICk7XG5cblx0XHRcdC8vIFVzZSAudGhlbigpIHRvIHVud3JhcCBzZWNvbmRhcnkgdGhlbmFibGVzIChjZi4gZ2gtMzAwMClcblx0XHRcdGlmICggbWFzdGVyLnN0YXRlKCkgPT09IFwicGVuZGluZ1wiIHx8XG5cdFx0XHRcdGlzRnVuY3Rpb24oIHJlc29sdmVWYWx1ZXNbIGkgXSAmJiByZXNvbHZlVmFsdWVzWyBpIF0udGhlbiApICkge1xuXG5cdFx0XHRcdHJldHVybiBtYXN0ZXIudGhlbigpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE11bHRpcGxlIGFyZ3VtZW50cyBhcmUgYWdncmVnYXRlZCBsaWtlIFByb21pc2UuYWxsIGFycmF5IGVsZW1lbnRzXG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRhZG9wdFZhbHVlKCByZXNvbHZlVmFsdWVzWyBpIF0sIHVwZGF0ZUZ1bmMoIGkgKSwgbWFzdGVyLnJlamVjdCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBtYXN0ZXIucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlc2UgdXN1YWxseSBpbmRpY2F0ZSBhIHByb2dyYW1tZXIgbWlzdGFrZSBkdXJpbmcgZGV2ZWxvcG1lbnQsXG4vLyB3YXJuIGFib3V0IHRoZW0gQVNBUCByYXRoZXIgdGhhbiBzd2FsbG93aW5nIHRoZW0gYnkgZGVmYXVsdC5cbnZhciByZXJyb3JOYW1lcyA9IC9eKEV2YWx8SW50ZXJuYWx8UmFuZ2V8UmVmZXJlbmNlfFN5bnRheHxUeXBlfFVSSSlFcnJvciQvO1xuXG5qUXVlcnkuRGVmZXJyZWQuZXhjZXB0aW9uSG9vayA9IGZ1bmN0aW9uKCBlcnJvciwgc3RhY2sgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDkgb25seVxuXHQvLyBDb25zb2xlIGV4aXN0cyB3aGVuIGRldiB0b29scyBhcmUgb3Blbiwgd2hpY2ggY2FuIGhhcHBlbiBhdCBhbnkgdGltZVxuXHRpZiAoIHdpbmRvdy5jb25zb2xlICYmIHdpbmRvdy5jb25zb2xlLndhcm4gJiYgZXJyb3IgJiYgcmVycm9yTmFtZXMudGVzdCggZXJyb3IubmFtZSApICkge1xuXHRcdHdpbmRvdy5jb25zb2xlLndhcm4oIFwialF1ZXJ5LkRlZmVycmVkIGV4Y2VwdGlvbjogXCIgKyBlcnJvci5tZXNzYWdlLCBlcnJvci5zdGFjaywgc3RhY2sgKTtcblx0fVxufTtcblxuXG5cblxualF1ZXJ5LnJlYWR5RXhjZXB0aW9uID0gZnVuY3Rpb24oIGVycm9yICkge1xuXHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0dGhyb3cgZXJyb3I7XG5cdH0gKTtcbn07XG5cblxuXG5cbi8vIFRoZSBkZWZlcnJlZCB1c2VkIG9uIERPTSByZWFkeVxudmFyIHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0cmVhZHlMaXN0XG5cdFx0LnRoZW4oIGZuIClcblxuXHRcdC8vIFdyYXAgalF1ZXJ5LnJlYWR5RXhjZXB0aW9uIGluIGEgZnVuY3Rpb24gc28gdGhhdCB0aGUgbG9va3VwXG5cdFx0Ly8gaGFwcGVucyBhdCB0aGUgdGltZSBvZiBlcnJvciBoYW5kbGluZyBpbnN0ZWFkIG9mIGNhbGxiYWNrXG5cdFx0Ly8gcmVnaXN0cmF0aW9uLlxuXHRcdC5jYXRjaCggZnVuY3Rpb24oIGVycm9yICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5RXhjZXB0aW9uKCBlcnJvciApO1xuXHRcdH0gKTtcblxuXHRyZXR1cm4gdGhpcztcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBJcyB0aGUgRE9NIHJlYWR5IHRvIGJlIHVzZWQ/IFNldCB0byB0cnVlIG9uY2UgaXQgb2NjdXJzLlxuXHRpc1JlYWR5OiBmYWxzZSxcblxuXHQvLyBBIGNvdW50ZXIgdG8gdHJhY2sgaG93IG1hbnkgaXRlbXMgdG8gd2FpdCBmb3IgYmVmb3JlXG5cdC8vIHRoZSByZWFkeSBldmVudCBmaXJlcy4gU2VlICM2NzgxXG5cdHJlYWR5V2FpdDogMSxcblxuXHQvLyBIYW5kbGUgd2hlbiB0aGUgRE9NIGlzIHJlYWR5XG5cdHJlYWR5OiBmdW5jdGlvbiggd2FpdCApIHtcblxuXHRcdC8vIEFib3J0IGlmIHRoZXJlIGFyZSBwZW5kaW5nIGhvbGRzIG9yIHdlJ3JlIGFscmVhZHkgcmVhZHlcblx0XHRpZiAoIHdhaXQgPT09IHRydWUgPyAtLWpRdWVyeS5yZWFkeVdhaXQgOiBqUXVlcnkuaXNSZWFkeSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBSZW1lbWJlciB0aGF0IHRoZSBET00gaXMgcmVhZHlcblx0XHRqUXVlcnkuaXNSZWFkeSA9IHRydWU7XG5cblx0XHQvLyBJZiBhIG5vcm1hbCBET00gUmVhZHkgZXZlbnQgZmlyZWQsIGRlY3JlbWVudCwgYW5kIHdhaXQgaWYgbmVlZCBiZVxuXHRcdGlmICggd2FpdCAhPT0gdHJ1ZSAmJiAtLWpRdWVyeS5yZWFkeVdhaXQgPiAwICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZXJlIGFyZSBmdW5jdGlvbnMgYm91bmQsIHRvIGV4ZWN1dGVcblx0XHRyZWFkeUxpc3QucmVzb2x2ZVdpdGgoIGRvY3VtZW50LCBbIGpRdWVyeSBdICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LnJlYWR5LnRoZW4gPSByZWFkeUxpc3QudGhlbjtcblxuLy8gVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbmZ1bmN0aW9uIGNvbXBsZXRlZCgpIHtcblx0ZG9jdW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXHR3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRqUXVlcnkucmVhZHkoKTtcbn1cblxuLy8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcbi8vIGFmdGVyIHRoZSBicm93c2VyIGV2ZW50IGhhcyBhbHJlYWR5IG9jY3VycmVkLlxuLy8gU3VwcG9ydDogSUUgPD05IC0gMTAgb25seVxuLy8gT2xkZXIgSUUgc29tZXRpbWVzIHNpZ25hbHMgXCJpbnRlcmFjdGl2ZVwiIHRvbyBzb29uXG5pZiAoIGRvY3VtZW50LnJlYWR5U3RhdGUgPT09IFwiY29tcGxldGVcIiB8fFxuXHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHQvLyBIYW5kbGUgaXQgYXN5bmNocm9ub3VzbHkgdG8gYWxsb3cgc2NyaXB0cyB0aGUgb3Bwb3J0dW5pdHkgdG8gZGVsYXkgcmVhZHlcblx0d2luZG93LnNldFRpbWVvdXQoIGpRdWVyeS5yZWFkeSApO1xuXG59IGVsc2Uge1xuXG5cdC8vIFVzZSB0aGUgaGFuZHkgZXZlbnQgY2FsbGJhY2tcblx0ZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJET01Db250ZW50TG9hZGVkXCIsIGNvbXBsZXRlZCApO1xuXG5cdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG59XG5cblxuXG5cbi8vIE11bHRpZnVuY3Rpb25hbCBtZXRob2QgdG8gZ2V0IGFuZCBzZXQgdmFsdWVzIG9mIGEgY29sbGVjdGlvblxuLy8gVGhlIHZhbHVlL3MgY2FuIG9wdGlvbmFsbHkgYmUgZXhlY3V0ZWQgaWYgaXQncyBhIGZ1bmN0aW9uXG52YXIgYWNjZXNzID0gZnVuY3Rpb24oIGVsZW1zLCBmbiwga2V5LCB2YWx1ZSwgY2hhaW5hYmxlLCBlbXB0eUdldCwgcmF3ICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gZWxlbXMubGVuZ3RoLFxuXHRcdGJ1bGsgPSBrZXkgPT0gbnVsbDtcblxuXHQvLyBTZXRzIG1hbnkgdmFsdWVzXG5cdGlmICggdG9UeXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyYXcgPSB0cnVlO1xuXHRcdH1cblxuXHRcdGlmICggYnVsayApIHtcblxuXHRcdFx0Ly8gQnVsayBvcGVyYXRpb25zIHJ1biBhZ2FpbnN0IHRoZSBlbnRpcmUgc2V0XG5cdFx0XHRpZiAoIHJhdyApIHtcblx0XHRcdFx0Zm4uY2FsbCggZWxlbXMsIHZhbHVlICk7XG5cdFx0XHRcdGZuID0gbnVsbDtcblxuXHRcdFx0Ly8gLi4uZXhjZXB0IHdoZW4gZXhlY3V0aW5nIGZ1bmN0aW9uIHZhbHVlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YnVsayA9IGZuO1xuXHRcdFx0XHRmbiA9IGZ1bmN0aW9uKCBlbGVtLCBrZXksIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiBidWxrLmNhbGwoIGpRdWVyeSggZWxlbSApLCB2YWx1ZSApO1xuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0Zm4oXG5cdFx0XHRcdFx0ZWxlbXNbIGkgXSwga2V5LCByYXcgP1xuXHRcdFx0XHRcdHZhbHVlIDpcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCBlbGVtc1sgaSBdLCBpLCBmbiggZWxlbXNbIGkgXSwga2V5ICkgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggY2hhaW5hYmxlICkge1xuXHRcdHJldHVybiBlbGVtcztcblx0fVxuXG5cdC8vIEdldHNcblx0aWYgKCBidWxrICkge1xuXHRcdHJldHVybiBmbi5jYWxsKCBlbGVtcyApO1xuXHR9XG5cblx0cmV0dXJuIGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcblxuXG4vLyBNYXRjaGVzIGRhc2hlZCBzdHJpbmcgZm9yIGNhbWVsaXppbmdcbnZhciBybXNQcmVmaXggPSAvXi1tcy0vLFxuXHRyZGFzaEFscGhhID0gLy0oW2Etel0pL2c7XG5cbi8vIFVzZWQgYnkgY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuZnVuY3Rpb24gZmNhbWVsQ2FzZSggYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCwgc2NhbGUsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uY3VyKCk7XG5cdFx0XHR9IDpcblx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5LmNzcyggZWxlbSwgcHJvcCwgXCJcIiApO1xuXHRcdFx0fSxcblx0XHRpbml0aWFsID0gY3VycmVudFZhbHVlKCksXG5cdFx0dW5pdCA9IHZhbHVlUGFydHMgJiYgdmFsdWVQYXJ0c1sgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApLFxuXG5cdFx0Ly8gU3RhcnRpbmcgdmFsdWUgY29tcHV0YXRpb24gaXMgcmVxdWlyZWQgZm9yIHBvdGVudGlhbCB1bml0IG1pc21hdGNoZXNcblx0XHRpbml0aWFsSW5Vbml0ID0gZWxlbS5ub2RlVHlwZSAmJlxuXHRcdFx0KCBqUXVlcnkuY3NzTnVtYmVyWyBwcm9wIF0gfHwgdW5pdCAhPT0gXCJweFwiICYmICtpbml0aWFsICkgJiZcblx0XHRcdHJjc3NOdW0uZXhlYyggalF1ZXJ5LmNzcyggZWxlbSwgcHJvcCApICk7XG5cblx0aWYgKCBpbml0aWFsSW5Vbml0ICYmIGluaXRpYWxJblVuaXRbIDMgXSAhPT0gdW5pdCApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD01NFxuXHRcdC8vIEhhbHZlIHRoZSBpdGVyYXRpb24gdGFyZ2V0IHZhbHVlIHRvIHByZXZlbnQgaW50ZXJmZXJlbmNlIGZyb20gQ1NTIHVwcGVyIGJvdW5kcyAoZ2gtMjE0NClcblx0XHRpbml0aWFsID0gaW5pdGlhbCAvIDI7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdHdoaWxlICggbWF4SXRlcmF0aW9ucy0tICkge1xuXG5cdFx0XHQvLyBFdmFsdWF0ZSBhbmQgdXBkYXRlIG91ciBiZXN0IGd1ZXNzIChkb3VibGluZyBndWVzc2VzIHRoYXQgemVybyBvdXQpLlxuXHRcdFx0Ly8gRmluaXNoIGlmIHRoZSBzY2FsZSBlcXVhbHMgb3IgY3Jvc3NlcyAxIChtYWtpbmcgdGhlIG9sZCpuZXcgcHJvZHVjdCBub24tcG9zaXRpdmUpLlxuXHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXHRcdFx0aWYgKCAoIDEgLSBzY2FsZSApICogKCAxIC0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCB8fCAwLjUgKSApIDw9IDAgKSB7XG5cdFx0XHRcdG1heEl0ZXJhdGlvbnMgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aW5pdGlhbEluVW5pdCA9IGluaXRpYWxJblVuaXQgLyBzY2FsZTtcblxuXHRcdH1cblxuXHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0ICogMjtcblx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBNYWtlIHN1cmUgd2UgdXBkYXRlIHRoZSB0d2VlbiBwcm9wZXJ0aWVzIGxhdGVyIG9uXG5cdFx0dmFsdWVQYXJ0cyA9IHZhbHVlUGFydHMgfHwgW107XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxuXG5cbnZhciBkZWZhdWx0RGlzcGxheU1hcCA9IHt9O1xuXG5mdW5jdGlvbiBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApIHtcblx0dmFyIHRlbXAsXG5cdFx0ZG9jID0gZWxlbS5vd25lckRvY3VtZW50LFxuXHRcdG5vZGVOYW1lID0gZWxlbS5ub2RlTmFtZSxcblx0XHRkaXNwbGF5ID0gZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF07XG5cblx0aWYgKCBkaXNwbGF5ICkge1xuXHRcdHJldHVybiBkaXNwbGF5O1xuXHR9XG5cblx0dGVtcCA9IGRvYy5ib2R5LmFwcGVuZENoaWxkKCBkb2MuY3JlYXRlRWxlbWVudCggbm9kZU5hbWUgKSApO1xuXHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggdGVtcCwgXCJkaXNwbGF5XCIgKTtcblxuXHR0ZW1wLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHRlbXAgKTtcblxuXHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdGRpc3BsYXkgPSBcImJsb2NrXCI7XG5cdH1cblx0ZGVmYXVsdERpc3BsYXlNYXBbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXG5cdHJldHVybiBkaXNwbGF5O1xufVxuXG5mdW5jdGlvbiBzaG93SGlkZSggZWxlbWVudHMsIHNob3cgKSB7XG5cdHZhciBkaXNwbGF5LCBlbGVtLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Ly8gRGV0ZXJtaW5lIG5ldyBkaXNwbGF5IHZhbHVlIGZvciBlbGVtZW50cyB0aGF0IG5lZWQgdG8gY2hhbmdlXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0ZWxlbSA9IGVsZW1lbnRzWyBpbmRleCBdO1xuXHRcdGlmICggIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gU2luY2Ugd2UgZm9yY2UgdmlzaWJpbGl0eSB1cG9uIGNhc2NhZGUtaGlkZGVuIGVsZW1lbnRzLCBhbiBpbW1lZGlhdGUgKGFuZCBzbG93KVxuXHRcdFx0Ly8gY2hlY2sgaXMgcmVxdWlyZWQgaW4gdGhpcyBmaXJzdCBsb29wIHVubGVzcyB3ZSBoYXZlIGEgbm9uZW1wdHkgZGlzcGxheSB2YWx1ZSAoZWl0aGVyXG5cdFx0XHQvLyBpbmxpbmUgb3IgYWJvdXQtdG8tYmUtcmVzdG9yZWQpXG5cdFx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZGlzcGxheVwiICkgfHwgbnVsbDtcblx0XHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICkge1xuXHRcdFx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICggZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIlwiICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBnZXREZWZhdWx0RGlzcGxheSggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiICkge1xuXHRcdFx0XHR2YWx1ZXNbIGluZGV4IF0gPSBcIm5vbmVcIjtcblxuXHRcdFx0XHQvLyBSZW1lbWJlciB3aGF0IHdlJ3JlIG92ZXJ3cml0aW5nXG5cdFx0XHRcdGRhdGFQcml2LnNldCggZWxlbSwgXCJkaXNwbGF5XCIsIGRpc3BsYXkgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBTZXQgdGhlIGRpc3BsYXkgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3AgdG8gYXZvaWQgY29uc3RhbnQgcmVmbG93XG5cdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCB2YWx1ZXNbIGluZGV4IF0gIT0gbnVsbCApIHtcblx0XHRcdGVsZW1lbnRzWyBpbmRleCBdLnN0eWxlLmRpc3BsYXkgPSB2YWx1ZXNbIGluZGV4IF07XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW1lbnRzO1xufVxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHNob3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBzaG93SGlkZSggdGhpcywgdHJ1ZSApO1xuXHR9LFxuXHRoaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMgKTtcblx0fSxcblx0dG9nZ2xlOiBmdW5jdGlvbiggc3RhdGUgKSB7XG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlID8gdGhpcy5zaG93KCkgOiB0aGlzLmhpZGUoKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggaXNIaWRkZW5XaXRoaW5UcmVlKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcbnZhciByY2hlY2thYmxlVHlwZSA9ICggL14oPzpjaGVja2JveHxyYWRpbykkL2kgKTtcblxudmFyIHJ0YWdOYW1lID0gKCAvPChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopL2kgKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8Xm1vZHVsZSR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0b3B0aW9uOiBbIDEsIFwiPHNlbGVjdCBtdWx0aXBsZT0nbXVsdGlwbGUnPlwiLCBcIjwvc2VsZWN0PlwiIF0sXG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxud3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uO1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cblxuZnVuY3Rpb24gZ2V0QWxsKCBjb250ZXh0LCB0YWcgKSB7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBVc2UgdHlwZW9mIHRvIGF2b2lkIHplcm8tYXJndW1lbnQgbWV0aG9kIGludm9jYXRpb24gb24gaG9zdCBvYmplY3RzICgjMTUxNTEpXG5cdHZhciByZXQ7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgfHwgXCIqXCIgKTtcblxuXHR9IGVsc2UgaWYgKCB0eXBlb2YgY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdHJldCA9IGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIHtcblx0XHRyZXQgPSBbXTtcblx0fVxuXG5cdGlmICggdGFnID09PSB1bmRlZmluZWQgfHwgdGFnICYmIG5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSApIHtcblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICk7XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufVxuXG5cbi8vIE1hcmsgc2NyaXB0cyBhcyBoYXZpbmcgYWxyZWFkeSBiZWVuIGV2YWx1YXRlZFxuZnVuY3Rpb24gc2V0R2xvYmFsRXZhbCggZWxlbXMsIHJlZkVsZW1lbnRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bCA9IGVsZW1zLmxlbmd0aDtcblxuXHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0ZGF0YVByaXYuc2V0KFxuXHRcdFx0ZWxlbXNbIGkgXSxcblx0XHRcdFwiZ2xvYmFsRXZhbFwiLFxuXHRcdFx0IXJlZkVsZW1lbnRzIHx8IGRhdGFQcml2LmdldCggcmVmRWxlbWVudHNbIGkgXSwgXCJnbG9iYWxFdmFsXCIgKVxuXHRcdCk7XG5cdH1cbn1cblxuXG52YXIgcmh0bWwgPSAvPHwmIz9cXHcrOy87XG5cbmZ1bmN0aW9uIGJ1aWxkRnJhZ21lbnQoIGVsZW1zLCBjb250ZXh0LCBzY3JpcHRzLCBzZWxlY3Rpb24sIGlnbm9yZWQgKSB7XG5cdHZhciBlbGVtLCB0bXAsIHRhZywgd3JhcCwgYXR0YWNoZWQsIGosXG5cdFx0ZnJhZ21lbnQgPSBjb250ZXh0LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRub2RlcyA9IFtdLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGVsZW0gPSBlbGVtc1sgaSBdO1xuXG5cdFx0aWYgKCBlbGVtIHx8IGVsZW0gPT09IDAgKSB7XG5cblx0XHRcdC8vIEFkZCBub2RlcyBkaXJlY3RseVxuXHRcdFx0aWYgKCB0b1R5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGF0dGFjaGVkID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gQXBwZW5kIHRvIGZyYWdtZW50XG5cdFx0dG1wID0gZ2V0QWxsKCBmcmFnbWVudC5hcHBlbmRDaGlsZCggZWxlbSApLCBcInNjcmlwdFwiICk7XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0aWYgKCBhdHRhY2hlZCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIHRtcCApO1xuXHRcdH1cblxuXHRcdC8vIENhcHR1cmUgZXhlY3V0YWJsZXNcblx0XHRpZiAoIHNjcmlwdHMgKSB7XG5cdFx0XHRqID0gMDtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdG1wWyBqKysgXSApICkge1xuXHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIGVsZW0udHlwZSB8fCBcIlwiICkgKSB7XG5cdFx0XHRcdFx0c2NyaXB0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnJhZ21lbnQ7XG59XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xufSApKCk7XG5cblxudmFyXG5cdHJrZXlFdmVudCA9IC9ea2V5Lyxcblx0cm1vdXNlRXZlbnQgPSAvXig/Om1vdXNlfHBvaW50ZXJ8Y29udGV4dG1lbnV8ZHJhZ3xkcm9wKXxjbGljay8sXG5cdHJ0eXBlbmFtZXNwYWNlID0gL14oW14uXSopKD86XFwuKC4rKXwpLztcblxuZnVuY3Rpb24gcmV0dXJuVHJ1ZSgpIHtcblx0cmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJldHVybkZhbHNlKCkge1xuXHRyZXR1cm4gZmFsc2U7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDExK1xuLy8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXMsIGV4Y2VwdCB3aGVuIHRoZXkgYXJlIG5vLW9wLlxuLy8gU28gZXhwZWN0IGZvY3VzIHRvIGJlIHN5bmNocm9ub3VzIHdoZW4gdGhlIGVsZW1lbnQgaXMgYWxyZWFkeSBhY3RpdmUsXG4vLyBhbmQgYmx1ciB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIG5vdCBhbHJlYWR5IGFjdGl2ZS5cbi8vIChmb2N1cyBhbmQgYmx1ciBhcmUgYWx3YXlzIHN5bmNocm9ub3VzIGluIG90aGVyIHN1cHBvcnRlZCBicm93c2Vycyxcbi8vIHRoaXMganVzdCBkZWZpbmVzIHdoZW4gd2UgY2FuIGNvdW50IG9uIGl0KS5cbmZ1bmN0aW9uIGV4cGVjdFN5bmMoIGVsZW0sIHR5cGUgKSB7XG5cdHJldHVybiAoIGVsZW0gPT09IHNhZmVBY3RpdmVFbGVtZW50KCkgKSA9PT0gKCB0eXBlID09PSBcImZvY3VzXCIgKTtcbn1cblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIEFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGNhbiB0aHJvdyB1bmV4cGVjdGVkbHlcbi8vIGh0dHBzOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xMzM5M1xuZnVuY3Rpb24gc2FmZUFjdGl2ZUVsZW1lbnQoKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQ7XG5cdH0gY2F0Y2ggKCBlcnIgKSB7IH1cbn1cblxuZnVuY3Rpb24gb24oIGVsZW0sIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIG9uZSApIHtcblx0dmFyIG9yaWdGbiwgdHlwZTtcblxuXHQvLyBUeXBlcyBjYW4gYmUgYSBtYXAgb2YgdHlwZXMvaGFuZGxlcnNcblx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHQvLyAoIHR5cGVzLU9iamVjdCwgc2VsZWN0b3IsIGRhdGEgKVxuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLU9iamVjdCwgZGF0YSApXG5cdFx0XHRkYXRhID0gZGF0YSB8fCBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0b24oIGVsZW0sIHR5cGUsIHNlbGVjdG9yLCBkYXRhLCB0eXBlc1sgdHlwZSBdLCBvbmUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIGVsZW07XG5cdH1cblxuXHRpZiAoIGRhdGEgPT0gbnVsbCAmJiBmbiA9PSBudWxsICkge1xuXG5cdFx0Ly8gKCB0eXBlcywgZm4gKVxuXHRcdGZuID0gc2VsZWN0b3I7XG5cdFx0ZGF0YSA9IHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHR9IGVsc2UgaWYgKCBmbiA9PSBudWxsICkge1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBzZWxlY3RvciwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyAoIHR5cGVzLCBkYXRhLCBmbiApXG5cdFx0XHRmbiA9IGRhdGE7XG5cdFx0XHRkYXRhID0gc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0aWYgKCBmbiA9PT0gZmFsc2UgKSB7XG5cdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0fSBlbHNlIGlmICggIWZuICkge1xuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBvbmUgPT09IDEgKSB7XG5cdFx0b3JpZ0ZuID0gZm47XG5cdFx0Zm4gPSBmdW5jdGlvbiggZXZlbnQgKSB7XG5cblx0XHRcdC8vIENhbiB1c2UgYW4gZW1wdHkgc2V0LCBzaW5jZSBldmVudCBjb250YWlucyB0aGUgaW5mb1xuXHRcdFx0alF1ZXJ5KCkub2ZmKCBldmVudCApO1xuXHRcdFx0cmV0dXJuIG9yaWdGbi5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0fTtcblxuXHRcdC8vIFVzZSBzYW1lIGd1aWQgc28gY2FsbGVyIGNhbiByZW1vdmUgdXNpbmcgb3JpZ0ZuXG5cdFx0Zm4uZ3VpZCA9IG9yaWdGbi5ndWlkIHx8ICggb3JpZ0ZuLmd1aWQgPSBqUXVlcnkuZ3VpZCsrICk7XG5cdH1cblx0cmV0dXJuIGVsZW0uZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0alF1ZXJ5LmV2ZW50LmFkZCggdGhpcywgdHlwZXMsIGZuLCBkYXRhLCBzZWxlY3RvciApO1xuXHR9ICk7XG59XG5cbi8qXG4gKiBIZWxwZXIgZnVuY3Rpb25zIGZvciBtYW5hZ2luZyBldmVudHMgLS0gbm90IHBhcnQgb2YgdGhlIHB1YmxpYyBpbnRlcmZhY2UuXG4gKiBQcm9wcyB0byBEZWFuIEVkd2FyZHMnIGFkZEV2ZW50IGxpYnJhcnkgZm9yIG1hbnkgb2YgdGhlIGlkZWFzLlxuICovXG5qUXVlcnkuZXZlbnQgPSB7XG5cblx0Z2xvYmFsOiB7fSxcblxuXHRhZGQ6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgZGF0YSwgc2VsZWN0b3IgKSB7XG5cblx0XHR2YXIgaGFuZGxlT2JqSW4sIGV2ZW50SGFuZGxlLCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHQvLyBEb24ndCBhdHRhY2ggZXZlbnRzIHRvIG5vRGF0YSBvciB0ZXh0L2NvbW1lbnQgbm9kZXMgKGJ1dCBhbGxvdyBwbGFpbiBvYmplY3RzKVxuXHRcdGlmICggIWVsZW1EYXRhICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIENhbGxlciBjYW4gcGFzcyBpbiBhbiBvYmplY3Qgb2YgY3VzdG9tIGRhdGEgaW4gbGlldSBvZiB0aGUgaGFuZGxlclxuXHRcdGlmICggaGFuZGxlci5oYW5kbGVyICkge1xuXHRcdFx0aGFuZGxlT2JqSW4gPSBoYW5kbGVyO1xuXHRcdFx0aGFuZGxlciA9IGhhbmRsZU9iakluLmhhbmRsZXI7XG5cdFx0XHRzZWxlY3RvciA9IGhhbmRsZU9iakluLnNlbGVjdG9yO1xuXHRcdH1cblxuXHRcdC8vIEVuc3VyZSB0aGF0IGludmFsaWQgc2VsZWN0b3JzIHRocm93IGV4Y2VwdGlvbnMgYXQgYXR0YWNoIHRpbWVcblx0XHQvLyBFdmFsdWF0ZSBhZ2FpbnN0IGRvY3VtZW50RWxlbWVudCBpbiBjYXNlIGVsZW0gaXMgYSBub24tZWxlbWVudCBub2RlIChlLmcuLCBkb2N1bWVudClcblx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBkb2N1bWVudEVsZW1lbnQsIHNlbGVjdG9yICk7XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgdGhlIGhhbmRsZXIgaGFzIGEgdW5pcXVlIElELCB1c2VkIHRvIGZpbmQvcmVtb3ZlIGl0IGxhdGVyXG5cdFx0aWYgKCAhaGFuZGxlci5ndWlkICkge1xuXHRcdFx0aGFuZGxlci5ndWlkID0galF1ZXJ5Lmd1aWQrKztcblx0XHR9XG5cblx0XHQvLyBJbml0IHRoZSBlbGVtZW50J3MgZXZlbnQgc3RydWN0dXJlIGFuZCBtYWluIGhhbmRsZXIsIGlmIHRoaXMgaXMgdGhlIGZpcnN0XG5cdFx0aWYgKCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyA9IHt9O1xuXHRcdH1cblx0XHRpZiAoICEoIGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlICkgKSB7XG5cdFx0XHRldmVudEhhbmRsZSA9IGVsZW1EYXRhLmhhbmRsZSA9IGZ1bmN0aW9uKCBlICkge1xuXG5cdFx0XHRcdC8vIERpc2NhcmQgdGhlIHNlY29uZCBldmVudCBvZiBhIGpRdWVyeS5ldmVudC50cmlnZ2VyKCkgYW5kXG5cdFx0XHRcdC8vIHdoZW4gYW4gZXZlbnQgaXMgY2FsbGVkIGFmdGVyIGEgcGFnZSBoYXMgdW5sb2FkZWRcblx0XHRcdFx0cmV0dXJuIHR5cGVvZiBqUXVlcnkgIT09IFwidW5kZWZpbmVkXCIgJiYgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCAhPT0gZS50eXBlID9cblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuZGlzcGF0Y2guYXBwbHkoIGVsZW0sIGFyZ3VtZW50cyApIDogdW5kZWZpbmVkO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHQvLyBIYW5kbGUgbXVsdGlwbGUgZXZlbnRzIHNlcGFyYXRlZCBieSBhIHNwYWNlXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFRoZXJlICptdXN0KiBiZSBhIHR5cGUsIG5vIGF0dGFjaGluZyBuYW1lc3BhY2Utb25seSBoYW5kbGVyc1xuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGV2ZW50IGNoYW5nZXMgaXRzIHR5cGUsIHVzZSB0aGUgc3BlY2lhbCBldmVudCBoYW5kbGVycyBmb3IgdGhlIGNoYW5nZWQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIElmIHNlbGVjdG9yIGRlZmluZWQsIGRldGVybWluZSBzcGVjaWFsIGV2ZW50IGFwaSB0eXBlLCBvdGhlcndpc2UgZ2l2ZW4gdHlwZVxuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXG5cdFx0XHQvLyBVcGRhdGUgc3BlY2lhbCBiYXNlZCBvbiBuZXdseSByZXNldCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gaGFuZGxlT2JqIGlzIHBhc3NlZCB0byBhbGwgZXZlbnQgaGFuZGxlcnNcblx0XHRcdGhhbmRsZU9iaiA9IGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0b3JpZ1R5cGU6IG9yaWdUeXBlLFxuXHRcdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0XHRoYW5kbGVyOiBoYW5kbGVyLFxuXHRcdFx0XHRndWlkOiBoYW5kbGVyLmd1aWQsXG5cdFx0XHRcdHNlbGVjdG9yOiBzZWxlY3Rvcixcblx0XHRcdFx0bmVlZHNDb250ZXh0OiBzZWxlY3RvciAmJiBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSxcblx0XHRcdFx0bmFtZXNwYWNlOiBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiIClcblx0XHRcdH0sIGhhbmRsZU9iakluICk7XG5cblx0XHRcdC8vIEluaXQgdGhlIGV2ZW50IGhhbmRsZXIgcXVldWUgaWYgd2UncmUgdGhlIGZpcnN0XG5cdFx0XHRpZiAoICEoIGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gKSApIHtcblx0XHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSA9IFtdO1xuXHRcdFx0XHRoYW5kbGVycy5kZWxlZ2F0ZUNvdW50ID0gMDtcblxuXHRcdFx0XHQvLyBPbmx5IHVzZSBhZGRFdmVudExpc3RlbmVyIGlmIHRoZSBzcGVjaWFsIGV2ZW50cyBoYW5kbGVyIHJldHVybnMgZmFsc2Vcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC5zZXR1cCB8fFxuXHRcdFx0XHRcdHNwZWNpYWwuc2V0dXAuY2FsbCggZWxlbSwgZGF0YSwgbmFtZXNwYWNlcywgZXZlbnRIYW5kbGUgKSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRpZiAoIGVsZW0uYWRkRXZlbnRMaXN0ZW5lciApIHtcblx0XHRcdFx0XHRcdGVsZW0uYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgZXZlbnRIYW5kbGUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0aWYgKCBzcGVjaWFsLmFkZCApIHtcblx0XHRcdFx0c3BlY2lhbC5hZGQuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cblx0XHRcdFx0aWYgKCAhaGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlci5ndWlkID0gaGFuZGxlci5ndWlkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCB0byB0aGUgZWxlbWVudCdzIGhhbmRsZXIgbGlzdCwgZGVsZWdhdGVzIGluIGZyb250XG5cdFx0XHRpZiAoIHNlbGVjdG9yICkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGhhbmRsZXJzLmRlbGVnYXRlQ291bnQrKywgMCwgaGFuZGxlT2JqICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gS2VlcCB0cmFjayBvZiB3aGljaCBldmVudHMgaGF2ZSBldmVyIGJlZW4gdXNlZCwgZm9yIGV2ZW50IG9wdGltaXphdGlvblxuXHRcdFx0alF1ZXJ5LmV2ZW50Lmdsb2JhbFsgdHlwZSBdID0gdHJ1ZTtcblx0XHR9XG5cblx0fSxcblxuXHQvLyBEZXRhY2ggYW4gZXZlbnQgb3Igc2V0IG9mIGV2ZW50cyBmcm9tIGFuIGVsZW1lbnRcblx0cmVtb3ZlOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIHNlbGVjdG9yLCBtYXBwZWRUeXBlcyApIHtcblxuXHRcdHZhciBqLCBvcmlnQ291bnQsIHRtcCxcblx0XHRcdGV2ZW50cywgdCwgaGFuZGxlT2JqLFxuXHRcdFx0c3BlY2lhbCwgaGFuZGxlcnMsIHR5cGUsIG5hbWVzcGFjZXMsIG9yaWdUeXBlLFxuXHRcdFx0ZWxlbURhdGEgPSBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICkgJiYgZGF0YVByaXYuZ2V0KCBlbGVtICk7XG5cblx0XHRpZiAoICFlbGVtRGF0YSB8fCAhKCBldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBPbmNlIGZvciBlYWNoIHR5cGUubmFtZXNwYWNlIGluIHR5cGVzOyB0eXBlIG1heSBiZSBvbWl0dGVkXG5cdFx0dHlwZXMgPSAoIHR5cGVzIHx8IFwiXCIgKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBuYXRpdmVFdmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdHZhciBldmVudCA9IGpRdWVyeS5ldmVudC5maXgoIG5hdGl2ZUV2ZW50ICk7XG5cblx0XHR2YXIgaSwgaiwgcmV0LCBtYXRjaGVkLCBoYW5kbGVPYmosIGhhbmRsZXJRdWV1ZSxcblx0XHRcdGFyZ3MgPSBuZXcgQXJyYXkoIGFyZ3VtZW50cy5sZW5ndGggKSxcblx0XHRcdGhhbmRsZXJzID0gKCBkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gfHwgW10sXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGV2ZW50LnR5cGUgXSB8fCB7fTtcblxuXHRcdC8vIFVzZSB0aGUgZml4LWVkIGpRdWVyeS5FdmVudCByYXRoZXIgdGhhbiB0aGUgKHJlYWQtb25seSkgbmF0aXZlIGV2ZW50XG5cdFx0YXJnc1sgMCBdID0gZXZlbnQ7XG5cblx0XHRmb3IgKCBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKyApIHtcblx0XHRcdGFyZ3NbIGkgXSA9IGFyZ3VtZW50c1sgaSBdO1xuXHRcdH1cblxuXHRcdGV2ZW50LmRlbGVnYXRlVGFyZ2V0ID0gdGhpcztcblxuXHRcdC8vIENhbGwgdGhlIHByZURpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZSwgYW5kIGxldCBpdCBiYWlsIGlmIGRlc2lyZWRcblx0XHRpZiAoIHNwZWNpYWwucHJlRGlzcGF0Y2ggJiYgc3BlY2lhbC5wcmVEaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApID09PSBmYWxzZSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBEZXRlcm1pbmUgaGFuZGxlcnNcblx0XHRoYW5kbGVyUXVldWUgPSBqUXVlcnkuZXZlbnQuaGFuZGxlcnMuY2FsbCggdGhpcywgZXZlbnQsIGhhbmRsZXJzICk7XG5cblx0XHQvLyBSdW4gZGVsZWdhdGVzIGZpcnN0OyB0aGV5IG1heSB3YW50IHRvIHN0b3AgcHJvcGFnYXRpb24gYmVuZWF0aCB1c1xuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBtYXRjaGVkID0gaGFuZGxlclF1ZXVlWyBpKysgXSApICYmICFldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0ZXZlbnQuY3VycmVudFRhcmdldCA9IG1hdGNoZWQuZWxlbTtcblxuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggaGFuZGxlT2JqID0gbWF0Y2hlZC5oYW5kbGVyc1sgaisrIF0gKSAmJlxuXHRcdFx0XHQhZXZlbnQuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGUgZXZlbnQgaXMgbmFtZXNwYWNlZCwgdGhlbiBlYWNoIGhhbmRsZXIgaXMgb25seSBpbnZva2VkIGlmIGl0IGlzXG5cdFx0XHRcdC8vIHNwZWNpYWxseSB1bml2ZXJzYWwgb3IgaXRzIG5hbWVzcGFjZXMgYXJlIGEgc3VwZXJzZXQgb2YgdGhlIGV2ZW50J3MuXG5cdFx0XHRcdGlmICggIWV2ZW50LnJuYW1lc3BhY2UgfHwgaGFuZGxlT2JqLm5hbWVzcGFjZSA9PT0gZmFsc2UgfHxcblx0XHRcdFx0XHRldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgaGFuZGxlT2JqLCBzZWwsIG1hdGNoZWRIYW5kbGVycywgbWF0Y2hlZFNlbGVjdG9ycyxcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0ZGVsZWdhdGVDb3VudCA9IGhhbmRsZXJzLmRlbGVnYXRlQ291bnQsXG5cdFx0XHRjdXIgPSBldmVudC50YXJnZXQ7XG5cblx0XHQvLyBGaW5kIGRlbGVnYXRlIGhhbmRsZXJzXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OVxuXHRcdFx0Ly8gQmxhY2staG9sZSBTVkcgPHVzZT4gaW5zdGFuY2UgdHJlZXMgKHRyYWMtMTMxODApXG5cdFx0XHRjdXIubm9kZVR5cGUgJiZcblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA8PTQyXG5cdFx0XHQvLyBTdXBwcmVzcyBzcGVjLXZpb2xhdGluZyBjbGlja3MgaW5kaWNhdGluZyBhIG5vbi1wcmltYXJ5IHBvaW50ZXIgYnV0dG9uICh0cmFjLTM4NjEpXG5cdFx0XHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvRE9NLUxldmVsLTMtRXZlbnRzLyNldmVudC10eXBlLWNsaWNrXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSBvbmx5XG5cdFx0XHQvLyAuLi5idXQgbm90IGFycm93IGtleSBcImNsaWNrc1wiIG9mIHJhZGlvIGlucHV0cywgd2hpY2ggY2FuIGhhdmUgYGJ1dHRvbmAgLTEgKGdoLTIzNDMpXG5cdFx0XHQhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgZXZlbnQuYnV0dG9uID49IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAhKCBldmVudC50eXBlID09PSBcImNsaWNrXCIgJiYgY3VyLmRpc2FibGVkID09PSB0cnVlICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlZEhhbmRsZXJzID0gW107XG5cdFx0XHRcdFx0bWF0Y2hlZFNlbGVjdG9ycyA9IHt9O1xuXHRcdFx0XHRcdGZvciAoIGkgPSAwOyBpIDwgZGVsZWdhdGVDb3VudDsgaSsrICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGkgXTtcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgY29uZmxpY3Qgd2l0aCBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKCMxMzIwMylcblx0XHRcdFx0XHRcdHNlbCA9IGhhbmRsZU9iai5zZWxlY3RvciArIFwiIFwiO1xuXG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdID0gaGFuZGxlT2JqLm5lZWRzQ29udGV4dCA/XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5KCBzZWwsIHRoaXMgKS5pbmRleCggY3VyICkgPiAtMSA6XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQoIHNlbCwgdGhpcywgbnVsbCwgWyBjdXIgXSApLmxlbmd0aDtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlZFNlbGVjdG9yc1sgc2VsIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVkSGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogbWF0Y2hlZEhhbmRsZXJzIH0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBZGQgdGhlIHJlbWFpbmluZyAoZGlyZWN0bHktYm91bmQpIGhhbmRsZXJzXG5cdFx0Y3VyID0gdGhpcztcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiBjdXIsIGhhbmRsZXJzOiBoYW5kbGVycy5zbGljZSggZGVsZWdhdGVDb3VudCApIH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gaGFuZGxlclF1ZXVlO1xuXHR9LFxuXG5cdGFkZFByb3A6IGZ1bmN0aW9uKCBuYW1lLCBob29rICkge1xuXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSwgbmFtZSwge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblxuXHRcdFx0Z2V0OiBpc0Z1bmN0aW9uKCBob29rICkgP1xuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGhvb2soIHRoaXMub3JpZ2luYWxFdmVudCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5vcmlnaW5hbEV2ZW50WyBuYW1lIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KCB0aGlzLCBuYW1lLCB7XG5cdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0XHRcdFx0dmFsdWU6IHZhbHVlXG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggb3JpZ2luYWxFdmVudCApIHtcblx0XHRyZXR1cm4gb3JpZ2luYWxFdmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRvcmlnaW5hbEV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIG9yaWdpbmFsRXZlbnQgKTtcblx0fSxcblxuXHRzcGVjaWFsOiB7XG5cdFx0bG9hZDoge1xuXG5cdFx0XHQvLyBQcmV2ZW50IHRyaWdnZXJlZCBpbWFnZS5sb2FkIGV2ZW50cyBmcm9tIGJ1YmJsaW5nIHRvIHdpbmRvdy5sb2FkXG5cdFx0XHRub0J1YmJsZTogdHJ1ZVxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgdG8gZW5zdXJlIGNvcnJlY3Qgc3RhdGUgZm9yIGNoZWNrYWJsZSBpbnB1dHNcblx0XHRcdHNldHVwOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIENsYWltIHRoZSBmaXJzdCBoYW5kbGVyXG5cdFx0XHRcdGlmICggcmNoZWNrYWJsZVR5cGUudGVzdCggZWwudHlwZSApICYmXG5cdFx0XHRcdFx0ZWwuY2xpY2sgJiYgbm9kZU5hbWUoIGVsLCBcImlucHV0XCIgKSApIHtcblxuXHRcdFx0XHRcdC8vIGRhdGFQcml2LnNldCggZWwsIFwiY2xpY2tcIiwgLi4uIClcblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiwgcmV0dXJuVHJ1ZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSxcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCBkYXRhICkge1xuXG5cdFx0XHRcdC8vIEZvciBtdXR1YWwgY29tcHJlc3NpYmlsaXR5IHdpdGggX2RlZmF1bHQsIHJlcGxhY2UgYHRoaXNgIGFjY2VzcyB3aXRoIGEgbG9jYWwgdmFyLlxuXHRcdFx0XHQvLyBgfHwgZGF0YWAgaXMgZGVhZCBjb2RlIG1lYW50IG9ubHkgdG8gcHJlc2VydmUgdGhlIHZhcmlhYmxlIHRocm91Z2ggbWluaWZpY2F0aW9uLlxuXHRcdFx0XHR2YXIgZWwgPSB0aGlzIHx8IGRhdGE7XG5cblx0XHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJpbmcgYSBjbGlja1xuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHRsZXZlcmFnZU5hdGl2ZSggZWwsIFwiY2xpY2tcIiApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH0sXG5cblx0XHRcdC8vIEZvciBjcm9zcy1icm93c2VyIGNvbnNpc3RlbmN5LCBzdXBwcmVzcyBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdC8vIEFsc28gcHJldmVudCBpdCBpZiB3ZSdyZSBjdXJyZW50bHkgaW5zaWRlIGEgbGV2ZXJhZ2VkIG5hdGl2ZS1ldmVudCBzdGFja1xuXHRcdFx0X2RlZmF1bHQ6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IGV2ZW50LnRhcmdldDtcblx0XHRcdFx0cmV0dXJuIHJjaGVja2FibGVUeXBlLnRlc3QoIHRhcmdldC50eXBlICkgJiZcblx0XHRcdFx0XHR0YXJnZXQuY2xpY2sgJiYgbm9kZU5hbWUoIHRhcmdldCwgXCJpbnB1dFwiICkgJiZcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRhcmdldCwgXCJjbGlja1wiICkgfHxcblx0XHRcdFx0XHRub2RlTmFtZSggdGFyZ2V0LCBcImFcIiApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRiZWZvcmV1bmxvYWQ6IHtcblx0XHRcdHBvc3REaXNwYXRjaDogZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggMjArXG5cdFx0XHRcdC8vIEZpcmVmb3ggZG9lc24ndCBhbGVydCBpZiB0aGUgcmV0dXJuVmFsdWUgZmllbGQgaXMgbm90IHNldC5cblx0XHRcdFx0aWYgKCBldmVudC5yZXN1bHQgIT09IHVuZGVmaW5lZCAmJiBldmVudC5vcmlnaW5hbEV2ZW50ICkge1xuXHRcdFx0XHRcdGV2ZW50Lm9yaWdpbmFsRXZlbnQucmV0dXJuVmFsdWUgPSBldmVudC5yZXN1bHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn07XG5cbi8vIEVuc3VyZSB0aGUgcHJlc2VuY2Ugb2YgYW4gZXZlbnQgbGlzdGVuZXIgdGhhdCBoYW5kbGVzIG1hbnVhbGx5LXRyaWdnZXJlZFxuLy8gc3ludGhldGljIGV2ZW50cyBieSBpbnRlcnJ1cHRpbmcgcHJvZ3Jlc3MgdW50aWwgcmVpbnZva2VkIGluIHJlc3BvbnNlIHRvXG4vLyAqbmF0aXZlKiBldmVudHMgdGhhdCBpdCBmaXJlcyBkaXJlY3RseSwgZW5zdXJpbmcgdGhhdCBzdGF0ZSBjaGFuZ2VzIGhhdmVcbi8vIGFscmVhZHkgb2NjdXJyZWQgYmVmb3JlIG90aGVyIGxpc3RlbmVycyBhcmUgaW52b2tlZC5cbmZ1bmN0aW9uIGxldmVyYWdlTmF0aXZlKCBlbCwgdHlwZSwgZXhwZWN0U3luYyApIHtcblxuXHQvLyBNaXNzaW5nIGV4cGVjdFN5bmMgaW5kaWNhdGVzIGEgdHJpZ2dlciBjYWxsLCB3aGljaCBtdXN0IGZvcmNlIHNldHVwIHRocm91Z2ggalF1ZXJ5LmV2ZW50LmFkZFxuXHRpZiAoICFleHBlY3RTeW5jICkge1xuXHRcdGlmICggZGF0YVByaXYuZ2V0KCBlbCwgdHlwZSApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwgcmV0dXJuVHJ1ZSApO1xuXHRcdH1cblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyBSZWdpc3RlciB0aGUgY29udHJvbGxlciBhcyBhIHNwZWNpYWwgdW5pdmVyc2FsIGhhbmRsZXIgZm9yIGFsbCBldmVudCBuYW1lc3BhY2VzXG5cdGRhdGFQcml2LnNldCggZWwsIHR5cGUsIGZhbHNlICk7XG5cdGpRdWVyeS5ldmVudC5hZGQoIGVsLCB0eXBlLCB7XG5cdFx0bmFtZXNwYWNlOiBmYWxzZSxcblx0XHRoYW5kbGVyOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgbm90QXN5bmMsIHJlc3VsdCxcblx0XHRcdFx0c2F2ZWQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0aWYgKCAoIGV2ZW50LmlzVHJpZ2dlciAmIDEgKSAmJiB0aGlzWyB0eXBlIF0gKSB7XG5cblx0XHRcdFx0Ly8gSW50ZXJydXB0IHByb2Nlc3Npbmcgb2YgdGhlIG91dGVyIHN5bnRoZXRpYyAudHJpZ2dlcigpZWQgZXZlbnRcblx0XHRcdFx0Ly8gU2F2ZWQgZGF0YSBzaG91bGQgYmUgZmFsc2UgaW4gc3VjaCBjYXNlcywgYnV0IG1pZ2h0IGJlIGEgbGVmdG92ZXIgY2FwdHVyZSBvYmplY3Rcblx0XHRcdFx0Ly8gZnJvbSBhbiBhc3luYyBuYXRpdmUgaGFuZGxlciAoZ2gtNDM1MClcblx0XHRcdFx0aWYgKCAhc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdFx0Ly8gU3RvcmUgYXJndW1lbnRzIGZvciB1c2Ugd2hlbiBoYW5kbGluZyB0aGUgaW5uZXIgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdFx0Ly8gVGhlcmUgd2lsbCBhbHdheXMgYmUgYXQgbGVhc3Qgb25lIGFyZ3VtZW50IChhbiBldmVudCBvYmplY3QpLCBzbyB0aGlzIGFycmF5XG5cdFx0XHRcdFx0Ly8gd2lsbCBub3QgYmUgY29uZnVzZWQgd2l0aCBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0LlxuXHRcdFx0XHRcdHNhdmVkID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCBzYXZlZCApO1xuXG5cdFx0XHRcdFx0Ly8gVHJpZ2dlciB0aGUgbmF0aXZlIGV2ZW50IGFuZCBjYXB0dXJlIGl0cyByZXN1bHRcblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHQvLyBmb2N1cygpIGFuZCBibHVyKCkgYXJlIGFzeW5jaHJvbm91c1xuXHRcdFx0XHRcdG5vdEFzeW5jID0gZXhwZWN0U3luYyggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdHRoaXNbIHR5cGUgXSgpO1xuXHRcdFx0XHRcdHJlc3VsdCA9IGRhdGFQcml2LmdldCggdGhpcywgdHlwZSApO1xuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCB8fCBub3RBc3luYyApIHtcblx0XHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgZmFsc2UgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzdWx0ID0ge307XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggc2F2ZWQgIT09IHJlc3VsdCApIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSBvdXRlciBzeW50aGV0aWMgZXZlbnRcblx0XHRcdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHQudmFsdWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoaXMgaXMgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IGZvciBhbiBldmVudCB3aXRoIGEgYnViYmxpbmcgc3Vycm9nYXRlXG5cdFx0XHRcdC8vIChmb2N1cyBvciBibHVyKSwgYXNzdW1lIHRoYXQgdGhlIHN1cnJvZ2F0ZSBhbHJlYWR5IHByb3BhZ2F0ZWQgZnJvbSB0cmlnZ2VyaW5nIHRoZVxuXHRcdFx0XHQvLyBuYXRpdmUgZXZlbnQgYW5kIHByZXZlbnQgdGhhdCBmcm9tIGhhcHBlbmluZyBhZ2FpbiBoZXJlLlxuXHRcdFx0XHQvLyBUaGlzIHRlY2huaWNhbGx5IGdldHMgdGhlIG9yZGVyaW5nIHdyb25nIHcuci50LiB0byBgLnRyaWdnZXIoKWAgKGluIHdoaWNoIHRoZVxuXHRcdFx0XHQvLyBidWJibGluZyBzdXJyb2dhdGUgcHJvcGFnYXRlcyAqYWZ0ZXIqIHRoZSBub24tYnViYmxpbmcgYmFzZSksIGJ1dCB0aGF0IHNlZW1zXG5cdFx0XHRcdC8vIGxlc3MgYmFkIHRoYW4gZHVwbGljYXRpb24uXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fSApLmRlbGVnYXRlVHlwZSApIHtcblx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgbmF0aXZlIGV2ZW50IHRyaWdnZXJlZCBhYm92ZSwgZXZlcnl0aGluZyBpcyBub3cgaW4gb3JkZXJcblx0XHRcdC8vIEZpcmUgYW4gaW5uZXIgc3ludGhldGljIGV2ZW50IHdpdGggdGhlIG9yaWdpbmFsIGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggc2F2ZWQubGVuZ3RoICkge1xuXG5cdFx0XHRcdC8vIC4uLmFuZCBjYXB0dXJlIHRoZSByZXN1bHRcblx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCB0eXBlLCB7XG5cdFx0XHRcdFx0dmFsdWU6IGpRdWVyeS5ldmVudC50cmlnZ2VyKFxuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcblx0XHRcdFx0XHRcdC8vIEV4dGVuZCB3aXRoIHRoZSBwcm90b3R5cGUgdG8gcmVzZXQgdGhlIGFib3ZlIHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpXG5cdFx0XHRcdFx0XHRqUXVlcnkuZXh0ZW5kKCBzYXZlZFsgMCBdLCBqUXVlcnkuRXZlbnQucHJvdG90eXBlICksXG5cdFx0XHRcdFx0XHRzYXZlZC5zbGljZSggMSApLFxuXHRcdFx0XHRcdFx0dGhpc1xuXHRcdFx0XHRcdClcblx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdC8vIEFib3J0IGhhbmRsaW5nIG9mIHRoZSBuYXRpdmUgZXZlbnRcblx0XHRcdFx0ZXZlbnQuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9ICk7XG59XG5cbmpRdWVyeS5yZW1vdmVFdmVudCA9IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBoYW5kbGUgKSB7XG5cblx0Ly8gVGhpcyBcImlmXCIgaXMgbmVlZGVkIGZvciBwbGFpbiBvYmplY3RzXG5cdGlmICggZWxlbS5yZW1vdmVFdmVudExpc3RlbmVyICkge1xuXHRcdGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciggdHlwZSwgaGFuZGxlICk7XG5cdH1cbn07XG5cbmpRdWVyeS5FdmVudCA9IGZ1bmN0aW9uKCBzcmMsIHByb3BzICkge1xuXG5cdC8vIEFsbG93IGluc3RhbnRpYXRpb24gd2l0aG91dCB0aGUgJ25ldycga2V5d29yZFxuXHRpZiAoICEoIHRoaXMgaW5zdGFuY2VvZiBqUXVlcnkuRXZlbnQgKSApIHtcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5FdmVudCggc3JjLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gRXZlbnQgb2JqZWN0XG5cdGlmICggc3JjICYmIHNyYy50eXBlICkge1xuXHRcdHRoaXMub3JpZ2luYWxFdmVudCA9IHNyYztcblx0XHR0aGlzLnR5cGUgPSBzcmMudHlwZTtcblxuXHRcdC8vIEV2ZW50cyBidWJibGluZyB1cCB0aGUgZG9jdW1lbnQgbWF5IGhhdmUgYmVlbiBtYXJrZWQgYXMgcHJldmVudGVkXG5cdFx0Ly8gYnkgYSBoYW5kbGVyIGxvd2VyIGRvd24gdGhlIHRyZWU7IHJlZmxlY3QgdGhlIGNvcnJlY3QgdmFsdWUuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSBzcmMuZGVmYXVsdFByZXZlbnRlZCB8fFxuXHRcdFx0XHRzcmMuZGVmYXVsdFByZXZlbnRlZCA9PT0gdW5kZWZpbmVkICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTIuMyBvbmx5XG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHRcdC8vIENyZWF0ZSB0YXJnZXQgcHJvcGVydGllc1xuXHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA8PTYgLSA3IG9ubHlcblx0XHQvLyBUYXJnZXQgc2hvdWxkIG5vdCBiZSBhIHRleHQgbm9kZSAoIzUwNCwgIzEzMTQzKVxuXHRcdHRoaXMudGFyZ2V0ID0gKCBzcmMudGFyZ2V0ICYmIHNyYy50YXJnZXQubm9kZVR5cGUgPT09IDMgKSA/XG5cdFx0XHRzcmMudGFyZ2V0LnBhcmVudE5vZGUgOlxuXHRcdFx0c3JjLnRhcmdldDtcblxuXHRcdHRoaXMuY3VycmVudFRhcmdldCA9IHNyYy5jdXJyZW50VGFyZ2V0O1xuXHRcdHRoaXMucmVsYXRlZFRhcmdldCA9IHNyYy5yZWxhdGVkVGFyZ2V0O1xuXG5cdC8vIEV2ZW50IHR5cGVcblx0fSBlbHNlIHtcblx0XHR0aGlzLnR5cGUgPSBzcmM7XG5cdH1cblxuXHQvLyBQdXQgZXhwbGljaXRseSBwcm92aWRlZCBwcm9wZXJ0aWVzIG9udG8gdGhlIGV2ZW50IG9iamVjdFxuXHRpZiAoIHByb3BzICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRoaXMsIHByb3BzICk7XG5cdH1cblxuXHQvLyBDcmVhdGUgYSB0aW1lc3RhbXAgaWYgaW5jb21pbmcgZXZlbnQgZG9lc24ndCBoYXZlIG9uZVxuXHR0aGlzLnRpbWVTdGFtcCA9IHNyYyAmJiBzcmMudGltZVN0YW1wIHx8IERhdGUubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cHM6Ly93d3cudzMub3JnL1RSLzIwMDMvV0QtRE9NLUxldmVsLTMtRXZlbnRzLTIwMDMwMzMxL2VjbWEtc2NyaXB0LWJpbmRpbmcuaHRtbFxualF1ZXJ5LkV2ZW50LnByb3RvdHlwZSA9IHtcblx0Y29uc3RydWN0b3I6IGpRdWVyeS5FdmVudCxcblx0aXNEZWZhdWx0UHJldmVudGVkOiByZXR1cm5GYWxzZSxcblx0aXNQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc0ltbWVkaWF0ZVByb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzU2ltdWxhdGVkOiBmYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgJiYgIXRoaXMuaXNTaW11bGF0ZWQgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBJbmNsdWRlcyBhbGwgY29tbW9uIGV2ZW50IHByb3BzIGluY2x1ZGluZyBLZXlFdmVudCBhbmQgTW91c2VFdmVudCBzcGVjaWZpYyBwcm9wc1xualF1ZXJ5LmVhY2goIHtcblx0YWx0S2V5OiB0cnVlLFxuXHRidWJibGVzOiB0cnVlLFxuXHRjYW5jZWxhYmxlOiB0cnVlLFxuXHRjaGFuZ2VkVG91Y2hlczogdHJ1ZSxcblx0Y3RybEtleTogdHJ1ZSxcblx0ZGV0YWlsOiB0cnVlLFxuXHRldmVudFBoYXNlOiB0cnVlLFxuXHRtZXRhS2V5OiB0cnVlLFxuXHRwYWdlWDogdHJ1ZSxcblx0cGFnZVk6IHRydWUsXG5cdHNoaWZ0S2V5OiB0cnVlLFxuXHR2aWV3OiB0cnVlLFxuXHRcImNoYXJcIjogdHJ1ZSxcblx0Y29kZTogdHJ1ZSxcblx0Y2hhckNvZGU6IHRydWUsXG5cdGtleTogdHJ1ZSxcblx0a2V5Q29kZTogdHJ1ZSxcblx0YnV0dG9uOiB0cnVlLFxuXHRidXR0b25zOiB0cnVlLFxuXHRjbGllbnRYOiB0cnVlLFxuXHRjbGllbnRZOiB0cnVlLFxuXHRvZmZzZXRYOiB0cnVlLFxuXHRvZmZzZXRZOiB0cnVlLFxuXHRwb2ludGVySWQ6IHRydWUsXG5cdHBvaW50ZXJUeXBlOiB0cnVlLFxuXHRzY3JlZW5YOiB0cnVlLFxuXHRzY3JlZW5ZOiB0cnVlLFxuXHR0YXJnZXRUb3VjaGVzOiB0cnVlLFxuXHR0b0VsZW1lbnQ6IHRydWUsXG5cdHRvdWNoZXM6IHRydWUsXG5cblx0d2hpY2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHR2YXIgYnV0dG9uID0gZXZlbnQuYnV0dG9uO1xuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBrZXkgZXZlbnRzXG5cdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICYmIHJrZXlFdmVudC50ZXN0KCBldmVudC50eXBlICkgKSB7XG5cdFx0XHRyZXR1cm4gZXZlbnQuY2hhckNvZGUgIT0gbnVsbCA/IGV2ZW50LmNoYXJDb2RlIDogZXZlbnQua2V5Q29kZTtcblx0XHR9XG5cblx0XHQvLyBBZGQgd2hpY2ggZm9yIGNsaWNrOiAxID09PSBsZWZ0OyAyID09PSBtaWRkbGU7IDMgPT09IHJpZ2h0XG5cdFx0aWYgKCAhZXZlbnQud2hpY2ggJiYgYnV0dG9uICE9PSB1bmRlZmluZWQgJiYgcm1vdXNlRXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0aWYgKCBidXR0b24gJiAxICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiAyICkge1xuXHRcdFx0XHRyZXR1cm4gMztcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBidXR0b24gJiA0ICkge1xuXHRcdFx0XHRyZXR1cm4gMjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LndoaWNoO1xuXHR9XG59LCBqUXVlcnkuZXZlbnQuYWRkUHJvcCApO1xuXG5qUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggdHlwZSwgZGVsZWdhdGVUeXBlICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdID0ge1xuXG5cdFx0Ly8gVXRpbGl6ZSBuYXRpdmUgZXZlbnQgaWYgcG9zc2libGUgc28gYmx1ci9mb2N1cyBzZXF1ZW5jZSBpcyBjb3JyZWN0XG5cdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImZvY3VzXCIsIC4uLiApXG5cdFx0XHQvLyBkYXRhUHJpdi5zZXQoIHRoaXMsIFwiYmx1clwiLCAuLi4gKVxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUsIGV4cGVjdFN5bmMgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIGZhbHNlIHRvIGFsbG93IG5vcm1hbCBwcm9jZXNzaW5nIGluIHRoZSBjYWxsZXJcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBGb3JjZSBzZXR1cCBiZWZvcmUgdHJpZ2dlclxuXHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIHRoaXMsIHR5cGUgKTtcblxuXHRcdFx0Ly8gUmV0dXJuIG5vbi1mYWxzZSB0byBhbGxvdyBub3JtYWwgZXZlbnQtcGF0aCBwcm9wYWdhdGlvblxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdGRlbGVnYXRlVHlwZTogZGVsZWdhdGVUeXBlXG5cdH07XG59ICk7XG5cbi8vIENyZWF0ZSBtb3VzZWVudGVyL2xlYXZlIGV2ZW50cyB1c2luZyBtb3VzZW92ZXIvb3V0IGFuZCBldmVudC10aW1lIGNoZWNrc1xuLy8gc28gdGhhdCBldmVudCBkZWxlZ2F0aW9uIHdvcmtzIGluIGpRdWVyeS5cbi8vIERvIHRoZSBzYW1lIGZvciBwb2ludGVyZW50ZXIvcG9pbnRlcmxlYXZlIGFuZCBwb2ludGVyb3Zlci9wb2ludGVyb3V0XG4vL1xuLy8gU3VwcG9ydDogU2FmYXJpIDcgb25seVxuLy8gU2FmYXJpIHNlbmRzIG1vdXNlZW50ZXIgdG9vIG9mdGVuOyBzZWU6XG4vLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD00NzAyNThcbi8vIGZvciB0aGUgZGVzY3JpcHRpb24gb2YgdGhlIGJ1ZyAoaXQgZXhpc3RlZCBpbiBvbGRlciBDaHJvbWUgdmVyc2lvbnMgYXMgd2VsbCkuXG5qUXVlcnkuZWFjaCgge1xuXHRtb3VzZWVudGVyOiBcIm1vdXNlb3ZlclwiLFxuXHRtb3VzZWxlYXZlOiBcIm1vdXNlb3V0XCIsXG5cdHBvaW50ZXJlbnRlcjogXCJwb2ludGVyb3ZlclwiLFxuXHRwb2ludGVybGVhdmU6IFwicG9pbnRlcm91dFwiXG59LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgb3JpZyBdID0ge1xuXHRcdGRlbGVnYXRlVHlwZTogZml4LFxuXHRcdGJpbmRUeXBlOiBmaXgsXG5cblx0XHRoYW5kbGU6IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdHZhciByZXQsXG5cdFx0XHRcdHRhcmdldCA9IHRoaXMsXG5cdFx0XHRcdHJlbGF0ZWQgPSBldmVudC5yZWxhdGVkVGFyZ2V0LFxuXHRcdFx0XHRoYW5kbGVPYmogPSBldmVudC5oYW5kbGVPYmo7XG5cblx0XHRcdC8vIEZvciBtb3VzZWVudGVyL2xlYXZlIGNhbGwgdGhlIGhhbmRsZXIgaWYgcmVsYXRlZCBpcyBvdXRzaWRlIHRoZSB0YXJnZXQuXG5cdFx0XHQvLyBOQjogTm8gcmVsYXRlZFRhcmdldCBpZiB0aGUgbW91c2UgbGVmdC9lbnRlcmVkIHRoZSBicm93c2VyIHdpbmRvd1xuXHRcdFx0aWYgKCAhcmVsYXRlZCB8fCAoIHJlbGF0ZWQgIT09IHRhcmdldCAmJiAhalF1ZXJ5LmNvbnRhaW5zKCB0YXJnZXQsIHJlbGF0ZWQgKSApICkge1xuXHRcdFx0XHRldmVudC50eXBlID0gaGFuZGxlT2JqLm9yaWdUeXBlO1xuXHRcdFx0XHRyZXQgPSBoYW5kbGVPYmouaGFuZGxlci5hcHBseSggdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBmaXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cblx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZXNsaW50L2VzbGludC9pc3N1ZXMvMzIyOVxuXHRyeGh0bWxUYWcgPSAvPCg/IWFyZWF8YnJ8Y29sfGVtYmVkfGhyfGltZ3xpbnB1dHxsaW5rfG1ldGF8cGFyYW0pKChbYS16XVteXFwvXFwwPlxceDIwXFx0XFxyXFxuXFxmXSopW14+XSopXFwvPi9naSxcblxuXHQvKiBlc2xpbnQtZW5hYmxlICovXG5cblx0Ly8gU3VwcG9ydDogSUUgPD0xMCAtIDExLCBFZGdlIDEyIC0gMTMgb25seVxuXHQvLyBJbiBJRS9FZGdlIHVzaW5nIHJlZ2V4IGdyb3VwcyBoZXJlIGNhdXNlcyBzZXZlcmUgc2xvd2Rvd25zLlxuXHQvLyBTZWUgaHR0cHM6Ly9jb25uZWN0Lm1pY3Jvc29mdC5jb20vSUUvZmVlZGJhY2svZGV0YWlscy8xNzM2NTEyL1xuXHRybm9Jbm5lcmh0bWwgPSAvPHNjcmlwdHw8c3R5bGV8PGxpbmsvaSxcblxuXHQvLyBjaGVja2VkPVwiY2hlY2tlZFwiIG9yIGNoZWNrZWRcblx0cmNoZWNrZWQgPSAvY2hlY2tlZFxccyooPzpbXj1dfD1cXHMqLmNoZWNrZWQuKS9pLFxuXHRyY2xlYW5TY3JpcHQgPSAvXlxccyo8ISg/OlxcW0NEQVRBXFxbfC0tKXwoPzpcXF1cXF18LS0pPlxccyokL2c7XG5cbi8vIFByZWZlciBhIHRib2R5IG92ZXIgaXRzIHBhcmVudCB0YWJsZSBmb3IgY29udGFpbmluZyBuZXcgcm93c1xuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRhYmxlXCIgKSAmJlxuXHRcdG5vZGVOYW1lKCBjb250ZW50Lm5vZGVUeXBlICE9PSAxMSA/IGNvbnRlbnQgOiBjb250ZW50LmZpcnN0Q2hpbGQsIFwidHJcIiApICkge1xuXG5cdFx0cmV0dXJuIGpRdWVyeSggZWxlbSApLmNoaWxkcmVuKCBcInRib2R5XCIgKVsgMCBdIHx8IGVsZW07XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxuLy8gUmVwbGFjZS9yZXN0b3JlIHRoZSB0eXBlIGF0dHJpYnV0ZSBvZiBzY3JpcHQgZWxlbWVudHMgZm9yIHNhZmUgRE9NIG1hbmlwdWxhdGlvblxuZnVuY3Rpb24gZGlzYWJsZVNjcmlwdCggZWxlbSApIHtcblx0ZWxlbS50eXBlID0gKCBlbGVtLmdldEF0dHJpYnV0ZSggXCJ0eXBlXCIgKSAhPT0gbnVsbCApICsgXCIvXCIgKyBlbGVtLnR5cGU7XG5cdHJldHVybiBlbGVtO1xufVxuZnVuY3Rpb24gcmVzdG9yZVNjcmlwdCggZWxlbSApIHtcblx0aWYgKCAoIGVsZW0udHlwZSB8fCBcIlwiICkuc2xpY2UoIDAsIDUgKSA9PT0gXCJ0cnVlL1wiICkge1xuXHRcdGVsZW0udHlwZSA9IGVsZW0udHlwZS5zbGljZSggNSApO1xuXHR9IGVsc2Uge1xuXHRcdGVsZW0ucmVtb3ZlQXR0cmlidXRlKCBcInR5cGVcIiApO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmZ1bmN0aW9uIGNsb25lQ29weUV2ZW50KCBzcmMsIGRlc3QgKSB7XG5cdHZhciBpLCBsLCB0eXBlLCBwZGF0YU9sZCwgcGRhdGFDdXIsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuYWNjZXNzKCBzcmMgKTtcblx0XHRwZGF0YUN1ciA9IGRhdGFQcml2LnNldCggZGVzdCwgcGRhdGFPbGQgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRlbGV0ZSBwZGF0YUN1ci5oYW5kbGU7XG5cdFx0XHRwZGF0YUN1ci5ldmVudHMgPSB7fTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGNvbmNhdC5hcHBseSggW10sIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0RE9NRXZhbCggbm9kZS50ZXh0Q29udGVudC5yZXBsYWNlKCByY2xlYW5TY3JpcHQsIFwiXCIgKSwgbm9kZSwgZG9jICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBpc0F0dGFjaGVkKCBub2RlICkgKSB7XG5cdFx0XHRcdHNldEdsb2JhbEV2YWwoIGdldEFsbCggbm9kZSwgXCJzY3JpcHRcIiApICk7XG5cdFx0XHR9XG5cdFx0XHRub2RlLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIG5vZGUgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXHRodG1sUHJlZmlsdGVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRyZXR1cm4gaHRtbC5yZXBsYWNlKCByeGh0bWxUYWcsIFwiPCQxPjwvJDI+XCIgKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGVsZW0sIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdHZhciBpLCBsLCBzcmNFbGVtZW50cywgZGVzdEVsZW1lbnRzLFxuXHRcdFx0Y2xvbmUgPSBlbGVtLmNsb25lTm9kZSggdHJ1ZSApLFxuXHRcdFx0aW5QYWdlID0gaXNBdHRhY2hlZCggZWxlbSApO1xuXG5cdFx0Ly8gRml4IElFIGNsb25pbmcgaXNzdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCAmJiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgZWxlbS5ub2RlVHlwZSA9PT0gMTEgKSAmJlxuXHRcdFx0XHQhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIFdlIGVzY2hldyBTaXp6bGUgaGVyZSBmb3IgcGVyZm9ybWFuY2UgcmVhc29uczogaHR0cHM6Ly9qc3BlcmYuY29tL2dldGFsbC12cy1zaXp6bGUvMlxuXHRcdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSApO1xuXHRcdFx0c3JjRWxlbWVudHMgPSBnZXRBbGwoIGVsZW0gKTtcblxuXHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZpeElucHV0KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvcHkgdGhlIGV2ZW50cyBmcm9tIHRoZSBvcmlnaW5hbCB0byB0aGUgY2xvbmVcblx0XHRpZiAoIGRhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRpZiAoIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0XHRzcmNFbGVtZW50cyA9IHNyY0VsZW1lbnRzIHx8IGdldEFsbCggZWxlbSApO1xuXHRcdFx0XHRkZXN0RWxlbWVudHMgPSBkZXN0RWxlbWVudHMgfHwgZ2V0QWxsKCBjbG9uZSApO1xuXG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGNsb25lQ29weUV2ZW50KCBzcmNFbGVtZW50c1sgaSBdLCBkZXN0RWxlbWVudHNbIGkgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjbG9uZUNvcHlFdmVudCggZWxlbSwgY2xvbmUgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBQcmVzZXJ2ZSBzY3JpcHQgZXZhbHVhdGlvbiBoaXN0b3J5XG5cdFx0ZGVzdEVsZW1lbnRzID0gZ2V0QWxsKCBjbG9uZSwgXCJzY3JpcHRcIiApO1xuXHRcdGlmICggZGVzdEVsZW1lbnRzLmxlbmd0aCA+IDAgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCBkZXN0RWxlbWVudHMsICFpblBhZ2UgJiYgZ2V0QWxsKCBlbGVtLCBcInNjcmlwdFwiICkgKTtcblx0XHR9XG5cblx0XHQvLyBSZXR1cm4gdGhlIGNsb25lZCBzZXRcblx0XHRyZXR1cm4gY2xvbmU7XG5cdH0sXG5cblx0Y2xlYW5EYXRhOiBmdW5jdGlvbiggZWxlbXMgKSB7XG5cdFx0dmFyIGRhdGEsIGVsZW0sIHR5cGUsXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWwsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9PSB1bmRlZmluZWQ7IGkrKyApIHtcblx0XHRcdGlmICggYWNjZXB0RGF0YSggZWxlbSApICkge1xuXHRcdFx0XHRpZiAoICggZGF0YSA9IGVsZW1bIGRhdGFQcml2LmV4cGFuZG8gXSApICkge1xuXHRcdFx0XHRcdGlmICggZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCB0eXBlIGluIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoIHNwZWNpYWxbIHR5cGUgXSApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICk7XG5cblx0XHRcdFx0XHRcdFx0Ly8gVGhpcyBpcyBhIHNob3J0Y3V0IHRvIGF2b2lkIGpRdWVyeS5ldmVudC5yZW1vdmUncyBvdmVyaGVhZFxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PTM1IC0gNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRkZXRhY2g6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gcmVtb3ZlKCB0aGlzLCBzZWxlY3RvciwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yICk7XG5cdH0sXG5cblx0dGV4dDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnRleHQoIHRoaXMgKSA6XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdHRoaXMudGV4dENvbnRlbnQgPSB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdGFwcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdHByZXBlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR2YXIgdGFyZ2V0ID0gbWFuaXB1bGF0aW9uVGFyZ2V0KCB0aGlzLCBlbGVtICk7XG5cdFx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoIGVsZW0sIHRhcmdldC5maXJzdENoaWxkICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGJlZm9yZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YWZ0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdGlmICggdGhpcy5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR0aGlzLnBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKCBlbGVtLCB0aGlzLm5leHRTaWJsaW5nICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGVtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZWxlbSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSB0aGlzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0Ly8gUHJldmVudCBtZW1vcnkgbGVha3Ncblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCBlbGVtLCBmYWxzZSApICk7XG5cblx0XHRcdFx0Ly8gUmVtb3ZlIGFueSByZW1haW5pbmcgbm9kZXNcblx0XHRcdFx0ZWxlbS50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRkYXRhQW5kRXZlbnRzID0gZGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZmFsc2UgOiBkYXRhQW5kRXZlbnRzO1xuXHRcdGRlZXBEYXRhQW5kRXZlbnRzID0gZGVlcERhdGFBbmRFdmVudHMgPT0gbnVsbCA/IGRhdGFBbmRFdmVudHMgOiBkZWVwRGF0YUFuZEV2ZW50cztcblxuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNsb25lKCB0aGlzLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApO1xuXHRcdH0gKTtcblx0fSxcblxuXHRodG1sOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF0gfHwge30sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRsID0gdGhpcy5sZW5ndGg7XG5cblx0XHRcdGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pbm5lckhUTUw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNlZSBpZiB3ZSBjYW4gdGFrZSBhIHNob3J0Y3V0IGFuZCBqdXN0IHVzZSBpbm5lckhUTUxcblx0XHRcdGlmICggdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmICFybm9Jbm5lcmh0bWwudGVzdCggdmFsdWUgKSAmJlxuXHRcdFx0XHQhd3JhcE1hcFsgKCBydGFnTmFtZS5leGVjKCB2YWx1ZSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpIF0gKSB7XG5cblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuaHRtbFByZWZpbHRlciggdmFsdWUgKTtcblxuXHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRcdGVsZW0gPSB0aGlzWyBpIF0gfHwge307XG5cblx0XHRcdFx0XHRcdC8vIFJlbW92ZSBlbGVtZW50IG5vZGVzIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0XHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblx0XHRcdFx0XHRcdFx0ZWxlbS5pbm5lckhUTUwgPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtID0gMDtcblxuXHRcdFx0XHQvLyBJZiB1c2luZyBpbm5lckhUTUwgdGhyb3dzIGFuIGV4Y2VwdGlvbiwgdXNlIHRoZSBmYWxsYmFjayBtZXRob2Rcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdHRoaXMuZW1wdHkoKS5hcHBlbmQoIHZhbHVlICk7XG5cdFx0XHR9XG5cdFx0fSwgbnVsbCwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggKTtcblx0fSxcblxuXHRyZXBsYWNlV2l0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGlnbm9yZWQgPSBbXTtcblxuXHRcdC8vIE1ha2UgdGhlIGNoYW5nZXMsIHJlcGxhY2luZyBlYWNoIG5vbi1pZ25vcmVkIGNvbnRleHQgZWxlbWVudCB3aXRoIHRoZSBuZXcgY29udGVudFxuXHRcdHJldHVybiBkb21NYW5pcCggdGhpcywgYXJndW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLnBhcmVudE5vZGU7XG5cblx0XHRcdGlmICggalF1ZXJ5LmluQXJyYXkoIHRoaXMsIGlnbm9yZWQgKSA8IDAgKSB7XG5cdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggdGhpcyApICk7XG5cdFx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRcdHBhcmVudC5yZXBsYWNlQ2hpbGQoIGVsZW0sIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gRm9yY2UgY2FsbGJhY2sgaW52b2NhdGlvblxuXHRcdH0sIGlnbm9yZWQgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCgge1xuXHRhcHBlbmRUbzogXCJhcHBlbmRcIixcblx0cHJlcGVuZFRvOiBcInByZXBlbmRcIixcblx0aW5zZXJ0QmVmb3JlOiBcImJlZm9yZVwiLFxuXHRpbnNlcnRBZnRlcjogXCJhZnRlclwiLFxuXHRyZXBsYWNlQWxsOiBcInJlcGxhY2VXaXRoXCJcbn0sIGZ1bmN0aW9uKCBuYW1lLCBvcmlnaW5hbCApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0dmFyIGVsZW1zLFxuXHRcdFx0cmV0ID0gW10sXG5cdFx0XHRpbnNlcnQgPSBqUXVlcnkoIHNlbGVjdG9yICksXG5cdFx0XHRsYXN0ID0gaW5zZXJ0Lmxlbmd0aCAtIDEsXG5cdFx0XHRpID0gMDtcblxuXHRcdGZvciAoIDsgaSA8PSBsYXN0OyBpKysgKSB7XG5cdFx0XHRlbGVtcyA9IGkgPT09IGxhc3QgPyB0aGlzIDogdGhpcy5jbG9uZSggdHJ1ZSApO1xuXHRcdFx0alF1ZXJ5KCBpbnNlcnRbIGkgXSApWyBvcmlnaW5hbCBdKCBlbGVtcyApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdC8vIC5nZXQoKSBiZWNhdXNlIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdHB1c2guYXBwbHkoIHJldCwgZWxlbXMuZ2V0KCkgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHJldCApO1xuXHR9O1xufSApO1xudmFyIHJudW1ub25weCA9IG5ldyBSZWdFeHAoIFwiXihcIiArIHBudW0gKyBcIikoPyFweClbYS16JV0rJFwiLCBcImlcIiApO1xuXG52YXIgZ2V0U3R5bGVzID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHksIEZpcmVmb3ggPD0zMCAoIzE1MDk4LCAjMTQxNTApXG5cdFx0Ly8gSUUgdGhyb3dzIG9uIGVsZW1lbnRzIGNyZWF0ZWQgaW4gcG9wdXBzXG5cdFx0Ly8gRkYgbWVhbndoaWxlIHRocm93cyBvbiBmcmFtZSBlbGVtZW50cyB0aHJvdWdoIFwiZGVmYXVsdFZpZXcuZ2V0Q29tcHV0ZWRTdHlsZVwiXG5cdFx0dmFyIHZpZXcgPSBlbGVtLm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXc7XG5cblx0XHRpZiAoICF2aWV3IHx8ICF2aWV3Lm9wZW5lciApIHtcblx0XHRcdHZpZXcgPSB3aW5kb3c7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHZpZXcuZ2V0Q29tcHV0ZWRTdHlsZSggZWxlbSApO1xuXHR9O1xuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwsXG5cdFx0Y29udGFpbmVyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLFxuXHRcdGRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKTtcblxuXHQvLyBGaW5pc2ggZWFybHkgaW4gbGltaXRlZCAobm9uLWJyb3dzZXIpIGVudmlyb25tZW50c1xuXHRpZiAoICFkaXYuc3R5bGUgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHQvLyBTdHlsZSBvZiBjbG9uZWQgZWxlbWVudCBhZmZlY3RzIHNvdXJjZSBlbGVtZW50IGNsb25lZCAoIzg5MDgpXG5cdGRpdi5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiY29udGVudC1ib3hcIjtcblx0ZGl2LmNsb25lTm9kZSggdHJ1ZSApLnN0eWxlLmJhY2tncm91bmRDbGlwID0gXCJcIjtcblx0c3VwcG9ydC5jbGVhckNsb25lU3R5bGUgPSBkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPT09IFwiY29udGVudC1ib3hcIjtcblxuXHRqUXVlcnkuZXh0ZW5kKCBzdXBwb3J0LCB7XG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBib3hTaXppbmdSZWxpYWJsZVZhbDtcblx0XHR9LFxuXHRcdHBpeGVsQm94U3R5bGVzOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxCb3hTdHlsZXNWYWw7XG5cdFx0fSxcblx0XHRwaXhlbFBvc2l0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gcGl4ZWxQb3NpdGlvblZhbDtcblx0XHR9LFxuXHRcdHJlbGlhYmxlTWFyZ2luTGVmdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHJlbGlhYmxlTWFyZ2luTGVmdFZhbDtcblx0XHR9LFxuXHRcdHNjcm9sbGJveFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBzY3JvbGxib3hTaXplVmFsO1xuXHRcdH1cblx0fSApO1xufSApKCk7XG5cblxuZnVuY3Rpb24gY3VyQ1NTKCBlbGVtLCBuYW1lLCBjb21wdXRlZCApIHtcblx0dmFyIHdpZHRoLCBtaW5XaWR0aCwgbWF4V2lkdGgsIHJldCxcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggNTErXG5cdFx0Ly8gUmV0cmlldmluZyBzdHlsZSBiZWZvcmUgY29tcHV0ZWQgc29tZWhvd1xuXHRcdC8vIGZpeGVzIGFuIGlzc3VlIHdpdGggZ2V0dGluZyB3cm9uZyB2YWx1ZXNcblx0XHQvLyBvbiBkZXRhY2hlZCBlbGVtZW50c1xuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIGdldFByb3BlcnR5VmFsdWUgaXMgbmVlZGVkIGZvcjpcblx0Ly8gICAuY3NzKCdmaWx0ZXInKSAoSUUgOSBvbmx5LCAjMTI1MzcpXG5cdC8vICAgLmNzcygnLS1jdXN0b21Qcm9wZXJ0eSkgKCMzMTQ0KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWlzQXR0YWNoZWQoIGVsZW0gKSApIHtcblx0XHRcdHJldCA9IGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSApO1xuXHRcdH1cblxuXHRcdC8vIEEgdHJpYnV0ZSB0byB0aGUgXCJhd2Vzb21lIGhhY2sgYnkgRGVhbiBFZHdhcmRzXCJcblx0XHQvLyBBbmRyb2lkIEJyb3dzZXIgcmV0dXJucyBwZXJjZW50YWdlIGZvciBzb21lIHZhbHVlcyxcblx0XHQvLyBidXQgd2lkdGggc2VlbXMgdG8gYmUgcmVsaWFibHkgcGl4ZWxzLlxuXHRcdC8vIFRoaXMgaXMgYWdhaW5zdCB0aGUgQ1NTT00gZHJhZnQgc3BlYzpcblx0XHQvLyBodHRwczovL2RyYWZ0cy5jc3N3Zy5vcmcvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxCb3hTdHlsZXMoKSAmJiBybnVtbm9ucHgudGVzdCggcmV0ICkgJiYgcmJveFN0eWxlLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSBvbmx5XG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyIGNzc1ByZWZpeGVzID0gWyBcIldlYmtpdFwiLCBcIk1velwiLCBcIm1zXCIgXSxcblx0ZW1wdHlTdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKS5zdHlsZSxcblx0dmVuZG9yUHJvcHMgPSB7fTtcblxuLy8gUmV0dXJuIGEgdmVuZG9yLXByZWZpeGVkIHByb3BlcnR5IG9yIHVuZGVmaW5lZFxuZnVuY3Rpb24gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB7XG5cblx0Ly8gQ2hlY2sgZm9yIHZlbmRvciBwcmVmaXhlZCBuYW1lc1xuXHR2YXIgY2FwTmFtZSA9IG5hbWVbIDAgXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zbGljZSggMSApLFxuXHRcdGkgPSBjc3NQcmVmaXhlcy5sZW5ndGg7XG5cblx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0bmFtZSA9IGNzc1ByZWZpeGVzWyBpIF0gKyBjYXBOYW1lO1xuXHRcdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdFx0cmV0dXJuIG5hbWU7XG5cdFx0fVxuXHR9XG59XG5cbi8vIFJldHVybiBhIHBvdGVudGlhbGx5LW1hcHBlZCBqUXVlcnkuY3NzUHJvcHMgb3IgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiBmaW5hbFByb3BOYW1lKCBuYW1lICkge1xuXHR2YXIgZmluYWwgPSBqUXVlcnkuY3NzUHJvcHNbIG5hbWUgXSB8fCB2ZW5kb3JQcm9wc1sgbmFtZSBdO1xuXG5cdGlmICggZmluYWwgKSB7XG5cdFx0cmV0dXJuIGZpbmFsO1xuXHR9XG5cdGlmICggbmFtZSBpbiBlbXB0eVN0eWxlICkge1xuXHRcdHJldHVybiBuYW1lO1xuXHR9XG5cdHJldHVybiB2ZW5kb3JQcm9wc1sgbmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG5hbWUgKSB8fCBuYW1lO1xufVxuXG5cbnZhclxuXG5cdC8vIFN3YXBwYWJsZSBpZiBkaXNwbGF5IGlzIG5vbmUgb3Igc3RhcnRzIHdpdGggdGFibGVcblx0Ly8gZXhjZXB0IFwidGFibGVcIiwgXCJ0YWJsZS1jZWxsXCIsIG9yIFwidGFibGUtY2FwdGlvblwiXG5cdC8vIFNlZSBoZXJlIGZvciBkaXNwbGF5IHZhbHVlczogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9DU1MvZGlzcGxheVxuXHRyZGlzcGxheXN3YXAgPSAvXihub25lfHRhYmxlKD8hLWNbZWFdKS4rKS8sXG5cdHJjdXN0b21Qcm9wID0gL14tLS8sXG5cdGNzc1Nob3cgPSB7IHBvc2l0aW9uOiBcImFic29sdXRlXCIsIHZpc2liaWxpdHk6IFwiaGlkZGVuXCIsIGRpc3BsYXk6IFwiYmxvY2tcIiB9LFxuXHRjc3NOb3JtYWxUcmFuc2Zvcm0gPSB7XG5cdFx0bGV0dGVyU3BhY2luZzogXCIwXCIsXG5cdFx0Zm9udFdlaWdodDogXCI0MDBcIlxuXHR9O1xuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIEZhbGwgYmFjayB0byBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgd2hlbiB2YWx1ZSBpcyBcImF1dG9cIlxuXHQvLyBUaGlzIGhhcHBlbnMgZm9yIGlubGluZSBlbGVtZW50cyB3aXRoIG5vIGV4cGxpY2l0IHNldHRpbmcgKGdoLTM1NzEpXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHQvLyBBbHNvIHVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIG1pc3JlcG9ydGVkIGlubGluZSBkaW1lbnNpb25zIChnaC0zNjAyKVxuXHQvLyBTdXBwb3J0OiBJRSA5LTExIG9ubHlcblx0Ly8gQWxzbyB1c2Ugb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGZvciB3aGVuIGJveCBzaXppbmcgaXMgdW5yZWxpYWJsZVxuXHQvLyBXZSB1c2UgZ2V0Q2xpZW50UmVjdHMoKSB0byBjaGVjayBmb3IgaGlkZGVuL2Rpc2Nvbm5lY3RlZC5cblx0Ly8gSW4gdGhvc2UgY2FzZXMsIHRoZSBjb21wdXRlZCB2YWx1ZSBjYW4gYmUgdHJ1c3RlZCB0byBiZSBib3JkZXItYm94XG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cdFx0dmFsID09PSBcImF1dG9cIiB8fFxuXHRcdCFwYXJzZUZsb2F0KCB2YWwgKSAmJiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImlubGluZVwiICkgJiZcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImdyaWRBcmVhXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uU3RhcnRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dFbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dTdGFydFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggaSwgZGltZW5zaW9uICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIGRpbWVuc2lvbiBdID0ge1xuXHRcdGdldDogZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkLCBleHRyYSApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0Ly8gQ2VydGFpbiBlbGVtZW50cyBjYW4gaGF2ZSBkaW1lbnNpb24gaW5mbyBpZiB3ZSBpbnZpc2libHkgc2hvdyB0aGVtXG5cdFx0XHRcdC8vIGJ1dCBpdCBtdXN0IGhhdmUgYSBjdXJyZW50IGRpc3BsYXkgc3R5bGUgdGhhdCB3b3VsZCBiZW5lZml0XG5cdFx0XHRcdHJldHVybiByZGlzcGxheXN3YXAudGVzdCggalF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSApICYmXG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCtcblx0XHRcdFx0XHQvLyBUYWJsZSBjb2x1bW5zIGluIFNhZmFyaSBoYXZlIG5vbi16ZXJvIG9mZnNldFdpZHRoICYgemVyb1xuXHRcdFx0XHRcdC8vIGdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoIHVubGVzcyBkaXNwbGF5IGlzIGNoYW5nZWQuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0XHRcdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYSBkaXNjb25uZWN0ZWQgbm9kZVxuXHRcdFx0XHRcdC8vIGluIElFIHRocm93cyBhbiBlcnJvci5cblx0XHRcdFx0XHQoICFlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoIHx8ICFlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICkgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBkaW1lbnNpb24sIGV4dHJhICk7XG5cdFx0XHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRcdFx0Z2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSwgZXh0cmEgKSB7XG5cdFx0XHR2YXIgbWF0Y2hlcyxcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHRcdFx0Ly8gT25seSByZWFkIHN0eWxlcy5wb3NpdGlvbiBpZiB0aGUgdGVzdCBoYXMgYSBjaGFuY2UgdG8gZmFpbFxuXHRcdFx0XHQvLyB0byBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LlxuXHRcdFx0XHRzY3JvbGxib3hTaXplQnVnZ3kgPSAhc3VwcG9ydC5zY3JvbGxib3hTaXplKCkgJiZcblx0XHRcdFx0XHRzdHlsZXMucG9zaXRpb24gPT09IFwiYWJzb2x1dGVcIixcblxuXHRcdFx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC0zOTkxKVxuXHRcdFx0XHRib3hTaXppbmdOZWVkZWQgPSBzY3JvbGxib3hTaXplQnVnZ3kgfHwgZXh0cmEsXG5cdFx0XHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSA/XG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0XHRcdFx0ZWxlbSxcblx0XHRcdFx0XHRcdGRpbWVuc2lvbixcblx0XHRcdFx0XHRcdGV4dHJhLFxuXHRcdFx0XHRcdFx0aXNCb3JkZXJCb3gsXG5cdFx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0XHQpIDpcblx0XHRcdFx0XHQwO1xuXG5cdFx0XHQvLyBBY2NvdW50IGZvciB1bnJlbGlhYmxlIGJvcmRlci1ib3ggZGltZW5zaW9ucyBieSBjb21wYXJpbmcgb2Zmc2V0KiB0byBjb21wdXRlZCBhbmRcblx0XHRcdC8vIGZha2luZyBhIGNvbnRlbnQtYm94IHRvIGdldCBib3JkZXIgYW5kIHBhZGRpbmcgKGdoLTM2OTkpXG5cdFx0XHRpZiAoIGlzQm9yZGVyQm94ICYmIHNjcm9sbGJveFNpemVCdWdneSApIHtcblx0XHRcdFx0c3VidHJhY3QgLT0gTWF0aC5jZWlsKFxuXHRcdFx0XHRcdGVsZW1bIFwib2Zmc2V0XCIgKyBkaW1lbnNpb25bIDAgXS50b1VwcGVyQ2FzZSgpICsgZGltZW5zaW9uLnNsaWNlKCAxICkgXSAtXG5cdFx0XHRcdFx0cGFyc2VGbG9hdCggc3R5bGVzWyBkaW1lbnNpb24gXSApIC1cblx0XHRcdFx0XHRib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgXCJib3JkZXJcIiwgZmFsc2UsIHN0eWxlcyApIC1cblx0XHRcdFx0XHQwLjVcblx0XHRcdFx0KTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBkaW1lbnNpb24gXSA9IHZhbHVlO1xuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5jc3MoIGVsZW0sIGRpbWVuc2lvbiApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gc2V0UG9zaXRpdmVOdW1iZXIoIGVsZW0sIHZhbHVlLCBzdWJ0cmFjdCApO1xuXHRcdH1cblx0fTtcbn0gKTtcblxualF1ZXJ5LmNzc0hvb2tzLm1hcmdpbkxlZnQgPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucmVsaWFibGVNYXJnaW5MZWZ0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiAoIHBhcnNlRmxvYXQoIGN1ckNTUyggZWxlbSwgXCJtYXJnaW5MZWZ0XCIgKSApIHx8XG5cdFx0XHRcdGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdCAtXG5cdFx0XHRcdFx0c3dhcCggZWxlbSwgeyBtYXJnaW5MZWZ0OiAwIH0sIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkubGVmdDtcblx0XHRcdFx0XHR9IClcblx0XHRcdFx0KSArIFwicHhcIjtcblx0XHR9XG5cdH1cbik7XG5cbi8vIFRoZXNlIGhvb2tzIGFyZSB1c2VkIGJ5IGFuaW1hdGUgdG8gZXhwYW5kIHByb3BlcnRpZXNcbmpRdWVyeS5lYWNoKCB7XG5cdG1hcmdpbjogXCJcIixcblx0cGFkZGluZzogXCJcIixcblx0Ym9yZGVyOiBcIldpZHRoXCJcbn0sIGZ1bmN0aW9uKCBwcmVmaXgsIHN1ZmZpeCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcmVmaXggKyBzdWZmaXggXSA9IHtcblx0XHRleHBhbmQ6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBpID0gMCxcblx0XHRcdFx0ZXhwYW5kZWQgPSB7fSxcblxuXHRcdFx0XHQvLyBBc3N1bWVzIGEgc2luZ2xlIG51bWJlciBpZiBub3QgYSBzdHJpbmdcblx0XHRcdFx0cGFydHMgPSB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgPyB2YWx1ZS5zcGxpdCggXCIgXCIgKSA6IFsgdmFsdWUgXTtcblxuXHRcdFx0Zm9yICggOyBpIDwgNDsgaSsrICkge1xuXHRcdFx0XHRleHBhbmRlZFsgcHJlZml4ICsgY3NzRXhwYW5kWyBpIF0gKyBzdWZmaXggXSA9XG5cdFx0XHRcdFx0cGFydHNbIGkgXSB8fCBwYXJ0c1sgaSAtIDIgXSB8fCBwYXJ0c1sgMCBdO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9O1xuXG5cdGlmICggcHJlZml4ICE9PSBcIm1hcmdpblwiICkge1xuXHRcdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0uc2V0ID0gc2V0UG9zaXRpdmVOdW1iZXI7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRjc3M6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgc3R5bGVzLCBsZW4sXG5cdFx0XHRcdG1hcCA9IHt9LFxuXHRcdFx0XHRpID0gMDtcblxuXHRcdFx0aWYgKCBBcnJheS5pc0FycmF5KCBuYW1lICkgKSB7XG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApO1xuXHRcdFx0XHRsZW4gPSBuYW1lLmxlbmd0aDtcblxuXHRcdFx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdFx0XHRtYXBbIG5hbWVbIGkgXSBdID0galF1ZXJ5LmNzcyggZWxlbSwgbmFtZVsgaSBdLCBmYWxzZSwgc3R5bGVzICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gbWFwO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgbmFtZSwgdmFsdWUgKSA6XG5cdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIG5hbWUgKTtcblx0XHR9LCBuYW1lLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgKTtcblx0fVxufSApO1xuXG5cbmZ1bmN0aW9uIFR3ZWVuKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZyApIHtcblx0cmV0dXJuIG5ldyBUd2Vlbi5wcm90b3R5cGUuaW5pdCggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKTtcbn1cbmpRdWVyeS5Ud2VlbiA9IFR3ZWVuO1xuXG5Ud2Vlbi5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBUd2Vlbixcblx0aW5pdDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nLCB1bml0ICkge1xuXHRcdHRoaXMuZWxlbSA9IGVsZW07XG5cdFx0dGhpcy5wcm9wID0gcHJvcDtcblx0XHR0aGlzLmVhc2luZyA9IGVhc2luZyB8fCBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0O1xuXHRcdHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG5cdFx0dGhpcy5zdGFydCA9IHRoaXMubm93ID0gdGhpcy5jdXIoKTtcblx0XHR0aGlzLmVuZCA9IGVuZDtcblx0XHR0aGlzLnVuaXQgPSB1bml0IHx8ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdID8gXCJcIiA6IFwicHhcIiApO1xuXHR9LFxuXHRjdXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRyZXR1cm4gaG9va3MgJiYgaG9va3MuZ2V0ID9cblx0XHRcdGhvb2tzLmdldCggdGhpcyApIDpcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5nZXQoIHRoaXMgKTtcblx0fSxcblx0cnVuOiBmdW5jdGlvbiggcGVyY2VudCApIHtcblx0XHR2YXIgZWFzZWQsXG5cdFx0XHRob29rcyA9IFR3ZWVuLnByb3BIb29rc1sgdGhpcy5wcm9wIF07XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5kdXJhdGlvbiApIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBqUXVlcnkuZWFzaW5nWyB0aGlzLmVhc2luZyBdKFxuXHRcdFx0XHRwZXJjZW50LCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKiBwZXJjZW50LCAwLCAxLCB0aGlzLm9wdGlvbnMuZHVyYXRpb25cblx0XHRcdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMucG9zID0gZWFzZWQgPSBwZXJjZW50O1xuXHRcdH1cblx0XHR0aGlzLm5vdyA9ICggdGhpcy5lbmQgLSB0aGlzLnN0YXJ0ICkgKiBlYXNlZCArIHRoaXMuc3RhcnQ7XG5cblx0XHRpZiAoIHRoaXMub3B0aW9ucy5zdGVwICkge1xuXHRcdFx0dGhpcy5vcHRpb25zLnN0ZXAuY2FsbCggdGhpcy5lbGVtLCB0aGlzLm5vdywgdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgaG9va3Muc2V0ICkge1xuXHRcdFx0aG9va3Muc2V0KCB0aGlzICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdFR3ZWVuLnByb3BIb29rcy5fZGVmYXVsdC5zZXQoIHRoaXMgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn07XG5cblR3ZWVuLnByb3RvdHlwZS5pbml0LnByb3RvdHlwZSA9IFR3ZWVuLnByb3RvdHlwZTtcblxuVHdlZW4ucHJvcEhvb2tzID0ge1xuXHRfZGVmYXVsdDoge1xuXHRcdGdldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdFx0dmFyIHJlc3VsdDtcblxuXHRcdFx0Ly8gVXNlIGEgcHJvcGVydHkgb24gdGhlIGVsZW1lbnQgZGlyZWN0bHkgd2hlbiBpdCBpcyBub3QgYSBET00gZWxlbWVudCxcblx0XHRcdC8vIG9yIHdoZW4gdGhlcmUgaXMgbm8gbWF0Y2hpbmcgc3R5bGUgcHJvcGVydHkgdGhhdCBleGlzdHMuXG5cdFx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgIT09IDEgfHxcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdICE9IG51bGwgJiYgdHdlZW4uZWxlbS5zdHlsZVsgdHdlZW4ucHJvcCBdID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiB0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF07XG5cdFx0XHR9XG5cblx0XHRcdC8vIFBhc3NpbmcgYW4gZW1wdHkgc3RyaW5nIGFzIGEgM3JkIHBhcmFtZXRlciB0byAuY3NzIHdpbGwgYXV0b21hdGljYWxseVxuXHRcdFx0Ly8gYXR0ZW1wdCBhIHBhcnNlRmxvYXQgYW5kIGZhbGxiYWNrIHRvIGEgc3RyaW5nIGlmIHRoZSBwYXJzZSBmYWlscy5cblx0XHRcdC8vIFNpbXBsZSB2YWx1ZXMgc3VjaCBhcyBcIjEwcHhcIiBhcmUgcGFyc2VkIHRvIEZsb2F0O1xuXHRcdFx0Ly8gY29tcGxleCB2YWx1ZXMgc3VjaCBhcyBcInJvdGF0ZSgxcmFkKVwiIGFyZSByZXR1cm5lZCBhcy1pcy5cblx0XHRcdHJlc3VsdCA9IGpRdWVyeS5jc3MoIHR3ZWVuLmVsZW0sIHR3ZWVuLnByb3AsIFwiXCIgKTtcblxuXHRcdFx0Ly8gRW1wdHkgc3RyaW5ncywgbnVsbCwgdW5kZWZpbmVkIGFuZCBcImF1dG9cIiBhcmUgY29udmVydGVkIHRvIDAuXG5cdFx0XHRyZXR1cm4gIXJlc3VsdCB8fCByZXN1bHQgPT09IFwiYXV0b1wiID8gMCA6IHJlc3VsdDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXG5cdFx0XHQvLyBVc2Ugc3RlcCBob29rIGZvciBiYWNrIGNvbXBhdC5cblx0XHRcdC8vIFVzZSBjc3NIb29rIGlmIGl0cyB0aGVyZS5cblx0XHRcdC8vIFVzZSAuc3R5bGUgaWYgYXZhaWxhYmxlIGFuZCB1c2UgcGxhaW4gcHJvcGVydGllcyB3aGVyZSBhdmFpbGFibGUuXG5cdFx0XHRpZiAoIGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS5meC5zdGVwWyB0d2Vlbi5wcm9wIF0oIHR3ZWVuICk7XG5cdFx0XHR9IGVsc2UgaWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0XHRqUXVlcnkuY3NzSG9va3NbIHR3ZWVuLnByb3AgXSB8fFxuXHRcdFx0XHRcdHR3ZWVuLmVsZW0uc3R5bGVbIGZpbmFsUHJvcE5hbWUoIHR3ZWVuLnByb3AgKSBdICE9IG51bGwgKSApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCB0d2Vlbi5ub3cgKyB0d2Vlbi51bml0ICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBTdXBwb3J0OiBJRSA8PTkgb25seVxuLy8gUGFuaWMgYmFzZWQgYXBwcm9hY2ggdG8gc2V0dGluZyB0aGluZ3Mgb24gZGlzY29ubmVjdGVkIG5vZGVzXG5Ud2Vlbi5wcm9wSG9va3Muc2Nyb2xsVG9wID0gVHdlZW4ucHJvcEhvb2tzLnNjcm9sbExlZnQgPSB7XG5cdHNldDogZnVuY3Rpb24oIHR3ZWVuICkge1xuXHRcdGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSAmJiB0d2Vlbi5lbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHR0d2Vlbi5lbGVtWyB0d2Vlbi5wcm9wIF0gPSB0d2Vlbi5ub3c7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZWFzaW5nID0ge1xuXHRsaW5lYXI6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiBwO1xuXHR9LFxuXHRzd2luZzogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIDAuNSAtIE1hdGguY29zKCBwICogTWF0aC5QSSApIC8gMjtcblx0fSxcblx0X2RlZmF1bHQ6IFwic3dpbmdcIlxufTtcblxualF1ZXJ5LmZ4ID0gVHdlZW4ucHJvdG90eXBlLmluaXQ7XG5cbi8vIEJhY2sgY29tcGF0IDwxLjggZXh0ZW5zaW9uIHBvaW50XG5qUXVlcnkuZnguc3RlcCA9IHt9O1xuXG5cblxuXG52YXJcblx0ZnhOb3csIGluUHJvZ3Jlc3MsXG5cdHJmeHR5cGVzID0gL14oPzp0b2dnbGV8c2hvd3xoaWRlKSQvLFxuXHRycnVuID0gL3F1ZXVlSG9va3MkLztcblxuZnVuY3Rpb24gc2NoZWR1bGUoKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRpZiAoIGRvY3VtZW50LmhpZGRlbiA9PT0gZmFsc2UgJiYgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSApIHtcblx0XHRcdHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoIHNjaGVkdWxlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBzY2hlZHVsZSwgalF1ZXJ5LmZ4LmludGVydmFsICk7XG5cdFx0fVxuXG5cdFx0alF1ZXJ5LmZ4LnRpY2soKTtcblx0fVxufVxuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0gRGF0ZS5ub3coKSApO1xufVxuXG4vLyBHZW5lcmF0ZSBwYXJhbWV0ZXJzIHRvIGNyZWF0ZSBhIHN0YW5kYXJkIGFuaW1hdGlvblxuZnVuY3Rpb24gZ2VuRngoIHR5cGUsIGluY2x1ZGVXaWR0aCApIHtcblx0dmFyIHdoaWNoLFxuXHRcdGkgPSAwLFxuXHRcdGF0dHJzID0geyBoZWlnaHQ6IHR5cGUgfTtcblxuXHQvLyBJZiB3ZSBpbmNsdWRlIHdpZHRoLCBzdGVwIHZhbHVlIGlzIDEgdG8gZG8gYWxsIGNzc0V4cGFuZCB2YWx1ZXMsXG5cdC8vIG90aGVyd2lzZSBzdGVwIHZhbHVlIGlzIDIgdG8gc2tpcCBvdmVyIExlZnQgYW5kIFJpZ2h0XG5cdGluY2x1ZGVXaWR0aCA9IGluY2x1ZGVXaWR0aCA/IDEgOiAwO1xuXHRmb3IgKCA7IGkgPCA0OyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0dmFyIHByb3AsIHZhbHVlLCB0b2dnbGUsIGhvb2tzLCBvbGRmaXJlLCBwcm9wVHdlZW4sIHJlc3RvcmVEaXNwbGF5LCBkaXNwbGF5LFxuXHRcdGlzQm94ID0gXCJ3aWR0aFwiIGluIHByb3BzIHx8IFwiaGVpZ2h0XCIgaW4gcHJvcHMsXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuV2l0aGluVHJlZSggZWxlbSApLFxuXHRcdGRhdGFTaG93ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cblx0Ly8gUXVldWUtc2tpcHBpbmcgYW5pbWF0aW9ucyBoaWphY2sgdGhlIGZ4IGhvb2tzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIERldGVjdCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRmb3IgKCBwcm9wIGluIHByb3BzICkge1xuXHRcdHZhbHVlID0gcHJvcHNbIHByb3AgXTtcblx0XHRpZiAoIHJmeHR5cGVzLnRlc3QoIHZhbHVlICkgKSB7XG5cdFx0XHRkZWxldGUgcHJvcHNbIHByb3AgXTtcblx0XHRcdHRvZ2dsZSA9IHRvZ2dsZSB8fCB2YWx1ZSA9PT0gXCJ0b2dnbGVcIjtcblx0XHRcdGlmICggdmFsdWUgPT09ICggaGlkZGVuID8gXCJoaWRlXCIgOiBcInNob3dcIiApICkge1xuXG5cdFx0XHRcdC8vIFByZXRlbmQgdG8gYmUgaGlkZGVuIGlmIHRoaXMgaXMgYSBcInNob3dcIiBhbmRcblx0XHRcdFx0Ly8gdGhlcmUgaXMgc3RpbGwgZGF0YSBmcm9tIGEgc3RvcHBlZCBzaG93L2hpZGVcblx0XHRcdFx0aWYgKCB2YWx1ZSA9PT0gXCJzaG93XCIgJiYgZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdGhpZGRlbiA9IHRydWU7XG5cblx0XHRcdFx0Ly8gSWdub3JlIGFsbCBvdGhlciBuby1vcCBzaG93L2hpZGUgZGF0YVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRvcmlnWyBwcm9wIF0gPSBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdIHx8IGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIEJhaWwgb3V0IGlmIHRoaXMgaXMgYSBuby1vcCBsaWtlIC5oaWRlKCkuaGlkZSgpXG5cdHByb3BUd2VlbiA9ICFqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcHMgKTtcblx0aWYgKCAhcHJvcFR3ZWVuICYmIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBvcmlnICkgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVzdHJpY3QgXCJvdmVyZmxvd1wiIGFuZCBcImRpc3BsYXlcIiBzdHlsZXMgZHVyaW5nIGJveCBhbmltYXRpb25zXG5cdGlmICggaXNCb3ggJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExLCBFZGdlIDEyIC0gMTVcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFIGRvZXMgbm90IGluZmVyIHRoZSBzaG9ydGhhbmRcblx0XHQvLyBmcm9tIGlkZW50aWNhbGx5LXZhbHVlZCBvdmVyZmxvd1ggYW5kIG92ZXJmbG93WSBhbmQgRWRnZSBqdXN0IG1pcnJvcnNcblx0XHQvLyB0aGUgb3ZlcmZsb3dYIHZhbHVlIHRoZXJlLlxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gSWRlbnRpZnkgYSBkaXNwbGF5IHR5cGUsIHByZWZlcnJpbmcgb2xkIHNob3cvaGlkZSBkYXRhIG92ZXIgdGhlIENTUyBjYXNjYWRlXG5cdFx0cmVzdG9yZURpc3BsYXkgPSBkYXRhU2hvdyAmJiBkYXRhU2hvdy5kaXNwbGF5O1xuXHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdH1cblx0XHRkaXNwbGF5ID0galF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSApIHtcblx0XHRcdFx0ZGlzcGxheSA9IHJlc3RvcmVEaXNwbGF5O1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBHZXQgbm9uZW1wdHkgdmFsdWUocykgYnkgdGVtcG9yYXJpbHkgZm9yY2luZyB2aXNpYmlsaXR5XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSwgdHJ1ZSApO1xuXHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheSB8fCByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0XHRcdHNob3dIaWRlKCBbIGVsZW0gXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFuaW1hdGUgaW5saW5lIGVsZW1lbnRzIGFzIGlubGluZS1ibG9ja1xuXHRcdGlmICggZGlzcGxheSA9PT0gXCJpbmxpbmVcIiB8fCBkaXNwbGF5ID09PSBcImlubGluZS1ibG9ja1wiICYmIHJlc3RvcmVEaXNwbGF5ICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblxuXHRcdFx0XHQvLyBSZXN0b3JlIHRoZSBvcmlnaW5hbCBkaXNwbGF5IHZhbHVlIGF0IHRoZSBlbmQgb2YgcHVyZSBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRcdFx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRcdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0aWYgKCByZXN0b3JlRGlzcGxheSA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0ZGlzcGxheSA9IHN0eWxlLmRpc3BsYXk7XG5cdFx0XHRcdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID8gXCJcIiA6IGRpc3BsYXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gSW1wbGVtZW50IHNob3cvaGlkZSBhbmltYXRpb25zXG5cdHByb3BUd2VlbiA9IGZhbHNlO1xuXHRmb3IgKCBwcm9wIGluIG9yaWcgKSB7XG5cblx0XHQvLyBHZW5lcmFsIHNob3cvaGlkZSBzZXR1cCBmb3IgdGhpcyBlbGVtZW50IGFuaW1hdGlvblxuXHRcdGlmICggIXByb3BUd2VlbiApIHtcblx0XHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRcdGlmICggXCJoaWRkZW5cIiBpbiBkYXRhU2hvdyApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSBkYXRhU2hvdy5oaWRkZW47XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRhdGFTaG93ID0gZGF0YVByaXYuYWNjZXNzKCBlbGVtLCBcImZ4c2hvd1wiLCB7IGRpc3BsYXk6IHJlc3RvcmVEaXNwbGF5IH0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3RvcmUgaGlkZGVuL3Zpc2libGUgZm9yIHRvZ2dsZSBzbyBgLnN0b3AoKS50b2dnbGUoKWAgXCJyZXZlcnNlc1wiXG5cdFx0XHRpZiAoIHRvZ2dsZSApIHtcblx0XHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2hvdyBlbGVtZW50cyBiZWZvcmUgYW5pbWF0aW5nIHRoZW1cblx0XHRcdGlmICggaGlkZGVuICkge1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdH1cblxuXHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8qIGVzbGludC1lbmFibGUgbm8tbG9vcC1mdW5jICovXG5cblx0XHRcdFx0Ly8gVGhlIGZpbmFsIHN0ZXAgb2YgYSBcImhpZGVcIiBhbmltYXRpb24gaXMgYWN0dWFsbHkgaGlkaW5nIHRoZSBlbGVtZW50XG5cdFx0XHRcdGlmICggIWhpZGRlbiApIHtcblx0XHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgb3JpZ1sgcHJvcCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHQvLyBQZXItcHJvcGVydHkgc2V0dXBcblx0XHRwcm9wVHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblx0XHRpZiAoICEoIHByb3AgaW4gZGF0YVNob3cgKSApIHtcblx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0cHJvcFR3ZWVuLmVuZCA9IHByb3BUd2Vlbi5zdGFydDtcblx0XHRcdFx0cHJvcFR3ZWVuLnN0YXJ0ID0gMDtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gcHJvcEZpbHRlciggcHJvcHMsIHNwZWNpYWxFYXNpbmcgKSB7XG5cdHZhciBpbmRleCwgbmFtZSwgZWFzaW5nLCB2YWx1ZSwgaG9va3M7XG5cblx0Ly8gY2FtZWxDYXNlLCBzcGVjaWFsRWFzaW5nIGFuZCBleHBhbmQgY3NzSG9vayBwYXNzXG5cdGZvciAoIGluZGV4IGluIHByb3BzICkge1xuXHRcdG5hbWUgPSBjYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdFx0ZWFzaW5nID0gdmFsdWVbIDEgXTtcblx0XHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF0gPSB2YWx1ZVsgMCBdO1xuXHRcdH1cblxuXHRcdGlmICggaW5kZXggIT09IG5hbWUgKSB7XG5cdFx0XHRwcm9wc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRkZWxldGUgcHJvcHNbIGluZGV4IF07XG5cdFx0fVxuXG5cdFx0aG9va3MgPSBqUXVlcnkuY3NzSG9va3NbIG5hbWUgXTtcblx0XHRpZiAoIGhvb2tzICYmIFwiZXhwYW5kXCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWx1ZSA9IGhvb2tzLmV4cGFuZCggdmFsdWUgKTtcblx0XHRcdGRlbGV0ZSBwcm9wc1sgbmFtZSBdO1xuXG5cdFx0XHQvLyBOb3QgcXVpdGUgJC5leHRlbmQsIHRoaXMgd29uJ3Qgb3ZlcndyaXRlIGV4aXN0aW5nIGtleXMuXG5cdFx0XHQvLyBSZXVzaW5nICdpbmRleCcgYmVjYXVzZSB3ZSBoYXZlIHRoZSBjb3JyZWN0IFwibmFtZVwiXG5cdFx0XHRmb3IgKCBpbmRleCBpbiB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhKCBpbmRleCBpbiBwcm9wcyApICkge1xuXHRcdFx0XHRcdHByb3BzWyBpbmRleCBdID0gdmFsdWVbIGluZGV4IF07XG5cdFx0XHRcdFx0c3BlY2lhbEVhc2luZ1sgaW5kZXggXSA9IGVhc2luZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRzcGVjaWFsRWFzaW5nWyBuYW1lIF0gPSBlYXNpbmc7XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIEFuaW1hdGlvbiggZWxlbSwgcHJvcGVydGllcywgb3B0aW9ucyApIHtcblx0dmFyIHJlc3VsdCxcblx0XHRzdG9wcGVkLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBBbmltYXRpb24ucHJlZmlsdGVycy5sZW5ndGgsXG5cdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBEb24ndCBtYXRjaCBlbGVtIGluIHRoZSA6YW5pbWF0ZWQgc2VsZWN0b3Jcblx0XHRcdGRlbGV0ZSB0aWNrLmVsZW07XG5cdFx0fSApLFxuXHRcdHRpY2sgPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGN1cnJlbnRUaW1lID0gZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdFx0cmVtYWluaW5nID0gTWF0aC5tYXgoIDAsIGFuaW1hdGlvbi5zdGFydFRpbWUgKyBhbmltYXRpb24uZHVyYXRpb24gLSBjdXJyZW50VGltZSApLFxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgMi4zIG9ubHlcblx0XHRcdFx0Ly8gQXJjaGFpYyBjcmFzaCBidWcgd29uJ3QgYWxsb3cgdXMgdG8gdXNlIGAxIC0gKCAwLjUgfHwgMCApYCAoIzEyNDk3KVxuXHRcdFx0XHR0ZW1wID0gcmVtYWluaW5nIC8gYW5pbWF0aW9uLmR1cmF0aW9uIHx8IDAsXG5cdFx0XHRcdHBlcmNlbnQgPSAxIC0gdGVtcCxcblx0XHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0XHRsZW5ndGggPSBhbmltYXRpb24udHdlZW5zLmxlbmd0aDtcblxuXHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdC8vIElmIHRoZXJlJ3MgbW9yZSB0byBkbywgeWllbGRcblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiB0aGlzIHdhcyBhbiBlbXB0eSBhbmltYXRpb24sIHN5bnRoZXNpemUgYSBmaW5hbCBwcm9ncmVzcyBub3RpZmljYXRpb25cblx0XHRcdGlmICggIWxlbmd0aCApIHtcblx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZXNvbHZlIHRoZSBhbmltYXRpb24gYW5kIHJlcG9ydCBpdHMgY29uY2x1c2lvblxuXHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXHRcdGFuaW1hdGlvbiA9IGRlZmVycmVkLnByb21pc2UoIHtcblx0XHRcdGVsZW06IGVsZW0sXG5cdFx0XHRwcm9wczogalF1ZXJ5LmV4dGVuZCgge30sIHByb3BlcnRpZXMgKSxcblx0XHRcdG9wdHM6IGpRdWVyeS5leHRlbmQoIHRydWUsIHtcblx0XHRcdFx0c3BlY2lhbEVhc2luZzoge30sXG5cdFx0XHRcdGVhc2luZzogalF1ZXJ5LmVhc2luZy5fZGVmYXVsdFxuXHRcdFx0fSwgb3B0aW9ucyApLFxuXHRcdFx0b3JpZ2luYWxQcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzLFxuXHRcdFx0b3JpZ2luYWxPcHRpb25zOiBvcHRpb25zLFxuXHRcdFx0c3RhcnRUaW1lOiBmeE5vdyB8fCBjcmVhdGVGeE5vdygpLFxuXHRcdFx0ZHVyYXRpb246IG9wdGlvbnMuZHVyYXRpb24sXG5cdFx0XHR0d2VlbnM6IFtdLFxuXHRcdFx0Y3JlYXRlVHdlZW46IGZ1bmN0aW9uKCBwcm9wLCBlbmQgKSB7XG5cdFx0XHRcdHZhciB0d2VlbiA9IGpRdWVyeS5Ud2VlbiggZWxlbSwgYW5pbWF0aW9uLm9wdHMsIHByb3AsIGVuZCxcblx0XHRcdFx0XHRcdGFuaW1hdGlvbi5vcHRzLnNwZWNpYWxFYXNpbmdbIHByb3AgXSB8fCBhbmltYXRpb24ub3B0cy5lYXNpbmcgKTtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVucy5wdXNoKCB0d2VlbiApO1xuXHRcdFx0XHRyZXR1cm4gdHdlZW47XG5cdFx0XHR9LFxuXHRcdFx0c3RvcDogZnVuY3Rpb24oIGdvdG9FbmQgKSB7XG5cdFx0XHRcdHZhciBpbmRleCA9IDAsXG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBhcmUgZ29pbmcgdG8gdGhlIGVuZCwgd2Ugd2FudCB0byBydW4gYWxsIHRoZSB0d2VlbnNcblx0XHRcdFx0XHQvLyBvdGhlcndpc2Ugd2Ugc2tpcCB0aGlzIHBhcnRcblx0XHRcdFx0XHRsZW5ndGggPSBnb3RvRW5kID8gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGggOiAwO1xuXHRcdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblx0XHRcdFx0c3RvcHBlZCA9IHRydWU7XG5cdFx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRyZXN1bHQgPSBBbmltYXRpb24ucHJlZmlsdGVyc1sgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIGVsZW0sIHByb3BzLCBhbmltYXRpb24ub3B0cyApO1xuXHRcdGlmICggcmVzdWx0ICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCByZXN1bHQuc3RvcCApICkge1xuXHRcdFx0XHRqUXVlcnkuX3F1ZXVlSG9va3MoIGFuaW1hdGlvbi5lbGVtLCBhbmltYXRpb24ub3B0cy5xdWV1ZSApLnN0b3AgPVxuXHRcdFx0XHRcdHJlc3VsdC5zdG9wLmJpbmQoIHJlc3VsdCApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3VsdDtcblx0XHR9XG5cdH1cblxuXHRqUXVlcnkubWFwKCBwcm9wcywgY3JlYXRlVHdlZW4sIGFuaW1hdGlvbiApO1xuXG5cdGlmICggaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdC8vIEF0dGFjaCBjYWxsYmFja3MgZnJvbSBvcHRpb25zXG5cdGFuaW1hdGlvblxuXHRcdC5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0cmV0dXJuIGFuaW1hdGlvbjtcbn1cblxualF1ZXJ5LkFuaW1hdGlvbiA9IGpRdWVyeS5leHRlbmQoIEFuaW1hdGlvbiwge1xuXG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBwcm9wcyApICkge1xuXHRcdFx0Y2FsbGJhY2sgPSBwcm9wcztcblx0XHRcdHByb3BzID0gWyBcIipcIiBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwcm9wcyA9IHByb3BzLm1hdGNoKCBybm90aHRtbHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0cHJvcCA9IHByb3BzWyBpbmRleCBdO1xuXHRcdFx0QW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gPSBBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXSB8fCBbXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9LFxuXG5cdHByZWZpbHRlcnM6IFsgZGVmYXVsdFByZWZpbHRlciBdLFxuXG5cdHByZWZpbHRlcjogZnVuY3Rpb24oIGNhbGxiYWNrLCBwcmVwZW5kICkge1xuXHRcdGlmICggcHJlcGVuZCApIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnVuc2hpZnQoIGNhbGxiYWNrICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdEFuaW1hdGlvbi5wcmVmaWx0ZXJzLnB1c2goIGNhbGxiYWNrICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbmpRdWVyeS5zcGVlZCA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBmbiApIHtcblx0dmFyIG9wdCA9IHNwZWVkICYmIHR5cGVvZiBzcGVlZCA9PT0gXCJvYmplY3RcIiA/IGpRdWVyeS5leHRlbmQoIHt9LCBzcGVlZCApIDoge1xuXHRcdGNvbXBsZXRlOiBmbiB8fCAhZm4gJiYgZWFzaW5nIHx8XG5cdFx0XHRpc0Z1bmN0aW9uKCBzcGVlZCApICYmIHNwZWVkLFxuXHRcdGR1cmF0aW9uOiBzcGVlZCxcblx0XHRlYXNpbmc6IGZuICYmIGVhc2luZyB8fCBlYXNpbmcgJiYgIWlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdC8vIEdvIHRvIHRoZSBlbmQgc3RhdGUgaWYgZnggYXJlIG9mZlxuXHRpZiAoIGpRdWVyeS5meC5vZmYgKSB7XG5cdFx0b3B0LmR1cmF0aW9uID0gMDtcblxuXHR9IGVsc2Uge1xuXHRcdGlmICggdHlwZW9mIG9wdC5kdXJhdGlvbiAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdGlmICggb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgKSB7XG5cdFx0XHRcdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5zcGVlZHNbIG9wdC5kdXJhdGlvbiBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0Lm9sZCApICkge1xuXHRcdFx0b3B0Lm9sZC5jYWxsKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHQucXVldWUgKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgb3B0LnF1ZXVlICk7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBvcHQ7XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGZhZGVUbzogZnVuY3Rpb24oIHNwZWVkLCB0bywgZWFzaW5nLCBjYWxsYmFjayApIHtcblxuXHRcdC8vIFNob3cgYW55IGhpZGRlbiBlbGVtZW50cyBhZnRlciBzZXR0aW5nIG9wYWNpdHkgdG8gMFxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggaXNIaWRkZW5XaXRoaW5UcmVlICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0gRGF0ZS5ub3coKTtcblxuXHRmb3IgKCA7IGkgPCB0aW1lcnMubGVuZ3RoOyBpKysgKSB7XG5cdFx0dGltZXIgPSB0aW1lcnNbIGkgXTtcblxuXHRcdC8vIFJ1biB0aGUgdGltZXIgYW5kIHNhZmVseSByZW1vdmUgaXQgd2hlbiBkb25lIChhbGxvd2luZyBmb3IgZXh0ZXJuYWwgcmVtb3ZhbClcblx0XHRpZiAoICF0aW1lcigpICYmIHRpbWVyc1sgaSBdID09PSB0aW1lciApIHtcblx0XHRcdHRpbWVycy5zcGxpY2UoIGktLSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdGlmICggIXRpbWVycy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5LmZ4LnN0b3AoKTtcblx0fVxuXHRmeE5vdyA9IHVuZGVmaW5lZDtcbn07XG5cbmpRdWVyeS5meC50aW1lciA9IGZ1bmN0aW9uKCB0aW1lciApIHtcblx0alF1ZXJ5LnRpbWVycy5wdXNoKCB0aW1lciApO1xuXHRqUXVlcnkuZnguc3RhcnQoKTtcbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggaW5Qcm9ncmVzcyApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHRpblByb2dyZXNzID0gdHJ1ZTtcblx0c2NoZWR1bGUoKTtcbn07XG5cbmpRdWVyeS5meC5zdG9wID0gZnVuY3Rpb24oKSB7XG5cdGluUHJvZ3Jlc3MgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDEwMDMyNDAxNDc0Ny9odHRwOi8vYmxpbmRzaWduYWxzLmNvbS9pbmRleC5waHAvMjAwOS8wNy9qcXVlcnktZGVsYXkvXG5qUXVlcnkuZm4uZGVsYXkgPSBmdW5jdGlvbiggdGltZSwgdHlwZSApIHtcblx0dGltZSA9IGpRdWVyeS5meCA/IGpRdWVyeS5meC5zcGVlZHNbIHRpbWUgXSB8fCB0aW1lIDogdGltZTtcblx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXG5cdHJldHVybiB0aGlzLnF1ZXVlKCB0eXBlLCBmdW5jdGlvbiggbmV4dCwgaG9va3MgKSB7XG5cdFx0dmFyIHRpbWVvdXQgPSB3aW5kb3cuc2V0VGltZW91dCggbmV4dCwgdGltZSApO1xuXHRcdGhvb2tzLnN0b3AgPSBmdW5jdGlvbigpIHtcblx0XHRcdHdpbmRvdy5jbGVhclRpbWVvdXQoIHRpbWVvdXQgKTtcblx0XHR9O1xuXHR9ICk7XG59O1xuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApLFxuXHRcdHNlbGVjdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwic2VsZWN0XCIgKSxcblx0XHRvcHQgPSBzZWxlY3QuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwib3B0aW9uXCIgKSApO1xuXG5cdGlucHV0LnR5cGUgPSBcImNoZWNrYm94XCI7XG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMyBvbmx5XG5cdC8vIERlZmF1bHQgdmFsdWUgZm9yIGEgY2hlY2tib3ggc2hvdWxkIGJlIFwib25cIlxuXHRzdXBwb3J0LmNoZWNrT24gPSBpbnB1dC52YWx1ZSAhPT0gXCJcIjtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gTXVzdCBhY2Nlc3Mgc2VsZWN0ZWRJbmRleCB0byBtYWtlIGRlZmF1bHQgb3B0aW9ucyBzZWxlY3Rcblx0c3VwcG9ydC5vcHRTZWxlY3RlZCA9IG9wdC5zZWxlY3RlZDtcblxuXHQvLyBTdXBwb3J0OiBJRSA8PTExIG9ubHlcblx0Ly8gQW4gaW5wdXQgbG9zZXMgaXRzIHZhbHVlIGFmdGVyIGJlY29taW5nIGEgcmFkaW9cblx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0aW5wdXQudmFsdWUgPSBcInRcIjtcblx0aW5wdXQudHlwZSA9IFwicmFkaW9cIjtcblx0c3VwcG9ydC5yYWRpb1ZhbHVlID0gaW5wdXQudmFsdWUgPT09IFwidFwiO1xufSApKCk7XG5cblxudmFyIGJvb2xIb29rLFxuXHRhdHRySGFuZGxlID0galF1ZXJ5LmV4cHIuYXR0ckhhbmRsZTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgalF1ZXJ5LmF0dHIsIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXG5cdHJlbW92ZUF0dHI6IGZ1bmN0aW9uKCBuYW1lICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIHRoaXMsIG5hbWUgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHRhdHRyOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUgKSB7XG5cdFx0dmFyIHJldCwgaG9va3MsXG5cdFx0XHRuVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0XHQvLyBEb24ndCBnZXQvc2V0IGF0dHJpYnV0ZXMgb24gdGV4dCwgY29tbWVudCBhbmQgYXR0cmlidXRlIG5vZGVzXG5cdFx0aWYgKCBuVHlwZSA9PT0gMyB8fCBuVHlwZSA9PT0gOCB8fCBuVHlwZSA9PT0gMiApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBGYWxsYmFjayB0byBwcm9wIHdoZW4gYXR0cmlidXRlcyBhcmUgbm90IHN1cHBvcnRlZFxuXHRcdGlmICggdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlID09PSBcInVuZGVmaW5lZFwiICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5wcm9wKCBlbGVtLCBuYW1lLCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdC8vIEF0dHJpYnV0ZSBob29rcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgbG93ZXJjYXNlIHZlcnNpb25cblx0XHQvLyBHcmFiIG5lY2Vzc2FyeSBob29rIGlmIG9uZSBpcyBkZWZpbmVkXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC50ZXN0KCBuYW1lICkgPyBib29sSG9vayA6IHVuZGVmaW5lZCApO1xuXHRcdH1cblxuXHRcdGlmICggdmFsdWUgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGlmICggdmFsdWUgPT09IG51bGwgKSB7XG5cdFx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBob29rcyAmJiBcInNldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3Muc2V0KCBlbGVtLCB2YWx1ZSwgbmFtZSApICkgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIG5hbWUsIHZhbHVlICsgXCJcIiApO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldCA9IGpRdWVyeS5maW5kLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdC8vIE5vbi1leGlzdGVudCBhdHRyaWJ1dGVzIHJldHVybiBudWxsLCB3ZSBub3JtYWxpemUgdG8gdW5kZWZpbmVkXG5cdFx0cmV0dXJuIHJldCA9PSBudWxsID8gdW5kZWZpbmVkIDogcmV0O1xuXHR9LFxuXG5cdGF0dHJIb29rczoge1xuXHRcdHR5cGU6IHtcblx0XHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdFx0XHRpZiAoICFzdXBwb3J0LnJhZGlvVmFsdWUgJiYgdmFsdWUgPT09IFwicmFkaW9cIiAmJlxuXHRcdFx0XHRcdG5vZGVOYW1lKCBlbGVtLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZWxlbS52YWx1ZTtcblx0XHRcdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIHZhbHVlICk7XG5cdFx0XHRcdFx0aWYgKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLnZhbHVlID0gdmFsO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIGVsZW0sIHZhbHVlICkge1xuXHRcdHZhciBuYW1lLFxuXHRcdFx0aSA9IDAsXG5cblx0XHRcdC8vIEF0dHJpYnV0ZSBuYW1lcyBjYW4gY29udGFpbiBub24tSFRNTCB3aGl0ZXNwYWNlIGNoYXJhY3RlcnNcblx0XHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3N5bnRheC5odG1sI2F0dHJpYnV0ZXMtMlxuXHRcdFx0YXR0ck5hbWVzID0gdmFsdWUgJiYgdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKTtcblxuXHRcdGlmICggYXR0ck5hbWVzICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHR3aGlsZSAoICggbmFtZSA9IGF0dHJOYW1lc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcblxualF1ZXJ5LmVhY2goIGpRdWVyeS5leHByLm1hdGNoLmJvb2wuc291cmNlLm1hdGNoKCAvXFx3Ky9nICksIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoIGRhdGFQcml2LmdldCggY3VyLCBcImV2ZW50c1wiICkgfHwge30gKVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLFxuXHRcdFx0XHRcdGF0dGFjaGVzID0gZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCApIC0gMTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MucmVtb3ZlRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnJlbW92ZSggZG9jLCBmaXggKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsIGF0dGFjaGVzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9ICk7XG59XG52YXIgbG9jYXRpb24gPSB3aW5kb3cubG9jYXRpb247XG5cbnZhciBub25jZSA9IERhdGUubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggaSwgZWxlbSApIHtcblx0XHRcdHZhciB2YWwgPSBqUXVlcnkoIHRoaXMgKS52YWwoKTtcblxuXHRcdFx0aWYgKCB2YWwgPT0gbnVsbCApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbnZhclxuXHRyMjAgPSAvJTIwL2csXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRyYW50aUNhY2hlID0gLyhbPyZdKV89W14mXSovLFxuXHRyaGVhZGVycyA9IC9eKC4qPyk6WyBcXHRdKihbXlxcclxcbl0qKSQvbWcsXG5cblx0Ly8gIzc2NTMsICM4MTI1LCAjODE1MjogbG9jYWwgcHJvdG9jb2wgZGV0ZWN0aW9uXG5cdHJsb2NhbFByb3RvY29sID0gL14oPzphYm91dHxhcHB8YXBwLXN0b3JhZ2V8ListZXh0ZW5zaW9ufGZpbGV8cmVzfHdpZGdldCk6JC8sXG5cdHJub0NvbnRlbnQgPSAvXig/OkdFVHxIRUFEKSQvLFxuXHRycHJvdG9jb2wgPSAvXlxcL1xcLy8sXG5cblx0LyogUHJlZmlsdGVyc1xuXHQgKiAxKSBUaGV5IGFyZSB1c2VmdWwgdG8gaW50cm9kdWNlIGN1c3RvbSBkYXRhVHlwZXMgKHNlZSBhamF4L2pzb25wLmpzIGZvciBhbiBleGFtcGxlKVxuXHQgKiAyKSBUaGVzZSBhcmUgY2FsbGVkOlxuXHQgKiAgICAtIEJFRk9SRSBhc2tpbmcgZm9yIGEgdHJhbnNwb3J0XG5cdCAqICAgIC0gQUZURVIgcGFyYW0gc2VyaWFsaXphdGlvbiAocy5kYXRhIGlzIGEgc3RyaW5nIGlmIHMucHJvY2Vzc0RhdGEgaXMgdHJ1ZSlcblx0ICogMykga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiA0KSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDUpIGV4ZWN1dGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGNvbnRpbnVlIGRvd24gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHRwcmVmaWx0ZXJzID0ge30sXG5cblx0LyogVHJhbnNwb3J0cyBiaW5kaW5nc1xuXHQgKiAxKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDIpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogMykgc2VsZWN0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gZ28gdG8gXCIqXCIgaWYgbmVlZGVkXG5cdCAqL1xuXHR0cmFuc3BvcnRzID0ge30sXG5cblx0Ly8gQXZvaWQgY29tbWVudC1wcm9sb2cgY2hhciBzZXF1ZW5jZSAoIzEwMDk4KTsgbXVzdCBhcHBlYXNlIGxpbnQgYW5kIGV2YWRlIGNvbXByZXNzaW9uXG5cdGFsbFR5cGVzID0gXCIqL1wiLmNvbmNhdCggXCIqXCIgKSxcblxuXHQvLyBBbmNob3IgdGFnIGZvciBwYXJzaW5nIHRoZSBkb2N1bWVudCBvcmlnaW5cblx0b3JpZ2luQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblx0b3JpZ2luQW5jaG9yLmhyZWYgPSBsb2NhdGlvbi5ocmVmO1xuXG4vLyBCYXNlIFwiY29uc3RydWN0b3JcIiBmb3IgalF1ZXJ5LmFqYXhQcmVmaWx0ZXIgYW5kIGpRdWVyeS5hamF4VHJhbnNwb3J0XG5mdW5jdGlvbiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSApIHtcblxuXHQvLyBkYXRhVHlwZUV4cHJlc3Npb24gaXMgb3B0aW9uYWwgYW5kIGRlZmF1bHRzIHRvIFwiKlwiXG5cdHJldHVybiBmdW5jdGlvbiggZGF0YVR5cGVFeHByZXNzaW9uLCBmdW5jICkge1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVFeHByZXNzaW9uICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZnVuYyA9IGRhdGFUeXBlRXhwcmVzc2lvbjtcblx0XHRcdGRhdGFUeXBlRXhwcmVzc2lvbiA9IFwiKlwiO1xuXHRcdH1cblxuXHRcdHZhciBkYXRhVHlwZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0ZGF0YVR5cGVzID0gZGF0YVR5cGVFeHByZXNzaW9uLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggZnVuYyApICkge1xuXG5cdFx0XHQvLyBGb3IgZWFjaCBkYXRhVHlwZSBpbiB0aGUgZGF0YVR5cGVFeHByZXNzaW9uXG5cdFx0XHR3aGlsZSAoICggZGF0YVR5cGUgPSBkYXRhVHlwZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0Ly8gUHJlcGVuZCBpZiByZXF1ZXN0ZWRcblx0XHRcdFx0aWYgKCBkYXRhVHlwZVsgMCBdID09PSBcIitcIiApIHtcblx0XHRcdFx0XHRkYXRhVHlwZSA9IGRhdGFUeXBlLnNsaWNlKCAxICkgfHwgXCIqXCI7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS51bnNoaWZ0KCBmdW5jICk7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIGFwcGVuZFxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkucHVzaCggZnVuYyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufVxuXG4vLyBCYXNlIGluc3BlY3Rpb24gZnVuY3Rpb24gZm9yIHByZWZpbHRlcnMgYW5kIHRyYW5zcG9ydHNcbmZ1bmN0aW9uIGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUsIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKSB7XG5cblx0dmFyIGluc3BlY3RlZCA9IHt9LFxuXHRcdHNlZWtpbmdUcmFuc3BvcnQgPSAoIHN0cnVjdHVyZSA9PT0gdHJhbnNwb3J0cyApO1xuXG5cdGZ1bmN0aW9uIGluc3BlY3QoIGRhdGFUeXBlICkge1xuXHRcdHZhciBzZWxlY3RlZDtcblx0XHRpbnNwZWN0ZWRbIGRhdGFUeXBlIF0gPSB0cnVlO1xuXHRcdGpRdWVyeS5lYWNoKCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10sIGZ1bmN0aW9uKCBfLCBwcmVmaWx0ZXJPckZhY3RvcnkgKSB7XG5cdFx0XHR2YXIgZGF0YVR5cGVPclRyYW5zcG9ydCA9IHByZWZpbHRlck9yRmFjdG9yeSggb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApO1xuXHRcdFx0aWYgKCB0eXBlb2YgZGF0YVR5cGVPclRyYW5zcG9ydCA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc2Vla2luZ1RyYW5zcG9ydCAmJiAhaW5zcGVjdGVkWyBkYXRhVHlwZU9yVHJhbnNwb3J0IF0gKSB7XG5cblx0XHRcdFx0b3B0aW9ucy5kYXRhVHlwZXMudW5zaGlmdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRpbnNwZWN0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAoIHNlZWtpbmdUcmFuc3BvcnQgKSB7XG5cdFx0XHRcdHJldHVybiAhKCBzZWxlY3RlZCA9IGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0cmV0dXJuIHNlbGVjdGVkO1xuXHR9XG5cblx0cmV0dXJuIGluc3BlY3QoIG9wdGlvbnMuZGF0YVR5cGVzWyAwIF0gKSB8fCAhaW5zcGVjdGVkWyBcIipcIiBdICYmIGluc3BlY3QoIFwiKlwiICk7XG59XG5cbi8vIEEgc3BlY2lhbCBleHRlbmQgZm9yIGFqYXggb3B0aW9uc1xuLy8gdGhhdCB0YWtlcyBcImZsYXRcIiBvcHRpb25zIChub3QgdG8gYmUgZGVlcCBleHRlbmRlZClcbi8vIEZpeGVzICM5ODg3XG5mdW5jdGlvbiBhamF4RXh0ZW5kKCB0YXJnZXQsIHNyYyApIHtcblx0dmFyIGtleSwgZGVlcCxcblx0XHRmbGF0T3B0aW9ucyA9IGpRdWVyeS5hamF4U2V0dGluZ3MuZmxhdE9wdGlvbnMgfHwge307XG5cblx0Zm9yICgga2V5IGluIHNyYyApIHtcblx0XHRpZiAoIHNyY1sga2V5IF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdCggZmxhdE9wdGlvbnNbIGtleSBdID8gdGFyZ2V0IDogKCBkZWVwIHx8ICggZGVlcCA9IHt9ICkgKSApWyBrZXkgXSA9IHNyY1sga2V5IF07XG5cdFx0fVxuXHR9XG5cdGlmICggZGVlcCApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0cnVlLCB0YXJnZXQsIGRlZXAgKTtcblx0fVxuXG5cdHJldHVybiB0YXJnZXQ7XG59XG5cbi8qIEhhbmRsZXMgcmVzcG9uc2VzIHRvIGFuIGFqYXggcmVxdWVzdDpcbiAqIC0gZmluZHMgdGhlIHJpZ2h0IGRhdGFUeXBlIChtZWRpYXRlcyBiZXR3ZWVuIGNvbnRlbnQtdHlwZSBhbmQgZXhwZWN0ZWQgZGF0YVR5cGUpXG4gKiAtIHJldHVybnMgdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2VcbiAqL1xuZnVuY3Rpb24gYWpheEhhbmRsZVJlc3BvbnNlcyggcywganFYSFIsIHJlc3BvbnNlcyApIHtcblxuXHR2YXIgY3QsIHR5cGUsIGZpbmFsRGF0YVR5cGUsIGZpcnN0RGF0YVR5cGUsXG5cdFx0Y29udGVudHMgPSBzLmNvbnRlbnRzLFxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzO1xuXG5cdC8vIFJlbW92ZSBhdXRvIGRhdGFUeXBlIGFuZCBnZXQgY29udGVudC10eXBlIGluIHRoZSBwcm9jZXNzXG5cdHdoaWxlICggZGF0YVR5cGVzWyAwIF0gPT09IFwiKlwiICkge1xuXHRcdGRhdGFUeXBlcy5zaGlmdCgpO1xuXHRcdGlmICggY3QgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdGN0ID0gcy5taW1lVHlwZSB8fCBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJDb250ZW50LVR5cGVcIiApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIGlmIHdlJ3JlIGRlYWxpbmcgd2l0aCBhIGtub3duIGNvbnRlbnQtdHlwZVxuXHRpZiAoIGN0ICkge1xuXHRcdGZvciAoIHR5cGUgaW4gY29udGVudHMgKSB7XG5cdFx0XHRpZiAoIGNvbnRlbnRzWyB0eXBlIF0gJiYgY29udGVudHNbIHR5cGUgXS50ZXN0KCBjdCApICkge1xuXHRcdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggdHlwZSApO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayB0byBzZWUgaWYgd2UgaGF2ZSBhIHJlc3BvbnNlIGZvciB0aGUgZXhwZWN0ZWQgZGF0YVR5cGVcblx0aWYgKCBkYXRhVHlwZXNbIDAgXSBpbiByZXNwb25zZXMgKSB7XG5cdFx0ZmluYWxEYXRhVHlwZSA9IGRhdGFUeXBlc1sgMCBdO1xuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gVHJ5IGNvbnZlcnRpYmxlIGRhdGFUeXBlc1xuXHRcdGZvciAoIHR5cGUgaW4gcmVzcG9uc2VzICkge1xuXHRcdFx0aWYgKCAhZGF0YVR5cGVzWyAwIF0gfHwgcy5jb252ZXJ0ZXJzWyB0eXBlICsgXCIgXCIgKyBkYXRhVHlwZXNbIDAgXSBdICkge1xuXHRcdFx0XHRmaW5hbERhdGFUeXBlID0gdHlwZTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAoICFmaXJzdERhdGFUeXBlICkge1xuXHRcdFx0XHRmaXJzdERhdGFUeXBlID0gdHlwZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBPciBqdXN0IHVzZSBmaXJzdCBvbmVcblx0XHRmaW5hbERhdGFUeXBlID0gZmluYWxEYXRhVHlwZSB8fCBmaXJzdERhdGFUeXBlO1xuXHR9XG5cblx0Ly8gSWYgd2UgZm91bmQgYSBkYXRhVHlwZVxuXHQvLyBXZSBhZGQgdGhlIGRhdGFUeXBlIHRvIHRoZSBsaXN0IGlmIG5lZWRlZFxuXHQvLyBhbmQgcmV0dXJuIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG5cdGlmICggZmluYWxEYXRhVHlwZSApIHtcblx0XHRpZiAoIGZpbmFsRGF0YVR5cGUgIT09IGRhdGFUeXBlc1sgMCBdICkge1xuXHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIGZpbmFsRGF0YVR5cGUgKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlc3BvbnNlc1sgZmluYWxEYXRhVHlwZSBdO1xuXHR9XG59XG5cbi8qIENoYWluIGNvbnZlcnNpb25zIGdpdmVuIHRoZSByZXF1ZXN0IGFuZCB0aGUgb3JpZ2luYWwgcmVzcG9uc2VcbiAqIEFsc28gc2V0cyB0aGUgcmVzcG9uc2VYWFggZmllbGRzIG9uIHRoZSBqcVhIUiBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKSB7XG5cdHZhciBjb252MiwgY3VycmVudCwgY29udiwgdG1wLCBwcmV2LFxuXHRcdGNvbnZlcnRlcnMgPSB7fSxcblxuXHRcdC8vIFdvcmsgd2l0aCBhIGNvcHkgb2YgZGF0YVR5cGVzIGluIGNhc2Ugd2UgbmVlZCB0byBtb2RpZnkgaXQgZm9yIGNvbnZlcnNpb25cblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcy5zbGljZSgpO1xuXG5cdC8vIENyZWF0ZSBjb252ZXJ0ZXJzIG1hcCB3aXRoIGxvd2VyY2FzZWQga2V5c1xuXHRpZiAoIGRhdGFUeXBlc1sgMSBdICkge1xuXHRcdGZvciAoIGNvbnYgaW4gcy5jb252ZXJ0ZXJzICkge1xuXHRcdFx0Y29udmVydGVyc1sgY29udi50b0xvd2VyQ2FzZSgpIF0gPSBzLmNvbnZlcnRlcnNbIGNvbnYgXTtcblx0XHR9XG5cdH1cblxuXHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0Ly8gQ29udmVydCB0byBlYWNoIHNlcXVlbnRpYWwgZGF0YVR5cGVcblx0d2hpbGUgKCBjdXJyZW50ICkge1xuXG5cdFx0aWYgKCBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gKSB7XG5cdFx0XHRqcVhIUlsgcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdIF0gPSByZXNwb25zZTtcblx0XHR9XG5cblx0XHQvLyBBcHBseSB0aGUgZGF0YUZpbHRlciBpZiBwcm92aWRlZFxuXHRcdGlmICggIXByZXYgJiYgaXNTdWNjZXNzICYmIHMuZGF0YUZpbHRlciApIHtcblx0XHRcdHJlc3BvbnNlID0gcy5kYXRhRmlsdGVyKCByZXNwb25zZSwgcy5kYXRhVHlwZSApO1xuXHRcdH1cblxuXHRcdHByZXYgPSBjdXJyZW50O1xuXHRcdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHRcdGlmICggY3VycmVudCApIHtcblxuXHRcdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXG5cdFx0Lypcblx0XHR0aW1lb3V0OiAwLFxuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZGF0YVR5cGU6IG51bGwsXG5cdFx0dXNlcm5hbWU6IG51bGwsXG5cdFx0cGFzc3dvcmQ6IG51bGwsXG5cdFx0Y2FjaGU6IG51bGwsXG5cdFx0dGhyb3dzOiBmYWxzZSxcblx0XHR0cmFkaXRpb25hbDogZmFsc2UsXG5cdFx0aGVhZGVyczoge30sXG5cdFx0Ki9cblxuXHRcdGFjY2VwdHM6IHtcblx0XHRcdFwiKlwiOiBhbGxUeXBlcyxcblx0XHRcdHRleHQ6IFwidGV4dC9wbGFpblwiLFxuXHRcdFx0aHRtbDogXCJ0ZXh0L2h0bWxcIixcblx0XHRcdHhtbDogXCJhcHBsaWNhdGlvbi94bWwsIHRleHQveG1sXCIsXG5cdFx0XHRqc29uOiBcImFwcGxpY2F0aW9uL2pzb24sIHRleHQvamF2YXNjcmlwdFwiXG5cdFx0fSxcblxuXHRcdGNvbnRlbnRzOiB7XG5cdFx0XHR4bWw6IC9cXGJ4bWxcXGIvLFxuXHRcdFx0aHRtbDogL1xcYmh0bWwvLFxuXHRcdFx0anNvbjogL1xcYmpzb25cXGIvXG5cdFx0fSxcblxuXHRcdHJlc3BvbnNlRmllbGRzOiB7XG5cdFx0XHR4bWw6IFwicmVzcG9uc2VYTUxcIixcblx0XHRcdHRleHQ6IFwicmVzcG9uc2VUZXh0XCIsXG5cdFx0XHRqc29uOiBcInJlc3BvbnNlSlNPTlwiXG5cdFx0fSxcblxuXHRcdC8vIERhdGEgY29udmVydGVyc1xuXHRcdC8vIEtleXMgc2VwYXJhdGUgc291cmNlIChvciBjYXRjaGFsbCBcIipcIikgYW5kIGRlc3RpbmF0aW9uIHR5cGVzIHdpdGggYSBzaW5nbGUgc3BhY2Vcblx0XHRjb252ZXJ0ZXJzOiB7XG5cblx0XHRcdC8vIENvbnZlcnQgYW55dGhpbmcgdG8gdGV4dFxuXHRcdFx0XCIqIHRleHRcIjogU3RyaW5nLFxuXG5cdFx0XHQvLyBUZXh0IHRvIGh0bWwgKHRydWUgPSBubyB0cmFuc2Zvcm1hdGlvbilcblx0XHRcdFwidGV4dCBodG1sXCI6IHRydWUsXG5cblx0XHRcdC8vIEV2YWx1YXRlIHRleHQgYXMgYSBqc29uIGV4cHJlc3Npb25cblx0XHRcdFwidGV4dCBqc29uXCI6IEpTT04ucGFyc2UsXG5cblx0XHRcdC8vIFBhcnNlIHRleHQgYXMgeG1sXG5cdFx0XHRcInRleHQgeG1sXCI6IGpRdWVyeS5wYXJzZVhNTFxuXHRcdH0sXG5cblx0XHQvLyBGb3Igb3B0aW9ucyB0aGF0IHNob3VsZG4ndCBiZSBkZWVwIGV4dGVuZGVkOlxuXHRcdC8vIHlvdSBjYW4gYWRkIHlvdXIgb3duIGN1c3RvbSBvcHRpb25zIGhlcmUgaWZcblx0XHQvLyBhbmQgd2hlbiB5b3UgY3JlYXRlIG9uZSB0aGF0IHNob3VsZG4ndCBiZVxuXHRcdC8vIGRlZXAgZXh0ZW5kZWQgKHNlZSBhamF4RXh0ZW5kKVxuXHRcdGZsYXRPcHRpb25zOiB7XG5cdFx0XHR1cmw6IHRydWUsXG5cdFx0XHRjb250ZXh0OiB0cnVlXG5cdFx0fVxuXHR9LFxuXG5cdC8vIENyZWF0ZXMgYSBmdWxsIGZsZWRnZWQgc2V0dGluZ3Mgb2JqZWN0IGludG8gdGFyZ2V0XG5cdC8vIHdpdGggYm90aCBhamF4U2V0dGluZ3MgYW5kIHNldHRpbmdzIGZpZWxkcy5cblx0Ly8gSWYgdGFyZ2V0IGlzIG9taXR0ZWQsIHdyaXRlcyBpbnRvIGFqYXhTZXR0aW5ncy5cblx0YWpheFNldHVwOiBmdW5jdGlvbiggdGFyZ2V0LCBzZXR0aW5ncyApIHtcblx0XHRyZXR1cm4gc2V0dGluZ3MgP1xuXG5cdFx0XHQvLyBCdWlsZGluZyBhIHNldHRpbmdzIG9iamVjdFxuXHRcdFx0YWpheEV4dGVuZCggYWpheEV4dGVuZCggdGFyZ2V0LCBqUXVlcnkuYWpheFNldHRpbmdzICksIHNldHRpbmdzICkgOlxuXG5cdFx0XHQvLyBFeHRlbmRpbmcgYWpheFNldHRpbmdzXG5cdFx0XHRhamF4RXh0ZW5kKCBqUXVlcnkuYWpheFNldHRpbmdzLCB0YXJnZXQgKTtcblx0fSxcblxuXHRhamF4UHJlZmlsdGVyOiBhZGRUb1ByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHByZWZpbHRlcnMgKSxcblx0YWpheFRyYW5zcG9ydDogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCB0cmFuc3BvcnRzICksXG5cblx0Ly8gTWFpbiBtZXRob2Rcblx0YWpheDogZnVuY3Rpb24oIHVybCwgb3B0aW9ucyApIHtcblxuXHRcdC8vIElmIHVybCBpcyBhbiBvYmplY3QsIHNpbXVsYXRlIHByZS0xLjUgc2lnbmF0dXJlXG5cdFx0aWYgKCB0eXBlb2YgdXJsID09PSBcIm9iamVjdFwiICkge1xuXHRcdFx0b3B0aW9ucyA9IHVybDtcblx0XHRcdHVybCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBGb3JjZSBvcHRpb25zIHRvIGJlIGFuIG9iamVjdFxuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0dmFyIHRyYW5zcG9ydCxcblxuXHRcdFx0Ly8gVVJMIHdpdGhvdXQgYW50aS1jYWNoZSBwYXJhbVxuXHRcdFx0Y2FjaGVVUkwsXG5cblx0XHRcdC8vIFJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyxcblx0XHRcdHJlc3BvbnNlSGVhZGVycyxcblxuXHRcdFx0Ly8gdGltZW91dCBoYW5kbGVcblx0XHRcdHRpbWVvdXRUaW1lcixcblxuXHRcdFx0Ly8gVXJsIGNsZWFudXAgdmFyXG5cdFx0XHR1cmxBbmNob3IsXG5cblx0XHRcdC8vIFJlcXVlc3Qgc3RhdGUgKGJlY29tZXMgZmFsc2UgdXBvbiBzZW5kIGFuZCB0cnVlIHVwb24gY29tcGxldGlvbilcblx0XHRcdGNvbXBsZXRlZCxcblxuXHRcdFx0Ly8gVG8ga25vdyBpZiBnbG9iYWwgZXZlbnRzIGFyZSB0byBiZSBkaXNwYXRjaGVkXG5cdFx0XHRmaXJlR2xvYmFscyxcblxuXHRcdFx0Ly8gTG9vcCB2YXJpYWJsZVxuXHRcdFx0aSxcblxuXHRcdFx0Ly8gdW5jYWNoZWQgcGFydCBvZiB0aGUgdXJsXG5cdFx0XHR1bmNhY2hlZCxcblxuXHRcdFx0Ly8gQ3JlYXRlIHRoZSBmaW5hbCBvcHRpb25zIG9iamVjdFxuXHRcdFx0cyA9IGpRdWVyeS5hamF4U2V0dXAoIHt9LCBvcHRpb25zICksXG5cblx0XHRcdC8vIENhbGxiYWNrcyBjb250ZXh0XG5cdFx0XHRjYWxsYmFja0NvbnRleHQgPSBzLmNvbnRleHQgfHwgcyxcblxuXHRcdFx0Ly8gQ29udGV4dCBmb3IgZ2xvYmFsIGV2ZW50cyBpcyBjYWxsYmFja0NvbnRleHQgaWYgaXQgaXMgYSBET00gbm9kZSBvciBqUXVlcnkgY29sbGVjdGlvblxuXHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0ID0gcy5jb250ZXh0ICYmXG5cdFx0XHRcdCggY2FsbGJhY2tDb250ZXh0Lm5vZGVUeXBlIHx8IGNhbGxiYWNrQ29udGV4dC5qcXVlcnkgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBjYWxsYmFja0NvbnRleHQgKSA6XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LFxuXG5cdFx0XHQvLyBEZWZlcnJlZHNcblx0XHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRjb21wbGV0ZURlZmVycmVkID0galF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRzdGF0dXNDb2RlID0gcy5zdGF0dXNDb2RlIHx8IHt9LFxuXG5cdFx0XHQvLyBIZWFkZXJzICh0aGV5IGFyZSBzZW50IGFsbCBhdCBvbmNlKVxuXHRcdFx0cmVxdWVzdEhlYWRlcnMgPSB7fSxcblx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXMgPSB7fSxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAhcmVzcG9uc2VIZWFkZXJzICkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnMgPSB7fTtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoID0gcmhlYWRlcnMuZXhlYyggcmVzcG9uc2VIZWFkZXJzU3RyaW5nICkgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gPVxuXHRcdFx0XHRcdFx0XHRcdFx0KCByZXNwb25zZUhlYWRlcnNbIG1hdGNoWyAxIF0udG9Mb3dlckNhc2UoKSArIFwiIFwiIF0gfHwgW10gKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuY29uY2F0KCBtYXRjaFsgMiBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdG1hdGNoID0gcmVzcG9uc2VIZWFkZXJzWyBrZXkudG9Mb3dlckNhc2UoKSArIFwiIFwiIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBtYXRjaCA9PSBudWxsID8gbnVsbCA6IG1hdGNoLmpvaW4oIFwiLCBcIiApO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFJhdyBzdHJpbmdcblx0XHRcdFx0Z2V0QWxsUmVzcG9uc2VIZWFkZXJzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gY29tcGxldGVkID8gcmVzcG9uc2VIZWFkZXJzU3RyaW5nIDogbnVsbDtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBDYWNoZXMgdGhlIGhlYWRlclxuXHRcdFx0XHRzZXRSZXF1ZXN0SGVhZGVyOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSA9XG5cdFx0XHRcdFx0XHRcdHJlcXVlc3RIZWFkZXJzTmFtZXNbIG5hbWUudG9Mb3dlckNhc2UoKSBdIHx8IG5hbWU7XG5cdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc1sgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlcyByZXNwb25zZSBjb250ZW50LXR5cGUgaGVhZGVyXG5cdFx0XHRcdG92ZXJyaWRlTWltZVR5cGU6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRzLm1pbWVUeXBlID0gdHlwZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdFx0c3RhdHVzQ29kZTogZnVuY3Rpb24oIG1hcCApIHtcblx0XHRcdFx0XHR2YXIgY29kZTtcblx0XHRcdFx0XHRpZiAoIG1hcCApIHtcblx0XHRcdFx0XHRcdGlmICggY29tcGxldGVkICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFja3MgaW4gYSB3YXkgdGhhdCBwcmVzZXJ2ZXMgb2xkIG9uZXNcblx0XHRcdFx0XHRcdFx0Zm9yICggY29kZSBpbiBtYXAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0c3RhdHVzQ29kZVsgY29kZSBdID0gWyBzdGF0dXNDb2RlWyBjb2RlIF0sIG1hcFsgY29kZSBdIF07XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICk7XG5cblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiIClcblx0XHRcdC5yZXBsYWNlKCBycHJvdG9jb2wsIGxvY2F0aW9uLnByb3RvY29sICsgXCIvL1wiICk7XG5cblx0XHQvLyBBbGlhcyBtZXRob2Qgb3B0aW9uIHRvIHR5cGUgYXMgcGVyIHRpY2tldCAjMTIwMDRcblx0XHRzLnR5cGUgPSBvcHRpb25zLm1ldGhvZCB8fCBvcHRpb25zLnR5cGUgfHwgcy5tZXRob2QgfHwgcy50eXBlO1xuXG5cdFx0Ly8gRXh0cmFjdCBkYXRhVHlwZXMgbGlzdFxuXHRcdHMuZGF0YVR5cGVzID0gKCBzLmRhdGFUeXBlIHx8IFwiKlwiICkudG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIG9uIGFjY2Vzc2luZyB0aGUgaHJlZiBwcm9wZXJ0eSBpZiB1cmwgaXMgbWFsZm9ybWVkLFxuXHRcdFx0Ly8gZS5nLiBodHRwOi8vZXhhbXBsZS5jb206ODB4L1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0dXJsQW5jaG9yLmhyZWYgPSBzLnVybDtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTggLSAxMSBvbmx5XG5cdFx0XHRcdC8vIEFuY2hvcidzIGhvc3QgcHJvcGVydHkgaXNuJ3QgY29ycmVjdGx5IHNldCB3aGVuIHMudXJsIGlzIHJlbGF0aXZlXG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gdXJsQW5jaG9yLmhyZWY7XG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSBvcmlnaW5BbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyBvcmlnaW5BbmNob3IuaG9zdCAhPT1cblx0XHRcdFx0XHR1cmxBbmNob3IucHJvdG9jb2wgKyBcIi8vXCIgKyB1cmxBbmNob3IuaG9zdDtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFuIGVycm9yIHBhcnNpbmcgdGhlIFVSTCwgYXNzdW1lIGl0IGlzIGNyb3NzRG9tYWluLFxuXHRcdFx0XHQvLyBpdCBjYW4gYmUgcmVqZWN0ZWQgYnkgdGhlIHRyYW5zcG9ydCBpZiBpdCBpcyBpbnZhbGlkXG5cdFx0XHRcdHMuY3Jvc3NEb21haW4gPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENvbnZlcnQgZGF0YSBpZiBub3QgYWxyZWFkeSBhIHN0cmluZ1xuXHRcdGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiYgdHlwZW9mIHMuZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHMuZGF0YSA9IGpRdWVyeS5wYXJhbSggcy5kYXRhLCBzLnRyYWRpdGlvbmFsICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgcHJlZmlsdGVyc1xuXHRcdGluc3BlY3RQcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzLCBzLCBvcHRpb25zLCBqcVhIUiApO1xuXG5cdFx0Ly8gSWYgcmVxdWVzdCB3YXMgYWJvcnRlZCBpbnNpZGUgYSBwcmVmaWx0ZXIsIHN0b3AgdGhlcmVcblx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdC8vIFJlbW92ZSBoYXNoIHRvIHNpbXBsaWZ5IHVybCBtYW5pcHVsYXRpb25cblx0XHRjYWNoZVVSTCA9IHMudXJsLnJlcGxhY2UoIHJoYXNoLCBcIlwiICk7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIGhhc2ggc28gd2UgY2FuIHB1dCBpdCBiYWNrXG5cdFx0XHR1bmNhY2hlZCA9IHMudXJsLnNsaWNlKCBjYWNoZVVSTC5sZW5ndGggKTtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWQsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgJiYgKCBzLnByb2Nlc3NEYXRhIHx8IHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgKSApIHtcblx0XHRcdFx0Y2FjaGVVUkwgKz0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuZGF0YTtcblxuXHRcdFx0XHQvLyAjOTY4MjogcmVtb3ZlIGRhdGEgc28gdGhhdCBpdCdzIG5vdCB1c2VkIGluIGFuIGV2ZW50dWFsIHJldHJ5XG5cdFx0XHRcdGRlbGV0ZSBzLmRhdGE7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBvciB1cGRhdGUgYW50aS1jYWNoZSBwYXJhbSBpZiBuZWVkZWRcblx0XHRcdGlmICggcy5jYWNoZSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gY2FjaGVVUkwucmVwbGFjZSggcmFudGlDYWNoZSwgXCIkMVwiICk7XG5cdFx0XHRcdHVuY2FjaGVkID0gKCBycXVlcnkudGVzdCggY2FjaGVVUkwgKSA/IFwiJlwiIDogXCI/XCIgKSArIFwiXz1cIiArICggbm9uY2UrKyApICsgdW5jYWNoZWQ7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFB1dCBoYXNoIGFuZCBhbnRpLWNhY2hlIG9uIHRoZSBVUkwgdGhhdCB3aWxsIGJlIHJlcXVlc3RlZCAoZ2gtMTczMilcblx0XHRcdHMudXJsID0gY2FjaGVVUkwgKyB1bmNhY2hlZDtcblxuXHRcdC8vIENoYW5nZSAnJTIwJyB0byAnKycgaWYgdGhpcyBpcyBlbmNvZGVkIGZvcm0gYm9keSBjb250ZW50IChnaC0yNjU4KVxuXHRcdH0gZWxzZSBpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmXG5cdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApLmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCApIHtcblx0XHRcdHMuZGF0YSA9IHMuZGF0YS5yZXBsYWNlKCByMjAsIFwiK1wiICk7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0IHRoZSBJZi1Nb2RpZmllZC1TaW5jZSBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIsIGlmIGluIGlmTW9kaWZpZWQgbW9kZS5cblx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdGlmICggalF1ZXJ5Lmxhc3RNb2RpZmllZFsgY2FjaGVVUkwgXSApIHtcblx0XHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJJZi1Nb2RpZmllZC1TaW5jZVwiLCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU5vbmUtTWF0Y2hcIiwgalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIGNvcnJlY3QgaGVhZGVyLCBpZiBkYXRhIGlzIGJlaW5nIHNlbnRcblx0XHRpZiAoIHMuZGF0YSAmJiBzLmhhc0NvbnRlbnQgJiYgcy5jb250ZW50VHlwZSAhPT0gZmFsc2UgfHwgb3B0aW9ucy5jb250ZW50VHlwZSApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIsIHMuY29udGVudFR5cGUgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIEFjY2VwdHMgaGVhZGVyIGZvciB0aGUgc2VydmVyLCBkZXBlbmRpbmcgb24gdGhlIGRhdGFUeXBlXG5cdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlcihcblx0XHRcdFwiQWNjZXB0XCIsXG5cdFx0XHRzLmRhdGFUeXBlc1sgMCBdICYmIHMuYWNjZXB0c1sgcy5kYXRhVHlwZXNbIDAgXSBdID9cblx0XHRcdFx0cy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gK1xuXHRcdFx0XHRcdCggcy5kYXRhVHlwZXNbIDAgXSAhPT0gXCIqXCIgPyBcIiwgXCIgKyBhbGxUeXBlcyArIFwiOyBxPTAuMDFcIiA6IFwiXCIgKSA6XG5cdFx0XHRcdHMuYWNjZXB0c1sgXCIqXCIgXVxuXHRcdCk7XG5cblx0XHQvLyBDaGVjayBmb3IgaGVhZGVycyBvcHRpb25cblx0XHRmb3IgKCBpIGluIHMuaGVhZGVycyApIHtcblx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIGksIHMuaGVhZGVyc1sgaSBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsb3cgY3VzdG9tIGhlYWRlcnMvbWltZXR5cGVzIGFuZCBlYXJseSBhYm9ydFxuXHRcdGlmICggcy5iZWZvcmVTZW5kICYmXG5cdFx0XHQoIHMuYmVmb3JlU2VuZC5jYWxsKCBjYWxsYmFja0NvbnRleHQsIGpxWEhSLCBzICkgPT09IGZhbHNlIHx8IGNvbXBsZXRlZCApICkge1xuXG5cdFx0XHQvLyBBYm9ydCBpZiBub3QgZG9uZSBhbHJlYWR5IGFuZCByZXR1cm5cblx0XHRcdHJldHVybiBqcVhIUi5hYm9ydCgpO1xuXHRcdH1cblxuXHRcdC8vIEFib3J0aW5nIGlzIG5vIGxvbmdlciBhIGNhbmNlbGxhdGlvblxuXHRcdHN0ckFib3J0ID0gXCJhYm9ydFwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja3Mgb24gZGVmZXJyZWRzXG5cdFx0Y29tcGxldGVEZWZlcnJlZC5hZGQoIHMuY29tcGxldGUgKTtcblx0XHRqcVhIUi5kb25lKCBzLnN1Y2Nlc3MgKTtcblx0XHRqcVhIUi5mYWlsKCBzLmVycm9yICk7XG5cblx0XHQvLyBHZXQgdHJhbnNwb3J0XG5cdFx0dHJhbnNwb3J0ID0gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHRyYW5zcG9ydHMsIHMsIG9wdGlvbnMsIGpxWEhSICk7XG5cblx0XHQvLyBJZiBubyB0cmFuc3BvcnQsIHdlIGF1dG8tYWJvcnRcblx0XHRpZiAoICF0cmFuc3BvcnQgKSB7XG5cdFx0XHRkb25lKCAtMSwgXCJObyBUcmFuc3BvcnRcIiApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gMTtcblxuXHRcdFx0Ly8gU2VuZCBnbG9iYWwgZXZlbnRcblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhTZW5kXCIsIFsganFYSFIsIHMgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiByZXF1ZXN0IHdhcyBhYm9ydGVkIGluc2lkZSBhamF4U2VuZCwgc3RvcCB0aGVyZVxuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybiBqcVhIUjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVGltZW91dFxuXHRcdFx0aWYgKCBzLmFzeW5jICYmIHMudGltZW91dCA+IDAgKSB7XG5cdFx0XHRcdHRpbWVvdXRUaW1lciA9IHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRqcVhIUi5hYm9ydCggXCJ0aW1lb3V0XCIgKTtcblx0XHRcdFx0fSwgcy50aW1lb3V0ICk7XG5cdFx0XHR9XG5cblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbXBsZXRlZCA9IGZhbHNlO1xuXHRcdFx0XHR0cmFuc3BvcnQuc2VuZCggcmVxdWVzdEhlYWRlcnMsIGRvbmUgKTtcblx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXG5cdFx0XHRcdC8vIFJldGhyb3cgcG9zdC1jb21wbGV0aW9uIGV4Y2VwdGlvbnNcblx0XHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFByb3BhZ2F0ZSBvdGhlcnMgYXMgcmVzdWx0c1xuXHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhbGxiYWNrIGZvciB3aGVuIGV2ZXJ5dGhpbmcgaXMgZG9uZVxuXHRcdGZ1bmN0aW9uIGRvbmUoIHN0YXR1cywgbmF0aXZlU3RhdHVzVGV4dCwgcmVzcG9uc2VzLCBoZWFkZXJzICkge1xuXHRcdFx0dmFyIGlzU3VjY2Vzcywgc3VjY2VzcywgZXJyb3IsIHJlc3BvbnNlLCBtb2RpZmllZCxcblx0XHRcdFx0c3RhdHVzVGV4dCA9IG5hdGl2ZVN0YXR1c1RleHQ7XG5cblx0XHRcdC8vIElnbm9yZSByZXBlYXQgaW52b2NhdGlvbnNcblx0XHRcdGlmICggY29tcGxldGVkICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGNvbXBsZXRlZCA9IHRydWU7XG5cblx0XHRcdC8vIENsZWFyIHRpbWVvdXQgaWYgaXQgZXhpc3RzXG5cdFx0XHRpZiAoIHRpbWVvdXRUaW1lciApIHtcblx0XHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dFRpbWVyICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIERlcmVmZXJlbmNlIHRyYW5zcG9ydCBmb3IgZWFybHkgZ2FyYmFnZSBjb2xsZWN0aW9uXG5cdFx0XHQvLyAobm8gbWF0dGVyIGhvdyBsb25nIHRoZSBqcVhIUiBvYmplY3Qgd2lsbCBiZSB1c2VkKVxuXHRcdFx0dHJhbnNwb3J0ID0gdW5kZWZpbmVkO1xuXG5cdFx0XHQvLyBDYWNoZSByZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcgPSBoZWFkZXJzIHx8IFwiXCI7XG5cblx0XHRcdC8vIFNldCByZWFkeVN0YXRlXG5cdFx0XHRqcVhIUi5yZWFkeVN0YXRlID0gc3RhdHVzID4gMCA/IDQgOiAwO1xuXG5cdFx0XHQvLyBEZXRlcm1pbmUgaWYgc3VjY2Vzc2Z1bFxuXHRcdFx0aXNTdWNjZXNzID0gc3RhdHVzID49IDIwMCAmJiBzdGF0dXMgPCAzMDAgfHwgc3RhdHVzID09PSAzMDQ7XG5cblx0XHRcdC8vIEdldCByZXNwb25zZSBkYXRhXG5cdFx0XHRpZiAoIHJlc3BvbnNlcyApIHtcblx0XHRcdFx0cmVzcG9uc2UgPSBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIGksIG1ldGhvZCApIHtcblx0alF1ZXJ5WyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB1cmwsIGRhdGEsIGNhbGxiYWNrLCB0eXBlICkge1xuXG5cdFx0Ly8gU2hpZnQgYXJndW1lbnRzIGlmIGRhdGEgYXJndW1lbnQgd2FzIG9taXR0ZWRcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsLCBvcHRpb25zICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMgKTtcblx0XHR9XG5cdH0gKTtcbn07XG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHR3cmFwQWxsOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgd3JhcDtcblxuXHRcdGlmICggdGhpc1sgMCBdICkge1xuXHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRcdGh0bWwgPSBodG1sLmNhbGwoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaGUgZWxlbWVudHMgdG8gd3JhcCB0aGUgdGFyZ2V0IGFyb3VuZFxuXHRcdFx0d3JhcCA9IGpRdWVyeSggaHRtbCwgdGhpc1sgMCBdLm93bmVyRG9jdW1lbnQgKS5lcSggMCApLmNsb25lKCB0cnVlICk7XG5cblx0XHRcdGlmICggdGhpc1sgMCBdLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHdyYXAuaW5zZXJ0QmVmb3JlKCB0aGlzWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0d3JhcC5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZWxlbSA9IHRoaXM7XG5cblx0XHRcdFx0d2hpbGUgKCBlbGVtLmZpcnN0RWxlbWVudENoaWxkICkge1xuXHRcdFx0XHRcdGVsZW0gPSBlbGVtLmZpcnN0RWxlbWVudENoaWxkO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGVsZW07XG5cdFx0XHR9ICkuYXBwZW5kKCB0aGlzICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0d3JhcElubmVyOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwSW5uZXIoIGh0bWwuY2FsbCggdGhpcywgaSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGpRdWVyeSggdGhpcyApLFxuXHRcdFx0XHRjb250ZW50cyA9IHNlbGYuY29udGVudHMoKTtcblxuXHRcdFx0aWYgKCBjb250ZW50cy5sZW5ndGggKSB7XG5cdFx0XHRcdGNvbnRlbnRzLndyYXBBbGwoIGh0bWwgKTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VsZi5hcHBlbmQoIGh0bWwgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0d3JhcDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIGh0bWxJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggaHRtbCApO1xuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS53cmFwQWxsKCBodG1sSXNGdW5jdGlvbiA/IGh0bWwuY2FsbCggdGhpcywgaSApIDogaHRtbCApO1xuXHRcdH0gKTtcblx0fSxcblxuXHR1bndyYXA6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR0aGlzLnBhcmVudCggc2VsZWN0b3IgKS5ub3QoIFwiYm9keVwiICkuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkoIHRoaXMgKS5yZXBsYWNlV2l0aCggdGhpcy5jaGlsZE5vZGVzICk7XG5cdFx0fSApO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59ICk7XG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5oaWRkZW4gPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICFqUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUoIGVsZW0gKTtcbn07XG5qUXVlcnkuZXhwci5wc2V1ZG9zLnZpc2libGUgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuICEhKCBlbGVtLm9mZnNldFdpZHRoIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0IHx8IGVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKTtcbn07XG5cblxuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0Ly8gIzE0NTA6IHNvbWV0aW1lcyBJRSByZXR1cm5zIDEyMjMgd2hlbiBpdCBzaG91bGQgYmUgMjA0XG5cdFx0MTIyMzogMjA0XG5cdH0sXG5cdHhoclN1cHBvcnRlZCA9IGpRdWVyeS5hamF4U2V0dGluZ3MueGhyKCk7XG5cbnN1cHBvcnQuY29ycyA9ICEheGhyU3VwcG9ydGVkICYmICggXCJ3aXRoQ3JlZGVudGlhbHNcIiBpbiB4aHJTdXBwb3J0ZWQgKTtcbnN1cHBvcnQuYWpheCA9IHhoclN1cHBvcnRlZCA9ICEheGhyU3VwcG9ydGVkO1xuXG5qUXVlcnkuYWpheFRyYW5zcG9ydCggZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cdHZhciBjYWxsYmFjaywgZXJyb3JDYWxsYmFjaztcblxuXHQvLyBDcm9zcyBkb21haW4gb25seSBhbGxvd2VkIGlmIHN1cHBvcnRlZCB0aHJvdWdoIFhNTEh0dHBSZXF1ZXN0XG5cdGlmICggc3VwcG9ydC5jb3JzIHx8IHhoclN1cHBvcnRlZCAmJiAhb3B0aW9ucy5jcm9zc0RvbWFpbiApIHtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2VuZDogZnVuY3Rpb24oIGhlYWRlcnMsIGNvbXBsZXRlICkge1xuXHRcdFx0XHR2YXIgaSxcblx0XHRcdFx0XHR4aHIgPSBvcHRpb25zLnhocigpO1xuXG5cdFx0XHRcdHhoci5vcGVuKFxuXHRcdFx0XHRcdG9wdGlvbnMudHlwZSxcblx0XHRcdFx0XHRvcHRpb25zLnVybCxcblx0XHRcdFx0XHRvcHRpb25zLmFzeW5jLFxuXHRcdFx0XHRcdG9wdGlvbnMudXNlcm5hbWUsXG5cdFx0XHRcdFx0b3B0aW9ucy5wYXNzd29yZFxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdC8vIEFwcGx5IGN1c3RvbSBmaWVsZHMgaWYgcHJvdmlkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRmb3IgKCBpIGluIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdFx0eGhyWyBpIF0gPSBvcHRpb25zLnhockZpZWxkc1sgaSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIE92ZXJyaWRlIG1pbWUgdHlwZSBpZiBuZWVkZWRcblx0XHRcdFx0aWYgKCBvcHRpb25zLm1pbWVUeXBlICYmIHhoci5vdmVycmlkZU1pbWVUeXBlICkge1xuXHRcdFx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCBvcHRpb25zLm1pbWVUeXBlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBYLVJlcXVlc3RlZC1XaXRoIGhlYWRlclxuXHRcdFx0XHQvLyBGb3IgY3Jvc3MtZG9tYWluIHJlcXVlc3RzLCBzZWVpbmcgYXMgY29uZGl0aW9ucyBmb3IgYSBwcmVmbGlnaHQgYXJlXG5cdFx0XHRcdC8vIGFraW4gdG8gYSBqaWdzYXcgcHV6emxlLCB3ZSBzaW1wbHkgbmV2ZXIgc2V0IGl0IHRvIGJlIHN1cmUuXG5cdFx0XHRcdC8vIChpdCBjYW4gYWx3YXlzIGJlIHNldCBvbiBhIHBlci1yZXF1ZXN0IGJhc2lzIG9yIGV2ZW4gdXNpbmcgYWpheFNldHVwKVxuXHRcdFx0XHQvLyBGb3Igc2FtZS1kb21haW4gcmVxdWVzdHMsIHdvbid0IGNoYW5nZSBoZWFkZXIgaWYgYWxyZWFkeSBwcm92aWRlZC5cblx0XHRcdFx0aWYgKCAhb3B0aW9ucy5jcm9zc0RvbWFpbiAmJiAhaGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSApIHtcblx0XHRcdFx0XHRoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdID0gXCJYTUxIdHRwUmVxdWVzdFwiO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gU2V0IGhlYWRlcnNcblx0XHRcdFx0Zm9yICggaSBpbiBoZWFkZXJzICkge1xuXHRcdFx0XHRcdHhoci5zZXRSZXF1ZXN0SGVhZGVyKCBpLCBoZWFkZXJzWyBpIF0gKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIENhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBlcnJvckNhbGxiYWNrID0geGhyLm9ubG9hZCA9XG5cdFx0XHRcdFx0XHRcdFx0eGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPVxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IG51bGw7XG5cblx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlID09PSBcImFib3J0XCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0eGhyLmFib3J0KCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoIHR5cGUgPT09IFwiZXJyb3JcIiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IHhoci5vbnRpbWVvdXQgPSBjYWxsYmFjayggXCJlcnJvclwiICk7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgOSBvbmx5XG5cdFx0XHRcdC8vIFVzZSBvbnJlYWR5c3RhdGVjaGFuZ2UgdG8gcmVwbGFjZSBvbmFib3J0XG5cdFx0XHRcdC8vIHRvIGhhbmRsZSB1bmNhdWdodCBhYm9ydHNcblx0XHRcdFx0aWYgKCB4aHIub25hYm9ydCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHhoci5vbmFib3J0ID0gZXJyb3JDYWxsYmFjaztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHRcdC8vIENoZWNrIHJlYWR5U3RhdGUgYmVmb3JlIHRpbWVvdXQgYXMgaXQgY2hhbmdlc1xuXHRcdFx0XHRcdFx0aWYgKCB4aHIucmVhZHlTdGF0ZSA9PT0gNCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBbGxvdyBvbmVycm9yIHRvIGJlIGNhbGxlZCBmaXJzdCxcblx0XHRcdFx0XHRcdFx0Ly8gYnV0IHRoYXQgd2lsbCBub3QgaGFuZGxlIGEgbmF0aXZlIGFib3J0XG5cdFx0XHRcdFx0XHRcdC8vIEFsc28sIHNhdmUgZXJyb3JDYWxsYmFjayB0byBhIHZhcmlhYmxlXG5cdFx0XHRcdFx0XHRcdC8vIGFzIHhoci5vbmVycm9yIGNhbm5vdCBiZSBhY2Nlc3NlZFxuXHRcdFx0XHRcdFx0XHR3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGVycm9yQ2FsbGJhY2soKTtcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ3JlYXRlIHRoZSBhYm9ydCBjYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGNhbGxiYWNrKCBcImFib3J0XCIgKTtcblxuXHRcdFx0XHR0cnkge1xuXG5cdFx0XHRcdFx0Ly8gRG8gc2VuZCB0aGUgcmVxdWVzdCAodGhpcyBtYXkgcmFpc2UgYW4gZXhjZXB0aW9uKVxuXHRcdFx0XHRcdHhoci5zZW5kKCBvcHRpb25zLmhhc0NvbnRlbnQgJiYgb3B0aW9ucy5kYXRhIHx8IG51bGwgKTtcblx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHQvLyAjMTQ2ODM6IE9ubHkgcmV0aHJvdyBpZiB0aGlzIGhhc24ndCBiZWVuIG5vdGlmaWVkIGFzIGFuIGVycm9yIHlldFxuXHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFByZXZlbnQgYXV0by1leGVjdXRpb24gb2Ygc2NyaXB0cyB3aGVuIG5vIGV4cGxpY2l0IGRhdGFUeXBlIHdhcyBwcm92aWRlZCAoU2VlIGdoLTI0MzIpXG5qUXVlcnkuYWpheFByZWZpbHRlciggZnVuY3Rpb24oIHMgKSB7XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLmNvbnRlbnRzLnNjcmlwdCA9IGZhbHNlO1xuXHR9XG59ICk7XG5cbi8vIEluc3RhbGwgc2NyaXB0IGRhdGFUeXBlXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGFjY2VwdHM6IHtcblx0XHRzY3JpcHQ6IFwidGV4dC9qYXZhc2NyaXB0LCBhcHBsaWNhdGlvbi9qYXZhc2NyaXB0LCBcIiArXG5cdFx0XHRcImFwcGxpY2F0aW9uL2VjbWFzY3JpcHQsIGFwcGxpY2F0aW9uL3gtZWNtYXNjcmlwdFwiXG5cdH0sXG5cdGNvbnRlbnRzOiB7XG5cdFx0c2NyaXB0OiAvXFxiKD86amF2YXxlY21hKXNjcmlwdFxcYi9cblx0fSxcblx0Y29udmVydGVyczoge1xuXHRcdFwidGV4dCBzY3JpcHRcIjogZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggdGV4dCApO1xuXHRcdFx0cmV0dXJuIHRleHQ7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIEhhbmRsZSBjYWNoZSdzIHNwZWNpYWwgY2FzZSBhbmQgY3Jvc3NEb21haW5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBcInNjcmlwdFwiLCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNhY2hlID09PSB1bmRlZmluZWQgKSB7XG5cdFx0cy5jYWNoZSA9IGZhbHNlO1xuXHR9XG5cdGlmICggcy5jcm9zc0RvbWFpbiApIHtcblx0XHRzLnR5cGUgPSBcIkdFVFwiO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgc2NyaXB0IHRhZyBoYWNrIHRyYW5zcG9ydFxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXG5cdC8vIFRoaXMgdHJhbnNwb3J0IG9ubHkgZGVhbHMgd2l0aCBjcm9zcyBkb21haW4gb3IgZm9yY2VkLWJ5LWF0dHJzIHJlcXVlc3RzXG5cdGlmICggcy5jcm9zc0RvbWFpbiB8fCBzLnNjcmlwdEF0dHJzICkge1xuXHRcdHZhciBzY3JpcHQsIGNhbGxiYWNrO1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggXywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHNjcmlwdCA9IGpRdWVyeSggXCI8c2NyaXB0PlwiIClcblx0XHRcdFx0XHQuYXR0ciggcy5zY3JpcHRBdHRycyB8fCB7fSApXG5cdFx0XHRcdFx0LnByb3AoIHsgY2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LCBzcmM6IHMudXJsIH0gKVxuXHRcdFx0XHRcdC5vbiggXCJsb2FkIGVycm9yXCIsIGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9ICk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0gaXNGdW5jdGlvbiggcy5qc29ucENhbGxiYWNrICkgP1xuXHRcdFx0cy5qc29ucENhbGxiYWNrKCkgOlxuXHRcdFx0cy5qc29ucENhbGxiYWNrO1xuXG5cdFx0Ly8gSW5zZXJ0IGNhbGxiYWNrIGludG8gdXJsIG9yIGZvcm0gZGF0YVxuXHRcdGlmICgganNvblByb3AgKSB7XG5cdFx0XHRzWyBqc29uUHJvcCBdID0gc1sganNvblByb3AgXS5yZXBsYWNlKCByanNvbnAsIFwiJDFcIiArIGNhbGxiYWNrTmFtZSApO1xuXHRcdH0gZWxzZSBpZiAoIHMuanNvbnAgIT09IGZhbHNlICkge1xuXHRcdFx0cy51cmwgKz0gKCBycXVlcnkudGVzdCggcy51cmwgKSA/IFwiJlwiIDogXCI/XCIgKSArIHMuanNvbnAgKyBcIj1cIiArIGNhbGxiYWNrTmFtZTtcblx0XHR9XG5cblx0XHQvLyBVc2UgZGF0YSBjb252ZXJ0ZXIgdG8gcmV0cmlldmUganNvbiBhZnRlciBzY3JpcHQgZXhlY3V0aW9uXG5cdFx0cy5jb252ZXJ0ZXJzWyBcInNjcmlwdCBqc29uXCIgXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCAhcmVzcG9uc2VDb250YWluZXIgKSB7XG5cdFx0XHRcdGpRdWVyeS5lcnJvciggY2FsbGJhY2tOYW1lICsgXCIgd2FzIG5vdCBjYWxsZWRcIiApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlc3BvbnNlQ29udGFpbmVyWyAwIF07XG5cdFx0fTtcblxuXHRcdC8vIEZvcmNlIGpzb24gZGF0YVR5cGVcblx0XHRzLmRhdGFUeXBlc1sgMCBdID0gXCJqc29uXCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrXG5cdFx0b3ZlcndyaXR0ZW4gPSB3aW5kb3dbIGNhbGxiYWNrTmFtZSBdO1xuXHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gYXJndW1lbnRzO1xuXHRcdH07XG5cblx0XHQvLyBDbGVhbi11cCBmdW5jdGlvbiAoZmlyZXMgYWZ0ZXIgY29udmVydGVycylcblx0XHRqcVhIUi5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBJZiBwcmV2aW91cyB2YWx1ZSBkaWRuJ3QgZXhpc3QgLSByZW1vdmUgaXRcblx0XHRcdGlmICggb3ZlcndyaXR0ZW4gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0alF1ZXJ5KCB3aW5kb3cgKS5yZW1vdmVQcm9wKCBjYWxsYmFja05hbWUgKTtcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHJlc3RvcmUgcHJlZXhpc3RpbmcgdmFsdWVcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdpbmRvd1sgY2FsbGJhY2tOYW1lIF0gPSBvdmVyd3JpdHRlbjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2F2ZSBiYWNrIGFzIGZyZWVcblx0XHRcdGlmICggc1sgY2FsbGJhY2tOYW1lIF0gKSB7XG5cblx0XHRcdFx0Ly8gTWFrZSBzdXJlIHRoYXQgcmUtdXNpbmcgdGhlIG9wdGlvbnMgZG9lc24ndCBzY3JldyB0aGluZ3MgYXJvdW5kXG5cdFx0XHRcdHMuanNvbnBDYWxsYmFjayA9IG9yaWdpbmFsU2V0dGluZ3MuanNvbnBDYWxsYmFjaztcblxuXHRcdFx0XHQvLyBTYXZlIHRoZSBjYWxsYmFjayBuYW1lIGZvciBmdXR1cmUgdXNlXG5cdFx0XHRcdG9sZENhbGxiYWNrcy5wdXNoKCBjYWxsYmFja05hbWUgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ2FsbCBpZiBpdCB3YXMgYSBmdW5jdGlvbiBhbmQgd2UgaGF2ZSBhIHJlc3BvbnNlXG5cdFx0XHRpZiAoIHJlc3BvbnNlQ29udGFpbmVyICYmIGlzRnVuY3Rpb24oIG92ZXJ3cml0dGVuICkgKSB7XG5cdFx0XHRcdG92ZXJ3cml0dGVuKCByZXNwb25zZUNvbnRhaW5lclsgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHJlc3BvbnNlQ29udGFpbmVyID0gb3ZlcndyaXR0ZW4gPSB1bmRlZmluZWQ7XG5cdFx0fSApO1xuXG5cdFx0Ly8gRGVsZWdhdGUgdG8gc2NyaXB0XG5cdFx0cmV0dXJuIFwic2NyaXB0XCI7XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogU2FmYXJpIDggb25seVxuLy8gSW4gU2FmYXJpIDggZG9jdW1lbnRzIGNyZWF0ZWQgdmlhIGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudFxuLy8gY29sbGFwc2Ugc2libGluZyBmb3JtczogdGhlIHNlY29uZCBvbmUgYmVjb21lcyBhIGNoaWxkIG9mIHRoZSBmaXJzdCBvbmUuXG4vLyBCZWNhdXNlIG9mIHRoYXQsIHRoaXMgc2VjdXJpdHkgbWVhc3VyZSBoYXMgdG8gYmUgZGlzYWJsZWQgaW4gU2FmYXJpIDguXG4vLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM3MzM3XG5zdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCA9ICggZnVuY3Rpb24oKSB7XG5cdHZhciBib2R5ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICkuYm9keTtcblx0Ym9keS5pbm5lckhUTUwgPSBcIjxmb3JtPjwvZm9ybT48Zm9ybT48L2Zvcm0+XCI7XG5cdHJldHVybiBib2R5LmNoaWxkTm9kZXMubGVuZ3RoID09PSAyO1xufSApKCk7XG5cblxuLy8gQXJndW1lbnQgXCJkYXRhXCIgc2hvdWxkIGJlIHN0cmluZyBvZiBodG1sXG4vLyBjb250ZXh0IChvcHRpb25hbCk6IElmIHNwZWNpZmllZCwgdGhlIGZyYWdtZW50IHdpbGwgYmUgY3JlYXRlZCBpbiB0aGlzIGNvbnRleHQsXG4vLyBkZWZhdWx0cyB0byBkb2N1bWVudFxuLy8ga2VlcFNjcmlwdHMgKG9wdGlvbmFsKTogSWYgdHJ1ZSwgd2lsbCBpbmNsdWRlIHNjcmlwdHMgcGFzc2VkIGluIHRoZSBodG1sIHN0cmluZ1xualF1ZXJ5LnBhcnNlSFRNTCA9IGZ1bmN0aW9uKCBkYXRhLCBjb250ZXh0LCBrZWVwU2NyaXB0cyApIHtcblx0aWYgKCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gW107XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdHZhciBiYXNlLCBwYXJzZWQsIHNjcmlwdHM7XG5cblx0aWYgKCAhY29udGV4dCApIHtcblxuXHRcdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHRcdC8vIGJ5IHVzaW5nIGRvY3VtZW50LmltcGxlbWVudGF0aW9uXG5cdFx0aWYgKCBzdXBwb3J0LmNyZWF0ZUhUTUxEb2N1bWVudCApIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKTtcblxuXHRcdFx0Ly8gU2V0IHRoZSBiYXNlIGhyZWYgZm9yIHRoZSBjcmVhdGVkIGRvY3VtZW50XG5cdFx0XHQvLyBzbyBhbnkgcGFyc2VkIGVsZW1lbnRzIHdpdGggVVJMc1xuXHRcdFx0Ly8gYXJlIGJhc2VkIG9uIHRoZSBkb2N1bWVudCdzIFVSTCAoZ2gtMjk2NSlcblx0XHRcdGJhc2UgPSBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiYmFzZVwiICk7XG5cdFx0XHRiYXNlLmhyZWYgPSBkb2N1bWVudC5sb2NhdGlvbi5ocmVmO1xuXHRcdFx0Y29udGV4dC5oZWFkLmFwcGVuZENoaWxkKCBiYXNlICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbnRleHQgPSBkb2N1bWVudDtcblx0XHR9XG5cdH1cblxuXHRwYXJzZWQgPSByc2luZ2xlVGFnLmV4ZWMoIGRhdGEgKTtcblx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLyoqXG4gKiBMb2FkIGEgdXJsIGludG8gYSBwYWdlXG4gKi9cbmpRdWVyeS5mbi5sb2FkID0gZnVuY3Rpb24oIHVybCwgcGFyYW1zLCBjYWxsYmFjayApIHtcblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0gc3RyaXBBbmRDb2xsYXBzZSggdXJsLnNsaWNlKCBvZmYgKSApO1xuXHRcdHVybCA9IHVybC5zbGljZSggMCwgb2ZmICk7XG5cdH1cblxuXHQvLyBJZiBpdCdzIGEgZnVuY3Rpb25cblx0aWYgKCBpc0Z1bmN0aW9uKCBwYXJhbXMgKSApIHtcblxuXHRcdC8vIFdlIGFzc3VtZSB0aGF0IGl0J3MgdGhlIGNhbGxiYWNrXG5cdFx0Y2FsbGJhY2sgPSBwYXJhbXM7XG5cdFx0cGFyYW1zID0gdW5kZWZpbmVkO1xuXG5cdC8vIE90aGVyd2lzZSwgYnVpbGQgYSBwYXJhbSBzdHJpbmdcblx0fSBlbHNlIGlmICggcGFyYW1zICYmIHR5cGVvZiBwYXJhbXMgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0dHlwZSA9IFwiUE9TVFwiO1xuXHR9XG5cblx0Ly8gSWYgd2UgaGF2ZSBlbGVtZW50cyB0byBtb2RpZnksIG1ha2UgdGhlIHJlcXVlc3Rcblx0aWYgKCBzZWxmLmxlbmd0aCA+IDAgKSB7XG5cdFx0alF1ZXJ5LmFqYXgoIHtcblx0XHRcdHVybDogdXJsLFxuXG5cdFx0XHQvLyBJZiBcInR5cGVcIiB2YXJpYWJsZSBpcyB1bmRlZmluZWQsIHRoZW4gXCJHRVRcIiBtZXRob2Qgd2lsbCBiZSB1c2VkLlxuXHRcdFx0Ly8gTWFrZSB2YWx1ZSBvZiB0aGlzIGZpZWxkIGV4cGxpY2l0IHNpbmNlXG5cdFx0XHQvLyB1c2VyIGNhbiBvdmVycmlkZSBpdCB0aHJvdWdoIGFqYXhTZXR1cCBtZXRob2Rcblx0XHRcdHR5cGU6IHR5cGUgfHwgXCJHRVRcIixcblx0XHRcdGRhdGFUeXBlOiBcImh0bWxcIixcblx0XHRcdGRhdGE6IHBhcmFtc1xuXHRcdH0gKS5kb25lKCBmdW5jdGlvbiggcmVzcG9uc2VUZXh0ICkge1xuXG5cdFx0XHQvLyBTYXZlIHJlc3BvbnNlIGZvciB1c2UgaW4gY29tcGxldGUgY2FsbGJhY2tcblx0XHRcdHJlc3BvbnNlID0gYXJndW1lbnRzO1xuXG5cdFx0XHRzZWxmLmh0bWwoIHNlbGVjdG9yID9cblxuXHRcdFx0XHQvLyBJZiBhIHNlbGVjdG9yIHdhcyBzcGVjaWZpZWQsIGxvY2F0ZSB0aGUgcmlnaHQgZWxlbWVudHMgaW4gYSBkdW1teSBkaXZcblx0XHRcdFx0Ly8gRXhjbHVkZSBzY3JpcHRzIHRvIGF2b2lkIElFICdQZXJtaXNzaW9uIERlbmllZCcgZXJyb3JzXG5cdFx0XHRcdGpRdWVyeSggXCI8ZGl2PlwiICkuYXBwZW5kKCBqUXVlcnkucGFyc2VIVE1MKCByZXNwb25zZVRleHQgKSApLmZpbmQoIHNlbGVjdG9yICkgOlxuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSB1c2UgdGhlIGZ1bGwgcmVzdWx0XG5cdFx0XHRcdHJlc3BvbnNlVGV4dCApO1xuXG5cdFx0Ly8gSWYgdGhlIHJlcXVlc3Qgc3VjY2VlZHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImRhdGFcIiwgXCJzdGF0dXNcIiwgXCJqcVhIUlwiXG5cdFx0Ly8gYnV0IHRoZXkgYXJlIGlnbm9yZWQgYmVjYXVzZSByZXNwb25zZSB3YXMgc2V0IGFib3ZlLlxuXHRcdC8vIElmIGl0IGZhaWxzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJqcVhIUlwiLCBcInN0YXR1c1wiLCBcImVycm9yXCJcblx0XHR9ICkuYWx3YXlzKCBjYWxsYmFjayAmJiBmdW5jdGlvbigganFYSFIsIHN0YXR1cyApIHtcblx0XHRcdHNlbGYuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGNhbGxiYWNrLmFwcGx5KCB0aGlzLCByZXNwb25zZSB8fCBbIGpxWEhSLnJlc3BvbnNlVGV4dCwgc3RhdHVzLCBqcVhIUiBdICk7XG5cdFx0XHR9ICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5cblxuXG4vLyBBdHRhY2ggYSBidW5jaCBvZiBmdW5jdGlvbnMgZm9yIGhhbmRsaW5nIGNvbW1vbiBBSkFYIGV2ZW50c1xualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIGksIHR5cGUgKSB7XG5cdGpRdWVyeS5mblsgdHlwZSBdID0gZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlLCBmbiApO1xuXHR9O1xufSApO1xuXG5cblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmFuaW1hdGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiBqUXVlcnkuZ3JlcCggalF1ZXJ5LnRpbWVycywgZnVuY3Rpb24oIGZuICkge1xuXHRcdHJldHVybiBlbGVtID09PSBmbi5lbGVtO1xuXHR9ICkubGVuZ3RoO1xufTtcblxuXG5cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBvcHRpb25zICkgKSB7XG5cblx0XHRcdC8vIFVzZSBqUXVlcnkuZXh0ZW5kIGhlcmUgdG8gYWxsb3cgbW9kaWZpY2F0aW9uIG9mIGNvb3JkaW5hdGVzIGFyZ3VtZW50IChnaC0xODQ4KVxuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMuY2FsbCggZWxlbSwgaSwgalF1ZXJ5LmV4dGVuZCgge30sIGN1ck9mZnNldCApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBvcHRpb25zLnRvcCAhPSBudWxsICkge1xuXHRcdFx0cHJvcHMudG9wID0gKCBvcHRpb25zLnRvcCAtIGN1ck9mZnNldC50b3AgKSArIGN1clRvcDtcblx0XHR9XG5cdFx0aWYgKCBvcHRpb25zLmxlZnQgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLmxlZnQgPSAoIG9wdGlvbnMubGVmdCAtIGN1ck9mZnNldC5sZWZ0ICkgKyBjdXJMZWZ0O1xuXHRcdH1cblxuXHRcdGlmICggXCJ1c2luZ1wiIGluIG9wdGlvbnMgKSB7XG5cdFx0XHRvcHRpb25zLnVzaW5nLmNhbGwoIGVsZW0sIHByb3BzICk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggaSwgcHJvcCApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBwcm9wIF0gPSBhZGRHZXRIb29rSWYoIHN1cHBvcnQucGl4ZWxQb3NpdGlvbixcblx0XHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0XHRjb21wdXRlZCA9IGN1ckNTUyggZWxlbSwgcHJvcCApO1xuXG5cdFx0XHRcdC8vIElmIGN1ckNTUyByZXR1cm5zIHBlcmNlbnRhZ2UsIGZhbGxiYWNrIHRvIG9mZnNldFxuXHRcdFx0XHRyZXR1cm4gcm51bW5vbnB4LnRlc3QoIGNvbXB1dGVkICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggZWxlbSApLnBvc2l0aW9uKClbIHByb3AgXSArIFwicHhcIiA6XG5cdFx0XHRcdFx0Y29tcHV0ZWQ7XG5cdFx0XHR9XG5cdFx0fVxuXHQpO1xufSApO1xuXG5cbi8vIENyZWF0ZSBpbm5lckhlaWdodCwgaW5uZXJXaWR0aCwgaGVpZ2h0LCB3aWR0aCwgb3V0ZXJIZWlnaHQgYW5kIG91dGVyV2lkdGggbWV0aG9kc1xualF1ZXJ5LmVhY2goIHsgSGVpZ2h0OiBcImhlaWdodFwiLCBXaWR0aDogXCJ3aWR0aFwiIH0sIGZ1bmN0aW9uKCBuYW1lLCB0eXBlICkge1xuXHRqUXVlcnkuZWFjaCggeyBwYWRkaW5nOiBcImlubmVyXCIgKyBuYW1lLCBjb250ZW50OiB0eXBlLCBcIlwiOiBcIm91dGVyXCIgKyBuYW1lIH0sXG5cdFx0ZnVuY3Rpb24oIGRlZmF1bHRFeHRyYSwgZnVuY05hbWUgKSB7XG5cblx0XHQvLyBNYXJnaW4gaXMgb25seSBmb3Igb3V0ZXJIZWlnaHQsIG91dGVyV2lkdGhcblx0XHRqUXVlcnkuZm5bIGZ1bmNOYW1lIF0gPSBmdW5jdGlvbiggbWFyZ2luLCB2YWx1ZSApIHtcblx0XHRcdHZhciBjaGFpbmFibGUgPSBhcmd1bWVudHMubGVuZ3RoICYmICggZGVmYXVsdEV4dHJhIHx8IHR5cGVvZiBtYXJnaW4gIT09IFwiYm9vbGVhblwiICksXG5cdFx0XHRcdGV4dHJhID0gZGVmYXVsdEV4dHJhIHx8ICggbWFyZ2luID09PSB0cnVlIHx8IHZhbHVlID09PSB0cnVlID8gXCJtYXJnaW5cIiA6IFwiYm9yZGVyXCIgKTtcblxuXHRcdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIHR5cGUsIHZhbHVlICkge1xuXHRcdFx0XHR2YXIgZG9jO1xuXG5cdFx0XHRcdGlmICggaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vICQoIHdpbmRvdyApLm91dGVyV2lkdGgvSGVpZ2h0IHJldHVybiB3L2ggaW5jbHVkaW5nIHNjcm9sbGJhcnMgKGdoLTE3MjkpXG5cdFx0XHRcdFx0cmV0dXJuIGZ1bmNOYW1lLmluZGV4T2YoIFwib3V0ZXJcIiApID09PSAwID9cblx0XHRcdFx0XHRcdGVsZW1bIFwiaW5uZXJcIiArIG5hbWUgXSA6XG5cdFx0XHRcdFx0XHRlbGVtLmRvY3VtZW50LmRvY3VtZW50RWxlbWVudFsgXCJjbGllbnRcIiArIG5hbWUgXTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEdldCBkb2N1bWVudCB3aWR0aCBvciBoZWlnaHRcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdGRvYyA9IGVsZW0uZG9jdW1lbnRFbGVtZW50O1xuXG5cdFx0XHRcdFx0Ly8gRWl0aGVyIHNjcm9sbFtXaWR0aC9IZWlnaHRdIG9yIG9mZnNldFtXaWR0aC9IZWlnaHRdIG9yIGNsaWVudFtXaWR0aC9IZWlnaHRdLFxuXHRcdFx0XHRcdC8vIHdoaWNoZXZlciBpcyBncmVhdGVzdFxuXHRcdFx0XHRcdHJldHVybiBNYXRoLm1heChcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJzY3JvbGxcIiArIG5hbWUgXSwgZG9jWyBcInNjcm9sbFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcIm9mZnNldFwiICsgbmFtZSBdLCBkb2NbIFwib2Zmc2V0XCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRkb2NbIFwiY2xpZW50XCIgKyBuYW1lIF1cblx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudCwgcmVxdWVzdGluZyBidXQgbm90IGZvcmNpbmcgcGFyc2VGbG9hdFxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIHR5cGUsIGV4dHJhICkgOlxuXG5cdFx0XHRcdFx0Ly8gU2V0IHdpZHRoIG9yIGhlaWdodCBvbiB0aGUgZWxlbWVudFxuXHRcdFx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgdHlwZSwgdmFsdWUsIGV4dHJhICk7XG5cdFx0XHR9LCB0eXBlLCBjaGFpbmFibGUgPyBtYXJnaW4gOiB1bmRlZmluZWQsIGNoYWluYWJsZSApO1xuXHRcdH07XG5cdH0gKTtcbn0gKTtcblxuXG5qUXVlcnkuZWFjaCggKCBcImJsdXIgZm9jdXMgZm9jdXNpbiBmb2N1c291dCByZXNpemUgc2Nyb2xsIGNsaWNrIGRibGNsaWNrIFwiICtcblx0XCJtb3VzZWRvd24gbW91c2V1cCBtb3VzZW1vdmUgbW91c2VvdmVyIG1vdXNlb3V0IG1vdXNlZW50ZXIgbW91c2VsZWF2ZSBcIiArXG5cdFwiY2hhbmdlIHNlbGVjdCBzdWJtaXQga2V5ZG93biBrZXlwcmVzcyBrZXl1cCBjb250ZXh0bWVudVwiICkuc3BsaXQoIFwiIFwiICksXG5cdGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXG5cdC8vIEhhbmRsZSBldmVudCBiaW5kaW5nXG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMCA/XG5cdFx0XHR0aGlzLm9uKCBuYW1lLCBudWxsLCBkYXRhLCBmbiApIDpcblx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhvdmVyOiBmdW5jdGlvbiggZm5PdmVyLCBmbk91dCApIHtcblx0XHRyZXR1cm4gdGhpcy5tb3VzZWVudGVyKCBmbk92ZXIgKS5tb3VzZWxlYXZlKCBmbk91dCB8fCBmbk92ZXIgKTtcblx0fVxufSApO1xuXG5cblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0YmluZDogZnVuY3Rpb24oIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIG51bGwsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuYmluZDogZnVuY3Rpb24oIHR5cGVzLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vZmYoIHR5cGVzLCBudWxsLCBmbiApO1xuXHR9LFxuXG5cdGRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmRlbGVnYXRlOiBmdW5jdGlvbiggc2VsZWN0b3IsIHR5cGVzLCBmbiApIHtcblxuXHRcdC8vICggbmFtZXNwYWNlICkgb3IgKCBzZWxlY3RvciwgdHlwZXMgWywgZm5dIClcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA9PT0gMSA/XG5cdFx0XHR0aGlzLm9mZiggc2VsZWN0b3IsIFwiKipcIiApIDpcblx0XHRcdHRoaXMub2ZmKCB0eXBlcywgc2VsZWN0b3IgfHwgXCIqKlwiLCBmbiApO1xuXHR9XG59ICk7XG5cbi8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuLy8gYXJndW1lbnRzLlxuLy8galF1ZXJ5LnByb3h5IGlzIGRlcHJlY2F0ZWQgdG8gcHJvbW90ZSBzdGFuZGFyZHMgKHNwZWNpZmljYWxseSBGdW5jdGlvbiNiaW5kKVxuLy8gSG93ZXZlciwgaXQgaXMgbm90IHNsYXRlZCBmb3IgcmVtb3ZhbCBhbnkgdGltZSBzb29uXG5qUXVlcnkucHJveHkgPSBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdHZhciB0bXAsIGFyZ3MsIHByb3h5O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRjb250ZXh0ID0gZm47XG5cdFx0Zm4gPSB0bXA7XG5cdH1cblxuXHQvLyBRdWljayBjaGVjayB0byBkZXRlcm1pbmUgaWYgdGFyZ2V0IGlzIGNhbGxhYmxlLCBpbiB0aGUgc3BlY1xuXHQvLyB0aGlzIHRocm93cyBhIFR5cGVFcnJvciwgYnV0IHdlIHdpbGwganVzdCByZXR1cm4gdW5kZWZpbmVkLlxuXHRpZiAoICFpc0Z1bmN0aW9uKCBmbiApICkge1xuXHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdH1cblxuXHQvLyBTaW11bGF0ZWQgYmluZFxuXHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdHByb3h5ID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZuLmFwcGx5KCBjb250ZXh0IHx8IHRoaXMsIGFyZ3MuY29uY2F0KCBzbGljZS5jYWxsKCBhcmd1bWVudHMgKSApICk7XG5cdH07XG5cblx0Ly8gU2V0IHRoZSBndWlkIG9mIHVuaXF1ZSBoYW5kbGVyIHRvIHRoZSBzYW1lIG9mIG9yaWdpbmFsIGhhbmRsZXIsIHNvIGl0IGNhbiBiZSByZW1vdmVkXG5cdHByb3h5Lmd1aWQgPSBmbi5ndWlkID0gZm4uZ3VpZCB8fCBqUXVlcnkuZ3VpZCsrO1xuXG5cdHJldHVybiBwcm94eTtcbn07XG5cbmpRdWVyeS5ob2xkUmVhZHkgPSBmdW5jdGlvbiggaG9sZCApIHtcblx0aWYgKCBob2xkICkge1xuXHRcdGpRdWVyeS5yZWFkeVdhaXQrKztcblx0fSBlbHNlIHtcblx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0fVxufTtcbmpRdWVyeS5pc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcbmpRdWVyeS5wYXJzZUpTT04gPSBKU09OLnBhcnNlO1xualF1ZXJ5Lm5vZGVOYW1lID0gbm9kZU5hbWU7XG5qUXVlcnkuaXNGdW5jdGlvbiA9IGlzRnVuY3Rpb247XG5qUXVlcnkuaXNXaW5kb3cgPSBpc1dpbmRvdztcbmpRdWVyeS5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG5qUXVlcnkudHlwZSA9IHRvVHlwZTtcblxualF1ZXJ5Lm5vdyA9IERhdGUubm93O1xuXG5qUXVlcnkuaXNOdW1lcmljID0gZnVuY3Rpb24oIG9iaiApIHtcblxuXHQvLyBBcyBvZiBqUXVlcnkgMy4wLCBpc051bWVyaWMgaXMgbGltaXRlZCB0b1xuXHQvLyBzdHJpbmdzIGFuZCBudW1iZXJzIChwcmltaXRpdmVzIG9yIG9iamVjdHMpXG5cdC8vIHRoYXQgY2FuIGJlIGNvZXJjZWQgdG8gZmluaXRlIG51bWJlcnMgKGdoLTI2NjIpXG5cdHZhciB0eXBlID0galF1ZXJ5LnR5cGUoIG9iaiApO1xuXHRyZXR1cm4gKCB0eXBlID09PSBcIm51bWJlclwiIHx8IHR5cGUgPT09IFwic3RyaW5nXCIgKSAmJlxuXG5cdFx0Ly8gcGFyc2VGbG9hdCBOYU5zIG51bWVyaWMtY2FzdCBmYWxzZSBwb3NpdGl2ZXMgKFwiXCIpXG5cdFx0Ly8gLi4uYnV0IG1pc2ludGVycHJldHMgbGVhZGluZy1udW1iZXIgc3RyaW5ncywgcGFydGljdWxhcmx5IGhleCBsaXRlcmFscyAoXCIweC4uLlwiKVxuXHRcdC8vIHN1YnRyYWN0aW9uIGZvcmNlcyBpbmZpbml0aWVzIHRvIE5hTlxuXHRcdCFpc05hTiggb2JqIC0gcGFyc2VGbG9hdCggb2JqICkgKTtcbn07XG5cblxuXG5cbi8vIFJlZ2lzdGVyIGFzIGEgbmFtZWQgQU1EIG1vZHVsZSwgc2luY2UgalF1ZXJ5IGNhbiBiZSBjb25jYXRlbmF0ZWQgd2l0aCBvdGhlclxuLy8gZmlsZXMgdGhhdCBtYXkgdXNlIGRlZmluZSwgYnV0IG5vdCB2aWEgYSBwcm9wZXIgY29uY2F0ZW5hdGlvbiBzY3JpcHQgdGhhdFxuLy8gdW5kZXJzdGFuZHMgYW5vbnltb3VzIEFNRCBtb2R1bGVzLiBBIG5hbWVkIEFNRCBpcyBzYWZlc3QgYW5kIG1vc3Qgcm9idXN0XG4vLyB3YXkgdG8gcmVnaXN0ZXIuIExvd2VyY2FzZSBqcXVlcnkgaXMgdXNlZCBiZWNhdXNlIEFNRCBtb2R1bGUgbmFtZXMgYXJlXG4vLyBkZXJpdmVkIGZyb20gZmlsZSBuYW1lcywgYW5kIGpRdWVyeSBpcyBub3JtYWxseSBkZWxpdmVyZWQgaW4gYSBsb3dlcmNhc2Vcbi8vIGZpbGUgbmFtZS4gRG8gdGhpcyBhZnRlciBjcmVhdGluZyB0aGUgZ2xvYmFsIHNvIHRoYXQgaWYgYW4gQU1EIG1vZHVsZSB3YW50c1xuLy8gdG8gY2FsbCBub0NvbmZsaWN0IHRvIGhpZGUgdGhpcyB2ZXJzaW9uIG9mIGpRdWVyeSwgaXQgd2lsbCB3b3JrLlxuXG4vLyBOb3RlIHRoYXQgZm9yIG1heGltdW0gcG9ydGFiaWxpdHksIGxpYnJhcmllcyB0aGF0IGFyZSBub3QgalF1ZXJ5IHNob3VsZFxuLy8gZGVjbGFyZSB0aGVtc2VsdmVzIGFzIGFub255bW91cyBtb2R1bGVzLCBhbmQgYXZvaWQgc2V0dGluZyBhIGdsb2JhbCBpZiBhblxuLy8gQU1EIGxvYWRlciBpcyBwcmVzZW50LiBqUXVlcnkgaXMgYSBzcGVjaWFsIGNhc2UuIEZvciBtb3JlIGluZm9ybWF0aW9uLCBzZWVcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcmJ1cmtlL3JlcXVpcmVqcy93aWtpL1VwZGF0aW5nLWV4aXN0aW5nLWxpYnJhcmllcyN3aWtpLWFub25cblxuaWYgKCB0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCApIHtcblx0ZGVmaW5lKCBcImpxdWVyeVwiLCBbXSwgZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGpRdWVyeTtcblx0fSApO1xufVxuXG5cblxuXG52YXJcblxuXHQvLyBNYXAgb3ZlciBqUXVlcnkgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0X2pRdWVyeSA9IHdpbmRvdy5qUXVlcnksXG5cblx0Ly8gTWFwIG92ZXIgdGhlICQgaW4gY2FzZSBvZiBvdmVyd3JpdGVcblx0XyQgPSB3aW5kb3cuJDtcblxualF1ZXJ5Lm5vQ29uZmxpY3QgPSBmdW5jdGlvbiggZGVlcCApIHtcblx0aWYgKCB3aW5kb3cuJCA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy4kID0gXyQ7XG5cdH1cblxuXHRpZiAoIGRlZXAgJiYgd2luZG93LmpRdWVyeSA9PT0galF1ZXJ5ICkge1xuXHRcdHdpbmRvdy5qUXVlcnkgPSBfalF1ZXJ5O1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeTtcbn07XG5cbi8vIEV4cG9zZSBqUXVlcnkgYW5kICQgaWRlbnRpZmllcnMsIGV2ZW4gaW4gQU1EXG4vLyAoIzcxMDIjY29tbWVudDoxMCwgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9qcXVlcnkvcHVsbC81NTcpXG4vLyBhbmQgQ29tbW9uSlMgZm9yIGJyb3dzZXIgZW11bGF0b3JzICgjMTM1NjYpXG5pZiAoICFub0dsb2JhbCApIHtcblx0d2luZG93LmpRdWVyeSA9IHdpbmRvdy4kID0galF1ZXJ5O1xufVxuXG5cblxuXG5yZXR1cm4galF1ZXJ5O1xufSApO1xuIiwiLy8gSlNUUy4gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHNcbi8vIExpY2Vuc2VzOlxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VETHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0VQTHYxLnR4dFxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9MSUNFTlNFX0xJQ0VOU0VfRVM2X0NPTExFQ1RJT05TLnR4dFxuIWZ1bmN0aW9uKHQsZSl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwidW5kZWZpbmVkXCIhPXR5cGVvZiBtb2R1bGU/ZShleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0sZSk6ZSh0LmpzdHM9dC5qc3RzfHx7fSl9KHRoaXMsZnVuY3Rpb24odCl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gZSh0LGUpe2Zvcih2YXIgbiBpbiBlKWUuaGFzT3duUHJvcGVydHkobikmJih0W25dPWVbbl0pfWZ1bmN0aW9uIG4oKXt9ZnVuY3Rpb24gaSgpe31mdW5jdGlvbiByKCl7fWZ1bmN0aW9uIHMoKXt9ZnVuY3Rpb24gbygpe31mdW5jdGlvbiBhKCl7fWZ1bmN0aW9uIHUoKXt9ZnVuY3Rpb24gbCh0KXt0aGlzLm1lc3NhZ2U9dH1mdW5jdGlvbiBoKHQsZSl7dC5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZShlLnByb3RvdHlwZSksdC5wcm90b3R5cGUuY29uc3RydWN0b3I9dH1mdW5jdGlvbiBjKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpbC5jYWxsKHRoaXMpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gZigpe31mdW5jdGlvbiBnKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy56PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpZy5jYWxsKHRoaXMsMCwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zy5jYWxsKHRoaXMsdC54LHQueSx0LnopfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtnLmNhbGwodGhpcyxlLG4sZy5OVUxMX09SRElOQVRFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy54PWksdGhpcy55PXIsdGhpcy56PXN9fWZ1bmN0aW9uIGQoKXtpZih0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q9MiwwPT09YXJndW1lbnRzLmxlbmd0aClkLmNhbGwodGhpcywyKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07aWYoMiE9PXQmJjMhPT10KXRocm93IG5ldyBpKFwib25seSAyIG9yIDMgZGltZW5zaW9ucyBtYXkgYmUgc3BlY2lmaWVkXCIpO3RoaXMuZGltZW5zaW9uc1RvVGVzdD10fX1mdW5jdGlvbiBwKCl7fWZ1bmN0aW9uIHYoKXt9ZnVuY3Rpb24gbSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiB5KCl7fWZ1bmN0aW9uIHgodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gRSh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBJKCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uIE4oKXtpZihJLmFwcGx5KHRoaXMpLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lbnN1cmVDYXBhY2l0eSh0Lmxlbmd0aCksdGhpcy5hZGQodCwhMCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZW5zdXJlQ2FwYWNpdHkoZS5sZW5ndGgpLHRoaXMuYWRkKGUsbil9fWZ1bmN0aW9uIEMoKXtpZih0aGlzLm1pbng9bnVsbCx0aGlzLm1heHg9bnVsbCx0aGlzLm1pbnk9bnVsbCx0aGlzLm1heHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC54LHQueCx0LnksdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdChlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChuLngsaS54LG4ueSxpLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTt0aGlzLmluaXQocixzLG8sYSl9fWZ1bmN0aW9uIFMoKXt9ZnVuY3Rpb24gdygpe1MuY2FsbCh0aGlzLFwiUHJvamVjdGl2ZSBwb2ludCBub3QgcmVwcmVzZW50YWJsZSBvbiB0aGUgQ2FydGVzaWFuIHBsYW5lLlwiKX1mdW5jdGlvbiBMKCl7fWZ1bmN0aW9uIFIodCxlKXtyZXR1cm4gdC5pbnRlcmZhY2VzXyYmdC5pbnRlcmZhY2VzXygpLmluZGV4T2YoZSk+LTF9ZnVuY3Rpb24gVCgpe31mdW5jdGlvbiBQKHQpe3RoaXMuc3RyPXR9ZnVuY3Rpb24gYih0KXt0aGlzLnZhbHVlPXR9ZnVuY3Rpb24gTygpe31mdW5jdGlvbiBfKCl7aWYodGhpcy5oaT0wLHRoaXMubG89MCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLmluaXQoMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaW5pdChlKX1lbHNlIGlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBuPWFyZ3VtZW50c1swXTtfLmNhbGwodGhpcyxfLnBhcnNlKG4pKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChpLHIpfX1mdW5jdGlvbiBNKCl7fWZ1bmN0aW9uIEQoKXt9ZnVuY3Rpb24gQSgpe31mdW5jdGlvbiBGKCl7aWYodGhpcy54PW51bGwsdGhpcy55PW51bGwsdGhpcy53PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy54PTAsdGhpcy55PTAsdGhpcy53PTE7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLnc9MX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy54PWUsdGhpcy55PW4sdGhpcy53PTF9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEYmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgRil7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3RoaXMueD1pLnkqci53LXIueSppLncsdGhpcy55PXIueCppLnctaS54KnIudyx0aGlzLnc9aS54KnIueS1yLngqaS55fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXTt0aGlzLng9cy55LW8ueSx0aGlzLnk9by54LXMueCx0aGlzLnc9cy54Km8ueS1vLngqcy55fX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl07dGhpcy54PWEsdGhpcy55PXUsdGhpcy53PWx9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGY9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdLHA9aC55LWMueSx2PWMueC1oLngsbT1oLngqYy55LWMueCpoLnkseT1mLnktZC55LHg9ZC54LWYueCxFPWYueCpkLnktZC54KmYueTt0aGlzLng9dipFLXgqbSx0aGlzLnk9eSptLXAqRSx0aGlzLnc9cCp4LXkqdn19ZnVuY3Rpb24gRygpe31mdW5jdGlvbiBxKCl7fWZ1bmN0aW9uIEIoKXt0aGlzLmVudmVsb3BlPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5TUklEPW51bGwsdGhpcy51c2VyRGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dCx0aGlzLlNSSUQ9dC5nZXRTUklEKCl9ZnVuY3Rpb24geigpe31mdW5jdGlvbiBWKCl7fWZ1bmN0aW9uIGsoKXt9ZnVuY3Rpb24gWSgpe31mdW5jdGlvbiBVKCl7fWZ1bmN0aW9uIFgoKXt9ZnVuY3Rpb24gSCgpe31mdW5jdGlvbiBXKCl7fWZ1bmN0aW9uIGooKXt9ZnVuY3Rpb24gSygpe31mdW5jdGlvbiBaKCl7fWZ1bmN0aW9uIFEoKXt9ZnVuY3Rpb24gSigpe3RoaXMuYXJyYXlfPVtdLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdiYmdGhpcy5hZGRBbGwoYXJndW1lbnRzWzBdKX1mdW5jdGlvbiAkKHQpe3JldHVybiBudWxsPT10PyRzOnQuY29sb3J9ZnVuY3Rpb24gdHQodCl7cmV0dXJuIG51bGw9PXQ/bnVsbDp0LnBhcmVudH1mdW5jdGlvbiBldCh0LGUpe251bGwhPT10JiYodC5jb2xvcj1lKX1mdW5jdGlvbiBudCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQubGVmdH1mdW5jdGlvbiBpdCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucmlnaHR9ZnVuY3Rpb24gcnQoKXt0aGlzLnJvb3RfPW51bGwsdGhpcy5zaXplXz0wfWZ1bmN0aW9uIHN0KCl7fWZ1bmN0aW9uIG90KCl7fWZ1bmN0aW9uIGF0KCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uIHV0KCl7fWZ1bmN0aW9uIGx0KCl7fWZ1bmN0aW9uIGh0KCl7fWZ1bmN0aW9uIGN0KCl7fWZ1bmN0aW9uIGZ0KCl7dGhpcy5nZW9tZXRyaWVzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKEIuY2FsbCh0aGlzLGUpLG51bGw9PT10JiYodD1bXSksQi5oYXNOdWxsRWxlbWVudHModCkpdGhyb3cgbmV3IGkoXCJnZW9tZXRyaWVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTt0aGlzLmdlb21ldHJpZXM9dH1mdW5jdGlvbiBndCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBkdCgpe2lmKHRoaXMuZ2VvbT1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLmJuUnVsZT1udWxsLHRoaXMuZW5kcG9pbnRNYXA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2R0LmNhbGwodGhpcyx0LFYuTU9EMl9CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5nZW9tPWUsdGhpcy5nZW9tRmFjdD1lLmdldEZhY3RvcnkoKSx0aGlzLmJuUnVsZT1ufX1mdW5jdGlvbiBwdCgpe3RoaXMuY291bnQ9bnVsbH1mdW5jdGlvbiB2dCgpe31mdW5jdGlvbiBtdCgpe31mdW5jdGlvbiB5dCgpe31mdW5jdGlvbiB4dCgpe31mdW5jdGlvbiBFdCgpe31mdW5jdGlvbiBJdCgpe31mdW5jdGlvbiBOdCgpe31mdW5jdGlvbiBDdCgpe31mdW5jdGlvbiBTdCgpe3RoaXMucG9pbnRzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0IuY2FsbCh0aGlzLGUpLHRoaXMuaW5pdCh0KX1mdW5jdGlvbiB3dCgpe31mdW5jdGlvbiBMdCgpe3RoaXMuY29vcmRpbmF0ZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Qi5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWZ1bmN0aW9uIFJ0KCl7fWZ1bmN0aW9uIFR0KCl7dGhpcy5zaGVsbD1udWxsLHRoaXMuaG9sZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYoQi5jYWxsKHRoaXMsbiksbnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcoKSksbnVsbD09PWUmJihlPVtdKSxCLmhhc051bGxFbGVtZW50cyhlKSl0aHJvdyBuZXcgaShcImhvbGVzIG11c3Qgbm90IGNvbnRhaW4gbnVsbCBlbGVtZW50c1wiKTtpZih0LmlzRW1wdHkoKSYmQi5oYXNOb25FbXB0eUVsZW1lbnRzKGUpKXRocm93IG5ldyBpKFwic2hlbGwgaXMgZW1wdHkgYnV0IGhvbGVzIGFyZSBub3RcIik7dGhpcy5zaGVsbD10LHRoaXMuaG9sZXM9ZX1mdW5jdGlvbiBQdCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBidCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpZSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2J0LmNhbGwodGhpcyxlLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCksZSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxEKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBpZSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO1N0LmNhbGwodGhpcyxuLGkpLHRoaXMudmFsaWRhdGVDb25zdHJ1Y3Rpb24oKX19ZnVuY3Rpb24gT3QoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZnQuY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gX3QoKXtpZih0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmlzVXNlckRhdGFDb3BpZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH19ZnVuY3Rpb24gTXQoKXt9ZnVuY3Rpb24gRHQoKXt9ZnVuY3Rpb24gQXQoKXt9ZnVuY3Rpb24gRnQoKXt9ZnVuY3Rpb24gR3QoKXtpZih0aGlzLmRpbWVuc2lvbj0zLHRoaXMuY29vcmRpbmF0ZXM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO0d0LmNhbGwodGhpcyx0LDMpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkoZSkuZmlsbChudWxsKTtmb3IodmFyIG49MDtlPm47bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09bmV3IGd9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGk9YXJndW1lbnRzWzBdO2lmKG51bGw9PT1pKXJldHVybiB0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7dGhpcy5kaW1lbnNpb249aS5nZXREaW1lbnNpb24oKSx0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShpLnNpemUoKSkuZmlsbChudWxsKTtmb3IodmFyIG49MDtuPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPWkuZ2V0Q29vcmRpbmF0ZUNvcHkobil9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07dGhpcy5jb29yZGluYXRlcz1yLHRoaXMuZGltZW5zaW9uPXMsbnVsbD09PXImJih0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKX1lbHNlIGlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMV0pKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV07dGhpcy5jb29yZGluYXRlcz1uZXcgQXJyYXkobykuZmlsbChudWxsKSx0aGlzLmRpbWVuc2lvbj1hO2Zvcih2YXIgbj0wO28+bjtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1uZXcgZ319ZnVuY3Rpb24gcXQoKXt9ZnVuY3Rpb24gQnQodCxlKXtyZXR1cm4gdD09PWV8fHQhPT10JiZlIT09ZX1mdW5jdGlvbiB6dCh0LGUpe2Z1bmN0aW9uIG4odCl7cmV0dXJuIHRoaXMmJnRoaXMuY29uc3RydWN0b3I9PT1uPyh0aGlzLl9rZXlzPVtdLHRoaXMuX3ZhbHVlcz1bXSx0aGlzLl9pdHA9W10sdGhpcy5vYmplY3RPbmx5PWUsdm9pZCh0JiZWdC5jYWxsKHRoaXMsdCkpKTpuZXcgbih0KX1yZXR1cm4gZXx8aW8odCxcInNpemVcIix7Z2V0Okp0fSksdC5jb25zdHJ1Y3Rvcj1uLG4ucHJvdG90eXBlPXQsbn1mdW5jdGlvbiBWdCh0KXt0aGlzLmFkZD90LmZvckVhY2godGhpcy5hZGQsdGhpcyk6dC5mb3JFYWNoKGZ1bmN0aW9uKHQpe3RoaXMuc2V0KHRbMF0sdFsxXSl9LHRoaXMpfWZ1bmN0aW9uIGt0KHQpe3JldHVybiB0aGlzLmhhcyh0KSYmKHRoaXMuX2tleXMuc3BsaWNlKG5vLDEpLHRoaXMuX3ZhbHVlcy5zcGxpY2Uobm8sMSksdGhpcy5faXRwLmZvckVhY2goZnVuY3Rpb24odCl7bm88dFswXSYmdFswXS0tfSkpLG5vPi0xfWZ1bmN0aW9uIFl0KHQpe3JldHVybiB0aGlzLmhhcyh0KT90aGlzLl92YWx1ZXNbbm9dOnZvaWQgMH1mdW5jdGlvbiBVdCh0LGUpe2lmKHRoaXMub2JqZWN0T25seSYmZSE9PU9iamVjdChlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCB2YWx1ZSB1c2VkIGFzIHdlYWsgY29sbGVjdGlvbiBrZXlcIik7aWYoZSE9PWV8fDA9PT1lKWZvcihubz10Lmxlbmd0aDtuby0tJiYhQnQodFtub10sZSk7KTtlbHNlIG5vPXQuaW5kZXhPZihlKTtyZXR1cm4gbm8+LTF9ZnVuY3Rpb24gWHQodCl7cmV0dXJuIFV0LmNhbGwodGhpcyx0aGlzLl9rZXlzLHQpfWZ1bmN0aW9uIEh0KHQsZSl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuX3ZhbHVlc1tub109ZTp0aGlzLl92YWx1ZXNbdGhpcy5fa2V5cy5wdXNoKHQpLTFdPWUsdGhpc31mdW5jdGlvbiBXdCgpeyh0aGlzLl9rZXlzfHwwKS5sZW5ndGg9dGhpcy5fdmFsdWVzLmxlbmd0aD0wfWZ1bmN0aW9uIGp0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl9rZXlzKX1mdW5jdGlvbiBLdCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fdmFsdWVzKX1mdW5jdGlvbiBadCgpe3JldHVybiBRdCh0aGlzLl9pdHAsdGhpcy5fa2V5cyx0aGlzLl92YWx1ZXMpfWZ1bmN0aW9uIFF0KHQsZSxuKXt2YXIgaT1bMF0scj0hMTtyZXR1cm4gdC5wdXNoKGkpLHtuZXh0OmZ1bmN0aW9uKCl7dmFyIHMsbz1pWzBdO3JldHVybiFyJiZvPGUubGVuZ3RoPyhzPW4/W2Vbb10sbltvXV06ZVtvXSxpWzBdKyspOihyPSEwLHQuc3BsaWNlKHQuaW5kZXhPZihpKSwxKSkse2RvbmU6cix2YWx1ZTpzfX19fWZ1bmN0aW9uIEp0KCl7cmV0dXJuIHRoaXMuX3ZhbHVlcy5sZW5ndGh9ZnVuY3Rpb24gJHQodCxlKXtmb3IodmFyIG49dGhpcy5lbnRyaWVzKCk7Oyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5kb25lKWJyZWFrO3QuY2FsbChlLGkudmFsdWVbMV0saS52YWx1ZVswXSx0aGlzKX19ZnVuY3Rpb24gdGUoKXt0aGlzLm1hcF89bmV3IHNvfWZ1bmN0aW9uIGVlKCl7aWYodGhpcy5tb2RlbFR5cGU9bnVsbCx0aGlzLnNjYWxlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5tb2RlbFR5cGU9ZWUuRkxPQVRJTkc7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG5lKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9dCx0PT09ZWUuRklYRUQmJnRoaXMuc2V0U2NhbGUoMSl9ZWxzZSBpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5tb2RlbFR5cGU9ZWUuRklYRUQsdGhpcy5zZXRTY2FsZShlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe3ZhciBuPWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT1uLm1vZGVsVHlwZSx0aGlzLnNjYWxlPW4uc2NhbGV9fWZ1bmN0aW9uIG5lKCl7dGhpcy5uYW1lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubmFtZT10LG5lLm5hbWVUb1R5cGVNYXAucHV0KHQsdGhpcyl9ZnVuY3Rpb24gaWUoKXtpZih0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW51bGwsdGhpcy5TUklEPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpaWUuY2FsbCh0aGlzLG5ldyBlZSwwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxHKSl7dmFyIHQ9YXJndW1lbnRzWzBdO2llLmNhbGwodGhpcyxuZXcgZWUsMCx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZWUpe3ZhciBlPWFyZ3VtZW50c1swXTtpZS5jYWxsKHRoaXMsZSwwLGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07aWUuY2FsbCh0aGlzLG4saSxpZS5nZXREZWZhdWx0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5wcmVjaXNpb25Nb2RlbD1yLHRoaXMuY29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeT1vLHRoaXMuU1JJRD1zfX1mdW5jdGlvbiByZSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWV9ZnVuY3Rpb24gc2UodCl7dGhpcy5wYXJzZXI9bmV3IHJlKHQpfWZ1bmN0aW9uIG9lKCl7dGhpcy5yZXN1bHQ9bnVsbCx0aGlzLmlucHV0TGluZXM9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgyKX0pLHRoaXMuaW50UHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5pbnRMaW5lSW5kZXg9bnVsbCx0aGlzLl9pc1Byb3Blcj1udWxsLHRoaXMucGE9bnVsbCx0aGlzLnBiPW51bGwsdGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuaW50UHRbMF09bmV3IGcsdGhpcy5pbnRQdFsxXT1uZXcgZyx0aGlzLnBhPXRoaXMuaW50UHRbMF0sdGhpcy5wYj10aGlzLmludFB0WzFdLHRoaXMucmVzdWx0PTB9ZnVuY3Rpb24gYWUoKXtvZS5hcHBseSh0aGlzKX1mdW5jdGlvbiB1ZSgpe31mdW5jdGlvbiBsZSgpe3RoaXMucD1udWxsLHRoaXMuY3Jvc3NpbmdDb3VudD0wLHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9ZnVuY3Rpb24gaGUoKXt9ZnVuY3Rpb24gY2UoKXtpZih0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKWNlLmNhbGwodGhpcyxuZXcgZyxuZXcgZyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2NlLmNhbGwodGhpcyx0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnAwPWUsdGhpcy5wMT1ufWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXTtjZS5jYWxsKHRoaXMsbmV3IGcoaSxyKSxuZXcgZyhzLG8pKX19ZnVuY3Rpb24gZmUoKXtpZih0aGlzLm1hdHJpeD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubWF0cml4PUFycmF5KDMpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMyl9KSx0aGlzLnNldEFsbChsdC5GQUxTRSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aClpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07ZmUuY2FsbCh0aGlzKSx0aGlzLnNldCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZmUpe3ZhciBlPWFyZ3VtZW50c1swXTtmZS5jYWxsKHRoaXMpLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPWUubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldPWUubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPWUubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdPWUubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldPWUubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPWUubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPWUubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPWUubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldLHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuRVhURVJJT1JdPWUubWF0cml4W0wuRVhURVJJT1JdW0wuRVhURVJJT1JdfX1mdW5jdGlvbiBnZSgpe3RoaXMuYXJlYUJhc2VQdD1udWxsLHRoaXMudHJpYW5nbGVDZW50Mz1uZXcgZyx0aGlzLmFyZWFzdW0yPTAsdGhpcy5jZzM9bmV3IGcsdGhpcy5saW5lQ2VudFN1bT1uZXcgZyx0aGlzLnRvdGFsTGVuZ3RoPTAsdGhpcy5wdENvdW50PTAsdGhpcy5wdENlbnRTdW09bmV3IGc7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJlYUJhc2VQdD1udWxsLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGRlKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIHBlKCl7dGhpcy5hcnJheV89W119ZnVuY3Rpb24gdmUoKXt0aGlzLnRyZWVTZXQ9bmV3IGF0LHRoaXMubGlzdD1uZXcgSX1mdW5jdGlvbiBtZSgpe2lmKHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbCx0aGlzLmlucHV0UHRzPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTttZS5jYWxsKHRoaXMsbWUuZXh0cmFjdENvb3JkaW5hdGVzKHQpLHQuZ2V0RmFjdG9yeSgpKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dFB0cz12ZS5maWx0ZXJDb29yZGluYXRlcyhlKSx0aGlzLmdlb21GYWN0b3J5PW59fWZ1bmN0aW9uIHllKCl7dGhpcy5vcmlnaW49bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5vcmlnaW49dH1mdW5jdGlvbiB4ZSgpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5wcnVuZUVtcHR5R2VvbWV0cnk9ITAsdGhpcy5wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU9ITAsdGhpcy5wcmVzZXJ2ZUNvbGxlY3Rpb25zPSExLHRoaXMucHJlc2VydmVUeXBlPSExfWZ1bmN0aW9uIEVlKCl7aWYodGhpcy5zbmFwVG9sZXJhbmNlPTAsdGhpcy5zcmNQdHM9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz0hMSx0aGlzLl9pc0Nsb3NlZD0hMSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07RWUuY2FsbCh0aGlzLHQuZ2V0Q29vcmRpbmF0ZXMoKSxlKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLnNyY1B0cz1uLHRoaXMuX2lzQ2xvc2VkPUVlLmlzQ2xvc2VkKG4pLHRoaXMuc25hcFRvbGVyYW5jZT1pfX1mdW5jdGlvbiBJZSgpe3RoaXMuc3JjR2VvbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNyY0dlb209dH1mdW5jdGlvbiBOZSgpe2lmKHhlLmFwcGx5KHRoaXMpLHRoaXMuc25hcFRvbGVyYW5jZT1udWxsLHRoaXMuc25hcFB0cz1udWxsLHRoaXMuaXNTZWxmU25hcD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc25hcFRvbGVyYW5jZT10LHRoaXMuc25hcFB0cz1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLnNuYXBUb2xlcmFuY2U9bix0aGlzLnNuYXBQdHM9aSx0aGlzLmlzU2VsZlNuYXA9cn19ZnVuY3Rpb24gQ2UoKXt0aGlzLmlzRmlyc3Q9ITAsdGhpcy5jb21tb25NYW50aXNzYUJpdHNDb3VudD01Myx0aGlzLmNvbW1vbkJpdHM9MCx0aGlzLmNvbW1vblNpZ25FeHA9bnVsbH1mdW5jdGlvbiBTZSgpe3RoaXMuY29tbW9uQ29vcmQ9bnVsbCx0aGlzLmNjRmlsdGVyPW5ldyB3ZX1mdW5jdGlvbiB3ZSgpe3RoaXMuY29tbW9uQml0c1g9bmV3IENlLHRoaXMuY29tbW9uQml0c1k9bmV3IENlfWZ1bmN0aW9uIExlKCl7dGhpcy50cmFucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRyYW5zPXR9ZnVuY3Rpb24gUmUoKXt0aGlzLnBhcmVudD1udWxsLHRoaXMuYXRTdGFydD1udWxsLHRoaXMubWF4PW51bGwsdGhpcy5pbmRleD1udWxsLHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucGFyZW50PXQsdGhpcy5hdFN0YXJ0PSEwLHRoaXMuaW5kZXg9MCx0aGlzLm1heD10LmdldE51bUdlb21ldHJpZXMoKX1mdW5jdGlvbiBUZSgpe2lmKHRoaXMuYm91bmRhcnlSdWxlPVYuT0dDX1NGU19CT1VOREFSWV9SVUxFLHRoaXMuaXNJbj1udWxsLHRoaXMubnVtQm91bmRhcmllcz1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07aWYobnVsbD09PXQpdGhyb3cgbmV3IGkoXCJSdWxlIG11c3QgYmUgbm9uLW51bGxcIik7dGhpcy5ib3VuZGFyeVJ1bGU9dH19ZnVuY3Rpb24gUGUoKXt9ZnVuY3Rpb24gYmUoKXt9ZnVuY3Rpb24gT2UoKXt0aGlzLnB0cz1udWxsLHRoaXMuZGF0YT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz10LHRoaXMuZGF0YT1lfWZ1bmN0aW9uIF9lKCl7fWZ1bmN0aW9uIE1lKCl7dGhpcy5ib3VuZHM9bnVsbCx0aGlzLml0ZW09bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5ib3VuZHM9dCx0aGlzLml0ZW09ZX1mdW5jdGlvbiBEZSgpe3RoaXMuX3NpemU9bnVsbCx0aGlzLml0ZW1zPW51bGwsdGhpcy5fc2l6ZT0wLHRoaXMuaXRlbXM9bmV3IEksdGhpcy5pdGVtcy5hZGQobnVsbCl9ZnVuY3Rpb24gQWUoKXt9ZnVuY3Rpb24gRmUoKXt9ZnVuY3Rpb24gR2UoKXtpZih0aGlzLmNoaWxkQm91bmRhYmxlcz1uZXcgSSx0aGlzLmJvdW5kcz1udWxsLHRoaXMubGV2ZWw9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGV2ZWw9dH19ZnVuY3Rpb24gcWUoKXt0aGlzLmJvdW5kYWJsZTE9bnVsbCx0aGlzLmJvdW5kYWJsZTI9bnVsbCx0aGlzLl9kaXN0YW5jZT1udWxsLHRoaXMuaXRlbURpc3RhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuYm91bmRhYmxlMT10LHRoaXMuYm91bmRhYmxlMj1lLHRoaXMuaXRlbURpc3RhbmNlPW4sdGhpcy5fZGlzdGFuY2U9dGhpcy5kaXN0YW5jZSgpfWZ1bmN0aW9uIEJlKCl7aWYodGhpcy5yb290PW51bGwsdGhpcy5idWlsdD0hMSx0aGlzLml0ZW1Cb3VuZGFibGVzPW5ldyBJLHRoaXMubm9kZUNhcGFjaXR5PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpQmUuY2FsbCh0aGlzLEJlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2YuaXNUcnVlKHQ+MSxcIk5vZGUgY2FwYWNpdHkgbXVzdCBiZSBncmVhdGVyIHRoYW4gMVwiKSx0aGlzLm5vZGVDYXBhY2l0eT10fX1mdW5jdGlvbiB6ZSgpe31mdW5jdGlvbiBWZSgpe31mdW5jdGlvbiBrZSgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWtlLmNhbGwodGhpcyxrZS5ERUZBVUxUX05PREVfQ0FQQUNJVFkpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtCZS5jYWxsKHRoaXMsdCl9fWZ1bmN0aW9uIFllKCl7dmFyIHQ9YXJndW1lbnRzWzBdO0dlLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBVZSgpe31mdW5jdGlvbiBYZSgpe3RoaXMuc2VnU3RyaW5nPW51bGwsdGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5zZWdtZW50T2N0YW50PW51bGwsdGhpcy5faXNJbnRlcmlvcj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLnNlZ1N0cmluZz10LHRoaXMuY29vcmQ9bmV3IGcoZSksdGhpcy5zZWdtZW50SW5kZXg9bix0aGlzLnNlZ21lbnRPY3RhbnQ9aSx0aGlzLl9pc0ludGVyaW9yPSFlLmVxdWFsczJEKHQuZ2V0Q29vcmRpbmF0ZShuKSl9ZnVuY3Rpb24gSGUoKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMuZWRnZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1mdW5jdGlvbiBXZSgpe3RoaXMubm9kZUxpc3Q9bnVsbCx0aGlzLmVkZ2U9bnVsbCx0aGlzLm5vZGVJdD1udWxsLHRoaXMuY3Vyck5vZGU9bnVsbCx0aGlzLm5leHROb2RlPW51bGwsdGhpcy5jdXJyU2VnSW5kZXg9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlTGlzdD10LHRoaXMuZWRnZT10LmdldEVkZ2UoKSx0aGlzLm5vZGVJdD10Lml0ZXJhdG9yKCksdGhpcy5yZWFkTmV4dE5vZGUoKX1mdW5jdGlvbiBqZSgpe31mdW5jdGlvbiBLZSgpe3RoaXMubm9kZUxpc3Q9bmV3IEhlKHRoaXMpLHRoaXMucHRzPW51bGwsdGhpcy5kYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5kYXRhPWV9ZnVuY3Rpb24gWmUoKXt0aGlzLnRlbXBFbnYxPW5ldyBDLHRoaXMudGVtcEVudjI9bmV3IEMsdGhpcy5vdmVybGFwU2VnMT1uZXcgY2UsdGhpcy5vdmVybGFwU2VnMj1uZXcgY2V9ZnVuY3Rpb24gUWUoKXt0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnQ9bnVsbCx0aGlzLmVuZD1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5jb250ZXh0PW51bGwsdGhpcy5pZD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLnB0cz10LHRoaXMuc3RhcnQ9ZSx0aGlzLmVuZD1uLHRoaXMuY29udGV4dD1pfWZ1bmN0aW9uIEplKCl7fWZ1bmN0aW9uICRlKCl7fWZ1bmN0aW9uIHRuKCl7fWZ1bmN0aW9uIGVuKCl7aWYodGhpcy5zZWdJbnQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0U2VnbWVudEludGVyc2VjdG9yKHQpfX1mdW5jdGlvbiBubigpe2lmKHRoaXMubW9ub0NoYWlucz1uZXcgSSx0aGlzLmluZGV4PW5ldyBrZSx0aGlzLmlkQ291bnRlcj0wLHRoaXMubm9kZWRTZWdTdHJpbmdzPW51bGwsdGhpcy5uT3ZlcmxhcHM9MCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2VuLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gcm4oKXtaZS5hcHBseSh0aGlzKSx0aGlzLnNpPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2k9dH1mdW5jdGlvbiBzbigpe2lmKHRoaXMucHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtsLmNhbGwodGhpcyxzbi5tc2dXaXRoQ29vcmQoZSxuKSksdGhpcy5wdD1uZXcgZyhuKX19ZnVuY3Rpb24gb24oKXt9ZnVuY3Rpb24gYW4oKXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT0hMSx0aGlzLmxpPW51bGwsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbj1udWxsLHRoaXMuaW50U2VnbWVudHM9bnVsbCx0aGlzLmludGVyc2VjdGlvbnM9bmV3IEksdGhpcy5pbnRlcnNlY3Rpb25Db3VudD0wLHRoaXMua2VlcEludGVyc2VjdGlvbnM9ITA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPW51bGx9ZnVuY3Rpb24gdW4oKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbCx0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPSExLHRoaXMuc2VnSW50PW51bGwsdGhpcy5faXNWYWxpZD0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gbG4oKXt0aGlzLm52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubnY9bmV3IHVuKGxuLnRvU2VnbWVudFN0cmluZ3ModCkpfWZ1bmN0aW9uIGhuKCl7dGhpcy5tYXBPcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1hcE9wPXR9ZnVuY3Rpb24gY24oKXt9ZnVuY3Rpb24gZm4oKXtpZih0aGlzLmxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5sZW5ndGgpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KDEpLHRoaXMubG9jYXRpb25bY24uT05dPWV9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZuKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5pbml0KG4ubG9jYXRpb24ubGVuZ3RoKSxudWxsIT09bilmb3IodmFyIGk9MDtpPHRoaXMubG9jYXRpb24ubGVuZ3RoO2krKyl0aGlzLmxvY2F0aW9uW2ldPW4ubG9jYXRpb25baV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLmluaXQoMyksdGhpcy5sb2NhdGlvbltjbi5PTl09cix0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPXMsdGhpcy5sb2NhdGlvbltjbi5SSUdIVF09b319ZnVuY3Rpb24gZ24oKXtpZih0aGlzLmVsdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lbHRbMF09bmV3IGZuKHQpLHRoaXMuZWx0WzFdPW5ldyBmbih0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ24pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgZm4oZS5lbHRbMF0pLHRoaXMuZWx0WzFdPW5ldyBmbihlLmVsdFsxXSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFsxXT1uZXcgZm4oTC5OT05FKSx0aGlzLmVsdFtuXS5zZXRMb2NhdGlvbihpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5lbHRbMF09bmV3IGZuKHIscyxvKSx0aGlzLmVsdFsxXT1uZXcgZm4ocixzLG8pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXSxoPWFyZ3VtZW50c1szXTt0aGlzLmVsdFswXT1uZXcgZm4oTC5OT05FLEwuTk9ORSxMLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBmbihMLk5PTkUsTC5OT05FLEwuTk9ORSksdGhpcy5lbHRbYV0uc2V0TG9jYXRpb25zKHUsbCxoKX19ZnVuY3Rpb24gZG4oKXt0aGlzLnN0YXJ0RGU9bnVsbCx0aGlzLm1heE5vZGVEZWdyZWU9LTEsdGhpcy5lZGdlcz1uZXcgSSx0aGlzLnB0cz1uZXcgSSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpLHRoaXMucmluZz1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLmhvbGVzPW5ldyBJLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5jb21wdXRlUG9pbnRzKHQpLHRoaXMuY29tcHV0ZVJpbmcoKX1mdW5jdGlvbiBwbigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiB2bigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtkbi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBtbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzQ292ZXJlZD0hMSx0aGlzLl9pc0NvdmVyZWRTZXQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sYWJlbD10fX1mdW5jdGlvbiB5bigpe21uLmFwcGx5KHRoaXMpLHRoaXMuY29vcmQ9bnVsbCx0aGlzLmVkZ2VzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuY29vcmQ9dCx0aGlzLmVkZ2VzPWUsdGhpcy5sYWJlbD1uZXcgZ24oMCxMLk5PTkUpfWZ1bmN0aW9uIHhuKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLm5vZGVGYWN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZUZhY3Q9dH1mdW5jdGlvbiBFbigpe2lmKHRoaXMuZWRnZT1udWxsLHRoaXMubGFiZWw9bnVsbCx0aGlzLm5vZGU9bnVsbCx0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMuZHg9bnVsbCx0aGlzLmR5PW51bGwsdGhpcy5xdWFkcmFudD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO0VuLmNhbGwodGhpcyxlLG4saSxudWxsKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM107RW4uY2FsbCh0aGlzLHIpLHRoaXMuaW5pdChzLG8pLHRoaXMubGFiZWw9YX19ZnVuY3Rpb24gSW4oKXt0aGlzLl9pc0ZvcndhcmQ9bnVsbCx0aGlzLl9pc0luUmVzdWx0PSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLnN5bT1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMubmV4dE1pbj1udWxsLHRoaXMuZWRnZVJpbmc9bnVsbCx0aGlzLm1pbkVkZ2VSaW5nPW51bGwsdGhpcy5kZXB0aD1bMCwtOTk5LC05OTldO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihFbi5jYWxsKHRoaXMsdCksdGhpcy5faXNGb3J3YXJkPWUsZSl0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKDApLHQuZ2V0Q29vcmRpbmF0ZSgxKSk7ZWxzZXt2YXIgbj10LmdldE51bVBvaW50cygpLTE7dGhpcy5pbml0KHQuZ2V0Q29vcmRpbmF0ZShuKSx0LmdldENvb3JkaW5hdGUobi0xKSl9dGhpcy5jb21wdXRlRGlyZWN0ZWRMYWJlbCgpfWZ1bmN0aW9uIE5uKCl7fWZ1bmN0aW9uIENuKCl7aWYodGhpcy5lZGdlcz1uZXcgSSx0aGlzLm5vZGVzPW51bGwsdGhpcy5lZGdlRW5kTGlzdD1uZXcgSSwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm5vZGVzPW5ldyB4bihuZXcgTm4pO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVzPW5ldyB4bih0KX19ZnVuY3Rpb24gU24oKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMuc2hlbGxMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fWZ1bmN0aW9uIHduKCl7dGhpcy5vcD1udWxsLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5wdExvY2F0b3I9bnVsbCx0aGlzLmxpbmVFZGdlc0xpc3Q9bmV3IEksdGhpcy5yZXN1bHRMaW5lTGlzdD1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWUsdGhpcy5wdExvY2F0b3I9bn1mdW5jdGlvbiBMbigpe3RoaXMub3A9bnVsbCx0aGlzLmdlb21ldHJ5RmFjdG9yeT1udWxsLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthcmd1bWVudHNbMl07dGhpcy5vcD10LHRoaXMuZ2VvbWV0cnlGYWN0b3J5PWV9ZnVuY3Rpb24gUm4oKXt9ZnVuY3Rpb24gVG4oKXt0aGlzLmdlb209bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5nZW9tPXR9ZnVuY3Rpb24gUG4oKXt0aGlzLmVkZ2VNYXA9bmV3IHJ0LHRoaXMuZWRnZUxpc3Q9bnVsbCx0aGlzLnB0SW5BcmVhTG9jYXRpb249W0wuTk9ORSxMLk5PTkVdfWZ1bmN0aW9uIGJuKCl7UG4uYXBwbHkodGhpcyksdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q9bnVsbCx0aGlzLmxhYmVsPW51bGwsdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc9MSx0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc9Mn1mdW5jdGlvbiBPbigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIF9uKCl7dGhpcy5tY2U9bnVsbCx0aGlzLmNoYWluSW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY2U9dCx0aGlzLmNoYWluSW5kZXg9ZX1mdW5jdGlvbiBNbigpe2lmKHRoaXMubGFiZWw9bnVsbCx0aGlzLnhWYWx1ZT1udWxsLHRoaXMuZXZlbnRUeXBlPW51bGwsdGhpcy5pbnNlcnRFdmVudD1udWxsLHRoaXMuZGVsZXRlRXZlbnRJbmRleD1udWxsLHRoaXMub2JqPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmV2ZW50VHlwZT1Nbi5ERUxFVEUsdGhpcy54VmFsdWU9dCx0aGlzLmluc2VydEV2ZW50PWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZXZlbnRUeXBlPU1uLklOU0VSVCx0aGlzLmxhYmVsPW4sdGhpcy54VmFsdWU9aSx0aGlzLm9iaj1yfX1mdW5jdGlvbiBEbigpe31mdW5jdGlvbiBBbigpe3RoaXMuX2hhc0ludGVyc2VjdGlvbj0hMSx0aGlzLmhhc1Byb3Blcj0hMSx0aGlzLmhhc1Byb3BlckludGVyaW9yPSExLHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5pbmNsdWRlUHJvcGVyPW51bGwsdGhpcy5yZWNvcmRJc29sYXRlZD1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1UZXN0cz0wLHRoaXMuYmR5Tm9kZXM9bnVsbCx0aGlzLl9pc0RvbmU9ITEsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50PSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmxpPXQsdGhpcy5pbmNsdWRlUHJvcGVyPWUsdGhpcy5yZWNvcmRJc29sYXRlZD1ufWZ1bmN0aW9uIEZuKCl7RG4uYXBwbHkodGhpcyksdGhpcy5ldmVudHM9bmV3IEksdGhpcy5uT3ZlcmxhcHM9bnVsbH1mdW5jdGlvbiBHbigpe3RoaXMubWluPXIuUE9TSVRJVkVfSU5GSU5JVFksdGhpcy5tYXg9ci5ORUdBVElWRV9JTkZJTklUWX1mdW5jdGlvbiBxbigpe31mdW5jdGlvbiBCbigpe0duLmFwcGx5KHRoaXMpLHRoaXMuaXRlbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLm1pbj10LHRoaXMubWF4PWUsdGhpcy5pdGVtPW59ZnVuY3Rpb24gem4oKXtHbi5hcHBseSh0aGlzKSx0aGlzLm5vZGUxPW51bGwsdGhpcy5ub2RlMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm5vZGUxPXQsdGhpcy5ub2RlMj1lLHRoaXMuYnVpbGRFeHRlbnQodGhpcy5ub2RlMSx0aGlzLm5vZGUyKX1mdW5jdGlvbiBWbigpe3RoaXMubGVhdmVzPW5ldyBJLHRoaXMucm9vdD1udWxsLHRoaXMubGV2ZWw9MH1mdW5jdGlvbiBrbigpe2lmKHRoaXMubGluZXM9bnVsbCx0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nPSExLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lcz10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmxpbmVzPWUsdGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz1ufX1mdW5jdGlvbiBZbigpe3RoaXMuaXRlbXM9bmV3IEl9ZnVuY3Rpb24gVW4oKXt0aGlzLmluZGV4PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKCFSKHQsUnQpKXRocm93IG5ldyBpKFwiQXJndW1lbnQgbXVzdCBiZSBQb2x5Z29uYWxcIik7dGhpcy5pbmRleD1uZXcgSG4odCl9ZnVuY3Rpb24gWG4oKXt0aGlzLmNvdW50ZXI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb3VudGVyPXR9ZnVuY3Rpb24gSG4oKXt0aGlzLmluZGV4PW5ldyBWbjt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWZ1bmN0aW9uIFduKCl7dGhpcy5jb29yZD1udWxsLHRoaXMuc2VnbWVudEluZGV4PW51bGwsdGhpcy5kaXN0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuY29vcmQ9bmV3IGcodCksdGhpcy5zZWdtZW50SW5kZXg9ZSx0aGlzLmRpc3Q9bn1mdW5jdGlvbiBqbigpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWZ1bmN0aW9uIEtuKCl7fWZ1bmN0aW9uIFpuKCl7dGhpcy5lPW51bGwsdGhpcy5wdHM9bnVsbCx0aGlzLnN0YXJ0SW5kZXg9bnVsbCx0aGlzLmVudjE9bmV3IEMsdGhpcy5lbnYyPW5ldyBDO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmU9dCx0aGlzLnB0cz10LmdldENvb3JkaW5hdGVzKCk7dmFyIGU9bmV3IEtuO3RoaXMuc3RhcnRJbmRleD1lLmdldENoYWluU3RhcnRJbmRpY2VzKHRoaXMucHRzKX1mdW5jdGlvbiBRbigpe3RoaXMuZGVwdGg9QXJyYXkoMikuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgzKX0pO2Zvcih2YXIgdD0wOzI+dDt0KyspZm9yKHZhciBlPTA7Mz5lO2UrKyl0aGlzLmRlcHRoW3RdW2VdPVFuLk5VTExfVkFMVUV9ZnVuY3Rpb24gSm4oKXtpZihtbi5hcHBseSh0aGlzKSx0aGlzLnB0cz1udWxsLHRoaXMuZW52PW51bGwsdGhpcy5laUxpc3Q9bmV3IGpuKHRoaXMpLHRoaXMubmFtZT1udWxsLHRoaXMubWNlPW51bGwsdGhpcy5faXNJc29sYXRlZD0hMCx0aGlzLmRlcHRoPW5ldyBRbix0aGlzLmRlcHRoRGVsdGE9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0puLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnB0cz1lLHRoaXMubGFiZWw9bn19ZnVuY3Rpb24gJG4oKXtpZihDbi5hcHBseSh0aGlzKSx0aGlzLnBhcmVudEdlb209bnVsbCx0aGlzLmxpbmVFZGdlTWFwPW5ldyB0ZSx0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGU9bnVsbCx0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITAsdGhpcy5hcmdJbmRleD1udWxsLHRoaXMuYm91bmRhcnlOb2Rlcz1udWxsLHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMSx0aGlzLmludmFsaWRQb2ludD1udWxsLHRoaXMuYXJlYVB0TG9jYXRvcj1udWxsLHRoaXMucHRMb2NhdG9yPW5ldyBUZSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdOyRuLmNhbGwodGhpcyx0LGUsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLmFyZ0luZGV4PW4sdGhpcy5wYXJlbnRHZW9tPWksdGhpcy5ib3VuZGFyeU5vZGVSdWxlPXIsbnVsbCE9PWkmJnRoaXMuYWRkKGkpfX1mdW5jdGlvbiB0aSgpe2lmKHRoaXMubGk9bmV3IGFlLHRoaXMucmVzdWx0UHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmFyZz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbih0LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuYXJnPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHRoaXMuYXJnWzBdPW5ldyAkbigwLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsZSxuLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aS5nZXRQcmVjaXNpb25Nb2RlbCgpLmNvbXBhcmVUbyhyLmdldFByZWNpc2lvbk1vZGVsKCkpPj0wP3RoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oaS5nZXRQcmVjaXNpb25Nb2RlbCgpKTp0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHIuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5hcmc9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5hcmdbMF09bmV3ICRuKDAsaSxzKSx0aGlzLmFyZ1sxXT1uZXcgJG4oMSxyLHMpfX1mdW5jdGlvbiBlaSgpe3RoaXMucHRzPW51bGwsdGhpcy5fb3JpZW50YXRpb249bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dCx0aGlzLl9vcmllbnRhdGlvbj1laS5vcmllbnRhdGlvbih0KX1mdW5jdGlvbiBuaSgpe3RoaXMuZWRnZXM9bmV3IEksdGhpcy5vY2FNYXA9bmV3IHJ0fWZ1bmN0aW9uIGlpKCl7dGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLnJlc3VsdEdlb209bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmksdGhpcy5yZXN1bHRQb2x5TGlzdD1uZXcgSSx0aGlzLnJlc3VsdExpbmVMaXN0PW5ldyBJLHRoaXMucmVzdWx0UG9pbnRMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLmdyYXBoPW5ldyBDbihuZXcgT24pLHRoaXMuZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCl9ZnVuY3Rpb24gcmkoKXt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5jYnI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tWzBdPXQsdGhpcy5nZW9tWzFdPWUsdGhpcy5jb21wdXRlU25hcFRvbGVyYW5jZSgpfWZ1bmN0aW9uIHNpKCl7dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21bMF09dCx0aGlzLmdlb21bMV09ZX1mdW5jdGlvbiBvaSgpe3RoaXMuZmFjdG9yeT1udWxsLHRoaXMuaW50ZXJpb3JQb2ludD1udWxsLHRoaXMubWF4V2lkdGg9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGFpKCl7dGhpcy5wb2x5PW51bGwsdGhpcy5jZW50cmVZPW51bGwsdGhpcy5oaVk9ci5NQVhfVkFMVUUsdGhpcy5sb1k9LXIuTUFYX1ZBTFVFO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBvbHk9dCx0aGlzLmhpWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNYXhZKCksdGhpcy5sb1k9dC5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0TWluWSgpLHRoaXMuY2VudHJlWT1vaS5hdmcodGhpcy5sb1ksdGhpcy5oaVkpfWZ1bmN0aW9uIHVpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZEludGVyaW9yKHQpLG51bGw9PT10aGlzLmludGVyaW9yUG9pbnQmJnRoaXMuYWRkRW5kcG9pbnRzKHQpfWZ1bmN0aW9uIGxpKCl7dGhpcy5jZW50cm9pZD1udWxsLHRoaXMubWluRGlzdGFuY2U9ci5NQVhfVkFMVUUsdGhpcy5pbnRlcmlvclBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2VudHJvaWQ9dC5nZXRDZW50cm9pZCgpLmdldENvb3JkaW5hdGUoKSx0aGlzLmFkZCh0KX1mdW5jdGlvbiBoaSgpe31mdW5jdGlvbiBjaSgpe3RoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5wMj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMucDI9bn1mdW5jdGlvbiBmaSgpe3RoaXMuaW5wdXQ9bnVsbCx0aGlzLmV4dHJlbWFsUHRzPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLnJhZGl1cz0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0PXR9ZnVuY3Rpb24gZ2koKXtpZih0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuaXNDb252ZXg9bnVsbCx0aGlzLmNvbnZleEh1bGxQdHM9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bmV3IGNlLHRoaXMubWluV2lkdGhQdD1udWxsLHRoaXMubWluUHRJbmRleD1udWxsLHRoaXMubWluV2lkdGg9MCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2dpLmNhbGwodGhpcyx0LCExKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEdlb209ZSx0aGlzLmlzQ29udmV4PW59fWZ1bmN0aW9uIGRpKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gcGkoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH1mdW5jdGlvbiB2aSgpe3RoaXMuX29yaWc9bnVsbCx0aGlzLl9zeW09bnVsbCx0aGlzLl9uZXh0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuX29yaWc9dH1mdW5jdGlvbiBtaSgpe3RoaXMuX2lzTWFya2VkPSExO3ZhciB0PWFyZ3VtZW50c1swXTt2aS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24geWkoKXt0aGlzLnZlcnRleE1hcD1uZXcgdGV9ZnVuY3Rpb24geGkoKXt0aGlzLl9pc1N0YXJ0PSExO3ZhciB0PWFyZ3VtZW50c1swXTttaS5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gRWkoKXt5aS5hcHBseSh0aGlzKX1mdW5jdGlvbiBJaSgpe3RoaXMucmVzdWx0PW51bGwsdGhpcy5mYWN0b3J5PW51bGwsdGhpcy5ncmFwaD1udWxsLHRoaXMubGluZXM9bmV3IEksdGhpcy5ub2RlRWRnZVN0YWNrPW5ldyBwZSx0aGlzLnJpbmdTdGFydEVkZ2U9bnVsbCx0aGlzLmdyYXBoPW5ldyBFaX1mdW5jdGlvbiBOaSgpe3RoaXMuaXRlbXM9bmV3IEksdGhpcy5zdWJub2RlPW5ldyBBcnJheSg0KS5maWxsKG51bGwpfWZ1bmN0aW9uIENpKCl7fWZ1bmN0aW9uIFNpKHQsZSl7dmFyIG4saSxyLHMsbz17MzI6e2Q6MTI3LGM6MTI4LGI6MCxhOjB9LDY0OntkOjMyNzUyLGM6MCxiOjAsYTowfX0sYT17MzI6OCw2NDoxMX1bdF07aWYoc3x8KG49MD5lfHwwPjEvZSxpc0Zpbml0ZShlKXx8KHM9b1t0XSxuJiYocy5kKz0xPDx0LzQtMSksaT1NYXRoLnBvdygyLGEpLTEscj0wKSksIXMpe2ZvcihpPXszMjoxMjcsNjQ6MTAyM31bdF0scj1NYXRoLmFicyhlKTtyPj0yOylpKyssci89Mjtmb3IoOzE+ciYmaT4wOylpLS0scio9MjswPj1pJiYoci89MiksMzI9PT10JiZpPjI1NCYmKHM9e2Q6bj8yNTU6MTI3LGM6MTI4LGI6MCxhOjB9LGk9TWF0aC5wb3coMixhKS0xLHI9MCl9cmV0dXJuIGl9ZnVuY3Rpb24gd2koKXt0aGlzLnB0PW5ldyBnLHRoaXMubGV2ZWw9MCx0aGlzLmVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9ZnVuY3Rpb24gTGkoKXtOaS5hcHBseSh0aGlzKSx0aGlzLmVudj1udWxsLHRoaXMuY2VudHJleD1udWxsLHRoaXMuY2VudHJleT1udWxsLHRoaXMubGV2ZWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbnY9dCx0aGlzLmxldmVsPWUsdGhpcy5jZW50cmV4PSh0LmdldE1pblgoKSt0LmdldE1heFgoKSkvMix0aGlzLmNlbnRyZXk9KHQuZ2V0TWluWSgpK3QuZ2V0TWF4WSgpKS8yfWZ1bmN0aW9uIFJpKCl7fWZ1bmN0aW9uIFRpKCl7TmkuYXBwbHkodGhpcyl9ZnVuY3Rpb24gUGkoKXt0aGlzLnJvb3Q9bnVsbCx0aGlzLm1pbkV4dGVudD0xLHRoaXMucm9vdD1uZXcgVGl9ZnVuY3Rpb24gYmkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllfWZ1bmN0aW9uIE9pKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZSx0aGlzLnByZWNpc2lvbk1vZGVsPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCksdGhpcy5wYXJzZXI9bmV3IGJpKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBfaSgpe3RoaXMucGFyc2VyPW5ldyBiaSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24gTWkodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllLHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKSx0aGlzLnBhcnNlcj1uZXcgcmUodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIERpKHQpe3JldHVyblt0LngsdC55XX1mdW5jdGlvbiBBaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWV9ZnVuY3Rpb24gRmkoKXtpZih0aGlzLm5vZGVyPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMub2Zmc2V0WD1udWxsLHRoaXMub2Zmc2V0WT1udWxsLHRoaXMuaXNTY2FsZWQ9ITEsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtGaS5jYWxsKHRoaXMsdCxlLDAsMCl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXSxhcmd1bWVudHNbM107dGhpcy5ub2Rlcj1uLHRoaXMuc2NhbGVGYWN0b3I9aSx0aGlzLmlzU2NhbGVkPSF0aGlzLmlzSW50ZWdlclByZWNpc2lvbigpfX1mdW5jdGlvbiBHaSgpe2lmKHRoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3I9ITAsdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5pbnB1dEdlb209ZSx0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hbi5pc0luQm91bmRhcnkoMil9fWZ1bmN0aW9uIHFpKCl7dGhpcy5wdD1udWxsLHRoaXMuaXNDbG9zZWQ9bnVsbCx0aGlzLmRlZ3JlZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0PXQsdGhpcy5pc0Nsb3NlZD0hMSx0aGlzLmRlZ3JlZT0wfWZ1bmN0aW9uIEJpKCl7aWYodGhpcy5xdWFkcmFudFNlZ21lbnRzPUJpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMsdGhpcy5lbmRDYXBTdHlsZT1CaS5DQVBfUk9VTkQsdGhpcy5qb2luU3R5bGU9QmkuSk9JTl9ST1VORCx0aGlzLm1pdHJlTGltaXQ9QmkuREVGQVVMVF9NSVRSRV9MSU1JVCx0aGlzLl9pc1NpbmdsZVNpZGVkPSExLHRoaXMuc2ltcGxpZnlGYWN0b3I9QmkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1IsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHModCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhlKSx0aGlzLnNldEVuZENhcFN0eWxlKG4pfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXTt0aGlzLnNldFF1YWRyYW50U2VnbWVudHMoaSksdGhpcy5zZXRFbmRDYXBTdHlsZShyKSx0aGlzLnNldEpvaW5TdHlsZShzKSx0aGlzLnNldE1pdHJlTGltaXQobyl9fWZ1bmN0aW9uIHppKCl7dGhpcy5taW5JbmRleD0tMSx0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5taW5EZT1udWxsLHRoaXMub3JpZW50ZWREZT1udWxsfWZ1bmN0aW9uIFZpKCl7dGhpcy5hcnJheV89W119ZnVuY3Rpb24ga2koKXt0aGlzLmZpbmRlcj1udWxsLHRoaXMuZGlyRWRnZUxpc3Q9bmV3IEksdGhpcy5ub2Rlcz1uZXcgSSx0aGlzLnJpZ2h0TW9zdENvb3JkPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmZpbmRlcj1uZXcgeml9ZnVuY3Rpb24gWWkoKXt0aGlzLmlucHV0TGluZT1udWxsLFxudGhpcy5kaXN0YW5jZVRvbD1udWxsLHRoaXMuaXNEZWxldGVkPW51bGwsdGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNPVU5URVJDTE9DS1dJU0U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRMaW5lPXR9ZnVuY3Rpb24gVWkoKXt0aGlzLnB0TGlzdD1udWxsLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZT0wLHRoaXMucHRMaXN0PW5ldyBJfWZ1bmN0aW9uIFhpKCl7dGhpcy5tYXhDdXJ2ZVNlZ21lbnRFcnJvcj0wLHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtPW51bGwsdGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPTEsdGhpcy5zZWdMaXN0PW51bGwsdGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsLHRoaXMubGk9bnVsbCx0aGlzLnMwPW51bGwsdGhpcy5zMT1udWxsLHRoaXMuczI9bnVsbCx0aGlzLnNlZzA9bmV3IGNlLHRoaXMuc2VnMT1uZXcgY2UsdGhpcy5vZmZzZXQwPW5ldyBjZSx0aGlzLm9mZnNldDE9bmV3IGNlLHRoaXMuc2lkZT0wLHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5wcmVjaXNpb25Nb2RlbD10LHRoaXMuYnVmUGFyYW1zPWUsdGhpcy5saT1uZXcgYWUsdGhpcy5maWxsZXRBbmdsZVF1YW50dW09TWF0aC5QSS8yL2UuZ2V0UXVhZHJhbnRTZWdtZW50cygpLGUuZ2V0UXVhZHJhbnRTZWdtZW50cygpPj04JiZlLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9ST1VORCYmKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj1YaS5NQVhfQ0xPU0lOR19TRUdfTEVOX0ZBQ1RPUiksdGhpcy5pbml0KG4pfWZ1bmN0aW9uIEhpKCl7dGhpcy5kaXN0YW5jZT0wLHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnByZWNpc2lvbk1vZGVsPXQsdGhpcy5idWZQYXJhbXM9ZX1mdW5jdGlvbiBXaSgpe3RoaXMuc3ViZ3JhcGhzPW51bGwsdGhpcy5zZWc9bmV3IGNlLHRoaXMuY2dhPW5ldyBoZTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJncmFwaHM9dH1mdW5jdGlvbiBqaSgpe3RoaXMudXB3YXJkU2VnPW51bGwsdGhpcy5sZWZ0RGVwdGg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy51cHdhcmRTZWc9bmV3IGNlKHQpLHRoaXMubGVmdERlcHRoPWV9ZnVuY3Rpb24gS2koKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2U9bnVsbCx0aGlzLmN1cnZlQnVpbGRlcj1udWxsLHRoaXMuY3VydmVMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmlucHV0R2VvbT10LHRoaXMuZGlzdGFuY2U9ZSx0aGlzLmN1cnZlQnVpbGRlcj1ufWZ1bmN0aW9uIFppKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuaGFzUHJvcGVyPSExLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5oYXNJbnRlcmlvcj0hMSx0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PW51bGwsdGhpcy5saT1udWxsLHRoaXMuaXNTZWxmSW50ZXJzZWN0aW9uPW51bGwsdGhpcy5udW1JbnRlcnNlY3Rpb25zPTAsdGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVByb3BlckludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGk9dH1mdW5jdGlvbiBRaSgpe3RoaXMuYnVmUGFyYW1zPW51bGwsdGhpcy53b3JraW5nUHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLndvcmtpbmdOb2Rlcj1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5lZGdlTGlzdD1uZXcgbmk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVmUGFyYW1zPXR9ZnVuY3Rpb24gSmkoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLnNlZ1N0cmluZ3M9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZWdTdHJpbmdzPXR9ZnVuY3Rpb24gJGkoKXt0aGlzLmxpPW51bGwsdGhpcy5wdD1udWxsLHRoaXMub3JpZ2luYWxQdD1udWxsLHRoaXMucHRTY2FsZWQ9bnVsbCx0aGlzLnAwU2NhbGVkPW51bGwsdGhpcy5wMVNjYWxlZD1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm1pbng9bnVsbCx0aGlzLm1heHg9bnVsbCx0aGlzLm1pbnk9bnVsbCx0aGlzLm1heHk9bnVsbCx0aGlzLmNvcm5lcj1uZXcgQXJyYXkoNCkuZmlsbChudWxsKSx0aGlzLnNhZmVFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07aWYodGhpcy5vcmlnaW5hbFB0PXQsdGhpcy5wdD10LHRoaXMuc2NhbGVGYWN0b3I9ZSx0aGlzLmxpPW4sMD49ZSl0aHJvdyBuZXcgaShcIlNjYWxlIGZhY3RvciBtdXN0IGJlIG5vbi16ZXJvXCIpOzEhPT1lJiYodGhpcy5wdD1uZXcgZyh0aGlzLnNjYWxlKHQueCksdGhpcy5zY2FsZSh0LnkpKSx0aGlzLnAwU2NhbGVkPW5ldyBnLHRoaXMucDFTY2FsZWQ9bmV3IGcpLHRoaXMuaW5pdENvcm5lcnModGhpcy5wdCl9ZnVuY3Rpb24gdHIoKXt0aGlzLnRlbXBFbnYxPW5ldyBDLHRoaXMuc2VsZWN0ZWRTZWdtZW50PW5ldyBjZX1mdW5jdGlvbiBlcigpe3RoaXMuaW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbmRleD10fWZ1bmN0aW9uIG5yKCl7dHIuYXBwbHkodGhpcyksdGhpcy5ob3RQaXhlbD1udWxsLHRoaXMucGFyZW50RWRnZT1udWxsLHRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD1udWxsLHRoaXMuX2lzTm9kZUFkZGVkPSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLmhvdFBpeGVsPXQsdGhpcy5wYXJlbnRFZGdlPWUsdGhpcy5ob3RQaXhlbFZlcnRleEluZGV4PW59ZnVuY3Rpb24gaXIoKXt0aGlzLmxpPW51bGwsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saT10LHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zPW5ldyBJfWZ1bmN0aW9uIHJyKCl7dGhpcy5wbT1udWxsLHRoaXMubGk9bnVsbCx0aGlzLnNjYWxlRmFjdG9yPW51bGwsdGhpcy5ub2Rlcj1udWxsLHRoaXMucG9pbnRTbmFwcGVyPW51bGwsdGhpcy5ub2RlZFNlZ1N0cmluZ3M9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wbT10LHRoaXMubGk9bmV3IGFlLHRoaXMubGkuc2V0UHJlY2lzaW9uTW9kZWwodCksdGhpcy5zY2FsZUZhY3Rvcj10LmdldFNjYWxlKCl9ZnVuY3Rpb24gc3IoKXtpZih0aGlzLmFyZ0dlb209bnVsbCx0aGlzLmRpc3RhbmNlPW51bGwsdGhpcy5idWZQYXJhbXM9bmV3IEJpLHRoaXMucmVzdWx0R2VvbWV0cnk9bnVsbCx0aGlzLnNhdmVFeGNlcHRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJnR2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmFyZ0dlb209ZSx0aGlzLmJ1ZlBhcmFtcz1ufX1mdW5jdGlvbiBvcigpe3RoaXMuY29tcHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wcz10fWZ1bmN0aW9uIGFyKCl7aWYodGhpcy5jb21wb25lbnQ9bnVsbCx0aGlzLnNlZ0luZGV4PW51bGwsdGhpcy5wdD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YXIuY2FsbCh0aGlzLHQsYXIuSU5TSURFX0FSRUEsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuY29tcG9uZW50PW4sdGhpcy5zZWdJbmRleD1pLHRoaXMucHQ9cn19ZnVuY3Rpb24gdXIoKXt0aGlzLnB0cz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz10fWZ1bmN0aW9uIGxyKCl7dGhpcy5sb2NhdGlvbnM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sb2NhdGlvbnM9dH1mdW5jdGlvbiBocigpe2lmKHRoaXMuZ2VvbT1udWxsLHRoaXMudGVybWluYXRlRGlzdGFuY2U9MCx0aGlzLnB0TG9jYXRvcj1uZXcgVGUsdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uPW51bGwsdGhpcy5taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2hyLmNhbGwodGhpcyx0LGUsMCl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMuZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmdlb21bMF09bix0aGlzLmdlb21bMV09aSx0aGlzLnRlcm1pbmF0ZURpc3RhbmNlPXN9fWZ1bmN0aW9uIGNyKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5kaXJlY3RlZEVkZ2VzPW5ldyBJLHRoaXMuY29vcmRpbmF0ZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gZnIoKXt0aGlzLl9pc01hcmtlZD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsdGhpcy5kYXRhPW51bGx9ZnVuY3Rpb24gZ3IoKXtmci5hcHBseSh0aGlzKSx0aGlzLnBhcmVudEVkZ2U9bnVsbCx0aGlzLmZyb209bnVsbCx0aGlzLnRvPW51bGwsdGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnN5bT1udWxsLHRoaXMuZWRnZURpcmVjdGlvbj1udWxsLHRoaXMucXVhZHJhbnQ9bnVsbCx0aGlzLmFuZ2xlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuZnJvbT10LHRoaXMudG89ZSx0aGlzLmVkZ2VEaXJlY3Rpb249aSx0aGlzLnAwPXQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMucDE9bjt2YXIgcj10aGlzLnAxLngtdGhpcy5wMC54LHM9dGhpcy5wMS55LXRoaXMucDAueTt0aGlzLnF1YWRyYW50PUplLnF1YWRyYW50KHIscyksdGhpcy5hbmdsZT1NYXRoLmF0YW4yKHMscil9ZnVuY3Rpb24gZHIoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107Z3IuY2FsbCh0aGlzLHQsZSxuLGkpfWZ1bmN0aW9uIHByKCl7aWYoZnIuYXBwbHkodGhpcyksdGhpcy5kaXJFZGdlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnNldERpcmVjdGVkRWRnZXModCxlKX19ZnVuY3Rpb24gdnIoKXt0aGlzLm91dEVkZ2VzPW5ldyBJLHRoaXMuc29ydGVkPSExfWZ1bmN0aW9uIG1yKCl7aWYoZnIuYXBwbHkodGhpcyksdGhpcy5wdD1udWxsLHRoaXMuZGVTdGFyPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTttci5jYWxsKHRoaXMsdCxuZXcgdnIpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnB0PWUsdGhpcy5kZVN0YXI9bn19ZnVuY3Rpb24geXIoKXtwci5hcHBseSh0aGlzKSx0aGlzLmxpbmU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lPXR9ZnVuY3Rpb24geHIoKXt0aGlzLm5vZGVNYXA9bmV3IHJ0fWZ1bmN0aW9uIEVyKCl7dGhpcy5lZGdlcz1uZXcgSix0aGlzLmRpckVkZ2VzPW5ldyBKLHRoaXMubm9kZU1hcD1uZXcgeHJ9ZnVuY3Rpb24gSXIoKXtFci5hcHBseSh0aGlzKX1mdW5jdGlvbiBOcigpe3RoaXMuZ3JhcGg9bmV3IElyLHRoaXMubWVyZ2VkTGluZVN0cmluZ3M9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmVkZ2VTdHJpbmdzPW51bGx9ZnVuY3Rpb24gQ3IoKXt0aGlzLmVkZ2VSaW5nPW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5sYWJlbD0tMTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107Z3IuY2FsbCh0aGlzLHQsZSxuLGkpfWZ1bmN0aW9uIFNyKCl7cHIuYXBwbHkodGhpcyksdGhpcy5saW5lPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubGluZT10fWZ1bmN0aW9uIHdyKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5kZUxpc3Q9bmV3IEksdGhpcy5sb3dlc3RFZGdlPW51bGwsdGhpcy5yaW5nPW51bGwsdGhpcy5yaW5nUHRzPW51bGwsdGhpcy5ob2xlcz1udWxsLHRoaXMuc2hlbGw9bnVsbCx0aGlzLl9pc0hvbGU9bnVsbCx0aGlzLl9pc1Byb2Nlc3NlZD0hMSx0aGlzLl9pc0luY2x1ZGVkU2V0PSExLHRoaXMuX2lzSW5jbHVkZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIExyKCl7fWZ1bmN0aW9uIFJyKCl7RXIuYXBwbHkodGhpcyksdGhpcy5mYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fWZ1bmN0aW9uIFRyKCl7aWYodGhpcy5saW5lU3RyaW5nQWRkZXI9bmV3IFByKHRoaXMpLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmRhbmdsZXM9bmV3IEksdGhpcy5jdXRFZGdlcz1uZXcgSSx0aGlzLmludmFsaWRSaW5nTGluZXM9bmV3IEksdGhpcy5ob2xlTGlzdD1udWxsLHRoaXMuc2hlbGxMaXN0PW51bGwsdGhpcy5wb2x5TGlzdD1udWxsLHRoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ9ITAsdGhpcy5leHRyYWN0T25seVBvbHlnb25hbD1udWxsLHRoaXMuZ2VvbUZhY3Rvcnk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClUci5jYWxsKHRoaXMsITEpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsPXR9fWZ1bmN0aW9uIFByKCl7dGhpcy5wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD10fWZ1bmN0aW9uIGJyKCl7fWZ1bmN0aW9uIE9yKCl7aWYodGhpcy5lZGdlRW5kcz1uZXcgSSwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO09yLmNhbGwodGhpcyxudWxsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPShhcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdKTtFbi5jYWxsKHRoaXMsZS5nZXRFZGdlKCksZS5nZXRDb29yZGluYXRlKCksZS5nZXREaXJlY3RlZENvb3JkaW5hdGUoKSxuZXcgZ24oZS5nZXRMYWJlbCgpKSksdGhpcy5pbnNlcnQoZSl9fWZ1bmN0aW9uIF9yKCl7UG4uYXBwbHkodGhpcyl9ZnVuY3Rpb24gTXIoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07eW4uY2FsbCh0aGlzLHQsZSl9ZnVuY3Rpb24gRHIoKXtObi5hcHBseSh0aGlzKX1mdW5jdGlvbiBBcigpe3RoaXMubGk9bmV3IGFlLHRoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLmFyZz1udWxsLHRoaXMubm9kZXM9bmV3IHhuKG5ldyBEciksdGhpcy5pbT1udWxsLHRoaXMuaXNvbGF0ZWRFZGdlcz1uZXcgSSx0aGlzLmludmFsaWRQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFyZz10fWZ1bmN0aW9uIEZyKCl7dGhpcy5yZWN0RW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1mdW5jdGlvbiBHcigpe3RoaXMubGk9bmV3IGFlLHRoaXMucmVjdEVudj1udWxsLHRoaXMuZGlhZ1VwMD1udWxsLHRoaXMuZGlhZ1VwMT1udWxsLHRoaXMuZGlhZ0Rvd24wPW51bGwsdGhpcy5kaWFnRG93bjE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQsdGhpcy5kaWFnVXAwPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSx0aGlzLmRpYWdVcDE9bmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLHRoaXMuZGlhZ0Rvd24wPW5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSx0aGlzLmRpYWdEb3duMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1pblkoKSl9ZnVuY3Rpb24gcXIoKXt0aGlzLl9pc0RvbmU9ITF9ZnVuY3Rpb24gQnIoKXt0aGlzLnJlY3RhbmdsZT1udWxsLHRoaXMucmVjdEVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RhbmdsZT10LHRoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKX1mdW5jdGlvbiB6cigpe3FyLmFwcGx5KHRoaXMpLHRoaXMucmVjdEVudj1udWxsLHRoaXMuX2ludGVyc2VjdHM9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10fWZ1bmN0aW9uIFZyKCl7cXIuYXBwbHkodGhpcyksdGhpcy5yZWN0U2VxPW51bGwsdGhpcy5yZWN0RW52PW51bGwsdGhpcy5fY29udGFpbnNQb2ludD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0U2VxPXQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIGtyKCl7cXIuYXBwbHkodGhpcyksdGhpcy5yZWN0RW52PW51bGwsdGhpcy5yZWN0SW50ZXJzZWN0b3I9bnVsbCx0aGlzLmhhc0ludGVyc2VjdGlvbj0hMSx0aGlzLnAwPW5ldyBnLHRoaXMucDE9bmV3IGc7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdEVudj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSx0aGlzLnJlY3RJbnRlcnNlY3Rvcj1uZXcgR3IodGhpcy5yZWN0RW52KX1mdW5jdGlvbiBZcigpe2lmKHRoaXMuX3JlbGF0ZT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGkuY2FsbCh0aGlzLHQsZSksdGhpcy5fcmVsYXRlPW5ldyBBcih0aGlzLmFyZyl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RpLmNhbGwodGhpcyxuLGksciksdGhpcy5fcmVsYXRlPW5ldyBBcih0aGlzLmFyZyl9fWZ1bmN0aW9uIFVyKCl7dGhpcy5nZW9tRmFjdG9yeT1udWxsLHRoaXMuc2tpcEVtcHR5PSExLHRoaXMuaW5wdXRHZW9tcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21GYWN0b3J5PVVyLmV4dHJhY3RGYWN0b3J5KHQpLHRoaXMuaW5wdXRHZW9tcz10fWZ1bmN0aW9uIFhyKCl7dGhpcy5wb2ludEdlb209bnVsbCx0aGlzLm90aGVyR2VvbT1udWxsLHRoaXMuZ2VvbUZhY3Q9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wb2ludEdlb209dCx0aGlzLm90aGVyR2VvbT1lLHRoaXMuZ2VvbUZhY3Q9ZS5nZXRGYWN0b3J5KCl9ZnVuY3Rpb24gSHIoKXt0aGlzLnNvcnRJbmRleD0tMSx0aGlzLmNvbXBzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc29ydEluZGV4PXQsdGhpcy5jb21wcz1lfWZ1bmN0aW9uIFdyKCl7dGhpcy5pbnB1dFBvbHlzPW51bGwsdGhpcy5nZW9tRmFjdG9yeT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0UG9seXM9dCxudWxsPT09dGhpcy5pbnB1dFBvbHlzJiYodGhpcy5pbnB1dFBvbHlzPW5ldyBJKX1mdW5jdGlvbiBqcigpe2lmKHRoaXMucG9seWdvbnM9bmV3IEksdGhpcy5saW5lcz1uZXcgSSx0aGlzLnBvaW50cz1uZXcgSSx0aGlzLmdlb21GYWN0PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5leHRyYWN0KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5nZW9tRmFjdD1pLHRoaXMuZXh0cmFjdChuKX19ZnVuY3Rpb24gS3IoKXt0aGlzLmdlb21ldHJ5RmFjdG9yeT1uZXcgaWUsdGhpcy5nZW9tR3JhcGg9bnVsbCx0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21HcmFwaD10fWZ1bmN0aW9uIFpyKCl7dGhpcy5pdGVtcz1uZXcgSSx0aGlzLnN1Ym5vZGU9W251bGwsbnVsbF19ZnVuY3Rpb24gUXIoKXtpZih0aGlzLm1pbj1udWxsLHRoaXMubWF4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5taW49MCx0aGlzLm1heD0wO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodC5taW4sdC5tYXgpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmluaXQoZSxuKX19ZnVuY3Rpb24gSnIoKXt0aGlzLnB0PTAsdGhpcy5sZXZlbD0wLHRoaXMuaW50ZXJ2YWw9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jb21wdXRlS2V5KHQpfWZ1bmN0aW9uICRyKCl7WnIuYXBwbHkodGhpcyksdGhpcy5pbnRlcnZhbD1udWxsLHRoaXMuY2VudHJlPW51bGwsdGhpcy5sZXZlbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmludGVydmFsPXQsdGhpcy5sZXZlbD1lLHRoaXMuY2VudHJlPSh0LmdldE1pbigpK3QuZ2V0TWF4KCkpLzJ9ZnVuY3Rpb24gdHMoKXtaci5hcHBseSh0aGlzKX1mdW5jdGlvbiBlcygpe3RoaXMucm9vdD1udWxsLHRoaXMubWluRXh0ZW50PTEsdGhpcy5yb290PW5ldyB0c31mdW5jdGlvbiBucygpe31mdW5jdGlvbiBpcygpe3RoaXMucmluZz1udWxsLHRoaXMudHJlZT1udWxsLHRoaXMuY3Jvc3NpbmdzPTAsdGhpcy5pbnRlcnZhbD1uZXcgUXI7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmluZz10LHRoaXMuYnVpbGRJbmRleCgpfWZ1bmN0aW9uIHJzKCl7dHIuYXBwbHkodGhpcyksdGhpcy5tY3A9bnVsbCx0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5tY3A9dCx0aGlzLnA9ZX1mdW5jdGlvbiBzcygpe3RoaXMubm9kZXM9bmV3IHhuKG5ldyBEcil9ZnVuY3Rpb24gb3MoKXt0aGlzLmxpPW5ldyBhZSx0aGlzLmdlb21HcmFwaD1udWxsLHRoaXMubm9kZUdyYXBoPW5ldyBzcyx0aGlzLmludmFsaWRQb2ludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb21HcmFwaD10fWZ1bmN0aW9uIGFzKCl7dGhpcy5ncmFwaD1udWxsLHRoaXMucmluZ3M9bmV3IEksdGhpcy50b3RhbEVudj1uZXcgQyx0aGlzLmluZGV4PW51bGwsdGhpcy5uZXN0ZWRQdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdyYXBoPXR9ZnVuY3Rpb24gdXMoKXtpZih0aGlzLmVycm9yVHlwZT1udWxsLHRoaXMucHQ9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3VzLmNhbGwodGhpcyx0LG51bGwpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVycm9yVHlwZT1lLG51bGwhPT1uJiYodGhpcy5wdD1uLmNvcHkoKSl9fWZ1bmN0aW9uIGxzKCl7dGhpcy5wYXJlbnRHZW9tZXRyeT1udWxsLHRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZD0hMSx0aGlzLnZhbGlkRXJyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucGFyZW50R2VvbWV0cnk9dH1mdW5jdGlvbiBocygpe190LkNvb3JkaW5hdGVPcGVyYXRpb24uYXBwbHkodGhpcyksdGhpcy50YXJnZXRQTT1udWxsLHRoaXMucmVtb3ZlQ29sbGFwc2VkPSEwO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnRhcmdldFBNPXQsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ZX1mdW5jdGlvbiBjcygpe3RoaXMudGFyZ2V0UE09bnVsbCx0aGlzLnJlbW92ZUNvbGxhcHNlZD0hMCx0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPSExLHRoaXMuaXNQb2ludHdpc2U9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudGFyZ2V0UE09dH1mdW5jdGlvbiBmcygpe3RoaXMucHRzPW51bGwsdGhpcy51c2VQdD1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLnNlZz1uZXcgY2U7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXR9ZnVuY3Rpb24gZ3MoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBkcygpe3hlLmFwcGx5KHRoaXMpLHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPWV9ZnVuY3Rpb24gcHMoKXtpZih0aGlzLnBhcmVudD1udWxsLHRoaXMuaW5kZXg9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3BzLmNhbGwodGhpcyx0LGUsbnVsbCwtMSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdLHM9YXJndW1lbnRzWzNdO2NlLmNhbGwodGhpcyxuLGkpLHRoaXMucGFyZW50PXIsdGhpcy5pbmRleD1zfX1mdW5jdGlvbiB2cygpe2lmKHRoaXMucGFyZW50TGluZT1udWxsLHRoaXMuc2Vncz1udWxsLHRoaXMucmVzdWx0U2Vncz1uZXcgSSx0aGlzLm1pbmltdW1TaXplPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt2cy5jYWxsKHRoaXMsdCwyKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wYXJlbnRMaW5lPWUsdGhpcy5taW5pbXVtU2l6ZT1uLHRoaXMuaW5pdCgpfX1mdW5jdGlvbiBtcygpe3RoaXMuaW5kZXg9bmV3IFBpfWZ1bmN0aW9uIHlzKCl7dGhpcy5xdWVyeVNlZz1udWxsLHRoaXMuaXRlbXM9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucXVlcnlTZWc9dH1mdW5jdGlvbiB4cygpe3RoaXMubGk9bmV3IGFlLHRoaXMuaW5wdXRJbmRleD1uZXcgbXMsdGhpcy5vdXRwdXRJbmRleD1uZXcgbXMsdGhpcy5saW5lPW51bGwsdGhpcy5saW5lUHRzPW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT0wO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0SW5kZXg9dCx0aGlzLm91dHB1dEluZGV4PWV9ZnVuY3Rpb24gRXMoKXt0aGlzLmlucHV0SW5kZXg9bmV3IG1zLHRoaXMub3V0cHV0SW5kZXg9bmV3IG1zLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9MH1mdW5jdGlvbiBJcygpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5saW5lU2ltcGxpZmllcj1uZXcgRXMsdGhpcy5saW5lc3RyaW5nTWFwPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRHZW9tPXR9ZnVuY3Rpb24gTnMoKXt4ZS5hcHBseSh0aGlzKSx0aGlzLmxpbmVzdHJpbmdNYXA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lc3RyaW5nTWFwPXR9ZnVuY3Rpb24gQ3MoKXt0aGlzLnRwcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRwcz10fWZ1bmN0aW9uIFNzKCl7dGhpcy5zZWc9bnVsbCx0aGlzLnNlZ0xlbj1udWxsLHRoaXMuc3BsaXRQdD1udWxsLHRoaXMubWluaW11bUxlbj0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNlZz10LHRoaXMuc2VnTGVuPXQuZ2V0TGVuZ3RoKCl9ZnVuY3Rpb24gd3MoKXt9ZnVuY3Rpb24gTHMoKXt9ZnVuY3Rpb24gUnMoKXt9ZnVuY3Rpb24gVHMoKXtpZih0aGlzLnA9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucD1uZXcgZyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wPW5ldyBnKGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMucD1uZXcgZyhpLHIscyl9fWZ1bmN0aW9uIFBzKCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9bnVsbCx0aGlzLmNvbnN0cmFpbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07VHMuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIGJzKCl7dGhpcy5fcm90PW51bGwsdGhpcy52ZXJ0ZXg9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLmRhdGE9bnVsbH1mdW5jdGlvbiBPcygpe3RoaXMuc3ViZGl2PW51bGwsdGhpcy5pc1VzaW5nVG9sZXJhbmNlPSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnN1YmRpdj10LHRoaXMuaXNVc2luZ1RvbGVyYW5jZT10LmdldFRvbGVyYW5jZSgpPjB9ZnVuY3Rpb24gX3MoKXt9ZnVuY3Rpb24gTXMoKXt0aGlzLnN1YmRpdj1udWxsLHRoaXMubGFzdEVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zdWJkaXY9dCx0aGlzLmluaXQoKX1mdW5jdGlvbiBEcygpe2lmKHRoaXMuc2VnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyx0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciBlPWFyZ3VtZW50c1swXTtsLmNhbGwodGhpcyxcIkxvY2F0ZSBmYWlsZWQgdG8gY29udmVyZ2UgKGF0IGVkZ2U6IFwiK2UrXCIpLiAgUG9zc2libGUgY2F1c2VzIGluY2x1ZGUgaW52YWxpZCBTdWJkaXZpc2lvbiB0b3BvbG9neSBvciB2ZXJ5IGNsb3NlIHNpdGVzXCIpLHRoaXMuc2VnPW5ldyBjZShlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2wuY2FsbCh0aGlzLERzLm1zZ1dpdGhTcGF0aWFsKG4saSkpLHRoaXMuc2VnPW5ldyBjZShpKX19ZnVuY3Rpb24gQXMoKXt9ZnVuY3Rpb24gRnMoKXt0aGlzLnZpc2l0ZWRLZXk9MCx0aGlzLnF1YWRFZGdlcz1uZXcgSSx0aGlzLnN0YXJ0aW5nRWRnZT1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2U9bnVsbCx0aGlzLmZyYW1lVmVydGV4PW5ldyBBcnJheSgzKS5maWxsKG51bGwpLHRoaXMuZnJhbWVFbnY9bnVsbCx0aGlzLmxvY2F0b3I9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy50cmlFZGdlcz1uZXcgQXJyYXkoMykuZmlsbChudWxsKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy50b2xlcmFuY2U9ZSx0aGlzLmVkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1lL0ZzLkVER0VfQ09JTkNJREVOQ0VfVE9MX0ZBQ1RPUix0aGlzLmNyZWF0ZUZyYW1lKHQpLHRoaXMuc3RhcnRpbmdFZGdlPXRoaXMuaW5pdFN1YmRpdigpLHRoaXMubG9jYXRvcj1uZXcgTXModGhpcyl9ZnVuY3Rpb24gR3MoKXt9ZnVuY3Rpb24gcXMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24gQnMoKXt0aGlzLnRyaUxpc3Q9bmV3IEl9ZnVuY3Rpb24genMoKXt0aGlzLmNvb3JkTGlzdD1uZXcgTix0aGlzLnRyaUNvb3Jkcz1uZXcgSX1mdW5jdGlvbiBWcygpe2lmKHRoaXMubHM9bnVsbCx0aGlzLmRhdGE9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubHM9bmV3IGNlKHQsZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMubHM9bmV3IGNlKG4saSksdGhpcy5kYXRhPXJ9ZWxzZSBpZig2PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9YXJndW1lbnRzWzJdLHU9YXJndW1lbnRzWzNdLGw9YXJndW1lbnRzWzRdLGg9YXJndW1lbnRzWzVdO1ZzLmNhbGwodGhpcyxuZXcgZyhzLG8sYSksbmV3IGcodSxsLGgpKX1lbHNlIGlmKDc9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZD1hcmd1bWVudHNbMl0scD1hcmd1bWVudHNbM10sdj1hcmd1bWVudHNbNF0sbT1hcmd1bWVudHNbNV0seT1hcmd1bWVudHNbNl07VnMuY2FsbCh0aGlzLG5ldyBnKGMsZixkKSxuZXcgZyhwLHYsbSkseSl9fWZ1bmN0aW9uIGtzKCl7fWZ1bmN0aW9uIFlzKCl7aWYodGhpcy5wPW51bGwsdGhpcy5kYXRhPW51bGwsdGhpcy5sZWZ0PW51bGwsdGhpcy5yaWdodD1udWxsLHRoaXMuY291bnQ9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucD1uZXcgZyh0KSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1lfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTt0aGlzLnA9bmV3IGcobixpKSx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD0xLHRoaXMuZGF0YT1yfX1mdW5jdGlvbiBVcygpe2lmKHRoaXMucm9vdD1udWxsLHRoaXMubnVtYmVyT2ZOb2Rlcz1udWxsLHRoaXMudG9sZXJhbmNlPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpVXMuY2FsbCh0aGlzLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnRvbGVyYW5jZT10fX1mdW5jdGlvbiBYcygpe3RoaXMudG9sZXJhbmNlPW51bGwsdGhpcy5tYXRjaE5vZGU9bnVsbCx0aGlzLm1hdGNoRGlzdD0wLHRoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnA9dCx0aGlzLnRvbGVyYW5jZT1lfWZ1bmN0aW9uIEhzKCl7dGhpcy5pbml0aWFsVmVydGljZXM9bnVsbCx0aGlzLnNlZ1ZlcnRpY2VzPW51bGwsdGhpcy5zZWdtZW50cz1uZXcgSSx0aGlzLnN1YmRpdj1udWxsLHRoaXMuaW5jRGVsPW51bGwsdGhpcy5jb252ZXhIdWxsPW51bGwsdGhpcy5zcGxpdEZpbmRlcj1uZXcgTHMsdGhpcy5rZHQ9bnVsbCx0aGlzLnZlcnRleEZhY3Rvcnk9bnVsbCx0aGlzLmNvbXB1dGVBcmVhRW52PW51bGwsdGhpcy5zcGxpdFB0PW51bGwsdGhpcy50b2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5pbml0aWFsVmVydGljZXM9bmV3IEkodCksdGhpcy50b2xlcmFuY2U9ZSx0aGlzLmtkdD1uZXcgVXMoZSl9ZnVuY3Rpb24gV3MoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGx9ZnVuY3Rpb24ganMoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLmNvbnN0cmFpbnRMaW5lcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbCx0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXA9bmV3IHJ0fWZ1bmN0aW9uIEtzKCl7dGhpcy5zaXRlQ29vcmRzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsLHRoaXMuY2xpcEVudj1udWxsLHRoaXMuZGlhZ3JhbUVudj1udWxsfWZ1bmN0aW9uIFpzKCl7fUFycmF5LnByb3RvdHlwZS5maWxsfHwoQXJyYXkucHJvdG90eXBlLmZpbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPU9iamVjdCh0aGlzKSxuPXBhcnNlSW50KGUubGVuZ3RoLDEwKSxpPWFyZ3VtZW50c1sxXSxyPXBhcnNlSW50KGksMTApfHwwLHM9MD5yP01hdGgubWF4KG4rciwwKTpNYXRoLm1pbihyLG4pLG89YXJndW1lbnRzWzJdLGE9dm9pZCAwPT09bz9uOnBhcnNlSW50KG8sMTApfHwwLHU9MD5hP01hdGgubWF4KG4rYSwwKTpNYXRoLm1pbihhLG4pO3U+cztzKyspZVtzXT10O3JldHVybiBlfSksTnVtYmVyLmlzRmluaXRlPU51bWJlci5pc0Zpbml0ZXx8ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpfSxOdW1iZXIuaXNJbnRlZ2VyPU51bWJlci5pc0ludGVnZXJ8fGZ1bmN0aW9uKHQpe3JldHVyblwibnVtYmVyXCI9PXR5cGVvZiB0JiZpc0Zpbml0ZSh0KSYmTWF0aC5mbG9vcih0KT09PXR9LE51bWJlci5wYXJzZUZsb2F0PU51bWJlci5wYXJzZUZsb2F0fHxwYXJzZUZsb2F0LE51bWJlci5pc05hTj1OdW1iZXIuaXNOYU58fGZ1bmN0aW9uKHQpe3JldHVybiB0IT09dH0sTWF0aC50cnVuYz1NYXRoLnRydW5jfHxmdW5jdGlvbih0KXtyZXR1cm4gMD50P01hdGguY2VpbCh0KTpNYXRoLmZsb29yKHQpfSxlKG4ucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBufX0pLG4uZXF1YWxzV2l0aFRvbGVyYW5jZT1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE1hdGguYWJzKHQtZSk8PW59LHIuaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIE51bWJlci5pc05hTih0KX0sci5kb3VibGVUb0xvbmdCaXRzPWZ1bmN0aW9uKHQpe3JldHVybiB0fSxyLmxvbmdCaXRzVG9Eb3VibGU9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIuaXNJbmZpbml0ZT1mdW5jdGlvbih0KXtyZXR1cm4hTnVtYmVyLmlzRmluaXRlKHQpfSxyLk1BWF9WQUxVRT1OdW1iZXIuTUFYX1ZBTFVFLGgoYyxsKSxlKGMucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjfX0pLGUoZi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ9fSksZi5zaG91bGROZXZlclJlYWNoSGVyZT1mdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUobnVsbCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3Rocm93IG5ldyBjKFwiU2hvdWxkIG5ldmVyIHJlYWNoIGhlcmVcIisobnVsbCE9PXQ/XCI6IFwiK3Q6XCJcIikpfX0sZi5pc1RydWU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2YuaXNUcnVlKHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKCFlKXRocm93IG51bGw9PT1uP25ldyBjOm5ldyBjKG4pfX0sZi5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2YuZXF1YWxzKHQsZSxudWxsKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07aWYoIWkuZXF1YWxzKG4pKXRocm93IG5ldyBjKFwiRXhwZWN0ZWQgXCIrbitcIiBidXQgZW5jb3VudGVyZWQgXCIraSsobnVsbCE9PXI/XCI6IFwiK3I6XCJcIikpfX0sZShnLnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godCl7Y2FzZSBnLlg6dGhpcy54PWU7YnJlYWs7Y2FzZSBnLlk6dGhpcy55PWU7YnJlYWs7Y2FzZSBnLlo6dGhpcy56PWU7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgaShcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfX0sZXF1YWxzMkQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnghPT10Lng/ITE6dGhpcy55PT09dC55fWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIG4uZXF1YWxzV2l0aFRvbGVyYW5jZSh0aGlzLngsZS54LGkpPyEhbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueSxlLnksaSk6ITF9fSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBnLlg6cmV0dXJuIHRoaXMueDtjYXNlIGcuWTpyZXR1cm4gdGhpcy55O2Nhc2UgZy5aOnJldHVybiB0aGlzLnp9dGhyb3cgbmV3IGkoXCJJbnZhbGlkIG9yZGluYXRlIGluZGV4OiBcIit0KX0sZXF1YWxzM0Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMueD09PXQueCYmdGhpcy55PT09dC55JiYodGhpcy56PT09dC56fHxyLmlzTmFOKHRoaXMueikmJnIuaXNOYU4odC56KSl9LGVxdWFsczpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIGc/dGhpcy5lcXVhbHMyRCh0KTohMX0sZXF1YWxJblo6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueix0LnosZSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLng8ZS54Py0xOnRoaXMueD5lLng/MTp0aGlzLnk8ZS55Py0xOnRoaXMueT5lLnk/MTowfSxjbG9uZTpmdW5jdGlvbigpe3RyeXt2YXIgdD1udWxsO3JldHVybiB0fWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gZi5zaG91bGROZXZlclJlYWNoSGVyZShcInRoaXMgc2hvdWxkbid0IGhhcHBlbiBiZWNhdXNlIHRoaXMgY2xhc3MgaXMgQ2xvbmVhYmxlXCIpLG51bGw7dGhyb3cgdH1maW5hbGx5e319LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcodGhpcyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCIoXCIrdGhpcy54K1wiLCBcIit0aGlzLnkrXCIsIFwiK3RoaXMueitcIilcIn0sZGlzdGFuY2UzRDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLngtdC54LG49dGhpcy55LXQueSxpPXRoaXMuei10Lno7cmV0dXJuIE1hdGguc3FydChlKmUrbipuK2kqaSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMueC10Lngsbj10aGlzLnktdC55O3JldHVybiBNYXRoLnNxcnQoZSplK24qbil9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9MTc7cmV0dXJuIHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMueCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy55KX0sc2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXt0aGlzLng9dC54LHRoaXMueT10LnksdGhpcy56PXQuen0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyxvLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnfX0pLGcuaGFzaENvZGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO3JldHVybiBNYXRoLnRydW5jKGVeZT4+PjMyKX19LGUoZC5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZSxyPWQuY29tcGFyZShuLngsaS54KTtpZigwIT09cilyZXR1cm4gcjt2YXIgcz1kLmNvbXBhcmUobi55LGkueSk7aWYoMCE9PXMpcmV0dXJuIHM7aWYodGhpcy5kaW1lbnNpb25zVG9UZXN0PD0yKXJldHVybiAwO3ZhciBvPWQuY29tcGFyZShuLnosaS56KTtyZXR1cm4gb30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGR9fSksZC5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+dD8tMTp0PmU/MTpyLmlzTmFOKHQpP3IuaXNOYU4oZSk/MDotMTpyLmlzTmFOKGUpPzE6MH0sZy5EaW1lbnNpb25hbENvbXBhcmF0b3I9ZCxnLnNlcmlhbFZlcnNpb25VSUQ9MHg1Y2JmMmMyMzVjN2U1ODAwLGcuTlVMTF9PUkRJTkFURT1yLk5hTixnLlg9MCxnLlk9MSxnLlo9MixwLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7fSxwLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmFkZD1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7fSxtLnByb3RvdHlwZT1uZXcgRXJyb3IsbS5wcm90b3R5cGUubmFtZT1cIkluZGV4T3V0T2ZCb3VuZHNFeGNlcHRpb25cIix5LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKHYucHJvdG90eXBlKSx5LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj15LHkucHJvdG90eXBlLmdldD1mdW5jdGlvbigpe30seS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7fSx4LnByb3RvdHlwZT1uZXcgRXJyb3IseC5wcm90b3R5cGUubmFtZT1cIk5vU3VjaEVsZW1lbnRFeGNlcHRpb25cIixFLnByb3RvdHlwZT1uZXcgRXJyb3IsRS5wcm90b3R5cGUubmFtZT1cIk9wZXJhdGlvbk5vdFN1cHBvcnRlZFwiLEkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUoeS5wcm90b3R5cGUpLEkucHJvdG90eXBlLmNvbnN0cnVjdG9yPUksSS5wcm90b3R5cGUuZW5zdXJlQ2FwYWNpdHk9ZnVuY3Rpb24oKXt9LEkucHJvdG90eXBlLmludGVyZmFjZXNfPWZ1bmN0aW9uKCl7cmV0dXJuW3ksdl19LEkucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0sSS5wcm90b3R5cGUuY2xlYXI9ZnVuY3Rpb24oKXt0aGlzLmFycmF5Xz1bXX0sSS5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSS5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hcnJheV9bdF07cmV0dXJuIHRoaXMuYXJyYXlfW3RdPWUsbn0sSS5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFFzKHRoaXMpfSxJLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgbTtyZXR1cm4gdGhpcy5hcnJheV9bdF19LEkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuYXJyYXlfLmxlbmd0aH0sSS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LEkucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sSS5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hMSxuPTAsaT10aGlzLmFycmF5Xy5sZW5ndGg7aT5uO24rKylpZih0aGlzLmFycmF5X1tuXT09PXQpe3RoaXMuYXJyYXlfLnNwbGljZShuLDEpLGU9ITA7YnJlYWt9cmV0dXJuIGV9O3ZhciBRcz1mdW5jdGlvbih0KXt0aGlzLmFycmF5TGlzdF89dCx0aGlzLnBvc2l0aW9uXz0wfTtRcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5hcnJheUxpc3RfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLmdldCh0aGlzLnBvc2l0aW9uXysrKX0sUXMucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy5hcnJheUxpc3RfLnNpemUoKX0sUXMucHJvdG90eXBlLnNldD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheUxpc3RfLnNldCh0aGlzLnBvc2l0aW9uXy0xLHQpfSxRcy5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LGgoTixJKSxlKE4ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldCh0KX0sYWRkQWxsOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj0hMSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspdGhpcy5hZGQoaS5uZXh0KCksZSksbj0hMDtyZXR1cm4gbn1yZXR1cm4gSS5wcm90b3R5cGUuYWRkQWxsLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY2xvbmU6ZnVuY3Rpb24gdCgpe2Zvcih2YXIgdD1JLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpLGU9MDtlPHRoaXMuc2l6ZSgpO2UrKyl0LmFkZChlLHRoaXMuZ2V0KGUpLmNvcHkoKSk7cmV0dXJuIHR9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9BcnJheShOLmNvb3JkQXJyYXlUeXBlKX0sYWRkOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtJLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKGUsbiwhMCksITB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO2lmKCFyJiZ0aGlzLnNpemUoKT49MSl7dmFyIHM9dGhpcy5nZXQodGhpcy5zaXplKCktMSk7aWYocy5lcXVhbHMyRChpKSlyZXR1cm4gbnVsbH1JLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYWRkKG8sYSksITB9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLGg9YXJndW1lbnRzWzJdO2lmKGgpZm9yKHZhciBjPTA7Yzx1Lmxlbmd0aDtjKyspdGhpcy5hZGQodVtjXSxsKTtlbHNlIGZvcih2YXIgYz11Lmxlbmd0aC0xO2M+PTA7Yy0tKXRoaXMuYWRkKHVbY10sbCk7cmV0dXJuITB9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgZj1hcmd1bWVudHNbMF0sZD1hcmd1bWVudHNbMV0scD1hcmd1bWVudHNbMl07aWYoIXApe3ZhciB2PXRoaXMuc2l6ZSgpO2lmKHY+MCl7aWYoZj4wKXt2YXIgbT10aGlzLmdldChmLTEpO2lmKG0uZXF1YWxzMkQoZCkpcmV0dXJuIG51bGx9aWYodj5mKXt2YXIgeT10aGlzLmdldChmKTtpZih5LmVxdWFsczJEKGQpKXJldHVybiBudWxsfX19SS5wcm90b3R5cGUuYWRkLmNhbGwodGhpcyxmLGQpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgeD1hcmd1bWVudHNbMF0sRT1hcmd1bWVudHNbMV0sTj1hcmd1bWVudHNbMl0sQz1hcmd1bWVudHNbM10sUz0xO04+QyYmKFM9LTEpO2Zvcih2YXIgYz1OO2MhPT1DO2MrPVMpdGhpcy5hZGQoeFtjXSxFKTtyZXR1cm4hMH19LGNsb3NlUmluZzpmdW5jdGlvbigpe3RoaXMuc2l6ZSgpPjAmJnRoaXMuYWRkKG5ldyBnKHRoaXMuZ2V0KDApKSwhMSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE59fSksTi5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxlKEMucHJvdG90eXBlLHtnZXRBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0V2lkdGgoKSp0aGlzLmdldEhlaWdodCgpfSxlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgQykpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5pc051bGwoKT9lLmlzTnVsbCgpOnRoaXMubWF4eD09PWUuZ2V0TWF4WCgpJiZ0aGlzLm1heHk9PT1lLmdldE1heFkoKSYmdGhpcy5taW54PT09ZS5nZXRNaW5YKCkmJnRoaXMubWlueT09PWUuZ2V0TWluWSgpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7aWYodGhpcy5pc051bGwoKXx8dC5pc051bGwoKXx8IXRoaXMuaW50ZXJzZWN0cyh0KSlyZXR1cm4gbmV3IEM7dmFyIGU9dGhpcy5taW54PnQubWlueD90aGlzLm1pbng6dC5taW54LG49dGhpcy5taW55PnQubWlueT90aGlzLm1pbnk6dC5taW55LGk9dGhpcy5tYXh4PHQubWF4eD90aGlzLm1heHg6dC5tYXh4LHI9dGhpcy5tYXh5PHQubWF4eT90aGlzLm1heHk6dC5tYXh5O3JldHVybiBuZXcgQyhlLGksbixyKX0saXNOdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eDx0aGlzLm1pbnh9LGdldE1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh4fSxjb3ZlcnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQueCx0LnkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTnVsbCgpfHxlLmlzTnVsbCgpPyExOmUuZ2V0TWluWCgpPj10aGlzLm1pbngmJmUuZ2V0TWF4WCgpPD10aGlzLm1heHgmJmUuZ2V0TWluWSgpPj10aGlzLm1pbnkmJmUuZ2V0TWF4WSgpPD10aGlzLm1heHl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc051bGwoKT8hMTpuPj10aGlzLm1pbngmJm48PXRoaXMubWF4eCYmaT49dGhpcy5taW55JiZpPD10aGlzLm1heHl9fSxpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpPyExOiEodC5taW54PnRoaXMubWF4eHx8dC5tYXh4PHRoaXMubWlueHx8dC5taW55PnRoaXMubWF4eXx8dC5tYXh5PHRoaXMubWlueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhlLngsZS55KX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzTnVsbCgpPyExOiEobj50aGlzLm1heHh8fG48dGhpcy5taW54fHxpPnRoaXMubWF4eXx8aTx0aGlzLm1pbnkpfX0sZ2V0TWluWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbnl9LGdldE1pblg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW54fSxleHBhbmRUb0luY2x1ZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5leHBhbmRUb0luY2x1ZGUodC54LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTtpZihlLmlzTnVsbCgpKXJldHVybiBudWxsO3RoaXMuaXNOdWxsKCk/KHRoaXMubWlueD1lLmdldE1pblgoKSx0aGlzLm1heHg9ZS5nZXRNYXhYKCksdGhpcy5taW55PWUuZ2V0TWluWSgpLHRoaXMubWF4eT1lLmdldE1heFkoKSk6KGUubWlueDx0aGlzLm1pbngmJih0aGlzLm1pbng9ZS5taW54KSxlLm1heHg+dGhpcy5tYXh4JiYodGhpcy5tYXh4PWUubWF4eCksZS5taW55PHRoaXMubWlueSYmKHRoaXMubWlueT1lLm1pbnkpLGUubWF4eT50aGlzLm1heHkmJih0aGlzLm1heHk9ZS5tYXh5KSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmlzTnVsbCgpPyh0aGlzLm1pbng9bix0aGlzLm1heHg9bix0aGlzLm1pbnk9aSx0aGlzLm1heHk9aSk6KG48dGhpcy5taW54JiYodGhpcy5taW54PW4pLG4+dGhpcy5tYXh4JiYodGhpcy5tYXh4PW4pLGk8dGhpcy5taW55JiYodGhpcy5taW55PWkpLGk+dGhpcy5tYXh5JiYodGhpcy5tYXh5PWkpKX19LG1pbkV4dGVudDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7dmFyIHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gZT50P3Q6ZX0sZ2V0V2lkdGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMubWF4eC10aGlzLm1pbnh9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk/MDotMTplLmlzTnVsbCgpPzE6dGhpcy5taW54PGUubWlueD8tMTp0aGlzLm1pbng+ZS5taW54PzE6dGhpcy5taW55PGUubWlueT8tMTp0aGlzLm1pbnk+ZS5taW55PzE6dGhpcy5tYXh4PGUubWF4eD8tMTp0aGlzLm1heHg+ZS5tYXh4PzE6dGhpcy5tYXh5PGUubWF4eT8tMTp0aGlzLm1heHk+ZS5tYXh5PzE6MH0sdHJhbnNsYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDp2b2lkIHRoaXMuaW5pdCh0aGlzLmdldE1pblgoKSt0LHRoaXMuZ2V0TWF4WCgpK3QsdGhpcy5nZXRNaW5ZKCkrZSx0aGlzLmdldE1heFkoKStlKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkVudltcIit0aGlzLm1pbngrXCIgOiBcIit0aGlzLm1heHgrXCIsIFwiK3RoaXMubWlueStcIiA6IFwiK3RoaXMubWF4eStcIl1cIn0sc2V0VG9OdWxsOmZ1bmN0aW9uKCl7dGhpcy5taW54PTAsdGhpcy5tYXh4PS0xLHRoaXMubWlueT0wLHRoaXMubWF4eT0tMX0sZ2V0SGVpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/MDp0aGlzLm1heHktdGhpcy5taW55fSxtYXhFeHRlbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTnVsbCgpKXJldHVybiAwO3ZhciB0PXRoaXMuZ2V0V2lkdGgoKSxlPXRoaXMuZ2V0SGVpZ2h0KCk7cmV0dXJuIHQ+ZT90OmV9LGV4cGFuZEJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZEJ5KHQsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5taW54LT1lLHRoaXMubWF4eCs9ZSx0aGlzLm1pbnktPW4sdGhpcy5tYXh5Kz1uLCh0aGlzLm1pbng+dGhpcy5tYXh4fHx0aGlzLm1pbnk+dGhpcy5tYXh5KSYmdGhpcy5zZXRUb051bGwoKX19LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnMoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb3ZlcnMobixpKX19LGNlbnRyZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpP251bGw6bmV3IGcoKHRoaXMuZ2V0TWluWCgpK3RoaXMuZ2V0TWF4WCgpKS8yLCh0aGlzLmdldE1pblkoKSt0aGlzLmdldE1heFkoKSkvMil9LGluaXQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnNldFRvTnVsbCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5taW54PWUubWlueCx0aGlzLm1heHg9ZS5tYXh4LHRoaXMubWlueT1lLm1pbnksdGhpcy5tYXh5PWUubWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaW5pdChuLngsaS54LG4ueSxpLnkpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTtzPnI/KHRoaXMubWlueD1yLHRoaXMubWF4eD1zKToodGhpcy5taW54PXMsdGhpcy5tYXh4PXIpLGE+bz8odGhpcy5taW55PW8sdGhpcy5tYXh5PWEpOih0aGlzLm1pbnk9YSx0aGlzLm1heHk9byl9fSxnZXRNYXhZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4eX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7aWYodGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiAwO3ZhciBlPTA7dGhpcy5tYXh4PHQubWlueD9lPXQubWlueC10aGlzLm1heHg6dGhpcy5taW54PnQubWF4eCYmKGU9dGhpcy5taW54LXQubWF4eCk7dmFyIG49MDtyZXR1cm4gdGhpcy5tYXh5PHQubWlueT9uPXQubWlueS10aGlzLm1heHk6dGhpcy5taW55PnQubWF4eSYmKG49dGhpcy5taW55LXQubWF4eSksMD09PWU/bjowPT09bj9lOk1hdGguc3FydChlKmUrbipuKX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy5taW54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1heHgpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWlueSksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5tYXh5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ319KSxDLmludGVyc2VjdHM9ZnVuY3Rpb24oKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBuLng+PSh0Lng8ZS54P3QueDplLngpJiZuLng8PSh0Lng+ZS54P3QueDplLngpJiZuLnk+PSh0Lnk8ZS55P3QueTplLnkpJiZuLnk8PSh0Lnk+ZS55P3QueTplLnkpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM10sYT1NYXRoLm1pbihzLngsby54KSx1PU1hdGgubWF4KHMueCxvLngpLGw9TWF0aC5taW4oaS54LHIueCksaD1NYXRoLm1heChpLngsci54KTtyZXR1cm4gbD51PyExOmE+aD8hMTooYT1NYXRoLm1pbihzLnksby55KSx1PU1hdGgubWF4KHMueSxvLnkpLGw9TWF0aC5taW4oaS55LHIueSksaD1NYXRoLm1heChpLnksci55KSxsPnU/ITE6IShhPmgpKX19LEMuc2VyaWFsVmVyc2lvblVJRD0weDUxODQ1Y2Q1NTIxODk4MDAsaCh3LFMpLGUody5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHd9fSksZShMLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTH19KSxMLnRvTG9jYXRpb25TeW1ib2w9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgTC5FWFRFUklPUjpyZXR1cm5cImVcIjtjYXNlIEwuQk9VTkRBUlk6cmV0dXJuXCJiXCI7Y2FzZSBMLklOVEVSSU9SOnJldHVyblwiaVwiO2Nhc2UgTC5OT05FOnJldHVyblwiLVwifXRocm93IG5ldyBpKFwiVW5rbm93biBsb2NhdGlvbiB2YWx1ZTogXCIrdCl9LEwuSU5URVJJT1I9MCxMLkJPVU5EQVJZPTEsTC5FWFRFUklPUj0yLEwuTk9ORT0tMSxlKFQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUfX0pLFQubG9nMTA9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5sb2codCk7cmV0dXJuIHIuaXNJbmZpbml0ZShlKT9lOnIuaXNOYU4oZSk/ZTplL1QuTE9HXzEwfSxULm1pbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10O3JldHVybiByPmUmJihyPWUpLHI+biYmKHI9bikscj5pJiYocj1pKSxyfSxULmNsYW1wPWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiBlPnQ/ZTp0Pm4/bjp0fWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtyZXR1cm4gcj5pP3I6aT5zP3M6aX19LFQud3JhcD1mdW5jdGlvbih0LGUpe3JldHVybiAwPnQ/ZS0gLXQlZTp0JWV9LFQubWF4PWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPXQ7cmV0dXJuIGU+aSYmKGk9ZSksbj5pJiYoaT1uKSxpfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10saT1yO3JldHVybiBzPmkmJihpPXMpLG8+aSYmKGk9byksYT5pJiYoaT1hKSxpfX0sVC5hdmVyYWdlPWZ1bmN0aW9uKHQsZSl7XG5yZXR1cm4odCtlKS8yfSxULkxPR18xMD1NYXRoLmxvZygxMCksUC5wcm90b3R5cGUuYXBwZW5kPWZ1bmN0aW9uKHQpe3RoaXMuc3RyKz10fSxQLnByb3RvdHlwZS5zZXRDaGFyQXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5zdHIuc3Vic3RyKDAsdCkrZSt0aGlzLnN0ci5zdWJzdHIodCsxKX0sUC5wcm90b3R5cGUudG9TdHJpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc3RyfSxiLnByb3RvdHlwZS5pbnRWYWx1ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxiLnByb3RvdHlwZS5jb21wYXJlVG89ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMudmFsdWU8dD8tMTp0aGlzLnZhbHVlPnQ/MTowfSxiLmlzTmFOPWZ1bmN0aW9uKHQpe3JldHVybiBOdW1iZXIuaXNOYU4odCl9LE8uaXNXaGl0ZXNwYWNlPWZ1bmN0aW9uKHQpe3JldHVybiAzMj49dCYmdD49MHx8MTI3PT10fSxPLnRvVXBwZXJDYXNlPWZ1bmN0aW9uKHQpe3JldHVybiB0LnRvVXBwZXJDYXNlKCl9LGUoXy5wcm90b3R5cGUse2xlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPHQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPD10LmxvfSxleHRyYWN0U2lnbmlmaWNhbnREaWdpdHM6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFicygpLGk9Xy5tYWduaXR1ZGUobi5oaSkscj1fLlRFTi5wb3coaSk7bj1uLmRpdmlkZShyKSxuLmd0KF8uVEVOKT8obj1uLmRpdmlkZShfLlRFTiksaSs9MSk6bi5sdChfLk9ORSkmJihuPW4ubXVsdGlwbHkoXy5URU4pLGktPTEpO2Zvcih2YXIgcz1pKzEsbz1uZXcgUCxhPV8uTUFYX1BSSU5UX0RJR0lUUy0xLHU9MDthPj11O3UrKyl7dCYmdT09PXMmJm8uYXBwZW5kKFwiLlwiKTt2YXIgbD1NYXRoLnRydW5jKG4uaGkpO2lmKDA+bClicmVhazt2YXIgaD0hMSxjPTA7bD45PyhoPSEwLGM9XCI5XCIpOmM9XCIwXCIrbCxvLmFwcGVuZChjKSxuPW4uc3VidHJhY3QoXy52YWx1ZU9mKGwpKS5tdWx0aXBseShfLlRFTiksaCYmbi5zZWxmQWRkKF8uVEVOKTt2YXIgZj0hMCxnPV8ubWFnbml0dWRlKG4uaGkpO2lmKDA+ZyYmTWF0aC5hYnMoZyk+PWEtdSYmKGY9ITEpLCFmKWJyZWFrfXJldHVybiBlWzBdPWksby50b1N0cmluZygpfSxzcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tdWx0aXBseSh0aGlzKX0sZG91YmxlVmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaSt0aGlzLmxvfSxzdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmFkZCh0Lm5lZ2F0ZSgpKX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKC1lKX19LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPT09dC5sb319LGlzWmVybzpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5oaSYmMD09PXRoaXMubG99LHNlbGZTdWJ0cmFjdDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLXQuaGksLXQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc05hTigpP3RoaXM6dGhpcy5zZWxmQWRkKC1lLDApfX0sZ2V0U3BlY2lhbE51bWJlclN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzWmVybygpP1wiMC4wXCI6dGhpcy5pc05hTigpP1wiTmFOIFwiOm51bGx9LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5sZSh0KT90aGlzOnR9LHNlbGZEaXZpZGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkRpdmlkZSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKGUsMCl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGwsdT1udWxsLGw9bnVsbCxoPW51bGwsYz1udWxsO3JldHVybiB1PXRoaXMuaGkvbixsPV8uU1BMSVQqdSxyPWwtdSxjPV8uU1BMSVQqbixyPWwtcixzPXUtcixvPWMtbixoPXUqbixvPWMtbyxhPW4tbyxjPXIqby1oK3IqYStzKm8rcyphLGw9KHRoaXMuaGktaC1jK3RoaXMubG8tdSppKS9uLGM9dStsLHRoaXMuaGk9Yyx0aGlzLmxvPXUtYytsLHRoaXN9fSxkdW1wOmZ1bmN0aW9uKCl7cmV0dXJuXCJERDxcIit0aGlzLmhpK1wiLCBcIit0aGlzLmxvK1wiPlwifSxkaXZpZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGwsbj1udWxsLGk9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO289dGhpcy5oaS90LmhpLGE9Xy5TUExJVCpvLGU9YS1vLGw9Xy5TUExJVCp0LmhpLGU9YS1lLG49by1lLGk9bC10LmhpLHU9byp0LmhpLGk9bC1pLHM9dC5oaS1pLGw9ZSppLXUrZSpzK24qaStuKnMsYT0odGhpcy5oaS11LWwrdGhpcy5sby1vKnQubG8pL3QuaGksbD1vK2E7dmFyIGg9bCxjPW8tbCthO3JldHVybiBuZXcgXyhoLGMpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBmPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihmKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmRGl2aWRlKGYsMCl9fSxnZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaT50LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbz49dC5sb30scG93OmZ1bmN0aW9uKHQpe2lmKDA9PT10KXJldHVybiBfLnZhbHVlT2YoMSk7dmFyIGU9bmV3IF8odGhpcyksbj1fLnZhbHVlT2YoMSksaT1NYXRoLmFicyh0KTtpZihpPjEpZm9yKDtpPjA7KWklMj09PTEmJm4uc2VsZk11bHRpcGx5KGUpLGkvPTIsaT4wJiYoZT1lLnNxcigpKTtlbHNlIG49ZTtyZXR1cm4gMD50P24ucmVjaXByb2NhbCgpOm59LGNlaWw6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIF8uTmFOO3ZhciB0PU1hdGguY2VpbCh0aGlzLmhpKSxlPTA7cmV0dXJuIHQ9PT10aGlzLmhpJiYoZT1NYXRoLmNlaWwodGhpcy5sbykpLG5ldyBfKHQsZSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmhpPGUuaGk/LTE6dGhpcy5oaT5lLmhpPzE6dGhpcy5sbzxlLmxvPy0xOnRoaXMubG8+ZS5sbz8xOjB9LHJpbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIHRoaXM7dmFyIHQ9dGhpcy5hZGQoLjUpO3JldHVybiB0LmZsb29yKCl9LHNldFZhbHVlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5pdCh0KSx0aGlzfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KGUpLHRoaXN9fSxtYXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2UodCk/dGhpczp0fSxzcXJ0OmZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gXy52YWx1ZU9mKDApO2lmKHRoaXMuaXNOZWdhdGl2ZSgpKXJldHVybiBfLk5hTjt2YXIgdD0xL01hdGguc3FydCh0aGlzLmhpKSxlPXRoaXMuaGkqdCxuPV8udmFsdWVPZihlKSxpPXRoaXMuc3VidHJhY3Qobi5zcXIoKSkscj1pLmhpKiguNSp0KTtyZXR1cm4gbi5hZGQocil9LHNlbGZBZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZkFkZCh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyZXR1cm4gcj10aGlzLmhpK2Usbz1yLXRoaXMuaGkscz1yLW8scz1lLW8rKHRoaXMuaGktcyksYT1zK3RoaXMubG8sbj1yK2EsaT1hKyhyLW4pLHRoaXMuaGk9bitpLHRoaXMubG89aSsobi10aGlzLmhpKSx0aGlzfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0sbj1udWxsLGk9bnVsbCxoPW51bGwsYz1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbDtyPXRoaXMuaGkrdSxoPXRoaXMubG8rbCxvPXItdGhpcy5oaSxhPWgtdGhpcy5sbyxzPXItbyxjPWgtYSxzPXUtbysodGhpcy5oaS1zKSxjPWwtYSsodGhpcy5sby1jKSxvPXMraCxuPXIrbyxpPW8rKHItbiksbz1jK2k7dmFyIGY9bitvLGc9bysobi1mKTtyZXR1cm4gdGhpcy5oaT1mLHRoaXMubG89Zyx0aGlzfX0sc2VsZk11bHRpcGx5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0LmhpLHQubG8pfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkoZSwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsO3U9Xy5TUExJVCp0aGlzLmhpLHI9dS10aGlzLmhpLGw9Xy5TUExJVCpuLHI9dS1yLHM9dGhpcy5oaS1yLG89bC1uLHU9dGhpcy5oaSpuLG89bC1vLGE9bi1vLGw9cipvLXUrciphK3MqbytzKmErKHRoaXMuaGkqaSt0aGlzLmxvKm4pO3ZhciBoPXUrbDtyPXUtaDt2YXIgYz1sK3I7cmV0dXJuIHRoaXMuaGk9aCx0aGlzLmxvPWMsdGhpc319LHNlbGZTcXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWxmTXVsdGlwbHkodGhpcyl9LGZsb29yOmZ1bmN0aW9uKCl7aWYodGhpcy5pc05hTigpKXJldHVybiBfLk5hTjt2YXIgdD1NYXRoLmZsb29yKHRoaXMuaGkpLGU9MDtyZXR1cm4gdD09PXRoaXMuaGkmJihlPU1hdGguZmxvb3IodGhpcy5sbykpLG5ldyBfKHQsZSl9LG5lZ2F0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczpuZXcgXygtdGhpcy5oaSwtdGhpcy5sbyl9LGNsb25lOmZ1bmN0aW9uKCl7dHJ5e3JldHVybiBudWxsfWNhdGNoKHQpe2lmKHQgaW5zdGFuY2VvZiBDbG9uZU5vdFN1cHBvcnRlZEV4Y2VwdGlvbilyZXR1cm4gbnVsbDt0aHJvdyB0fWZpbmFsbHl7fX0sbXVsdGlwbHk6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5pc05hTigpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZNdWx0aXBseSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHIuaXNOYU4oZSk/Xy5jcmVhdGVOYU4oKTpfLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KGUsMCl9fSxpc05hTjpmdW5jdGlvbigpe3JldHVybiByLmlzTmFOKHRoaXMuaGkpfSxpbnRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiBNYXRoLnRydW5jKHRoaXMuaGkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PV8ubWFnbml0dWRlKHRoaXMuaGkpO3JldHVybiB0Pj0tMyYmMjA+PXQ/dGhpcy50b1N0YW5kYXJkTm90YXRpb24oKTp0aGlzLnRvU2NpTm90YXRpb24oKX0sdG9TdGFuZGFyZE5vdGF0aW9uOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7dmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMCxlKSxpPWVbMF0rMSxyPW47aWYoXCIuXCI9PT1uLmNoYXJBdCgwKSlyPVwiMFwiK247ZWxzZSBpZigwPmkpcj1cIjAuXCIrXy5zdHJpbmdPZkNoYXIoXCIwXCIsLWkpK247ZWxzZSBpZigtMT09PW4uaW5kZXhPZihcIi5cIikpe3ZhciBzPWktbi5sZW5ndGgsbz1fLnN0cmluZ09mQ2hhcihcIjBcIixzKTtyPW4rbytcIi4wXCJ9cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3I6cn0scmVjaXByb2NhbDpmdW5jdGlvbigpe3ZhciB0PW51bGwsZT1udWxsLG49bnVsbCxpPW51bGwscj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsO3I9MS90aGlzLmhpLHM9Xy5TUExJVCpyLHQ9cy1yLGE9Xy5TUExJVCp0aGlzLmhpLHQ9cy10LGU9ci10LG49YS10aGlzLmhpLG89cip0aGlzLmhpLG49YS1uLGk9dGhpcy5oaS1uLGE9dCpuLW8rdCppK2UqbitlKmkscz0oMS1vLWEtcip0aGlzLmxvKS90aGlzLmhpO3ZhciB1PXIrcyxsPXItdStzO3JldHVybiBuZXcgXyh1LGwpfSx0b1NjaU5vdGF0aW9uOmZ1bmN0aW9uKCl7aWYodGhpcy5pc1plcm8oKSlyZXR1cm4gXy5TQ0lfTk9UX1pFUk87dmFyIHQ9dGhpcy5nZXRTcGVjaWFsTnVtYmVyU3RyaW5nKCk7aWYobnVsbCE9PXQpcmV0dXJuIHQ7dmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLmV4dHJhY3RTaWduaWZpY2FudERpZ2l0cyghMSxlKSxpPV8uU0NJX05PVF9FWFBPTkVOVF9DSEFSK2VbMF07aWYoXCIwXCI9PT1uLmNoYXJBdCgwKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRm91bmQgbGVhZGluZyB6ZXJvOiBcIituKTt2YXIgcj1cIlwiO24ubGVuZ3RoPjEmJihyPW4uc3Vic3RyaW5nKDEpKTt2YXIgcz1uLmNoYXJBdCgwKStcIi5cIityO3JldHVybiB0aGlzLmlzTmVnYXRpdmUoKT9cIi1cIitzK2k6cytpfSxhYnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc05hTigpP18uTmFOOnRoaXMuaXNOZWdhdGl2ZSgpP3RoaXMubmVnYXRlKCk6bmV3IF8odGhpcyl9LGlzUG9zaXRpdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaT4wfHwwPT09dGhpcy5oaSYmdGhpcy5sbz4wfSxsdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5oaTx0LmhpfHx0aGlzLmhpPT09dC5oaSYmdGhpcy5sbzx0LmxvfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gXy5jb3B5KHRoaXMpLnNlbGZBZGQodCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBfLmNvcHkodGhpcykuc2VsZkFkZChlKX19LGluaXQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaGk9dCx0aGlzLmxvPTB9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmhpPWUuaGksdGhpcy5sbz1lLmxvfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5oaT1uLHRoaXMubG89aX19LGd0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPnQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPnQubG99LGlzTmVnYXRpdmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaTwwfHwwPT09dGhpcy5oaSYmdGhpcy5sbzwwfSx0cnVuYzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/Xy5OYU46dGhpcy5pc1Bvc2l0aXZlKCk/dGhpcy5mbG9vcigpOnRoaXMuY2VpbCgpfSxzaWdudW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oaT4wPzE6dGhpcy5oaTwwPy0xOnRoaXMubG8+MD8xOnRoaXMubG88MD8tMTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1LHMsb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF99fSksXy5zcXI9ZnVuY3Rpb24odCl7cmV0dXJuIF8udmFsdWVPZih0KS5zZWxmTXVsdGlwbHkodCl9LF8udmFsdWVPZj1mdW5jdGlvbigpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gXy5wYXJzZSh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBfKGUpfX0sXy5zcXJ0PWZ1bmN0aW9uKHQpe3JldHVybiBfLnZhbHVlT2YodCkuc3FydCgpfSxfLnBhcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dC5sZW5ndGg7Ty5pc1doaXRlc3BhY2UodC5jaGFyQXQoZSkpOyllKys7dmFyIGk9ITE7aWYobj5lKXt2YXIgcj10LmNoYXJBdChlKTtcIi1cIiE9PXImJlwiK1wiIT09cnx8KGUrKyxcIi1cIj09PXImJihpPSEwKSl9Zm9yKHZhciBzPW5ldyBfLG89MCxhPTAsdT0wOzspe2lmKGU+PW4pYnJlYWs7dmFyIGw9dC5jaGFyQXQoZSk7aWYoZSsrLE8uaXNEaWdpdChsKSl7dmFyIGg9bC1cIjBcIjtzLnNlbGZNdWx0aXBseShfLlRFTikscy5zZWxmQWRkKGgpLG8rK31lbHNle2lmKFwiLlwiIT09bCl7aWYoXCJlXCI9PT1sfHxcIkVcIj09PWwpe3ZhciBjPXQuc3Vic3RyaW5nKGUpO3RyeXt1PWIucGFyc2VJbnQoYyl9Y2F0Y2goZSl7dGhyb3cgZSBpbnN0YW5jZW9mIE51bWJlckZvcm1hdEV4Y2VwdGlvbj9uZXcgTnVtYmVyRm9ybWF0RXhjZXB0aW9uKFwiSW52YWxpZCBleHBvbmVudCBcIitjK1wiIGluIHN0cmluZyBcIit0KTplfWZpbmFsbHl7fWJyZWFrfXRocm93IG5ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJVbmV4cGVjdGVkIGNoYXJhY3RlciAnXCIrbCtcIicgYXQgcG9zaXRpb24gXCIrZStcIiBpbiBzdHJpbmcgXCIrdCl9YT1vfX12YXIgZj1zLGc9by1hLXU7aWYoMD09PWcpZj1zO2Vsc2UgaWYoZz4wKXt2YXIgZD1fLlRFTi5wb3coZyk7Zj1zLmRpdmlkZShkKX1lbHNlIGlmKDA+Zyl7dmFyIGQ9Xy5URU4ucG93KC1nKTtmPXMubXVsdGlwbHkoZCl9cmV0dXJuIGk/Zi5uZWdhdGUoKTpmfSxfLmNyZWF0ZU5hTj1mdW5jdGlvbigpe3JldHVybiBuZXcgXyhyLk5hTixyLk5hTil9LF8uY29weT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IF8odCl9LF8ubWFnbml0dWRlPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguYWJzKHQpLG49TWF0aC5sb2coZSkvTWF0aC5sb2coMTApLGk9TWF0aC50cnVuYyhNYXRoLmZsb29yKG4pKSxyPU1hdGgucG93KDEwLGkpO3JldHVybiBlPj0xMCpyJiYoaSs9MSksaX0sXy5zdHJpbmdPZkNoYXI9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IFAsaT0wO2U+aTtpKyspbi5hcHBlbmQodCk7cmV0dXJuIG4udG9TdHJpbmcoKX0sXy5QST1uZXcgXygzLjE0MTU5MjY1MzU4OTc5MywxLjIyNDY0Njc5OTE0NzM1MzJlLTE2KSxfLlRXT19QST1uZXcgXyg2LjI4MzE4NTMwNzE3OTU4NiwyLjQ0OTI5MzU5ODI5NDcwNjRlLTE2KSxfLlBJXzI9bmV3IF8oMS41NzA3OTYzMjY3OTQ4OTY2LDYuMTIzMjMzOTk1NzM2NzY2ZS0xNyksXy5FPW5ldyBfKDIuNzE4MjgxODI4NDU5MDQ1LDEuNDQ1NjQ2ODkxNzI5MjUwMmUtMTYpLF8uTmFOPW5ldyBfKHIuTmFOLHIuTmFOKSxfLkVQUz0xLjIzMjU5NTE2NDQwNzgzZS0zMixfLlNQTElUPTEzNDIxNzcyOSxfLk1BWF9QUklOVF9ESUdJVFM9MzIsXy5URU49Xy52YWx1ZU9mKDEwKSxfLk9ORT1fLnZhbHVlT2YoMSksXy5TQ0lfTk9UX0VYUE9ORU5UX0NIQVI9XCJFXCIsXy5TQ0lfTk9UX1pFUk89XCIwLjBFMFwiLGUoTS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE19fSksTS5vcmllbnRhdGlvbkluZGV4PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1NLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXIodCxlLG4pO2lmKDE+PWkpcmV0dXJuIGk7dmFyIHI9Xy52YWx1ZU9mKGUueCkuc2VsZkFkZCgtdC54KSxzPV8udmFsdWVPZihlLnkpLnNlbGZBZGQoLXQueSksbz1fLnZhbHVlT2Yobi54KS5zZWxmQWRkKC1lLngpLGE9Xy52YWx1ZU9mKG4ueSkuc2VsZkFkZCgtZS55KTtyZXR1cm4gci5zZWxmTXVsdGlwbHkoYSkuc2VsZlN1YnRyYWN0KHMuc2VsZk11bHRpcGx5KG8pKS5zaWdudW0oKX0sTS5zaWduT2ZEZXQyeDI9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dC5tdWx0aXBseShpKS5zZWxmU3VidHJhY3QoZS5tdWx0aXBseShuKSk7cmV0dXJuIHIuc2lnbnVtKCl9LE0uaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KSkscz1fLnZhbHVlT2YoaS54KS5zZWxmU3VidHJhY3Qobi54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkpLG89ci5zdWJ0cmFjdChzKSxhPV8udmFsdWVPZihpLngpLnNlbGZTdWJ0cmFjdChuLngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qobi55KSksdT1fLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KG4ueCkpLGw9YS5zdWJ0cmFjdCh1KSxoPWwuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLGM9Xy52YWx1ZU9mKHQueCkuc2VsZkFkZChfLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoaCkpLmRvdWJsZVZhbHVlKCksZj1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KG4ueSkpLGQ9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChuLngpKSxwPWYuc3VidHJhY3QoZCksdj1wLnNlbGZEaXZpZGUobykuZG91YmxlVmFsdWUoKSxtPV8udmFsdWVPZihuLnkpLnNlbGZBZGQoXy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KHYpKS5kb3VibGVWYWx1ZSgpO3JldHVybiBuZXcgZyhjLG0pfSxNLm9yaWVudGF0aW9uSW5kZXhGaWx0ZXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW51bGwscj0odC54LW4ueCkqKGUueS1uLnkpLHM9KHQueS1uLnkpKihlLngtbi54KSxvPXItcztpZihyPjApe2lmKDA+PXMpcmV0dXJuIE0uc2lnbnVtKG8pO2k9citzfWVsc2V7aWYoISgwPnIpKXJldHVybiBNLnNpZ251bShvKTtpZihzPj0wKXJldHVybiBNLnNpZ251bShvKTtpPS1yLXN9dmFyIGE9TS5EUF9TQUZFX0VQU0lMT04qaTtyZXR1cm4gbz49YXx8LW8+PWE/TS5zaWdudW0obyk6Mn0sTS5zaWdudW09ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MD8xOjA+dD8tMTowfSxNLkRQX1NBRkVfRVBTSUxPTj0xZS0xNSxlKEQucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUsbil7fSxzaXplOmZ1bmN0aW9uKCl7fSxnZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGdldENvb3JkaW5hdGVDb3B5OmZ1bmN0aW9uKHQpe30sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7fSxnZXRYOmZ1bmN0aW9uKHQpe30sY2xvbmU6ZnVuY3Rpb24oKXt9LGV4cGFuZEVudmVsb3BlOmZ1bmN0aW9uKHQpe30sY29weTpmdW5jdGlvbigpe30sZ2V0WTpmdW5jdGlvbih0KXt9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRH19KSxELlg9MCxELlk9MSxELlo9MixELk09MyxBLmFycmF5Y29weT1mdW5jdGlvbih0LGUsbixpLHIpe2Zvcih2YXIgcz0wLG89ZTtlK3I+bztvKyspbltpK3NdPXRbb10scysrfSxBLmdldFByb3BlcnR5PWZ1bmN0aW9uKHQpe3JldHVybntcImxpbmUuc2VwYXJhdG9yXCI6XCJcXG5cIn1bdF19LGUoRi5wcm90b3R5cGUse2dldFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnkvdGhpcy53O2lmKHIuaXNOYU4odCl8fHIuaXNJbmZpbml0ZSh0KSl0aHJvdyBuZXcgdztyZXR1cm4gdH0sZ2V0WDpmdW5jdGlvbigpe3ZhciB0PXRoaXMueC90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB3O3JldHVybiB0fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGc7cmV0dXJuIHQueD10aGlzLmdldFgoKSx0Lnk9dGhpcy5nZXRZKCksdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRn19KSxGLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcz10LnktZS55LG89ZS54LXQueCxhPXQueCplLnktZS54KnQueSx1PW4ueS1pLnksbD1pLngtbi54LGg9bi54KmkueS1pLngqbi55LGM9bypoLWwqYSxmPXUqYS1zKmgsZD1zKmwtdSpvLHA9Yy9kLHY9Zi9kO2lmKHIuaXNOYU4ocCl8fHIuaXNJbmZpbml0ZShwKXx8ci5pc05hTih2KXx8ci5pc0luZmluaXRlKHYpKXRocm93IG5ldyB3O3JldHVybiBuZXcgZyhwLHYpfSxlKEcucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7YXJndW1lbnRzWzBdfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sRCkpe2FyZ3VtZW50c1swXX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEd9fSksZShxLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcX19KSxlKEIucHJvdG90eXBlLHtpc0dlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfSxnZXRGYWN0b3J5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeX0sZ2V0R2VvbWV0cnlOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzfSxnZXRBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGlzUmVjdGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGVxdWFsczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbnVsbD09PXQ/ITE6dGhpcy5lcXVhbHNUb3BvKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0KXt2YXIgZT1hcmd1bWVudHNbMF07aWYoIShlIGluc3RhbmNlb2YgQikpcmV0dXJuITE7dmFyIG49ZTtyZXR1cm4gdGhpcy5lcXVhbHNFeGFjdChuKX19fSxlcXVhbHNFeGFjdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcz09PXR8fHRoaXMuZXF1YWxzRXhhY3QodCwwKX0sZ2VvbWV0cnlDaGFuZ2VkOmZ1bmN0aW9uKCl7dGhpcy5hcHBseShCLmdlb21ldHJ5Q2hhbmdlZEZpbHRlcil9LGdlb21ldHJ5Q2hhbmdlZEFjdGlvbjpmdW5jdGlvbigpe3RoaXMuZW52ZWxvcGU9bnVsbH0sZXF1YWxzTm9ybTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXQ/ITE6dGhpcy5ub3JtKCkuZXF1YWxzRXhhY3QodC5ub3JtKCkpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiAxfSxjb21wYXJlVG86ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dDtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSE9PWUuZ2V0U29ydEluZGV4KCk/dGhpcy5nZXRTb3J0SW5kZXgoKS1lLmdldFNvcnRJbmRleCgpOnRoaXMuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOmUuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3ModCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW47cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCkhPT1lLmdldFNvcnRJbmRleCgpP3RoaXMuZ2V0U29ydEluZGV4KCktZS5nZXRTb3J0SW5kZXgoKTp0aGlzLmlzRW1wdHkoKSYmZS5pc0VtcHR5KCk/MDp0aGlzLmlzRW1wdHkoKT8tMTplLmlzRW1wdHkoKT8xOnRoaXMuY29tcGFyZVRvU2FtZUNsYXNzKG4saSl9fSxnZXRVc2VyRGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnVzZXJEYXRhfSxnZXRTUklEOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuU1JJRH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeSh0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9LGNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHQuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT04pdGhyb3cgbmV3IGkoXCJUaGlzIG1ldGhvZCBkb2VzIG5vdCBzdXBwb3J0IEdlb21ldHJ5Q29sbGVjdGlvbiBhcmd1bWVudHNcIil9LGVxdWFsOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gMD09PW4/dC5lcXVhbHMoZSk6dC5kaXN0YW5jZShlKTw9bn0sbm9ybTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29weSgpO3JldHVybiB0Lm5vcm1hbGl6ZSgpLHR9LGdldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpfSxnZXRFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVudmVsb3BlJiYodGhpcy5lbnZlbG9wZT10aGlzLmNvbXB1dGVFbnZlbG9wZUludGVybmFsKCkpLG5ldyBDKHRoaXMuZW52ZWxvcGUpfSxzZXRTUklEOmZ1bmN0aW9uKHQpe3RoaXMuU1JJRD10fSxzZXRVc2VyRGF0YTpmdW5jdGlvbih0KXt0aGlzLnVzZXJEYXRhPXR9LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5pdGVyYXRvcigpLGk9ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpJiZpLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9aS5uZXh0KCksbz1yLmNvbXBhcmVUbyhzKTtpZigwIT09bylyZXR1cm4gb31yZXR1cm4gbi5oYXNOZXh0KCk/MTppLmhhc05leHQoKT8tMTowfSxoYXNoQ29kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5oYXNoQ29kZSgpfSxpc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfHx0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfTVVMVElQT0lOVHx8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJTElORVNUUklOR3x8dGhpcy5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX01VTFRJUE9MWUdPTn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bbyxzLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCfX0pLEIuaGFzTm9uRW1wdHlFbGVtZW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQubGVuZ3RoO2UrKylpZighdFtlXS5pc0VtcHR5KCkpcmV0dXJuITA7cmV0dXJuITF9LEIuaGFzTnVsbEVsZW1lbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKG51bGw9PT10W2VdKXJldHVybiEwO3JldHVybiExfSxCLnNlcmlhbFZlcnNpb25VSUQ9MHg3OTllYTQ2NTIyODU0YzAwLEIuU09SVElOREVYX1BPSU5UPTAsQi5TT1JUSU5ERVhfTVVMVElQT0lOVD0xLEIuU09SVElOREVYX0xJTkVTVFJJTkc9MixCLlNPUlRJTkRFWF9MSU5FQVJSSU5HPTMsQi5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HPTQsQi5TT1JUSU5ERVhfUE9MWUdPTj01LEIuU09SVElOREVYX01VTFRJUE9MWUdPTj02LEIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTj03LEIuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QuZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uKCl9fSxlKHoucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6fX0pLGUoVi5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZ9fSksZShrLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0JTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga319KSxlKFkucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFl9fSksZShVLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0PjF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVfX0pLGUoWC5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gMT09PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYfX0pLFYuTW9kMkJvdW5kYXJ5Tm9kZVJ1bGU9ayxWLkVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1ZLFYuTXVsdGlWYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9VSxWLk1vbm9WYWxlbnRFbmRQb2ludEJvdW5kYXJ5Tm9kZVJ1bGU9WCxWLk1PRDJfQk9VTkRBUllfUlVMRT1uZXcgayxWLkVORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFksVi5NVUxUSVZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBVLFYuTU9OT1ZBTEVOVF9FTkRQT0lOVF9CT1VOREFSWV9SVUxFPW5ldyBYLFYuT0dDX1NGU19CT1VOREFSWV9SVUxFPVYuTU9EMl9CT1VOREFSWV9SVUxFLGUoSC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEh9fSksSC5pc1Jpbmc9ZnVuY3Rpb24odCl7cmV0dXJuIHQubGVuZ3RoPDQ/ITE6ISF0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfSxILnB0Tm90SW5MaXN0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl07aWYoSC5pbmRleE9mKGksZSk8MClyZXR1cm4gaX1yZXR1cm4gbnVsbH0sSC5zY3JvbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj1ILmluZGV4T2YoZSx0KTtpZigwPm4pcmV0dXJuIG51bGw7dmFyIGk9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpO0EuYXJyYXljb3B5KHQsbixpLDAsdC5sZW5ndGgtbiksQS5hcnJheWNvcHkodCwwLGksdC5sZW5ndGgtbixuKSxBLmFycmF5Y29weShpLDAsdCwwLHQubGVuZ3RoKX0sSC5lcXVhbHM9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKHQ9PT1lKXJldHVybiEwO2lmKG51bGw9PT10fHxudWxsPT09ZSlyZXR1cm4hMTtpZih0Lmxlbmd0aCE9PWUubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248dC5sZW5ndGg7bisrKWlmKCF0W25dLmVxdWFscyhlW25dKSlyZXR1cm4hMTtyZXR1cm4hMH1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO2lmKGk9PT1yKXJldHVybiEwO2lmKG51bGw9PT1pfHxudWxsPT09cilyZXR1cm4hMTtpZihpLmxlbmd0aCE9PXIubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0wO248aS5sZW5ndGg7bisrKWlmKDAhPT1zLmNvbXBhcmUoaVtuXSxyW25dKSlyZXR1cm4hMTtyZXR1cm4hMH19LEguaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBOLGk9MDtpPHQubGVuZ3RoO2krKyllLmludGVyc2VjdHModFtpXSkmJm4uYWRkKHRbaV0sITApO3JldHVybiBuLnRvQ29vcmRpbmF0ZUFycmF5KCl9LEguaGFzUmVwZWF0ZWRQb2ludHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspaWYodFtlLTFdLmVxdWFscyh0W2VdKSlyZXR1cm4hMDtyZXR1cm4hMX0sSC5yZW1vdmVSZXBlYXRlZFBvaW50cz1mdW5jdGlvbih0KXtpZighSC5oYXNSZXBlYXRlZFBvaW50cyh0KSlyZXR1cm4gdDt2YXIgZT1uZXcgTih0LCExKTtyZXR1cm4gZS50b0Nvb3JkaW5hdGVBcnJheSgpfSxILnJldmVyc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQubGVuZ3RoLTEsbj1NYXRoLnRydW5jKGUvMiksaT0wO24+PWk7aSsrKXt2YXIgcj10W2ldO3RbaV09dFtlLWldLHRbZS1pXT1yfX0sSC5yZW1vdmVOdWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmZSsrO3ZhciBpPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2lmKDA9PT1lKXJldHVybiBpO2Zvcih2YXIgcj0wLG49MDtuPHQubGVuZ3RoO24rKyludWxsIT09dFtuXSYmKGlbcisrXT10W25dKTtyZXR1cm4gaX0sSC5jb3B5RGVlcD1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPHQubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfWlmKDU9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl0sbz1hcmd1bWVudHNbM10sYT1hcmd1bWVudHNbNF0sbj0wO2E+bjtuKyspc1tvK25dPW5ldyBnKGlbcituXSl9LEguaXNFcXVhbFJldmVyc2VkPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspe3ZhciBpPXRbbl0scj1lW3QubGVuZ3RoLW4tMV07aWYoMCE9PWkuY29tcGFyZVRvKHIpKXJldHVybiExfXJldHVybiEwfSxILmVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPTA7bjx0Lmxlbmd0aDtuKyspZS5leHBhbmRUb0luY2x1ZGUodFtuXSk7cmV0dXJuIGV9LEgudG9Db29yZGluYXRlQXJyYXk9ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9BcnJheShILmNvb3JkQXJyYXlUeXBlKX0sSC5hdExlYXN0TkNvb3JkaW5hdGVzT3JOb3RoaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUubGVuZ3RoPj10P2U6W119LEguaW5kZXhPZj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKWlmKHQuZXF1YWxzKGVbbl0pKXJldHVybiBuO3JldHVybi0xfSxILmluY3JlYXNpbmdEaXJlY3Rpb249ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTxNYXRoLnRydW5jKHQubGVuZ3RoLzIpO2UrKyl7dmFyIG49dC5sZW5ndGgtMS1lLGk9dFtlXS5jb21wYXJlVG8odFtuXSk7aWYoMCE9PWkpcmV0dXJuIGl9cmV0dXJuIDF9LEguY29tcGFyZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5sZW5ndGgmJm48ZS5sZW5ndGg7KXt2YXIgaT10W25dLmNvbXBhcmVUbyhlW25dKTtpZigwIT09aSlyZXR1cm4gaTtuKyt9cmV0dXJuIG48ZS5sZW5ndGg/LTE6bjx0Lmxlbmd0aD8xOjB9LEgubWluQ29vcmRpbmF0ZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPTA7bjx0Lmxlbmd0aDtuKyspKG51bGw9PT1lfHxlLmNvbXBhcmVUbyh0W25dKT4wKSYmKGU9dFtuXSk7cmV0dXJuIGV9LEguZXh0cmFjdD1mdW5jdGlvbih0LGUsbil7ZT1ULmNsYW1wKGUsMCx0Lmxlbmd0aCksbj1ULmNsYW1wKG4sLTEsdC5sZW5ndGgpO3ZhciBpPW4tZSsxOzA+biYmKGk9MCksZT49dC5sZW5ndGgmJihpPTApLGU+biYmKGk9MCk7dmFyIHI9bmV3IEFycmF5KGkpLmZpbGwobnVsbCk7aWYoMD09PWkpcmV0dXJuIHI7Zm9yKHZhciBzPTAsbz1lO24+PW87bysrKXJbcysrXT10W29dO3JldHVybiByfSxlKFcucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7cmV0dXJuIEguY29tcGFyZShuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV319KSxlKGoucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7aWYobi5sZW5ndGg8aS5sZW5ndGgpcmV0dXJuLTE7aWYobi5sZW5ndGg+aS5sZW5ndGgpcmV0dXJuIDE7aWYoMD09PW4ubGVuZ3RoKXJldHVybiAwO3ZhciByPUguY29tcGFyZShuLGkpLHM9SC5pc0VxdWFsUmV2ZXJzZWQobixpKTtyZXR1cm4gcz8wOnJ9LE9MRGNvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtpZihuLmxlbmd0aDxpLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5pLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7Zm9yKHZhciByPUguaW5jcmVhc2luZ0RpcmVjdGlvbihuKSxzPUguaW5jcmVhc2luZ0RpcmVjdGlvbihpKSxvPXI+MD8wOm4ubGVuZ3RoLTEsYT1zPjA/MDpuLmxlbmd0aC0xLHU9MDt1PG4ubGVuZ3RoO3UrKyl7dmFyIGw9bltvXS5jb21wYXJlVG8oaVthXSk7aWYoMCE9PWwpcmV0dXJuIGw7bys9cixhKz1zfXJldHVybiAwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gan19KSxILkZvcndhcmRDb21wYXJhdG9yPVcsSC5CaWRpcmVjdGlvbmFsQ29tcGFyYXRvcj1qLEguY29vcmRBcnJheVR5cGU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksSy5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt9LFoucHJvdG90eXBlPW5ldyBLLFEucHJvdG90eXBlPW5ldyB2LFEucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKCl7fSxKLnByb3RvdHlwZT1uZXcgUSxKLnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXt2YXIgaT10aGlzLmFycmF5X1tlXTtpZihpPT09dClyZXR1cm4hMH1yZXR1cm4hMX0sSi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnRhaW5zKHQpPyExOih0aGlzLmFycmF5Xy5wdXNoKHQpLCEwKX0sSi5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sSi5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBqYXZhc2NyaXB0LnV0aWwuT3BlcmF0aW9uTm90U3VwcG9ydGVkfSxKLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSi5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LEoucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBKcyh0aGlzKX07dmFyIEpzPWZ1bmN0aW9uKHQpe3RoaXMuaGFzaFNldF89dCx0aGlzLnBvc2l0aW9uXz0wfTtKcy5wcm90b3R5cGUubmV4dD1mdW5jdGlvbigpe2lmKHRoaXMucG9zaXRpb25fPT09dGhpcy5oYXNoU2V0Xy5zaXplKCkpdGhyb3cgbmV3IHg7cmV0dXJuIHRoaXMuaGFzaFNldF8uYXJyYXlfW3RoaXMucG9zaXRpb25fKytdfSxKcy5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmhhc2hTZXRfLnNpemUoKX0sSnMucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe3Rocm93IG5ldyBFfTt2YXIgJHM9MCx0bz0xO3J0LnByb3RvdHlwZT1uZXcgWixydC5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnJvb3RfO251bGwhPT1lOyl7dmFyIG49dC5jb21wYXJlVG8oZS5rZXkpO2lmKDA+billPWUubGVmdDtlbHNle2lmKCEobj4wKSlyZXR1cm4gZS52YWx1ZTtlPWUucmlnaHR9fXJldHVybiBudWxsfSxydC5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXRoaXMucm9vdF8pcmV0dXJuIHRoaXMucm9vdF89e2tleTp0LHZhbHVlOmUsbGVmdDpudWxsLHJpZ2h0Om51bGwscGFyZW50Om51bGwsY29sb3I6JHMsZ2V0VmFsdWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52YWx1ZX0sZ2V0S2V5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2V5fX0sdGhpcy5zaXplXz0xLG51bGw7dmFyIG4saSxyPXRoaXMucm9vdF87ZG8gaWYobj1yLGk9dC5jb21wYXJlVG8oci5rZXkpLDA+aSlyPXIubGVmdDtlbHNle2lmKCEoaT4wKSl7dmFyIHM9ci52YWx1ZTtyZXR1cm4gci52YWx1ZT1lLHN9cj1yLnJpZ2h0fXdoaWxlKG51bGwhPT1yKTt2YXIgbz17a2V5OnQsbGVmdDpudWxsLHJpZ2h0Om51bGwsdmFsdWU6ZSxwYXJlbnQ6bixjb2xvcjokcyxnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9fTtyZXR1cm4gMD5pP24ubGVmdD1vOm4ucmlnaHQ9byx0aGlzLmZpeEFmdGVySW5zZXJ0aW9uKG8pLHRoaXMuc2l6ZV8rKyxudWxsfSxydC5wcm90b3R5cGUuZml4QWZ0ZXJJbnNlcnRpb249ZnVuY3Rpb24odCl7Zm9yKHQuY29sb3I9dG87bnVsbCE9dCYmdCE9dGhpcy5yb290XyYmdC5wYXJlbnQuY29sb3I9PXRvOylpZih0dCh0KT09bnQodHQodHQodCkpKSl7dmFyIGU9aXQodHQodHQodCkpKTskKGUpPT10bz8oZXQodHQodCksJHMpLGV0KGUsJHMpLGV0KHR0KHR0KHQpKSx0byksdD10dCh0dCh0KSkpOih0PT1pdCh0dCh0KSkmJih0PXR0KHQpLHRoaXMucm90YXRlTGVmdCh0KSksZXQodHQodCksJHMpLGV0KHR0KHR0KHQpKSx0byksdGhpcy5yb3RhdGVSaWdodCh0dCh0dCh0KSkpKX1lbHNle3ZhciBlPW50KHR0KHR0KHQpKSk7JChlKT09dG8/KGV0KHR0KHQpLCRzKSxldChlLCRzKSxldCh0dCh0dCh0KSksdG8pLHQ9dHQodHQodCkpKToodD09bnQodHQodCkpJiYodD10dCh0KSx0aGlzLnJvdGF0ZVJpZ2h0KHQpKSxldCh0dCh0KSwkcyksZXQodHQodHQodCkpLHRvKSx0aGlzLnJvdGF0ZUxlZnQodHQodHQodCkpKSl9dGhpcy5yb290Xy5jb2xvcj0kc30scnQucHJvdG90eXBlLnZhbHVlcz1mdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5nZXRGaXJzdEVudHJ5KCk7aWYobnVsbCE9PWUpZm9yKHQuYWRkKGUudmFsdWUpO251bGwhPT0oZT1ydC5zdWNjZXNzb3IoZSkpOyl0LmFkZChlLnZhbHVlKTtyZXR1cm4gdH0scnQucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEosZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUpO3JldHVybiB0fSxydC5wcm90b3R5cGUucm90YXRlTGVmdD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LnJpZ2h0O3QucmlnaHQ9ZS5sZWZ0LG51bGwhPWUubGVmdCYmKGUubGVmdC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LmxlZnQ9PXQ/dC5wYXJlbnQubGVmdD1lOnQucGFyZW50LnJpZ2h0PWUsZS5sZWZ0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5yb3RhdGVSaWdodD1mdW5jdGlvbih0KXtpZihudWxsIT10KXt2YXIgZT10LmxlZnQ7dC5sZWZ0PWUucmlnaHQsbnVsbCE9ZS5yaWdodCYmKGUucmlnaHQucGFyZW50PXQpLGUucGFyZW50PXQucGFyZW50LG51bGw9PXQucGFyZW50P3RoaXMucm9vdF89ZTp0LnBhcmVudC5yaWdodD09dD90LnBhcmVudC5yaWdodD1lOnQucGFyZW50LmxlZnQ9ZSxlLnJpZ2h0PXQsdC5wYXJlbnQ9ZX19LHJ0LnByb3RvdHlwZS5nZXRGaXJzdEVudHJ5PWZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yb290XztpZihudWxsIT10KWZvcig7bnVsbCE9dC5sZWZ0Oyl0PXQubGVmdDtyZXR1cm4gdH0scnQuc3VjY2Vzc29yPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2lmKG51bGwhPT10LnJpZ2h0KXtmb3IodmFyIGU9dC5yaWdodDtudWxsIT09ZS5sZWZ0OyllPWUubGVmdDtyZXR1cm4gZX1mb3IodmFyIGU9dC5wYXJlbnQsbj10O251bGwhPT1lJiZuPT09ZS5yaWdodDspbj1lLGU9ZS5wYXJlbnQ7cmV0dXJuIGV9LHJ0LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2l6ZV99LGUoc3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzdH19KSxvdC5wcm90b3R5cGU9bmV3IFEsYXQucHJvdG90eXBlPW5ldyBvdCxhdC5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMD09PWkuY29tcGFyZVRvKHQpKXJldHVybiEwfXJldHVybiExfSxhdC5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe2lmKHRoaXMuY29udGFpbnModCkpcmV0dXJuITE7Zm9yKHZhciBlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl7dmFyIGk9dGhpcy5hcnJheV9bZV07aWYoMT09PWkuY29tcGFyZVRvKHQpKXJldHVybiB0aGlzLmFycmF5Xy5zcGxpY2UoZSwwLHQpLCEwfXJldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxhdC5wcm90b3R5cGUuYWRkQWxsPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKTtyZXR1cm4hMH0sYXQucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbih0KXt0aHJvdyBuZXcgRX0sYXQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxhdC5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxhdC5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGVvKHRoaXMpfTt2YXIgZW89ZnVuY3Rpb24odCl7dGhpcy50cmVlU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9O2VvLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLnRyZWVTZXRfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy50cmVlU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LGVvLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMudHJlZVNldF8uc2l6ZSgpfSxlby5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9LHV0LnNvcnQ9ZnVuY3Rpb24oKXt2YXIgdCxlLG4saSxyPWFyZ3VtZW50c1swXTtpZigxPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gaT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNvbXBhcmVUbyhlKX0sdm9pZCByLnNvcnQoaSk7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpbj1hcmd1bWVudHNbMV0saT1mdW5jdGlvbih0LGUpe3JldHVybiBuLmNvbXBhcmUodCxlKX0sci5zb3J0KGkpO2Vsc2V7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2U9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxlLnNvcnQoKTt2YXIgcz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpO2ZvcihyLnNwbGljZSgwLHIubGVuZ3RoKSx0PTA7dDxzLmxlbmd0aDt0Kyspci5wdXNoKHNbdF0pO3JldHVybn1pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKGU9ci5zbGljZShhcmd1bWVudHNbMV0sYXJndW1lbnRzWzJdKSxuPWFyZ3VtZW50c1szXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY29tcGFyZSh0LGUpfSxlLnNvcnQoaSkscz1yLnNsaWNlKDAsYXJndW1lbnRzWzFdKS5jb25jYXQoZSxyLnNsaWNlKGFyZ3VtZW50c1syXSxyLmxlbmd0aCkpLHIuc3BsaWNlKDAsci5sZW5ndGgpLHQ9MDt0PHMubGVuZ3RoO3QrKylyLnB1c2goc1t0XSk7cmV0dXJufX19LHV0LmFzTGlzdD1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9dC5sZW5ndGg7aT5uO24rKyllLmFkZCh0W25dKTtyZXR1cm4gZX0sZShsdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGx0fX0pLGx0LnRvRGltZW5zaW9uU3ltYm9sPWZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIGx0LkZBTFNFOnJldHVybiBsdC5TWU1fRkFMU0U7Y2FzZSBsdC5UUlVFOnJldHVybiBsdC5TWU1fVFJVRTtjYXNlIGx0LkRPTlRDQVJFOnJldHVybiBsdC5TWU1fRE9OVENBUkU7Y2FzZSBsdC5QOnJldHVybiBsdC5TWU1fUDtjYXNlIGx0Lkw6cmV0dXJuIGx0LlNZTV9MO2Nhc2UgbHQuQTpyZXR1cm4gbHQuU1lNX0F9dGhyb3cgbmV3IGkoXCJVbmtub3duIGRpbWVuc2lvbiB2YWx1ZTogXCIrdCl9LGx0LnRvRGltZW5zaW9uVmFsdWU9ZnVuY3Rpb24odCl7c3dpdGNoKE8udG9VcHBlckNhc2UodCkpe2Nhc2UgbHQuU1lNX0ZBTFNFOnJldHVybiBsdC5GQUxTRTtjYXNlIGx0LlNZTV9UUlVFOnJldHVybiBsdC5UUlVFO2Nhc2UgbHQuU1lNX0RPTlRDQVJFOnJldHVybiBsdC5ET05UQ0FSRTtjYXNlIGx0LlNZTV9QOnJldHVybiBsdC5QO2Nhc2UgbHQuU1lNX0w6cmV0dXJuIGx0Lkw7Y2FzZSBsdC5TWU1fQTpyZXR1cm4gbHQuQX10aHJvdyBuZXcgaShcIlVua25vd24gZGltZW5zaW9uIHN5bWJvbDogXCIrdCl9LGx0LlA9MCxsdC5MPTEsbHQuQT0yLGx0LkZBTFNFPS0xLGx0LlRSVUU9LTIsbHQuRE9OVENBUkU9LTMsbHQuU1lNX0ZBTFNFPVwiRlwiLGx0LlNZTV9UUlVFPVwiVFwiLGx0LlNZTV9ET05UQ0FSRT1cIipcIixsdC5TWU1fUD1cIjBcIixsdC5TWU1fTD1cIjFcIixsdC5TWU1fQT1cIjJcIixlKGh0LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHR9fSksZShjdC5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0LGUpe30saXNEb25lOmZ1bmN0aW9uKCl7fSxpc0dlb21ldHJ5Q2hhbmdlZDpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3R9fSksaChmdCxCKSxlKGZ0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEMsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5nZW9tZXRyaWVzW2VdLmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIHR9LGdldEdlb21ldHJ5TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzW3RdfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKSxlPS0xLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWZvcih2YXIgaT10aGlzLmdlb21ldHJpZXNbbl0uZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aDtyKyspZSsrLHRbZV09aVtyXTtyZXR1cm4gdH0sZ2V0QXJlYTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXRBcmVhKCk7cmV0dXJuIHR9LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZighdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KSlyZXR1cm4hMTt2YXIgbj10O2lmKHRoaXMuZ2VvbWV0cmllcy5sZW5ndGghPT1uLmdlb21ldHJpZXMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgaT0wO2k8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtpKyspaWYoIXRoaXMuZ2VvbWV0cmllc1tpXS5lcXVhbHNFeGFjdChuLmdlb21ldHJpZXNbaV0sZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKyl0aGlzLmdlb21ldHJpZXNbdF0ubm9ybWFsaXplKCk7dXQuc29ydCh0aGlzLmdlb21ldHJpZXMpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZW9tZXRyaWVzWzBdLmdldENvb3JkaW5hdGUoKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bHQuRkFMU0UsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuZ2VvbWV0cmllc1tlXS5nZXRCb3VuZGFyeURpbWVuc2lvbigpKTtyZXR1cm4gdH0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWx0LkZBTFNFLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQ9TWF0aC5tYXgodCx0aGlzLmdlb21ldHJpZXNbZV0uZ2V0RGltZW5zaW9uKCkpO3JldHVybiB0fSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmdlb21ldHJpZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9LGdldE51bVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXROdW1Qb2ludHMoKTtyZXR1cm4gdH0sZ2V0TnVtR2VvbWV0cmllczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21ldHJpZXMubGVuZ3RofSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW25dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBhdCh1dC5hc0xpc3QodGhpcy5nZW9tZXRyaWVzKSksbj1uZXcgYXQodXQuYXNMaXN0KHQuZ2VvbWV0cmllcykpO3JldHVybiB0aGlzLmNvbXBhcmUoZSxuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWksbz10aGlzLmdldE51bUdlb21ldHJpZXMoKSxhPXMuZ2V0TnVtR2VvbWV0cmllcygpLHU9MDtvPnUmJmE+dTspe3ZhciBsPXRoaXMuZ2V0R2VvbWV0cnlOKHUpLGg9cy5nZXRHZW9tZXRyeU4odSksYz1sLmNvbXBhcmVUb1NhbWVDbGFzcyhoLHIpO2lmKDAhPT1jKXJldHVybiBjO3UrK31yZXR1cm4gbz51PzE6YT51Py0xOjB9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KHQpO2Vsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoJiYodGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KG4pLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KGkpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXRoaXMuZ2VvbWV0cmllc1tlXS5hcHBseShyKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksZi5zaG91bGROZXZlclJlYWNoSGVyZSgpLG51bGx9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTt0Lmdlb21ldHJpZXM9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0Lmdlb21ldHJpZXNbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNsb25lKCk7cmV0dXJuIHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiR2VvbWV0cnlDb2xsZWN0aW9uXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGZ0KHQsdGhpcy5mYWN0b3J5KX0saXNFbXB0eTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDt0KyspaWYoIXRoaXMuZ2VvbWV0cmllc1t0XS5pc0VtcHR5KCkpcmV0dXJuITE7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZ0fX0pLGZ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4NGYwN2JjYjFmODU3ZDgwMCxoKGd0LGZ0KSxlKGd0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJTElORVNUUklOR30sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP2Z0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKTohMX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP2x0LkZBTFNFOjB9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuITE7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5nZW9tZXRyaWVzW3RdLmlzQ2xvc2VkKCkpcmV0dXJuITE7cmV0dXJuITB9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW3QtMS1uXT10aGlzLmdlb21ldHJpZXNbbl0ucmV2ZXJzZSgpO3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkdCh0aGlzKS5nZXRCb3VuZGFyeSgpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpTGluZVN0cmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBndCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7XG5yZXR1cm5bc3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBndH19KSxndC5zZXJpYWxWZXJzaW9uVUlEPTB4NzE1NWQyYWI0YWZhODAwMCxlKGR0LnByb3RvdHlwZSx7Ym91bmRhcnlNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7aWYodGhpcy5nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTt2YXIgZT10aGlzLmNvbXB1dGVCb3VuZGFyeUNvb3JkaW5hdGVzKHQpO3JldHVybiAxPT09ZS5sZW5ndGg/dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludChlWzBdKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnRGcm9tQ29vcmRzKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb20gaW5zdGFuY2VvZiBTdD90aGlzLmJvdW5kYXJ5TGluZVN0cmluZyh0aGlzLmdlb20pOnRoaXMuZ2VvbSBpbnN0YW5jZW9mIGd0P3RoaXMuYm91bmRhcnlNdWx0aUxpbmVTdHJpbmcodGhpcy5nZW9tKTp0aGlzLmdlb20uZ2V0Qm91bmRhcnkoKX0sYm91bmRhcnlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZ2VvbS5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RW1wdHlNdWx0aVBvaW50KCk7aWYodC5pc0Nsb3NlZCgpKXt2YXIgZT10aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoMik7cmV0dXJuIGU/dC5nZXRTdGFydFBvaW50KCk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KCl9cmV0dXJuIHRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludChbdC5nZXRTdGFydFBvaW50KCksdC5nZXRFbmRQb2ludCgpXSl9LGdldEVtcHR5TXVsdGlQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX0sY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7dGhpcy5lbmRwb2ludE1hcD1uZXcgcnQ7Zm9yKHZhciBuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pOzAhPT1pLmdldE51bVBvaW50cygpJiYodGhpcy5hZGRFbmRwb2ludChpLmdldENvb3JkaW5hdGVOKDApKSx0aGlzLmFkZEVuZHBvaW50KGkuZ2V0Q29vcmRpbmF0ZU4oaS5nZXROdW1Qb2ludHMoKS0xKSkpfWZvcih2YXIgcj10aGlzLmVuZHBvaW50TWFwLmVudHJ5U2V0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRWYWx1ZSgpLGE9by5jb3VudDt0aGlzLmJuUnVsZS5pc0luQm91bmRhcnkoYSkmJmUuYWRkKHMuZ2V0S2V5KCkpfXJldHVybiBILnRvQ29vcmRpbmF0ZUFycmF5KGUpfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVuZHBvaW50TWFwLmdldCh0KTtudWxsPT09ZSYmKGU9bmV3IHB0LHRoaXMuZW5kcG9pbnRNYXAucHV0KHQsZSkpLGUuY291bnQrK30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZHR9fSksZHQuZ2V0Qm91bmRhcnk9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGR0KHQpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW5ldyBkdChuLGkpO3JldHVybiBlLmdldEJvdW5kYXJ5KCl9fSxlKHB0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHR9fSksZShOdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE50fX0pLE50LmNoYXJzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBBcnJheShlKS5maWxsKG51bGwpLGk9MDtlPmk7aSsrKW5baV09dDtyZXR1cm4gbmV3IFN0cmluZyhuKX0sTnQuZ2V0U3RhY2tUcmFjZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgeHQsbj1uZXcgdnQoZSk7cmV0dXJuIHQucHJpbnRTdGFja1RyYWNlKG4pLGUudG9TdHJpbmcoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPVwiXCIsbz1uZXcgbXQoTnQuZ2V0U3RhY2tUcmFjZShpKSksYT1uZXcgSXQobyksdT0wO3I+dTt1KyspdHJ5e3MrPWEucmVhZExpbmUoKStOdC5ORVdMSU5FfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIEV0KSl0aHJvdyB0O2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1maW5hbGx5e31yZXR1cm4gc319LE50LnNwbGl0PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUubGVuZ3RoLGk9bmV3IEkscj1cIlwiK3Qscz1yLmluZGV4T2YoZSk7cz49MDspe3ZhciBvPXIuc3Vic3RyaW5nKDAscyk7aS5hZGQobykscj1yLnN1YnN0cmluZyhzK24pLHM9ci5pbmRleE9mKGUpfXIubGVuZ3RoPjAmJmkuYWRkKHIpO2Zvcih2YXIgYT1uZXcgQXJyYXkoaS5zaXplKCkpLmZpbGwobnVsbCksdT0wO3U8YS5sZW5ndGg7dSsrKWFbdV09aS5nZXQodSk7cmV0dXJuIGF9LE50LnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gTnQuU0lNUExFX09SRElOQVRFX0ZPUk1BVC5mb3JtYXQodCl9fSxOdC5zcGFjZXM9ZnVuY3Rpb24odCl7cmV0dXJuIE50LmNoYXJzKFwiIFwiLHQpfSxOdC5ORVdMSU5FPUEuZ2V0UHJvcGVydHkoXCJsaW5lLnNlcGFyYXRvclwiKSxOdC5TSU1QTEVfT1JESU5BVEVfRk9STUFUPW5ldyB5dChcIjAuI1wiKSxlKEN0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3R9fSksQ3QuY29weUNvb3JkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1NYXRoLm1pbih0LmdldERpbWVuc2lvbigpLG4uZ2V0RGltZW5zaW9uKCkpLHM9MDtyPnM7cysrKW4uc2V0T3JkaW5hdGUoaSxzLHQuZ2V0T3JkaW5hdGUoZSxzKSl9LEN0LmlzUmluZz1mdW5jdGlvbih0KXt2YXIgZT10LnNpemUoKTtyZXR1cm4gMD09PWU/ITA6Mz49ZT8hMTp0LmdldE9yZGluYXRlKDAsRC5YKT09PXQuZ2V0T3JkaW5hdGUoZS0xLEQuWCkmJnQuZ2V0T3JkaW5hdGUoMCxELlkpPT09dC5nZXRPcmRpbmF0ZShlLTEsRC5ZKX0sQ3QuaXNFcXVhbD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuc2l6ZSgpLGk9ZS5zaXplKCk7aWYobiE9PWkpcmV0dXJuITE7Zm9yKHZhciBzPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSksbz0wO24+bztvKyspZm9yKHZhciBhPTA7cz5hO2ErKyl7dmFyIHU9dC5nZXRPcmRpbmF0ZShvLGEpLGw9ZS5nZXRPcmRpbmF0ZShvLGEpO2lmKCEodC5nZXRPcmRpbmF0ZShvLGEpPT09ZS5nZXRPcmRpbmF0ZShvLGEpfHxyLmlzTmFOKHUpJiZyLmlzTmFOKGwpKSlyZXR1cm4hMX1yZXR1cm4hMH0sQ3QuZXh0ZW5kPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmNyZWF0ZShuLGUuZ2V0RGltZW5zaW9uKCkpLHI9ZS5zaXplKCk7aWYoQ3QuY29weShlLDAsaSwwLHIpLHI+MClmb3IodmFyIHM9cjtuPnM7cysrKUN0LmNvcHkoZSxyLTEsaSxzLDEpO3JldHVybiBpfSxDdC5yZXZlcnNlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LnNpemUoKS0xLG49TWF0aC50cnVuYyhlLzIpLGk9MDtuPj1pO2krKylDdC5zd2FwKHQsaSxlLWkpfSxDdC5zd2FwPWZ1bmN0aW9uKHQsZSxuKXtpZihlPT09bilyZXR1cm4gbnVsbDtmb3IodmFyIGk9MDtpPHQuZ2V0RGltZW5zaW9uKCk7aSsrKXt2YXIgcj10LmdldE9yZGluYXRlKGUsaSk7dC5zZXRPcmRpbmF0ZShlLGksdC5nZXRPcmRpbmF0ZShuLGkpKSx0LnNldE9yZGluYXRlKG4saSxyKX19LEN0LmNvcHk9ZnVuY3Rpb24odCxlLG4saSxyKXtmb3IodmFyIHM9MDtyPnM7cysrKUN0LmNvcHlDb29yZCh0LGUrcyxuLGkrcyl9LEN0LnRvU3RyaW5nPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuc2l6ZSgpO2lmKDA9PT1lKXJldHVyblwiKClcIjt2YXIgbj10LmdldERpbWVuc2lvbigpLGk9bmV3IFA7aS5hcHBlbmQoXCIoXCIpO2Zvcih2YXIgcj0wO2U+cjtyKyspe3I+MCYmaS5hcHBlbmQoXCIgXCIpO2Zvcih2YXIgcz0wO24+cztzKyspcz4wJiZpLmFwcGVuZChcIixcIiksaS5hcHBlbmQoTnQudG9TdHJpbmcodC5nZXRPcmRpbmF0ZShyLHMpKSl9cmV0dXJuIGkuYXBwZW5kKFwiKVwiKSxpLnRvU3RyaW5nKCl9fSxDdC5lbnN1cmVWYWxpZFJpbmc9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLnNpemUoKTtpZigwPT09bilyZXR1cm4gZTtpZigzPj1uKXJldHVybiBDdC5jcmVhdGVDbG9zZWRSaW5nKHQsZSw0KTt2YXIgaT1lLmdldE9yZGluYXRlKDAsRC5YKT09PWUuZ2V0T3JkaW5hdGUobi0xLEQuWCkmJmUuZ2V0T3JkaW5hdGUoMCxELlkpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRC5ZKTtyZXR1cm4gaT9lOkN0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLG4rMSl9LEN0LmNyZWF0ZUNsb3NlZFJpbmc9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSkscj1lLnNpemUoKTtDdC5jb3B5KGUsMCxpLDAscik7Zm9yKHZhciBzPXI7bj5zO3MrKylDdC5jb3B5KGUsMCxpLHMsMSk7cmV0dXJuIGl9LGgoU3QsQiksZShTdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP25ldyBDOnRoaXMucG9pbnRzLmV4cGFuZEVudmVsb3BlKG5ldyBDKX0saXNSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKSYmdGhpcy5pc1NpbXBsZSgpfSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTElORVNUUklOR30sZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHMudG9Db29yZGluYXRlQXJyYXkoKX0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO3ZhciBuPXQ7aWYodGhpcy5wb2ludHMuc2l6ZSgpIT09bi5wb2ludHMuc2l6ZSgpKXJldHVybiExO2Zvcih2YXIgaT0wO2k8dGhpcy5wb2ludHMuc2l6ZSgpO2krKylpZighdGhpcy5lcXVhbCh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGkpLG4ucG9pbnRzLmdldENvb3JkaW5hdGUoaSksZSkpcmV0dXJuITE7cmV0dXJuITB9cmV0dXJuIEIucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDxNYXRoLnRydW5jKHRoaXMucG9pbnRzLnNpemUoKS8yKTt0Kyspe3ZhciBlPXRoaXMucG9pbnRzLnNpemUoKS0xLXQ7aWYoIXRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCkuZXF1YWxzKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkpKXJldHVybiB0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKHQpLmNvbXBhcmVUbyh0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpKT4wJiZDdC5yZXZlcnNlKHRoaXMucG9pbnRzKSxudWxsfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoMCl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNDbG9zZWQoKT9sdC5GQUxTRTowfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8hMTp0aGlzLmdldENvb3JkaW5hdGVOKDApLmVxdWFsczJEKHRoaXMuZ2V0Q29vcmRpbmF0ZU4odGhpcy5nZXROdW1Qb2ludHMoKS0xKSl9LGdldEVuZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4odGhpcy5nZXROdW1Qb2ludHMoKS0xKX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiBoZS5jb21wdXRlTGVuZ3RoKHRoaXMucG9pbnRzKX0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzLnNpemUoKX0scmV2ZXJzZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucG9pbnRzLmNvcHkoKTtDdC5yZXZlcnNlKHQpO3ZhciBlPXRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodCk7cmV0dXJuIGV9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dCxuPTAsaT0wO248dGhpcy5wb2ludHMuc2l6ZSgpJiZpPGUucG9pbnRzLnNpemUoKTspe3ZhciByPXRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUobikuY29tcGFyZVRvKGUucG9pbnRzLmdldENvb3JkaW5hdGUoaSkpO2lmKDAhPT1yKXJldHVybiByO24rKyxpKyt9cmV0dXJuIG48dGhpcy5wb2ludHMuc2l6ZSgpPzE6aTxlLnBvaW50cy5zaXplKCk/LTE6MH1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGU9cztyZXR1cm4gby5jb21wYXJlKHRoaXMucG9pbnRzLGUucG9pbnRzKX19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCk7ZSsrKXQuZmlsdGVyKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkpO2Vsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgbj1hcmd1bWVudHNbMF07aWYoMD09PXRoaXMucG9pbnRzLnNpemUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKSYmKG4uZmlsdGVyKHRoaXMucG9pbnRzLGUpLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBkdCh0aGlzKS5nZXRCb3VuZGFyeSgpfSxpc0VxdWl2YWxlbnRDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIFN0fSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7cmV0dXJuIHQucG9pbnRzPXRoaXMucG9pbnRzLmNsb25lKCksdH0sZ2V0Q29vcmRpbmF0ZU46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTGluZVN0cmluZ1wifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBTdCh0aGlzLnBvaW50cy5jb3B5KCksdGhpcy5mYWN0b3J5KX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9pbnRzfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLnBvaW50cy5zaXplKCl9LGluaXQ6ZnVuY3Rpb24odCl7aWYobnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSwxPT09dC5zaXplKCkpdGhyb3cgbmV3IGkoXCJJbnZhbGlkIG51bWJlciBvZiBwb2ludHMgaW4gTGluZVN0cmluZyAoZm91bmQgXCIrdC5zaXplKCkrXCIgLSBtdXN0IGJlIDAgb3IgPj0gMilcIik7dGhpcy5wb2ludHM9dH0saXNDb29yZGluYXRlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpO2UrKylpZih0aGlzLnBvaW50cy5nZXRDb29yZGluYXRlKGUpLmVxdWFscyh0KSlyZXR1cm4hMDtyZXR1cm4hMX0sZ2V0U3RhcnRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9udWxsOnRoaXMuZ2V0UG9pbnROKDApfSxnZXRQb2ludE46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFN0fX0pLFN0LnNlcmlhbFZlcnNpb25VSUQ9MHgyYjJiNTFiYTQzNWM4ZTAwLGUod3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3dH19KSxoKEx0LEIpLGUoTHQucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBuZXcgQzt2YXIgdD1uZXcgQztyZXR1cm4gdC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb29yZGluYXRlcy5nZXRYKDApLHRoaXMuY29vcmRpbmF0ZXMuZ2V0WSgwKSksdH0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX1BPSU5UfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9bXTpbdGhpcy5nZXRDb29yZGluYXRlKCldfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/dGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpPyEwOnRoaXMuaXNFbXB0eSgpIT09dC5pc0VtcHR5KCk/ITE6dGhpcy5lcXVhbCh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmdldENvb3JkaW5hdGUoKSxlKTohMX1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXt9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gMCE9PXRoaXMuY29vcmRpbmF0ZXMuc2l6ZSgpP3RoaXMuY29vcmRpbmF0ZXMuZ2V0Q29vcmRpbmF0ZSgwKTpudWxsfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiBsdC5GQUxTRX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzRW1wdHkoKT8wOjF9LHJldmVyc2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3B5KCl9LGdldFg6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZXRDb29yZGluYXRlKCkpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcImdldFggY2FsbGVkIG9uIGVtcHR5IFBvaW50XCIpO3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS54fSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dDtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKGUuZ2V0Q29vcmRpbmF0ZSgpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bjtyZXR1cm4gaS5jb21wYXJlKHRoaXMuY29vcmRpbmF0ZXMsZS5jb29yZGluYXRlcyl9fSxhcHBseTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHopKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dC5maWx0ZXIodGhpcy5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sY3QpKXt2YXIgZT1hcmd1bWVudHNbMF07aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7ZS5maWx0ZXIodGhpcy5jb29yZGluYXRlcywwKSxlLmlzR2VvbWV0cnlDaGFuZ2VkKCkmJnRoaXMuZ2VvbWV0cnlDaGFuZ2VkKCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxodCkpe3ZhciBuPWFyZ3VtZW50c1swXTtuLmZpbHRlcih0aGlzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHEpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyl9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5jb29yZGluYXRlcz10aGlzLmNvb3JkaW5hdGVzLmNsb25lKCksdH0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJQb2ludFwifSxjb3B5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBMdCh0aGlzLmNvb3JkaW5hdGVzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxnZXRDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc30sZ2V0WTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WSBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnl9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMuY29vcmRpbmF0ZXMuc2l6ZSgpfSxpbml0OmZ1bmN0aW9uKHQpe251bGw9PT10JiYodD10aGlzLmdldEZhY3RvcnkoKS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSksZi5pc1RydWUodC5zaXplKCk8PTEpLHRoaXMuY29vcmRpbmF0ZXM9dH0saXNTaW1wbGU6ZnVuY3Rpb24oKXtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bd3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMdH19KSxMdC5zZXJpYWxWZXJzaW9uVUlEPTB4NDQwNzdiYWQxNjFjYmMwMCxlKFJ0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnR9fSksaChUdCxCKSxlKFR0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5nZXRFbnZlbG9wZUludGVybmFsKCl9LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9QT0xZR09OfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybltdO2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZXROdW1Qb2ludHMoKSkuZmlsbChudWxsKSxlPS0xLG49dGhpcy5zaGVsbC5nZXRDb29yZGluYXRlcygpLGk9MDtpPG4ubGVuZ3RoO2krKyllKyssdFtlXT1uW2ldO2Zvcih2YXIgcj0wO3I8dGhpcy5ob2xlcy5sZW5ndGg7cisrKWZvcih2YXIgcz10aGlzLmhvbGVzW3JdLmdldENvb3JkaW5hdGVzKCksbz0wO288cy5sZW5ndGg7bysrKWUrKyx0W2VdPXNbb107cmV0dXJuIHR9LGdldEFyZWE6ZnVuY3Rpb24oKXt2YXIgdD0wO3QrPU1hdGguYWJzKGhlLnNpZ25lZEFyZWEodGhpcy5zaGVsbC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQtPU1hdGguYWJzKGhlLnNpZ25lZEFyZWEodGhpcy5ob2xlc1tlXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSkpO3JldHVybiB0fSxpc1JlY3RhbmdsZTpmdW5jdGlvbigpe2lmKDAhPT10aGlzLmdldE51bUludGVyaW9yUmluZygpKXJldHVybiExO2lmKG51bGw9PT10aGlzLnNoZWxsKXJldHVybiExO2lmKDUhPT10aGlzLnNoZWxsLmdldE51bVBvaW50cygpKXJldHVybiExO2Zvcih2YXIgdD10aGlzLnNoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLGU9dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCksbj0wOzU+bjtuKyspe3ZhciBpPXQuZ2V0WChuKTtpZihpIT09ZS5nZXRNaW5YKCkmJmkhPT1lLmdldE1heFgoKSlyZXR1cm4hMTt2YXIgcj10LmdldFkobik7aWYociE9PWUuZ2V0TWluWSgpJiZyIT09ZS5nZXRNYXhZKCkpcmV0dXJuITF9Zm9yKHZhciBzPXQuZ2V0WCgwKSxvPXQuZ2V0WSgwKSxuPTE7ND49bjtuKyspe3ZhciBpPXQuZ2V0WChuKSxyPXQuZ2V0WShuKSxhPWkhPT1zLHU9ciE9PW87aWYoYT09PXUpcmV0dXJuITE7cz1pLG89cn1yZXR1cm4hMH0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO3ZhciBuPXQsaT10aGlzLnNoZWxsLHI9bi5zaGVsbDtpZighaS5lcXVhbHNFeGFjdChyLGUpKXJldHVybiExO2lmKHRoaXMuaG9sZXMubGVuZ3RoIT09bi5ob2xlcy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBzPTA7czx0aGlzLmhvbGVzLmxlbmd0aDtzKyspaWYoIXRoaXMuaG9sZXNbc10uZXF1YWxzRXhhY3Qobi5ob2xlc1tzXSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7dGhpcy5ub3JtYWxpemUodGhpcy5zaGVsbCwhMCk7Zm9yKHZhciB0PTA7dDx0aGlzLmhvbGVzLmxlbmd0aDt0KyspdGhpcy5ub3JtYWxpemUodGhpcy5ob2xlc1t0XSwhMSk7dXQuc29ydCh0aGlzLmhvbGVzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGk9bmV3IEFycmF5KGUuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSkuZmlsbChudWxsKTtBLmFycmF5Y29weShlLmdldENvb3JkaW5hdGVzKCksMCxpLDAsaS5sZW5ndGgpO3ZhciByPUgubWluQ29vcmRpbmF0ZShlLmdldENvb3JkaW5hdGVzKCkpO0guc2Nyb2xsKGksciksQS5hcnJheWNvcHkoaSwwLGUuZ2V0Q29vcmRpbmF0ZXMoKSwwLGkubGVuZ3RoKSxlLmdldENvb3JkaW5hdGVzKClbaS5sZW5ndGhdPWlbMF0saGUuaXNDQ1coZS5nZXRDb29yZGluYXRlcygpKT09PW4mJkgucmV2ZXJzZShlLmdldENvb3JkaW5hdGVzKCkpfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmdldENvb3JkaW5hdGUoKX0sZ2V0TnVtSW50ZXJpb3JSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaG9sZXMubGVuZ3RofSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAxfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMn0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7dmFyIHQ9MDt0Kz10aGlzLnNoZWxsLmdldExlbmd0aCgpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuaG9sZXNbZV0uZ2V0TGVuZ3RoKCk7cmV0dXJuIHR9LGdldE51bVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLnNoZWxsLmdldE51bVBvaW50cygpLGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0Kz10aGlzLmhvbGVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb3B5KCk7dC5zaGVsbD10aGlzLnNoZWxsLmNvcHkoKS5yZXZlcnNlKCksdC5ob2xlcz1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdC5ob2xlc1tlXT10aGlzLmhvbGVzW2VdLmNvcHkoKS5yZXZlcnNlKCk7cmV0dXJuIHR9LGNvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFeHRlcmlvclJpbmcoKS5jb252ZXhIdWxsKCl9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLnNoZWxsLG49dC5zaGVsbDtyZXR1cm4gZS5jb21wYXJlVG9TYW1lQ2xhc3Mobil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWksZT10aGlzLnNoZWxsLG49cy5zaGVsbCxvPWUuY29tcGFyZVRvU2FtZUNsYXNzKG4scik7aWYoMCE9PW8pcmV0dXJuIG87Zm9yKHZhciBhPXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCksdT1zLmdldE51bUludGVyaW9yUmluZygpLGw9MDthPmwmJnU+bDspe3ZhciBoPXRoaXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxjPXMuZ2V0SW50ZXJpb3JSaW5nTihsKSxmPWguY29tcGFyZVRvU2FtZUNsYXNzKGMscik7aWYoMCE9PWYpcmV0dXJuIGY7bCsrfXJldHVybiBhPmw/MTp1Pmw/LTE6MH19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNoZWxsLmFwcGx5KHQpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuaG9sZXNbZV0uYXBwbHkodCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLnNoZWxsLmFwcGx5KG4pLCFuLmlzRG9uZSgpKWZvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGgmJih0aGlzLmhvbGVzW2VdLmFwcGx5KG4pLCFuLmlzRG9uZSgpKTtlKyspO24uaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIGk9YXJndW1lbnRzWzBdO2kuZmlsdGVyKHRoaXMpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciByPWFyZ3VtZW50c1swXTtyLmZpbHRlcih0aGlzKSx0aGlzLnNoZWxsLmFwcGx5KHIpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXRoaXMuaG9sZXNbZV0uYXBwbHkocil9fSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTt2YXIgdD1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgrMSkuZmlsbChudWxsKTt0WzBdPXRoaXMuc2hlbGw7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdFtlKzFdPXRoaXMuaG9sZXNbZV07cmV0dXJuIHQubGVuZ3RoPD0xP3RoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodFswXS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk6dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQpfSxjbG9uZTpmdW5jdGlvbigpe3ZhciB0PUIucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyk7dC5zaGVsbD10aGlzLnNoZWxsLmNsb25lKCksdC5ob2xlcz1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdC5ob2xlc1tlXT10aGlzLmhvbGVzW2VdLmNsb25lKCk7cmV0dXJuIHR9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiUG9seWdvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuc2hlbGwuY29weSgpLGU9bmV3IEFycmF5KHRoaXMuaG9sZXMubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRoaXMuaG9sZXNbbl0uY29weSgpO3JldHVybiBuZXcgVHQodCxlLHRoaXMuZmFjdG9yeSl9LGdldEV4dGVyaW9yUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuaXNFbXB0eSgpfSxnZXRJbnRlcmlvclJpbmdOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhvbGVzW3RdfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFR0fX0pLFR0LnNlcmlhbFZlcnNpb25VSUQ9LTB4MzA3ZmZlZmQ4ZGM5NzIwMCxoKFB0LGZ0KSxlKFB0LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJUE9JTlR9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP2Z0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKTohMX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZ2VvbWV0cmllc1t0XS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIGZ0LnByb3RvdHlwZS5nZXRDb29yZGluYXRlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAwfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obnVsbCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlQb2ludFwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBQdCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3d0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHR9fSksUHQuc2VyaWFsVmVyc2lvblVJRD0tMHg2ZmIxZWQ0MTYyZTBmYzAwLGgoYnQsU3QpLGUoYnQucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTElORUFSUklOR30sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gbHQuRkFMU0V9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPyEwOlN0LnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb2ludHMuY29weSgpO0N0LnJldmVyc2UodCk7dmFyIGU9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0KTtyZXR1cm4gZX0sdmFsaWRhdGVDb25zdHJ1Y3Rpb246ZnVuY3Rpb24oKXtpZighdGhpcy5pc0VtcHR5KCkmJiFTdC5wcm90b3R5cGUuaXNDbG9zZWQuY2FsbCh0aGlzKSl0aHJvdyBuZXcgaShcIlBvaW50cyBvZiBMaW5lYXJSaW5nIGRvIG5vdCBmb3JtIGEgY2xvc2VkIGxpbmVzdHJpbmdcIik7aWYodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk+PTEmJnRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpPGJ0Lk1JTklNVU1fVkFMSURfU0laRSl0aHJvdyBuZXcgaShcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lYXJSaW5nIChmb3VuZCBcIit0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSA0KVwiKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJMaW5lYXJSaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGJ0KHRoaXMucG9pbnRzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBidH19KSxidC5NSU5JTVVNX1ZBTElEX1NJWkU9NCxidC5zZXJpYWxWZXJzaW9uVUlEPS0weDNiMjI5ZTI2MjM2N2E2MDAsaChPdCxmdCksZShPdC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9NVUxUSVBPTFlHT059LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT9mdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuY2FsbCh0aGlzLHQsZSk6ITF9cmV0dXJuIGZ0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAyfSxyZXZlcnNlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2VvbWV0cmllcy5sZW5ndGgsZT1uZXcgQXJyYXkodCkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO24rKyllW25dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Zm9yKHZhciB0PW5ldyBJLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKWZvcih2YXIgbj10aGlzLmdlb21ldHJpZXNbZV0saT1uLmdldEJvdW5kYXJ5KCkscj0wO3I8aS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXQuYWRkKGkuZ2V0R2VvbWV0cnlOKHIpKTt2YXIgcz1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyh0LnRvQXJyYXkocykpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIk11bHRpUG9seWdvblwifSxjb3B5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdlb21ldHJpZXMubGVuZ3RoKS5maWxsKG51bGwpLGU9MDtlPHQubGVuZ3RoO2UrKyl0W2VdPXRoaXMuZ2VvbWV0cmllc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBPdCh0LHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1J0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3R9fSksT3Quc2VyaWFsVmVyc2lvblVJRD0tMHg3YTVhYTEzNjkxNzE5ODAsZShfdC5wcm90b3R5cGUse3NldENvcHlVc2VyRGF0YTpmdW5jdGlvbih0KXt0aGlzLmlzVXNlckRhdGFDb3BpZWQ9dH0sZWRpdDpmdW5jdGlvbih0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciBuPXRoaXMuZWRpdEludGVybmFsKHQsZSk7cmV0dXJuIHRoaXMuaXNVc2VyRGF0YUNvcGllZCYmbi5zZXRVc2VyRGF0YSh0LmdldFVzZXJEYXRhKCkpLG59LGVkaXRJbnRlcm5hbDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpKSx0IGluc3RhbmNlb2YgZnQ/dGhpcy5lZGl0R2VvbWV0cnlDb2xsZWN0aW9uKHQsZSk6dCBpbnN0YW5jZW9mIFR0P3RoaXMuZWRpdFBvbHlnb24odCxlKTp0IGluc3RhbmNlb2YgTHQ/ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTp0IGluc3RhbmNlb2YgU3Q/ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTooZi5zaG91bGROZXZlclJlYWNoSGVyZShcIlVuc3VwcG9ydGVkIEdlb21ldHJ5IGNsYXNzOiBcIit0LmdldENsYXNzKCkuZ2V0TmFtZSgpKSxudWxsKX0sZWRpdEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLmVkaXQodCx0aGlzLmZhY3RvcnkpLGk9bmV3IEkscj0wO3I8bi5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz10aGlzLmVkaXQobi5nZXRHZW9tZXRyeU4ociksZSk7bnVsbD09PXN8fHMuaXNFbXB0eSgpfHxpLmFkZChzKX1yZXR1cm4gbi5nZXRDbGFzcygpPT09UHQ/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoaS50b0FycmF5KFtdKSk6bi5nZXRDbGFzcygpPT09Z3Q/dGhpcy5mYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhpLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1PdD90aGlzLmZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGkudG9BcnJheShbXSkpOnRoaXMuZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaS50b0FycmF5KFtdKSl9LGVkaXRQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5lZGl0KHQsdGhpcy5mYWN0b3J5KTtpZihudWxsPT09biYmKG49dGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24obnVsbCkpLG4uaXNFbXB0eSgpKXJldHVybiBuO3ZhciBpPXRoaXMuZWRpdChuLmdldEV4dGVyaW9yUmluZygpLGUpO2lmKG51bGw9PT1pfHxpLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oKTtmb3IodmFyIHI9bmV3IEkscz0wO3M8bi5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXRoaXMuZWRpdChuLmdldEludGVyaW9yUmluZ04ocyksZSk7bnVsbD09PW98fG8uaXNFbXB0eSgpfHxyLmFkZChvKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oaSxyLnRvQXJyYXkoW10pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3R9fSksX3QuR2VvbWV0cnlFZGl0b3JPcGVyYXRpb249TXQsZShEdC5wcm90b3R5cGUse2VkaXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEdH19KSxlKEF0LnByb3RvdHlwZSx7ZWRpdDpmdW5jdGlvbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBidClyZXR1cm4gZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiBlLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0Q29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpLHQpKTtpZih0IGluc3RhbmNlb2YgTHQpe3ZhciBuPXRoaXMuZWRpdENvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KTtyZXR1cm4gbi5sZW5ndGg+MD9lLmNyZWF0ZVBvaW50KG5bMF0pOmUuY3JlYXRlUG9pbnQoKX1yZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBdH19KSxlKEZ0LnByb3RvdHlwZSx7ZWRpdDpmdW5jdGlvbih0LGUpe3JldHVybiB0IGluc3RhbmNlb2YgYnQ/ZS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgU3Q/ZS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0IGluc3RhbmNlb2YgTHQ/ZS5jcmVhdGVQb2ludCh0aGlzLmVkaXQodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSk6dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTXRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGdH19KSxfdC5Ob09wR2VvbWV0cnlPcGVyYXRpb249RHQsX3QuQ29vcmRpbmF0ZU9wZXJhdGlvbj1BdCxfdC5Db29yZGluYXRlU2VxdWVuY2VPcGVyYXRpb249RnQsZShHdC5wcm90b3R5cGUse3NldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSxuKXtzd2l0Y2goZSl7Y2FzZSBELlg6dGhpcy5jb29yZGluYXRlc1t0XS54PW47YnJlYWs7Y2FzZSBELlk6dGhpcy5jb29yZGluYXRlc1t0XS55PW47YnJlYWs7Y2FzZSBELlo6dGhpcy5jb29yZGluYXRlc1t0XS56PW47YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgaShcImludmFsaWQgb3JkaW5hdGVJbmRleFwiKX19LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlcy5sZW5ndGh9LGdldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSl7c3dpdGNoKGUpe2Nhc2UgRC5YOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLng7Y2FzZSBELlk6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueTtjYXNlIEQuWjpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS56fXJldHVybiByLk5hTn0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF19aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtuLng9dGhpcy5jb29yZGluYXRlc1tlXS54LG4ueT10aGlzLmNvb3JkaW5hdGVzW2VdLnksbi56PXRoaXMuY29vcmRpbmF0ZXNbZV0uen19LGdldENvb3JkaW5hdGVDb3B5OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0aGlzLmNvb3JkaW5hdGVzW3RdKX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGltZW5zaW9ufSxnZXRYOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnh9LGNsb25lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdFtlXT10aGlzLmNvb3JkaW5hdGVzW2VdLmNsb25lKCk7cmV0dXJuIG5ldyBHdCh0LHRoaXMuZGltZW5zaW9uKX0sZXhwYW5kRW52ZWxvcGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aDtlKyspdC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb29yZGluYXRlc1tlXSk7cmV0dXJuIHR9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpLGU9MDtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0W2VdPXRoaXMuY29vcmRpbmF0ZXNbZV0uY29weSgpO3JldHVybiBuZXcgR3QodCx0aGlzLmRpbWVuc2lvbil9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7aWYodGhpcy5jb29yZGluYXRlcy5sZW5ndGg+MCl7dmFyIHQ9bmV3IFAoMTcqdGhpcy5jb29yZGluYXRlcy5sZW5ndGgpO3QuYXBwZW5kKFwiKFwiKSx0LmFwcGVuZCh0aGlzLmNvb3JkaW5hdGVzWzBdKTtmb3IodmFyIGU9MTtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmFwcGVuZChcIiwgXCIpLHQuYXBwZW5kKHRoaXMuY29vcmRpbmF0ZXNbZV0pO3JldHVybiB0LmFwcGVuZChcIilcIiksdC50b1N0cmluZygpfXJldHVyblwiKClcIn0sZ2V0WTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS55fSx0b0Nvb3JkaW5hdGVBcnJheTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltELHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHdH19KSxHdC5zZXJpYWxWZXJzaW9uVUlEPS0weGNiNDRhNzc4ZGIxOGUwMCxlKHF0LnByb3RvdHlwZSx7cmVhZFJlc29sdmU6ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2UoKX0sY3JlYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEd0KHQpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBHdChlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiBpPjMmJihpPTMpLDI+aT9uZXcgR3Qobik6bmV3IEd0KG4saSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltHLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxdH19KSxxdC5pbnN0YW5jZT1mdW5jdGlvbigpe3JldHVybiBxdC5pbnN0YW5jZU9iamVjdH0scXQuc2VyaWFsVmVyc2lvblVJRD0tMHgzOGU0OWZhNmNmNmYyZTAwLHF0Lmluc3RhbmNlT2JqZWN0PW5ldyBxdDt2YXIgbm8saW89T2JqZWN0LmRlZmluZVByb3BlcnR5LHJvPXp0KHtkZWxldGU6a3QsaGFzOlh0LGdldDpZdCxzZXQ6SHQsa2V5czpqdCx2YWx1ZXM6S3QsZW50cmllczpadCxmb3JFYWNoOiR0LGNsZWFyOld0fSksc289XCJ1bmRlZmluZWRcIiE9dHlwZW9mIE1hcCYmTWFwLnByb3RvdHlwZS52YWx1ZXM/TWFwOnJvO3RlLnByb3RvdHlwZT1uZXcgSyx0ZS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm1hcF8uZ2V0KHQpfHxudWxsfSx0ZS5wcm90b3R5cGUucHV0PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWFwXy5zZXQodCxlKSxlfSx0ZS5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5tYXBfLnZhbHVlcygpLG49ZS5uZXh0KCk7IW4uZG9uZTspdC5hZGQobi52YWx1ZSksbj1lLm5leHQoKTtyZXR1cm4gdH0sdGUucHJvdG90eXBlLmVudHJ5U2V0PWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEo7cmV0dXJuIHRoaXMubWFwXy5lbnRyaWVzKCkuZm9yRWFjaChmdW5jdGlvbihlKXtyZXR1cm4gdC5hZGQoZSl9KSx0fSx0ZS5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLm1hcF8uc2l6ZSgpfSxlKGVlLnByb3RvdHlwZSx7ZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIGVlKSlyZXR1cm4hMTt2YXIgZT10O3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWUubW9kZWxUeXBlJiZ0aGlzLnNjYWxlPT09ZS5zY2FsZX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpLGk9ZS5nZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHMoKTtyZXR1cm4gbmV3IGIobikuY29tcGFyZVRvKG5ldyBiKGkpKX0sZ2V0U2NhbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zY2FsZX0saXNGbG9hdGluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HfHx0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRX0sZ2V0VHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vZGVsVHlwZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1cIlVOS05PV05cIjtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORz90PVwiRmxvYXRpbmdcIjp0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HX1NJTkdMRT90PVwiRmxvYXRpbmctU2luZ2xlXCI6dGhpcy5tb2RlbFR5cGU9PT1lZS5GSVhFRCYmKHQ9XCJGaXhlZCAoU2NhbGU9XCIrdGhpcy5nZXRTY2FsZSgpK1wiKVwiKSx0fSxtYWtlUHJlY2lzZTpmdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtpZihyLmlzTmFOKHQpKXJldHVybiB0O2lmKHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFKXt2YXIgZT10O3JldHVybiBlfXJldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEP01hdGgucm91bmQodCp0aGlzLnNjYWxlKS90aGlzLnNjYWxlOnR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORylyZXR1cm4gbnVsbDtuLng9dGhpcy5tYWtlUHJlY2lzZShuLngpLG4ueT10aGlzLm1ha2VQcmVjaXNlKG4ueSl9fSxnZXRNYXhpbXVtU2lnbmlmaWNhbnREaWdpdHM6ZnVuY3Rpb24oKXt2YXIgdD0xNjtyZXR1cm4gdGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElORz90PTE2OnRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFP3Q9Njp0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEJiYodD0xK01hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGgubG9nKHRoaXMuZ2V0U2NhbGUoKSkvTWF0aC5sb2coMTApKSkpLHR9LHNldFNjYWxlOmZ1bmN0aW9uKHQpe3RoaXMuc2NhbGU9TWF0aC5hYnModCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3Usc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVlfX0pLGVlLm1vc3RQcmVjaXNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpPj0wP3Q6ZX0sZShuZS5wcm90b3R5cGUse3JlYWRSZXNvbHZlOmZ1bmN0aW9uKCl7cmV0dXJuIG5lLm5hbWVUb1R5cGVNYXAuZ2V0KHRoaXMubmFtZSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmFtZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5lfX0pLG5lLnNlcmlhbFZlcnNpb25VSUQ9LTU1Mjg2MDI2MzE3MzE1OWU0LG5lLm5hbWVUb1R5cGVNYXA9bmV3IHRlLGVlLlR5cGU9bmUsZWUuc2VyaWFsVmVyc2lvblVJRD0weDZiZWU2NDA0ZTlhMjVjMDAsZWUuRklYRUQ9bmV3IG5lKFwiRklYRURcIiksZWUuRkxPQVRJTkc9bmV3IG5lKFwiRkxPQVRJTkdcIiksZWUuRkxPQVRJTkdfU0lOR0xFPW5ldyBuZShcIkZMT0FUSU5HIFNJTkdMRVwiKSxlZS5tYXhpbXVtUHJlY2lzZVZhbHVlPTkwMDcxOTkyNTQ3NDA5OTIsZShpZS5wcm90b3R5cGUse3RvR2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNOdWxsKCk/dGhpcy5jcmVhdGVQb2ludChudWxsKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpJiZ0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlUG9pbnQobmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpKTp0LmdldE1pblgoKT09PXQuZ2V0TWF4WCgpfHx0LmdldE1pblkoKT09PXQuZ2V0TWF4WSgpP3RoaXMuY3JlYXRlTGluZVN0cmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWF4WSgpKV0pOnRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpLG5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKSxuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSldKSxudWxsKX0sY3JlYXRlTGluZVN0cmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lU3RyaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgU3QoZSx0aGlzKX19fSxjcmVhdGVNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IGd0KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGd0KHQsdGhpcyl9fSxidWlsZEdlb21ldHJ5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49ITEsaT0hMSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRDbGFzcygpO251bGw9PT1lJiYoZT1vKSxvIT09ZSYmKG49ITApLHMuaXNHZW9tZXRyeUNvbGxlY3Rpb25PckRlcml2ZWQoKSYmKGk9ITApfWlmKG51bGw9PT1lKXJldHVybiB0aGlzLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpO2lmKG58fGkpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGllLnRvR2VvbWV0cnlBcnJheSh0KSk7dmFyIGE9dC5pdGVyYXRvcigpLm5leHQoKSx1PXQuc2l6ZSgpPjE7aWYodSl7aWYoYSBpbnN0YW5jZW9mIFR0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9seWdvbihpZS50b1BvbHlnb25BcnJheSh0KSk7aWYoYSBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpTGluZVN0cmluZyhpZS50b0xpbmVTdHJpbmdBcnJheSh0KSk7aWYoYSBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoaWUudG9Qb2ludEFycmF5KHQpKTtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5oYW5kbGVkIGNsYXNzOiBcIithLmdldENsYXNzKCkuZ2V0TmFtZSgpKX1yZXR1cm4gYX0sY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9LGNyZWF0ZVBvaW50OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbdF0pOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBMdChlLHRoaXMpfX19LGdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5fSxjcmVhdGVQb2x5Z29uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBUdChudWxsLG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbih0aGlzLmNyZWF0ZUxpbmVhclJpbmcodCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhlKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24obixudWxsKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3JldHVybiBuZXcgVHQoaSxyLHRoaXMpfX0sZ2V0U1JJRDpmdW5jdGlvbigpe3JldHVybiB0aGlzLlNSSUR9LGNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZnQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZnQodCx0aGlzKX19LGNyZWF0ZUdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBfdCh0aGlzKTtyZXR1cm4gZS5lZGl0KHQse2VkaXQ6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2FyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5LmNyZWF0ZSh0KX19fSl9LGdldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWx9LGNyZWF0ZUxpbmVhclJpbmc6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTGluZWFyUmluZyhudWxsIT09dD90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IGJ0KGUsdGhpcyl9fX0sY3JlYXRlTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBPdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBPdCh0LHRoaXMpfX0sY3JlYXRlTXVsdGlQb2ludDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgUHQobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgUHQodCx0aGlzKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChudWxsIT09ZT90aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoZSk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZihudWxsPT09bilyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG5ldyBBcnJheSgwKS5maWxsKG51bGwpKTtmb3IodmFyIGk9bmV3IEFycmF5KG4uc2l6ZSgpKS5maWxsKG51bGwpLHI9MDtyPG4uc2l6ZSgpO3IrKyl7dmFyIHM9dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKDEsbi5nZXREaW1lbnNpb24oKSk7Q3QuY29weShuLHIscywwLDEpLGlbcl09dGhpcy5jcmVhdGVQb2ludChzKX1yZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KGkpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBpZX19KSxpZS50b011bHRpUG9seWdvbkFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0dlb21ldHJ5QXJyYXk9ZnVuY3Rpb24odCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PWZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlKCl9LGllLnRvTXVsdGlMaW5lU3RyaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTGluZVN0cmluZ0FycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b011bHRpUG9pbnRBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9MaW5lYXJSaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvUG9pbnRBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9Qb2x5Z29uQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRQcmVjaXNpb25Nb2RlbCgpLm1ha2VQcmVjaXNlKHQpLGUuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHQpfSxpZS5zZXJpYWxWZXJzaW9uVUlEPS0weDVlYTc1ZjIwNTFlZWI0MDA7dmFyIG9vPXt0eXBlU3RyOi9eXFxzKihcXHcrKVxccypcXChcXHMqKC4qKVxccypcXClcXHMqJC8sZW1wdHlUeXBlU3RyOi9eXFxzKihcXHcrKVxccypFTVBUWVxccyokLyxzcGFjZXM6L1xccysvLHBhcmVuQ29tbWE6L1xcKVxccyosXFxzKlxcKC8sZG91YmxlUGFyZW5Db21tYTovXFwpXFxzKlxcKVxccyosXFxzKlxcKFxccypcXCgvLHRyaW1QYXJlbnM6L15cXHMqXFwoPyguKj8pXFwpP1xccyokL307ZShyZS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGUsbixpO3Q9dC5yZXBsYWNlKC9bXFxuXFxyXS9nLFwiIFwiKTt2YXIgcj1vby50eXBlU3RyLmV4ZWModCk7aWYoLTEhPT10LnNlYXJjaChcIkVNUFRZXCIpJiYocj1vby5lbXB0eVR5cGVTdHIuZXhlYyh0KSxyWzJdPXZvaWQgMCksciYmKG49clsxXS50b0xvd2VyQ2FzZSgpLGk9clsyXSx1b1tuXSYmKGU9dW9bbl0uYXBwbHkodGhpcyxbaV0pKSksdm9pZCAwPT09ZSl0aHJvdyBuZXcgRXJyb3IoXCJDb3VsZCBub3QgcGFyc2UgV0tUIFwiK3QpO3JldHVybiBlfSx3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0R2VvbWV0cnkodCl9LGV4dHJhY3RHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT10LmdldEdlb21ldHJ5VHlwZSgpLnRvTG93ZXJDYXNlKCk7aWYoIWFvW2VdKXJldHVybiBudWxsO3ZhciBuLGk9ZS50b1VwcGVyQ2FzZSgpO3JldHVybiBuPXQuaXNFbXB0eSgpP2krXCIgRU1QVFlcIjppK1wiKFwiK2FvW2VdLmFwcGx5KHRoaXMsW3RdKStcIilcIn19KTt2YXIgYW89e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHQueCtcIiBcIit0Lnl9LHBvaW50OmZ1bmN0aW9uKHQpe1xucmV0dXJuIGFvLmNvb3JkaW5hdGUuY2FsbCh0aGlzLHQuY29vcmRpbmF0ZXMuY29vcmRpbmF0ZXNbMF0pfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvaW50LmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKGFvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbdC5wb2ludHMuY29vcmRpbmF0ZXNbbl1dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtpPm47KytuKWUucHVzaChhby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QucG9pbnRzLmNvb3JkaW5hdGVzW25dXSkpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LHBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9W107ZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5zaGVsbF0pK1wiKVwiKTtmb3IodmFyIG49MCxpPXQuaG9sZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbdC5ob2xlc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10Lmdlb21ldHJpZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKFwiKFwiK2FvLnBvbHlnb24uYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2godGhpcy5leHRyYWN0R2VvbWV0cnkodC5nZW9tZXRyaWVzW25dKSk7cmV0dXJuIGUuam9pbihcIixcIil9fSx1bz17cG9pbnQ6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgZT10LnRyaW0oKS5zcGxpdChvby5zcGFjZXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpfSxtdWx0aXBvaW50OmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ucG9pbnQuYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChpKX0sbGluZXN0cmluZzpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0udHJpbSgpLnNwbGl0KG9vLnNwYWNlcyksaS5wdXNoKG5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoaSl9LGxpbmVhcnJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZygpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnRyaW0oKS5zcGxpdChvby5zcGFjZXMpLGkucHVzaChuZXcgZyhOdW1iZXIucGFyc2VGbG9hdChlWzBdKSxOdW1iZXIucGFyc2VGbG9hdChlWzFdKSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGkpfSxtdWx0aWxpbmVzdHJpbmc6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQob28ucGFyZW5Db21tYSksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFtlXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoaSl9LHBvbHlnb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2Zvcih2YXIgZSxuLGkscixzPXQudHJpbSgpLnNwbGl0KG9vLnBhcmVuQ29tbWEpLG89W10sYT0wLHU9cy5sZW5ndGg7dT5hOysrYSllPXNbYV0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksbj11by5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW2VdKSxpPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcobi5wb2ludHMpLDA9PT1hP3I9aTpvLnB1c2goaSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24ocixvKX0sbXVsdGlwb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9seWdvbigpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KG9vLmRvdWJsZVBhcmVuQ29tbWEpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0ucmVwbGFjZShvby50cmltUGFyZW5zLFwiJDFcIiksaS5wdXNoKHVvLnBvbHlnb24uYXBwbHkodGhpcyxbZV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGkpfSxnZW9tZXRyeWNvbGxlY3Rpb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7dD10LnJlcGxhY2UoLyxcXHMqKFtBLVphLXpdKS9nLFwifCQxXCIpO2Zvcih2YXIgZT10LnRyaW0oKS5zcGxpdChcInxcIiksbj1bXSxpPTAscj1lLmxlbmd0aDtyPmk7KytpKW4ucHVzaCh0aGlzLnJlYWQoZVtpXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obil9fTtlKHNlLnByb3RvdHlwZSx7d3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0pLGUoc2Use3RvTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXRocm93IG5ldyBFcnJvcihcIk5vdCBpbXBsZW1lbnRlZFwiKTtyZXR1cm5cIkxJTkVTVFJJTkcgKCBcIit0LngrXCIgXCIrdC55K1wiLCBcIitlLngrXCIgXCIrZS55K1wiIClcIn19KSxlKG9lLnByb3RvdHlwZSx7Z2V0SW5kZXhBbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRMaW5lSW5kZXhbdF1bZV19LGdldFRvcG9sb2d5U3VtbWFyeTpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmlzRW5kUG9pbnQoKSYmdC5hcHBlbmQoXCIgZW5kcG9pbnRcIiksdGhpcy5faXNQcm9wZXImJnQuYXBwZW5kKFwiIHByb3BlclwiKSx0aGlzLmlzQ29sbGluZWFyKCkmJnQuYXBwZW5kKFwiIGNvbGxpbmVhclwiKSx0LnRvU3RyaW5nKCl9LGNvbXB1dGVJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dGhpcy5pbnB1dExpbmVzWzBdWzBdPXQsdGhpcy5pbnB1dExpbmVzWzBdWzFdPWUsdGhpcy5pbnB1dExpbmVzWzFdWzBdPW4sdGhpcy5pbnB1dExpbmVzWzFdWzFdPWksdGhpcy5yZXN1bHQ9dGhpcy5jb21wdXRlSW50ZXJzZWN0KHQsZSxuLGkpfSxnZXRJbnRlcnNlY3Rpb25OdW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHR9LGNvbXB1dGVJbnRMaW5lSW5kZXg6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCludWxsPT09dGhpcy5pbnRMaW5lSW5kZXgmJih0aGlzLmludExpbmVJbmRleD1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDIpfSksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDApLHRoaXMuY29tcHV0ZUludExpbmVJbmRleCgxKSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwwKSxuPXRoaXMuZ2V0RWRnZURpc3RhbmNlKHQsMSk7ZT5uPyh0aGlzLmludExpbmVJbmRleFt0XVswXT0wLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTEpOih0aGlzLmludExpbmVJbmRleFt0XVswXT0xLHRoaXMuaW50TGluZUluZGV4W3RdWzFdPTApfX0saXNQcm9wZXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5faXNQcm9wZXJ9LHNldFByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMucHJlY2lzaW9uTW9kZWw9dH0saXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMCk/ITA6ISF0aGlzLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oMSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dGhpcy5yZXN1bHQ7ZSsrKWlmKCF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVswXSkmJiF0aGlzLmludFB0W2VdLmVxdWFsczJEKHRoaXMuaW5wdXRMaW5lc1t0XVsxXSkpcmV0dXJuITA7cmV0dXJuITF9fSxnZXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaW50UHRbdF19LGlzRW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb24oKSYmIXRoaXMuX2lzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQhPT1vZS5OT19JTlRFUlNFQ1RJT059LGdldEVkZ2VEaXN0YW5jZTpmdW5jdGlvbih0LGUpe3ZhciBuPW9lLmNvbXB1dGVFZGdlRGlzdGFuY2UodGhpcy5pbnRQdFtlXSx0aGlzLmlucHV0TGluZXNbdF1bMF0sdGhpcy5pbnB1dExpbmVzW3RdWzFdKTtyZXR1cm4gbn0saXNDb2xsaW5lYXI6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yZXN1bHQ9PT1vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSkrXCIgLSBcIitzZS50b0xpbmVTdHJpbmcodGhpcy5pbnB1dExpbmVzWzFdWzBdLHRoaXMuaW5wdXRMaW5lc1sxXVsxXSkrdGhpcy5nZXRUb3BvbG9neVN1bW1hcnkoKX0sZ2V0RW5kcG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pbnB1dExpbmVzW3RdW2VdfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMucmVzdWx0O2UrKylpZih0aGlzLmludFB0W2VdLmVxdWFsczJEKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRJbnRlcnNlY3Rpb25BbG9uZ1NlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb21wdXRlSW50TGluZUluZGV4KCksdGhpcy5pbnRQdFt0aGlzLmludExpbmVJbmRleFt0XVtlXV19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9lfX0pLG9lLmNvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPU1hdGguYWJzKG4ueC1lLngpLHI9TWF0aC5hYnMobi55LWUueSkscz0tMTtpZih0LmVxdWFscyhlKSlzPTA7ZWxzZSBpZih0LmVxdWFscyhuKSlzPWk+cj9pOnI7ZWxzZXt2YXIgbz1NYXRoLmFicyh0LngtZS54KSxhPU1hdGguYWJzKHQueS1lLnkpO3M9aT5yP286YSwwIT09c3x8dC5lcXVhbHMoZSl8fChzPU1hdGgubWF4KG8sYSkpfXJldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiQmFkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHN9LG9lLm5vblJvYnVzdENvbXB1dGVFZGdlRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9TWF0aC5zcXJ0KGkqaStyKnIpO3JldHVybiBmLmlzVHJ1ZSghKDA9PT1zJiYhdC5lcXVhbHMoZSkpLFwiSW52YWxpZCBkaXN0YW5jZSBjYWxjdWxhdGlvblwiKSxzfSxvZS5ET05UX0lOVEVSU0VDVD0wLG9lLkRPX0lOVEVSU0VDVD0xLG9lLkNPTExJTkVBUj0yLG9lLk5PX0lOVEVSU0VDVElPTj0wLG9lLlBPSU5UX0lOVEVSU0VDVElPTj0xLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT049MixoKGFlLG9lKSxlKGFlLnByb3RvdHlwZSx7aXNJblNlZ21lbnRFbnZlbG9wZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEModGhpcy5pbnB1dExpbmVzWzBdWzBdLHRoaXMuaW5wdXRMaW5lc1swXVsxXSksbj1uZXcgQyh0aGlzLmlucHV0TGluZXNbMV1bMF0sdGhpcy5pbnB1dExpbmVzWzFdWzFdKTtyZXR1cm4gZS5jb250YWlucyh0KSYmbi5jb250YWlucyh0KX0sY29tcHV0ZUludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDMhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBvZS5wcm90b3R5cGUuY29tcHV0ZUludGVyc2VjdGlvbi5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3JldHVybiB0aGlzLl9pc1Byb3Blcj0hMSxDLmludGVyc2VjdHMoZSxuLHQpJiYwPT09aGUub3JpZW50YXRpb25JbmRleChlLG4sdCkmJjA9PT1oZS5vcmllbnRhdGlvbkluZGV4KG4sZSx0KT8odGhpcy5faXNQcm9wZXI9ITAsKHQuZXF1YWxzKGUpfHx0LmVxdWFscyhuKSkmJih0aGlzLl9pc1Byb3Blcj0hMSksdGhpcy5yZXN1bHQ9b2UuUE9JTlRfSU5URVJTRUNUSU9OLG51bGwpOnZvaWQodGhpcy5yZXN1bHQ9b2UuTk9fSU5URVJTRUNUSU9OKX0sbm9ybWFsaXplVG9NaW5pbXVtOmZ1bmN0aW9uKHQsZSxuLGkscil7ci54PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueCxlLngsbi54LGkueCksci55PXRoaXMuc21hbGxlc3RJbkFic1ZhbHVlKHQueSxlLnksbi55LGkueSksdC54LT1yLngsdC55LT1yLnksZS54LT1yLngsZS55LT1yLnksbi54LT1yLngsbi55LT1yLnksaS54LT1yLngsaS55LT1yLnl9LHNhZmVIQ29vcmRpbmF0ZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3RyeXtyPUYuaW50ZXJzZWN0aW9uKHQsZSxuLGkpfWNhdGNoKHMpe2lmKCEocyBpbnN0YW5jZW9mIHcpKXRocm93IHM7cj1hZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSl9ZmluYWxseXt9cmV0dXJuIHJ9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uKHQsZSxuLGkpO3JldHVybiB0aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHIpfHwocj1uZXcgZyhhZS5uZWFyZXN0RW5kcG9pbnQodCxlLG4saSkpKSxudWxsIT09dGhpcy5wcmVjaXNpb25Nb2RlbCYmdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShyKSxyfSxzbWFsbGVzdEluQWJzVmFsdWU6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPU1hdGguYWJzKHIpO3JldHVybiBNYXRoLmFicyhlKTxzJiYocj1lLHM9TWF0aC5hYnMoZSkpLE1hdGguYWJzKG4pPHMmJihyPW4scz1NYXRoLmFicyhuKSksTWF0aC5hYnMoaSk8cyYmKHI9aSkscn0sY2hlY2tERDpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPU0uaW50ZXJzZWN0aW9uKHQsZSxuLGkpLG89dGhpcy5pc0luU2VnbWVudEVudmVsb3BlcyhzKTtBLm91dC5wcmludGxuKFwiREQgaW4gZW52ID0gXCIrbytcIiAgLS0tLS0tLS0tLS0tLS0tLS0tLS0tIFwiK3MpLHIuZGlzdGFuY2Uocyk+MWUtNCYmQS5vdXQucHJpbnRsbihcIkRpc3RhbmNlID0gXCIrci5kaXN0YW5jZShzKSl9LGludGVyc2VjdGlvbldpdGhOb3JtYWxpemF0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBnKHQpLHM9bmV3IGcoZSksbz1uZXcgZyhuKSxhPW5ldyBnKGkpLHU9bmV3IGc7dGhpcy5ub3JtYWxpemVUb0VudkNlbnRyZShyLHMsbyxhLHUpO3ZhciBsPXRoaXMuc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpO3JldHVybiBsLngrPXUueCxsLnkrPXUueSxsfSxjb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPUMuaW50ZXJzZWN0cyh0LGUsbikscz1DLmludGVyc2VjdHModCxlLGkpLG89Qy5pbnRlcnNlY3RzKG4saSx0KSxhPUMuaW50ZXJzZWN0cyhuLGksZSk7cmV0dXJuIHImJnM/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPWksb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTik6byYmYT8odGhpcy5pbnRQdFswXT10LHRoaXMuaW50UHRbMV09ZSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpyJiZvPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT10LCFuLmVxdWFscyh0KXx8c3x8YT9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6ciYmYT8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09ZSwhbi5lcXVhbHMoZSl8fHN8fG8/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnMmJm8/KHRoaXMuaW50UHRbMF09aSx0aGlzLmludFB0WzFdPXQsIWkuZXF1YWxzKHQpfHxyfHxhP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpzJiZhPyh0aGlzLmludFB0WzBdPWksdGhpcy5pbnRQdFsxXT1lLCFpLmVxdWFscyhlKXx8cnx8bz9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6b2UuTk9fSU5URVJTRUNUSU9OfSxub3JtYWxpemVUb0VudkNlbnRyZTpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPXQueDxlLng/dC54OmUueCxvPXQueTxlLnk/dC55OmUueSxhPXQueD5lLng/dC54OmUueCx1PXQueT5lLnk/dC55OmUueSxsPW4ueDxpLng/bi54OmkueCxoPW4ueTxpLnk/bi55OmkueSxjPW4ueD5pLng/bi54OmkueCxmPW4ueT5pLnk/bi55OmkueSxnPXM+bD9zOmwsZD1jPmE/YTpjLHA9bz5oP286aCx2PWY+dT91OmYsbT0oZytkKS8yLHk9KHArdikvMjtyLng9bSxyLnk9eSx0LngtPXIueCx0LnktPXIueSxlLngtPXIueCxlLnktPXIueSxuLngtPXIueCxuLnktPXIueSxpLngtPXIueCxpLnktPXIueX0sY29tcHV0ZUludGVyc2VjdDpmdW5jdGlvbih0LGUsbixpKXtpZih0aGlzLl9pc1Byb3Blcj0hMSwhQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIHI9aGUub3JpZW50YXRpb25JbmRleCh0LGUsbikscz1oZS5vcmllbnRhdGlvbkluZGV4KHQsZSxpKTtpZihyPjAmJnM+MHx8MD5yJiYwPnMpcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgbz1oZS5vcmllbnRhdGlvbkluZGV4KG4saSx0KSxhPWhlLm9yaWVudGF0aW9uSW5kZXgobixpLGUpO2lmKG8+MCYmYT4wfHwwPm8mJjA+YSlyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciB1PTA9PT1yJiYwPT09cyYmMD09PW8mJjA9PT1hO3JldHVybiB1P3RoaXMuY29tcHV0ZUNvbGxpbmVhckludGVyc2VjdGlvbih0LGUsbixpKTooMD09PXJ8fDA9PT1zfHwwPT09b3x8MD09PWE/KHRoaXMuX2lzUHJvcGVyPSExLHQuZXF1YWxzMkQobil8fHQuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT10OmUuZXF1YWxzMkQobil8fGUuZXF1YWxzMkQoaSk/dGhpcy5pbnRQdFswXT1lOjA9PT1yP3RoaXMuaW50UHRbMF09bmV3IGcobik6MD09PXM/dGhpcy5pbnRQdFswXT1uZXcgZyhpKTowPT09bz90aGlzLmludFB0WzBdPW5ldyBnKHQpOjA9PT1hJiYodGhpcy5pbnRQdFswXT1uZXcgZyhlKSkpOih0aGlzLl9pc1Byb3Blcj0hMCx0aGlzLmludFB0WzBdPXRoaXMuaW50ZXJzZWN0aW9uKHQsZSxuLGkpKSxvZS5QT0lOVF9JTlRFUlNFQ1RJT04pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhZX19KSxhZS5uZWFyZXN0RW5kcG9pbnQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dCxzPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsbixpKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKTtyZXR1cm4gcz5vJiYocz1vLHI9ZSksbz1oZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSkscz5vJiYocz1vLHI9biksbz1oZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSkscz5vJiYocz1vLHI9aSkscn0sZSh1ZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVlfX0pLHVlLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9bi54LWUueCxvPW4ueS1lLnk7cmV0dXJuIHVlLnNpZ25PZkRldDJ4MihpLHIscyxvKX0sdWUuc2lnbk9mRGV0MngyPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGwscz1udWxsLG89bnVsbCxhPTA7aWYocj0xLDA9PT10fHwwPT09aSlyZXR1cm4gMD09PWV8fDA9PT1uPzA6ZT4wP24+MD8tcjpyOm4+MD9yOi1yO2lmKDA9PT1lfHwwPT09bilyZXR1cm4gaT4wP3Q+MD9yOi1yOnQ+MD8tcjpyO2lmKGU+MD9pPjA/aT49ZXx8KHI9LXIscz10LHQ9bixuPXMscz1lLGU9aSxpPXMpOi1pPj1lPyhyPS1yLG49LW4saT0taSk6KHM9dCx0PS1uLG49cyxzPWUsZT0taSxpPXMpOmk+MD9pPj0tZT8ocj0tcix0PS10LGU9LWUpOihzPS10LHQ9bixuPXMscz0tZSxlPWksaT1zKTplPj1pPyh0PS10LGU9LWUsbj0tbixpPS1pKToocj0tcixzPS10LHQ9LW4sbj1zLHM9LWUsZT0taSxpPXMpLHQ+MCl7aWYoIShuPjApKXJldHVybiByO2lmKCEobj49dCkpcmV0dXJuIHJ9ZWxzZXtpZihuPjApcmV0dXJuLXI7aWYoISh0Pj1uKSlyZXR1cm4tcjtyPS1yLHQ9LXQsbj0tbn1mb3IoOzspe2lmKGErPTEsbz1NYXRoLmZsb29yKG4vdCksbi09byp0LGktPW8qZSwwPmkpcmV0dXJuLXI7aWYoaT5lKXJldHVybiByO2lmKHQ+bituKXtpZihpK2k+ZSlyZXR1cm4gcn1lbHNle2lmKGU+aStpKXJldHVybi1yO249dC1uLGk9ZS1pLHI9LXJ9aWYoMD09PWkpcmV0dXJuIDA9PT1uPzA6LXI7aWYoMD09PW4pcmV0dXJuIHI7aWYobz1NYXRoLmZsb29yKHQvbiksdC09bypuLGUtPW8qaSwwPmUpcmV0dXJuIHI7aWYoZT5pKXJldHVybi1yO2lmKG4+dCt0KXtpZihlK2U+aSlyZXR1cm4tcn1lbHNle2lmKGk+ZStlKXJldHVybiByO3Q9bi10LGU9aS1lLHI9LXJ9aWYoMD09PWUpcmV0dXJuIDA9PT10PzA6cjtpZigwPT09dClyZXR1cm4tcn19LGUobGUucHJvdG90eXBlLHtjb3VudFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtpZih0Lng8dGhpcy5wLngmJmUueDx0aGlzLnAueClyZXR1cm4gbnVsbDtpZih0aGlzLnAueD09PWUueCYmdGhpcy5wLnk9PT1lLnkpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO2lmKHQueT09PXRoaXMucC55JiZlLnk9PT10aGlzLnAueSl7dmFyIG49dC54LGk9ZS54O3JldHVybiBuPmkmJihuPWUueCxpPXQueCksdGhpcy5wLng+PW4mJnRoaXMucC54PD1pJiYodGhpcy5pc1BvaW50T25TZWdtZW50PSEwKSxudWxsfWlmKHQueT50aGlzLnAueSYmZS55PD10aGlzLnAueXx8ZS55PnRoaXMucC55JiZ0Lnk8PXRoaXMucC55KXt2YXIgcj10LngtdGhpcy5wLngscz10LnktdGhpcy5wLnksbz1lLngtdGhpcy5wLngsYT1lLnktdGhpcy5wLnksdT11ZS5zaWduT2ZEZXQyeDIocixzLG8sYSk7aWYoMD09PXUpcmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD0hMCxudWxsO3M+YSYmKHU9LXUpLHU+MCYmdGhpcy5jcm9zc2luZ0NvdW50Kyt9fSxpc1BvaW50SW5Qb2x5Z29uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb24oKSE9PUwuRVhURVJJT1J9LGdldExvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudD9MLkJPVU5EQVJZOnRoaXMuY3Jvc3NpbmdDb3VudCUyPT09MT9MLklOVEVSSU9SOkwuRVhURVJJT1J9LGlzT25TZWdtZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNQb2ludE9uU2VnbWVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbGV9fSksbGUubG9jYXRlUG9pbnRJblJpbmc9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlIoYXJndW1lbnRzWzFdLEQpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IGxlKHQpLGk9bmV3IGcscj1uZXcgZyxzPTE7czxlLnNpemUoKTtzKyspaWYoZS5nZXRDb29yZGluYXRlKHMsaSksZS5nZXRDb29yZGluYXRlKHMtMSxyKSxuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpO3JldHVybiBuLmdldExvY2F0aW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLG49bmV3IGxlKG8pLHM9MTtzPGEubGVuZ3RoO3MrKyl7dmFyIGk9YVtzXSxyPWFbcy0xXTtpZihuLmNvdW50U2VnbWVudChpLHIpLG4uaXNPblNlZ21lbnQoKSlyZXR1cm4gbi5nZXRMb2NhdGlvbigpfXJldHVybiBuLmdldExvY2F0aW9uKCl9fSxlKGhlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGV9fSksaGUub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7cmV0dXJuIE0ub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLnNpZ25lZEFyZWE9ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5sZW5ndGg8MylyZXR1cm4gMDtmb3IodmFyIGU9MCxuPXRbMF0ueCxpPTE7aTx0Lmxlbmd0aC0xO2krKyl7dmFyIHI9dFtpXS54LW4scz10W2krMV0ueSxvPXRbaS0xXS55O2UrPXIqKG8tcyl9cmV0dXJuIGUvMn1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YS5zaXplKCk7aWYoMz51KXJldHVybiAwO3ZhciBsPW5ldyBnLGg9bmV3IGcsYz1uZXcgZzthLmdldENvb3JkaW5hdGUoMCxoKSxhLmdldENvb3JkaW5hdGUoMSxjKTt2YXIgbj1oLng7Yy54LT1uO2Zvcih2YXIgZT0wLGk9MTt1LTE+aTtpKyspbC55PWgueSxoLng9Yy54LGgueT1jLnksYS5nZXRDb29yZGluYXRlKGkrMSxjKSxjLngtPW4sZSs9aC54KihsLnktYy55KTtyZXR1cm4gZS8yfX0saGUuZGlzdGFuY2VMaW5lTGluZT1mdW5jdGlvbih0LGUsbixpKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpO2lmKG4uZXF1YWxzKGkpKXJldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSk7dmFyIHI9ITE7aWYoQy5pbnRlcnNlY3RzKHQsZSxuLGkpKXt2YXIgcz0oZS54LXQueCkqKGkueS1uLnkpLShlLnktdC55KSooaS54LW4ueCk7aWYoMD09PXMpcj0hMDtlbHNle3ZhciBvPSh0Lnktbi55KSooaS54LW4ueCktKHQueC1uLngpKihpLnktbi55KSxhPSh0Lnktbi55KSooZS54LXQueCktKHQueC1uLngpKihlLnktdC55KSx1PWEvcyxsPW8vczsoMD5sfHxsPjF8fDA+dXx8dT4xKSYmKHI9ITApfX1lbHNlIHI9ITA7cmV0dXJuIHI/VC5taW4oaGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsbixpKSxoZS5kaXN0YW5jZVBvaW50TGluZShuLHQsZSksaGUuZGlzdGFuY2VQb2ludExpbmUoaSx0LGUpKTowfSxoZS5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGhlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSkhPT1MLkVYVEVSSU9SfSxoZS5jb21wdXRlTGVuZ3RoPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2l6ZSgpO2lmKDE+PWUpcmV0dXJuIDA7dmFyIG49MCxpPW5ldyBnO3QuZ2V0Q29vcmRpbmF0ZSgwLGkpO2Zvcih2YXIgcj1pLngscz1pLnksbz0xO2U+bztvKyspe3QuZ2V0Q29vcmRpbmF0ZShvLGkpO3ZhciBhPWkueCx1PWkueSxsPWEtcixoPXUtcztuKz1NYXRoLnNxcnQobCpsK2gqaCkscj1hLHM9dX1yZXR1cm4gbn0saGUuaXNDQ1c9ZnVuY3Rpb24odCl7dmFyIGU9dC5sZW5ndGgtMTtpZigzPmUpdGhyb3cgbmV3IGkoXCJSaW5nIGhhcyBmZXdlciB0aGFuIDQgcG9pbnRzLCBzbyBvcmllbnRhdGlvbiBjYW5ub3QgYmUgZGV0ZXJtaW5lZFwiKTtmb3IodmFyIG49dFswXSxyPTAscz0xO2U+PXM7cysrKXt2YXIgbz10W3NdO28ueT5uLnkmJihuPW8scj1zKX12YXIgYT1yO2RvIGEtPTEsMD5hJiYoYT1lKTt3aGlsZSh0W2FdLmVxdWFsczJEKG4pJiZhIT09cik7dmFyIHU9cjtkbyB1PSh1KzEpJWU7d2hpbGUodFt1XS5lcXVhbHMyRChuKSYmdSE9PXIpO3ZhciBsPXRbYV0saD10W3VdO2lmKGwuZXF1YWxzMkQobil8fGguZXF1YWxzMkQobil8fGwuZXF1YWxzMkQoaCkpcmV0dXJuITE7dmFyIGM9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGwsbixoKSxmPSExO3JldHVybiBmPTA9PT1jP2wueD5oLng6Yz4wfSxoZS5sb2NhdGVQb2ludEluUmluZz1mdW5jdGlvbih0LGUpe3JldHVybiBsZS5sb2NhdGVQb2ludEluUmluZyh0LGUpfSxoZS5kaXN0YW5jZVBvaW50TGluZVBlcnBlbmRpY3VsYXI9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPShuLngtZS54KSoobi54LWUueCkrKG4ueS1lLnkpKihuLnktZS55KSxyPSgoZS55LXQueSkqKG4ueC1lLngpLShlLngtdC54KSoobi55LWUueSkpL2k7cmV0dXJuIE1hdGguYWJzKHIpKk1hdGguc3FydChpKX0saGUuY29tcHV0ZU9yaWVudGF0aW9uPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGUub3JpZW50YXRpb25JbmRleCh0LGUsbil9LGhlLmRpc3RhbmNlUG9pbnRMaW5lPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09ZS5sZW5ndGgpdGhyb3cgbmV3IGkoXCJMaW5lIGFycmF5IG11c3QgY29udGFpbiBhdCBsZWFzdCBvbmUgdmVydGV4XCIpO2Zvcih2YXIgbj10LmRpc3RhbmNlKGVbMF0pLHI9MDtyPGUubGVuZ3RoLTE7cisrKXt2YXIgcz1oZS5kaXN0YW5jZVBvaW50TGluZSh0LGVbcl0sZVtyKzFdKTtuPnMmJihuPXMpfXJldHVybiBufWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl07aWYoYS54PT09dS54JiZhLnk9PT11LnkpcmV0dXJuIG8uZGlzdGFuY2UoYSk7dmFyIGw9KHUueC1hLngpKih1LngtYS54KSsodS55LWEueSkqKHUueS1hLnkpLGg9KChvLngtYS54KSoodS54LWEueCkrKG8ueS1hLnkpKih1LnktYS55KSkvbDtpZigwPj1oKXJldHVybiBvLmRpc3RhbmNlKGEpO2lmKGg+PTEpcmV0dXJuIG8uZGlzdGFuY2UodSk7dmFyIGM9KChhLnktby55KSoodS54LWEueCktKGEueC1vLngpKih1LnktYS55KSkvbDtyZXR1cm4gTWF0aC5hYnMoYykqTWF0aC5zcXJ0KGwpfX0saGUuaXNPbkxpbmU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFlLGk9MTtpPGUubGVuZ3RoO2krKyl7dmFyIHI9ZVtpLTFdLHM9ZVtpXTtpZihuLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxyLHMpLG4uaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuITB9cmV0dXJuITF9LGhlLkNMT0NLV0lTRT0tMSxoZS5SSUdIVD1oZS5DTE9DS1dJU0UsaGUuQ09VTlRFUkNMT0NLV0lTRT0xLGhlLkxFRlQ9aGUuQ09VTlRFUkNMT0NLV0lTRSxoZS5DT0xMSU5FQVI9MCxoZS5TVFJBSUdIVD1oZS5DT0xMSU5FQVIsZShjZS5wcm90b3R5cGUse21pblg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC54LHRoaXMucDEueCl9LG9yaWVudGF0aW9uSW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1oZS5vcmllbnRhdGlvbkluZGV4KHRoaXMucDAsdGhpcy5wMSx0LnAwKSxuPWhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDEpO3JldHVybiBlPj0wJiZuPj0wP01hdGgubWF4KGUsbik6MD49ZSYmMD49bj9NYXRoLm1heChlLG4pOjB9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLGkpfX0sdG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5jcmVhdGVMaW5lU3RyaW5nKFt0aGlzLnAwLHRoaXMucDFdKX0saXNWZXJ0aWNhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLng9PT10aGlzLnAxLnh9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBjZSkpcmV0dXJuITE7dmFyIGU9dDtyZXR1cm4gdGhpcy5wMC5lcXVhbHMoZS5wMCkmJnRoaXMucDEuZXF1YWxzKGUucDEpfSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFlO3JldHVybiBlLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSksZS5oYXNJbnRlcnNlY3Rpb24oKT9lLmdldEludGVyc2VjdGlvbigwKTpudWxsfSxwcm9qZWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5lcXVhbHModGhpcy5wMCl8fHQuZXF1YWxzKHRoaXMucDEpKXJldHVybiBuZXcgZyh0KTt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCksbj1uZXcgZztyZXR1cm4gbi54PXRoaXMucDAueCtlKih0aGlzLnAxLngtdGhpcy5wMC54KSxuLnk9dGhpcy5wMC55K2UqKHRoaXMucDEueS10aGlzLnAwLnkpLG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDApLHM9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKGkucDEpO2lmKHI+PTEmJnM+PTEpcmV0dXJuIG51bGw7aWYoMD49ciYmMD49cylyZXR1cm4gbnVsbDt2YXIgbz10aGlzLnByb2plY3QoaS5wMCk7MD5yJiYobz10aGlzLnAwKSxyPjEmJihvPXRoaXMucDEpO3ZhciBhPXRoaXMucHJvamVjdChpLnAxKTtyZXR1cm4gMD5zJiYoYT10aGlzLnAwKSxzPjEmJihhPXRoaXMucDEpLG5ldyBjZShvLGEpfX0sbm9ybWFsaXplOmZ1bmN0aW9uKCl7dGhpcy5wMS5jb21wYXJlVG8odGhpcy5wMCk8MCYmdGhpcy5yZXZlcnNlKCl9LGFuZ2xlOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguYXRhbjIodGhpcy5wMS55LXRoaXMucDAueSx0aGlzLnAxLngtdGhpcy5wMC54KX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5wMDp0aGlzLnAxfSxkaXN0YW5jZVBlcnBlbmRpY3VsYXI6ZnVuY3Rpb24odCl7cmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcih0LHRoaXMucDAsdGhpcy5wMSl9LG1pblk6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5taW4odGhpcy5wMC55LHRoaXMucDEueSl9LG1pZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIGNlLm1pZFBvaW50KHRoaXMucDAsdGhpcy5wMSl9LHByb2plY3Rpb25GYWN0b3I6ZnVuY3Rpb24odCl7aWYodC5lcXVhbHModGhpcy5wMCkpcmV0dXJuIDA7aWYodC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIDE7dmFyIGU9dGhpcy5wMS54LXRoaXMucDAueCxuPXRoaXMucDEueS10aGlzLnAwLnksaT1lKmUrbipuO2lmKDA+PWkpcmV0dXJuIHIuTmFOO3ZhciBzPSgodC54LXRoaXMucDAueCkqZSsodC55LXRoaXMucDAueSkqbikvaTtyZXR1cm4gc30sY2xvc2VzdFBvaW50czpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmludGVyc2VjdGlvbih0KTtpZihudWxsIT09ZSlyZXR1cm5bZSxlXTt2YXIgbj1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxpPXIuTUFYX1ZBTFVFLHM9bnVsbCxvPXRoaXMuY2xvc2VzdFBvaW50KHQucDApO2k9by5kaXN0YW5jZSh0LnAwKSxuWzBdPW8sblsxXT10LnAwO3ZhciBhPXRoaXMuY2xvc2VzdFBvaW50KHQucDEpO3M9YS5kaXN0YW5jZSh0LnAxKSxpPnMmJihpPXMsblswXT1hLG5bMV09dC5wMSk7dmFyIHU9dC5jbG9zZXN0UG9pbnQodGhpcy5wMCk7cz11LmRpc3RhbmNlKHRoaXMucDApLGk+cyYmKGk9cyxuWzBdPXRoaXMucDAsblsxXT11KTt2YXIgbD10LmNsb3Nlc3RQb2ludCh0aGlzLnAxKTtyZXR1cm4gcz1sLmRpc3RhbmNlKHRoaXMucDEpLGk+cyYmKGk9cyxuWzBdPXRoaXMucDEsblsxXT1sKSxufSxjbG9zZXN0UG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wcm9qZWN0aW9uRmFjdG9yKHQpO2lmKGU+MCYmMT5lKXJldHVybiB0aGlzLnByb2plY3QodCk7dmFyIG49dGhpcy5wMC5kaXN0YW5jZSh0KSxpPXRoaXMucDEuZGlzdGFuY2UodCk7cmV0dXJuIGk+bj90aGlzLnAwOnRoaXMucDF9LG1heFg6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5tYXgodGhpcy5wMC54LHRoaXMucDEueCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLmRpc3RhbmNlKHRoaXMucDEpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMucDAuY29tcGFyZVRvKGUucDApO3JldHVybiAwIT09bj9uOnRoaXMucDEuY29tcGFyZVRvKGUucDEpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wMDt0aGlzLnAwPXRoaXMucDEsdGhpcy5wMT10fSxlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAwLmVxdWFscyh0LnAwKSYmdGhpcy5wMS5lcXVhbHModC5wMSl8fHRoaXMucDAuZXF1YWxzKHQucDEpJiZ0aGlzLnAxLmVxdWFscyh0LnAwKX0sbGluZUludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt0cnl7dmFyIGU9Ri5pbnRlcnNlY3Rpb24odGhpcy5wMCx0aGlzLnAxLHQucDAsdC5wMSk7cmV0dXJuIGV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdH1maW5hbGx5e31yZXR1cm4gbnVsbH0sbWF4WTpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLnksdGhpcy5wMS55KX0scG9pbnRBbG9uZ09mZnNldDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxpPXRoaXMucDAueSt0Kih0aGlzLnAxLnktdGhpcy5wMC55KSxyPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55LG89TWF0aC5zcXJ0KHIqcitzKnMpLGE9MCx1PTA7aWYoMCE9PWUpe2lmKDA+PW8pdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkNhbm5vdCBjb21wdXRlIG9mZnNldCBmcm9tIHplcm8tbGVuZ3RoIGxpbmUgc2VnbWVudFwiKTthPWUqci9vLHU9ZSpzL299dmFyIGw9bi11LGg9aSthLGM9bmV3IGcobCxoKTtyZXR1cm4gY30sc2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0Q29vcmRpbmF0ZXModC5wMCx0LnAxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5wMC54PWUueCx0aGlzLnAwLnk9ZS55LHRoaXMucDEueD1uLngsdGhpcy5wMS55PW4ueX19LHNlZ21lbnRGcmFjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7cmV0dXJuIDA+ZT9lPTA6KGU+MXx8ci5pc05hTihlKSkmJihlPTEpLGV9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJMSU5FU1RSSU5HKCBcIit0aGlzLnAwLngrXCIgXCIrdGhpcy5wMC55K1wiLCBcIit0aGlzLnAxLngrXCIgXCIrdGhpcy5wMS55K1wiKVwifSxpc0hvcml6b250YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMC55PT09dGhpcy5wMS55fSxkaXN0YW5jZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VMaW5lTGluZSh0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmUoZSx0aGlzLnAwLHRoaXMucDEpfX0scG9pbnRBbG9uZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZztyZXR1cm4gZS54PXRoaXMucDAueCt0Kih0aGlzLnAxLngtdGhpcy5wMC54KSxlLnk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLGV9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueCk7dF49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDAueSk7dmFyIGU9TWF0aC50cnVuYyh0KV5NYXRoLnRydW5jKHQ+PjMyKSxuPWphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLngpO25ePTMxKmphdmEubGFuZy5Eb3VibGUuZG91YmxlVG9Mb25nQml0cyh0aGlzLnAxLnkpO3ZhciBpPU1hdGgudHJ1bmMobileTWF0aC50cnVuYyhuPj4zMik7cmV0dXJuIGVeaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcyx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY2V9fSksY2UubWlkUG9pbnQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbmV3IGcoKHQueCtlLngpLzIsKHQueStlLnkpLzIpfSxjZS5zZXJpYWxWZXJzaW9uVUlEPTB4MmQyMTcyMTM1ZjQxMWMwMCxlKGZlLnByb3RvdHlwZSx7aXNJbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXNEaXNqb2ludCgpfSxpc0NvdmVyczpmdW5jdGlvbigpe3ZhciB0PWZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSk7cmV0dXJuIHQmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ292ZXJlZEJ5OmZ1bmN0aW9uKCl7dmFyIHQ9ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKTtyZXR1cm4gdCYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRX0sc2V0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPU1hdGgudHJ1bmMoZS8zKSxpPWUlMzt0aGlzLm1hdHJpeFtuXVtpXT1sdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5tYXRyaXhbcl1bc109b319LGlzQ29udGFpbnM6ZnVuY3Rpb24oKXtyZXR1cm4gZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sc2V0QXRMZWFzdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKXt2YXIgbj1NYXRoLnRydW5jKGUvMyksaT1lJTM7dGhpcy5zZXRBdExlYXN0KG4saSxsdC50b0RpbWVuc2lvblZhbHVlKHQuY2hhckF0KGUpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMubWF0cml4W3JdW3NdPG8mJih0aGlzLm1hdHJpeFtyXVtzXT1vKX19LHNldEF0TGVhc3RJZlZhbGlkOmZ1bmN0aW9uKHQsZSxuKXt0Pj0wJiZlPj0wJiZ0aGlzLnNldEF0TGVhc3QodCxlLG4pfSxpc1dpdGhpbjpmdW5jdGlvbigpe3JldHVybiBmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFfSxpc1RvdWNoZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lP3RoaXMuaXNUb3VjaGVzKGUsdCk6dD09PWx0LkEmJmU9PT1sdC5BfHx0PT09bHQuTCYmZT09PWx0Lkx8fHQ9PT1sdC5MJiZlPT09bHQuQXx8dD09PWx0LlAmJmU9PT1sdC5BfHx0PT09bHQuUCYmZT09PWx0Lkw/dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmKGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkJPVU5EQVJZXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLklOVEVSSU9SXSl8fGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkJPVU5EQVJZXSkpOiExfSxpc092ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1sdC5QJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5MPzE9PT10aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTohMX0saXNFcXVhbHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdCE9PWU/ITE6ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IFAoXCIxMjM0NTY3ODlcIiksZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0LnNldENoYXJBdCgzKmUrbixsdC50b0RpbWVuc2lvblN5bWJvbCh0aGlzLm1hdHJpeFtlXVtuXSkpO3JldHVybiB0LnRvU3RyaW5nKCl9LHNldEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspdGhpcy5tYXRyaXhbZV1bbl09dH0sZ2V0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubWF0cml4W3RdW2VdfSx0cmFuc3Bvc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1hdHJpeFsxXVswXTtyZXR1cm4gdGhpcy5tYXRyaXhbMV1bMF09dGhpcy5tYXRyaXhbMF1bMV0sdGhpcy5tYXRyaXhbMF1bMV09dCx0PXRoaXMubWF0cml4WzJdWzBdLHRoaXMubWF0cml4WzJdWzBdPXRoaXMubWF0cml4WzBdWzJdLHRoaXMubWF0cml4WzBdWzJdPXQsdD10aGlzLm1hdHJpeFsyXVsxXSx0aGlzLm1hdHJpeFsyXVsxXT10aGlzLm1hdHJpeFsxXVsyXSx0aGlzLm1hdHJpeFsxXVsyXT10LHRoaXN9LG1hdGNoZXM6ZnVuY3Rpb24odCl7aWYoOSE9PXQubGVuZ3RoKXRocm93IG5ldyBpKFwiU2hvdWxkIGJlIGxlbmd0aCA5OiBcIit0KTtmb3IodmFyIGU9MDszPmU7ZSsrKWZvcih2YXIgbj0wOzM+bjtuKyspaWYoIWZlLm1hdGNoZXModGhpcy5tYXRyaXhbZV1bbl0sdC5jaGFyQXQoMyplK24pKSlyZXR1cm4hMTtyZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0aGlzLnNldEF0TGVhc3QoZSxuLHQuZ2V0KGUsbikpfSxpc0Rpc2pvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldPT09bHQuRkFMU0V9LGlzQ3Jvc3NlczpmdW5jdGlvbih0LGUpe3JldHVybiB0PT09bHQuUCYmZT09PWx0Lkx8fHQ9PT1sdC5QJiZlPT09bHQuQXx8dD09PWx0LkwmJmU9PT1sdC5BP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuTD9mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0pOnQ9PT1sdC5MJiZlPT09bHQuTD8wPT09dGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl06ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmZX19KSxmZS5tYXRjaGVzPWZ1bmN0aW9uKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIGU9PT1sdC5TWU1fRE9OVENBUkU/ITA6ZT09PWx0LlNZTV9UUlVFJiYodD49MHx8dD09PWx0LlRSVUUpPyEwOmU9PT1sdC5TWU1fRkFMU0UmJnQ9PT1sdC5GQUxTRT8hMDplPT09bHQuU1lNX1AmJnQ9PT1sdC5QPyEwOmU9PT1sdC5TWU1fTCYmdD09PWx0Lkw/ITA6ZT09PWx0LlNZTV9BJiZ0PT09bHQuQX1pZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1uZXcgZmUobik7cmV0dXJuIHIubWF0Y2hlcyhpKX19LGZlLmlzVHJ1ZT1mdW5jdGlvbih0KXtyZXR1cm4gdD49MHx8dD09PWx0LlRSVUV9O3ZhciBsbz1PYmplY3QuZnJlZXplKHtDb29yZGluYXRlOmcsQ29vcmRpbmF0ZUxpc3Q6TixFbnZlbG9wZTpDLExpbmVTZWdtZW50OmNlLEdlb21ldHJ5RmFjdG9yeTppZSxHZW9tZXRyeTpCLFBvaW50Okx0LExpbmVTdHJpbmc6U3QsTGluZWFyUmluZzpidCxQb2x5Z29uOlR0LEdlb21ldHJ5Q29sbGVjdGlvbjpmdCxNdWx0aVBvaW50OlB0LE11bHRpTGluZVN0cmluZzpndCxNdWx0aVBvbHlnb246T3QsRGltZW5zaW9uOmx0LEludGVyc2VjdGlvbk1hdHJpeDpmZX0pO2UoZ2UucHJvdG90eXBlLHthZGRQb2ludDpmdW5jdGlvbih0KXt0aGlzLnB0Q291bnQrPTEsdGhpcy5wdENlbnRTdW0ueCs9dC54LHRoaXMucHRDZW50U3VtLnkrPXQueX0sc2V0QmFzZVBvaW50OmZ1bmN0aW9uKHQpe251bGw9PT10aGlzLmFyZWFCYXNlUHQmJih0aGlzLmFyZWFCYXNlUHQ9dCl9LGFkZExpbmVTZWdtZW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPTA7bjx0Lmxlbmd0aC0xO24rKyl7dmFyIGk9dFtuXS5kaXN0YW5jZSh0W24rMV0pO2lmKDAhPT1pKXtlKz1pO3ZhciByPSh0W25dLngrdFtuKzFdLngpLzI7dGhpcy5saW5lQ2VudFN1bS54Kz1pKnI7dmFyIHM9KHRbbl0ueSt0W24rMV0ueSkvMjt0aGlzLmxpbmVDZW50U3VtLnkrPWkqc319dGhpcy50b3RhbExlbmd0aCs9ZSwwPT09ZSYmdC5sZW5ndGg+MCYmdGhpcy5hZGRQb2ludCh0WzBdKX0sYWRkSG9sZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9aGUuaXNDQ1codCksbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLmFyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9LGdldENlbnRyb2lkOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGc7aWYoTWF0aC5hYnModGhpcy5hcmVhc3VtMik+MCl0Lng9dGhpcy5jZzMueC8zL3RoaXMuYXJlYXN1bTIsdC55PXRoaXMuY2czLnkvMy90aGlzLmFyZWFzdW0yO2Vsc2UgaWYodGhpcy50b3RhbExlbmd0aD4wKXQueD10aGlzLmxpbmVDZW50U3VtLngvdGhpcy50b3RhbExlbmd0aCx0Lnk9dGhpcy5saW5lQ2VudFN1bS55L3RoaXMudG90YWxMZW5ndGg7ZWxzZXtpZighKHRoaXMucHRDb3VudD4wKSlyZXR1cm4gbnVsbDt0Lng9dGhpcy5wdENlbnRTdW0ueC90aGlzLnB0Q291bnQsdC55PXRoaXMucHRDZW50U3VtLnkvdGhpcy5wdENvdW50fXJldHVybiB0fSxhZGRTaGVsbDpmdW5jdGlvbih0KXt0Lmxlbmd0aD4wJiZ0aGlzLnNldEJhc2VQb2ludCh0WzBdKTtmb3IodmFyIGU9IWhlLmlzQ0NXKHQpLG49MDtuPHQubGVuZ3RoLTE7bisrKXRoaXMuYWRkVHJpYW5nbGUodGhpcy5hcmVhQmFzZVB0LHRbbl0sdFtuKzFdLGUpO3RoaXMuYWRkTGluZVNlZ21lbnRzKHQpfSxhZGRUcmlhbmdsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1pPzE6LTE7Z2UuY2VudHJvaWQzKHQsZSxuLHRoaXMudHJpYW5nbGVDZW50Myk7dmFyIHM9Z2UuYXJlYTIodCxlLG4pO3RoaXMuY2czLngrPXIqcyp0aGlzLnRyaWFuZ2xlQ2VudDMueCx0aGlzLmNnMy55Kz1yKnMqdGhpcy50cmlhbmdsZUNlbnQzLnksdGhpcy5hcmVhc3VtMis9cipzfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hZGRTaGVsbCh0LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspdGhpcy5hZGRIb2xlKHQuZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIG49YXJndW1lbnRzWzBdO2lmKG4uaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKG4gaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KG4uZ2V0Q29vcmRpbmF0ZSgpKTtlbHNlIGlmKG4gaW5zdGFuY2VvZiBTdCl0aGlzLmFkZExpbmVTZWdtZW50cyhuLmdldENvb3JkaW5hdGVzKCkpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIFR0KXt2YXIgaT1uO3RoaXMuYWRkKGkpfWVsc2UgaWYobiBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgcj1uLGU9MDtlPHIuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl0aGlzLmFkZChyLmdldEdlb21ldHJ5TihlKSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnZX19KSxnZS5hcmVhMj1mdW5jdGlvbih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0obi54LXQueCkqKGUueS10LnkpfSxnZS5jZW50cm9pZDM9ZnVuY3Rpb24odCxlLG4saSl7cmV0dXJuIGkueD10LngrZS54K24ueCxpLnk9dC55K2UueStuLnksbnVsbH0sZ2UuZ2V0Q2VudHJvaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGdlKHQpO3JldHVybiBlLmdldENlbnRyb2lkKCl9LGRlLnByb3RvdHlwZT1uZXcgRXJyb3IsZGUucHJvdG90eXBlLm5hbWU9XCJFbXB0eVN0YWNrRXhjZXB0aW9uXCIscGUucHJvdG90eXBlPW5ldyB5LHBlLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LHBlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7aWYoMD50fHx0Pj10aGlzLnNpemUoKSl0aHJvdyBuZXcgSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvbjtyZXR1cm4gdGhpcy5hcnJheV9bdF19LHBlLnByb3RvdHlwZS5wdXNoPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLHR9LHBlLnByb3RvdHlwZS5wb3A9ZnVuY3Rpb24odCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgZGU7cmV0dXJuIHRoaXMuYXJyYXlfLnBvcCgpfSxwZS5wcm90b3R5cGUucGVlaz1mdW5jdGlvbigpe2lmKDA9PT10aGlzLmFycmF5Xy5sZW5ndGgpdGhyb3cgbmV3IGRlO3JldHVybiB0aGlzLmFycmF5X1t0aGlzLmFycmF5Xy5sZW5ndGgtMV19LHBlLnByb3RvdHlwZS5lbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxwZS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmVtcHR5KCl9LHBlLnByb3RvdHlwZS5zZWFyY2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLmluZGV4T2YodCl9LHBlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0scGUucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sZSh2ZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLnRyZWVTZXQuY29udGFpbnModCl8fCh0aGlzLmxpc3QuYWRkKHQpLHRoaXMudHJlZVNldC5hZGQodCkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSh0aGlzLmxpc3Quc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0aGlzLmxpc3QudG9BcnJheSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bel19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZlfX0pLHZlLmZpbHRlckNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgdmUsbj0wO248dC5sZW5ndGg7bisrKWUuZmlsdGVyKHRbbl0pO3JldHVybiBlLmdldENvb3JkaW5hdGVzKCl9LGUobWUucHJvdG90eXBlLHtwcmVTb3J0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49MTtuPHQubGVuZ3RoO24rKykodFtuXS55PHRbMF0ueXx8dFtuXS55PT09dFswXS55JiZ0W25dLng8dFswXS54KSYmKGU9dFswXSx0WzBdPXRbbl0sdFtuXT1lKTtyZXR1cm4gdXQuc29ydCh0LDEsdC5sZW5ndGgsbmV3IHllKHRbMF0pKSx0fSxjb21wdXRlT2N0UmluZzpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RQdHModCksbj1uZXcgTjtyZXR1cm4gbi5hZGQoZSwhMSksbi5zaXplKCk8Mz9udWxsOihuLmNsb3NlUmluZygpLG4udG9Db29yZGluYXRlQXJyYXkoKSl9LGxpbmVPclBvbHlnb246ZnVuY3Rpb24odCl7aWYodD10aGlzLmNsZWFuUmluZyh0KSwzPT09dC5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhbdFswXSx0WzFdXSk7dmFyIGU9dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZVBvbHlnb24oZSxudWxsKX0sY2xlYW5SaW5nOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRbMF0sdFt0Lmxlbmd0aC0xXSk7Zm9yKHZhciBlPW5ldyBJLG49bnVsbCxpPTA7aTw9dC5sZW5ndGgtMjtpKyspe3ZhciByPXRbaV0scz10W2krMV07ci5lcXVhbHMocyl8fG51bGwhPT1uJiZ0aGlzLmlzQmV0d2VlbihuLHIscyl8fChlLmFkZChyKSxuPXIpfWUuYWRkKHRbdC5sZW5ndGgtMV0pO3ZhciBvPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gZS50b0FycmF5KG8pfSxpc0JldHdlZW46ZnVuY3Rpb24odCxlLG4pe2lmKDAhPT1oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLG4pKXJldHVybiExO2lmKHQueCE9PW4ueCl7aWYodC54PD1lLngmJmUueDw9bi54KXJldHVybiEwO2lmKG4ueDw9ZS54JiZlLng8PXQueClyZXR1cm4hMH1pZih0LnkhPT1uLnkpe2lmKHQueTw9ZS55JiZlLnk8PW4ueSlyZXR1cm4hMDtpZihuLnk8PWUueSYmZS55PD10LnkpcmV0dXJuITB9cmV0dXJuITF9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmNvbXB1dGVPY3RSaW5nKHQpO2lmKG51bGw9PT1lKXJldHVybiB0O2Zvcih2YXIgbj1uZXcgYXQsaT0wO2k8ZS5sZW5ndGg7aSsrKW4uYWRkKGVbaV0pO2Zvcih2YXIgaT0wO2k8dC5sZW5ndGg7aSsrKWhlLmlzUG9pbnRJblJpbmcodFtpXSxlKXx8bi5hZGQodFtpXSk7dmFyIHI9SC50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gci5sZW5ndGg8Mz90aGlzLnBhZEFycmF5MyhyKTpyfSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTtpZigxPT09dGhpcy5pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy5pbnB1dFB0c1swXSk7aWYoMj09PXRoaXMuaW5wdXRQdHMubGVuZ3RoKXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5pbnB1dFB0cyk7dmFyIHQ9dGhpcy5pbnB1dFB0czt0aGlzLmlucHV0UHRzLmxlbmd0aD41MCYmKHQ9dGhpcy5yZWR1Y2UodGhpcy5pbnB1dFB0cykpO3ZhciBlPXRoaXMucHJlU29ydCh0KSxuPXRoaXMuZ3JhaGFtU2NhbihlKSxpPXRoaXMudG9Db29yZGluYXRlQXJyYXkobik7cmV0dXJuIHRoaXMubGluZU9yUG9seWdvbihpKX0scGFkQXJyYXkzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspbjx0Lmxlbmd0aD9lW25dPXRbbl06ZVtuXT10WzBdO3JldHVybiBlfSxjb21wdXRlT2N0UHRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoOCkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10WzBdO2Zvcih2YXIgaT0xO2k8dC5sZW5ndGg7aSsrKXRbaV0ueDxlWzBdLngmJihlWzBdPXRbaV0pLHRbaV0ueC10W2ldLnk8ZVsxXS54LWVbMV0ueSYmKGVbMV09dFtpXSksdFtpXS55PmVbMl0ueSYmKGVbMl09dFtpXSksdFtpXS54K3RbaV0ueT5lWzNdLngrZVszXS55JiYoZVszXT10W2ldKSx0W2ldLng+ZVs0XS54JiYoZVs0XT10W2ldKSx0W2ldLngtdFtpXS55PmVbNV0ueC1lWzVdLnkmJihlWzVdPXRbaV0pLHRbaV0ueTxlWzZdLnkmJihlWzZdPXRbaV0pLHRbaV0ueCt0W2ldLnk8ZVs3XS54K2VbN10ueSYmKGVbN109dFtpXSk7cmV0dXJuIGV9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dC5zaXplKCk7bisrKXt2YXIgaT10LmdldChuKTtlW25dPWl9cmV0dXJuIGV9LGdyYWhhbVNjYW46ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPW5ldyBwZTtlPW4ucHVzaCh0WzBdKSxlPW4ucHVzaCh0WzFdKSxlPW4ucHVzaCh0WzJdKTtmb3IodmFyIGk9MztpPHQubGVuZ3RoO2krKyl7Zm9yKGU9bi5wb3AoKTshbi5lbXB0eSgpJiZoZS5jb21wdXRlT3JpZW50YXRpb24obi5wZWVrKCksZSx0W2ldKT4wOyllPW4ucG9wKCk7ZT1uLnB1c2goZSksZT1uLnB1c2godFtpXSl9cmV0dXJuIGU9bi5wdXNoKHRbMF0pLG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1lfX0pLG1lLmV4dHJhY3RDb29yZGluYXRlcz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdmU7cmV0dXJuIHQuYXBwbHkoZSksZS5nZXRDb29yZGluYXRlcygpfSxlKHllLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiB5ZS5wb2xhckNvbXBhcmUodGhpcy5vcmlnaW4sbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHllfX0pLHllLnBvbGFyQ29tcGFyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS54LXQueCxyPWUueS10Lnkscz1uLngtdC54LG89bi55LXQueSxhPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbik7XG5pZihhPT09aGUuQ09VTlRFUkNMT0NLV0lTRSlyZXR1cm4gMTtpZihhPT09aGUuQ0xPQ0tXSVNFKXJldHVybi0xO3ZhciB1PWkqaStyKnIsbD1zKnMrbypvO3JldHVybiBsPnU/LTE6dT5sPzE6MH0sbWUuUmFkaWFsQ29tcGFyYXRvcj15ZSxlKHhlLnByb3RvdHlwZSx7dHJhbnNmb3JtUG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9LHRyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj0hMCxpPXRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LmdldEV4dGVyaW9yUmluZygpLHQpO251bGwhPT1pJiZpIGluc3RhbmNlb2YgYnQmJiFpLmlzRW1wdHkoKXx8KG49ITEpO2Zvcih2YXIgcj1uZXcgSSxzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl7dmFyIG89dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0SW50ZXJpb3JSaW5nTihzKSx0KTtudWxsPT09b3x8by5pc0VtcHR5KCl8fChvIGluc3RhbmNlb2YgYnR8fChuPSExKSxyLmFkZChvKSl9aWYobilyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24oaSxyLnRvQXJyYXkoW10pKTt2YXIgYT1uZXcgSTtyZXR1cm4gbnVsbCE9PWkmJmEuYWRkKGkpLGEuYWRkQWxsKHIpLHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KGEpfSxjcmVhdGVDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpfSxnZXRJbnB1dEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXRHZW9tfSx0cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybUxpbmVTdHJpbmcodC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5jb3B5KHQpfSx0cmFuc2Zvcm1MaW5lU3RyaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMudHJhbnNmb3JtQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0KSl9LHRyYW5zZm9ybU11bHRpUG9pbnQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybVBvaW50KHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LHRyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtUG9seWdvbih0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSxjb3B5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNvcHkoKX0sdHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm0odC5nZXRHZW9tZXRyeU4oaSkpO251bGwhPT1yJiYodGhpcy5wcnVuZUVtcHR5R2VvbWV0cnkmJnIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMucHJlc2VydmVHZW9tZXRyeUNvbGxlY3Rpb25UeXBlP3RoaXMuZmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KG4pKTp0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaW5wdXRHZW9tPXQsdGhpcy5mYWN0b3J5PXQuZ2V0RmFjdG9yeSgpLHQgaW5zdGFuY2VvZiBMdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2ludCh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBQdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiB0aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBndClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aUxpbmVTdHJpbmcodCxudWxsKTtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMudHJhbnNmb3JtUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBPdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1NdWx0aVBvbHlnb24odCxudWxsKTtpZih0IGluc3RhbmNlb2YgZnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtR2VvbWV0cnlDb2xsZWN0aW9uKHQsbnVsbCk7dGhyb3cgbmV3IGkoXCJVbmtub3duIEdlb21ldHJ5IHN1YnR5cGU6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSx0cmFuc2Zvcm1MaW5lYXJSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhudWxsKTt2YXIgaT1uLnNpemUoKTtyZXR1cm4gaT4wJiY0PmkmJiF0aGlzLnByZXNlcnZlVHlwZT90aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuKTp0aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geGV9fSksZShFZS5wcm90b3R5cGUse3NuYXBWZXJ0aWNlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLl9pc0Nsb3NlZD90LnNpemUoKS0xOnQuc2l6ZSgpLGk9MDtuPmk7aSsrKXt2YXIgcj10LmdldChpKSxzPXRoaXMuZmluZFNuYXBGb3JWZXJ0ZXgocixlKTtudWxsIT09cyYmKHQuc2V0KGksbmV3IGcocykpLDA9PT1pJiZ0aGlzLl9pc0Nsb3NlZCYmdC5zZXQodC5zaXplKCktMSxuZXcgZyhzKSkpfX0sZmluZFNuYXBGb3JWZXJ0ZXg6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPGUubGVuZ3RoO24rKyl7aWYodC5lcXVhbHMyRChlW25dKSlyZXR1cm4gbnVsbDtpZih0LmRpc3RhbmNlKGVbbl0pPHRoaXMuc25hcFRvbGVyYW5jZSlyZXR1cm4gZVtuXX1yZXR1cm4gbnVsbH0sc25hcFRvOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBOKHRoaXMuc3JjUHRzKTt0aGlzLnNuYXBWZXJ0aWNlcyhlLHQpLHRoaXMuc25hcFNlZ21lbnRzKGUsdCk7dmFyIG49ZS50b0Nvb3JkaW5hdGVBcnJheSgpO3JldHVybiBufSxzbmFwU2VnbWVudHM6ZnVuY3Rpb24odCxlKXtpZigwPT09ZS5sZW5ndGgpcmV0dXJuIG51bGw7dmFyIG49ZS5sZW5ndGg7ZVswXS5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSYmKG49ZS5sZW5ndGgtMSk7Zm9yKHZhciBpPTA7bj5pO2krKyl7dmFyIHI9ZVtpXSxzPXRoaXMuZmluZFNlZ21lbnRJbmRleFRvU25hcChyLHQpO3M+PTAmJnQuYWRkKHMrMSxuZXcgZyhyKSwhMSl9fSxmaW5kU2VnbWVudEluZGV4VG9TbmFwOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXIuTUFYX1ZBTFVFLGk9LTEscz0wO3M8ZS5zaXplKCktMTtzKyspe2lmKHRoaXMuc2VnLnAwPWUuZ2V0KHMpLHRoaXMuc2VnLnAxPWUuZ2V0KHMrMSksdGhpcy5zZWcucDAuZXF1YWxzMkQodCl8fHRoaXMuc2VnLnAxLmVxdWFsczJEKHQpKXtpZih0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKWNvbnRpbnVlO3JldHVybi0xfXZhciBvPXRoaXMuc2VnLmRpc3RhbmNlKHQpO288dGhpcy5zbmFwVG9sZXJhbmNlJiZuPm8mJihuPW8saT1zKX1yZXR1cm4gaX0sc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXM6ZnVuY3Rpb24odCl7dGhpcy5hbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlcz10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFZX19KSxFZS5pc0Nsb3NlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg8PTE/ITE6dFswXS5lcXVhbHMyRCh0W3QubGVuZ3RoLTFdKX0sZShJZS5wcm90b3R5cGUse3NuYXBUbzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHQpLGk9bmV3IE5lKGUsbik7cmV0dXJuIGkudHJhbnNmb3JtKHRoaXMuc3JjR2VvbSl9LHNuYXBUb1NlbGY6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmV4dHJhY3RUYXJnZXRDb29yZGluYXRlcyh0aGlzLnNyY0dlb20pLGk9bmV3IE5lKHQsbiwhMCkscj1pLnRyYW5zZm9ybSh0aGlzLnNyY0dlb20pLHM9cjtyZXR1cm4gZSYmUihzLFJ0KSYmKHM9ci5idWZmZXIoMCkpLHN9LGNvbXB1dGVTbmFwVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29tcHV0ZU1pbmltdW1TZWdtZW50TGVuZ3RoKHQpLG49ZS8xMDtyZXR1cm4gbn0sZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgYXQsbj10LmdldENvb3JkaW5hdGVzKCksaT0wO2k8bi5sZW5ndGg7aSsrKWUuYWRkKG5baV0pO3JldHVybiBlLnRvQXJyYXkobmV3IEFycmF5KDApLmZpbGwobnVsbCkpfSxjb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXIuTUFYX1ZBTFVFLG49MDtuPHQubGVuZ3RoLTE7bisrKXt2YXIgaT10W25dLmRpc3RhbmNlKHRbbisxXSk7ZT5pJiYoZT1pKX1yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSWV9fSksSWUuc25hcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEFycmF5KDIpLmZpbGwobnVsbCkscj1uZXcgSWUodCk7aVswXT1yLnNuYXBUbyhlLG4pO3ZhciBzPW5ldyBJZShlKTtyZXR1cm4gaVsxXT1zLnNuYXBUbyhpWzBdLG4pLGl9LEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1JZS5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZSh0KSxuPXQuZ2V0UHJlY2lzaW9uTW9kZWwoKTtpZihuLmdldFR5cGUoKT09PWVlLkZJWEVEKXt2YXIgaT0xL24uZ2V0U2NhbGUoKSoyLzEuNDE1O2k+ZSYmKGU9aSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXTtyZXR1cm4gTWF0aC5taW4oSWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHIpLEllLmNvbXB1dGVPdmVybGF5U25hcFRvbGVyYW5jZShzKSl9fSxJZS5jb21wdXRlU2l6ZUJhc2VkU25hcFRvbGVyYW5jZT1mdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPU1hdGgubWluKGUuZ2V0SGVpZ2h0KCksZS5nZXRXaWR0aCgpKSxpPW4qSWUuU05BUF9QUkVDSVNJT05fRkFDVE9SO3JldHVybiBpfSxJZS5zbmFwVG9TZWxmPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgSWUodCk7cmV0dXJuIGkuc25hcFRvU2VsZihlLG4pfSxJZS5TTkFQX1BSRUNJU0lPTl9GQUNUT1I9MWUtOSxoKE5lLHhlKSxlKE5lLnByb3RvdHlwZSx7c25hcExpbmU6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgRWUodCx0aGlzLnNuYXBUb2xlcmFuY2UpO3JldHVybiBuLnNldEFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzKHRoaXMuaXNTZWxmU25hcCksbi5zbmFwVG8oZSl9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9dGhpcy5zbmFwTGluZShuLHRoaXMuc25hcFB0cyk7cmV0dXJuIHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOZX19KSxlKENlLnByb3RvdHlwZSx7Z2V0Q29tbW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHIubG9uZ0JpdHNUb0RvdWJsZSh0aGlzLmNvbW1vbkJpdHMpfSxhZGQ6ZnVuY3Rpb24odCl7dmFyIGU9ci5kb3VibGVUb0xvbmdCaXRzKHQpO2lmKHRoaXMuaXNGaXJzdClyZXR1cm4gdGhpcy5jb21tb25CaXRzPWUsdGhpcy5jb21tb25TaWduRXhwPUNlLnNpZ25FeHBCaXRzKHRoaXMuY29tbW9uQml0cyksdGhpcy5pc0ZpcnN0PSExLG51bGw7dmFyIG49Q2Uuc2lnbkV4cEJpdHMoZSk7cmV0dXJuIG4hPT10aGlzLmNvbW1vblNpZ25FeHA/KHRoaXMuY29tbW9uQml0cz0wLG51bGwpOih0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50PUNlLm51bUNvbW1vbk1vc3RTaWdNYW50aXNzYUJpdHModGhpcy5jb21tb25CaXRzLGUpLHZvaWQodGhpcy5jb21tb25CaXRzPUNlLnplcm9Mb3dlckJpdHModGhpcy5jb21tb25CaXRzLDY0LSgxMit0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50KSkpKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9ci5sb25nQml0c1RvRG91YmxlKHQpLG49TG9uZy50b0JpbmFyeVN0cmluZyh0KSxpPVwiMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMFwiK24scz1pLnN1YnN0cmluZyhpLmxlbmd0aC02NCksbz1zLnN1YnN0cmluZygwLDEpK1wiICBcIitzLnN1YnN0cmluZygxLDEyKStcIihleHApIFwiK3Muc3Vic3RyaW5nKDEyKStcIiBbIFwiK2UrXCIgXVwiO3JldHVybiBvfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ2V9fSksQ2UuZ2V0Qml0PWZ1bmN0aW9uKHQsZSl7dmFyIG49MTw8ZTtyZXR1cm4gMCE9PSh0Jm4pPzE6MH0sQ2Uuc2lnbkV4cEJpdHM9ZnVuY3Rpb24odCl7cmV0dXJuIHQ+PjUyfSxDZS56ZXJvTG93ZXJCaXRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49KDE8PGUpLTEsaT1+bixyPXQmaTtyZXR1cm4gcn0sQ2UubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9NTI7aT49MDtpLS0pe2lmKENlLmdldEJpdCh0LGkpIT09Q2UuZ2V0Qml0KGUsaSkpcmV0dXJuIG47bisrfXJldHVybiA1Mn0sZShTZS5wcm90b3R5cGUse2FkZENvbW1vbkJpdHM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IExlKHRoaXMuY29tbW9uQ29vcmQpO3QuYXBwbHkoZSksdC5nZW9tZXRyeUNoYW5nZWQoKX0scmVtb3ZlQ29tbW9uQml0czpmdW5jdGlvbih0KXtpZigwPT09dGhpcy5jb21tb25Db29yZC54JiYwPT09dGhpcy5jb21tb25Db29yZC55KXJldHVybiB0O3ZhciBlPW5ldyBnKHRoaXMuY29tbW9uQ29vcmQpO2UueD0tZS54LGUueT0tZS55O3ZhciBuPW5ldyBMZShlKTtyZXR1cm4gdC5hcHBseShuKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpLHR9LGdldENvbW1vbkNvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21tb25Db29yZH0sYWRkOmZ1bmN0aW9uKHQpe3QuYXBwbHkodGhpcy5jY0ZpbHRlciksdGhpcy5jb21tb25Db29yZD10aGlzLmNjRmlsdGVyLmdldENvbW1vbkNvb3JkaW5hdGUoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU2V9fSksZSh3ZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0aGlzLmNvbW1vbkJpdHNYLmFkZCh0LngpLHRoaXMuY29tbW9uQml0c1kuYWRkKHQueSl9LGdldENvbW1vbkNvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcodGhpcy5jb21tb25CaXRzWC5nZXRDb21tb24oKSx0aGlzLmNvbW1vbkJpdHNZLmdldENvbW1vbigpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bel19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdlfX0pLGUoTGUucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldE9yZGluYXRlKGUsMCkrdGhpcy50cmFucy54LGk9dC5nZXRPcmRpbmF0ZShlLDEpK3RoaXMudHJhbnMueTt0LnNldE9yZGluYXRlKGUsMCxuKSx0LnNldE9yZGluYXRlKGUsMSxpKX0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGlzR2VvbWV0cnlDaGFuZ2VkOmZ1bmN0aW9uKCl7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTGV9fSksU2UuQ29tbW9uQ29vcmRpbmF0ZUZpbHRlcj13ZSxTZS5UcmFuc2xhdGVyPUxlLGUoUmUucHJvdG90eXBlLHtuZXh0OmZ1bmN0aW9uKCl7aWYodGhpcy5hdFN0YXJ0KXJldHVybiB0aGlzLmF0U3RhcnQ9ITEsUmUuaXNBdG9taWModGhpcy5wYXJlbnQpJiZ0aGlzLmluZGV4KyssdGhpcy5wYXJlbnQ7aWYobnVsbCE9PXRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yKXtpZih0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5oYXNOZXh0KCkpcmV0dXJuIHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKTt0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfWlmKHRoaXMuaW5kZXg+PXRoaXMubWF4KXRocm93IG5ldyB4O3ZhciB0PXRoaXMucGFyZW50LmdldEdlb21ldHJ5Tih0aGlzLmluZGV4KyspO3JldHVybiB0IGluc3RhbmNlb2YgZnQ/KHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW5ldyBSZSh0KSx0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvci5uZXh0KCkpOnR9LHJlbW92ZTpmdW5jdGlvbigpe3Rocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpKX0saGFzTmV4dDpmdW5jdGlvbigpe2lmKHRoaXMuYXRTdGFydClyZXR1cm4hMDtpZihudWxsIT09dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4hMDt0aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcj1udWxsfXJldHVybiEodGhpcy5pbmRleD49dGhpcy5tYXgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltwXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUmV9fSksUmUuaXNBdG9taWM9ZnVuY3Rpb24odCl7cmV0dXJuISh0IGluc3RhbmNlb2YgZnQpfSxlKFRlLnByb3RvdHlwZSx7bG9jYXRlSW50ZXJuYWw6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gTC5FWFRFUklPUjt2YXIgbj1lLmdldEV4dGVyaW9yUmluZygpLGk9dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQsbik7aWYoaT09PUwuRVhURVJJT1IpcmV0dXJuIEwuRVhURVJJT1I7aWYoaT09PUwuQk9VTkRBUlkpcmV0dXJuIEwuQk9VTkRBUlk7Zm9yKHZhciByPTA7cjxlLmdldE51bUludGVyaW9yUmluZygpO3IrKyl7dmFyIHM9ZS5nZXRJbnRlcmlvclJpbmdOKHIpLG89dGhpcy5sb2NhdGVJblBvbHlnb25SaW5nKHQscyk7aWYobz09PUwuSU5URVJJT1IpcmV0dXJuIEwuRVhURVJJT1I7aWYobz09PUwuQk9VTkRBUlkpcmV0dXJuIEwuQk9VTkRBUll9cmV0dXJuIEwuSU5URVJJT1J9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFN0KXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV07aWYoIXUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoYSkpcmV0dXJuIEwuRVhURVJJT1I7dmFyIGw9dS5nZXRDb29yZGluYXRlcygpO3JldHVybiB1LmlzQ2xvc2VkKCl8fCFhLmVxdWFscyhsWzBdKSYmIWEuZXF1YWxzKGxbbC5sZW5ndGgtMV0pP2hlLmlzT25MaW5lKGEsbCk/TC5JTlRFUklPUjpMLkVYVEVSSU9SOkwuQk9VTkRBUll9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEx0KXt2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1jLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gZi5lcXVhbHMyRChoKT9MLklOVEVSSU9SOkwuRVhURVJJT1J9fSxsb2NhdGVJblBvbHlnb25SaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/aGUubG9jYXRlUG9pbnRJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpOkwuRVhURVJJT1J9LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5sb2NhdGUodCxlKSE9PUwuRVhURVJJT1J9LHVwZGF0ZUxvY2F0aW9uSW5mbzpmdW5jdGlvbih0KXt0PT09TC5JTlRFUklPUiYmKHRoaXMuaXNJbj0hMCksdD09PUwuQk9VTkRBUlkmJnRoaXMubnVtQm91bmRhcmllcysrfSxjb21wdXRlTG9jYXRpb246ZnVuY3Rpb24odCxlKXtpZihlIGluc3RhbmNlb2YgTHQmJnRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSksZSBpbnN0YW5jZW9mIFN0KXRoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxlKSk7ZWxzZSBpZihlIGluc3RhbmNlb2YgVHQpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBndClmb3IodmFyIG49ZSxpPTA7aTxuLmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPW4uZ2V0R2VvbWV0cnlOKGkpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxyKSl9ZWxzZSBpZihlIGluc3RhbmNlb2YgT3QpZm9yKHZhciBzPWUsaT0wO2k8cy5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgbz1zLmdldEdlb21ldHJ5TihpKTt0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsbykpfWVsc2UgaWYoZSBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgYT1uZXcgUmUoZSk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKTt1IT09ZSYmdGhpcy5jb21wdXRlTG9jYXRpb24odCx1KX19LGxvY2F0ZTpmdW5jdGlvbih0LGUpe3JldHVybiBlLmlzRW1wdHkoKT9MLkVYVEVSSU9SOmUgaW5zdGFuY2VvZiBTdD90aGlzLmxvY2F0ZUludGVybmFsKHQsZSk6ZSBpbnN0YW5jZW9mIFR0P3RoaXMubG9jYXRlSW50ZXJuYWwodCxlKToodGhpcy5pc0luPSExLHRoaXMubnVtQm91bmRhcmllcz0wLHRoaXMuY29tcHV0ZUxvY2F0aW9uKHQsZSksdGhpcy5ib3VuZGFyeVJ1bGUuaXNJbkJvdW5kYXJ5KHRoaXMubnVtQm91bmRhcmllcyk/TC5CT1VOREFSWTp0aGlzLm51bUJvdW5kYXJpZXM+MHx8dGhpcy5pc0luP0wuSU5URVJJT1I6TC5FWFRFUklPUil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRlfX0pLGUoUGUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQZX19KSxQZS5vY3RhbnQ9ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7dmFyIG49TWF0aC5hYnModCkscj1NYXRoLmFicyhlKTtyZXR1cm4gdD49MD9lPj0wP24+PXI/MDoxOm4+PXI/Nzo2OmU+PTA/bj49cj8zOjI6bj49cj80OjV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPW8ueC1zLngsdT1vLnktcy55O2lmKDA9PT1hJiYwPT09dSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBvY3RhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK3MpO3JldHVybiBQZS5vY3RhbnQoYSx1KX19LGUoYmUucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe30sc2l6ZTpmdW5jdGlvbigpe30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXt9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7fSxzZXREYXRhOmZ1bmN0aW9uKHQpe30sZ2V0RGF0YTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYmV9fSksZShPZS5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHNbdF19LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfSxnZXRTZWdtZW50T2N0YW50OmZ1bmN0aW9uKHQpe3JldHVybiB0PT09dGhpcy5wdHMubGVuZ3RoLTE/LTE6UGUub2N0YW50KHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KSx0aGlzLmdldENvb3JkaW5hdGUodCsxKSl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMucHRzKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2JlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT2V9fSksZShfZS5wcm90b3R5cGUse2dldEJvdW5kczpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX2V9fSksZShNZS5wcm90b3R5cGUse2dldEl0ZW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtfSxnZXRCb3VuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19lLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNZX19KSxlKERlLnByb3RvdHlwZSx7cG9sbDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciB0PXRoaXMuaXRlbXMuZ2V0KDEpO3JldHVybiB0aGlzLml0ZW1zLnNldCgxLHRoaXMuaXRlbXMuZ2V0KHRoaXMuX3NpemUpKSx0aGlzLl9zaXplLT0xLHRoaXMucmVvcmRlcigxKSx0fSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3NpemV9LHJlb3JkZXI6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj10aGlzLml0ZW1zLmdldCh0KTsyKnQ8PXRoaXMuX3NpemUmJihlPTIqdCxlIT09dGhpcy5fc2l6ZSYmdGhpcy5pdGVtcy5nZXQoZSsxKS5jb21wYXJlVG8odGhpcy5pdGVtcy5nZXQoZSkpPDAmJmUrKyx0aGlzLml0ZW1zLmdldChlKS5jb21wYXJlVG8obik8MCk7dD1lKXRoaXMuaXRlbXMuc2V0KHQsdGhpcy5pdGVtcy5nZXQoZSkpO3RoaXMuaXRlbXMuc2V0KHQsbil9LGNsZWFyOmZ1bmN0aW9uKCl7dGhpcy5fc2l6ZT0wLHRoaXMuaXRlbXMuY2xlYXIoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5fc2l6ZX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKG51bGwpLHRoaXMuX3NpemUrPTE7dmFyIGU9dGhpcy5fc2l6ZTtmb3IodGhpcy5pdGVtcy5zZXQoMCx0KTt0LmNvbXBhcmVUbyh0aGlzLml0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTwwO2UvPTIpdGhpcy5pdGVtcy5zZXQoZSx0aGlzLml0ZW1zLmdldChNYXRoLnRydW5jKGUvMikpKTt0aGlzLml0ZW1zLnNldChlLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEZX19KSxlKEFlLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQWV9fSksZShGZS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe30scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7fSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZlfX0pLGUoR2UucHJvdG90eXBlLHtnZXRMZXZlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsfSxzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRCb3VuZGFibGVzLnNpemUoKX0sZ2V0Q2hpbGRCb3VuZGFibGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRCb3VuZGFibGVzfSxhZGRDaGlsZEJvdW5kYWJsZTpmdW5jdGlvbih0KXtmLmlzVHJ1ZShudWxsPT09dGhpcy5ib3VuZHMpLHRoaXMuY2hpbGRCb3VuZGFibGVzLmFkZCh0KX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoaWxkQm91bmRhYmxlcy5pc0VtcHR5KCl9LGdldEJvdW5kczpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5ib3VuZHMmJih0aGlzLmJvdW5kcz10aGlzLmNvbXB1dGVCb3VuZHMoKSksdGhpcy5ib3VuZHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19lLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHZX19KSxHZS5zZXJpYWxWZXJzaW9uVUlEPTB4NWExZTU1ZWM0MTM2OTgwMDt2YXIgaG89e3JldmVyc2VPcmRlcjpmdW5jdGlvbigpe3JldHVybntjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuY29tcGFyZVRvKHQpfX19LG1pbjpmdW5jdGlvbih0KXtyZXR1cm4gaG8uc29ydCh0KSx0LmdldCgwKX0sc29ydDpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9BcnJheSgpO2U/dXQuc29ydChuLGUpOnV0LnNvcnQobik7Zm9yKHZhciBpPXQuaXRlcmF0b3IoKSxyPTAscz1uLmxlbmd0aDtzPnI7cisrKWkubmV4dCgpLGkuc2V0KG5bcl0pfSxzaW5nbGV0b25MaXN0OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJO3JldHVybiBlLmFkZCh0KSxlfX07ZShxZS5wcm90b3R5cGUse2V4cGFuZFRvUXVldWU6ZnVuY3Rpb24odCxlKXt2YXIgbj1xZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTEpLHI9cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUyKTtpZihuJiZyKXJldHVybiBxZS5hcmVhKHRoaXMuYm91bmRhYmxlMSk+cWUuYXJlYSh0aGlzLmJvdW5kYWJsZTIpPyh0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyLHQsZSksbnVsbCk6KHRoaXMuZXhwYW5kKHRoaXMuYm91bmRhYmxlMix0aGlzLmJvdW5kYWJsZTEsdCxlKSxudWxsKTtpZihuKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyLHQsZSksbnVsbDtpZihyKXJldHVybiB0aGlzLmV4cGFuZCh0aGlzLmJvdW5kYWJsZTIsdGhpcy5ib3VuZGFibGUxLHQsZSksbnVsbDt0aHJvdyBuZXcgaShcIm5laXRoZXIgYm91bmRhYmxlIGlzIGNvbXBvc2l0ZVwiKX0saXNMZWF2ZXM6ZnVuY3Rpb24oKXtyZXR1cm4hKHFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMSl8fHFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMikpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5fZGlzdGFuY2U8ZS5fZGlzdGFuY2U/LTE6dGhpcy5fZGlzdGFuY2U+ZS5fZGlzdGFuY2U/MTowfSxleHBhbmQ6ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkscz1yLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPW5ldyBxZShvLGUsdGhpcy5pdGVtRGlzdGFuY2UpO2EuZ2V0RGlzdGFuY2UoKTxpJiZuLmFkZChhKX19LGdldEJvdW5kYWJsZTpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXQ/dGhpcy5ib3VuZGFibGUxOnRoaXMuYm91bmRhYmxlMn0sZ2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fZGlzdGFuY2V9LGRpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNMZWF2ZXMoKT90aGlzLml0ZW1EaXN0YW5jZS5kaXN0YW5jZSh0aGlzLmJvdW5kYWJsZTEsdGhpcy5ib3VuZGFibGUyKTp0aGlzLmJvdW5kYWJsZTEuZ2V0Qm91bmRzKCkuZGlzdGFuY2UodGhpcy5ib3VuZGFibGUyLmdldEJvdW5kcygpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFlfX0pLHFlLmFyZWE9ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpfSxxZS5pc0NvbXBvc2l0ZT1mdW5jdGlvbih0KXtyZXR1cm4gdCBpbnN0YW5jZW9mIEdlfSxlKEJlLnByb3RvdHlwZSx7Z2V0Tm9kZUNhcGFjaXR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZUNhcGFjaXR5fSxsYXN0Tm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXQodC5zaXplKCktMSl9LHNpemU6ZnVuY3Rpb24gdCgpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5zaXplKHRoaXMucm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLHQ9MCxuPWUuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kgaW5zdGFuY2VvZiBHZT90Kz10aGlzLnNpemUoaSk6aSBpbnN0YW5jZW9mIE1lJiYodCs9MSl9cmV0dXJuIHR9fSxyZW1vdmVJdGVtOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW51bGwsaT10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyIGluc3RhbmNlb2YgTWUmJnIuZ2V0SXRlbSgpPT09ZSYmKG49cil9cmV0dXJuIG51bGwhPT1uPyh0LmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShuKSwhMCk6ITF9LGl0ZW1zVHJlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLmJ1aWxkKCk7dmFyIHQ9dGhpcy5pdGVtc1RyZWUodGhpcy5yb290KTtyZXR1cm4gbnVsbD09PXQ/bmV3IEk6dH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPW5ldyBJLGk9ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYociBpbnN0YW5jZW9mIEdlKXt2YXIgcz10aGlzLml0ZW1zVHJlZShyKTtudWxsIT09cyYmbi5hZGQocyl9ZWxzZSByIGluc3RhbmNlb2YgTWU/bi5hZGQoci5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX1yZXR1cm4gbi5zaXplKCk8PTA/bnVsbDpufX0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXRoaXMuYnVpbHQsXCJDYW5ub3QgaW5zZXJ0IGl0ZW1zIGludG8gYW4gU1RSIHBhY2tlZCBSLXRyZWUgYWZ0ZXIgaXQgaGFzIGJlZW4gYnVpbHQuXCIpLHRoaXMuaXRlbUJvdW5kYWJsZXMuYWRkKG5ldyBNZSh0LGUpKX0sYm91bmRhYmxlc0F0TGV2ZWw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIHRoaXMuYm91bmRhYmxlc0F0TGV2ZWwodCx0aGlzLnJvb3QsZSksZX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO2lmKGYuaXNUcnVlKG4+LTIpLGkuZ2V0TGV2ZWwoKT09PW4pcmV0dXJuIHIuYWRkKGkpLG51bGw7Zm9yKHZhciBzPWkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO28gaW5zdGFuY2VvZiBHZT90aGlzLmJvdW5kYWJsZXNBdExldmVsKG4sbyxyKTooZi5pc1RydWUobyBpbnN0YW5jZW9mIE1lKSwtMT09PW4mJnIuYWRkKG8pKX1yZXR1cm4gbnVsbH19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmJ1aWxkKCk7dmFyIGU9bmV3IEk7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP2U6KHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLnJvb3QuZ2V0Qm91bmRzKCksdCkmJnRoaXMucXVlcnkodCx0aGlzLnJvb3QsZSksZSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtpZih0aGlzLmJ1aWxkKCksdGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSxuKSYmdGhpcy5xdWVyeShuLHRoaXMucm9vdCxpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPXMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxyKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KHIsbCxvKTpsIGluc3RhbmNlb2YgTWU/by52aXNpdEl0ZW0obC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2UpZm9yKHZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxhPWMuZ2V0Q2hpbGRCb3VuZGFibGVzKCksdT0wO3U8YS5zaXplKCk7dSsrKXt2YXIgbD1hLmdldCh1KTt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHMobC5nZXRCb3VuZHMoKSxoKSYmKGwgaW5zdGFuY2VvZiBHZT90aGlzLnF1ZXJ5KGgsbCxnKTpsIGluc3RhbmNlb2YgTWU/Zy5hZGQobC5nZXRJdGVtKCkpOmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKSl9fSxidWlsZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0P251bGw6KHRoaXMucm9vdD10aGlzLml0ZW1Cb3VuZGFibGVzLmlzRW1wdHkoKT90aGlzLmNyZWF0ZU5vZGUoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHModGhpcy5pdGVtQm91bmRhYmxlcywtMSksdGhpcy5pdGVtQm91bmRhYmxlcz1udWxsLHZvaWQodGhpcy5idWlsdD0hMCkpfSxnZXRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLnJvb3R9LHJlbW92ZTpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuYnVpbGQoKSx0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLHQpP3RoaXMucmVtb3ZlKHQsdGhpcy5yb290LGUpOiExfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz10aGlzLnJlbW92ZUl0ZW0oaSxyKTtpZihzKXJldHVybiEwO2Zvcih2YXIgbz1udWxsLGE9aS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCk7aWYodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHUuZ2V0Qm91bmRzKCksbikmJnUgaW5zdGFuY2VvZiBHZSYmKHM9dGhpcy5yZW1vdmUobix1LHIpKSl7bz11O2JyZWFrfX1yZXR1cm4gbnVsbCE9PW8mJm8uZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXNFbXB0eSgpJiZpLmdldENoaWxkQm91bmRhYmxlcygpLnJlbW92ZShvKSxzfX0sY3JlYXRlSGlnaGVyTGV2ZWxzOmZ1bmN0aW9uKHQsZSl7Zi5pc1RydWUoIXQuaXNFbXB0eSgpKTt2YXIgbj10aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXModCxlKzEpO3JldHVybiAxPT09bi5zaXplKCk/bi5nZXQoMCk6dGhpcy5jcmVhdGVIaWdoZXJMZXZlbHMobixlKzEpfSxkZXB0aDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmlzRW1wdHkoKT8wOih0aGlzLmJ1aWxkKCksdGhpcy5kZXB0aCh0aGlzLnJvb3QpKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTAsbj10LmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpIGluc3RhbmNlb2YgR2Upe3ZhciByPXRoaXMuZGVwdGgoaSk7cj5lJiYoZT1yKX19cmV0dXJuIGUrMX19LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPW5ldyBJO24uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSk7dmFyIGk9bmV3IEkodCk7aG8uc29ydChpLHRoaXMuZ2V0Q29tcGFyYXRvcigpKTtmb3IodmFyIHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7dGhpcy5sYXN0Tm9kZShuKS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5zaXplKCk9PT10aGlzLmdldE5vZGVDYXBhY2l0eSgpJiZuLmFkZCh0aGlzLmNyZWF0ZU5vZGUoZSkpLHRoaXMubGFzdE5vZGUobikuYWRkQ2hpbGRCb3VuZGFibGUocyl9cmV0dXJuIG59LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsdD90aGlzLnJvb3QuaXNFbXB0eSgpOnRoaXMuaXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQmV9fSksQmUuY29tcGFyZURvdWJsZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD5lPzE6ZT50Py0xOjB9LEJlLkludGVyc2VjdHNPcD16ZSxCZS5zZXJpYWxWZXJzaW9uVUlEPS0weDM1ZWY2NGM4MmQ0YzU0MDAsQmUuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwLGUoVmUucHJvdG90eXBlLHtkaXN0YW5jZTpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVmV9fSksaChrZSxCZSksZShrZS5wcm90b3R5cGUse2NyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSh0Lmxlbmd0aD4wKTtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5sZW5ndGg7aSsrKW4uYWRkQWxsKHRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlKHRbaV0sZSkpO3JldHVybiBufSxjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgWWUodCl9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/QmUucHJvdG90eXBlLnNpemUuY2FsbCh0aGlzKTpCZS5wcm90b3R5cGUuc2l6ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGluc2VydDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBCZS5wcm90b3R5cGUuaW5zZXJ0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHQuaXNOdWxsKCk/bnVsbDp2b2lkIEJlLnByb3RvdHlwZS5pbnNlcnQuY2FsbCh0aGlzLHQsZSl9LGdldEludGVyc2VjdHNPcDpmdW5jdGlvbigpe3JldHVybiBrZS5pbnRlcnNlY3RzT3B9LHZlcnRpY2FsU2xpY2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL2UpKSxpPW5ldyBBcnJheShlKS5maWxsKG51bGwpLHI9dC5pdGVyYXRvcigpLHM9MDtlPnM7cysrKXtpW3NdPW5ldyBJO2Zvcih2YXIgbz0wO3IuaGFzTmV4dCgpJiZuPm87KXt2YXIgYT1yLm5leHQoKTtpW3NdLmFkZChhKSxvKyt9fXJldHVybiBpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIEJlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsdCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLGUsbil9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihSKGFyZ3VtZW50c1syXSxBZSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgT2JqZWN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIEdlKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07QmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyxpLHIscyl9ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2Upe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLG8sYSx1KX19LGdldENvbXBhcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4ga2UueUNvbXBhcmF0b3J9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5wcm90b3R5cGUuY3JlYXRlUGFyZW50Qm91bmRhYmxlcy5jYWxsKHRoaXMsdCxlKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5jYWxsKHRoaXMsdCxlKX1yZXR1cm4gQmUucHJvdG90eXBlLnJlbW92ZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT1hcmd1bWVudHMubGVuZ3RoP0JlLnByb3RvdHlwZS5kZXB0aC5jYWxsKHRoaXMpOkJlLnByb3RvdHlwZS5kZXB0aC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGNyZWF0ZVBhcmVudEJvdW5kYWJsZXM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPU1hdGgudHJ1bmMoTWF0aC5jZWlsKHQuc2l6ZSgpL3RoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkpKSxpPW5ldyBJKHQpO2hvLnNvcnQoaSxrZS54Q29tcGFyYXRvcik7dmFyIHI9dGhpcy52ZXJ0aWNhbFNsaWNlcyhpLE1hdGgudHJ1bmMoTWF0aC5jZWlsKE1hdGguc3FydChuKSkpKTtyZXR1cm4gdGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2VzKHIsZSl9LG5lYXJlc3ROZWlnaGJvdXI6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sVmUpKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgcWUodGhpcy5nZXRSb290KCksdGhpcy5nZXRSb290KCksdCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHFlKXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihuLHIuUE9TSVRJVkVfSU5GSU5JVFkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGtlJiZSKGFyZ3VtZW50c1sxXSxWZSkpe3ZhciBpPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSxpLmdldFJvb3QoKSxzKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcWUmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWEsbD1udWxsLGg9bmV3IERlO2ZvcihoLmFkZChvKTshaC5pc0VtcHR5KCkmJnU+MDspe3ZhciBjPWgucG9sbCgpLGY9Yy5nZXREaXN0YW5jZSgpO2lmKGY+PXUpYnJlYWs7Yy5pc0xlYXZlcygpPyh1PWYsbD1jKTpjLmV4cGFuZFRvUXVldWUoaCx1KX1yZXR1cm5bbC5nZXRCb3VuZGFibGUoMCkuZ2V0SXRlbSgpLGwuZ2V0Qm91bmRhYmxlKDEpLmdldEl0ZW0oKV19fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXSx2PW5ldyBNZShnLGQpLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLHYscCk7cmV0dXJuIHRoaXMubmVhcmVzdE5laWdoYm91cihlKVswXX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ZlLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrZX19KSxrZS5jZW50cmVYPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5YKCksdC5nZXRNYXhYKCkpfSxrZS5hdmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4odCtlKS8yfSxrZS5jZW50cmVZPWZ1bmN0aW9uKHQpe3JldHVybiBrZS5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpfSxoKFllLEdlKSxlKFllLnByb3RvdHlwZSx7Y29tcHV0ZUJvdW5kczpmdW5jdGlvbigpe2Zvcih2YXIgdD1udWxsLGU9dGhpcy5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bnVsbD09PXQ/dD1uZXcgQyhuLmdldEJvdW5kcygpKTp0LmV4cGFuZFRvSW5jbHVkZShuLmdldEJvdW5kcygpKX1yZXR1cm4gdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWWV9fSksa2UuU1RSdHJlZU5vZGU9WWUsa2Uuc2VyaWFsVmVyc2lvblVJRD0weDM5OTIwZjdkNWYyNjFlMCxrZS54Q29tcGFyYXRvcj17aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGNvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gQmUuY29tcGFyZURvdWJsZXMoa2UuY2VudHJlWCh0LmdldEJvdW5kcygpKSxrZS5jZW50cmVYKGUuZ2V0Qm91bmRzKCkpKX19LGtlLnlDb21wYXJhdG9yPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5jb21wYXJlRG91YmxlcyhrZS5jZW50cmVZKHQuZ2V0Qm91bmRzKCkpLGtlLmNlbnRyZVkoZS5nZXRCb3VuZHMoKSkpfX0sa2UuaW50ZXJzZWN0c09wPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltJbnRlcnNlY3RzT3BdfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaW50ZXJzZWN0cyhlKX19LGtlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWT0xMCxlKFVlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVWV9fSksVWUucmVsYXRpdmVTaWduPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+dD8tMTp0PmU/MTowfSxVZS5jb21wYXJlPWZ1bmN0aW9uKHQsZSxuKXtpZihlLmVxdWFsczJEKG4pKXJldHVybiAwO3ZhciBpPVVlLnJlbGF0aXZlU2lnbihlLngsbi54KSxyPVVlLnJlbGF0aXZlU2lnbihlLnksbi55KTtzd2l0Y2godCl7Y2FzZSAwOnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSxyKTtjYXNlIDE6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShyLGkpO2Nhc2UgMjpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKHIsLWkpO2Nhc2UgMzpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLHIpO2Nhc2UgNDpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1pLC1yKTtjYXNlIDU6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtciwtaSk7Y2FzZSA2OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLXIsaSk7Y2FzZSA3OnJldHVybiBVZS5jb21wYXJlVmFsdWUoaSwtcil9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJpbnZhbGlkIG9jdGFudCB2YWx1ZVwiKSwwfSxVZS5jb21wYXJlVmFsdWU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD50Py0xOnQ+MD8xOjA+ZT8tMTplPjA/MTowfSxlKFhlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50KHRoaXMuY29vcmQpLHQucHJpbnQoXCIgc2VnICMgPSBcIit0aGlzLnNlZ21lbnRJbmRleCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDxlLnNlZ21lbnRJbmRleD8tMTp0aGlzLnNlZ21lbnRJbmRleD5lLnNlZ21lbnRJbmRleD8xOnRoaXMuY29vcmQuZXF1YWxzMkQoZS5jb29yZCk/MDpVZS5jb21wYXJlKHRoaXMuc2VnbWVudE9jdGFudCx0aGlzLmNvb3JkLGUuY29vcmQpfSxpc0VuZFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiAwIT09dGhpcy5zZWdtZW50SW5kZXh8fHRoaXMuX2lzSW50ZXJpb3I/dGhpcy5zZWdtZW50SW5kZXg9PT10OiEwfSxpc0ludGVyaW9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW50ZXJpb3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYZX19KSxlKEhlLnByb3RvdHlwZSx7Z2V0U3BsaXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBOO3RoaXMuYWRkRW5kcG9pbnRzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCk7dGhpcy5hZGRFZGdlQ29vcmRpbmF0ZXMobixpLHQpLG49aX1yZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxhZGRDb2xsYXBzZWROb2RlczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3RoaXMuZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzKHQpLHRoaXMuZmluZENvbGxhcHNlc0Zyb21FeGlzdGluZ1ZlcnRpY2VzKHQpO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKS5pbnRWYWx1ZSgpO3RoaXMuYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG4pLG4pfX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxmaW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2Uuc2l6ZSgpLTI7ZSsrKXt2YXIgbj10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKSxpPSh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlKzEpLHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUrMikpO24uZXF1YWxzMkQoaSkmJnQuYWRkKG5ldyBiKGUrMSkpfX0sYWRkRWRnZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleCsyLHI9dGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZS5zZWdtZW50SW5kZXgpLHM9ZS5pc0ludGVyaW9yKCl8fCFlLmNvb3JkLmVxdWFsczJEKHIpO3N8fGktLTtuLmFkZChuZXcgZyh0LmNvb3JkKSwhMSk7Zm9yKHZhciBvPXQuc2VnbWVudEluZGV4KzE7bzw9ZS5zZWdtZW50SW5kZXg7bysrKW4uYWRkKHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKG8pKTtzJiZuLmFkZChuZXcgZyhlLmNvb3JkKSl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxhZGRTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCksdGhpcy5hZGRDb2xsYXBzZWROb2RlcygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpLHI9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixpKTt0LmFkZChyKSxuPWl9fSxmaW5kQ29sbGFwc2VJbmRleDpmdW5jdGlvbih0LGUsbil7aWYoIXQuY29vcmQuZXF1YWxzMkQoZS5jb29yZCkpcmV0dXJuITE7dmFyIGk9ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXg7cmV0dXJuIGUuaXNJbnRlcmlvcigpfHxpLS0sMT09PWk/KG5bMF09dC5zZWdtZW50SW5kZXgrMSwhMCk6ITF9LGZpbmRDb2xsYXBzZXNGcm9tSW5zZXJ0ZWROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksbj10aGlzLml0ZXJhdG9yKCksaT1uLm5leHQoKTtuLmhhc05leHQoKTspe3ZhciByPW4ubmV4dCgpLHM9dGhpcy5maW5kQ29sbGFwc2VJbmRleChpLHIsZSk7cyYmdC5hZGQobmV3IGIoZVswXSkpLGk9cn19LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxhZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2Uuc2l6ZSgpLTE7dGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUoMCksMCksdGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUodCksdCl9LGNyZWF0ZVNwbGl0RWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIsaT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCkscj1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQoaSk7cnx8bi0tO3ZhciBzPW5ldyBBcnJheShuKS5maWxsKG51bGwpLG89MDtzW28rK109bmV3IGcodC5jb29yZCk7Zm9yKHZhciBhPXQuc2VnbWVudEluZGV4KzE7YTw9ZS5zZWdtZW50SW5kZXg7YSsrKXNbbysrXT10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShhKTtyZXR1cm4gciYmKHNbb109bmV3IGcoZS5jb29yZCkpLG5ldyBLZShzLHRoaXMuZWRnZS5nZXREYXRhKCkpfSxhZGQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWGUodGhpcy5lZGdlLHQsZSx0aGlzLmVkZ2UuZ2V0U2VnbWVudE9jdGFudChlKSksaT10aGlzLm5vZGVNYXAuZ2V0KG4pO3JldHVybiBudWxsIT09aT8oZi5pc1RydWUoaS5jb29yZC5lcXVhbHMyRCh0KSxcIkZvdW5kIGVxdWFsIG5vZGVzIHdpdGggZGlmZmVyZW50IGNvb3JkaW5hdGVzXCIpLGkpOih0aGlzLm5vZGVNYXAucHV0KG4sbiksbil9LGNoZWNrU3BsaXRFZGdlc0NvcnJlY3RuZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlcygpLG49dC5nZXQoMCksaT1uLmdldENvb3JkaW5hdGUoMCk7aWYoIWkuZXF1YWxzMkQoZVswXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBzdGFydCBwb2ludCBhdCBcIitpKTt2YXIgcj10LmdldCh0LnNpemUoKS0xKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPXNbcy5sZW5ndGgtMV07aWYoIW8uZXF1YWxzMkQoZVtlLmxlbmd0aC0xXSkpdGhyb3cgbmV3IGwoXCJiYWQgc3BsaXQgZWRnZSBlbmQgcG9pbnQgYXQgXCIrbyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhlfX0pLGUoV2UucHJvdG90eXBlLHtuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmN1cnJOb2RlPyh0aGlzLmN1cnJOb2RlPXRoaXMubmV4dE5vZGUsdGhpcy5jdXJyU2VnSW5kZXg9dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXgsdGhpcy5yZWFkTmV4dE5vZGUoKSx0aGlzLmN1cnJOb2RlKTpudWxsPT09dGhpcy5uZXh0Tm9kZT9udWxsOnRoaXMubmV4dE5vZGUuc2VnbWVudEluZGV4PT09dGhpcy5jdXJyTm9kZS5zZWdtZW50SW5kZXg/KHRoaXMuY3Vyck5vZGU9dGhpcy5uZXh0Tm9kZSx0aGlzLmN1cnJTZWdJbmRleD10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCx0aGlzLnJlYWROZXh0Tm9kZSgpLHRoaXMuY3Vyck5vZGUpOih0aGlzLm5leHROb2RlLnNlZ21lbnRJbmRleD50aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCxudWxsKX0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSxoYXNOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLm5leHROb2RlfSxyZWFkTmV4dE5vZGU6ZnVuY3Rpb24oKXt0aGlzLm5vZGVJdC5oYXNOZXh0KCk/dGhpcy5uZXh0Tm9kZT10aGlzLm5vZGVJdC5uZXh0KCk6dGhpcy5uZXh0Tm9kZT1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltwXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2V9fSksZShqZS5wcm90b3R5cGUse2FkZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYmVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqZX19KSxlKEtlLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0c1t0XX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9LGdldFNlZ21lbnRPY3RhbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnB0cy5sZW5ndGgtMT8tMTp0aGlzLnNhZmVPY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sc2FmZU9jdGFudDpmdW5jdGlvbih0LGUpe3JldHVybiB0LmVxdWFsczJEKGUpPzA6UGUub2N0YW50KHQsZSl9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuYWRkSW50ZXJzZWN0aW9uTm9kZSh0LGUpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPShhcmd1bWVudHNbMl0sYXJndW1lbnRzWzNdKSxzPW5ldyBnKG4uZ2V0SW50ZXJzZWN0aW9uKHIpKTt0aGlzLmFkZEludGVyc2VjdGlvbihzLGkpfX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBHdCh0aGlzLnB0cykpfSxnZXROb2RlTGlzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVMaXN0fSxhZGRJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSxpPW4rMTtpZihpPHRoaXMucHRzLmxlbmd0aCl7dmFyIHI9dGhpcy5wdHNbaV07dC5lcXVhbHMyRChyKSYmKG49aSl9dmFyIHM9dGhpcy5ub2RlTGlzdC5hZGQodCxuKTtyZXR1cm4gc30sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bamVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLZX19KSxLZS5nZXROb2RlZFN1YnN0cmluZ3M9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEk7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0LGUpLGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW4uaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3MuZ2V0Tm9kZUxpc3QoKS5hZGRTcGxpdEVkZ2VzKGkpfX0sZShaZS5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdLGFyZ3VtZW50c1sxXX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dC5nZXRMaW5lU2VnbWVudChlLHRoaXMub3ZlcmxhcFNlZzEpLG4uZ2V0TGluZVNlZ21lbnQoaSx0aGlzLm92ZXJsYXBTZWcyKSx0aGlzLm92ZXJsYXAodGhpcy5vdmVybGFwU2VnMSx0aGlzLm92ZXJsYXBTZWcyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFplfX0pLGUoUWUucHJvdG90eXBlLHtnZXRMaW5lU2VnbWVudDpmdW5jdGlvbih0LGUpe2UucDA9dGhpcy5wdHNbdF0sZS5wMT10aGlzLnB0c1t0KzFdfSxjb21wdXRlU2VsZWN0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMucHRzW2VdLHM9dGhpcy5wdHNbbl07aWYoaS50ZW1wRW52MS5pbml0KHIscyksbi1lPT09MSlyZXR1cm4gaS5zZWxlY3QodGhpcyxlKSxudWxsO2lmKCF0LmludGVyc2VjdHMoaS50ZW1wRW52MSkpcmV0dXJuIG51bGw7dmFyIG89TWF0aC50cnVuYygoZStuKS8yKTtcbm8+ZSYmdGhpcy5jb21wdXRlU2VsZWN0KHQsZSxvLGkpLG4+byYmdGhpcy5jb21wdXRlU2VsZWN0KHQsbyxuLGkpfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5lbmQtdGhpcy5zdGFydCsxKS5maWxsKG51bGwpLGU9MCxuPXRoaXMuc3RhcnQ7bjw9dGhpcy5lbmQ7bisrKXRbZSsrXT10aGlzLnB0c1tuXTtyZXR1cm4gdH0sY29tcHV0ZU92ZXJsYXBzOmZ1bmN0aW9uKHQsZSl7dGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0aGlzLnN0YXJ0LHRoaXMuZW5kLHQsdC5zdGFydCx0LmVuZCxlKX0sc2V0SWQ6ZnVuY3Rpb24odCl7dGhpcy5pZD10fSxzZWxlY3Q6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbXB1dGVTZWxlY3QodCx0aGlzLnN0YXJ0LHRoaXMuZW5kLGUpfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dmFyIHQ9dGhpcy5wdHNbdGhpcy5zdGFydF0sZT10aGlzLnB0c1t0aGlzLmVuZF07dGhpcy5lbnY9bmV3IEModCxlKX1yZXR1cm4gdGhpcy5lbnZ9LGdldEVuZEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kfSxnZXRTdGFydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnR9LGdldENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb250ZXh0fSxnZXRJZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlkfSxjb21wdXRlT3ZlcmxhcHNJbnRlcm5hbDpmdW5jdGlvbih0LGUsbixpLHIscyl7dmFyIG89dGhpcy5wdHNbdF0sYT10aGlzLnB0c1tlXSx1PW4ucHRzW2ldLGw9bi5wdHNbcl07aWYoZS10PT09MSYmci1pPT09MSlyZXR1cm4gcy5vdmVybGFwKHRoaXMsdCxuLGkpLG51bGw7aWYocy50ZW1wRW52MS5pbml0KG8sYSkscy50ZW1wRW52Mi5pbml0KHUsbCksIXMudGVtcEVudjEuaW50ZXJzZWN0cyhzLnRlbXBFbnYyKSlyZXR1cm4gbnVsbDt2YXIgaD1NYXRoLnRydW5jKCh0K2UpLzIpLGM9TWF0aC50cnVuYygoaStyKS8yKTtoPnQmJihjPmkmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwodCxoLG4saSxjLHMpLHI+YyYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0LGgsbixjLHIscykpLGU+aCYmKGM+aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbChoLGUsbixpLGMscykscj5jJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKGgsZSxuLGMscixzKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFlfX0pLGUoSmUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKZX19KSxKZS5pc05vcnRoZXJuPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09SmUuTkV8fHQ9PT1KZS5OV30sSmUuaXNPcHBvc2l0ZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiExO3ZhciBuPSh0LWUrNCklNDtyZXR1cm4gMj09PW59LEplLmNvbW1vbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe2lmKHQ9PT1lKXJldHVybiB0O3ZhciBuPSh0LWUrNCklNDtpZigyPT09bilyZXR1cm4tMTt2YXIgaT1lPnQ/dDplLHI9dD5lP3Q6ZTtyZXR1cm4gMD09PWkmJjM9PT1yPzM6aX0sSmUuaXNJbkhhbGZQbGFuZT1mdW5jdGlvbih0LGUpe3JldHVybiBlPT09SmUuU0U/dD09PUplLlNFfHx0PT09SmUuU1c6dD09PWV8fHQ9PT1lKzF9LEplLnF1YWRyYW50PWZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT10JiYwPT09ZSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgcG9pbnQgKCBcIit0K1wiLCBcIitlK1wiIClcIik7cmV0dXJuIHQ+PTA/ZT49MD9KZS5ORTpKZS5TRTplPj0wP0plLk5XOkplLlNXfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07aWYoci54PT09bi54JiZyLnk9PT1uLnkpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgcXVhZHJhbnQgZm9yIHR3byBpZGVudGljYWwgcG9pbnRzIFwiK24pO3JldHVybiByLng+PW4ueD9yLnk+PW4ueT9KZS5ORTpKZS5TRTpyLnk+PW4ueT9KZS5OVzpKZS5TV319LEplLk5FPTAsSmUuTlc9MSxKZS5TVz0yLEplLlNFPTMsZSgkZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRlfX0pLCRlLmdldENoYWluU3RhcnRJbmRpY2VzPWZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1uZXcgSTtuLmFkZChuZXcgYihlKSk7ZG97dmFyIGk9JGUuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IGIoaSkpLGU9aX13aGlsZShlPHQubGVuZ3RoLTEpO3ZhciByPSRlLnRvSW50QXJyYXkobik7cmV0dXJuIHJ9LCRlLmZpbmRDaGFpbkVuZD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lO248dC5sZW5ndGgtMSYmdFtuXS5lcXVhbHMyRCh0W24rMV0pOyluKys7aWYobj49dC5sZW5ndGgtMSlyZXR1cm4gdC5sZW5ndGgtMTtmb3IodmFyIGk9SmUucXVhZHJhbnQodFtuXSx0W24rMV0pLHI9ZSsxO3I8dC5sZW5ndGg7KXtpZighdFtyLTFdLmVxdWFsczJEKHRbcl0pKXt2YXIgcz1KZS5xdWFkcmFudCh0W3ItMV0sdFtyXSk7aWYocyE9PWkpYnJlYWt9cisrfXJldHVybiByLTF9LCRlLmdldENoYWlucz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuICRlLmdldENoYWlucyh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9bmV3IEkscj0kZS5nZXRDaGFpblN0YXJ0SW5kaWNlcyhlKSxzPTA7czxyLmxlbmd0aC0xO3MrKyl7dmFyIG89bmV3IFFlKGUscltzXSxyW3MrMV0sbik7aS5hZGQobyl9cmV0dXJuIGl9fSwkZS50b0ludEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX0sZSh0bi5wcm90b3R5cGUse2NvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdG59fSksZShlbi5wcm90b3R5cGUse3NldFNlZ21lbnRJbnRlcnNlY3RvcjpmdW5jdGlvbih0KXt0aGlzLnNlZ0ludD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVufX0pLGgobm4sZW4pLGUobm4ucHJvdG90eXBlLHtnZXRNb25vdG9uZUNoYWluczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1vbm9DaGFpbnN9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3JldHVybiBLZS5nZXROb2RlZFN1YnN0cmluZ3ModGhpcy5ub2RlZFNlZ1N0cmluZ3MpfSxnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fSxhZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSRlLmdldENoYWlucyh0LmdldENvb3JkaW5hdGVzKCksdCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldElkKHRoaXMuaWRDb3VudGVyKyspLHRoaXMuaW5kZXguaW5zZXJ0KGkuZ2V0RW52ZWxvcGUoKSxpKSx0aGlzLm1vbm9DaGFpbnMuYWRkKGkpfX0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3RoaXMubm9kZWRTZWdTdHJpbmdzPXQ7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3RoaXMuaW50ZXJzZWN0Q2hhaW5zKCl9LGludGVyc2VjdENoYWluczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgcm4odGhpcy5zZWdJbnQpLGU9dGhpcy5tb25vQ2hhaW5zLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPXRoaXMuaW5kZXgucXVlcnkobi5nZXRFbnZlbG9wZSgpKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0SWQoKT5uLmdldElkKCkmJihuLmNvbXB1dGVPdmVybGFwcyhzLHQpLHRoaXMubk92ZXJsYXBzKyspLHRoaXMuc2VnSW50LmlzRG9uZSgpKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbm59fSksaChybixaZSksZShybi5wcm90b3R5cGUse292ZXJsYXA6ZnVuY3Rpb24oKXtpZig0IT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gWmUucHJvdG90eXBlLm92ZXJsYXAuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXSxyPXQuZ2V0Q29udGV4dCgpLHM9bi5nZXRDb250ZXh0KCk7dGhpcy5zaS5wcm9jZXNzSW50ZXJzZWN0aW9ucyhyLGUscyxpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcm59fSksbm4uU2VnbWVudE92ZXJsYXBBY3Rpb249cm4saChzbixsKSxlKHNuLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzbn19KSxzbi5tc2dXaXRoQ29vcmQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUob24ucHJvdG90eXBlLHtwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXt9LGlzRG9uZTpmdW5jdGlvbigpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb259fSksZShhbi5wcm90b3R5cGUse2dldEludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LHNldENoZWNrRW5kU2VnbWVudHNPbmx5OmZ1bmN0aW9uKHQpe3RoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seT10fSxnZXRJbnRlcnNlY3Rpb25TZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludFNlZ21lbnRzfSxjb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyc2VjdGlvbkNvdW50fSxnZXRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uc30sc2V0RmluZEFsbEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz10fSxzZXRLZWVwSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmtlZXBJbnRlcnNlY3Rpb25zPXR9LHByb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKCF0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zJiZ0aGlzLmhhc0ludGVyc2VjdGlvbigpKXJldHVybiBudWxsO2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDtpZih0aGlzLmlzQ2hlY2tFbmRTZWdtZW50c09ubHkpe3ZhciByPXRoaXMuaXNFbmRTZWdtZW50KHQsZSl8fHRoaXMuaXNFbmRTZWdtZW50KG4saSk7aWYoIXIpcmV0dXJuIG51bGx9dmFyIHM9dC5nZXRDb29yZGluYXRlcygpW2VdLG89dC5nZXRDb29yZGluYXRlcygpW2UrMV0sYT1uLmdldENvb3JkaW5hdGVzKClbaV0sdT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocyxvLGEsdSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkmJih0aGlzLmludFNlZ21lbnRzPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuaW50U2VnbWVudHNbMF09cyx0aGlzLmludFNlZ21lbnRzWzFdPW8sdGhpcy5pbnRTZWdtZW50c1syXT1hLHRoaXMuaW50U2VnbWVudHNbM109dSx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApLHRoaXMua2VlcEludGVyc2VjdGlvbnMmJnRoaXMuaW50ZXJzZWN0aW9ucy5hZGQodGhpcy5pbnRlcmlvckludGVyc2VjdGlvbiksdGhpcy5pbnRlcnNlY3Rpb25Db3VudCsrKX0saXNFbmRTZWdtZW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA9PT1lPyEwOmU+PXQuc2l6ZSgpLTJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZmluZEFsbEludGVyc2VjdGlvbnM/ITE6bnVsbCE9PXRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb259LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29uXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYW59fSksYW4uY3JlYXRlQWxsSW50ZXJzZWN0aW9uc0ZpbmRlcj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGV9LGFuLmNyZWF0ZUFueUludGVyc2VjdGlvbkZpbmRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGFuKHQpfSxhbi5jcmVhdGVJbnRlcnNlY3Rpb25Db3VudGVyPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhbih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5zZXRLZWVwSW50ZXJzZWN0aW9ucyghMSksZX0sZSh1bi5wcm90b3R5cGUse2V4ZWN1dGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuc2VnSW50P251bGw6dm9pZCB0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9LGdldEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdJbnQuZ2V0SW50ZXJzZWN0aW9ucygpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXhlY3V0ZSgpLHRoaXMuX2lzVmFsaWR9LHNldEZpbmRBbGxJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9dH0sY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXt0aGlzLl9pc1ZhbGlkPSEwLHRoaXMuc2VnSW50PW5ldyBhbih0aGlzLmxpKSx0aGlzLnNlZ0ludC5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyh0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zKTt2YXIgdD1uZXcgbm47cmV0dXJuIHQuc2V0U2VnbWVudEludGVyc2VjdG9yKHRoaXMuc2VnSW50KSx0LmNvbXB1dGVOb2Rlcyh0aGlzLnNlZ1N0cmluZ3MpLHRoaXMuc2VnSW50Lmhhc0ludGVyc2VjdGlvbigpPyh0aGlzLl9pc1ZhbGlkPSExLG51bGwpOnZvaWQgMH0sY2hlY2tWYWxpZDpmdW5jdGlvbigpe2lmKHRoaXMuZXhlY3V0ZSgpLCF0aGlzLl9pc1ZhbGlkKXRocm93IG5ldyBzbih0aGlzLmdldEVycm9yTWVzc2FnZSgpLHRoaXMuc2VnSW50LmdldEludGVyaW9ySW50ZXJzZWN0aW9uKCkpfSxnZXRFcnJvck1lc3NhZ2U6ZnVuY3Rpb24oKXtpZih0aGlzLl9pc1ZhbGlkKXJldHVyblwibm8gaW50ZXJzZWN0aW9ucyBmb3VuZFwiO3ZhciB0PXRoaXMuc2VnSW50LmdldEludGVyc2VjdGlvblNlZ21lbnRzKCk7cmV0dXJuXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGJldHdlZW4gXCIrc2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSkrXCIgYW5kIFwiK3NlLnRvTGluZVN0cmluZyh0WzJdLHRbM10pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1bn19KSx1bi5jb21wdXRlSW50ZXJzZWN0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgdW4odCk7cmV0dXJuIGUuc2V0RmluZEFsbEludGVyc2VjdGlvbnMoITApLGUuaXNWYWxpZCgpLGUuZ2V0SW50ZXJzZWN0aW9ucygpfSxlKGxuLnByb3RvdHlwZSx7Y2hlY2tWYWxpZDpmdW5jdGlvbigpe3RoaXMubnYuY2hlY2tWYWxpZCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsbn19KSxsbi50b1NlZ21lbnRTdHJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBPZShpLmdldENvb3JkaW5hdGVzKCksaSkpfXJldHVybiBlfSxsbi5jaGVja1ZhbGlkPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBsbih0KTtlLmNoZWNrVmFsaWQoKX0sZShobi5wcm90b3R5cGUse21hcDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLm1hcE9wLm1hcCh0LmdldEdlb21ldHJ5TihuKSk7aS5pc0VtcHR5KCl8fGUuYWRkKGkpfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaG59fSksaG4ubWFwPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGhuKGUpO3JldHVybiBuLm1hcCh0KX0sZShjbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNufX0pLGNuLm9wcG9zaXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0PT09Y24uTEVGVD9jbi5SSUdIVDp0PT09Y24uUklHSFQ/Y24uTEVGVDp0fSxjbi5PTj0wLGNuLkxFRlQ9MSxjbi5SSUdIVD0yLGUoZm4ucHJvdG90eXBlLHtzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT10fSxpc051bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdIT09TC5OT05FKXJldHVybiExO3JldHVybiEwfSxzZXRBbGxMb2NhdGlvbnNJZk51bGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspdGhpcy5sb2NhdGlvbltlXT09PUwuTk9ORSYmKHRoaXMubG9jYXRpb25bZV09dCl9LGlzTGluZTpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sb2NhdGlvbi5sZW5ndGh9LG1lcmdlOmZ1bmN0aW9uKHQpe2lmKHQubG9jYXRpb24ubGVuZ3RoPnRoaXMubG9jYXRpb24ubGVuZ3RoKXt2YXIgZT1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtlW2NuLk9OXT10aGlzLmxvY2F0aW9uW2NuLk9OXSxlW2NuLkxFRlRdPUwuTk9ORSxlW2NuLlJJR0hUXT1MLk5PTkUsdGhpcy5sb2NhdGlvbj1lfWZvcih2YXIgbj0wO248dGhpcy5sb2NhdGlvbi5sZW5ndGg7bisrKXRoaXMubG9jYXRpb25bbl09PT1MLk5PTkUmJm48dC5sb2NhdGlvbi5sZW5ndGgmJih0aGlzLmxvY2F0aW9uW25dPXQubG9jYXRpb25bbl0pfSxnZXRMb2NhdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sb2NhdGlvbn0sZmxpcDpmdW5jdGlvbigpe2lmKHRoaXMubG9jYXRpb24ubGVuZ3RoPD0xKXJldHVybiBudWxsO3ZhciB0PXRoaXMubG9jYXRpb25bY24uTEVGVF07dGhpcy5sb2NhdGlvbltjbi5MRUZUXT10aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT10fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xJiZ0LmFwcGVuZChMLnRvTG9jYXRpb25TeW1ib2wodGhpcy5sb2NhdGlvbltjbi5MRUZUXSkpLHQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLk9OXSkpLHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXSkpLHQudG9TdHJpbmcoKX0sc2V0TG9jYXRpb25zOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmxvY2F0aW9uW2NuLk9OXT10LHRoaXMubG9jYXRpb25bY24uTEVGVF09ZSx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT1ufSxnZXQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8dGhpcy5sb2NhdGlvbi5sZW5ndGg/dGhpcy5sb2NhdGlvblt0XTpMLk5PTkV9LGlzQXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9uLmxlbmd0aD4xfSxpc0FueU51bGw6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMubG9jYXRpb24ubGVuZ3RoO3QrKylpZih0aGlzLmxvY2F0aW9uW3RdPT09TC5OT05FKXJldHVybiEwO3JldHVybiExfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRMb2NhdGlvbihjbi5PTix0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5sb2NhdGlvbltlXT1ufX0saW5pdDpmdW5jdGlvbih0KXt0aGlzLmxvY2F0aW9uPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLHRoaXMuc2V0QWxsTG9jYXRpb25zKEwuTk9ORSl9LGlzRXF1YWxPblNpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5sb2NhdGlvbltlXT09PXQubG9jYXRpb25bZV19LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5sb2NhdGlvbi5sZW5ndGg7ZSsrKWlmKHRoaXMubG9jYXRpb25bZV0hPT10KXJldHVybiExO3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmbn19KSxlKGduLnByb3RvdHlwZSx7Z2V0R2VvbWV0cnlDb3VudDpmdW5jdGlvbigpe3ZhciB0PTA7cmV0dXJuIHRoaXMuZWx0WzBdLmlzTnVsbCgpfHx0KyssdGhpcy5lbHRbMV0uaXNOdWxsKCl8fHQrKyx0fSxzZXRBbGxMb2NhdGlvbnM6ZnVuY3Rpb24odCxlKXt0aGlzLmVsdFt0XS5zZXRBbGxMb2NhdGlvbnMoZSl9LGlzTnVsbDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNOdWxsKCl9LHNldEFsbExvY2F0aW9uc0lmTnVsbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0KSx0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFtlXS5zZXRBbGxMb2NhdGlvbnNJZk51bGwobil9fSxpc0xpbmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzTGluZSgpfSxtZXJnZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDsyPmU7ZSsrKW51bGw9PT10aGlzLmVsdFtlXSYmbnVsbCE9PXQuZWx0W2VdP3RoaXMuZWx0W2VdPW5ldyBmbih0LmVsdFtlXSk6dGhpcy5lbHRbZV0ubWVyZ2UodC5lbHRbZV0pfSxmbGlwOmZ1bmN0aW9uKCl7dGhpcy5lbHRbMF0uZmxpcCgpLHRoaXMuZWx0WzFdLmZsaXAoKX0sZ2V0TG9jYXRpb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5nZXQoY24uT04pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuZWx0W2VdLmdldChuKX19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7cmV0dXJuIG51bGwhPT10aGlzLmVsdFswXSYmKHQuYXBwZW5kKFwiQTpcIiksdC5hcHBlbmQodGhpcy5lbHRbMF0udG9TdHJpbmcoKSkpLG51bGwhPT10aGlzLmVsdFsxXSYmKHQuYXBwZW5kKFwiIEI6XCIpLHQuYXBwZW5kKHRoaXMuZWx0WzFdLnRvU3RyaW5nKCkpKSx0LnRvU3RyaW5nKCl9LGlzQXJlYTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmVsdFswXS5pc0FyZWEoKXx8dGhpcy5lbHRbMV0uaXNBcmVhKCk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBcmVhKCl9fSxpc0FueU51bGw6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZWx0W3RdLmlzQW55TnVsbCgpfSxzZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5lbHRbdF0uc2V0TG9jYXRpb24oY24uT04sZSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuZWx0W25dLnNldExvY2F0aW9uKGkscil9fSxpc0VxdWFsT25TaWRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0WzBdLmlzRXF1YWxPblNpZGUodC5lbHRbMF0sZSkmJnRoaXMuZWx0WzFdLmlzRXF1YWxPblNpZGUodC5lbHRbMV0sZSl9LGFsbFBvc2l0aW9uc0VxdWFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZWx0W3RdLmFsbFBvc2l0aW9uc0VxdWFsKGUpfSx0b0xpbmU6ZnVuY3Rpb24odCl7dGhpcy5lbHRbdF0uaXNBcmVhKCkmJih0aGlzLmVsdFt0XT1uZXcgZm4odGhpcy5lbHRbdF0ubG9jYXRpb25bMF0pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ259fSksZ24udG9MaW5lTGFiZWw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBnbihMLk5PTkUpLG49MDsyPm47bisrKWUuc2V0TG9jYXRpb24obix0LmdldExvY2F0aW9uKG4pKTtyZXR1cm4gZX0sZShkbi5wcm90b3R5cGUse2NvbXB1dGVSaW5nOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmluZylyZXR1cm4gbnVsbDtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMucHRzLnNpemUoKSkuZmlsbChudWxsKSxlPTA7ZTx0aGlzLnB0cy5zaXplKCk7ZSsrKXRbZV09dGhpcy5wdHMuZ2V0KGUpO3RoaXMucmluZz10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHQpLHRoaXMuX2lzSG9sZT1oZS5pc0NDVyh0aGlzLnJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSl9LGlzSXNvbGF0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpfSxjb21wdXRlUG9pbnRzOmZ1bmN0aW9uKHQpe3RoaXMuc3RhcnREZT10O3ZhciBlPXQsbj0hMDtkb3tpZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJGb3VuZCBudWxsIERpcmVjdGVkRWRnZVwiKTtpZihlLmdldEVkZ2VSaW5nKCk9PT10aGlzKXRocm93IG5ldyBzbihcIkRpcmVjdGVkIEVkZ2UgdmlzaXRlZCB0d2ljZSBkdXJpbmcgcmluZy1idWlsZGluZyBhdCBcIitlLmdldENvb3JkaW5hdGUoKSk7dGhpcy5lZGdlcy5hZGQoZSk7dmFyIGk9ZS5nZXRMYWJlbCgpO2YuaXNUcnVlKGkuaXNBcmVhKCkpLHRoaXMubWVyZ2VMYWJlbChpKSx0aGlzLmFkZFBvaW50cyhlLmdldEVkZ2UoKSxlLmlzRm9yd2FyZCgpLG4pLG49ITEsdGhpcy5zZXRFZGdlUmluZyhlLHRoaXMpLGU9dGhpcy5nZXROZXh0KGUpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpfSxnZXRMaW5lYXJSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmluZ30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wdHMuZ2V0KHQpfSxjb21wdXRlTWF4Tm9kZURlZ3JlZTpmdW5jdGlvbigpe3RoaXMubWF4Tm9kZURlZ3JlZT0wO3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKSxuPWUuZ2V0RWRnZXMoKS5nZXRPdXRnb2luZ0RlZ3JlZSh0aGlzKTtuPnRoaXMubWF4Tm9kZURlZ3JlZSYmKHRoaXMubWF4Tm9kZURlZ3JlZT1uKSx0PXRoaXMuZ2V0TmV4dCh0KX13aGlsZSh0IT09dGhpcy5zdGFydERlKTt0aGlzLm1heE5vZGVEZWdyZWUqPTJ9LGFkZFBvaW50czpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpO2lmKGUpe3ZhciByPTE7biYmKHI9MCk7Zm9yKHZhciBzPXI7czxpLmxlbmd0aDtzKyspdGhpcy5wdHMuYWRkKGlbc10pfWVsc2V7dmFyIHI9aS5sZW5ndGgtMjtuJiYocj1pLmxlbmd0aC0xKTtmb3IodmFyIHM9cjtzPj0wO3MtLSl0aGlzLnB0cy5hZGQoaVtzXSl9fSxpc0hvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlfSxzZXRJblJlc3VsdDpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkbyB0LmdldEVkZ2UoKS5zZXRJblJlc3VsdCghMCksdD10LmdldE5leHQoKTt3aGlsZSh0IT09dGhpcy5zdGFydERlKX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldExpbmVhclJpbmcoKSxuPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFuLmNvbnRhaW5zKHQpKXJldHVybiExO2lmKCFoZS5pc1BvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKSlyZXR1cm4hMTtmb3IodmFyIGk9dGhpcy5ob2xlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYoci5jb250YWluc1BvaW50KHQpKXJldHVybiExfXJldHVybiEwfSxhZGRIb2xlOmZ1bmN0aW9uKHQpe3RoaXMuaG9sZXMuYWRkKHQpfSxpc1NoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnNoZWxsfSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxnZXRNYXhOb2RlRGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4Tm9kZURlZ3JlZTwwJiZ0aGlzLmNvbXB1dGVNYXhOb2RlRGVncmVlKCksdGhpcy5tYXhOb2RlRGVncmVlfSxnZXRTaGVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsfSxtZXJnZUxhYmVsOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodCwwKSx0aGlzLm1lcmdlTGFiZWwodCwxKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1lLmdldExvY2F0aW9uKG4sY24uUklHSFQpO2lmKGk9PT1MLk5PTkUpcmV0dXJuIG51bGw7aWYodGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKT09PUwuTk9ORSlyZXR1cm4gdGhpcy5sYWJlbC5zZXRMb2NhdGlvbihuLGkpLG51bGx9fSxzZXRTaGVsbDpmdW5jdGlvbih0KXt0aGlzLnNoZWxsPXQsbnVsbCE9PXQmJnQuYWRkSG9sZSh0aGlzKX0sdG9Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodGhpcy5ob2xlcy5zaXplKCkpLmZpbGwobnVsbCksbj0wO248dGhpcy5ob2xlcy5zaXplKCk7bisrKWVbbl09dGhpcy5ob2xlcy5nZXQobikuZ2V0TGluZWFyUmluZygpO3ZhciBpPXQuY3JlYXRlUG9seWdvbih0aGlzLmdldExpbmVhclJpbmcoKSxlKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZG59fSksaChwbixkbiksZShwbi5wcm90b3R5cGUse3NldEVkZ2VSaW5nOmZ1bmN0aW9uKHQsZSl7dC5zZXRNaW5FZGdlUmluZyhlKX0sZ2V0TmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXROZXh0TWluKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBufX0pLGgodm4sZG4pLGUodm4ucHJvdG90eXBlLHtidWlsZE1pbmltYWxSaW5nczpmdW5jdGlvbigpe3ZhciB0PW5ldyBJLGU9dGhpcy5zdGFydERlO2Rve2lmKG51bGw9PT1lLmdldE1pbkVkZ2VSaW5nKCkpe3ZhciBuPW5ldyBwbihlLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTt0LmFkZChuKX1lPWUuZ2V0TmV4dCgpfXdoaWxlKGUhPT10aGlzLnN0YXJ0RGUpO3JldHVybiB0fSxzZXRFZGdlUmluZzpmdW5jdGlvbih0LGUpe3Quc2V0RWRnZVJpbmcoZSl9LGxpbmtEaXJlY3RlZEVkZ2VzRm9yTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3RhcnREZTtkb3t2YXIgZT10LmdldE5vZGUoKTtlLmdldEVkZ2VzKCkubGlua01pbmltYWxEaXJlY3RlZEVkZ2VzKHRoaXMpLHQ9dC5nZXROZXh0KCl9d2hpbGUodCE9PXRoaXMuc3RhcnREZSl9LGdldE5leHQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQuZ2V0TmV4dCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2bn19KSxlKG1uLnByb3RvdHlwZSx7c2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJblJlc3VsdD10fSxpc0NvdmVyZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkfSxpc0NvdmVyZWRTZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNDb3ZlcmVkU2V0fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldENvdmVyZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNDb3ZlcmVkPXQsdGhpcy5faXNDb3ZlcmVkU2V0PSEwfSx1cGRhdGVJTTpmdW5jdGlvbih0KXtmLmlzVHJ1ZSh0aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKT49MixcImZvdW5kIHBhcnRpYWwgbGFiZWxcIiksdGhpcy5jb21wdXRlSU0odCl9LGlzSW5SZXN1bHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJblJlc3VsdH0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbW59fSksaCh5bixtbiksZSh5bi5wcm90b3R5cGUse2lzSW5jaWRlbnRFZGdlSW5SZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZXRFZGdlcygpLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2lmKGUuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSlyZXR1cm4hMH1yZXR1cm4hMX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwibm9kZSBcIit0aGlzLmNvb3JkK1wiIGxibDogXCIrdGhpcy5sYWJlbCl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXt9LGNvbXB1dGVNZXJnZWRMb2NhdGlvbjpmdW5jdGlvbih0LGUpe3ZhciBuPUwuTk9ORTtpZihuPXRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSksIXQuaXNOdWxsKGUpKXt2YXIgaT10LmdldExvY2F0aW9uKGUpO24hPT1MLkJPVU5EQVJZJiYobj1pKX1yZXR1cm4gbn0sc2V0TGFiZWw6ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbW4ucHJvdG90eXBlLnNldExhYmVsLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07bnVsbD09PXRoaXMubGFiZWw/dGhpcy5sYWJlbD1uZXcgZ24odCxlKTp0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LG1lcmdlTGFiZWw6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHluKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tZXJnZUxhYmVsKHQubGFiZWwpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnbilmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49MDsyPm47bisrKXt2YXIgaT10aGlzLmNvbXB1dGVNZXJnZWRMb2NhdGlvbihlLG4pLHI9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbihuKTtyPT09TC5OT05FJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKG4saSl9fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5lZGdlcy5pbnNlcnQodCksdC5zZXROb2RlKHRoaXMpfSxzZXRMYWJlbEJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10aGlzLmxhYmVsKXJldHVybiBudWxsO3ZhciBlPUwuTk9ORTtudWxsIT09dGhpcy5sYWJlbCYmKGU9dGhpcy5sYWJlbC5nZXRMb2NhdGlvbih0KSk7dmFyIG49bnVsbDtzd2l0Y2goZSl7Y2FzZSBMLkJPVU5EQVJZOm49TC5JTlRFUklPUjticmVhaztjYXNlIEwuSU5URVJJT1I6bj1MLkJPVU5EQVJZO2JyZWFrO2RlZmF1bHQ6bj1MLkJPVU5EQVJZfXRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geW59fSksZSh4bi5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGFkZE5vZGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1lJiYoZT10aGlzLm5vZGVGYWN0LmNyZWF0ZU5vZGUodCksdGhpcy5ub2RlTWFwLnB1dCh0LGUpKSxlfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciBuPWFyZ3VtZW50c1swXSxlPXRoaXMubm9kZU1hcC5nZXQobi5nZXRDb29yZGluYXRlKCkpO3JldHVybiBudWxsPT09ZT8odGhpcy5ub2RlTWFwLnB1dChuLmdldENvb3JkaW5hdGUoKSxuKSxuKTooZS5tZXJnZUxhYmVsKG4pLGUpfX0scHJpbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sdmFsdWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX0sZ2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk9PT1MLkJPVU5EQVJZJiZlLmFkZChpKX1yZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZSgpLG49dGhpcy5hZGROb2RlKGUpO24uYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4bn19KSxlKEVuLnByb3RvdHlwZSx7Y29tcGFyZURpcmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5keD09PXQuZHgmJnRoaXMuZHk9PT10LmR5PzA6dGhpcy5xdWFkcmFudD50LnF1YWRyYW50PzE6dGhpcy5xdWFkcmFudDx0LnF1YWRyYW50Py0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0LnAwLHQucDEsdGhpcy5wMSl9LGdldER5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMH0sc2V0Tm9kZTpmdW5jdGlvbih0KXt0aGlzLm5vZGU9dH0scHJpbnQ6ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hdGFuMih0aGlzLmR5LHRoaXMuZHgpLG49dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxpPW4ubGFzdEluZGV4T2YoXCIuXCIpLHI9bi5zdWJzdHJpbmcoaSsxKTt0LnByaW50KFwiICBcIityK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK2UrXCIgICBcIit0aGlzLmxhYmVsKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX0sZ2V0RGlyZWN0ZWRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDF9LGdldER4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZHh9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxnZXRRdWFkcmFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1NYXRoLmF0YW4yKHRoaXMuZHksdGhpcy5keCksZT10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLG49ZS5sYXN0SW5kZXhPZihcIi5cIiksaT1lLnN1YnN0cmluZyhuKzEpO3JldHVyblwiICBcIitpK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK3QrXCIgICBcIit0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWw6ZnVuY3Rpb24odCl7fSxpbml0OmZ1bmN0aW9uKHQsZSl7dGhpcy5wMD10LHRoaXMucDE9ZSx0aGlzLmR4PWUueC10LngsdGhpcy5keT1lLnktdC55LHRoaXMucXVhZHJhbnQ9SmUucXVhZHJhbnQodGhpcy5keCx0aGlzLmR5KSxmLmlzVHJ1ZSghKDA9PT10aGlzLmR4JiYwPT09dGhpcy5keSksXCJFZGdlRW5kIHdpdGggaWRlbnRpY2FsIGVuZHBvaW50cyBmb3VuZFwiKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVufX0pLGgoSW4sRW4pLGUoSW4ucHJvdG90eXBlLHtnZXROZXh0TWluOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dE1pbn0sZ2V0RGVwdGg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVwdGhbdF19LHNldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LGNvbXB1dGVEaXJlY3RlZExhYmVsOmZ1bmN0aW9uKCl7dGhpcy5sYWJlbD1uZXcgZ24odGhpcy5lZGdlLmdldExhYmVsKCkpLHRoaXMuX2lzRm9yd2FyZHx8dGhpcy5sYWJlbC5mbGlwKCl9LGdldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0fSxzZXREZXB0aDpmdW5jdGlvbih0LGUpe2lmKC05OTkhPT10aGlzLmRlcHRoW3RdJiZ0aGlzLmRlcHRoW3RdIT09ZSl0aHJvdyBuZXcgc24oXCJhc3NpZ25lZCBkZXB0aHMgZG8gbm90IG1hdGNoXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO3RoaXMuZGVwdGhbdF09ZX0saXNJbnRlcmlvckFyZWFFZGdlOmZ1bmN0aW9uIHQoKXtmb3IodmFyIHQ9ITAsZT0wOzI+ZTtlKyspdGhpcy5sYWJlbC5pc0FyZWEoZSkmJnRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSxjbi5MRUZUKT09PUwuSU5URVJJT1ImJnRoaXMubGFiZWwuZ2V0TG9jYXRpb24oZSxjbi5SSUdIVCk9PT1MLklOVEVSSU9SfHwodD0hMSk7cmV0dXJuIHR9LHNldE5leHRNaW46ZnVuY3Rpb24odCl7dGhpcy5uZXh0TWluPXR9LHByaW50OmZ1bmN0aW9uKHQpe0VuLnByb3RvdHlwZS5wcmludC5jYWxsKHRoaXMsdCksdC5wcmludChcIiBcIit0aGlzLmRlcHRoW2NuLkxFRlRdK1wiL1wiK3RoaXMuZGVwdGhbY24uUklHSFRdKSx0LnByaW50KFwiIChcIit0aGlzLmdldERlcHRoRGVsdGEoKStcIilcIiksdGhpcy5faXNJblJlc3VsdCYmdC5wcmludChcIiBpblJlc3VsdFwiKX0sc2V0TWluRWRnZVJpbmc6ZnVuY3Rpb24odCl7dGhpcy5taW5FZGdlUmluZz10fSxpc0xpbmVFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5sYWJlbC5pc0xpbmUoMCl8fHRoaXMubGFiZWwuaXNMaW5lKDEpLGU9IXRoaXMubGFiZWwuaXNBcmVhKDApfHx0aGlzLmxhYmVsLmFsbFBvc2l0aW9uc0VxdWFsKDAsTC5FWFRFUklPUiksbj0hdGhpcy5sYWJlbC5pc0FyZWEoMSl8fHRoaXMubGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMSxMLkVYVEVSSU9SKTtyZXR1cm4gdCYmZSYmbn0sc2V0RWRnZVJpbmc6ZnVuY3Rpb24odCl7dGhpcy5lZGdlUmluZz10fSxnZXRNaW5FZGdlUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbkVkZ2VSaW5nfSxnZXREZXB0aERlbHRhOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5lZGdlLmdldERlcHRoRGVsdGEoKTtyZXR1cm4gdGhpcy5faXNGb3J3YXJkfHwodD0tdCksdH0sc2V0SW5SZXN1bHQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJblJlc3VsdD10fSxnZXRTeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW19LGlzRm9yd2FyZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0ZvcndhcmR9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlfSxwcmludEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5wcmludCh0KSx0LnByaW50KFwiIFwiKSx0aGlzLl9pc0ZvcndhcmQ/dGhpcy5lZGdlLnByaW50KHQpOnRoaXMuZWRnZS5wcmludFJldmVyc2UodCl9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLnN5bT10fSxzZXRWaXNpdGVkRWRnZTpmdW5jdGlvbih0KXt0aGlzLnNldFZpc2l0ZWQodCksdGhpcy5zeW0uc2V0VmlzaXRlZCh0KX0sc2V0RWRnZURlcHRoczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0RWRnZSgpLmdldERlcHRoRGVsdGEoKTt0aGlzLl9pc0ZvcndhcmR8fChuPS1uKTt2YXIgaT0xO3Q9PT1jbi5MRUZUJiYoaT0tMSk7dmFyIHI9Y24ub3Bwb3NpdGUodCkscz1uKmksbz1lK3M7dGhpcy5zZXREZXB0aCh0LGUpLHRoaXMuc2V0RGVwdGgocixvKX0sZ2V0RWRnZVJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlUmluZ30saXNJblJlc3VsdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxpc1Zpc2l0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJbn19KSxJbi5kZXB0aEZhY3Rvcj1mdW5jdGlvbih0LGUpe3JldHVybiB0PT09TC5FWFRFUklPUiYmZT09PUwuSU5URVJJT1I/MTp0PT09TC5JTlRFUklPUiYmZT09PUwuRVhURVJJT1I/LTE6MH0sZShObi5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB5bih0LG51bGwpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBObn19KSxlKENuLnByb3RvdHlwZSx7cHJpbnRFZGdlczpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJFZGdlczpcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspe3QucHJpbnRsbihcImVkZ2UgXCIrZStcIjpcIik7dmFyIG49dGhpcy5lZGdlcy5nZXQoZSk7bi5wcmludCh0KSxuLmVpTGlzdC5wcmludCh0KX19LGZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZXMuZmluZCh0KX0sYWRkTm9kZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5ub2Rlcy5hZGROb2RlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm5vZGVzLmFkZE5vZGUoZSl9fSxnZXROb2RlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlcy5pdGVyYXRvcigpfSxsaW5rUmVzdWx0RGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19LGRlYnVnUHJpbnRsbjpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKHQpfSxpc0JvdW5kYXJ5Tm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubm9kZXMuZmluZChlKTtpZihudWxsPT09bilyZXR1cm4hMTt2YXIgaT1uLmdldExhYmVsKCk7cmV0dXJuIG51bGwhPT1pJiZpLmdldExvY2F0aW9uKHQpPT09TC5CT1VOREFSWX0sbGlua0FsbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmxpbmtBbGxEaXJlY3RlZEVkZ2VzKCl9fSxtYXRjaEluU2FtZURpcmVjdGlvbjpmdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdC5lcXVhbHMobik/aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxpKT09PWhlLkNPTExJTkVBUiYmSmUucXVhZHJhbnQodCxlKT09PUplLnF1YWRyYW50KG4saSk6ITF9LGdldEVkZ2VFbmRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZExpc3R9LGRlYnVnUHJpbnQ6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnQodCl9LGdldEVkZ2VJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LGZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLmVkZ2VzLnNpemUoKTtuKyspe3ZhciBpPXRoaXMuZWRnZXMuZ2V0KG4pLHI9aS5nZXRDb29yZGluYXRlcygpO2lmKHRoaXMubWF0Y2hJblNhbWVEaXJlY3Rpb24odCxlLHJbMF0sclsxXSkpcmV0dXJuIGk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUscltyLmxlbmd0aC0xXSxyW3IubGVuZ3RoLTJdKSlyZXR1cm4gaX1yZXR1cm4gbnVsbH0saW5zZXJ0RWRnZTpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmFkZCh0KX0sZmluZEVkZ2VFbmQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBufXJldHVybiBudWxsfSxhZGRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5lZGdlcy5hZGQobik7dmFyIGk9bmV3IEluKG4sITApLHI9bmV3IEluKG4sITEpO2kuc2V0U3ltKHIpLHIuc2V0U3ltKGkpLHRoaXMuYWRkKGkpLHRoaXMuYWRkKHIpfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMubm9kZXMuYWRkKHQpLHRoaXMuZWRnZUVuZExpc3QuYWRkKHQpfSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLnZhbHVlcygpfSxmaW5kRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5lZGdlcy5zaXplKCk7bisrKXt2YXIgaT10aGlzLmVkZ2VzLmdldChuKSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKTtpZih0LmVxdWFscyhyWzBdKSYmZS5lcXVhbHMoclsxXSkpcmV0dXJuIGl9cmV0dXJuIG51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENufX0pLENuLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldEVkZ2VzKCkubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKX19LGUoU24ucHJvdG90eXBlLHtzb3J0U2hlbGxzQW5kSG9sZXM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzSG9sZSgpP24uYWRkKHIpOmUuYWRkKHIpfX0sY29tcHV0ZVBvbHlnb25zOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS50b1BvbHlnb24odGhpcy5nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHIpfXJldHVybiBlfSxwbGFjZUZyZWVIb2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihudWxsPT09aS5nZXRTaGVsbCgpKXt2YXIgcj10aGlzLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcoaSx0KTtpZihudWxsPT09cil0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gYXNzaWduIGhvbGUgdG8gYSBzaGVsbFwiLGkuZ2V0Q29vcmRpbmF0ZSgwKSk7aS5zZXRTaGVsbChyKX19fSxidWlsZE1pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgSSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKHMuZ2V0TWF4Tm9kZURlZ3JlZSgpPjIpe3MubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIG89cy5idWlsZE1pbmltYWxSaW5ncygpLGE9dGhpcy5maW5kU2hlbGwobyk7bnVsbCE9PWE/KHRoaXMucGxhY2VQb2x5Z29uSG9sZXMoYSxvKSxlLmFkZChhKSk6bi5hZGRBbGwobyl9ZWxzZSBpLmFkZChzKX1yZXR1cm4gaX0sY29udGFpbnNQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5zaGVsbExpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKG4uY29udGFpbnNQb2ludCh0KSlyZXR1cm4hMH1yZXR1cm4hMX0sYnVpbGRNYXhpbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNJblJlc3VsdCgpJiZpLmdldExhYmVsKCkuaXNBcmVhKCkmJm51bGw9PT1pLmdldEVkZ2VSaW5nKCkpe3ZhciByPW5ldyB2bihpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5KTtlLmFkZChyKSxyLnNldEluUmVzdWx0KCl9fXJldHVybiBlfSxwbGFjZVBvbHlnb25Ib2xlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSG9sZSgpJiZpLnNldFNoZWxsKHQpfX0sZ2V0UG9seWdvbnM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvbXB1dGVQb2x5Z29ucyh0aGlzLnNoZWxsTGlzdCk7cmV0dXJuIHR9LGZpbmRFZGdlUmluZ0NvbnRhaW5pbmc6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRMaW5lYXJSaW5nKCksaT1uLmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPW4uZ2V0Q29vcmRpbmF0ZU4oMCkscz1udWxsLG89bnVsbCxhPWUuaXRlcmF0b3IoKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpLGw9dS5nZXRMaW5lYXJSaW5nKCksaD1sLmdldEVudmVsb3BlSW50ZXJuYWwoKTtudWxsIT09cyYmKG89cy5nZXRMaW5lYXJSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTt2YXIgYz0hMTtoLmNvbnRhaW5zKGkpJiZoZS5pc1BvaW50SW5SaW5nKHIsbC5nZXRDb29yZGluYXRlcygpKSYmKGM9ITApLGMmJihudWxsPT09c3x8by5jb250YWlucyhoKSkmJihzPXUpfXJldHVybiBzfSxmaW5kU2hlbGw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj1udWxsLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc0hvbGUoKXx8KG49cixlKyspfXJldHVybiBmLmlzVHJ1ZSgxPj1lLFwiZm91bmQgdHdvIHNoZWxscyBpbiBNaW5pbWFsRWRnZVJpbmcgbGlzdFwiKSxufSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYWRkKHQuZ2V0RWRnZUVuZHMoKSx0LmdldE5vZGVzKCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtDbi5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcyhuKTt2YXIgaT10aGlzLmJ1aWxkTWF4aW1hbEVkZ2VSaW5ncyhlKSxyPW5ldyBJLHM9dGhpcy5idWlsZE1pbmltYWxFZGdlUmluZ3MoaSx0aGlzLnNoZWxsTGlzdCxyKTt0aGlzLnNvcnRTaGVsbHNBbmRIb2xlcyhzLHRoaXMuc2hlbGxMaXN0LHIpLHRoaXMucGxhY2VGcmVlSG9sZXModGhpcy5zaGVsbExpc3Qscil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTbn19KSxlKHduLnByb3RvdHlwZSx7Y29sbGVjdExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm9wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5jb2xsZWN0TGluZUVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCksdGhpcy5jb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2Uobix0LHRoaXMubGluZUVkZ2VzTGlzdCl9fSxsYWJlbElzb2xhdGVkTGluZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLm9wLmdldEFyZ0dlb21ldHJ5KGUpKTt0LmdldExhYmVsKCkuc2V0TG9jYXRpb24oZSxuKX0sYnVpbGQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZmluZENvdmVyZWRMaW5lRWRnZXMoKSx0aGlzLmNvbGxlY3RMaW5lcyh0KSx0aGlzLmJ1aWxkTGluZXModCksdGhpcy5yZXN1bHRMaW5lTGlzdH0sY29sbGVjdExpbmVFZGdlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldExhYmVsKCkscj10LmdldEVkZ2UoKTt0LmlzTGluZUVkZ2UoKSYmKHQuaXNWaXNpdGVkKCl8fCFpaS5pc1Jlc3VsdE9mT3AoaSxlKXx8ci5pc0NvdmVyZWQoKXx8KG4uYWRkKHIpLHQuc2V0VmlzaXRlZEVkZ2UoITApKSl9LGZpbmRDb3ZlcmVkTGluZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMub3AuZ2V0R3JhcGgoKS5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuZmluZENvdmVyZWRMaW5lRWRnZXMoKX1mb3IodmFyIG49dGhpcy5vcC5nZXRHcmFwaCgpLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRFZGdlKCk7aWYoaS5pc0xpbmVFZGdlKCkmJiFyLmlzQ292ZXJlZFNldCgpKXt2YXIgcz10aGlzLm9wLmlzQ292ZXJlZEJ5QShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRDb3ZlcmVkKHMpfX19LGxhYmVsSXNvbGF0ZWRMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7bi5pc0lzb2xhdGVkKCkmJihpLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKG4sMCk6dGhpcy5sYWJlbElzb2xhdGVkTGluZShuLDEpKX19LGJ1aWxkTGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMubGluZUVkZ2VzTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT0obi5nZXRMYWJlbCgpLHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcobi5nZXRDb29yZGluYXRlcygpKSk7dGhpcy5yZXN1bHRMaW5lTGlzdC5hZGQoaSksbi5zZXRJblJlc3VsdCghMCl9fSxjb2xsZWN0Qm91bmRhcnlUb3VjaEVkZ2U6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0TGFiZWwoKTtyZXR1cm4gdC5pc0xpbmVFZGdlKCk/bnVsbDp0LmlzVmlzaXRlZCgpP251bGw6dC5pc0ludGVyaW9yQXJlYUVkZ2UoKT9udWxsOnQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKT9udWxsOihmLmlzVHJ1ZSghKHQuaXNJblJlc3VsdCgpfHx0LmdldFN5bSgpLmlzSW5SZXN1bHQoKSl8fCF0LmdldEVkZ2UoKS5pc0luUmVzdWx0KCkpLHZvaWQoaWkuaXNSZXN1bHRPZk9wKGksZSkmJmU9PT1paS5JTlRFUlNFQ1RJT04mJihuLmFkZCh0LmdldEVkZ2UoKSksdC5zZXRWaXNpdGVkRWRnZSghMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdufX0pLGUoTG4ucHJvdG90eXBlLHtmaWx0ZXJDb3ZlcmVkTm9kZVRvUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRDb29yZGluYXRlKCk7aWYoIXRoaXMub3AuaXNDb3ZlcmVkQnlMQShlKSl7dmFyIG49dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQoZSk7dGhpcy5yZXN1bHRQb2ludExpc3QuYWRkKG4pfX0sZXh0cmFjdE5vbkNvdmVyZWRSZXN1bHROb2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKCEobi5pc0luUmVzdWx0KCl8fG4uaXNJbmNpZGVudEVkZ2VJblJlc3VsdCgpfHwwIT09bi5nZXRFZGdlcygpLmdldERlZ3JlZSgpJiZ0IT09aWkuSU5URVJTRUNUSU9OKSl7dmFyIGk9bi5nZXRMYWJlbCgpO2lpLmlzUmVzdWx0T2ZPcChpLHQpJiZ0aGlzLmZpbHRlckNvdmVyZWROb2RlVG9Qb2ludChuKX19fSxidWlsZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5leHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzKHQpLHRoaXMucmVzdWx0UG9pbnRMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMbn19KSxlKFJuLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUm59fSksZShUbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gVG4ubG9jYXRlKHQsdGhpcy5nZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUm5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUbn19KSxUbi5pc1BvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/aGUuaXNQb2ludEluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6ITF9LFRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb249ZnVuY3Rpb24odCxlKXtpZihlLmlzRW1wdHkoKSlyZXR1cm4hMTt2YXIgbj1lLmdldEV4dGVyaW9yUmluZygpO2lmKCFUbi5pc1BvaW50SW5SaW5nKHQsbikpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTxlLmdldE51bUludGVyaW9yUmluZygpO2krKyl7dmFyIHI9ZS5nZXRJbnRlcmlvclJpbmdOKGkpO2lmKFRuLmlzUG9pbnRJblJpbmcodCxyKSlyZXR1cm4hMX1yZXR1cm4hMH0sVG4uY29udGFpbnNQb2ludD1mdW5jdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBUdClyZXR1cm4gVG4uY29udGFpbnNQb2ludEluUG9seWdvbih0LGUpO2lmKGUgaW5zdGFuY2VvZiBmdClmb3IodmFyIG49bmV3IFJlKGUpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaSE9PWUmJlRuLmNvbnRhaW5zUG9pbnQodCxpKSlyZXR1cm4hMH1yZXR1cm4hMX0sVG4ubG9jYXRlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP0wuRVhURVJJT1I6VG4uY29udGFpbnNQb2ludCh0LGUpP0wuSU5URVJJT1I6TC5FWFRFUklPUn0sZShQbi5wcm90b3R5cGUse2dldE5leHRDVzpmdW5jdGlvbih0KXt0aGlzLmdldEVkZ2VzKCk7dmFyIGU9dGhpcy5lZGdlTGlzdC5pbmRleE9mKHQpLG49ZS0xO3JldHVybiAwPT09ZSYmKG49dGhpcy5lZGdlTGlzdC5zaXplKCktMSksdGhpcy5lZGdlTGlzdC5nZXQobil9LHByb3BhZ2F0ZVNpZGVMYWJlbHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPUwuTk9ORSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpO3IuaXNBcmVhKHQpJiZyLmdldExvY2F0aW9uKHQsY24uTEVGVCkhPT1MLk5PTkUmJihlPXIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSl9aWYoZT09PUwuTk9ORSlyZXR1cm4gbnVsbDtmb3IodmFyIHM9ZSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpO2lmKHIuZ2V0TG9jYXRpb24odCxjbi5PTik9PT1MLk5PTkUmJnIuc2V0TG9jYXRpb24odCxjbi5PTixzKSxyLmlzQXJlYSh0KSl7dmFyIG89ci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpLGE9ci5nZXRMb2NhdGlvbih0LGNuLlJJR0hUKTtpZihhIT09TC5OT05FKXtpZihhIT09cyl0aHJvdyBuZXcgc24oXCJzaWRlIGxvY2F0aW9uIGNvbmZsaWN0XCIsaS5nZXRDb29yZGluYXRlKCkpO289PT1MLk5PTkUmJmYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlIChhdCBcIitpLmdldENvb3JkaW5hdGUoKStcIilcIikscz1vfWVsc2UgZi5pc1RydWUoci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpPT09TC5OT05FLFwiZm91bmQgc2luZ2xlIG51bGwgc2lkZVwiKSxyLnNldExvY2F0aW9uKHQsY24uUklHSFQscyksci5zZXRMb2NhdGlvbih0LGNuLkxFRlQscyl9fX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpfSxwcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpfX0saXNBcmVhTGFiZWxzQ29uc2lzdGVudDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0LmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5jaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50KDApfSxjaGVja0FyZWFMYWJlbHNDb25zaXN0ZW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0RWRnZXMoKTtpZihlLnNpemUoKTw9MClyZXR1cm4hMDt2YXIgbj1lLnNpemUoKS0xLGk9ZS5nZXQobikuZ2V0TGFiZWwoKSxyPWkuZ2V0TG9jYXRpb24odCxjbi5MRUZUKTtmLmlzVHJ1ZShyIT09TC5OT05FLFwiRm91bmQgdW5sYWJlbGxlZCBhcmVhIGVkZ2VcIik7Zm9yKHZhciBzPXIsbz10aGlzLml0ZXJhdG9yKCk7by5oYXNOZXh0KCk7KXt2YXIgYT1vLm5leHQoKSx1PWEuZ2V0TGFiZWwoKTtcbmYuaXNUcnVlKHUuaXNBcmVhKHQpLFwiRm91bmQgbm9uLWFyZWEgZWRnZVwiKTt2YXIgbD11LmdldExvY2F0aW9uKHQsY24uTEVGVCksaD11LmdldExvY2F0aW9uKHQsY24uUklHSFQpO2lmKGw9PT1oKXJldHVybiExO2lmKGghPT1zKXJldHVybiExO3M9bH1yZXR1cm4hMH0sZmluZEluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuaXRlcmF0b3IoKTtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZUxpc3Quc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5lZGdlTGlzdC5nZXQoZSk7aWYobj09PXQpcmV0dXJuIGV9cmV0dXJuLTF9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RWRnZXMoKS5pdGVyYXRvcigpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5lZGdlTGlzdCYmKHRoaXMuZWRnZUxpc3Q9bmV3IEkodGhpcy5lZGdlTWFwLnZhbHVlcygpKSksdGhpcy5lZGdlTGlzdH0sZ2V0TG9jYXRpb246ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF09PT1MLk5PTkUmJih0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF09VG4ubG9jYXRlKGUsblt0XS5nZXRHZW9tZXRyeSgpKSksdGhpcy5wdEluQXJlYUxvY2F0aW9uW3RdfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3QuYXBwZW5kKFwiRWRnZUVuZFN0YXI6ICAgXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpLHQuYXBwZW5kKFwiXFxuXCIpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0LmFwcGVuZChuKSx0LmFwcGVuZChcIlxcblwiKX1yZXR1cm4gdC50b1N0cmluZygpfSxjb21wdXRlRWRnZUVuZExhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5jb21wdXRlTGFiZWwodCl9fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe3RoaXMuY29tcHV0ZUVkZ2VFbmRMYWJlbHModFswXS5nZXRCb3VuZGFyeU5vZGVSdWxlKCkpLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygwKSx0aGlzLnByb3BhZ2F0ZVNpZGVMYWJlbHMoMSk7Zm9yKHZhciBlPVshMSwhMV0sbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKylyLmlzTGluZShzKSYmci5nZXRMb2NhdGlvbihzKT09PUwuQk9VTkRBUlkmJihlW3NdPSEwKTtmb3IodmFyIG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOylmb3IodmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCkscz0wOzI+cztzKyspaWYoci5pc0FueU51bGwocykpe3ZhciBvPUwuTk9ORTtpZihlW3NdKW89TC5FWFRFUklPUjtlbHNle3ZhciBhPWkuZ2V0Q29vcmRpbmF0ZSgpO289dGhpcy5nZXRMb2NhdGlvbihzLGEsdCl9ci5zZXRBbGxMb2NhdGlvbnNJZk51bGwocyxvKX19LGdldERlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VNYXAuc2l6ZSgpfSxpbnNlcnRFZGdlRW5kOmZ1bmN0aW9uKHQsZSl7dGhpcy5lZGdlTWFwLnB1dCh0LGUpLHRoaXMuZWRnZUxpc3Q9bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUG59fSksaChibixQbiksZShibi5wcm90b3R5cGUse2xpbmtSZXN1bHREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5nZXRSZXN1bHRBcmVhRWRnZXMoKTtmb3IodmFyIHQ9bnVsbCxlPW51bGwsbj10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORyxpPTA7aTx0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5zaXplKCk7aSsrKXt2YXIgcj10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5nZXQoaSkscz1yLmdldFN5bSgpO2lmKHIuZ2V0TGFiZWwoKS5pc0FyZWEoKSlzd2l0Y2gobnVsbD09PXQmJnIuaXNJblJlc3VsdCgpJiYodD1yKSxuKXtjYXNlIHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKCFzLmlzSW5SZXN1bHQoKSljb250aW51ZTtlPXMsbj10aGlzLkxJTktJTkdfVE9fT1VUR09JTkc7YnJlYWs7Y2FzZSB0aGlzLkxJTktJTkdfVE9fT1VUR09JTkc6aWYoIXIuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2Uuc2V0TmV4dChyKSxuPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pZihuPT09dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HKXtpZihudWxsPT09dCl0aHJvdyBuZXcgc24oXCJubyBvdXRnb2luZyBkaXJFZGdlIGZvdW5kXCIsdGhpcy5nZXRDb29yZGluYXRlKCkpO2YuaXNUcnVlKHQuaXNJblJlc3VsdCgpLFwidW5hYmxlIHRvIGxpbmsgbGFzdCBpbmNvbWluZyBkaXJFZGdlXCIpLGUuc2V0TmV4dCh0KX19LGluc2VydDpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuaW5zZXJ0RWRnZUVuZChlLGUpfSxnZXRSaWdodG1vc3RFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRFZGdlcygpLGU9dC5zaXplKCk7aWYoMT5lKXJldHVybiBudWxsO3ZhciBuPXQuZ2V0KDApO2lmKDE9PT1lKXJldHVybiBuO3ZhciBpPXQuZ2V0KGUtMSkscj1uLmdldFF1YWRyYW50KCkscz1pLmdldFF1YWRyYW50KCk7aWYoSmUuaXNOb3J0aGVybihyKSYmSmUuaXNOb3J0aGVybihzKSlyZXR1cm4gbjtpZighSmUuaXNOb3J0aGVybihyKSYmIUplLmlzTm9ydGhlcm4ocykpcmV0dXJuIGk7cmV0dXJuIDAhPT1uLmdldER5KCk/bjowIT09aS5nZXREeSgpP2k6KGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJmb3VuZCB0d28gaG9yaXpvbnRhbCBlZGdlcyBpbmNpZGVudCBvbiBub2RlXCIpLG51bGwpfSxwcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludGxuKFwiRGlyZWN0ZWRFZGdlU3RhcjogXCIrdGhpcy5nZXRDb29yZGluYXRlKCkpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0LnByaW50KFwib3V0IFwiKSxuLnByaW50KHQpLHQucHJpbnRsbigpLHQucHJpbnQoXCJpbiBcIiksbi5nZXRTeW0oKS5wcmludCh0KSx0LnByaW50bG4oKX19LGdldFJlc3VsdEFyZWFFZGdlczpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdClyZXR1cm4gdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q7dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Q9bmV3IEk7Zm9yKHZhciB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpOyhlLmlzSW5SZXN1bHQoKXx8ZS5nZXRTeW0oKS5pc0luUmVzdWx0KCkpJiZ0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5hZGQoZSl9cmV0dXJuIHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0fSx1cGRhdGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO2kuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDAsdC5nZXRMb2NhdGlvbigwKSksaS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMSx0LmdldExvY2F0aW9uKDEpKX19LGxpbmtBbGxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5nZXRFZGdlcygpO2Zvcih2YXIgdD1udWxsLGU9bnVsbCxuPXRoaXMuZWRnZUxpc3Quc2l6ZSgpLTE7bj49MDtuLS0pe3ZhciBpPXRoaXMuZWRnZUxpc3QuZ2V0KG4pLHI9aS5nZXRTeW0oKTtudWxsPT09ZSYmKGU9ciksbnVsbCE9PXQmJnIuc2V0TmV4dCh0KSx0PWl9ZS5zZXROZXh0KHQpfSxjb21wdXRlRGVwdGhzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZmluZEluZGV4KHQpLG49KHQuZ2V0TGFiZWwoKSx0LmdldERlcHRoKGNuLkxFRlQpKSxpPXQuZ2V0RGVwdGgoY24uUklHSFQpLHI9dGhpcy5jb21wdXRlRGVwdGhzKGUrMSx0aGlzLmVkZ2VMaXN0LnNpemUoKSxuKSxzPXRoaXMuY29tcHV0ZURlcHRocygwLGUscik7aWYocyE9PWkpdGhyb3cgbmV3IHNuKFwiZGVwdGggbWlzbWF0Y2ggYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sdT1hcmd1bWVudHNbMl0sbD11LGg9bzthPmg7aCsrKXt2YXIgYz10aGlzLmVkZ2VMaXN0LmdldChoKTtjLmdldExhYmVsKCk7Yy5zZXRFZGdlRGVwdGhzKGNuLlJJR0hULGwpLGw9Yy5nZXREZXB0aChjbi5MRUZUKX1yZXR1cm4gbH19LG1lcmdlU3ltTGFiZWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO24ubWVyZ2UoZS5nZXRTeW0oKS5nZXRMYWJlbCgpKX19LGxpbmtNaW5pbWFsRGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPW51bGwsaT10aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORyxyPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKS0xO3I+PTA7ci0tKXt2YXIgcz10aGlzLnJlc3VsdEFyZWFFZGdlTGlzdC5nZXQociksbz1zLmdldFN5bSgpO3N3aXRjaChudWxsPT09ZSYmcy5nZXRFZGdlUmluZygpPT09dCYmKGU9cyksaSl7Y2FzZSB0aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORzppZihvLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO249byxpPXRoaXMuTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuTElOS0lOR19UT19PVVRHT0lORzppZihzLmdldEVkZ2VSaW5nKCkhPT10KWNvbnRpbnVlO24uc2V0TmV4dE1pbihzKSxpPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HfX1pPT09dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HJiYoZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIGZvciBmaXJzdCBvdXRnb2luZyBkaXJFZGdlXCIpLGYuaXNUcnVlKGUuZ2V0RWRnZVJpbmcoKT09PXQsXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksbi5zZXROZXh0TWluKGUpKX0sZ2V0T3V0Z29pbmdEZWdyZWU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PTAsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzSW5SZXN1bHQoKSYmdCsrfXJldHVybiB0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGk9YXJndW1lbnRzWzBdLHQ9MCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZVJpbmcoKT09PWkmJnQrK31yZXR1cm4gdH19LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGZpbmRDb3ZlcmVkTGluZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PUwuTk9ORSxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRTeW0oKTtpZighbi5pc0xpbmVFZGdlKCkpe2lmKG4uaXNJblJlc3VsdCgpKXt0PUwuSU5URVJJT1I7YnJlYWt9aWYoaS5pc0luUmVzdWx0KCkpe3Q9TC5FWFRFUklPUjticmVha319fWlmKHQ9PT1MLk5PTkUpcmV0dXJuIG51bGw7Zm9yKHZhciByPXQsZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0U3ltKCk7bi5pc0xpbmVFZGdlKCk/bi5nZXRFZGdlKCkuc2V0Q292ZXJlZChyPT09TC5JTlRFUklPUik6KG4uaXNJblJlc3VsdCgpJiYocj1MLkVYVEVSSU9SKSxpLmlzSW5SZXN1bHQoKSYmKHI9TC5JTlRFUklPUikpfX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXtQbi5wcm90b3R5cGUuY29tcHV0ZUxhYmVsbGluZy5jYWxsKHRoaXMsdCksdGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldEVkZ2UoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKyl7dmFyIG89ci5nZXRMb2NhdGlvbihzKTtvIT09TC5JTlRFUklPUiYmbyE9PUwuQk9VTkRBUll8fHRoaXMubGFiZWwuc2V0TG9jYXRpb24ocyxMLklOVEVSSU9SKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJufX0pLGgoT24sTm4pLGUoT24ucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeW4odCxuZXcgYm4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPbn19KSxlKF9uLnByb3RvdHlwZSx7Y29tcHV0ZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlKXt0aGlzLm1jZS5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuY2hhaW5JbmRleCx0Lm1jZSx0LmNoYWluSW5kZXgsZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9ufX0pLGUoTW4ucHJvdG90eXBlLHtpc0RlbGV0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmV2ZW50VHlwZT09PU1uLkRFTEVURX0sc2V0RGVsZXRlRXZlbnRJbmRleDpmdW5jdGlvbih0KXt0aGlzLmRlbGV0ZUV2ZW50SW5kZXg9dH0sZ2V0T2JqZWN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub2JqfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy54VmFsdWU8ZS54VmFsdWU/LTE6dGhpcy54VmFsdWU+ZS54VmFsdWU/MTp0aGlzLmV2ZW50VHlwZTxlLmV2ZW50VHlwZT8tMTp0aGlzLmV2ZW50VHlwZT5lLmV2ZW50VHlwZT8xOjB9LGdldEluc2VydEV2ZW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5zZXJ0RXZlbnR9LGlzSW5zZXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZlbnRUeXBlPT09TW4uSU5TRVJUfSxpc1NhbWVMYWJlbDpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMubGFiZWw/ITE6dGhpcy5sYWJlbD09PXQubGFiZWx9LGdldERlbGV0ZUV2ZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZWxldGVFdmVudEluZGV4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTW59fSksTW4uSU5TRVJUPTEsTW4uREVMRVRFPTIsZShEbi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERufX0pLGUoQW4ucHJvdG90eXBlLHtpc1RyaXZpYWxJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJjE9PT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihBbi5pc0FkamFjZW50U2VnbWVudHMoZSxpKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe3ZhciByPXQuZ2V0TnVtUG9pbnRzKCktMTtpZigwPT09ZSYmaT09PXJ8fDA9PT1pJiZlPT09cilyZXR1cm4hMH19cmV0dXJuITF9LGdldFByb3BlckludGVyc2VjdGlvblBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9LHNldElzRG9uZUlmUHJvcGVySW50OmZ1bmN0aW9uKHQpe3RoaXMuaXNEb25lV2hlblByb3BlckludD10fSxoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3BlckludGVyaW9yfSxpc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpO2lmKHQuaXNJbnRlcnNlY3Rpb24ocikpcmV0dXJuITB9cmV0dXJuITF9LGhhc1Byb3BlckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3Blcn0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRG9uZX0saXNCb3VuZGFyeVBvaW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT1lPyExOnRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzBdKT8hMDohIXRoaXMuaXNCb3VuZGFyeVBvaW50SW50ZXJuYWwodCxlWzFdKX0sc2V0Qm91bmRhcnlOb2RlczpmdW5jdGlvbih0LGUpe3RoaXMuYmR5Tm9kZXM9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5iZHlOb2Rlc1swXT10LHRoaXMuYmR5Tm9kZXNbMV09ZX0sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLnJlY29yZElzb2xhdGVkJiYodC5zZXRJc29sYXRlZCghMSksbi5zZXRJc29sYXRlZCghMSkpLHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMuaXNUcml2aWFsSW50ZXJzZWN0aW9uKHQsZSxuLGkpfHwodGhpcy5faGFzSW50ZXJzZWN0aW9uPSEwLCF0aGlzLmluY2x1ZGVQcm9wZXImJnRoaXMubGkuaXNQcm9wZXIoKXx8KHQuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKSksdGhpcy5saS5pc1Byb3BlcigpJiYodGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD10aGlzLmxpLmdldEludGVyc2VjdGlvbigwKS5jb3B5KCksdGhpcy5oYXNQcm9wZXI9ITAsdGhpcy5pc0RvbmVXaGVuUHJvcGVySW50JiYodGhpcy5faXNEb25lPSEwKSx0aGlzLmlzQm91bmRhcnlQb2ludCh0aGlzLmxpLHRoaXMuYmR5Tm9kZXMpfHwodGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFufX0pLEFuLmlzQWRqYWNlbnRTZWdtZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX0saChGbixEbiksZShGbi5wcm90b3R5cGUse3ByZXBhcmVFdmVudHM6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMuZXZlbnRzKTtmb3IodmFyIHQ9MDt0PHRoaXMuZXZlbnRzLnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZXZlbnRzLmdldCh0KTtlLmlzRGVsZXRlKCkmJmUuZ2V0SW5zZXJ0RXZlbnQoKS5zZXREZWxldGVFdmVudEluZGV4KHQpfX0sY29tcHV0ZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubk92ZXJsYXBzPTAsdGhpcy5wcmVwYXJlRXZlbnRzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmV2ZW50cy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmV2ZW50cy5nZXQoZSk7aWYobi5pc0luc2VydCgpJiZ0aGlzLnByb2Nlc3NPdmVybGFwcyhlLG4uZ2V0RGVsZXRlRXZlbnRJbmRleCgpLG4sdCksdC5pc0RvbmUoKSlicmVha319ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFuJiZSKGFyZ3VtZW50c1swXSx5KSYmUihhcmd1bWVudHNbMV0seSkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmFkZEVkZ2VzKGksaSksdGhpcy5hZGRFZGdlcyhyLHIpLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMocyl9ZWxzZSBpZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmUihhcmd1bWVudHNbMF0seSkmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQW4pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTt1P3RoaXMuYWRkRWRnZXMobyxudWxsKTp0aGlzLmFkZEVkZ2VzKG8pLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbnMoYSl9fSxhZGRFZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0TW9ub3RvbmVDaGFpbkVkZ2UoKSxpPW4uZ2V0U3RhcnRJbmRleGVzKCkscj0wO3I8aS5sZW5ndGgtMTtyKyspe3ZhciBzPW5ldyBfbihuLHIpLG89bmV3IE1uKGUsbi5nZXRNaW5YKHIpLHMpO3RoaXMuZXZlbnRzLmFkZChvKSx0aGlzLmV2ZW50cy5hZGQobmV3IE1uKG4uZ2V0TWF4WChyKSxvKSl9fSxwcm9jZXNzT3ZlcmxhcHM6ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPW4uZ2V0T2JqZWN0KCkscz10O2U+cztzKyspe3ZhciBvPXRoaXMuZXZlbnRzLmdldChzKTtpZihvLmlzSW5zZXJ0KCkpe3ZhciBhPW8uZ2V0T2JqZWN0KCk7bi5pc1NhbWVMYWJlbChvKXx8KHIuY29tcHV0ZUludGVyc2VjdGlvbnMoYSxpKSx0aGlzLm5PdmVybGFwcysrKX19fSxhZGRFZGdlczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixuKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sZT1pLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZEVkZ2UobixyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZufX0pLGUoR24ucHJvdG90eXBlLHtnZXRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKHRoaXMubWluPmV8fHRoaXMubWF4PHQpfSxnZXRNYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgZyh0aGlzLm1pbiwwKSxuZXcgZyh0aGlzLm1heCwwKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdufX0pLGUocW4ucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWUscj0obi5taW4rbi5tYXgpLzIscz0oaS5taW4raS5tYXgpLzI7cmV0dXJuIHM+cj8tMTpyPnM/MTowfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcW59fSksR24uTm9kZUNvbXBhcmF0b3I9cW4saChCbixHbiksZShCbi5wcm90b3R5cGUse3F1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/dm9pZCBuLnZpc2l0SXRlbSh0aGlzLml0ZW0pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJufX0pLGgoem4sR24pLGUoem4ucHJvdG90eXBlLHtidWlsZEV4dGVudDpmdW5jdGlvbih0LGUpe3RoaXMubWluPU1hdGgubWluKHQubWluLGUubWluKSx0aGlzLm1heD1NYXRoLm1heCh0Lm1heCxlLm1heCl9LHF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKHQsZSk/KG51bGwhPT10aGlzLm5vZGUxJiZ0aGlzLm5vZGUxLnF1ZXJ5KHQsZSxuKSx2b2lkKG51bGwhPT10aGlzLm5vZGUyJiZ0aGlzLm5vZGUyLnF1ZXJ5KHQsZSxuKSkpOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpufX0pLGUoVm4ucHJvdG90eXBlLHtidWlsZFRyZWU6ZnVuY3Rpb24oKXtoby5zb3J0KHRoaXMubGVhdmVzLG5ldyBJbnRlcnZhbFJUcmVlTm9kZS5Ob2RlQ29tcGFyYXRvcik7Zm9yKHZhciB0PXRoaXMubGVhdmVzLGU9bnVsbCxuPW5ldyBJOzspe2lmKHRoaXMuYnVpbGRMZXZlbCh0LG4pLDE9PT1uLnNpemUoKSlyZXR1cm4gbi5nZXQoMCk7ZT10LHQ9bixuPWV9fSxpbnNlcnQ6ZnVuY3Rpb24odCxlLG4pe2lmKG51bGwhPT10aGlzLnJvb3QpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkluZGV4IGNhbm5vdCBiZSBhZGRlZCB0byBvbmNlIGl0IGhhcyBiZWVuIHF1ZXJpZWRcIik7dGhpcy5sZWF2ZXMuYWRkKG5ldyBCbih0LGUsbikpfSxxdWVyeTpmdW5jdGlvbih0LGUsbil7dGhpcy5pbml0KCksdGhpcy5yb290LnF1ZXJ5KHQsZSxuKX0sYnVpbGRSb290OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/bnVsbDp2b2lkKHRoaXMucm9vdD10aGlzLmJ1aWxkVHJlZSgpKX0scHJpbnROb2RlOmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oc2UudG9MaW5lU3RyaW5nKG5ldyBnKHQubWluLHRoaXMubGV2ZWwpLG5ldyBnKHQubWF4LHRoaXMubGV2ZWwpKSl9LGluaXQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD9udWxsOnZvaWQgdGhpcy5idWlsZFJvb3QoKX0sYnVpbGRMZXZlbDpmdW5jdGlvbih0LGUpe3RoaXMubGV2ZWwrKyxlLmNsZWFyKCk7Zm9yKHZhciBuPTA7bjx0LnNpemUoKTtuKz0yKXt2YXIgaT10LmdldChuKSxyPW4rMTx0LnNpemUoKT90LmdldChuKTpudWxsO2lmKG51bGw9PT1yKWUuYWRkKGkpO2Vsc2V7dmFyIHM9bmV3IHpuKHQuZ2V0KG4pLHQuZ2V0KG4rMSkpO2UuYWRkKHMpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZufX0pLGUoa24ucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7aWYodGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZyYmdCBpbnN0YW5jZW9mIGJ0KXt2YXIgZT10LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkpO3JldHVybiB0aGlzLmxpbmVzLmFkZChlKSxudWxsfXQgaW5zdGFuY2VvZiBTdCYmdGhpcy5saW5lcy5hZGQodCl9LHNldEZvcmNlVG9MaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3RoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtufX0pLGtuLmdldEdlb21ldHJ5PWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdC5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyh0KSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZS5nZXRGYWN0b3J5KCkuYnVpbGRHZW9tZXRyeShrbi5nZXRMaW5lcyhlLG4pKX19LGtuLmdldExpbmVzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4ga24uZ2V0TGluZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpJiZSKGFyZ3VtZW50c1sxXSx2KSl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2tuLmdldExpbmVzKHIsbil9cmV0dXJuIG59aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9bmV3IEk7cmV0dXJuIHMuYXBwbHkobmV3IGtuKGEsbykpLGF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZSKGFyZ3VtZW50c1sxXSx2KSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdO3JldHVybiB1IGluc3RhbmNlb2YgU3Q/bC5hZGQodSk6dS5hcHBseShuZXcga24obCkpLGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZSKGFyZ3VtZW50c1swXSx2KSYmUihhcmd1bWVudHNbMV0sdikpe2Zvcih2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1hcmd1bWVudHNbMl0saT1oLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtrbi5nZXRMaW5lcyhyLGMsZil9cmV0dXJuIGN9aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmUihhcmd1bWVudHNbMV0sdikpe3ZhciBnPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXTtyZXR1cm4gZy5hcHBseShuZXcga24oZCxwKSksZH19fSxlKFluLnByb3RvdHlwZSx7dmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlufX0pLGUoVW4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGxlKHQpLG49bmV3IFhuKGUpO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHQueSx0LnksbiksZS5nZXRMb2NhdGlvbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFVufX0pLGUoWG4ucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmNvdW50ZXIuY291bnRTZWdtZW50KGUuZ2V0Q29vcmRpbmF0ZSgwKSxlLmdldENvb3JkaW5hdGUoMSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhufX0pLGUoSG4ucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1rbi5nZXRMaW5lcyh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRDb29yZGluYXRlcygpO3RoaXMuYWRkTGluZShyKX19LGFkZExpbmU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTE7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPW5ldyBjZSh0W2UtMV0sdFtlXSksaT1NYXRoLm1pbihuLnAwLnksbi5wMS55KSxyPU1hdGgubWF4KG4ucDAueSxuLnAxLnkpO3RoaXMuaW5kZXguaW5zZXJ0KGkscixuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBZbjtyZXR1cm4gdGhpcy5pbmRleC5xdWVyeSh0LGUsbiksbi5nZXRJdGVtcygpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5pbmRleC5xdWVyeShpLHIscyl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIbn19KSxVbi5TZWdtZW50VmlzaXRvcj1YbixVbi5JbnRlcnZhbEluZGV4ZWRHZW9tZXRyeT1IbixlKFduLnByb3RvdHlwZSx7Z2V0U2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KSx0LnByaW50bG4oXCIgZGlzdCA9IFwiK3RoaXMuZGlzdCl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLmNvbXBhcmUoZS5zZWdtZW50SW5kZXgsZS5kaXN0KX0saXNFbmRQb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gMD09PXRoaXMuc2VnbWVudEluZGV4JiYwPT09dGhpcy5kaXN0PyEwOnRoaXMuc2VnbWVudEluZGV4PT09dH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZCtcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4K1wiIGRpc3QgPSBcIit0aGlzLmRpc3R9LGdldERpc3RhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlzdH0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnNlZ21lbnRJbmRleDx0Py0xOnRoaXMuc2VnbWVudEluZGV4PnQ/MTp0aGlzLmRpc3Q8ZT8tMTp0aGlzLmRpc3Q+ZT8xOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXbn19KSxlKGpuLnByb3RvdHlwZSx7cHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludGxuKFwiSW50ZXJzZWN0aW9uczpcIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCkuaXRlcmF0b3IoKX0sYWRkU3BsaXRFZGdlczpmdW5jdGlvbih0KXt0aGlzLmFkZEVuZHBvaW50cygpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCksbj1lLm5leHQoKTtlLmhhc05leHQoKTspe3ZhciBpPWUubmV4dCgpLHI9dGhpcy5jcmVhdGVTcGxpdEVkZ2UobixpKTt0LmFkZChyKSxuPWl9fSxhZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2UucHRzLmxlbmd0aC0xO3RoaXMuYWRkKHRoaXMuZWRnZS5wdHNbMF0sMCwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UucHRzW3RdLHQsMCl9LGNyZWF0ZVNwbGl0RWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIsaT10aGlzLmVkZ2UucHRzW2Uuc2VnbWVudEluZGV4XSxyPWUuZGlzdD4wfHwhZS5jb29yZC5lcXVhbHMyRChpKTtyfHxuLS07dmFyIHM9bmV3IEFycmF5KG4pLmZpbGwobnVsbCksbz0wO3NbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IodmFyIGE9dC5zZWdtZW50SW5kZXgrMTthPD1lLnNlZ21lbnRJbmRleDthKyspc1tvKytdPXRoaXMuZWRnZS5wdHNbYV07cmV0dXJuIHImJihzW29dPWUuY29vcmQpLG5ldyBKbihzLG5ldyBnbih0aGlzLmVkZ2UubGFiZWwpKX0sYWRkOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgV24odCxlLG4pLHI9dGhpcy5ub2RlTWFwLmdldChpKTtyZXR1cm4gbnVsbCE9PXI/cjoodGhpcy5ub2RlTWFwLnB1dChpLGkpLGkpfSxpc0ludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYobi5jb29yZC5lcXVhbHModCkpcmV0dXJuITB9cmV0dXJuITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpufX0pLGUoS24ucHJvdG90eXBlLHtnZXRDaGFpblN0YXJ0SW5kaWNlczpmdW5jdGlvbih0KXt2YXIgZT0wLG49bmV3IEk7bi5hZGQobmV3IGIoZSkpO2Rve3ZhciBpPXRoaXMuZmluZENoYWluRW5kKHQsZSk7bi5hZGQobmV3IGIoaSkpLGU9aX13aGlsZShlPHQubGVuZ3RoLTEpO3ZhciByPUtuLnRvSW50QXJyYXkobik7cmV0dXJuIHJ9LGZpbmRDaGFpbkVuZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1KZS5xdWFkcmFudCh0W2VdLHRbZSsxXSksaT1lKzE7aTx0Lmxlbmd0aDspe3ZhciByPUplLnF1YWRyYW50KHRbaS0xXSx0W2ldKTtpZihyIT09bilicmVhaztpKyt9cmV0dXJuIGktMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS259fSksS24udG9JbnRBcnJheT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXQuZ2V0KG4pLmludFZhbHVlKCk7cmV0dXJuIGV9LGUoWm4ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sZ2V0TWF4WDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gZT5uP2U6bn0sZ2V0TWluWDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdF1dLngsbj10aGlzLnB0c1t0aGlzLnN0YXJ0SW5kZXhbdCsxXV0ueDtyZXR1cm4gbj5lP2U6bn0sY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbjpmdW5jdGlvbigpe2lmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHRoaXMuc3RhcnRJbmRleFt0XSx0aGlzLnN0YXJ0SW5kZXhbdCsxXSxlLGUuc3RhcnRJbmRleFtuXSxlLnN0YXJ0SW5kZXhbbisxXSxpKX1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1hcmd1bWVudHNbM10sdT1hcmd1bWVudHNbNF0sbD1hcmd1bWVudHNbNV0saD10aGlzLnB0c1tyXSxjPXRoaXMucHRzW3NdLGY9by5wdHNbYV0sZz1vLnB0c1t1XTtpZihzLXI9PT0xJiZ1LWE9PT0xKXJldHVybiBsLmFkZEludGVyc2VjdGlvbnModGhpcy5lLHIsby5lLGEpLG51bGw7aWYodGhpcy5lbnYxLmluaXQoaCxjKSx0aGlzLmVudjIuaW5pdChmLGcpLCF0aGlzLmVudjEuaW50ZXJzZWN0cyh0aGlzLmVudjIpKXJldHVybiBudWxsO3ZhciBkPU1hdGgudHJ1bmMoKHIrcykvMikscD1NYXRoLnRydW5jKChhK3UpLzIpO2Q+ciYmKHA+YSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHIsZCxvLGEscCxsKSx1PnAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihyLGQsbyxwLHUsbCkpLHM+ZCYmKHA+YSYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGQscyxvLGEscCxsKSx1PnAmJnRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihkLHMsbyxwLHUsbCkpfX0sZ2V0U3RhcnRJbmRleGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3RhcnRJbmRleH0sY29tcHV0ZUludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuc3RhcnRJbmRleC5sZW5ndGgtMTtuKyspZm9yKHZhciBpPTA7aTx0LnN0YXJ0SW5kZXgubGVuZ3RoLTE7aSsrKXRoaXMuY29tcHV0ZUludGVyc2VjdHNGb3JDaGFpbihuLHQsaSxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWm59fSksZShRbi5wcm90b3R5cGUse2dldERlcHRoOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuZGVwdGhbdF1bZV19LHNldERlcHRoOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmRlcHRoW3RdW2VdPW59LGlzTnVsbDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWZvcih2YXIgZT0wOzM+ZTtlKyspaWYodGhpcy5kZXB0aFt0XVtlXSE9PVFuLk5VTExfVkFMVUUpcmV0dXJuITE7cmV0dXJuITB9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kZXB0aFtuXVsxXT09PVFuLk5VTExfVkFMVUV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5kZXB0aFtpXVtyXT09PVFuLk5VTExfVkFMVUV9fSxub3JtYWxpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWlmKCF0aGlzLmlzTnVsbCh0KSl7dmFyIGU9dGhpcy5kZXB0aFt0XVsxXTt0aGlzLmRlcHRoW3RdWzJdPGUmJihlPXRoaXMuZGVwdGhbdF1bMl0pLDA+ZSYmKGU9MCk7Zm9yKHZhciBuPTE7Mz5uO24rKyl7dmFyIGk9MDt0aGlzLmRlcHRoW3RdW25dPmUmJihpPTEpLHRoaXMuZGVwdGhbdF1bbl09aX19fSxnZXREZWx0YTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtjbi5SSUdIVF0tdGhpcy5kZXB0aFt0XVtjbi5MRUZUXX0sZ2V0TG9jYXRpb246ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtlXTw9MD9MLkVYVEVSSU9SOkwuSU5URVJJT1J9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJBOiBcIit0aGlzLmRlcHRoWzBdWzFdK1wiLFwiK3RoaXMuZGVwdGhbMF1bMl0rXCIgQjogXCIrdGhpcy5kZXB0aFsxXVsxXStcIixcIit0aGlzLmRlcHRoWzFdWzJdfSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDsyPmU7ZSsrKWZvcih2YXIgbj0xOzM+bjtuKyspe3ZhciBpPXQuZ2V0TG9jYXRpb24oZSxuKTtpIT09TC5FWFRFUklPUiYmaSE9PUwuSU5URVJJT1J8fCh0aGlzLmlzTnVsbChlLG4pP3RoaXMuZGVwdGhbZV1bbl09UW4uZGVwdGhBdExvY2F0aW9uKGkpOnRoaXMuZGVwdGhbZV1bbl0rPVFuLmRlcHRoQXRMb2NhdGlvbihpKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO289PT1MLklOVEVSSU9SJiZ0aGlzLmRlcHRoW3JdW3NdKyt9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRbn19KSxRbi5kZXB0aEF0TG9jYXRpb249ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1MLkVYVEVSSU9SPzA6dD09PUwuSU5URVJJT1I/MTpRbi5OVUxMX1ZBTFVFfSxRbi5OVUxMX1ZBTFVFPS0xLGgoSm4sbW4pLGUoSm4ucHJvdG90eXBlLHtnZXREZXB0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlcHRofSxnZXRDb2xsYXBzZWRFZGdlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7dFswXT10aGlzLnB0c1swXSx0WzFdPXRoaXMucHRzWzFdO3ZhciBlPW5ldyBKbih0LGduLnRvTGluZUxhYmVsKHRoaXMubGFiZWwpKTtyZXR1cm4gZX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0lzb2xhdGVkfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2V0SXNvbGF0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJc29sYXRlZD10fSxzZXROYW1lOmZ1bmN0aW9uKHQpe3RoaXMubmFtZT10fSxlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgSm4pKXJldHVybiExO3ZhciBlPXQ7aWYodGhpcy5wdHMubGVuZ3RoIT09ZS5wdHMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgbj0hMCxpPSEwLHI9dGhpcy5wdHMubGVuZ3RoLHM9MDtzPHRoaXMucHRzLmxlbmd0aDtzKyspaWYodGhpcy5wdHNbc10uZXF1YWxzMkQoZS5wdHNbc10pfHwobj0hMSksdGhpcy5wdHNbc10uZXF1YWxzMkQoZS5wdHNbLS1yXSl8fChpPSExKSwhbiYmIWkpcmV0dXJuITE7cmV0dXJuITB9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5wdHMubGVuZ3RoPjA/dGhpcy5wdHNbMF06bnVsbDtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnB0c1t0XX19LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpLHQucHJpbnQoXCJMSU5FU1RSSU5HIChcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLnB0cy5sZW5ndGg7ZSsrKWU+MCYmdC5wcmludChcIixcIiksdC5wcmludCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3QucHJpbnQoXCIpICBcIit0aGlzLmxhYmVsK1wiIFwiK3RoaXMuZGVwdGhEZWx0YSl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXtKbi51cGRhdGVJTSh0aGlzLmxhYmVsLHQpfSxpc0NvbGxhcHNlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsLmlzQXJlYSgpPzMhPT10aGlzLnB0cy5sZW5ndGg/ITE6ISF0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbMl0pOiExfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0TWF4aW11bVNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGgtMX0sZ2V0RGVwdGhEZWx0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlcHRoRGVsdGF9LGdldE51bVBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LHByaW50UmV2ZXJzZTpmdW5jdGlvbih0KXt0LnByaW50KFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKTtmb3IodmFyIGU9dGhpcy5wdHMubGVuZ3RoLTE7ZT49MDtlLS0pdC5wcmludCh0aGlzLnB0c1tlXStcIiBcIik7dC5wcmludGxuKFwiXCIpfSxnZXRNb25vdG9uZUNoYWluRWRnZTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5tY2UmJih0aGlzLm1jZT1uZXcgWm4odGhpcykpLHRoaXMubWNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7dGhpcy5lbnY9bmV3IEM7Zm9yKHZhciB0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMuZW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLnB0c1t0XSl9cmV0dXJuIHRoaXMuZW52fSxhZGRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGcodC5nZXRJbnRlcnNlY3Rpb24oaSkpLHM9ZSxvPXQuZ2V0RWRnZURpc3RhbmNlKG4saSksYT1zKzE7aWYoYTx0aGlzLnB0cy5sZW5ndGgpe3ZhciB1PXRoaXMucHRzW2FdO3IuZXF1YWxzMkQodSkmJihzPWEsbz0wKX10aGlzLmVpTGlzdC5hZGQocixzLG8pfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBQO3QuYXBwZW5kKFwiZWRnZSBcIit0aGlzLm5hbWUrXCI6IFwiKSx0LmFwcGVuZChcIkxJTkVTVFJJTkcgKFwiKTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LmFwcGVuZChcIixcIiksdC5hcHBlbmQodGhpcy5wdHNbZV0ueCtcIiBcIit0aGlzLnB0c1tlXS55KTtyZXR1cm4gdC5hcHBlbmQoXCIpICBcIit0aGlzLmxhYmVsK1wiIFwiK3RoaXMuZGVwdGhEZWx0YSksdC50b1N0cmluZygpfSxpc1BvaW50d2lzZUVxdWFsOmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRzLmxlbmd0aCE9PXQucHRzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspaWYoIXRoaXMucHRzW2VdLmVxdWFsczJEKHQucHRzW2VdKSlyZXR1cm4hMTtyZXR1cm4hMH0sc2V0RGVwdGhEZWx0YTpmdW5jdGlvbih0KXt0aGlzLmRlcHRoRGVsdGE9dH0sZ2V0RWRnZUludGVyc2VjdGlvbkxpc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5laUxpc3R9LGFkZEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtpKyspdGhpcy5hZGRJbnRlcnNlY3Rpb24odCxlLG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpufX0pLEpuLnVwZGF0ZUlNPWZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG1uLnByb3RvdHlwZS51cGRhdGVJTS5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Uuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLk9OKSx0LmdldExvY2F0aW9uKDEsY24uT04pLDEpLHQuaXNBcmVhKCkmJihlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5MRUZUKSx0LmdldExvY2F0aW9uKDEsY24uTEVGVCksMiksZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uUklHSFQpLHQuZ2V0TG9jYXRpb24oMSxjbi5SSUdIVCksMikpfSxoKCRuLENuKSxlKCRuLnByb3RvdHlwZSx7aW5zZXJ0Qm91bmRhcnlQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMubm9kZXMuYWRkTm9kZShlKSxpPW4uZ2V0TGFiZWwoKSxyPTEscz1MLk5PTkU7cz1pLmdldExvY2F0aW9uKHQsY24uT04pLHM9PT1MLkJPVU5EQVJZJiZyKys7dmFyIG89JG4uZGV0ZXJtaW5lQm91bmRhcnkodGhpcy5ib3VuZGFyeU5vZGVSdWxlLHIpO2kuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZVNlbGZOb2RlczpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuY29tcHV0ZVNlbGZOb2Rlcyh0LGUsITEpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz1uZXcgQW4obiwhMCwhMSk7cy5zZXRJc0RvbmVJZlByb3BlckludChyKTt2YXIgbz10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpLGE9dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgYnR8fHRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIFR0fHx0aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBPdCx1PWl8fCFhO3JldHVybiBvLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuZWRnZXMscyx1KSx0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2Rlcyh0aGlzLmFyZ0luZGV4KSxzfX0sY29tcHV0ZVNwbGl0RWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZWlMaXN0LmFkZFNwbGl0RWRnZXModCl9fSxjb21wdXRlRWRnZUludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBBbihlLG4sITApO2kuc2V0Qm91bmRhcnlOb2Rlcyh0aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSx0LmdldEJvdW5kYXJ5Tm9kZXMoKSk7dmFyIHI9dGhpcy5jcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3IoKTtyZXR1cm4gci5jb21wdXRlSW50ZXJzZWN0aW9ucyh0aGlzLmVkZ2VzLHQuZWRnZXMsaSksaX0sZ2V0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRHZW9tfSxnZXRCb3VuZGFyeU5vZGVSdWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYm91bmRhcnlOb2RlUnVsZX0saGFzVG9vRmV3UG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50c30sYWRkUG9pbnQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldENvb3JkaW5hdGUoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZSxMLklOVEVSSU9SKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxuLEwuSU5URVJJT1IpfX0sYWRkUG9seWdvbjpmdW5jdGlvbih0KXt0aGlzLmFkZFBvbHlnb25SaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksTC5FWFRFUklPUixMLklOVEVSSU9SKTtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7ZSsrKXt2YXIgbj10LmdldEludGVyaW9yUmluZ04oZSk7dGhpcy5hZGRQb2x5Z29uUmluZyhuLEwuSU5URVJJT1IsTC5FWFRFUklPUil9fSxhZGRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuaW5zZXJ0RWRnZSh0KTt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbMF0sTC5CT1VOREFSWSksdGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LGVbZS5sZW5ndGgtMV0sTC5CT1VOREFSWSl9LGFkZExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLmludmFsaWRQb2ludD1lWzBdLG51bGw7dmFyIG49bmV3IEpuKGUsbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5JTlRFUklPUikpO3RoaXMubGluZUVkZ2VNYXAucHV0KHQsbiksdGhpcy5pbnNlcnRFZGdlKG4pLGYuaXNUcnVlKGUubGVuZ3RoPj0yLFwiZm91bmQgTGluZVN0cmluZyB3aXRoIHNpbmdsZSBwb2ludFwiKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlWzBdKSx0aGlzLmluc2VydEJvdW5kYXJ5UG9pbnQodGhpcy5hcmdJbmRleCxlW2UubGVuZ3RoLTFdKX0sZ2V0SW52YWxpZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52YWxpZFBvaW50fSxnZXRCb3VuZGFyeVBvaW50czpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldEJvdW5kYXJ5Tm9kZXMoKSxlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTAsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtlW24rK109ci5nZXRDb29yZGluYXRlKCkuY29weSgpfXJldHVybiBlfSxnZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmJvdW5kYXJ5Tm9kZXMmJih0aGlzLmJvdW5kYXJ5Tm9kZXM9dGhpcy5ub2Rlcy5nZXRCb3VuZGFyeU5vZGVzKHRoaXMuYXJnSW5kZXgpKSx0aGlzLmJvdW5kYXJ5Tm9kZXN9LGFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5pc0JvdW5kYXJ5Tm9kZSh0LGUpP251bGw6dm9pZChuPT09TC5CT1VOREFSWSYmdGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlP3RoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0LGUpOnRoaXMuaW5zZXJ0UG9pbnQodCxlLG4pKX0sYWRkUG9seWdvblJpbmc6ZnVuY3Rpb24odCxlLG4pe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBpPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihpLmxlbmd0aDw0KXJldHVybiB0aGlzLl9oYXNUb29GZXdQb2ludHM9ITAsdGhpcy5pbnZhbGlkUG9pbnQ9aVswXSxudWxsO3ZhciByPWUscz1uO2hlLmlzQ0NXKGkpJiYocj1uLHM9ZSk7dmFyIG89bmV3IEpuKGksbmV3IGduKHRoaXMuYXJnSW5kZXgsTC5CT1VOREFSWSxyLHMpKTt0aGlzLmxpbmVFZGdlTWFwLnB1dCh0LG8pLHRoaXMuaW5zZXJ0RWRnZShvKSx0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsaVswXSxMLkJPVU5EQVJZKX0saW5zZXJ0UG9pbnQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMubm9kZXMuYWRkTm9kZShlKSxyPWkuZ2V0TGFiZWwoKTtudWxsPT09cj9pLmxhYmVsPW5ldyBnbih0LG4pOnIuc2V0TG9jYXRpb24odCxuKX0sY3JlYXRlRWRnZVNldEludGVyc2VjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBGbn0sYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZWlMaXN0Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTt0aGlzLmFkZFNlbGZJbnRlcnNlY3Rpb25Ob2RlKHQscy5jb29yZCxpKX19LGFkZDpmdW5jdGlvbigpe2lmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBDbi5wcm90b3R5cGUuYWRkLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF07aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIE90JiYodGhpcy51c2VCb3VuZGFyeURldGVybWluYXRpb25SdWxlPSExKSx0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVN0cmluZyh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZFBvaW50KHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIFB0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBndCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgT3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2V7aWYoISh0IGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbih0LmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmFkZENvbGxlY3Rpb24odCl9fSxhZGRDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19LGxvY2F0ZTpmdW5jdGlvbih0KXtyZXR1cm4gUih0aGlzLnBhcmVudEdlb20sUnQpJiZ0aGlzLnBhcmVudEdlb20uZ2V0TnVtR2VvbWV0cmllcygpPjUwPyhudWxsPT09dGhpcy5hcmVhUHRMb2NhdG9yJiYodGhpcy5hcmVhUHRMb2NhdG9yPW5ldyBVbih0aGlzLnBhcmVudEdlb20pKSx0aGlzLmFyZWFQdExvY2F0b3IubG9jYXRlKHQpKTp0aGlzLnB0TG9jYXRvci5sb2NhdGUodCx0aGlzLnBhcmVudEdlb20pfSxmaW5kRWRnZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubGluZUVkZ2VNYXAuZ2V0KHQpfXJldHVybiBDbi5wcm90b3R5cGUuZmluZEVkZ2UuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiAkbn19KSwkbi5kZXRlcm1pbmVCb3VuZGFyeT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzSW5Cb3VuZGFyeShlKT9MLkJPVU5EQVJZOkwuSU5URVJJT1J9LGUodGkucHJvdG90eXBlLHtnZXRBcmdHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcmdbdF0uZ2V0R2VvbWV0cnkoKX0sc2V0Q29tcHV0YXRpb25QcmVjaXNpb246ZnVuY3Rpb24odCl7dGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbD10LHRoaXMubGkuc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRpfX0pLGUoZWkucHJvdG90eXBlLHtjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPWVpLmNvbXBhcmVPcmllbnRlZCh0aGlzLnB0cyx0aGlzLl9vcmllbnRhdGlvbixlLnB0cyxlLl9vcmllbnRhdGlvbik7cmV0dXJuIG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlaX19KSxlaS5vcmllbnRhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gMT09PUguaW5jcmVhc2luZ0RpcmVjdGlvbih0KX0sZWkuY29tcGFyZU9yaWVudGVkPWZ1bmN0aW9uKHQsZSxuLGkpe2Zvcih2YXIgcj1lPzE6LTEscz1pPzE6LTEsbz1lP3QubGVuZ3RoOi0xLGE9aT9uLmxlbmd0aDotMSx1PWU/MDp0Lmxlbmd0aC0xLGw9aT8wOm4ubGVuZ3RoLTE7Oyl7dmFyIGg9dFt1XS5jb21wYXJlVG8obltsXSk7aWYoMCE9PWgpcmV0dXJuIGg7dSs9cixsKz1zO3ZhciBjPXU9PT1vLGY9bD09PWE7aWYoYyYmIWYpcmV0dXJuLTE7aWYoIWMmJmYpcmV0dXJuIDE7aWYoYyYmZilyZXR1cm4gMH19LGUobmkucHJvdG90eXBlLHtwcmludDpmdW5jdGlvbih0KXt0LnByaW50KFwiTVVMVElMSU5FU1RSSU5HICggXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VzLmdldChlKTtlPjAmJnQucHJpbnQoXCIsXCIpLHQucHJpbnQoXCIoXCIpO2Zvcih2YXIgaT1uLmdldENvb3JkaW5hdGVzKCkscj0wO3I8aS5sZW5ndGg7cisrKXI+MCYmdC5wcmludChcIixcIiksdC5wcmludChpW3JdLngrXCIgXCIraVtyXS55KTt0LnByaW50bG4oXCIpXCIpfXQucHJpbnQoXCIpICBcIil9LGFkZEFsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSl9LGZpbmRFZGdlSW5kZXg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspaWYodGhpcy5lZGdlcy5nZXQoZSkuZXF1YWxzKHQpKXJldHVybiBlO3JldHVybi0xfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LGdldDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lZGdlcy5nZXQodCl9LGZpbmRFcXVhbEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGVpKHQuZ2V0Q29vcmRpbmF0ZXMoKSksbj10aGlzLm9jYU1hcC5nZXQoZSk7cmV0dXJuIG59LGFkZDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmFkZCh0KTt2YXIgZT1uZXcgZWkodC5nZXRDb29yZGluYXRlcygpKTt0aGlzLm9jYU1hcC5wdXQoZSx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbml9fSksaChpaSx0aSksZShpaS5wcm90b3R5cGUse2luc2VydFVuaXF1ZUVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXt2YXIgbj1lLmdldExhYmVsKCksaT10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwoaT1uZXcgZ24odC5nZXRMYWJlbCgpKSxpLmZsaXAoKSk7dmFyIHI9ZS5nZXREZXB0aCgpO3IuaXNOdWxsKCkmJnIuYWRkKG4pLHIuYWRkKGkpLG4ubWVyZ2UoaSl9ZWxzZSB0aGlzLmVkZ2VMaXN0LmFkZCh0KX0sZ2V0R3JhcGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ncmFwaH0sY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0U3ltKCk7ZS5pc0luUmVzdWx0KCkmJm4uaXNJblJlc3VsdCgpJiYoZS5zZXRJblJlc3VsdCghMSksbi5zZXRJblJlc3VsdCghMSkpfX0saXNDb3ZlcmVkQnlMQTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdExpbmVMaXN0KT8hMDohIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRQb2x5TGlzdCl9LGNvbXB1dGVHZW9tZXRyeTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgSTtyZXR1cm4gci5hZGRBbGwodCksci5hZGRBbGwoZSksci5hZGRBbGwobiksci5pc0VtcHR5KCk/aWkuY3JlYXRlRW1wdHlSZXN1bHQoaSx0aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLHRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCksdGhpcy5nZW9tRmFjdCk6dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHIpfSxtZXJnZVN5bUxhYmVsczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5tZXJnZVN5bUxhYmVscygpfX0saXNDb3ZlcmVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9dGhpcy5wdExvY2F0b3IubG9jYXRlKHQsaSk7aWYociE9PUwuRVhURVJJT1IpcmV0dXJuITB9cmV0dXJuITF9LHJlcGxhY2VDb2xsYXBzZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMuZWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNDb2xsYXBzZWQoKSYmKGUucmVtb3ZlKCksdC5hZGQobi5nZXRDb2xsYXBzZWRFZGdlKCkpKX10aGlzLmVkZ2VMaXN0LmFkZEFsbCh0KX0sdXBkYXRlTm9kZUxhYmVsbGluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRFZGdlcygpLmdldExhYmVsKCk7ZS5nZXRMYWJlbCgpLm1lcmdlKG4pfX0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29tcHV0ZU92ZXJsYXkodCksdGhpcy5yZXN1bHRHZW9tfSxpbnNlcnRVbmlxdWVFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlKG4pfX0sY29tcHV0ZU92ZXJsYXk6ZnVuY3Rpb24odCl7dGhpcy5jb3B5UG9pbnRzKDApLHRoaXMuY29weVBvaW50cygxKSx0aGlzLmFyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpLHRoaXMuYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuYXJnWzFdLHRoaXMubGksITApO3ZhciBlPW5ldyBJO3RoaXMuYXJnWzBdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpLHRoaXMuYXJnWzFdLmNvbXB1dGVTcGxpdEVkZ2VzKGUpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZXMoZSksdGhpcy5jb21wdXRlTGFiZWxzRnJvbURlcHRocygpLHRoaXMucmVwbGFjZUNvbGxhcHNlZEVkZ2VzKCksbG4uY2hlY2tWYWxpZCh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuZ3JhcGguYWRkRWRnZXModGhpcy5lZGdlTGlzdC5nZXRFZGdlcygpKSx0aGlzLmNvbXB1dGVMYWJlbGxpbmcoKSx0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGVzKCksdGhpcy5maW5kUmVzdWx0QXJlYUVkZ2VzKHQpLHRoaXMuY2FuY2VsRHVwbGljYXRlUmVzdWx0RWRnZXMoKTt2YXIgbj1uZXcgU24odGhpcy5nZW9tRmFjdCk7bi5hZGQodGhpcy5ncmFwaCksdGhpcy5yZXN1bHRQb2x5TGlzdD1uLmdldFBvbHlnb25zKCk7dmFyIGk9bmV3IHduKHRoaXMsdGhpcy5nZW9tRmFjdCx0aGlzLnB0TG9jYXRvcik7dGhpcy5yZXN1bHRMaW5lTGlzdD1pLmJ1aWxkKHQpO3ZhciByPW5ldyBMbih0aGlzLHRoaXMuZ2VvbUZhY3QsdGhpcy5wdExvY2F0b3IpO3RoaXMucmVzdWx0UG9pbnRMaXN0PXIuYnVpbGQodCksXG50aGlzLnJlc3VsdEdlb209dGhpcy5jb21wdXRlR2VvbWV0cnkodGhpcy5yZXN1bHRQb2ludExpc3QsdGhpcy5yZXN1bHRMaW5lTGlzdCx0aGlzLnJlc3VsdFBvbHlMaXN0LHQpfSxsYWJlbEluY29tcGxldGVOb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfSxjb3B5UG9pbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9dGhpcy5ncmFwaC5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKTtpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19LGZpbmRSZXN1bHRBcmVhRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ3JhcGguZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7aS5pc0FyZWEoKSYmIW4uaXNJbnRlcmlvckFyZWFFZGdlKCkmJmlpLmlzUmVzdWx0T2ZPcChpLmdldExvY2F0aW9uKDAsY24uUklHSFQpLGkuZ2V0TG9jYXRpb24oMSxjbi5SSUdIVCksdCkmJm4uc2V0SW5SZXN1bHQoITApfX0sY29tcHV0ZUxhYmVsc0Zyb21EZXB0aHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5lZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCksaT1lLmdldERlcHRoKCk7aWYoIWkuaXNOdWxsKCkpe2kubm9ybWFsaXplKCk7Zm9yKHZhciByPTA7Mj5yO3IrKyluLmlzTnVsbChyKXx8IW4uaXNBcmVhKCl8fGkuaXNOdWxsKHIpfHwoMD09PWkuZ2V0RGVsdGEocik/bi50b0xpbmUocik6KGYuaXNUcnVlKCFpLmlzTnVsbChyLGNuLkxFRlQpLFwiZGVwdGggb2YgTEVGVCBzaWRlIGhhcyBub3QgYmVlbiBpbml0aWFsaXplZFwiKSxuLnNldExvY2F0aW9uKHIsY24uTEVGVCxpLmdldExvY2F0aW9uKHIsY24uTEVGVCkpLGYuaXNUcnVlKCFpLmlzTnVsbChyLGNuLlJJR0hUKSxcImRlcHRoIG9mIFJJR0hUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24ocixjbi5SSUdIVCxpLmdldExvY2F0aW9uKHIsY24uUklHSFQpKSkpfX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkuY29tcHV0ZUxhYmVsbGluZyh0aGlzLmFyZyl9dGhpcy5tZXJnZVN5bUxhYmVscygpLHRoaXMudXBkYXRlTm9kZUxhYmVsbGluZygpfSxsYWJlbEluY29tcGxldGVOb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtuLmlzSXNvbGF0ZWQoKSYmKHQrKyxpLmlzTnVsbCgwKT90aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwwKTp0aGlzLmxhYmVsSW5jb21wbGV0ZU5vZGUobiwxKSksbi5nZXRFZGdlcygpLnVwZGF0ZUxhYmVsbGluZyhpKX19LGlzQ292ZXJlZEJ5QTpmdW5jdGlvbih0KXtyZXR1cm4hIXRoaXMuaXNDb3ZlcmVkKHQsdGhpcy5yZXN1bHRQb2x5TGlzdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlpfX0pLGlpLm92ZXJsYXlPcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IGlpKHQsZSkscj1pLmdldFJlc3VsdEdlb21ldHJ5KG4pO3JldHVybiByfSxpaS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLklOVEVSU0VDVElPTix0LGUsdC5nZXRGYWN0b3J5KCkpO2lmKHQuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7dmFyIG49ZTtyZXR1cm4gaG4ubWFwKHQse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW01hcE9wXX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyc2VjdGlvbihuKX19KX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0saWkuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSl7aWYodC5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5TWU1ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuU1lNRElGRkVSRU5DRSl9LGlpLnJlc3VsdERpbWVuc2lvbj1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5nZXREaW1lbnNpb24oKSxyPW4uZ2V0RGltZW5zaW9uKCkscz0tMTtzd2l0Y2godCl7Y2FzZSBpaS5JTlRFUlNFQ1RJT046cz1NYXRoLm1pbihpLHIpO2JyZWFrO2Nhc2UgaWkuVU5JT046cz1NYXRoLm1heChpLHIpO2JyZWFrO2Nhc2UgaWkuRElGRkVSRU5DRTpzPWk7YnJlYWs7Y2FzZSBpaS5TWU1ESUZGRVJFTkNFOnM9TWF0aC5tYXgoaSxyKX1yZXR1cm4gc30saWkuY3JlYXRlRW1wdHlSZXN1bHQ9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bnVsbDtzd2l0Y2goaWkucmVzdWx0RGltZW5zaW9uKHQsZSxuKSl7Y2FzZS0xOnI9aS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24obmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2JyZWFrO2Nhc2UgMDpyPWkuY3JlYXRlUG9pbnQoKTticmVhaztjYXNlIDE6cj1pLmNyZWF0ZUxpbmVTdHJpbmcoKTticmVhaztjYXNlIDI6cj1pLmNyZWF0ZVBvbHlnb24oKX1yZXR1cm4gcn0saWkuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiB0LmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpaS5ESUZGRVJFTkNFLHQsZSx0LmdldEZhY3RvcnkoKSk6ZS5pc0VtcHR5KCk/dC5jb3B5KCk6KHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxzaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpKX0saWkuaXNSZXN1bHRPZk9wPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0TG9jYXRpb24oMCksaT10LmdldExvY2F0aW9uKDEpO3JldHVybiBpaS5pc1Jlc3VsdE9mT3AobixpLGUpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07c3dpdGNoKHI9PT1MLkJPVU5EQVJZJiYocj1MLklOVEVSSU9SKSxzPT09TC5CT1VOREFSWSYmKHM9TC5JTlRFUklPUiksbyl7Y2FzZSBpaS5JTlRFUlNFQ1RJT046cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzPT09TC5JTlRFUklPUjtjYXNlIGlpLlVOSU9OOnJldHVybiByPT09TC5JTlRFUklPUnx8cz09PUwuSU5URVJJT1I7Y2FzZSBpaS5ESUZGRVJFTkNFOnJldHVybiByPT09TC5JTlRFUklPUiYmcyE9PUwuSU5URVJJT1I7Y2FzZSBpaS5TWU1ESUZGRVJFTkNFOnJldHVybiByPT09TC5JTlRFUklPUiYmcyE9PUwuSU5URVJJT1J8fHIhPT1MLklOVEVSSU9SJiZzPT09TC5JTlRFUklPUn1yZXR1cm4hMX19LGlpLklOVEVSU0VDVElPTj0xLGlpLlVOSU9OPTIsaWkuRElGRkVSRU5DRT0zLGlpLlNZTURJRkZFUkVOQ0U9NCxlKHJpLnByb3RvdHlwZSx7c2VsZlNuYXA6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEllKHQpLG49ZS5zbmFwVG8odCx0aGlzLnNuYXBUb2xlcmFuY2UpO3JldHVybiBufSxyZW1vdmVDb21tb25CaXRzOmZ1bmN0aW9uKHQpe3RoaXMuY2JyPW5ldyBTZSx0aGlzLmNici5hZGQodFswXSksdGhpcy5jYnIuYWRkKHRbMV0pO3ZhciBlPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO3JldHVybiBlWzBdPXRoaXMuY2JyLnJlbW92ZUNvbW1vbkJpdHModFswXS5jb3B5KCkpLGVbMV09dGhpcy5jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzFdLmNvcHkoKSksZX0scHJlcGFyZVJlc3VsdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jYnIuYWRkQ29tbW9uQml0cyh0KSx0fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnNuYXAodGhpcy5nZW9tKSxuPWlpLm92ZXJsYXlPcChlWzBdLGVbMV0sdCk7cmV0dXJuIHRoaXMucHJlcGFyZVJlc3VsdChuKX0sY2hlY2tWYWxpZDpmdW5jdGlvbih0KXt0LmlzVmFsaWQoKXx8QS5vdXQucHJpbnRsbihcIlNuYXBwZWQgZ2VvbWV0cnkgaXMgaW52YWxpZFwiKX0sY29tcHV0ZVNuYXBUb2xlcmFuY2U6ZnVuY3Rpb24oKXt0aGlzLnNuYXBUb2xlcmFuY2U9SWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0pfSxzbmFwOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucmVtb3ZlQ29tbW9uQml0cyh0KSxuPUllLnNuYXAoZVswXSxlWzFdLHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG59LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJpfX0pLHJpLm92ZXJsYXlPcD1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IHJpKHQsZSk7cmV0dXJuIGkuZ2V0UmVzdWx0R2VvbWV0cnkobil9LHJpLnVuaW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSxyaS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxyaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHJpLm92ZXJsYXlPcCh0LGUsaWkuU1lNRElGRkVSRU5DRSl9LHJpLmRpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5ESUZGRVJFTkNFKX0sZShzaS5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW51bGwsbj0hMSxpPW51bGw7dHJ5e2U9aWkub3ZlcmxheU9wKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0sdCk7dmFyIHI9ITA7ciYmKG49ITApfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGwpKXRocm93IHQ7aT10fWZpbmFsbHl7fWlmKCFuKXRyeXtlPXJpLm92ZXJsYXlPcCh0aGlzLmdlb21bMF0sdGhpcy5nZW9tWzFdLHQpfWNhdGNoKHQpe3Rocm93IHQgaW5zdGFuY2VvZiBsP2k6dH1maW5hbGx5e31yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gc2l9fSksc2kub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgc2kodCxlKTtyZXR1cm4gaS5nZXRSZXN1bHRHZW9tZXRyeShuKX0sc2kudW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHNpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LHNpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gc2kub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0sc2kuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpfSxlKG9pLnByb3RvdHlwZSx7YWRkUG9seWdvbjpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgZT1udWxsLG49MCxpPXRoaXMuaG9yaXpvbnRhbEJpc2VjdG9yKHQpO2lmKDA9PT1pLmdldExlbmd0aCgpKW49MCxlPWkuZ2V0Q29vcmRpbmF0ZSgpO2Vsc2V7dmFyIHI9c2kub3ZlcmxheU9wKGksdCxpaS5JTlRFUlNFQ1RJT04pLHM9dGhpcy53aWRlc3RHZW9tZXRyeShyKTtuPXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCksZT1vaS5jZW50cmUocy5nZXRFbnZlbG9wZUludGVybmFsKCkpfShudWxsPT09dGhpcy5pbnRlcmlvclBvaW50fHxuPnRoaXMubWF4V2lkdGgpJiYodGhpcy5pbnRlcmlvclBvaW50PWUsdGhpcy5tYXhXaWR0aD1uKX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LHdpZGVzdEdlb21ldHJ5OmZ1bmN0aW9uIHQoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KXt2YXIgZT1hcmd1bWVudHNbMF07aWYoZS5pc0VtcHR5KCkpcmV0dXJuIGU7Zm9yKHZhciB0PWUuZ2V0R2VvbWV0cnlOKDApLG49MTtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyllLmdldEdlb21ldHJ5TihuKS5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKT50LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpJiYodD1lLmdldEdlb21ldHJ5TihuKSk7cmV0dXJuIHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgaT1hcmd1bWVudHNbMF07cmV0dXJuIGkgaW5zdGFuY2VvZiBmdD90aGlzLndpZGVzdEdlb21ldHJ5KGkpOml9fSxob3Jpem9udGFsQmlzZWN0b3I6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCksbj1haS5nZXRCaXNlY3RvclkodCk7cmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyhlLmdldE1pblgoKSxuKSxuZXcgZyhlLmdldE1heFgoKSxuKV0pfSxhZGQ6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGQoZS5nZXRHZW9tZXRyeU4obikpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvaX19KSxvaS5jZW50cmU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKG9pLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSksb2kuYXZnKHQuZ2V0TWluWSgpLHQuZ2V0TWF4WSgpKSl9LG9pLmF2Zz1mdW5jdGlvbih0LGUpe3JldHVybih0K2UpLzJ9LGUoYWkucHJvdG90eXBlLHt1cGRhdGVJbnRlcnZhbDpmdW5jdGlvbih0KXt0PD10aGlzLmNlbnRyZVk/dD50aGlzLmxvWSYmKHRoaXMubG9ZPXQpOnQ+dGhpcy5jZW50cmVZJiZ0PHRoaXMuaGlZJiYodGhpcy5oaVk9dCl9LGdldEJpc2VjdG9yWTpmdW5jdGlvbigpe3RoaXMucHJvY2Vzcyh0aGlzLnBvbHkuZ2V0RXh0ZXJpb3JSaW5nKCkpO2Zvcih2YXIgdD0wO3Q8dGhpcy5wb2x5LmdldE51bUludGVyaW9yUmluZygpO3QrKyl0aGlzLnByb2Nlc3ModGhpcy5wb2x5LmdldEludGVyaW9yUmluZ04odCkpO3ZhciBlPW9pLmF2Zyh0aGlzLmhpWSx0aGlzLmxvWSk7cmV0dXJuIGV9LHByb2Nlc3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj0wO248ZS5zaXplKCk7bisrKXt2YXIgaT1lLmdldFkobik7dGhpcy51cGRhdGVJbnRlcnZhbChpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFpfX0pLGFpLmdldEJpc2VjdG9yWT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgYWkodCk7cmV0dXJuIGUuZ2V0QmlzZWN0b3JZKCl9LG9pLlNhZmVCaXNlY3RvckZpbmRlcj1haSxlKHVpLnByb3RvdHlwZSx7YWRkRW5kcG9pbnRzOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkRW5kcG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkRW5kcG9pbnRzKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLmFkZChpWzBdKSx0aGlzLmFkZChpW2kubGVuZ3RoLTFdKX19LGdldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvclBvaW50fSxhZGRJbnRlcmlvcjpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZEludGVyaW9yKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkSW50ZXJpb3IoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSlmb3IodmFyIGk9YXJndW1lbnRzWzBdLG49MTtuPGkubGVuZ3RoLTE7bisrKXRoaXMuYWRkKGlbbl0pfSxhZGQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5kaXN0YW5jZSh0aGlzLmNlbnRyb2lkKTtlPHRoaXMubWluRGlzdGFuY2UmJih0aGlzLmludGVyaW9yUG9pbnQ9bmV3IGcodCksdGhpcy5taW5EaXN0YW5jZT1lKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdWl9fSksZShsaS5wcm90b3R5cGUse2dldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvclBvaW50fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgTHQpdGhpcy5hZGQodC5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWkuZGlzdGFuY2UodGhpcy5jZW50cm9pZCk7cjx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5pbnRlcmlvclBvaW50PW5ldyBnKGkpLHRoaXMubWluRGlzdGFuY2U9cil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsaX19KSxlKGhpLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaGl9fSksaGkudG9EZWdyZWVzPWZ1bmN0aW9uKHQpe3JldHVybiAxODAqdC9NYXRoLlBJfSxoaS5ub3JtYWxpemU9ZnVuY3Rpb24odCl7Zm9yKDt0Pk1hdGguUEk7KXQtPWhpLlBJX1RJTUVTXzI7Zm9yKDt0PD0tTWF0aC5QSTspdCs9aGkuUElfVElNRVNfMjtyZXR1cm4gdH0saGkuYW5nbGU9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBNYXRoLmF0YW4yKHQueSx0LngpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uLngtZS54LHI9bi55LWUueTtyZXR1cm4gTWF0aC5hdGFuMihyLGkpfX0saGkuaXNBY3V0ZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC54LWUueCxyPXQueS1lLnkscz1uLngtZS54LG89bi55LWUueSxhPWkqcytyKm87cmV0dXJuIGE+MH0saGkuaXNPYnR1c2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQueC1lLngscj10LnktZS55LHM9bi54LWUueCxvPW4ueS1lLnksYT1pKnMrcipvO3JldHVybiAwPmF9LGhpLmludGVyaW9yQW5nbGU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWhpLmFuZ2xlKGUsdCkscj1oaS5hbmdsZShlLG4pO3JldHVybiBNYXRoLmFicyhyLWkpfSxoaS5ub3JtYWxpemVQb3NpdGl2ZT1mdW5jdGlvbih0KXtpZigwPnQpe2Zvcig7MD50Oyl0Kz1oaS5QSV9USU1FU18yO3Q+PWhpLlBJX1RJTUVTXzImJih0PTApfWVsc2V7Zm9yKDt0Pj1oaS5QSV9USU1FU18yOyl0LT1oaS5QSV9USU1FU18yOzA+dCYmKHQ9MCl9cmV0dXJuIHR9LGhpLmFuZ2xlQmV0d2Vlbj1mdW5jdGlvbih0LGUsbil7dmFyIGk9aGkuYW5nbGUoZSx0KSxyPWhpLmFuZ2xlKGUsbik7cmV0dXJuIGhpLmRpZmYoaSxyKX0saGkuZGlmZj1mdW5jdGlvbih0LGUpe3ZhciBuPW51bGw7cmV0dXJuIG49ZT50P2UtdDp0LWUsbj5NYXRoLlBJJiYobj0yKk1hdGguUEktbiksbn0saGkudG9SYWRpYW5zPWZ1bmN0aW9uKHQpe3JldHVybiB0Kk1hdGguUEkvMTgwfSxoaS5nZXRUdXJuPWZ1bmN0aW9uKHQsZSl7dmFyIG49TWF0aC5zaW4oZS10KTtyZXR1cm4gbj4wP2hpLkNPVU5URVJDTE9DS1dJU0U6MD5uP2hpLkNMT0NLV0lTRTpoaS5OT05FfSxoaS5hbmdsZUJldHdlZW5PcmllbnRlZD1mdW5jdGlvbih0LGUsbil7dmFyIGk9aGkuYW5nbGUoZSx0KSxyPWhpLmFuZ2xlKGUsbikscz1yLWk7cmV0dXJuIHM8PS1NYXRoLlBJP3MraGkuUElfVElNRVNfMjpzPk1hdGguUEk/cy1oaS5QSV9USU1FU18yOnN9LGhpLlBJX1RJTUVTXzI9MipNYXRoLlBJLGhpLlBJX09WRVJfMj1NYXRoLlBJLzIsaGkuUElfT1ZFUl80PU1hdGguUEkvNCxoaS5DT1VOVEVSQ0xPQ0tXSVNFPWhlLkNPVU5URVJDTE9DS1dJU0UsaGkuQ0xPQ0tXSVNFPWhlLkNMT0NLV0lTRSxoaS5OT05FPWhlLkNPTExJTkVBUixlKGNpLnByb3RvdHlwZSx7YXJlYTpmdW5jdGlvbigpe3JldHVybiBjaS5hcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sc2lnbmVkQXJlYTpmdW5jdGlvbigpe3JldHVybiBjaS5zaWduZWRBcmVhKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW50ZXJwb2xhdGVaOmZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXRocm93IG5ldyBpKFwiU3VwcGxpZWQgcG9pbnQgaXMgbnVsbC5cIik7cmV0dXJuIGNpLmludGVycG9sYXRlWih0LHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sbG9uZ2VzdFNpZGVMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gY2kubG9uZ2VzdFNpZGVMZW5ndGgodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpc0FjdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmlzQWN1dGUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxjaXJjdW1jZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuY2lyY3VtY2VudHJlKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sYXJlYTNEOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmFyZWEzRCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGNlbnRyb2lkOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmNlbnRyb2lkKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0saW5DZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuaW5DZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjaX19KSxjaS5hcmVhPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnMoKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMil9LGNpLnNpZ25lZEFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybigobi54LXQueCkqKGUueS10LnkpLShlLngtdC54KSoobi55LXQueSkpLzJ9LGNpLmRldD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gdCppLWUqbn0sY2kuaW50ZXJwb2xhdGVaPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWUueCxzPWUueSxvPW4ueC1yLGE9aS54LXIsdT1uLnktcyxsPWkueS1zLGg9bypsLWEqdSxjPXQueC1yLGY9dC55LXMsZz0obCpjLWEqZikvaCxkPSgtdSpjK28qZikvaCxwPWUueitnKihuLnotZS56KStkKihpLnotZS56KTtyZXR1cm4gcH0sY2kubG9uZ2VzdFNpZGVMZW5ndGg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZGlzdGFuY2UoZSkscj1lLmRpc3RhbmNlKG4pLHM9bi5kaXN0YW5jZSh0KSxvPWk7cmV0dXJuIHI+byYmKG89cikscz5vJiYobz1zKSxvfSxjaS5pc0FjdXRlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gaGkuaXNBY3V0ZSh0LGUsbikmJmhpLmlzQWN1dGUoZSxuLHQpPyEhaGkuaXNBY3V0ZShuLHQsZSk6ITF9LGNpLmNpcmN1bWNlbnRyZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bi54LHI9bi55LHM9dC54LWksbz10LnktcixhPWUueC1pLHU9ZS55LXIsbD0yKmNpLmRldChzLG8sYSx1KSxoPWNpLmRldChvLHMqcytvKm8sdSxhKmErdSp1KSxjPWNpLmRldChzLHMqcytvKm8sYSxhKmErdSp1KSxmPWktaC9sLGQ9citjL2w7cmV0dXJuIG5ldyBnKGYsZCl9LGNpLnBlcnBlbmRpY3VsYXJCaXNlY3Rvcj1mdW5jdGlvbih0LGUpe3ZhciBuPWUueC10LngsaT1lLnktdC55LHI9bmV3IEYodC54K24vMix0LnkraS8yLDEpLHM9bmV3IEYodC54LWkrbi8yLHQueStuK2kvMiwxKTtyZXR1cm4gbmV3IEYocixzKX0sY2kuYW5nbGVCaXNlY3Rvcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS5kaXN0YW5jZSh0KSxyPWUuZGlzdGFuY2Uobikscz1pLyhpK3IpLG89bi54LXQueCxhPW4ueS10LnksdT1uZXcgZyh0LngrcypvLHQueStzKmEpO3JldHVybiB1fSxjaS5hcmVhM0Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUueC10Lngscj1lLnktdC55LHM9ZS56LXQueixvPW4ueC10LngsYT1uLnktdC55LHU9bi56LXQueixsPXIqdS1zKmEsaD1zKm8taSp1LGM9aSphLXIqbyxmPWwqbCtoKmgrYypjLGc9TWF0aC5zcXJ0KGYpLzI7cmV0dXJuIGd9LGNpLmNlbnRyb2lkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0odC54K2UueCtuLngpLzMscj0odC55K2UueStuLnkpLzM7cmV0dXJuIG5ldyBnKGkscil9LGNpLmluQ2VudHJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShuKSxzPXQuZGlzdGFuY2UoZSksbz1pK3IrcyxhPShpKnQueCtyKmUueCtzKm4ueCkvbyx1PShpKnQueStyKmUueStzKm4ueSkvbztyZXR1cm4gbmV3IGcoYSx1KX0sZShmaS5wcm90b3R5cGUse2dldFJhZGl1czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLnJhZGl1c30sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5jZW50cmUpfXZhciB0PXRoaXMuZXh0cmVtYWxQdHNbMF0sZT10aGlzLmV4dHJlbWFsUHRzWzFdO3JldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX0sZ2V0RXh0cmVtYWxQb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0c30sY29tcHV0ZUNpcmNsZVBvaW50czpmdW5jdGlvbigpe2lmKHRoaXMuaW5wdXQuaXNFbXB0eSgpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLG51bGw7aWYoMT09PXRoaXMuaW5wdXQuZ2V0TnVtUG9pbnRzKCkpe3ZhciB0PXRoaXMuaW5wdXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcodFswXSldLG51bGx9dmFyIGU9dGhpcy5pbnB1dC5jb252ZXhIdWxsKCksbj1lLmdldENvb3JkaW5hdGVzKCksdD1uO2lmKG5bMF0uZXF1YWxzMkQobltuLmxlbmd0aC0xXSkmJih0PW5ldyBBcnJheShuLmxlbmd0aC0xKS5maWxsKG51bGwpLEguY29weURlZXAobiwwLHQsMCxuLmxlbmd0aC0xKSksdC5sZW5ndGg8PTIpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9SC5jb3B5RGVlcCh0KSxudWxsO2Zvcih2YXIgaT1maS5sb3dlc3RQb2ludCh0KSxyPWZpLnBvaW50V2l0TWluQW5nbGVXaXRoWCh0LGkpLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89ZmkucG9pbnRXaXRoTWluQW5nbGVXaXRoU2VnbWVudCh0LGkscik7aWYoaGkuaXNPYnR1c2UoaSxvLHIpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPVtuZXcgZyhpKSxuZXcgZyhyKV0sbnVsbDtpZihoaS5pc09idHVzZShvLGkscikpaT1vO2Vsc2V7aWYoIWhpLmlzT2J0dXNlKG8scixpKSlyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1bbmV3IGcoaSksbmV3IGcociksbmV3IGcobyldLG51bGw7cj1vfX1mLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiTG9naWMgZmFpbHVyZSBpbiBNaW5pbXVtIEJvdW5kaW5nIENpcmNsZSBhbGdvcml0aG0hXCIpfSxjb21wdXRlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmV4dHJlbWFsUHRzP251bGw6KHRoaXMuY29tcHV0ZUNpcmNsZVBvaW50cygpLHRoaXMuY29tcHV0ZUNlbnRyZSgpLHZvaWQobnVsbCE9PXRoaXMuY2VudHJlJiYodGhpcy5yYWRpdXM9dGhpcy5jZW50cmUuZGlzdGFuY2UodGhpcy5leHRyZW1hbFB0c1swXSkpKSl9LGdldEZhcnRoZXN0UG9pbnRzOmZ1bmN0aW9uKCl7c3dpdGNoKHRoaXMuY29tcHV0ZSgpLHRoaXMuZXh0cmVtYWxQdHMubGVuZ3RoKXtjYXNlIDA6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoKTtjYXNlIDE6cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKX12YXIgdD10aGlzLmV4dHJlbWFsUHRzWzBdLGU9dGhpcy5leHRyZW1hbFB0c1t0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aC0xXTtyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCxlXSl9LGdldENpcmNsZTpmdW5jdGlvbigpe2lmKHRoaXMuY29tcHV0ZSgpLG51bGw9PT10aGlzLmNlbnRyZSlyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9seWdvbigpO3ZhciB0PXRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMuY2VudHJlKTtyZXR1cm4gMD09PXRoaXMucmFkaXVzP3Q6dC5idWZmZXIodGhpcy5yYWRpdXMpfSxnZXRDZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlKCksdGhpcy5jZW50cmV9LGNvbXB1dGVDZW50cmU6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDp0aGlzLmNlbnRyZT1udWxsO2JyZWFrO2Nhc2UgMTp0aGlzLmNlbnRyZT10aGlzLmV4dHJlbWFsUHRzWzBdO2JyZWFrO2Nhc2UgMjp0aGlzLmNlbnRyZT1uZXcgZygodGhpcy5leHRyZW1hbFB0c1swXS54K3RoaXMuZXh0cmVtYWxQdHNbMV0ueCkvMiwodGhpcy5leHRyZW1hbFB0c1swXS55K3RoaXMuZXh0cmVtYWxQdHNbMV0ueSkvMik7YnJlYWs7Y2FzZSAzOnRoaXMuY2VudHJlPWNpLmNpcmN1bWNlbnRyZSh0aGlzLmV4dHJlbWFsUHRzWzBdLHRoaXMuZXh0cmVtYWxQdHNbMV0sdGhpcy5leHRyZW1hbFB0c1syXSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmaX19KSxmaS5wb2ludFdpdE1pbkFuZ2xlV2l0aFg9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ci5NQVhfVkFMVUUsaT1udWxsLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dFtzXTtpZihvIT09ZSl7dmFyIGE9by54LWUueCx1PW8ueS1lLnk7MD51JiYodT0tdSk7dmFyIGw9TWF0aC5zcXJ0KGEqYSt1KnUpLGg9dS9sO24+aCYmKG49aCxpPW8pfX1yZXR1cm4gaX0sZmkubG93ZXN0UG9pbnQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRbMF0sbj0xO248dC5sZW5ndGg7bisrKXRbbl0ueTxlLnkmJihlPXRbbl0pO3JldHVybiBlfSxmaS5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50PWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ci5NQVhfVkFMVUUscz1udWxsLG89MDtvPHQubGVuZ3RoO28rKyl7dmFyIGE9dFtvXTtpZihhIT09ZSYmYSE9PW4pe3ZhciB1PWhpLmFuZ2xlQmV0d2VlbihlLGEsbik7aT51JiYoaT11LHM9YSl9fXJldHVybiBzfSxlKGdpLnByb3RvdHlwZSx7Z2V0V2lkdGhDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMubWluV2lkdGhQdH0sZ2V0U3VwcG9ydGluZ1NlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMubWluQmFzZVNlZy5wMCx0aGlzLm1pbkJhc2VTZWcucDFdKX0sZ2V0RGlhbWV0ZXI6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSxudWxsPT09dGhpcy5taW5XaWR0aFB0KXJldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhudWxsKTt2YXIgdD10aGlzLm1pbkJhc2VTZWcucHJvamVjdCh0aGlzLm1pbldpZHRoUHQpO3JldHVybiB0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdCx0aGlzLm1pbldpZHRoUHRdKX0sY29tcHV0ZVdpZHRoQ29udmV4OmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBUdD90aGlzLmNvbnZleEh1bGxQdHM9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlcygpOnRoaXMuY29udmV4SHVsbFB0cz10LmdldENvb3JkaW5hdGVzKCksMD09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9bnVsbCx0aGlzLm1pbkJhc2VTZWc9bnVsbCk6MT09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAxPXRoaXMuY29udmV4SHVsbFB0c1swXSk6Mj09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGh8fDM9PT10aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoPyh0aGlzLm1pbldpZHRoPTAsdGhpcy5taW5XaWR0aFB0PXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDA9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMT10aGlzLmNvbnZleEh1bGxQdHNbMV0pOnRoaXMuY29tcHV0ZUNvbnZleFJpbmdNaW5EaWFtZXRlcih0aGlzLmNvbnZleEh1bGxQdHMpfSxjb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyOmZ1bmN0aW9uKHQpe3RoaXMubWluV2lkdGg9ci5NQVhfVkFMVUU7Zm9yKHZhciBlPTEsbj1uZXcgY2UsaT0wO2k8dC5sZW5ndGgtMTtpKyspbi5wMD10W2ldLG4ucDE9dFtpKzFdLGU9dGhpcy5maW5kTWF4UGVycERpc3RhbmNlKHQsbixlKX0sY29tcHV0ZU1pbmltdW1EaWFtZXRlcjpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLm1pbldpZHRoUHQpcmV0dXJuIG51bGw7aWYodGhpcy5pc0NvbnZleCl0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0aGlzLmlucHV0R2VvbSk7ZWxzZXt2YXIgdD1uZXcgbWUodGhpcy5pbnB1dEdlb20pLmdldENvbnZleEh1bGwoKTt0aGlzLmNvbXB1dGVXaWR0aENvbnZleCh0KX19LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLm1pbldpZHRofSxmaW5kTWF4UGVycERpc3RhbmNlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtuXSkscj1pLHM9bixvPXM7cj49aTspaT1yLHM9byxvPWdpLm5leHRJbmRleCh0LHMpLHI9ZS5kaXN0YW5jZVBlcnBlbmRpY3VsYXIodFtvXSk7cmV0dXJuIGk8dGhpcy5taW5XaWR0aCYmKHRoaXMubWluUHRJbmRleD1zLHRoaXMubWluV2lkdGg9aSx0aGlzLm1pbldpZHRoUHQ9dFt0aGlzLm1pblB0SW5kZXhdLHRoaXMubWluQmFzZVNlZz1uZXcgY2UoZSkpLHN9LGdldE1pbmltdW1SZWN0YW5nbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSwwPT09dGhpcy5taW5XaWR0aClyZXR1cm4gdGhpcy5taW5CYXNlU2VnLnAwLmVxdWFsczJEKHRoaXMubWluQmFzZVNlZy5wMSk/dGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvaW50KHRoaXMubWluQmFzZVNlZy5wMCk6dGhpcy5taW5CYXNlU2VnLnRvR2VvbWV0cnkodGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHQ9dGhpcy5taW5CYXNlU2VnLnAxLngtdGhpcy5taW5CYXNlU2VnLnAwLngsZT10aGlzLm1pbkJhc2VTZWcucDEueS10aGlzLm1pbkJhc2VTZWcucDAueSxuPXIuTUFYX1ZBTFVFLGk9LXIuTUFYX1ZBTFVFLHM9ci5NQVhfVkFMVUUsbz0tci5NQVhfVkFMVUUsYT0wO2E8dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aDthKyspe3ZhciB1PWdpLmNvbXB1dGVDKHQsZSx0aGlzLmNvbnZleEh1bGxQdHNbYV0pO3U+aSYmKGk9dSksbj51JiYobj11KTt2YXIgbD1naS5jb21wdXRlQygtZSx0LHRoaXMuY29udmV4SHVsbFB0c1thXSk7bD5vJiYobz1sKSxzPmwmJihzPWwpfXZhciBoPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxvKSxjPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtdCwtZSxzKSxmPWdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZSgtZSx0LGkpLGc9Z2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsbiksZD1mLmxpbmVJbnRlcnNlY3Rpb24oaCkscD1nLmxpbmVJbnRlcnNlY3Rpb24oaCksdj1nLmxpbmVJbnRlcnNlY3Rpb24oYyksbT1mLmxpbmVJbnRlcnNlY3Rpb24oYykseT10aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyhbZCxwLHYsbSxkXSk7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKHksbnVsbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdpfX0pLGdpLm5leHRJbmRleD1mdW5jdGlvbih0LGUpe3JldHVybiBlKyssZT49dC5sZW5ndGgmJihlPTApLGV9LGdpLmNvbXB1dGVDPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdCpuLnktZSpuLnh9LGdpLmdldE1pbmltdW1EaWFtZXRlcj1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGdpKHQpLmdldERpYW1ldGVyKCl9LGdpLmdldE1pbmltdW1SZWN0YW5nbGU9ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnaSh0KS5nZXRNaW5pbXVtUmVjdGFuZ2xlKCl9LGdpLmNvbXB1dGVTZWdtZW50Rm9yTGluZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bnVsbCxyPW51bGw7cmV0dXJuIE1hdGguYWJzKGUpPk1hdGguYWJzKHQpPyhpPW5ldyBnKDAsbi9lKSxyPW5ldyBnKDEsbi9lLXQvZSkpOihpPW5ldyBnKG4vdCwwKSxyPW5ldyBnKG4vdC1lL3QsMSkpLG5ldyBjZShpLHIpfTt2YXIgY289T2JqZWN0LmZyZWV6ZSh7Q2VudHJvaWQ6Z2UsQ0dBbGdvcml0aG1zOmhlLENvbnZleEh1bGw6bWUsSW50ZXJpb3JQb2ludEFyZWE6b2ksSW50ZXJpb3JQb2ludExpbmU6dWksSW50ZXJpb3JQb2ludFBvaW50OmxpLFJvYnVzdExpbmVJbnRlcnNlY3RvcjphZSxNaW5pbXVtQm91bmRpbmdDaXJjbGU6ZmksTWluaW11bURpYW1ldGVyOmdpfSk7ZShkaS5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBwaSh0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZigwPj10KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgcG9zaXRpdmVcIik7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkaX19KSxkaS5kZW5zaWZ5UG9pbnRzPWZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IGNlLHI9bmV3IE4scz0wO3M8dC5sZW5ndGgtMTtzKyspe2kucDA9dFtzXSxpLnAxPXRbcysxXSxyLmFkZChpLnAwLCExKTt2YXIgbz1pLmdldExlbmd0aCgpLGE9TWF0aC50cnVuYyhvL2UpKzE7aWYoYT4xKWZvcih2YXIgdT1vL2EsbD0xO2E+bDtsKyspe3ZhciBoPWwqdS9vLGM9aS5wb2ludEFsb25nKGgpO24ubWFrZVByZWNpc2UoYyksci5hZGQoYywhMSl9fXJldHVybiByLmFkZCh0W3QubGVuZ3RoLTFdLCExKSxyLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGRpLmRlbnNpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZGkodCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKHBpLHhlKSxlKHBpLnByb3RvdHlwZSx7dHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49eGUucHJvdG90eXBlLnRyYW5zZm9ybU11bHRpUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gdGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIE90P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LHRyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0Nvb3JkaW5hdGVBcnJheSgpLGk9ZGkuZGVuc2lmeVBvaW50cyhuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UsZS5nZXRQcmVjaXNpb25Nb2RlbCgpKTtyZXR1cm4gZSBpbnN0YW5jZW9mIFN0JiYxPT09aS5sZW5ndGgmJihpPW5ldyBBcnJheSgwKS5maWxsKG51bGwpKSx0aGlzLmZhY3RvcnkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShpKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0LmJ1ZmZlcigwKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcGl9fSksZGkuRGVuc2lmeVRyYW5zZm9ybWVyPXBpO3ZhciBmbz1PYmplY3QuZnJlZXplKHtEZW5zaWZpZXI6ZGl9KTtlKHZpLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzO2Rve2lmKG51bGw9PT1lKXJldHVybiBudWxsO2lmKGUuZGVzdCgpLmVxdWFsczJEKHQpKXJldHVybiBlO2U9ZS5vTmV4dCgpfXdoaWxlKGUhPT10aGlzKTtyZXR1cm4gbnVsbH0sZGVzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWd9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fbmV4dH0saW5zZXJ0OmZ1bmN0aW9uKHQpe2lmKHRoaXMub05leHQoKT09PXRoaXMpcmV0dXJuIHRoaXMuaW5zZXJ0QWZ0ZXIodCksbnVsbDt2YXIgZT10aGlzLmNvbXBhcmVUbyh0KSxuPXRoaXM7ZG97dmFyIGk9bi5vTmV4dCgpLHI9aS5jb21wYXJlVG8odCk7aWYociE9PWV8fGk9PT10aGlzKXJldHVybiBuLmluc2VydEFmdGVyKHQpLG51bGw7bj1pfXdoaWxlKG4hPT10aGlzKTtmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCl9LGluc2VydEFmdGVyOmZ1bmN0aW9uKHQpe2YuZXF1YWxzKHRoaXMuX29yaWcsdC5vcmlnKCkpO3ZhciBlPXRoaXMub05leHQoKTt0aGlzLl9zeW0uc2V0TmV4dCh0KSx0LnN5bSgpLnNldE5leHQoZSl9LGRlZ3JlZTpmdW5jdGlvbiB0KCl7dmFyIHQ9MCxlPXRoaXM7ZG8gdCsrLGU9ZS5vTmV4dCgpO3doaWxlKGUhPT10aGlzKTtyZXR1cm4gdH0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5fb3JpZy5lcXVhbHMyRCh0KSYmdGhpcy5fc3ltLl9vcmlnLmVxdWFscyhlKX19LGRlbHRhWTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueS10aGlzLl9vcmlnLnl9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW19LHByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLm5leHQoKS5fc3ltfSxjb21wYXJlQW5ndWxhckRpcmVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRlbHRhWCgpLG49dGhpcy5kZWx0YVkoKSxpPXQuZGVsdGFYKCkscj10LmRlbHRhWSgpO2lmKGU9PT1pJiZuPT09cilyZXR1cm4gMDt2YXIgcz1KZS5xdWFkcmFudChlLG4pLG89SmUucXVhZHJhbnQoaSxyKTtyZXR1cm4gcz5vPzE6bz5zPy0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0Ll9vcmlnLHQuZGVzdCgpLHRoaXMuZGVzdCgpKX0scHJldk5vZGU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpczsyPT09dC5kZWdyZWUoKTspaWYodD10LnByZXYoKSx0PT09dGhpcylyZXR1cm4gbnVsbDtyZXR1cm4gdH0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10aGlzLmNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uKGUpO3JldHVybiBufSxuZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX25leHR9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLl9zeW09dH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9vcmlnfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiSEUoXCIrdGhpcy5fb3JpZy54K1wiIFwiK3RoaXMuX29yaWcueStcIiwgXCIrdGhpcy5fc3ltLl9vcmlnLngrXCIgXCIrdGhpcy5fc3ltLl9vcmlnLnkrXCIpXCJ9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5fbmV4dD10fSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMuc2V0U3ltKHQpLHQuc2V0U3ltKHRoaXMpLHRoaXMuc2V0TmV4dCh0KSx0LnNldE5leHQodGhpcyl9LGRlbHRhWDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0uX29yaWcueC10aGlzLl9vcmlnLnh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZpfX0pLHZpLmluaXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsIT09dC5fc3ltfHxudWxsIT09ZS5fc3ltfHxudWxsIT09dC5fbmV4dHx8bnVsbCE9PWUuX25leHQpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcIkVkZ2VzIGFyZSBhbHJlYWR5IGluaXRpYWxpemVkXCIpO3JldHVybiB0LmluaXQoZSksdH0sdmkuY3JlYXRlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IHZpKHQpLGk9bmV3IHZpKGUpO3JldHVybiBuLmluaXQoaSksbn0saChtaSx2aSksZShtaS5wcm90b3R5cGUse21hcms6ZnVuY3Rpb24oKXt0aGlzLl9pc01hcmtlZD0hMH0sc2V0TWFyazpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbWl9fSksbWkuc2V0TWFya0JvdGg9ZnVuY3Rpb24odCxlKXt0LnNldE1hcmsoZSksdC5zeW0oKS5zZXRNYXJrKGUpfSxtaS5pc01hcmtlZD1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc01hcmtlZCgpfSxtaS5zZXRNYXJrPWZ1bmN0aW9uKHQsZSl7dC5zZXRNYXJrKGUpfSxtaS5tYXJrQm90aD1mdW5jdGlvbih0KXt0Lm1hcmsoKSx0LnN5bSgpLm1hcmsoKX0sbWkubWFyaz1mdW5jdGlvbih0KXt0Lm1hcmsoKX0sZSh5aS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5jcmVhdGUodCxlKTtudWxsIT09bj9uLmluc2VydChpKTp0aGlzLnZlcnRleE1hcC5wdXQodCxpKTt2YXIgcj10aGlzLnZlcnRleE1hcC5nZXQoZSk7cmV0dXJuIG51bGwhPT1yP3IuaW5zZXJ0KGkuc3ltKCkpOnRoaXMudmVydGV4TWFwLnB1dChlLGkuc3ltKCkpLGl9LGNyZWF0ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRnZSh0KSxpPXRoaXMuY3JlYXRlRWRnZShlKTtyZXR1cm4gdmkuaW5pdChuLGkpLG59LGNyZWF0ZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB2aSh0KX0sYWRkRWRnZTpmdW5jdGlvbih0LGUpe2lmKCF5aS5pc1ZhbGlkRWRnZSh0LGUpKXJldHVybiBudWxsO3ZhciBuPXRoaXMudmVydGV4TWFwLmdldCh0KSxpPW51bGw7aWYobnVsbCE9PW4mJihpPW4uZmluZChlKSksbnVsbCE9PWkpcmV0dXJuIGk7dmFyIHI9dGhpcy5pbnNlcnQodCxlLG4pO3JldHVybiByfSxnZXRWZXJ0ZXhFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleE1hcC52YWx1ZXMoKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnZlcnRleE1hcC5nZXQodCk7cmV0dXJuIG51bGw9PT1uP251bGw6bi5maW5kKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5aX19KSx5aS5pc1ZhbGlkRWRnZT1mdW5jdGlvbih0LGUpe3ZhciBuPWUuY29tcGFyZVRvKHQpO3JldHVybiAwIT09bn0saCh4aSxtaSksZSh4aS5wcm90b3R5cGUse3NldFN0YXJ0OmZ1bmN0aW9uKCl7dGhpcy5faXNTdGFydD0hMH0saXNTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1N0YXJ0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4aX19KSxoKEVpLHlpKSxlKEVpLnByb3RvdHlwZSx7Y3JlYXRlRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHhpKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBFaX19KSxlKElpLnByb3RvdHlwZSx7YWRkTGluZTpmdW5jdGlvbih0KXt0aGlzLmxpbmVzLmFkZCh0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LnRvQ29vcmRpbmF0ZUFycmF5KCkpKX0sdXBkYXRlUmluZ1N0YXJ0RWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gdC5pc1N0YXJ0KCl8fCh0PXQuc3ltKCksdC5pc1N0YXJ0KCkpP251bGw9PT10aGlzLnJpbmdTdGFydEVkZ2U/KHRoaXMucmluZ1N0YXJ0RWRnZT10LG51bGwpOnZvaWQodC5vcmlnKCkuY29tcGFyZVRvKHRoaXMucmluZ1N0YXJ0RWRnZS5vcmlnKCkpPDAmJih0aGlzLnJpbmdTdGFydEVkZ2U9dCkpOm51bGx9LGdldFJlc3VsdDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yZXN1bHQmJnRoaXMuY29tcHV0ZVJlc3VsdCgpLHRoaXMucmVzdWx0fSxwcm9jZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPXQucHJldk5vZGUoKTtudWxsPT09ZSYmKGU9dCksdGhpcy5zdGFja0VkZ2VzKGUpLHRoaXMuYnVpbGRMaW5lcygpfSxidWlsZFJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4sbj10O2ZvcihlLmFkZChuLm9yaWcoKS5jb3B5KCksITEpOzI9PT1uLnN5bSgpLmRlZ3JlZSgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpYnJlYWs7ZS5hZGQoaS5vcmlnKCkuY29weSgpLCExKSxuPWl9ZS5hZGQobi5kZXN0KCkuY29weSgpLCExKSx0aGlzLmFkZExpbmUoZSl9LGJ1aWxkTGluZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTixuPXQ7Zm9yKHRoaXMucmluZ1N0YXJ0RWRnZT1udWxsLG1pLm1hcmtCb3RoKG4pLGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt0aGlzLnVwZGF0ZVJpbmdTdGFydEVkZ2Uobik7dmFyIGk9bi5uZXh0KCk7aWYoaT09PXQpcmV0dXJuIHRoaXMuYnVpbGRSaW5nKHRoaXMucmluZ1N0YXJ0RWRnZSksbnVsbDtlLmFkZChpLm9yaWcoKS5jb3B5KCksITEpLG49aSxtaS5tYXJrQm90aChuKX1lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuc3RhY2tFZGdlcyhuLnN5bSgpKSx0aGlzLmFkZExpbmUoZSl9LHN0YWNrRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9dDtkbyBtaS5pc01hcmtlZChlKXx8dGhpcy5ub2RlRWRnZVN0YWNrLmFkZChlKSxlPWUub05leHQoKTt3aGlsZShlIT09dCl9LGNvbXB1dGVSZXN1bHQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXRWZXJ0ZXhFZGdlcygpLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bWkuaXNNYXJrZWQobil8fHRoaXMucHJvY2VzcyhuKX10aGlzLnJlc3VsdD10aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLmxpbmVzKX0sYnVpbGRMaW5lczpmdW5jdGlvbigpe2Zvcig7IXRoaXMubm9kZUVkZ2VTdGFjay5lbXB0eSgpOyl7dmFyIHQ9dGhpcy5ub2RlRWRnZVN0YWNrLnBvcCgpO21pLmlzTWFya2VkKHQpfHx0aGlzLmJ1aWxkTGluZSh0KX19LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3QuYXBwbHkoe2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmFkZCh0KX19KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmFkZChpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciByPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5mYWN0b3J5JiYodGhpcy5mYWN0b3J5PXIuZ2V0RmFjdG9yeSgpKTtmb3IodmFyIHM9ci5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxvPSExLG49MTtuPHMuc2l6ZSgpO24rKyl7dmFyIGE9dGhpcy5ncmFwaC5hZGRFZGdlKHMuZ2V0Q29vcmRpbmF0ZShuLTEpLHMuZ2V0Q29vcmRpbmF0ZShuKSk7bnVsbCE9PWEmJihvfHwoYS5zZXRTdGFydCgpLG89ITApKX19fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJaX19KSxJaS5kaXNzb2x2ZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgSWk7cmV0dXJuIGUuYWRkKHQpLGUuZ2V0UmVzdWx0KCl9O3ZhciBnbz1PYmplY3QuZnJlZXplKHtMaW5lRGlzc29sdmVyOklpfSk7ZShOaS5wcm90b3R5cGUse2hhc0NoaWxkcmVuOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7ND50O3QrKylpZihudWxsIT09dGhpcy5zdWJub2RlW3RdKXJldHVybiEwO3JldHVybiExfSxpc1BydW5hYmxlOmZ1bmN0aW9uKCl7cmV0dXJuISh0aGlzLmhhc0NoaWxkcmVuKCl8fHRoaXMuaGFzSXRlbXMoKSl9LGFkZEFsbEl0ZW1zOmZ1bmN0aW9uKHQpe3QuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmdGhpcy5zdWJub2RlW2VdLmFkZEFsbEl0ZW1zKHQpO3JldHVybiB0fSxnZXROb2RlQ291bnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrMX0sc2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLml0ZW1zLnNpemUoKX0sYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmc6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO2UuYWRkQWxsKHRoaXMuaXRlbXMpO2Zvcih2YXIgbj0wOzQ+bjtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSl9LHZpc2l0SXRlbXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5pdGVtcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyllLnZpc2l0SXRlbShuLm5leHQoKSl9LGhhc0l0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXRlbXMuaXNFbXB0eSgpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2Zvcih2YXIgbj0hMSxpPTA7ND5pO2krKylpZihudWxsIT09dGhpcy5zdWJub2RlW2ldJiYobj10aGlzLnN1Ym5vZGVbaV0ucmVtb3ZlKHQsZSkpKXt0aGlzLnN1Ym5vZGVbaV0uaXNQcnVuYWJsZSgpJiYodGhpcy5zdWJub2RlW2ldPW51bGwpO2JyZWFrfXJldHVybiBuP246bj10aGlzLml0ZW1zLnJlbW92ZShlKX0sdmlzaXQ6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiBudWxsO3RoaXMudmlzaXRJdGVtcyh0LGUpO2Zvcih2YXIgbj0wOzQ+bjtuKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtuXSYmdGhpcy5zdWJub2RlW25dLnZpc2l0KHQsZSl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGRlcHRoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzQ+ZTtlKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfSxpc0VtcHR5OmZ1bmN0aW9uIHQoKXt2YXIgdD0hMDt0aGlzLml0ZW1zLmlzRW1wdHkoKXx8KHQ9ITEpO2Zvcih2YXIgZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHRoaXMuc3Vibm9kZVtlXS5pc0VtcHR5KCl8fCh0PSExKSk7cmV0dXJuIHR9LGFkZDpmdW5jdGlvbih0KXt0aGlzLml0ZW1zLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5pfX0pLE5pLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9LTE7cmV0dXJuIHQuZ2V0TWluWCgpPj1lJiYodC5nZXRNaW5ZKCk+PW4mJihpPTMpLHQuZ2V0TWF4WSgpPD1uJiYoaT0xKSksdC5nZXRNYXhYKCk8PWUmJih0LmdldE1pblkoKT49biYmKGk9MiksdC5nZXRNYXhZKCk8PW4mJihpPTApKSxpfSxDaS5leHBvbmVudD1mdW5jdGlvbih0KXtyZXR1cm4gU2koNjQsdCktMTAyM30sQ2kucG93ZXJPZjI9ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucG93KDIsdCl9LGUod2kucHJvdG90eXBlLHtnZXRMZXZlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsfSxjb21wdXRlS2V5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtmb3IodGhpcy5sZXZlbD13aS5jb21wdXRlUXVhZExldmVsKHQpLHRoaXMuZW52PW5ldyBDLHRoaXMuY29tcHV0ZUtleSh0aGlzLmxldmVsLHQpOyF0aGlzLmVudi5jb250YWlucyh0KTspdGhpcy5sZXZlbCs9MSx0aGlzLmNvbXB1dGVLZXkodGhpcy5sZXZlbCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1DaS5wb3dlck9mMihlKTt0aGlzLnB0Lng9TWF0aC5mbG9vcihuLmdldE1pblgoKS9pKSppLHRoaXMucHQueT1NYXRoLmZsb29yKG4uZ2V0TWluWSgpL2kpKmksdGhpcy5lbnYuaW5pdCh0aGlzLnB0LngsdGhpcy5wdC54K2ksdGhpcy5wdC55LHRoaXMucHQueStpKX19LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW52fSxnZXRDZW50cmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGcoKHRoaXMuZW52LmdldE1pblgoKSt0aGlzLmVudi5nZXRNYXhYKCkpLzIsKHRoaXMuZW52LmdldE1pblkoKSt0aGlzLmVudi5nZXRNYXhZKCkpLzIpfSxnZXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB3aX19KSx3aS5jb21wdXRlUXVhZExldmVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKSxuPXQuZ2V0SGVpZ2h0KCksaT1lPm4/ZTpuLHI9Q2kuZXhwb25lbnQoaSkrMTtyZXR1cm4gcn0saChMaSxOaSksZShMaS5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7dmFyIGU9TmkuZ2V0U3Vibm9kZUluZGV4KHQsdGhpcy5jZW50cmV4LHRoaXMuY2VudHJleSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXTtyZXR1cm4gbi5maW5kKHQpfXJldHVybiB0aGlzfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVudi5pbnRlcnNlY3RzKHQpfSxnZXRTdWJub2RlOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dGhpcy5zdWJub2RlW3RdJiYodGhpcy5zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5zdWJub2RlW3RdfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVudn0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT1OaS5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZXgsdGhpcy5jZW50cmV5KTtpZigtMSE9PWUpe3ZhciBuPXRoaXMuZ2V0U3Vibm9kZShlKTtyZXR1cm4gbi5nZXROb2RlKHQpfXJldHVybiB0aGlzfSxjcmVhdGVTdWJub2RlOmZ1bmN0aW9uKHQpe3ZhciBlPTAsbj0wLGk9MCxyPTA7c3dpdGNoKHQpe2Nhc2UgMDplPXRoaXMuZW52LmdldE1pblgoKSxuPXRoaXMuY2VudHJleCxpPXRoaXMuZW52LmdldE1pblkoKSxyPXRoaXMuY2VudHJleTticmVhaztjYXNlIDE6ZT10aGlzLmNlbnRyZXgsbj10aGlzLmVudi5nZXRNYXhYKCksaT10aGlzLmVudi5nZXRNaW5ZKCkscj10aGlzLmNlbnRyZXk7YnJlYWs7Y2FzZSAyOmU9dGhpcy5lbnYuZ2V0TWluWCgpLG49dGhpcy5jZW50cmV4LGk9dGhpcy5jZW50cmV5LHI9dGhpcy5lbnYuZ2V0TWF4WSgpO2JyZWFrO2Nhc2UgMzplPXRoaXMuY2VudHJleCxuPXRoaXMuZW52LmdldE1heFgoKSxpPXRoaXMuY2VudHJleSxyPXRoaXMuZW52LmdldE1heFkoKX12YXIgcz1uZXcgQyhlLG4saSxyKSxvPW5ldyBMaShzLHRoaXMubGV2ZWwtMSk7cmV0dXJuIG99LGluc2VydE5vZGU6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuZW52fHx0aGlzLmVudi5jb250YWlucyh0LmVudikpO3ZhciBlPU5pLmdldFN1Ym5vZGVJbmRleCh0LmVudix0aGlzLmNlbnRyZXgsdGhpcy5jZW50cmV5KTtpZih0LmxldmVsPT09dGhpcy5sZXZlbC0xKXRoaXMuc3Vibm9kZVtlXT10O2Vsc2V7dmFyIG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0Tm9kZSh0KSx0aGlzLnN1Ym5vZGVbZV09bn19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExpfX0pLExpLmNyZWF0ZU5vZGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHdpKHQpLG49bmV3IExpKGUuZ2V0RW52ZWxvcGUoKSxlLmdldExldmVsKCkpO3JldHVybiBufSxMaS5jcmVhdGVFeHBhbmRlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0LmVudik7dmFyIGk9TGkuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJmkuaW5zZXJ0Tm9kZSh0KSxpfSxlKFJpLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUml9fSksUmkuaXNaZXJvV2lkdGg9ZnVuY3Rpb24odCxlKXt2YXIgbj1lLXQ7aWYoMD09PW4pcmV0dXJuITA7dmFyIGk9TWF0aC5tYXgoTWF0aC5hYnModCksTWF0aC5hYnMoZSkpLHI9bi9pLHM9Q2kuZXhwb25lbnQocik7cmV0dXJuIHM8PVJpLk1JTl9CSU5BUllfRVhQT05FTlR9LFJpLk1JTl9CSU5BUllfRVhQT05FTlQ9LTUwLGgoVGksTmkpLGUoVGkucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1OaS5nZXRTdWJub2RlSW5kZXgodCxUaS5vcmlnaW4ueCxUaS5vcmlnaW4ueSk7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO3ZhciBpPXRoaXMuc3Vibm9kZVtuXTtpZihudWxsPT09aXx8IWkuZ2V0RW52ZWxvcGUoKS5jb250YWlucyh0KSl7dmFyIHI9TGkuY3JlYXRlRXhwYW5kZWQoaSx0KTt0aGlzLnN1Ym5vZGVbbl09cn10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLnN1Ym5vZGVbbl0sdCxlKX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4hMH0saW5zZXJ0Q29udGFpbmVkOmZ1bmN0aW9uKHQsZSxuKXtmLmlzVHJ1ZSh0LmdldEVudmVsb3BlKCkuY29udGFpbnMoZSkpO3ZhciBpPVJpLmlzWmVyb1dpZHRoKGUuZ2V0TWluWCgpLGUuZ2V0TWF4WCgpKSxyPVJpLmlzWmVyb1dpZHRoKGUuZ2V0TWluWSgpLGUuZ2V0TWF4WSgpKSxzPW51bGw7cz1pfHxyP3QuZmluZChlKTp0LmdldE5vZGUoZSkscy5hZGQobil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRpfX0pLFRpLm9yaWdpbj1uZXcgZygwLDApLGUoUGkucHJvdG90eXBlLHtzaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LnNpemUoKTowfSxpbnNlcnQ6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbGxlY3RTdGF0cyh0KTt2YXIgbj1QaS5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7dGhpcy5yb290Lmluc2VydChuLGUpfSxxdWVyeTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgWW47cmV0dXJuIHRoaXMucXVlcnkodCxlKSxlLmdldEl0ZW1zKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLnJvb3QudmlzaXQobixpKX19LHF1ZXJ5QWxsOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7cmV0dXJuIHRoaXMucm9vdC5hZGRBbGxJdGVtcyh0KSxcbnR9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPVBpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpO3ZhciBuPXQuZ2V0SGVpZ2h0KCk7bjx0aGlzLm1pbkV4dGVudCYmbj4wJiYodGhpcy5taW5FeHRlbnQ9bil9LGRlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290LmRlcHRoKCk6MH0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltGZSx1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUGl9fSksUGkuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW5YKCksaT10LmdldE1heFgoKSxyPXQuZ2V0TWluWSgpLHM9dC5nZXRNYXhZKCk7cmV0dXJuIG4hPT1pJiZyIT09cz90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxyPT09cyYmKHItPWUvMixzPXIrZS8yKSxuZXcgQyhuLGkscixzKSl9LFBpLnNlcmlhbFZlcnNpb25VSUQ9LTB4Njc4YjYwYzk2N2EyNTQwMDt2YXIgcG89T2JqZWN0LmZyZWV6ZSh7UXVhZHRyZWU6UGl9KSx2bz1PYmplY3QuZnJlZXplKHtTVFJ0cmVlOmtlfSksbW89T2JqZWN0LmZyZWV6ZSh7cXVhZHRyZWU6cG8sc3RydHJlZTp2b30pLHlvPVtcIlBvaW50XCIsXCJNdWx0aVBvaW50XCIsXCJMaW5lU3RyaW5nXCIsXCJNdWx0aUxpbmVTdHJpbmdcIixcIlBvbHlnb25cIixcIk11bHRpUG9seWdvblwiXTtlKGJpLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT12b2lkIDA7ZT1cInN0cmluZ1wiPT10eXBlb2YgdD9KU09OLnBhcnNlKHQpOnQ7dmFyIG49ZS50eXBlO2lmKCF4b1tuXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrZS50eXBlKTtyZXR1cm4tMSE9PXlvLmluZGV4T2Yobik/eG9bbl0uYXBwbHkodGhpcyxbZS5jb29yZGluYXRlc10pOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT1uP3hvW25dLmFwcGx5KHRoaXMsW2UuZ2VvbWV0cmllc10pOnhvW25dLmFwcGx5KHRoaXMsW2VdKX0sd3JpdGU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyeVR5cGUoKTtpZighRW9bZV0pdGhyb3cgbmV3IEVycm9yKFwiR2VvbWV0cnkgaXMgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gRW9bZV0uYXBwbHkodGhpcyxbdF0pfX0pO3ZhciB4bz17RmVhdHVyZTpmdW5jdGlvbih0KXt2YXIgZT17fTtmb3IodmFyIG4gaW4gdCllW25dPXRbbl07aWYodC5nZW9tZXRyeSl7dmFyIGk9dC5nZW9tZXRyeS50eXBlO2lmKCF4b1tpXSl0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIEdlb0pTT04gdHlwZTogXCIrdC50eXBlKTtlLmdlb21ldHJ5PXRoaXMucmVhZCh0Lmdlb21ldHJ5KX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXhvLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LEZlYXR1cmVDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXt9O2lmKHQuZmVhdHVyZXMpe2UuZmVhdHVyZXM9W107Zm9yKHZhciBuPTA7bjx0LmZlYXR1cmVzLmxlbmd0aDsrK24pZS5mZWF0dXJlcy5wdXNoKHRoaXMucmVhZCh0LmZlYXR1cmVzW25dKSl9cmV0dXJuIHQuYmJveCYmKGUuYmJveD10aGlzLnBhcnNlLmJib3guYXBwbHkodGhpcyxbdC5iYm94XSkpLGV9LGNvb3JkaW5hdGVzOmZ1bmN0aW9uIHQoZSl7Zm9yKHZhciB0PVtdLG49MDtuPGUubGVuZ3RoOysrbil7dmFyIGk9ZVtuXTt0LnB1c2gobmV3IGcoaVswXSxpWzFdKSl9cmV0dXJuIHR9LGJib3g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoW25ldyBnKHRbMF0sdFsxXSksbmV3IGcodFsyXSx0WzFdKSxuZXcgZyh0WzJdLHRbM10pLG5ldyBnKHRbMF0sdFszXSksbmV3IGcodFswXSx0WzFdKV0pfSxQb2ludDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0WzBdLHRbMV0pO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKX0sTXVsdGlQb2ludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKWUucHVzaCh4by5Qb2ludC5hcHBseSh0aGlzLFt0W25dXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXhvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3RdKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhlKX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKHhvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbdFtuXV0pKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGUpfSxQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT14by5jb29yZGluYXRlcy5hcHBseSh0aGlzLFt0WzBdXSksbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKGUpLGk9W10scj0xO3I8dC5sZW5ndGg7KytyKXt2YXIgcz10W3JdLG89eG8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbc10pLGE9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhvKTtpLnB1c2goYSl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixpKX0sTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pe3ZhciBpPXRbbl07ZS5wdXNoKHhvLlBvbHlnb24uYXBwbHkodGhpcyxbaV0pKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIGk9dFtuXTtlLnB1c2godGhpcy5yZWFkKGkpKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0sRW89e2Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuW3QueCx0LnldfSxQb2ludDpmdW5jdGlvbih0KXt2YXIgZT1Fby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3QuZ2V0Q29vcmRpbmF0ZSgpXSk7cmV0dXJue3R5cGU6XCJQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9RW8uUG9pbnQuYXBwbHkodGhpcyxbaV0pO2UucHVzaChyLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9pbnRcIixjb29yZGluYXRlczplfX0sTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj10LmdldENvb3JkaW5hdGVzKCksaT0wO2k8bi5sZW5ndGg7KytpKXt2YXIgcj1uW2ldO2UucHVzaChFby5jb29yZGluYXRlLmFwcGx5KHRoaXMsW3JdKSl9cmV0dXJue3R5cGU6XCJMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUVvLkxpbmVTdHJpbmcuYXBwbHkodGhpcyxbaV0pO2UucHVzaChyLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpTGluZVN0cmluZ1wiLGNvb3JkaW5hdGVzOmV9fSxQb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPVtdLG49RW8uTGluZVN0cmluZy5hcHBseSh0aGlzLFt0LnNoZWxsXSk7ZS5wdXNoKG4uY29vcmRpbmF0ZXMpO2Zvcih2YXIgaT0wO2k8dC5ob2xlcy5sZW5ndGg7KytpKXt2YXIgcj10LmhvbGVzW2ldLHM9RW8uTGluZVN0cmluZy5hcHBseSh0aGlzLFtyXSk7ZS5wdXNoKHMuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Fby5Qb2x5Z29uLmFwcGx5KHRoaXMsW2ldKTtlLnB1c2goci5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJNdWx0aVBvbHlnb25cIixjb29yZGluYXRlczplfX0sR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9aS5nZXRHZW9tZXRyeVR5cGUoKTtlLnB1c2goRW9bcl0uYXBwbHkodGhpcyxbaV0pKX1yZXR1cm57dHlwZTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiLGdlb21ldHJpZXM6ZX19fTtlKE9pLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnBhcnNlci5yZWFkKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLmdldFR5cGUoKT09PWVlLkZJWEVEJiZ0aGlzLnJlZHVjZVByZWNpc2lvbihlKSxlfSxyZWR1Y2VQcmVjaXNpb246ZnVuY3Rpb24odCl7dmFyIGUsbjtpZih0LmNvb3JkaW5hdGUpdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LmNvb3JkaW5hdGUpO2Vsc2UgaWYodC5wb2ludHMpZm9yKGU9MCxuPXQucG9pbnRzLmxlbmd0aDtuPmU7ZSsrKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5wb2ludHNbZV0pO2Vsc2UgaWYodC5nZW9tZXRyaWVzKWZvcihlPTAsbj10Lmdlb21ldHJpZXMubGVuZ3RoO24+ZTtlKyspdGhpcy5yZWR1Y2VQcmVjaXNpb24odC5nZW9tZXRyaWVzW2VdKX19KSxlKF9pLnByb3RvdHlwZSx7d3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucGFyc2VyLndyaXRlKHQpfX0pLGUoTWkucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucGFyc2VyLnJlYWQodCk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwuZ2V0VHlwZSgpPT09ZWUuRklYRUQmJnRoaXMucmVkdWNlUHJlY2lzaW9uKGUpLGV9LHJlZHVjZVByZWNpc2lvbjpmdW5jdGlvbih0KXtpZih0LmNvb3JkaW5hdGUpdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LmNvb3JkaW5hdGUpO2Vsc2UgaWYodC5wb2ludHMpZm9yKHZhciBlPTAsbj10LnBvaW50cy5jb29yZGluYXRlcy5sZW5ndGg7bj5lO2UrKyl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQucG9pbnRzLmNvb3JkaW5hdGVzW2VdKTtlbHNlIGlmKHQuZ2VvbWV0cmllcylmb3IodmFyIGk9MCxyPXQuZ2VvbWV0cmllcy5sZW5ndGg7cj5pO2krKyl0aGlzLnJlZHVjZVByZWNpc2lvbih0Lmdlb21ldHJpZXNbaV0pfX0pLGUoQWkucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2Ygb2wuZ2VvbS5Qb2ludD90aGlzLmNvbnZlcnRGcm9tUG9pbnQodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5MaW5lYXJSaW5nP3RoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLlBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uTXVsdGlQb2ludD90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2ludCh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5NdWx0aUxpbmVTdHJpbmc/dGhpcy5jb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZyh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5NdWx0aVBvbHlnb24/dGhpcy5jb252ZXJ0RnJvbU11bHRpUG9seWdvbih0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5HZW9tZXRyeUNvbGxlY3Rpb24/dGhpcy5jb252ZXJ0RnJvbUNvbGxlY3Rpb24odCk6dm9pZCAwfSxjb252ZXJ0RnJvbVBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9pbnQobmV3IGcoZVswXSxlWzFdKSl9LGNvbnZlcnRGcm9tTGluZVN0cmluZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpfSxjb252ZXJ0RnJvbUxpbmVhclJpbmc6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodC5nZXRDb29yZGluYXRlcygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcodFswXSx0WzFdKX0pKX0sY29udmVydEZyb21Qb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldExpbmVhclJpbmdzKCksbj1udWxsLGk9W10scj0wO3I8ZS5sZW5ndGg7cisrKXt2YXIgcz10aGlzLmNvbnZlcnRGcm9tTGluZWFyUmluZyhlW3JdKTswPT09cj9uPXM6aS5wdXNoKHMpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKG4saSl9LGNvbnZlcnRGcm9tTXVsdGlQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldFBvaW50cygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvaW50KHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChlKX0sY29udmVydEZyb21NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRMaW5lU3RyaW5ncygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbUxpbmVTdHJpbmcodCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LGNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0UG9seWdvbnMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udmVydEZyb21Qb2x5Z29uKHQpfSx0aGlzKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxjb252ZXJ0RnJvbUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRHZW9tZXRyaWVzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnJlYWQodCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9LHdyaXRlOmZ1bmN0aW9uKHQpe3JldHVyblwiUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9Qb2ludCh0LmdldENvb3JkaW5hdGUoKSk6XCJMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTGluZVN0cmluZyh0KTpcIkxpbmVhclJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lYXJSaW5nKHQpOlwiUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvbHlnb24odCk6XCJNdWx0aVBvaW50XCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2ludCh0KTpcIk11bHRpTGluZVN0cmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpTGluZVN0cmluZyh0KTpcIk11bHRpUG9seWdvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb011bHRpUG9seWdvbih0KTpcIkdlb21ldHJ5Q29sbGVjdGlvblwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0NvbGxlY3Rpb24odCk6dm9pZCAwfSxjb252ZXJ0VG9Qb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IG9sLmdlb20uUG9pbnQoW3QueCx0LnldKX0sY29udmVydFRvTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT10LnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpO3JldHVybiBuZXcgb2wuZ2VvbS5MaW5lU3RyaW5nKGUpfSxjb252ZXJ0VG9MaW5lYXJSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSk7cmV0dXJuIG5ldyBvbC5nZW9tLkxpbmVhclJpbmcoZSl9LGNvbnZlcnRUb1BvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVt0LnNoZWxsLnBvaW50cy5jb29yZGluYXRlcy5tYXAoRGkpXSxuPTA7bjx0LmhvbGVzLmxlbmd0aDtuKyspZS5wdXNoKHQuaG9sZXNbbl0ucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSkpO3JldHVybiBuZXcgb2wuZ2VvbS5Qb2x5Z29uKGUpfSxjb252ZXJ0VG9NdWx0aVBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgb2wuZ2VvbS5NdWx0aVBvaW50KHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoRGkpKX0sY29udmVydFRvTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQuZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyBvbC5nZW9tLk11bHRpTGluZVN0cmluZyhlKX0sY29udmVydFRvTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoO24rKyllLnB1c2godGhpcy5jb252ZXJ0VG9Qb2x5Z29uKHQuZ2VvbWV0cmllc1tuXSkuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIG5ldyBvbC5nZW9tLk11bHRpUG9seWdvbihlKX0sY29udmVydFRvQ29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDtuKyspe3ZhciBpPXQuZ2VvbWV0cmllc1tuXTtlLnB1c2godGhpcy53cml0ZShpKSl9cmV0dXJuIG5ldyBvbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbihlKX19KTt2YXIgSW89T2JqZWN0LmZyZWV6ZSh7R2VvSlNPTlJlYWRlcjpPaSxHZW9KU09OV3JpdGVyOl9pLE9MM1BhcnNlcjpBaSxXS1RSZWFkZXI6TWksV0tUV3JpdGVyOnNlfSk7ZShGaS5wcm90b3R5cGUse3Jlc2NhbGU6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5yZXNjYWxlKG4uZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgaT1hcmd1bWVudHNbMF0scj1udWxsLHM9bnVsbDsyPT09aS5sZW5ndGgmJihyPW5ldyBnKGlbMF0pLHM9bmV3IGcoaVsxXSkpO2Zvcih2YXIgZT0wO2U8aS5sZW5ndGg7ZSsrKWlbZV0ueD1pW2VdLngvdGhpcy5zY2FsZUZhY3Rvcit0aGlzLm9mZnNldFgsaVtlXS55PWlbZV0ueS90aGlzLnNjYWxlRmFjdG9yK3RoaXMub2Zmc2V0WTsyPT09aS5sZW5ndGgmJmlbMF0uZXF1YWxzMkQoaVsxXSkmJkEub3V0LnByaW50bG4oaSl9fSxzY2FsZTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmFkZChuZXcgS2UodGhpcy5zY2FsZShpLmdldENvb3JkaW5hdGVzKCkpLGkuZ2V0RGF0YSgpKSl9cmV0dXJuIGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7Zm9yKHZhciByPWFyZ3VtZW50c1swXSxzPW5ldyBBcnJheShyLmxlbmd0aCkuZmlsbChudWxsKSxuPTA7bjxyLmxlbmd0aDtuKyspc1tuXT1uZXcgZyhNYXRoLnJvdW5kKChyW25dLngtdGhpcy5vZmZzZXRYKSp0aGlzLnNjYWxlRmFjdG9yKSxNYXRoLnJvdW5kKChyW25dLnktdGhpcy5vZmZzZXRZKSp0aGlzLnNjYWxlRmFjdG9yKSxyW25dLnopO3ZhciBvPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHMocyk7cmV0dXJuIG99fSxpc0ludGVnZXJQcmVjaXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMT09PXRoaXMuc2NhbGVGYWN0b3J9LGdldE5vZGVkU3Vic3RyaW5nczpmdW5jdGlvbigpe3ZhciB0PXRoaXMubm9kZXIuZ2V0Tm9kZWRTdWJzdHJpbmdzKCk7cmV0dXJuIHRoaXMuaXNTY2FsZWQmJnRoaXMucmVzY2FsZSh0KSx0fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dmFyIGU9dDt0aGlzLmlzU2NhbGVkJiYoZT10aGlzLnNjYWxlKHQpKSx0aGlzLm5vZGVyLmNvbXB1dGVOb2RlcyhlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdG5dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGaX19KTt2YXIgTm89T2JqZWN0LmZyZWV6ZSh7TUNJbmRleE5vZGVyOm5uLFNjYWxlZE5vZGVyOkZpLFNlZ21lbnRTdHJpbmc6YmV9KTtlKEdpLnByb3RvdHlwZSx7aXNTaW1wbGVNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiEwO2Zvcih2YXIgZT1uZXcgYXQsbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10LmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpO2lmKGUuY29udGFpbnMocikpcmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249ciwhMTtlLmFkZChyKX1yZXR1cm4hMH0saXNTaW1wbGVQb2x5Z29uYWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWtuLmdldExpbmVzKHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoIXRoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeShpKSlyZXR1cm4hMX1yZXR1cm4hMH0saGFzQ2xvc2VkRW5kcG9pbnRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBydCxuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPShpLmdldE1heGltdW1TZWdtZW50SW5kZXgoKSxpLmlzQ2xvc2VkKCkpLHM9aS5nZXRDb29yZGluYXRlKDApO3RoaXMuYWRkRW5kcG9pbnQoZSxzLHIpO3ZhciBvPWkuZ2V0Q29vcmRpbmF0ZShpLmdldE51bVBvaW50cygpLTEpO3RoaXMuYWRkRW5kcG9pbnQoZSxvLHIpfWZvcih2YXIgbj1lLnZhbHVlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgYT1uLm5leHQoKTtpZihhLmlzQ2xvc2VkJiYyIT09YS5kZWdyZWUpcmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249YS5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9LGdldE5vblNpbXBsZUxvY2F0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb259LGlzU2ltcGxlTGluZWFyR2VvbWV0cnk6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7dmFyIGU9bmV3ICRuKDAsdCksbj1uZXcgYWUsaT1lLmNvbXB1dGVTZWxmTm9kZXMobiwhMCk7cmV0dXJuIGkuaGFzSW50ZXJzZWN0aW9uKCk/aS5oYXNQcm9wZXJJbnRlcnNlY3Rpb24oKT8odGhpcy5ub25TaW1wbGVMb2NhdGlvbj1pLmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOnRoaXMuaGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb24oZSk/ITE6IXRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yfHwhdGhpcy5oYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbihlKTohMH0saGFzTm9uRW5kcG9pbnRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZighcy5pc0VuZFBvaW50KGkpKXJldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPXMuZ2V0Q29vcmRpbmF0ZSgpLCEwfXJldHVybiExfSxhZGRFbmRwb2ludDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXQoZSk7bnVsbD09PWkmJihpPW5ldyBxaShlKSx0LnB1dChlLGkpKSxpLmFkZEVuZHBvaW50KG4pfSxjb21wdXRlU2ltcGxlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsdC5pc0VtcHR5KCk/ITA6dCBpbnN0YW5jZW9mIFN0P3RoaXMuaXNTaW1wbGVMaW5lYXJHZW9tZXRyeSh0KTp0IGluc3RhbmNlb2YgZ3Q/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiBQdD90aGlzLmlzU2ltcGxlTXVsdGlQb2ludCh0KTpSKHQsUnQpP3RoaXMuaXNTaW1wbGVQb2x5Z29uYWwodCk6dCBpbnN0YW5jZW9mIGZ0P3RoaXMuaXNTaW1wbGVHZW9tZXRyeUNvbGxlY3Rpb24odCk6ITB9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCx0aGlzLmNvbXB1dGVTaW1wbGUodGhpcy5pbnB1dEdlb20pfSxpc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYoIXRoaXMuY29tcHV0ZVNpbXBsZShuKSlyZXR1cm4hMX1yZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR2l9fSksZShxaS5wcm90b3R5cGUse2FkZEVuZHBvaW50OmZ1bmN0aW9uKHQpe3RoaXMuZGVncmVlKyssdGhpcy5pc0Nsb3NlZHw9dH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxaX19KSxHaS5FbmRwb2ludEluZm89cWksZShCaS5wcm90b3R5cGUse2dldEVuZENhcFN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW5kQ2FwU3R5bGV9LGlzU2luZ2xlU2lkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNTaW5nbGVTaWRlZH0sc2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbih0KXt0aGlzLnF1YWRyYW50U2VnbWVudHM9dCwwPT09dGhpcy5xdWFkcmFudFNlZ21lbnRzJiYodGhpcy5qb2luU3R5bGU9QmkuSk9JTl9CRVZFTCksdGhpcy5xdWFkcmFudFNlZ21lbnRzPDAmJih0aGlzLmpvaW5TdHlsZT1CaS5KT0lOX01JVFJFLHRoaXMubWl0cmVMaW1pdD1NYXRoLmFicyh0aGlzLnF1YWRyYW50U2VnbWVudHMpKSwwPj10JiYodGhpcy5xdWFkcmFudFNlZ21lbnRzPTEpLHRoaXMuam9pblN0eWxlIT09QmkuSk9JTl9ST1VORCYmKHRoaXMucXVhZHJhbnRTZWdtZW50cz1CaS5ERUZBVUxUX1FVQURSQU5UX1NFR01FTlRTKX0sZ2V0Sm9pblN0eWxlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuam9pblN0eWxlfSxzZXRKb2luU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5qb2luU3R5bGU9dH0sc2V0U2ltcGxpZnlGYWN0b3I6ZnVuY3Rpb24odCl7dGhpcy5zaW1wbGlmeUZhY3Rvcj0wPnQ/MDp0fSxnZXRTaW1wbGlmeUZhY3RvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNpbXBsaWZ5RmFjdG9yfSxnZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhZHJhbnRTZWdtZW50c30sc2V0RW5kQ2FwU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5lbmRDYXBTdHlsZT10fSxnZXRNaXRyZUxpbWl0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWl0cmVMaW1pdH0sc2V0TWl0cmVMaW1pdDpmdW5jdGlvbih0KXt0aGlzLm1pdHJlTGltaXQ9dH0sc2V0U2luZ2xlU2lkZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNTaW5nbGVTaWRlZD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCaX19KSxCaS5idWZmZXJEaXN0YW5jZUVycm9yPWZ1bmN0aW9uKHQpe3ZhciBlPU1hdGguUEkvMi90O3JldHVybiAxLU1hdGguY29zKGUvMil9LEJpLkNBUF9ST1VORD0xLEJpLkNBUF9GTEFUPTIsQmkuQ0FQX1NRVUFSRT0zLEJpLkpPSU5fUk9VTkQ9MSxCaS5KT0lOX01JVFJFPTIsQmkuSk9JTl9CRVZFTD0zLEJpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFM9OCxCaS5ERUZBVUxUX01JVFJFX0xJTUlUPTUsQmkuREVGQVVMVF9TSU1QTElGWV9GQUNUT1I9LjAxLGUoemkucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluQ29vcmR9LGdldFJpZ2h0bW9zdFNpZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlKTtyZXR1cm4gMD5uJiYobj10aGlzLmdldFJpZ2h0bW9zdFNpZGVPZlNlZ21lbnQodCxlLTEpKSwwPm4mJih0aGlzLm1pbkNvb3JkPW51bGwsdGhpcy5jaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGUodCkpLG59LGZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpO2YuaXNUcnVlKHRoaXMubWluSW5kZXg+MCYmdGhpcy5taW5JbmRleDx0Lmxlbmd0aCxcInJpZ2h0bW9zdCBwb2ludCBleHBlY3RlZCB0byBiZSBpbnRlcmlvciB2ZXJ0ZXggb2YgZWRnZVwiKTt2YXIgZT10W3RoaXMubWluSW5kZXgtMV0sbj10W3RoaXMubWluSW5kZXgrMV0saT1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5taW5Db29yZCxuLGUpLHI9ITE7ZS55PHRoaXMubWluQ29vcmQueSYmbi55PHRoaXMubWluQ29vcmQueSYmaT09PWhlLkNPVU5URVJDTE9DS1dJU0U/cj0hMDplLnk+dGhpcy5taW5Db29yZC55JiZuLnk+dGhpcy5taW5Db29yZC55JiZpPT09aGUuQ0xPQ0tXSVNFJiYocj0hMCksciYmKHRoaXMubWluSW5kZXg9dGhpcy5taW5JbmRleC0xKX0sZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0RWRnZSgpLGk9bi5nZXRDb29yZGluYXRlcygpO2lmKDA+ZXx8ZSsxPj1pLmxlbmd0aClyZXR1cm4tMTtpZihpW2VdLnk9PT1pW2UrMV0ueSlyZXR1cm4tMTt2YXIgcj1jbi5MRUZUO3JldHVybiBpW2VdLnk8aVtlKzFdLnkmJihyPWNuLlJJR0hUKSxyfSxnZXRFZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZW50ZWREZX0sY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLG49MDtuPGUubGVuZ3RoLTE7bisrKShudWxsPT09dGhpcy5taW5Db29yZHx8ZVtuXS54PnRoaXMubWluQ29vcmQueCkmJih0aGlzLm1pbkRlPXQsdGhpcy5taW5JbmRleD1uLHRoaXMubWluQ29vcmQ9ZVtuXSl9LGZpbmRSaWdodG1vc3RFZGdlQXROb2RlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5taW5EZS5nZXROb2RlKCksZT10LmdldEVkZ2VzKCk7dGhpcy5taW5EZT1lLmdldFJpZ2h0bW9zdEVkZ2UoKSx0aGlzLm1pbkRlLmlzRm9yd2FyZCgpfHwodGhpcy5taW5EZT10aGlzLm1pbkRlLmdldFN5bSgpLHRoaXMubWluSW5kZXg9dGhpcy5taW5EZS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKS5sZW5ndGgtMSl9LGZpbmRFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmlzRm9yd2FyZCgpJiZ0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZShuKX1mLmlzVHJ1ZSgwIT09dGhpcy5taW5JbmRleHx8dGhpcy5taW5Db29yZC5lcXVhbHModGhpcy5taW5EZS5nZXRDb29yZGluYXRlKCkpLFwiaW5jb25zaXN0ZW5jeSBpbiByaWdodG1vc3QgcHJvY2Vzc2luZ1wiKSwwPT09dGhpcy5taW5JbmRleD90aGlzLmZpbmRSaWdodG1vc3RFZGdlQXROb2RlKCk6dGhpcy5maW5kUmlnaHRtb3N0RWRnZUF0VmVydGV4KCksdGhpcy5vcmllbnRlZERlPXRoaXMubWluRGU7dmFyIGk9dGhpcy5nZXRSaWdodG1vc3RTaWRlKHRoaXMubWluRGUsdGhpcy5taW5JbmRleCk7aT09PWNuLkxFRlQmJih0aGlzLm9yaWVudGVkRGU9dGhpcy5taW5EZS5nZXRTeW0oKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHppfX0pLFZpLnByb3RvdHlwZS5hZGRMYXN0PWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlfLnB1c2godCl9LFZpLnByb3RvdHlwZS5yZW1vdmVGaXJzdD1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5zaGlmdCgpfSxWaS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxlKGtpLnByb3RvdHlwZSx7Y2xlYXJWaXNpdGVkRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5zZXRWaXNpdGVkKCExKX19LGdldFJpZ2h0bW9zdENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZH0sY29tcHV0ZU5vZGVEZXB0aDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5pc1Zpc2l0ZWQoKXx8aS5nZXRTeW0oKS5pc1Zpc2l0ZWQoKSl7ZT1pO2JyZWFrfX1pZihudWxsPT09ZSl0aHJvdyBuZXcgc24oXCJ1bmFibGUgdG8gZmluZCBlZGdlIHRvIGNvbXB1dGUgZGVwdGhzIGF0IFwiK3QuZ2V0Q29vcmRpbmF0ZSgpKTt0LmdldEVkZ2VzKCkuY29tcHV0ZURlcHRocyhlKTtmb3IodmFyIG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldFZpc2l0ZWQoITApLHRoaXMuY29weVN5bURlcHRocyhpKX19LGNvbXB1dGVEZXB0aDpmdW5jdGlvbih0KXt0aGlzLmNsZWFyVmlzaXRlZEVkZ2VzKCk7dmFyIGU9dGhpcy5maW5kZXIuZ2V0RWRnZSgpO2UuZ2V0Tm9kZSgpLGUuZ2V0TGFiZWwoKTtlLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsdCksdGhpcy5jb3B5U3ltRGVwdGhzKGUpLHRoaXMuY29tcHV0ZURlcHRocyhlKX0sY3JlYXRlOmZ1bmN0aW9uKHQpe3RoaXMuYWRkUmVhY2hhYmxlKHQpLHRoaXMuZmluZGVyLmZpbmRFZGdlKHRoaXMuZGlyRWRnZUxpc3QpLHRoaXMucmlnaHRNb3N0Q29vcmQ9dGhpcy5maW5kZXIuZ2V0Q29vcmRpbmF0ZSgpfSxmaW5kUmVzdWx0RWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXREZXB0aChjbi5SSUdIVCk+PTEmJmUuZ2V0RGVwdGgoY24uTEVGVCk8PTAmJiFlLmlzSW50ZXJpb3JBcmVhRWRnZSgpJiZlLnNldEluUmVzdWx0KCEwKX19LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEosbj1uZXcgVmksaT10LmdldE5vZGUoKTtmb3Iobi5hZGRMYXN0KGkpLGUuYWRkKGkpLHQuc2V0VmlzaXRlZCghMCk7IW4uaXNFbXB0eSgpOyl7dmFyIHI9bi5yZW1vdmVGaXJzdCgpO2UuYWRkKHIpLHRoaXMuY29tcHV0ZU5vZGVEZXB0aChyKTtmb3IodmFyIHM9ci5nZXRFZGdlcygpLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxhPW8uZ2V0U3ltKCk7aWYoIWEuaXNWaXNpdGVkKCkpe3ZhciB1PWEuZ2V0Tm9kZSgpO2UuY29udGFpbnModSl8fChuLmFkZExhc3QodSksZS5hZGQodSkpfX19fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5yaWdodE1vc3RDb29yZC54PGUucmlnaHRNb3N0Q29vcmQueD8tMTp0aGlzLnJpZ2h0TW9zdENvb3JkLng+ZS5yaWdodE1vc3RDb29yZC54PzE6MH0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5lbnYpe2Zvcih2YXIgdD1uZXcgQyxlPXRoaXMuZGlyRWRnZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aC0xO3IrKyl0LmV4cGFuZFRvSW5jbHVkZShpW3JdKTt0aGlzLmVudj10fXJldHVybiB0aGlzLmVudn0sYWRkUmVhY2hhYmxlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBwZTtmb3IoZS5hZGQodCk7IWUuZW1wdHkoKTspe3ZhciBuPWUucG9wKCk7dGhpcy5hZGQobixlKX19LGNvcHlTeW1EZXB0aHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRTeW0oKTtlLnNldERlcHRoKGNuLkxFRlQsdC5nZXREZXB0aChjbi5SSUdIVCkpLGUuc2V0RGVwdGgoY24uUklHSFQsdC5nZXREZXB0aChjbi5MRUZUKSl9LGFkZDpmdW5jdGlvbih0LGUpe3Quc2V0VmlzaXRlZCghMCksdGhpcy5ub2Rlcy5hZGQodCk7Zm9yKHZhciBuPXQuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5kaXJFZGdlTGlzdC5hZGQoaSk7dmFyIHI9aS5nZXRTeW0oKSxzPXIuZ2V0Tm9kZSgpO3MuaXNWaXNpdGVkKCl8fGUucHVzaChzKX19LGdldE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXN9LGdldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXJFZGdlTGlzdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtpfX0pLGUoWWkucHJvdG90eXBlLHtpc0RlbGV0YWJsZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10aGlzLmlucHV0TGluZVt0XSxzPXRoaXMuaW5wdXRMaW5lW2VdLG89dGhpcy5pbnB1dExpbmVbbl07cmV0dXJuIHRoaXMuaXNDb25jYXZlKHIscyxvKSYmdGhpcy5pc1NoYWxsb3cocixzLG8saSk/dGhpcy5pc1NoYWxsb3dTYW1wbGVkKHIscyx0LG4saSk6ITF9LGRlbGV0ZVNoYWxsb3dDb25jYXZpdGllczpmdW5jdGlvbigpe2Zvcih2YXIgdD0xLGU9KHRoaXMuaW5wdXRMaW5lLmxlbmd0aC0xLHRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCkpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKSxpPSExO248dGhpcy5pbnB1dExpbmUubGVuZ3RoOyl7dmFyIHI9ITE7dGhpcy5pc0RlbGV0YWJsZSh0LGUsbix0aGlzLmRpc3RhbmNlVG9sKSYmKHRoaXMuaXNEZWxldGVkW2VdPVlpLkRFTEVURSxyPSEwLGk9ITApLHQ9cj9uOmUsZT10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KHQpLG49dGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleChlKX1yZXR1cm4gaX0saXNTaGFsbG93Q29uY2F2aXR5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbikscz1yPT09dGhpcy5hbmdsZU9yaWVudGF0aW9uO2lmKCFzKXJldHVybiExO3ZhciBvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsdCxuKTtyZXR1cm4gaT5vfSxpc1NoYWxsb3dTYW1wbGVkOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9TWF0aC50cnVuYygoaS1uKS9ZaS5OVU1fUFRTX1RPX0NIRUNLKTswPj1zJiYocz0xKTtmb3IodmFyIG89bjtpPm87bys9cylpZighdGhpcy5pc1NoYWxsb3codCxlLHRoaXMuaW5wdXRMaW5lW29dLHIpKXJldHVybiExO3JldHVybiEwfSxpc0NvbmNhdmU6ZnVuY3Rpb24gdChlLG4saSl7dmFyIHI9aGUuY29tcHV0ZU9yaWVudGF0aW9uKGUsbixpKSx0PXI9PT10aGlzLmFuZ2xlT3JpZW50YXRpb247cmV0dXJuIHR9LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2w9TWF0aC5hYnModCksMD50JiYodGhpcy5hbmdsZU9yaWVudGF0aW9uPWhlLkNMT0NLV0lTRSksdGhpcy5pc0RlbGV0ZWQ9bmV3IEFycmF5KHRoaXMuaW5wdXRMaW5lLmxlbmd0aCkuZmlsbChudWxsKTt2YXIgZT0hMTtkbyBlPXRoaXMuZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzKCk7d2hpbGUoZSk7cmV0dXJuIHRoaXMuY29sbGFwc2VMaW5lKCl9LGZpbmROZXh0Tm9uRGVsZXRlZEluZGV4OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10KzE7ZTx0aGlzLmlucHV0TGluZS5sZW5ndGgmJnRoaXMuaXNEZWxldGVkW2VdPT09WWkuREVMRVRFOyllKys7cmV0dXJuIGV9LGlzU2hhbGxvdzpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1oZS5kaXN0YW5jZVBvaW50TGluZShlLHQsbik7cmV0dXJuIGk+cn0sY29sbGFwc2VMaW5lOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBOLGU9MDtlPHRoaXMuaW5wdXRMaW5lLmxlbmd0aDtlKyspdGhpcy5pc0RlbGV0ZWRbZV0hPT1ZaS5ERUxFVEUmJnQuYWRkKHRoaXMuaW5wdXRMaW5lW2VdKTtyZXR1cm4gdC50b0Nvb3JkaW5hdGVBcnJheSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZaX19KSxZaS5zaW1wbGlmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBZaSh0KTtyZXR1cm4gbi5zaW1wbGlmeShlKX0sWWkuSU5JVD0wLFlpLkRFTEVURT0xLFlpLktFRVA9MSxZaS5OVU1fUFRTX1RPX0NIRUNLPTEwLGUoVWkucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMucHRMaXN0LnRvQXJyYXkoVWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFKTtyZXR1cm4gdH0sc2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5wcmVjaXNpb25Nb2RlbD10fSxhZGRQdDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZShlKSx0aGlzLmlzUmVkdW5kYW50KGUpP251bGw6dm9pZCB0aGlzLnB0TGlzdC5hZGQoZSl9LHJldmVyc2U6ZnVuY3Rpb24oKXt9LGFkZFB0czpmdW5jdGlvbih0LGUpe2lmKGUpZm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspdGhpcy5hZGRQdCh0W25dKTtlbHNlIGZvcih2YXIgbj10Lmxlbmd0aC0xO24+PTA7bi0tKXRoaXMuYWRkUHQodFtuXSl9LGlzUmVkdW5kYW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiExO3ZhciBlPXRoaXMucHRMaXN0LmdldCh0aGlzLnB0TGlzdC5zaXplKCktMSksbj10LmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMubWluaW1pbVZlcnRleERpc3RhbmNlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PW5ldyBpZSxlPXQuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpO3JldHVybiBlLnRvU3RyaW5nKCl9LGNsb3NlUmluZzpmdW5jdGlvbigpe2lmKHRoaXMucHRMaXN0LnNpemUoKTwxKXJldHVybiBudWxsO3ZhciB0PW5ldyBnKHRoaXMucHRMaXN0LmdldCgwKSksZT10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTEpLG49bnVsbDtyZXR1cm4gdGhpcy5wdExpc3Quc2l6ZSgpPj0yJiYobj10aGlzLnB0TGlzdC5nZXQodGhpcy5wdExpc3Quc2l6ZSgpLTIpKSx0LmVxdWFscyhlKT9udWxsOnZvaWQgdGhpcy5wdExpc3QuYWRkKHQpfSxzZXRNaW5pbXVtVmVydGV4RGlzdGFuY2U6ZnVuY3Rpb24odCl7dGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVWl9fSksVWkuQ09PUkRJTkFURV9BUlJBWV9UWVBFPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGUoWGkucHJvdG90eXBlLHthZGROZXh0U2VnbWVudDpmdW5jdGlvbih0LGUpe2lmKHRoaXMuczA9dGhpcy5zMSx0aGlzLnMxPXRoaXMuczIsdGhpcy5zMj10LHRoaXMuc2VnMC5zZXRDb29yZGluYXRlcyh0aGlzLnMwLHRoaXMuczEpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcwLHRoaXMuc2lkZSx0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MCksdGhpcy5zZWcxLnNldENvb3JkaW5hdGVzKHRoaXMuczEsdGhpcy5zMiksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLnNlZzEsdGhpcy5zaWRlLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQxKSx0aGlzLnMxLmVxdWFscyh0aGlzLnMyKSlyZXR1cm4gbnVsbDt2YXIgbj1oZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczIpLGk9bj09PWhlLkNMT0NLV0lTRSYmdGhpcy5zaWRlPT09Y24uTEVGVHx8bj09PWhlLkNPVU5URVJDTE9DS1dJU0UmJnRoaXMuc2lkZT09PWNuLlJJR0hUOzA9PT1uP3RoaXMuYWRkQ29sbGluZWFyKGUpOmk/dGhpcy5hZGRPdXRzaWRlVHVybihuLGUpOnRoaXMuYWRkSW5zaWRlVHVybihuLGUpfSxhZGRMaW5lRW5kQ2FwOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNlKHQsZSksaT1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLkxFRlQsdGhpcy5kaXN0YW5jZSxpKTt2YXIgcj1uZXcgY2U7dGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudChuLGNuLlJJR0hULHRoaXMuZGlzdGFuY2Uscik7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyk7c3dpdGNoKHRoaXMuYnVmUGFyYW1zLmdldEVuZENhcFN0eWxlKCkpe2Nhc2UgQmkuQ0FQX1JPVU5EOnRoaXMuc2VnTGlzdC5hZGRQdChpLnAxKSx0aGlzLmFkZEZpbGxldEFyYyhlLGErTWF0aC5QSS8yLGEtTWF0aC5QSS8yLGhlLkNMT0NLV0lTRSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuYWRkUHQoci5wMSk7YnJlYWs7Y2FzZSBCaS5DQVBfRkxBVDp0aGlzLnNlZ0xpc3QuYWRkUHQoaS5wMSksdGhpcy5zZWdMaXN0LmFkZFB0KHIucDEpO2JyZWFrO2Nhc2UgQmkuQ0FQX1NRVUFSRTp2YXIgdT1uZXcgZzt1Lng9TWF0aC5hYnModGhpcy5kaXN0YW5jZSkqTWF0aC5jb3MoYSksdS55PU1hdGguYWJzKHRoaXMuZGlzdGFuY2UpKk1hdGguc2luKGEpO3ZhciBsPW5ldyBnKGkucDEueCt1LngsaS5wMS55K3UueSksaD1uZXcgZyhyLnAxLngrdS54LHIucDEueSt1LnkpO3RoaXMuc2VnTGlzdC5hZGRQdChsKSx0aGlzLnNlZ0xpc3QuYWRkUHQoaCl9fSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc2VnTGlzdC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0fSxhZGRNaXRyZUpvaW46ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9ITAscz1udWxsO3RyeXtzPUYuaW50ZXJzZWN0aW9uKGUucDAsZS5wMSxuLnAwLG4ucDEpO3ZhciBvPTA+PWk/MTpzLmRpc3RhbmNlKHQpL01hdGguYWJzKGkpO28+dGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpJiYocj0hMSl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgdykpdGhyb3cgdDtzPW5ldyBnKDAsMCkscj0hMX1maW5hbGx5e31yP3RoaXMuc2VnTGlzdC5hZGRQdChzKTp0aGlzLmFkZExpbWl0ZWRNaXRyZUpvaW4oZSxuLGksdGhpcy5idWZQYXJhbXMuZ2V0TWl0cmVMaW1pdCgpKX0sYWRkRmlsbGV0Q29ybmVyOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9ZS54LXQueCxvPWUueS10LnksYT1NYXRoLmF0YW4yKG8scyksdT1uLngtdC54LGw9bi55LXQueSxoPU1hdGguYXRhbjIobCx1KTtpPT09aGUuQ0xPQ0tXSVNFP2g+PWEmJihhKz0yKk1hdGguUEkpOmE+PWgmJihhLT0yKk1hdGguUEkpLHRoaXMuc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZEZpbGxldEFyYyh0LGEsaCxpLHIpLHRoaXMuc2VnTGlzdC5hZGRQdChuKX0sYWRkT3V0c2lkZVR1cm46ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5vZmZzZXQwLnAxLmRpc3RhbmNlKHRoaXMub2Zmc2V0MS5wMCk8dGhpcy5kaXN0YW5jZSpYaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj8odGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksbnVsbCk6dm9pZCh0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fTUlUUkU/dGhpcy5hZGRNaXRyZUpvaW4odGhpcy5zMSx0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxLHRoaXMuZGlzdGFuY2UpOnRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9CRVZFTD90aGlzLmFkZEJldmVsSm9pbih0aGlzLm9mZnNldDAsdGhpcy5vZmZzZXQxKTooZSYmdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksdGhpcy5hZGRGaWxsZXRDb3JuZXIodGhpcy5zMSx0aGlzLm9mZnNldDAucDEsdGhpcy5vZmZzZXQxLnAwLHQsdGhpcy5kaXN0YW5jZSksdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCkpKX0sY3JlYXRlU3F1YXJlOmZ1bmN0aW9uKHQpe3RoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnktdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5hZGRQdChuZXcgZyh0LngtdGhpcy5kaXN0YW5jZSx0LnkrdGhpcy5kaXN0YW5jZSkpLHRoaXMuc2VnTGlzdC5jbG9zZVJpbmcoKX0sYWRkU2VnbWVudHM6ZnVuY3Rpb24odCxlKXt0aGlzLnNlZ0xpc3QuYWRkUHRzKHQsZSl9LGFkZEZpcnN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApfSxhZGRMYXN0U2VnbWVudDpmdW5jdGlvbigpe3RoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDEpfSxpbml0U2lkZVNlZ21lbnRzOmZ1bmN0aW9uKHQsZSxuKXt0aGlzLnMxPXQsdGhpcy5zMj1lLHRoaXMuc2lkZT1uLHRoaXMuc2VnMS5zZXRDb29yZGluYXRlcyh0LGUpLHRoaXMuY29tcHV0ZU9mZnNldFNlZ21lbnQodGhpcy5zZWcxLG4sdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDEpfSxhZGRMaW1pdGVkTWl0cmVKb2luOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMuc2VnMC5wMSxzPWhpLmFuZ2xlKHIsdGhpcy5zZWcwLnAwKSxvPShoaS5hbmdsZShyLHRoaXMuc2VnMS5wMSksaGkuYW5nbGVCZXR3ZWVuT3JpZW50ZWQodGhpcy5zZWcwLnAwLHIsdGhpcy5zZWcxLnAxKSksYT1vLzIsdT1oaS5ub3JtYWxpemUocythKSxsPWhpLm5vcm1hbGl6ZSh1K01hdGguUEkpLGg9aSpuLGM9aCpNYXRoLmFicyhNYXRoLnNpbihhKSksZj1uLWMsZD1yLngraCpNYXRoLmNvcyhsKSxwPXIueStoKk1hdGguc2luKGwpLHY9bmV3IGcoZCxwKSxtPW5ldyBjZShyLHYpLHk9bS5wb2ludEFsb25nT2Zmc2V0KDEsZikseD1tLnBvaW50QWxvbmdPZmZzZXQoMSwtZik7dGhpcy5zaWRlPT09Y24uTEVGVD8odGhpcy5zZWdMaXN0LmFkZFB0KHkpLHRoaXMuc2VnTGlzdC5hZGRQdCh4KSk6KHRoaXMuc2VnTGlzdC5hZGRQdCh4KSx0aGlzLnNlZ0xpc3QuYWRkUHQoeSkpfSxjb21wdXRlT2Zmc2V0U2VnbWVudDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1lPT09Y24uTEVGVD8xOi0xLHM9dC5wMS54LXQucDAueCxvPXQucDEueS10LnAwLnksYT1NYXRoLnNxcnQocypzK28qbyksdT1yKm4qcy9hLGw9cipuKm8vYTtpLnAwLng9dC5wMC54LWwsaS5wMC55PXQucDAueSt1LGkucDEueD10LnAxLngtbCxpLnAxLnk9dC5wMS55K3V9LGFkZEZpbGxldEFyYzpmdW5jdGlvbih0LGUsbixpLHIpe3ZhciBzPWk9PT1oZS5DTE9DS1dJU0U/LTE6MSxvPU1hdGguYWJzKGUtbiksYT1NYXRoLnRydW5jKG8vdGhpcy5maWxsZXRBbmdsZVF1YW50dW0rLjUpO2lmKDE+YSlyZXR1cm4gbnVsbDt2YXIgdT1udWxsLGw9bnVsbDt1PTAsbD1vL2E7Zm9yKHZhciBoPXUsYz1uZXcgZztvPmg7KXt2YXIgZj1lK3MqaDtjLng9dC54K3IqTWF0aC5jb3MoZiksYy55PXQueStyKk1hdGguc2luKGYpLHRoaXMuc2VnTGlzdC5hZGRQdChjKSxoKz1sfX0sYWRkSW5zaWRlVHVybjpmdW5jdGlvbih0LGUpe2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLm9mZnNldDAucDAsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCx0aGlzLm9mZnNldDEucDEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApKTtlbHNlIGlmKHRoaXMuX2hhc05hcnJvd0NvbmNhdmVBbmdsZT0hMCx0aGlzLm9mZnNldDAucDEuZGlzdGFuY2UodGhpcy5vZmZzZXQxLnAwKTx0aGlzLmRpc3RhbmNlKlhpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKTtlbHNle2lmKHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcj4wKXt2YXIgbj1uZXcgZygodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS54K3RoaXMuczEueCkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSwodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKnRoaXMub2Zmc2V0MC5wMS55K3RoaXMuczEueSkvKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3RvcisxKSk7dGhpcy5zZWdMaXN0LmFkZFB0KG4pO3ZhciBpPW5ldyBnKCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLngrdGhpcy5zMS54KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQxLnAwLnkrdGhpcy5zMS55KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLnNlZ0xpc3QuYWRkUHQoaSl9ZWxzZSB0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5zMSk7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCl9fSxjcmVhdGVDaXJjbGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGcodC54K3RoaXMuZGlzdGFuY2UsdC55KTt0aGlzLnNlZ0xpc3QuYWRkUHQoZSksdGhpcy5hZGRGaWxsZXRBcmModCwwLDIqTWF0aC5QSSwtMSx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGFkZEJldmVsSm9pbjpmdW5jdGlvbih0LGUpe3RoaXMuc2VnTGlzdC5hZGRQdCh0LnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQoZS5wMCl9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZT10LHRoaXMubWF4Q3VydmVTZWdtZW50RXJyb3I9dCooMS1NYXRoLmNvcyh0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bS8yKSksdGhpcy5zZWdMaXN0PW5ldyBVaSx0aGlzLnNlZ0xpc3Quc2V0UHJlY2lzaW9uTW9kZWwodGhpcy5wcmVjaXNpb25Nb2RlbCksdGhpcy5zZWdMaXN0LnNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZSh0KlhpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUil9LGFkZENvbGxpbmVhcjpmdW5jdGlvbih0KXt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odGhpcy5zMCx0aGlzLnMxLHRoaXMuczEsdGhpcy5zMik7dmFyIGU9dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTtlPj0yJiYodGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX0JFVkVMfHx0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fTUlUUkU/KHQmJnRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpLHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDEucDApKTp0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLnMxLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsaGUuQ0xPQ0tXSVNFLHRoaXMuZGlzdGFuY2UpKX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxoYXNOYXJyb3dDb25jYXZlQW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYaX19KSxYaS5PRkZTRVRfU0VHTUVOVF9TRVBBUkFUSU9OX0ZBQ1RPUj0uMDAxLFhpLklOU0lERV9UVVJOX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0uMDAxLFhpLkNVUlZFX1ZFUlRFWF9TTkFQX0RJU1RBTkNFX0ZBQ1RPUj0xZS02LFhpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SPTgwLGUoSGkucHJvdG90eXBlLHtnZXRPZmZzZXRDdXJ2ZTpmdW5jdGlvbih0LGUpe2lmKHRoaXMuZGlzdGFuY2U9ZSwwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj0wPmUsaT1NYXRoLmFicyhlKSxyPXRoaXMuZ2V0U2VnR2VuKGkpO3QubGVuZ3RoPD0xP3RoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxyKTp0aGlzLmNvbXB1dGVPZmZzZXRDdXJ2ZSh0LG4scik7dmFyIHM9ci5nZXRDb29yZGluYXRlcygpO3JldHVybiBuJiZILnJldmVyc2Uocyksc30sY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7aWYoZSl7bi5hZGRTZWdtZW50cyh0LCEwKTt2YXIgcj1ZaS5zaW1wbGlmeSh0LC1pKSxzPXIubGVuZ3RoLTE7bi5pbml0U2lkZVNlZ21lbnRzKHJbc10scltzLTFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPXMtMjtvPj0wO28tLSluLmFkZE5leHRTZWdtZW50KHJbb10sITApfWVsc2V7bi5hZGRTZWdtZW50cyh0LCExKTt2YXIgYT1ZaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCksbi5jbG9zZVJpbmcoKX0sY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtlPT09Y24uUklHSFQmJihpPS1pKTt2YXIgcj1ZaS5zaW1wbGlmeSh0LGkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzLTFdLHJbMF0sZSk7Zm9yKHZhciBvPTE7cz49bztvKyspe3ZhciBhPTEhPT1vO24uYWRkTmV4dFNlZ21lbnQocltvXSxhKX1uLmNsb3NlUmluZygpfSxjb21wdXRlTGluZUJ1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKSxpPVlpLnNpbXBsaWZ5KHQsbikscj1pLmxlbmd0aC0xO2UuaW5pdFNpZGVTZWdtZW50cyhpWzBdLGlbMV0sY24uTEVGVCk7Zm9yKHZhciBzPTI7cj49cztzKyspZS5hZGROZXh0U2VnbWVudChpW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKGlbci0xXSxpW3JdKTt2YXIgbz1ZaS5zaW1wbGlmeSh0LC1uKSxhPW8ubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKG9bYV0sb1thLTFdLGNuLkxFRlQpO2Zvcih2YXIgcz1hLTI7cz49MDtzLS0pZS5hZGROZXh0U2VnbWVudChvW3NdLCEwKTtlLmFkZExhc3RTZWdtZW50KCksZS5hZGRMaW5lRW5kQ2FwKG9bMV0sb1swXSksZS5jbG9zZVJpbmcoKX0sY29tcHV0ZVBvaW50Q3VydmU6ZnVuY3Rpb24odCxlKXtzd2l0Y2godGhpcy5idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBCaS5DQVBfUk9VTkQ6ZS5jcmVhdGVDaXJjbGUodCk7YnJlYWs7Y2FzZSBCaS5DQVBfU1FVQVJFOmUuY3JlYXRlU3F1YXJlKHQpfX0sZ2V0TGluZUN1cnZlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5kaXN0YW5jZT1lLDA+ZSYmIXRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSlyZXR1cm4gbnVsbDtpZigwPT09ZSlyZXR1cm4gbnVsbDt2YXIgbj1NYXRoLmFicyhlKSxpPXRoaXMuZ2V0U2VnR2VuKG4pO2lmKHQubGVuZ3RoPD0xKXRoaXMuY29tcHV0ZVBvaW50Q3VydmUodFswXSxpKTtlbHNlIGlmKHRoaXMuYnVmUGFyYW1zLmlzU2luZ2xlU2lkZWQoKSl7dmFyIHI9MD5lO3RoaXMuY29tcHV0ZVNpbmdsZVNpZGVkQnVmZmVyQ3VydmUodCxyLGkpfWVsc2UgdGhpcy5jb21wdXRlTGluZUJ1ZmZlckN1cnZlKHQsaSk7dmFyIHM9aS5nZXRDb29yZGluYXRlcygpO3JldHVybiBzfSxnZXRCdWZmZXJQYXJhbWV0ZXJzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVmUGFyYW1zfSxzaW1wbGlmeVRvbGVyYW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdCp0aGlzLmJ1ZlBhcmFtcy5nZXRTaW1wbGlmeUZhY3RvcigpfSxnZXRSaW5nQ3VydmU6ZnVuY3Rpb24odCxlLG4pe2lmKHRoaXMuZGlzdGFuY2U9bix0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5nZXRMaW5lQ3VydmUodCxuKTtpZigwPT09bilyZXR1cm4gSGkuY29weUNvb3JkaW5hdGVzKHQpO3ZhciBpPXRoaXMuZ2V0U2VnR2VuKG4pO3JldHVybiB0aGlzLmNvbXB1dGVSaW5nQnVmZmVyQ3VydmUodCxlLGkpLGkuZ2V0Q29vcmRpbmF0ZXMoKX0sY29tcHV0ZU9mZnNldEN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2lmKGUpe3ZhciByPVlpLnNpbXBsaWZ5KHQsLWkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzXSxyW3MtMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89cy0yO28+PTA7by0tKW4uYWRkTmV4dFNlZ21lbnQocltvXSwhMCl9ZWxzZXt2YXIgYT1ZaS5zaW1wbGlmeSh0LGkpLHU9YS5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMoYVswXSxhWzFdLGNuLkxFRlQpLG4uYWRkRmlyc3RTZWdtZW50KCk7Zm9yKHZhciBvPTI7dT49bztvKyspbi5hZGROZXh0U2VnbWVudChhW29dLCEwKX1uLmFkZExhc3RTZWdtZW50KCl9LGdldFNlZ0dlbjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFhpKHRoaXMucHJlY2lzaW9uTW9kZWwsdGhpcy5idWZQYXJhbXMsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhpfX0pLEhpLmNvcHlDb29yZGluYXRlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPW5ldyBnKHRbbl0pO3JldHVybiBlfSxlKFdpLnByb3RvdHlwZSx7ZmluZFN0YWJiZWRTZWdtZW50czpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10aGlzLnN1YmdyYXBocy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldEVudmVsb3BlKCk7dC55PHIuZ2V0TWluWSgpfHx0Lnk+ci5nZXRNYXhZKCl8fHRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0LGkuZ2V0RGlyZWN0ZWRFZGdlcygpLGUpfXJldHVybiBlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgSW4pZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPWFyZ3VtZW50c1syXSx1PW8uZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCksbj0wO248dS5sZW5ndGgtMTtuKyspe3RoaXMuc2VnLnAwPXVbbl0sdGhpcy5zZWcucDE9dVtuKzFdLHRoaXMuc2VnLnAwLnk+dGhpcy5zZWcucDEueSYmdGhpcy5zZWcucmV2ZXJzZSgpO3ZhciBsPU1hdGgubWF4KHRoaXMuc2VnLnAwLngsdGhpcy5zZWcucDEueCk7aWYoIShsPHMueHx8dGhpcy5zZWcuaXNIb3Jpem9udGFsKCl8fHMueTx0aGlzLnNlZy5wMC55fHxzLnk+dGhpcy5zZWcucDEueXx8aGUuY29tcHV0ZU9yaWVudGF0aW9uKHRoaXMuc2VnLnAwLHRoaXMuc2VnLnAxLHMpPT09aGUuUklHSFQpKXt2YXIgaD1vLmdldERlcHRoKGNuLkxFRlQpO3RoaXMuc2VnLnAwLmVxdWFscyh1W25dKXx8KGg9by5nZXREZXB0aChjbi5SSUdIVCkpO3ZhciBjPW5ldyBqaSh0aGlzLnNlZyxoKTthLmFkZChjKX19ZWxzZSBpZihSKGFyZ3VtZW50c1syXSx5KSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZSKGFyZ3VtZW50c1sxXSx5KSlmb3IodmFyIGY9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLG49ZC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIHY9bi5uZXh0KCk7di5pc0ZvcndhcmQoKSYmdGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKGYsdixwKX19LGdldERlcHRoOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZFN0YWJiZWRTZWdtZW50cyh0KTtpZigwPT09ZS5zaXplKCkpcmV0dXJuIDA7dmFyIG49aG8ubWluKGUpO3JldHVybiBuLmxlZnREZXB0aH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV2l9fSksZShqaS5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O2lmKHRoaXMudXB3YXJkU2VnLm1pblgoKT49ZS51cHdhcmRTZWcubWF4WCgpKXJldHVybiAxO2lmKHRoaXMudXB3YXJkU2VnLm1heFgoKTw9ZS51cHdhcmRTZWcubWluWCgpKXJldHVybi0xO3ZhciBuPXRoaXMudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgoZS51cHdhcmRTZWcpO3JldHVybiAwIT09bj9uOihuPS0xKmUudXB3YXJkU2VnLm9yaWVudGF0aW9uSW5kZXgodGhpcy51cHdhcmRTZWcpLDAhPT1uP246dGhpcy51cHdhcmRTZWcuY29tcGFyZVRvKGUudXB3YXJkU2VnKSl9LGNvbXBhcmVYOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dC5wMS5jb21wYXJlVG8oZS5wMSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXB3YXJkU2VnLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqaX19KSxXaS5EZXB0aFNlZ21lbnQ9amksZShLaS5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTApcmV0dXJuIG51bGw7XG52YXIgZT10LmdldENvb3JkaW5hdGVzKCksbj10aGlzLmN1cnZlQnVpbGRlci5nZXRMaW5lQ3VydmUoZSx0aGlzLmRpc3RhbmNlKTt0aGlzLmFkZEN1cnZlKG4sTC5FWFRFUklPUixMLklOVEVSSU9SKX0sYWRkUG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmRpc3RhbmNlLG49Y24uTEVGVDt0aGlzLmRpc3RhbmNlPDAmJihlPS10aGlzLmRpc3RhbmNlLG49Y24uUklHSFQpO3ZhciBpPXQuZ2V0RXh0ZXJpb3JSaW5nKCkscj1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKGkuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYodGhpcy5kaXN0YW5jZTwwJiZ0aGlzLmlzRXJvZGVkQ29tcGxldGVseShpLHRoaXMuZGlzdGFuY2UpKXJldHVybiBudWxsO2lmKHRoaXMuZGlzdGFuY2U8PTAmJnIubGVuZ3RoPDMpcmV0dXJuIG51bGw7dGhpcy5hZGRQb2x5Z29uUmluZyhyLGUsbixMLkVYVEVSSU9SLEwuSU5URVJJT1IpO2Zvcih2YXIgcz0wO3M8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtzKyspe3ZhciBvPXQuZ2V0SW50ZXJpb3JSaW5nTihzKSxhPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoby5nZXRDb29yZGluYXRlcygpKTt0aGlzLmRpc3RhbmNlPjAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KG8sLXRoaXMuZGlzdGFuY2UpfHx0aGlzLmFkZFBvbHlnb25SaW5nKGEsZSxjbi5vcHBvc2l0ZShuKSxMLklOVEVSSU9SLEwuRVhURVJJT1IpfX0saXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHk6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgY2kodFswXSx0WzFdLHRbMl0pLGk9bi5pbkNlbnRyZSgpLHI9aGUuZGlzdGFuY2VQb2ludExpbmUoaSxuLnAwLG4ucDEpO3JldHVybiByPE1hdGguYWJzKGUpfSxhZGRMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHRoaXMuZGlzdGFuY2U8PTAmJiF0aGlzLmN1cnZlQnVpbGRlci5nZXRCdWZmZXJQYXJhbWV0ZXJzKCkuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMuY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixMLkVYVEVSSU9SLEwuSU5URVJJT1IpfSxhZGRDdXJ2ZTpmdW5jdGlvbih0LGUsbil7aWYobnVsbD09PXR8fHQubGVuZ3RoPDIpcmV0dXJuIG51bGw7dmFyIGk9bmV3IEtlKHQsbmV3IGduKDAsTC5CT1VOREFSWSxlLG4pKTt0aGlzLmN1cnZlTGlzdC5hZGQoaSl9LGdldEN1cnZlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFkZCh0aGlzLmlucHV0R2VvbSksdGhpcy5jdXJ2ZUxpc3R9LGFkZFBvbHlnb25SaW5nOmZ1bmN0aW9uKHQsZSxuLGkscil7aWYoMD09PWUmJnQubGVuZ3RoPGJ0Lk1JTklNVU1fVkFMSURfU0laRSlyZXR1cm4gbnVsbDt2YXIgcz1pLG89cjt0Lmxlbmd0aD49YnQuTUlOSU1VTV9WQUxJRF9TSVpFJiZoZS5pc0NDVyh0KSYmKHM9cixvPWksbj1jbi5vcHBvc2l0ZShuKSk7dmFyIGE9dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0UmluZ0N1cnZlKHQsbixlKTt0aGlzLmFkZEN1cnZlKGEscyxvKX0sYWRkOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO2lmKHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBPdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19LGlzRXJvZGVkQ29tcGxldGVseTpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZXMoKTtpZihuLmxlbmd0aDw0KXJldHVybiAwPmU7aWYoND09PW4ubGVuZ3RoKXJldHVybiB0aGlzLmlzVHJpYW5nbGVFcm9kZWRDb21wbGV0ZWx5KG4sZSk7dmFyIGk9dC5nZXRFbnZlbG9wZUludGVybmFsKCkscj1NYXRoLm1pbihpLmdldEhlaWdodCgpLGkuZ2V0V2lkdGgoKSk7cmV0dXJuIDA+ZSYmMipNYXRoLmFicyhlKT5yfSxhZGRDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTt0aGlzLmFkZChuKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtpfX0pLGUoWmkucHJvdG90eXBlLHtpc1RyaXZpYWxJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7aWYodD09PW4mJjE9PT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpKXtpZihaaS5pc0FkamFjZW50U2VnbWVudHMoZSxpKSlyZXR1cm4hMDtpZih0LmlzQ2xvc2VkKCkpe3ZhciByPXQuc2l6ZSgpLTE7aWYoMD09PWUmJmk9PT1yfHwwPT09aSYmZT09PXIpcmV0dXJuITB9fXJldHVybiExfSxnZXRQcm9wZXJJbnRlcnNlY3Rpb25Qb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50fSxoYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc1Byb3BlckludGVyaW9yfSxnZXRMaW5lSW50ZXJzZWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saX0saGFzUHJvcGVySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVyfSxwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dGhpcy5udW1UZXN0cysrO3ZhciByPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlXSxzPXQuZ2V0Q29vcmRpbmF0ZXMoKVtlKzFdLG89bi5nZXRDb29yZGluYXRlcygpW2ldLGE9bi5nZXRDb29yZGluYXRlcygpW2krMV07dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHIscyxvLGEpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLm51bUludGVyc2VjdGlvbnMrKyx0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJpb3JJbnRlcnNlY3Rpb25zKyssdGhpcy5oYXNJbnRlcmlvcj0hMCksdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4saSl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsdC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpLHRoaXMubGkuaXNQcm9wZXIoKSYmKHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucysrLHRoaXMuaGFzUHJvcGVyPSEwLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITApKSl9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNJbnRlcnNlY3Rpb259LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyaW9yfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFppfX0pLFppLmlzQWRqYWNlbnRTZWdtZW50cz1mdW5jdGlvbih0LGUpe3JldHVybiAxPT09TWF0aC5hYnModC1lKX0sZShRaS5wcm90b3R5cGUse3NldFdvcmtpbmdQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLndvcmtpbmdQcmVjaXNpb25Nb2RlbD10fSxpbnNlcnRVbmlxdWVFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZUxpc3QuZmluZEVxdWFsRWRnZSh0KTtpZihudWxsIT09ZSl7dmFyIG49ZS5nZXRMYWJlbCgpLGk9dC5nZXRMYWJlbCgpO2UuaXNQb2ludHdpc2VFcXVhbCh0KXx8KGk9bmV3IGduKHQuZ2V0TGFiZWwoKSksaS5mbGlwKCkpLG4ubWVyZ2UoaSk7dmFyIHI9UWkuZGVwdGhEZWx0YShpKSxzPWUuZ2V0RGVwdGhEZWx0YSgpLG89cytyO2Uuc2V0RGVwdGhEZWx0YShvKX1lbHNlIHRoaXMuZWRnZUxpc3QuYWRkKHQpLHQuc2V0RGVwdGhEZWx0YShRaS5kZXB0aERlbHRhKHQuZ2V0TGFiZWwoKSkpfSxidWlsZFN1YmdyYXBoczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpLHM9ci5nZXRSaWdodG1vc3RDb29yZGluYXRlKCksbz1uZXcgV2kobiksYT1vLmdldERlcHRoKHMpO3IuY29tcHV0ZURlcHRoKGEpLHIuZmluZFJlc3VsdEVkZ2VzKCksbi5hZGQociksZS5hZGQoci5nZXREaXJlY3RlZEVkZ2VzKCksci5nZXROb2RlcygpKX19LGNyZWF0ZVN1YmdyYXBoczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10LmdldE5vZGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKCFpLmlzVmlzaXRlZCgpKXt2YXIgcj1uZXcga2k7ci5jcmVhdGUoaSksZS5hZGQocil9fXJldHVybiBoby5zb3J0KGUsaG8ucmV2ZXJzZU9yZGVyKCkpLGV9LGNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdlb21GYWN0LmNyZWF0ZVBvbHlnb24oKTtyZXR1cm4gdH0sZ2V0Tm9kZXI6ZnVuY3Rpb24odCl7aWYobnVsbCE9PXRoaXMud29ya2luZ05vZGVyKXJldHVybiB0aGlzLndvcmtpbmdOb2Rlcjt2YXIgZT1uZXcgbm4sbj1uZXcgYWU7cmV0dXJuIG4uc2V0UHJlY2lzaW9uTW9kZWwodCksZS5zZXRTZWdtZW50SW50ZXJzZWN0b3IobmV3IFppKG4pKSxlfSxidWZmZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLndvcmtpbmdQcmVjaXNpb25Nb2RlbDtudWxsPT09biYmKG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLmdlb21GYWN0PXQuZ2V0RmFjdG9yeSgpO3ZhciBpPW5ldyBIaShuLHRoaXMuYnVmUGFyYW1zKSxyPW5ldyBLaSh0LGUsaSkscz1yLmdldEN1cnZlcygpO2lmKHMuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt0aGlzLmNvbXB1dGVOb2RlZEVkZ2VzKHMsbiksdGhpcy5ncmFwaD1uZXcgQ24obmV3IE9uKSx0aGlzLmdyYXBoLmFkZEVkZ2VzKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSk7dmFyIG89dGhpcy5jcmVhdGVTdWJncmFwaHModGhpcy5ncmFwaCksYT1uZXcgU24odGhpcy5nZW9tRmFjdCk7dGhpcy5idWlsZFN1YmdyYXBocyhvLGEpO3ZhciB1PWEuZ2V0UG9seWdvbnMoKTtpZih1LnNpemUoKTw9MClyZXR1cm4gdGhpcy5jcmVhdGVFbXB0eVJlc3VsdEdlb21ldHJ5KCk7dmFyIGw9dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHUpO3JldHVybiBsfSxjb21wdXRlTm9kZWRFZGdlczpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0Tm9kZXIoZSk7bi5jb21wdXRlTm9kZXModCk7Zm9yKHZhciBpPW4uZ2V0Tm9kZWRTdWJzdHJpbmdzKCkscj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZigyIT09by5sZW5ndGh8fCFvWzBdLmVxdWFsczJEKG9bMV0pKXt2YXIgYT1zLmdldERhdGEoKSx1PW5ldyBKbihzLmdldENvb3JkaW5hdGVzKCksbmV3IGduKGEpKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2UodSl9fX0sc2V0Tm9kZXI6ZnVuY3Rpb24odCl7dGhpcy53b3JraW5nTm9kZXI9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUWl9fSksUWkuZGVwdGhEZWx0YT1mdW5jdGlvbih0KXt2YXIgZT10LmdldExvY2F0aW9uKDAsY24uTEVGVCksbj10LmdldExvY2F0aW9uKDAsY24uUklHSFQpO3JldHVybiBlPT09TC5JTlRFUklPUiYmbj09PUwuRVhURVJJT1I/MTplPT09TC5FWFRFUklPUiYmbj09PUwuSU5URVJJT1I/LTE6MH0sUWkuY29udmVydFNlZ1N0cmluZ3M9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBpZSxuPW5ldyBJO3QuaGFzTmV4dCgpOyl7dmFyIGk9dC5uZXh0KCkscj1lLmNyZWF0ZUxpbmVTdHJpbmcoaS5nZXRDb29yZGluYXRlcygpKTtuLmFkZChyKX1yZXR1cm4gZS5idWlsZEdlb21ldHJ5KG4pfSxlKEppLnByb3RvdHlwZSx7Y2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKG5bMF0sdGhpcy5zZWdTdHJpbmdzKSx0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKG5bbi5sZW5ndGgtMV0sdGhpcy5zZWdTdHJpbmdzKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sdD1yLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPTE7czxuLmxlbmd0aC0xO3MrKylpZihuW3NdLmVxdWFscyhpKSl0aHJvdyBuZXcgbChcImZvdW5kIGVuZHB0L2ludGVyaW9yIHB0IGludGVyc2VjdGlvbiBhdCBpbmRleCBcIitzK1wiIDpwdCBcIitpKX0sY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhlLGkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPXIuZ2V0Q29vcmRpbmF0ZXMoKSxhPXMuZ2V0Q29vcmRpbmF0ZXMoKSx1PTA7dTxvLmxlbmd0aC0xO3UrKylmb3IodmFyIGg9MDtoPGEubGVuZ3RoLTE7aCsrKXRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMocix1LHMsaCk7ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGM9YXJndW1lbnRzWzBdLGY9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGQ9YXJndW1lbnRzWzNdO2lmKGM9PT1nJiZmPT09ZClyZXR1cm4gbnVsbDt2YXIgcD1jLmdldENvb3JkaW5hdGVzKClbZl0sdj1jLmdldENvb3JkaW5hdGVzKClbZisxXSxtPWcuZ2V0Q29vcmRpbmF0ZXMoKVtkXSx5PWcuZ2V0Q29vcmRpbmF0ZXMoKVtkKzFdO2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihwLHYsbSx5KSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYodGhpcy5saS5pc1Byb3BlcigpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMubGkscCx2KXx8dGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbih0aGlzLmxpLG0seSkpKXRocm93IG5ldyBsKFwiZm91bmQgbm9uLW5vZGVkIGludGVyc2VjdGlvbiBhdCBcIitwK1wiLVwiK3YrXCIgYW5kIFwiK20rXCItXCIreSl9fSxjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7dGhpcy5jaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKSx0aGlzLmNoZWNrQ29sbGFwc2VzKCl9LGNoZWNrQ29sbGFwc2VzOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PXRoaXMuc2VnU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7dGhpcy5jaGVja0NvbGxhcHNlcyhlKX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgbj1hcmd1bWVudHNbMF0saT1uLmdldENvb3JkaW5hdGVzKCksdD0wO3Q8aS5sZW5ndGgtMjt0KyspdGhpcy5jaGVja0NvbGxhcHNlKGlbdF0saVt0KzFdLGlbdCsyXSl9LGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7aSsrKXt2YXIgcj10LmdldEludGVyc2VjdGlvbihpKTtpZighci5lcXVhbHMoZSkmJiFyLmVxdWFscyhuKSlyZXR1cm4hMH1yZXR1cm4hMX0sY2hlY2tDb2xsYXBzZTpmdW5jdGlvbih0LGUsbil7aWYodC5lcXVhbHMobikpdGhyb3cgbmV3IGwoXCJmb3VuZCBub24tbm9kZWQgY29sbGFwc2UgYXQgXCIrSmkuZmFjdC5jcmVhdGVMaW5lU3RyaW5nKFt0LGUsbl0pKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSml9fSksSmkuZmFjdD1uZXcgaWUsZSgkaS5wcm90b3R5cGUse2ludGVyc2VjdHNTY2FsZWQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLm1pbih0LngsZS54KSxpPU1hdGgubWF4KHQueCxlLngpLHI9TWF0aC5taW4odC55LGUueSkscz1NYXRoLm1heCh0LnksZS55KSxvPXRoaXMubWF4eDxufHx0aGlzLm1pbng+aXx8dGhpcy5tYXh5PHJ8fHRoaXMubWlueT5zO2lmKG8pcmV0dXJuITE7dmFyIGE9dGhpcy5pbnRlcnNlY3RzVG9sZXJhbmNlU3F1YXJlKHQsZSk7cmV0dXJuIGYuaXNUcnVlKCEobyYmYSksXCJGb3VuZCBiYWQgZW52ZWxvcGUgdGVzdFwiKSxhfSxpbml0Q29ybmVyczpmdW5jdGlvbih0KXt2YXIgZT0uNTt0aGlzLm1pbng9dC54LWUsdGhpcy5tYXh4PXQueCtlLHRoaXMubWlueT10LnktZSx0aGlzLm1heHk9dC55K2UsdGhpcy5jb3JuZXJbMF09bmV3IGcodGhpcy5tYXh4LHRoaXMubWF4eSksdGhpcy5jb3JuZXJbMV09bmV3IGcodGhpcy5taW54LHRoaXMubWF4eSksdGhpcy5jb3JuZXJbMl09bmV3IGcodGhpcy5taW54LHRoaXMubWlueSksdGhpcy5jb3JuZXJbM109bmV3IGcodGhpcy5tYXh4LHRoaXMubWlueSl9LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gMT09PXRoaXMuc2NhbGVGYWN0b3I/dGhpcy5pbnRlcnNlY3RzU2NhbGVkKHQsZSk6KHRoaXMuY29weVNjYWxlZCh0LHRoaXMucDBTY2FsZWQpLHRoaXMuY29weVNjYWxlZChlLHRoaXMucDFTY2FsZWQpLHRoaXMuaW50ZXJzZWN0c1NjYWxlZCh0aGlzLnAwU2NhbGVkLHRoaXMucDFTY2FsZWQpKX0sc2NhbGU6ZnVuY3Rpb24odCl7cmV0dXJuIE1hdGgucm91bmQodCp0aGlzLnNjYWxlRmFjdG9yKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWdpbmFsUHR9LGNvcHlTY2FsZWQ6ZnVuY3Rpb24odCxlKXtlLng9dGhpcy5zY2FsZSh0LngpLGUueT10aGlzLnNjYWxlKHQueSl9LGdldFNhZmVFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnNhZmVFbnYpe3ZhciB0PSRpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1IvdGhpcy5zY2FsZUZhY3Rvcjt0aGlzLnNhZmVFbnY9bmV3IEModGhpcy5vcmlnaW5hbFB0LngtdCx0aGlzLm9yaWdpbmFsUHQueCt0LHRoaXMub3JpZ2luYWxQdC55LXQsdGhpcy5vcmlnaW5hbFB0LnkrdCl9cmV0dXJuIHRoaXMuc2FmZUVudn0saW50ZXJzZWN0c1BpeGVsQ2xvc3VyZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzBdLHRoaXMuY29ybmVyWzFdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzFdLHRoaXMuY29ybmVyWzJdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzJdLHRoaXMuY29ybmVyWzNdKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpPyEwOih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzNdLHRoaXMuY29ybmVyWzBdKSwhIXRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkpKSl9LGludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj0hMSxpPSExO3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odCxlLHRoaXMuY29ybmVyWzBdLHRoaXMuY29ybmVyWzFdKSx0aGlzLmxpLmlzUHJvcGVyKCk/ITA6KHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMV0sdGhpcy5jb3JuZXJbMl0pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDoodGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKG49ITApLHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMl0sdGhpcy5jb3JuZXJbM10pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDoodGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKGk9ITApLHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbM10sdGhpcy5jb3JuZXJbMF0pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDpuJiZpPyEwOnQuZXF1YWxzKHRoaXMucHQpPyEwOiEhZS5lcXVhbHModGhpcy5wdCkpKSl9LGFkZFNuYXBwZWROb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRDb29yZGluYXRlKGUpLGk9dC5nZXRDb29yZGluYXRlKGUrMSk7cmV0dXJuIHRoaXMuaW50ZXJzZWN0cyhuLGkpPyh0LmFkZEludGVyc2VjdGlvbih0aGlzLmdldENvb3JkaW5hdGUoKSxlKSwhMCk6ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRpfX0pLCRpLlNBRkVfRU5WX0VYUEFOU0lPTl9GQUNUT1I9Ljc1LGUodHIucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7YXJndW1lbnRzWzBdfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5zZWxlY3RlZFNlZ21lbnQpLHRoaXMuc2VsZWN0KHRoaXMuc2VsZWN0ZWRTZWdtZW50KX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHRyfX0pLGUoZXIucHJvdG90eXBlLHtzbmFwOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zbmFwKHQsbnVsbCwtMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWFyZ3VtZW50c1syXSxyPWUuZ2V0U2FmZUVudmVsb3BlKCkscz1uZXcgbnIoZSxuLGkpO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHIse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sdmlzaXRJdGVtOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7ZS5zZWxlY3QocixzKX19KSxzLmlzTm9kZUFkZGVkKCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBlcn19KSxoKG5yLHRyKSxlKG5yLnByb3RvdHlwZSx7aXNOb2RlQWRkZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNOb2RlQWRkZWR9LHNlbGVjdDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0ci5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj10LmdldENvbnRleHQoKTtyZXR1cm4gbnVsbCE9PXRoaXMucGFyZW50RWRnZSYmbj09PXRoaXMucGFyZW50RWRnZSYmZT09PXRoaXMuaG90UGl4ZWxWZXJ0ZXhJbmRleD9udWxsOnZvaWQodGhpcy5faXNOb2RlQWRkZWQ9dGhpcy5ob3RQaXhlbC5hZGRTbmFwcGVkTm9kZShuLGUpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbnJ9fSksZXIuSG90UGl4ZWxTbmFwQWN0aW9uPW5yLGUoaXIucHJvdG90eXBlLHtwcm9jZXNzSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmZT09PWkpcmV0dXJuIG51bGw7dmFyIHI9dC5nZXRDb29yZGluYXRlcygpW2VdLHM9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbaV0sYT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTtpZih0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixzLG8sYSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCkpe2Zvcih2YXIgdT0wO3U8dGhpcy5saS5nZXRJbnRlcnNlY3Rpb25OdW0oKTt1KyspdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnMuYWRkKHRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKHUpKTt0LmFkZEludGVyc2VjdGlvbnModGhpcy5saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGksMSl9fSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb25zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlyfX0pLGUocnIucHJvdG90eXBlLHtjaGVja0NvcnJlY3RuZXNzOmZ1bmN0aW9uKHQpe3ZhciBlPUtlLmdldE5vZGVkU3Vic3RyaW5ncyh0KSxuPW5ldyBKaShlKTt0cnl7bi5jaGVja1ZhbGlkKCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdDt0LnByaW50U3RhY2tUcmFjZSgpfWZpbmFsbHl7fX0sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLm5vZGVkU2VnU3RyaW5ncyl9LHNuYXBSb3VuZDpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZmluZEludGVyaW9ySW50ZXJzZWN0aW9ucyh0LGUpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvblNuYXBzKG4pLHRoaXMuY29tcHV0ZVZlcnRleFNuYXBzKHQpfSxmaW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGlyKGUpO3JldHVybiB0aGlzLm5vZGVyLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuKSx0aGlzLm5vZGVyLmNvbXB1dGVOb2Rlcyh0KSxuLmdldEludGVyaW9ySW50ZXJzZWN0aW9ucygpfSxjb21wdXRlVmVydGV4U25hcHM6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5jb21wdXRlVmVydGV4U25hcHMobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEtlKWZvcih2YXIgaT1hcmd1bWVudHNbMF0scj1pLmdldENvb3JkaW5hdGVzKCkscz0wO3M8ci5sZW5ndGg7cysrKXt2YXIgbz1uZXcgJGkocltzXSx0aGlzLnNjYWxlRmFjdG9yLHRoaXMubGkpLGE9dGhpcy5wb2ludFNuYXBwZXIuc25hcChvLGkscyk7YSYmaS5hZGRJbnRlcnNlY3Rpb24ocltzXSxzKX19LGNvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt0aGlzLm5vZGVkU2VnU3RyaW5ncz10LHRoaXMubm9kZXI9bmV3IG5uLHRoaXMucG9pbnRTbmFwcGVyPW5ldyBlcih0aGlzLm5vZGVyLmdldEluZGV4KCkpLHRoaXMuc25hcFJvdW5kKHQsdGhpcy5saSl9LGNvbXB1dGVJbnRlcnNlY3Rpb25TbmFwczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uZXcgJGkobix0aGlzLnNjYWxlRmFjdG9yLHRoaXMubGkpO3RoaXMucG9pbnRTbmFwcGVyLnNuYXAoaSl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJyfX0pLGUoc3IucHJvdG90eXBlLHtidWZmZXJGaXhlZFByZWNpc2lvbjpmdW5jdGlvbih0KXt2YXIgZT1uZXcgRmkobmV3IHJyKG5ldyBlZSgxKSksdC5nZXRTY2FsZSgpKSxuPW5ldyBRaSh0aGlzLmJ1ZlBhcmFtcyk7bi5zZXRXb3JraW5nUHJlY2lzaW9uTW9kZWwodCksbi5zZXROb2RlcihlKSx0aGlzLnJlc3VsdEdlb21ldHJ5PW4uYnVmZmVyKHRoaXMuYXJnR2VvbSx0aGlzLmRpc3RhbmNlKX0sYnVmZmVyUmVkdWNlZFByZWNpc2lvbjpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9c3IuTUFYX1BSRUNJU0lPTl9ESUdJVFM7dD49MDt0LS0pe3RyeXt0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24odCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2Ygc24pKXRocm93IHQ7dGhpcy5zYXZlRXhjZXB0aW9uPXR9ZmluYWxseXt9aWYobnVsbCE9PXRoaXMucmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGx9dGhyb3cgdGhpcy5zYXZlRXhjZXB0aW9ufWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1zci5wcmVjaXNpb25TY2FsZUZhY3Rvcih0aGlzLmFyZ0dlb20sdGhpcy5kaXN0YW5jZSxlKSxpPW5ldyBlZShuKTt0aGlzLmJ1ZmZlckZpeGVkUHJlY2lzaW9uKGkpfX0sY29tcHV0ZUdlb21ldHJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5idWZmZXJPcmlnaW5hbFByZWNpc2lvbigpLG51bGwhPT10aGlzLnJlc3VsdEdlb21ldHJ5KXJldHVybiBudWxsO3ZhciB0PXRoaXMuYXJnR2VvbS5nZXRGYWN0b3J5KCkuZ2V0UHJlY2lzaW9uTW9kZWwoKTt0LmdldFR5cGUoKT09PWVlLkZJWEVEP3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24odCk6dGhpcy5idWZmZXJSZWR1Y2VkUHJlY2lzaW9uKCl9LHNldFF1YWRyYW50U2VnbWVudHM6ZnVuY3Rpb24odCl7dGhpcy5idWZQYXJhbXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX0sYnVmZmVyT3JpZ2luYWxQcmVjaXNpb246ZnVuY3Rpb24oKXt0cnl7dmFyIHQ9bmV3IFFpKHRoaXMuYnVmUGFyYW1zKTt0aGlzLnJlc3VsdEdlb21ldHJ5PXQuYnVmZmVyKHRoaXMuYXJnR2VvbSx0aGlzLmRpc3RhbmNlKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBsKSl0aHJvdyB0O3RoaXMuc2F2ZUV4Y2VwdGlvbj10fWZpbmFsbHl7fX0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGlzdGFuY2U9dCx0aGlzLmNvbXB1dGVHZW9tZXRyeSgpLHRoaXMucmVzdWx0R2VvbWV0cnl9LHNldEVuZENhcFN0eWxlOmZ1bmN0aW9uKHQpe3RoaXMuYnVmUGFyYW1zLnNldEVuZENhcFN0eWxlKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzcn19KSxzci5idWZmZXJPcD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgc3IodCksaT1uLmdldFJlc3VsdEdlb21ldHJ5KGUpO3JldHVybiBpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1syXSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9bmV3IHNyKHIpO2Euc2V0UXVhZHJhbnRTZWdtZW50cyhvKTt2YXIgaT1hLmdldFJlc3VsdEdlb21ldHJ5KHMpO3JldHVybiBpfWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQmkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIHU9YXJndW1lbnRzWzBdLGw9YXJndW1lbnRzWzFdLGg9YXJndW1lbnRzWzJdLGE9bmV3IHNyKHUsaCksaT1hLmdldFJlc3VsdEdlb21ldHJ5KGwpO3JldHVybiBpfX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZz1hcmd1bWVudHNbMl0sZD1hcmd1bWVudHNbM10sYT1uZXcgc3IoYyk7YS5zZXRRdWFkcmFudFNlZ21lbnRzKGcpLGEuc2V0RW5kQ2FwU3R5bGUoZCk7dmFyIGk9YS5nZXRSZXN1bHRHZW9tZXRyeShmKTtyZXR1cm4gaX19LHNyLnByZWNpc2lvblNjYWxlRmFjdG9yPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPVQubWF4KE1hdGguYWJzKGkuZ2V0TWF4WCgpKSxNYXRoLmFicyhpLmdldE1heFkoKSksTWF0aC5hYnMoaS5nZXRNaW5YKCkpLE1hdGguYWJzKGkuZ2V0TWluWSgpKSkscz1lPjA/ZTowLG89cisyKnMsYT1NYXRoLnRydW5jKE1hdGgubG9nKG8pL01hdGgubG9nKDEwKSsxKSx1PW4tYSxsPU1hdGgucG93KDEwLHUpO3JldHVybiBsfSxzci5DQVBfUk9VTkQ9QmkuQ0FQX1JPVU5ELHNyLkNBUF9CVVRUPUJpLkNBUF9GTEFULHNyLkNBUF9GTEFUPUJpLkNBUF9GTEFULHNyLkNBUF9TUVVBUkU9QmkuQ0FQX1NRVUFSRSxzci5NQVhfUFJFQ0lTSU9OX0RJR0lUUz0xMjt2YXIgQ289T2JqZWN0LmZyZWV6ZSh7QnVmZmVyT3A6c3IsQnVmZmVyUGFyYW1ldGVyczpCaX0pO2Uob3IucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFR0JiZ0aGlzLmNvbXBzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvcn19KSxvci5nZXRQb2x5Z29ucz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG9yLmdldFBvbHlnb25zKHQsbmV3IEkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIGUgaW5zdGFuY2VvZiBUdD9uLmFkZChlKTplIGluc3RhbmNlb2YgZnQmJmUuYXBwbHkobmV3IG9yKG4pKSxufX0sZShhci5wcm90b3R5cGUse2lzSW5zaWRlQXJlYTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ0luZGV4PT09YXIuSU5TSURFX0FSRUF9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0sZ2V0R2VvbWV0cnlDb21wb25lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wb25lbnR9LGdldFNlZ21lbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ0luZGV4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhcn19KSxhci5JTlNJREVfQVJFQT0tMSxlKHVyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBMdCYmdGhpcy5wdHMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVyfX0pLHVyLmdldFBvaW50cz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHQgaW5zdGFuY2VvZiBMdD9oby5zaW5nbGV0b25MaXN0KHQpOnVyLmdldFBvaW50cyh0LG5ldyBJKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlIGluc3RhbmNlb2YgTHQ/bi5hZGQoZSk6ZSBpbnN0YW5jZW9mIGZ0JiZlLmFwcGx5KG5ldyB1cihuKSksbn19LGUobHIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7KHQgaW5zdGFuY2VvZiBMdHx8dCBpbnN0YW5jZW9mIFN0fHx0IGluc3RhbmNlb2YgVHQpJiZ0aGlzLmxvY2F0aW9ucy5hZGQobmV3IGFyKHQsMCx0LmdldENvb3JkaW5hdGUoKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxyfX0pLGxyLmdldExvY2F0aW9ucz1mdW5jdGlvbih0KXt2YXIgZT1uZXcgSTtyZXR1cm4gdC5hcHBseShuZXcgbHIoZSkpLGV9LGUoaHIucHJvdG90eXBlLHtjb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDAsdCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9MS1lLHI9b3IuZ2V0UG9seWdvbnModGhpcy5nZW9tW2VdKTtpZihyLnNpemUoKT4wKXt2YXIgcz1sci5nZXRMb2NhdGlvbnModGhpcy5nZW9tW2ldKTtpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKHMscixuKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiB0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25baV09blswXSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bZV09blsxXSxudWxsfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJlIoYXJndW1lbnRzWzBdLHkpJiZSKGFyZ3VtZW50c1sxXSx5KSl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXSxsPTA7bDxvLnNpemUoKTtsKyspZm9yKHZhciBoPW8uZ2V0KGwpLGM9MDtjPGEuc2l6ZSgpO2MrKylpZih0aGlzLmNvbXB1dGVDb250YWlubWVudERpc3RhbmNlKGgsYS5nZXQoYyksdSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgYXImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgVHQpe3ZhciBmPWFyZ3VtZW50c1swXSxnPWFyZ3VtZW50c1sxXSxkPWFyZ3VtZW50c1syXSxwPWYuZ2V0Q29vcmRpbmF0ZSgpO2lmKEwuRVhURVJJT1IhPT10aGlzLnB0TG9jYXRvci5sb2NhdGUocCxnKSlyZXR1cm4gdGhpcy5taW5EaXN0YW5jZT0wLGRbMF09ZixkWzFdPW5ldyBhcihnLHApLG51bGx9fSxjb21wdXRlTWluRGlzdGFuY2VMaW5lc1BvaW50czpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UocixvLG4pLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxjb21wdXRlRmFjZXREaXN0YW5jZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGU9a24uZ2V0TGluZXModGhpcy5nZW9tWzBdKSxuPWtuLmdldExpbmVzKHRoaXMuZ2VvbVsxXSksaT11ci5nZXRQb2ludHModGhpcy5nZW9tWzBdKSxyPXVyLmdldFBvaW50cyh0aGlzLmdlb21bMV0pO3JldHVybiB0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzKGUsbix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKGUscix0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzKG4saSx0KSx0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITApLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2U/bnVsbDoodFswXT1udWxsLHRbMV09bnVsbCx0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZVBvaW50cyhpLHIsdCksdm9pZCB0aGlzLnVwZGF0ZU1pbkRpc3RhbmNlKHQsITEpKSkpfSxuZWFyZXN0TG9jYXRpb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9ufSx1cGRhdGVNaW5EaXN0YW5jZTpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dFswXT9udWxsOnZvaWQoZT8odGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdPXRbMV0sdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzFdPXRbMF0pOih0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMF09dFswXSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMV09dFsxXSkpfSxuZWFyZXN0UG9pbnRzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKTt2YXIgdD1bdGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uWzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMV0uZ2V0Q29vcmRpbmF0ZSgpXTtyZXR1cm4gdH0sY29tcHV0ZU1pbkRpc3RhbmNlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKG51bGwhPT10aGlzLm1pbkRpc3RhbmNlTG9jYXRpb24pcmV0dXJuIG51bGw7aWYodGhpcy5taW5EaXN0YW5jZUxvY2F0aW9uPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUZhY2V0RGlzdGFuY2UoKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQXJyYXkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk+dGhpcy5taW5EaXN0YW5jZSlyZXR1cm4gbnVsbDtmb3IodmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRDb29yZGluYXRlKCkscz0wO3M8aS5sZW5ndGgtMTtzKyspe3ZhciBvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHIsaVtzXSxpW3MrMV0pO2lmKG88dGhpcy5taW5EaXN0YW5jZSl7dGhpcy5taW5EaXN0YW5jZT1vO3ZhciBhPW5ldyBjZShpW3NdLGlbcysxXSksdT1hLmNsb3Nlc3RQb2ludChyKTtuWzBdPW5ldyBhcih0LHMsdSksblsxXT1uZXcgYXIoZSwwLHIpfWlmKHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBTdCl7dmFyIGw9YXJndW1lbnRzWzBdLGg9YXJndW1lbnRzWzFdLGM9YXJndW1lbnRzWzJdO2lmKGwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGguZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLm1pbkRpc3RhbmNlKXJldHVybiBudWxsO2Zvcih2YXIgaT1sLmdldENvb3JkaW5hdGVzKCksZj1oLmdldENvb3JkaW5hdGVzKCkscz0wO3M8aS5sZW5ndGgtMTtzKyspZm9yKHZhciBnPTA7ZzxmLmxlbmd0aC0xO2crKyl7dmFyIG89aGUuZGlzdGFuY2VMaW5lTGluZShpW3NdLGlbcysxXSxmW2ddLGZbZysxXSk7aWYobzx0aGlzLm1pbkRpc3RhbmNlKXt0aGlzLm1pbkRpc3RhbmNlPW87dmFyIGQ9bmV3IGNlKGlbc10saVtzKzFdKSxwPW5ldyBjZShmW2ddLGZbZysxXSksdj1kLmNsb3Nlc3RQb2ludHMocCk7Y1swXT1uZXcgYXIobCxzLHZbMF0pLGNbMV09bmV3IGFyKGgsZyx2WzFdKX1pZih0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX19LGNvbXB1dGVNaW5EaXN0YW5jZVBvaW50czpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyksYT1yLmdldENvb3JkaW5hdGUoKS5kaXN0YW5jZShvLmdldENvb3JkaW5hdGUoKSk7aWYoYTx0aGlzLm1pbkRpc3RhbmNlJiYodGhpcy5taW5EaXN0YW5jZT1hLG5bMF09bmV3IGFyKHIsMCxyLmdldENvb3JkaW5hdGUoKSksblsxXT1uZXcgYXIobywwLG8uZ2V0Q29vcmRpbmF0ZSgpKSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19LGRpc3RhbmNlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2VvbVswXXx8bnVsbD09PXRoaXMuZ2VvbVsxXSl0aHJvdyBuZXcgaShcIm51bGwgZ2VvbWV0cmllcyBhcmUgbm90IHN1cHBvcnRlZFwiKTtyZXR1cm4gdGhpcy5nZW9tWzBdLmlzRW1wdHkoKXx8dGhpcy5nZW9tWzFdLmlzRW1wdHkoKT8wOih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2UpfSxjb21wdXRlTWluRGlzdGFuY2VMaW5lczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LnNpemUoKTtpKyspZm9yKHZhciByPXQuZ2V0KGkpLHM9MDtzPGUuc2l6ZSgpO3MrKyl7dmFyIG89ZS5nZXQocyk7aWYodGhpcy5jb21wdXRlTWluRGlzdGFuY2UocixvLG4pLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBocn19KSxoci5kaXN0YW5jZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBocih0LGUpO3JldHVybiBuLmRpc3RhbmNlKCl9LGhyLmlzV2l0aGluRGlzdGFuY2U9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBocih0LGUsbik7cmV0dXJuIGkuZGlzdGFuY2UoKTw9bn0saHIubmVhcmVzdFBvaW50cz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBocih0LGUpO3JldHVybiBuLm5lYXJlc3RQb2ludHMoKX07dmFyIFNvPU9iamVjdC5mcmVlemUoe0Rpc3RhbmNlT3A6aHJ9KTtlKGNyLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5jb29yZGluYXRlcyl7Zm9yKHZhciB0PTAsZT0wLG49bmV3IE4saT10aGlzLmRpcmVjdGVkRWRnZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuZ2V0RWRnZURpcmVjdGlvbigpP3QrKzplKyssbi5hZGQoci5nZXRFZGdlKCkuZ2V0TGluZSgpLmdldENvb3JkaW5hdGVzKCksITEsci5nZXRFZGdlRGlyZWN0aW9uKCkpfXRoaXMuY29vcmRpbmF0ZXM9bi50b0Nvb3JkaW5hdGVBcnJheSgpLGU+dCYmSC5yZXZlcnNlKHRoaXMuY29vcmRpbmF0ZXMpfXJldHVybiB0aGlzLmNvb3JkaW5hdGVzfSx0b0xpbmVTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5nZXRDb29yZGluYXRlcygpKX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZGlyZWN0ZWRFZGdlcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNyfX0pLGUoZnIucHJvdG90eXBlLHtzZXRWaXNpdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzVmlzaXRlZD10fSxpc01hcmtlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc01hcmtlZH0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHNldE1hcmtlZDpmdW5jdGlvbih0KXt0aGlzLl9pc01hcmtlZD10fSxnZXRDb250ZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0saXNWaXNpdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzVmlzaXRlZH0sc2V0Q29udGV4dDpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnJ9fSksZnIuZ2V0Q29tcG9uZW50V2l0aFZpc2l0ZWRTdGF0ZT1mdW5jdGlvbih0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt2YXIgbj10Lm5leHQoKTtpZihuLmlzVmlzaXRlZCgpPT09ZSlyZXR1cm4gbn1yZXR1cm4gbnVsbH0sZnIuc2V0VmlzaXRlZD1mdW5jdGlvbih0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt2YXIgbj10Lm5leHQoKTtuLnNldFZpc2l0ZWQoZSl9fSxmci5zZXRNYXJrZWQ9ZnVuY3Rpb24odCxlKXtmb3IoO3QuaGFzTmV4dCgpOyl7dmFyIG49dC5uZXh0KCk7bi5zZXRNYXJrZWQoZSl9fSxoKGdyLGZyKSxlKGdyLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnBhcmVudEVkZ2V9LGNvbXBhcmVEaXJlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucXVhZHJhbnQ+dC5xdWFkcmFudD8xOnRoaXMucXVhZHJhbnQ8dC5xdWFkcmFudD8tMTpoZS5jb21wdXRlT3JpZW50YXRpb24odC5wMCx0LnAxLHRoaXMucDEpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZnJvbS5nZXRDb29yZGluYXRlKCl9LHByaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxpPWUuc3Vic3RyaW5nKG4rMSk7dC5wcmludChcIiAgXCIraStcIjogXCIrdGhpcy5wMCtcIiAtIFwiK3RoaXMucDErXCIgXCIrdGhpcy5xdWFkcmFudCtcIjpcIit0aGlzLmFuZ2xlKX0sZ2V0RGlyZWN0aW9uUHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMX0sZ2V0QW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hbmdsZX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZURpcmVjdGlvbihlKX0sZ2V0RnJvbU5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mcm9tfSxnZXRTeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW19LHNldEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5wYXJlbnRFZGdlPXR9LHJlbW92ZTpmdW5jdGlvbigpe3RoaXMuc3ltPW51bGwsdGhpcy5wYXJlbnRFZGdlPW51bGx9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRFZGdlfSxnZXRRdWFkcmFudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnF1YWRyYW50fSxzZXRTeW06ZnVuY3Rpb24odCl7dGhpcy5zeW09dH0sZ2V0VG9Ob2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG99LGdldEVkZ2VEaXJlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRGlyZWN0aW9ufSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3J9fSksZ3IudG9FZGdlcz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUuYWRkKG4ubmV4dCgpLnBhcmVudEVkZ2UpO3JldHVybiBlfSxoKGRyLGdyKSxlKGRyLnByb3RvdHlwZSx7Z2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiAyIT09dGhpcy5nZXRUb05vZGUoKS5nZXREZWdyZWUoKT9udWxsOnRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKT09PXRoaXMuZ2V0U3ltKCk/dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDEpOihmLmlzVHJ1ZSh0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk9PT10aGlzLmdldFN5bSgpKSx0aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkcn19KSxoKHByLGZyKSxlKHByLnByb3RvdHlwZSx7aXNSZW1vdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmRpckVkZ2V9LHNldERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24odCxlKXt0aGlzLmRpckVkZ2U9W3QsZV0sdC5zZXRFZGdlKHRoaXMpLGUuc2V0RWRnZSh0aGlzKSx0LnNldFN5bShlKSxlLnNldFN5bSh0KSx0LmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZSh0KSxlLmdldEZyb21Ob2RlKCkuYWRkT3V0RWRnZShlKX0sZ2V0RGlyRWRnZTpmdW5jdGlvbigpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbdF19aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcil7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRpckVkZ2VbMF0uZ2V0RnJvbU5vZGUoKT09PWU/dGhpcy5kaXJFZGdlWzBdOnRoaXMuZGlyRWRnZVsxXS5nZXRGcm9tTm9kZSgpPT09ZT90aGlzLmRpckVkZ2VbMV06bnVsbH19LHJlbW92ZTpmdW5jdGlvbigpe3RoaXMuZGlyRWRnZT1udWxsfSxnZXRPcHBvc2l0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09dD90aGlzLmRpckVkZ2VbMF0uZ2V0VG9Ob2RlKCk6dGhpcy5kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuZGlyRWRnZVsxXS5nZXRUb05vZGUoKTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwcn19KSxlKHZyLnByb3RvdHlwZSx7Z2V0TmV4dEVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlKzEpKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuaXRlcmF0b3IoKTtpZighdC5oYXNOZXh0KCkpcmV0dXJuIG51bGw7dmFyIGU9dC5uZXh0KCk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZSgpfSxpdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXMuaXRlcmF0b3IoKX0sc29ydEVkZ2VzOmZ1bmN0aW9uKCl7dGhpcy5zb3J0ZWR8fChoby5zb3J0KHRoaXMub3V0RWRnZXMpLHRoaXMuc29ydGVkPSEwKX0scmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMucmVtb3ZlKHQpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNvcnRFZGdlcygpLHRoaXMub3V0RWRnZXN9LGdldE5leHRDV0VkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRJbmRleCh0KTtyZXR1cm4gdGhpcy5vdXRFZGdlcy5nZXQodGhpcy5nZXRJbmRleChlLTEpKX0sZ2V0SW5kZXg6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHByKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zb3J0RWRnZXMoKTtmb3IodmFyIGU9MDtlPHRoaXMub3V0RWRnZXMuc2l6ZSgpO2UrKyl7dmFyIG49dGhpcy5vdXRFZGdlcy5nZXQoZSk7aWYobi5nZXRFZGdlKCk9PT10KXJldHVybiBlfXJldHVybi0xfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Ipe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2Zvcih2YXIgZT0wO2U8dGhpcy5vdXRFZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLm91dEVkZ2VzLmdldChlKTtpZihuPT09aSlyZXR1cm4gZX1yZXR1cm4tMX1pZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciByPWFyZ3VtZW50c1swXSxzPXIldGhpcy5vdXRFZGdlcy5zaXplKCk7cmV0dXJuIDA+cyYmKHMrPXRoaXMub3V0RWRnZXMuc2l6ZSgpKSxzfX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMub3V0RWRnZXMuYWRkKHQpLHRoaXMuc29ydGVkPSExfSxnZXREZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vdXRFZGdlcy5zaXplKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZyfX0pLGgobXIsZnIpLGUobXIucHJvdG90eXBlLHtpc1JlbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucHR9LGFkZE91dEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5kZVN0YXIuYWRkKHQpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGdldE91dEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLnB0PW51bGw7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZGVTdGFyLnJlbW92ZSh0KX19LGdldEluZGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlU3Rhci5nZXRJbmRleCh0KX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVTdGFyLmdldERlZ3JlZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtcn19KSxtci5nZXRFZGdlc0JldHdlZW49ZnVuY3Rpb24odCxlKXt2YXIgbj1nci50b0VkZ2VzKHQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKSxpPW5ldyBKKG4pLHI9Z3IudG9FZGdlcyhlLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSk7cmV0dXJuIGkucmV0YWluQWxsKHIpLGl9LGgoeXIscHIpLGUoeXIucHJvdG90eXBlLHtnZXRMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGluZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geXJ9fSksZSh4ci5wcm90b3R5cGUse2ZpbmQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5nZXQodCl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5yZW1vdmUodCl9LHZhbHVlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGFkZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLnB1dCh0LmdldENvb3JkaW5hdGUoKSx0KSx0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4cn19KSxlKEVyLnByb3RvdHlwZSx7ZmluZE5vZGVzT2ZEZWdyZWU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5ub2RlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuZ2V0RGVncmVlKCk9PT10JiZlLmFkZChpKX1yZXR1cm4gZX0sZGlyRWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKX0sZWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwcil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVtb3ZlKHQuZ2V0RGlyRWRnZSgwKSksdGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDEpKSx0aGlzLmVkZ2VzLnJlbW92ZSh0KSx0LnJlbW92ZSgpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBncil7dmFyIGU9YXJndW1lbnRzWzBdLG49ZS5nZXRTeW0oKTtudWxsIT09biYmbi5zZXRTeW0obnVsbCksZS5nZXRGcm9tTm9kZSgpLnJlbW92ZShlKSxlLnJlbW92ZSgpLHRoaXMuZGlyRWRnZXMucmVtb3ZlKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBtcil7Zm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLHM9ci5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksbj1vLmdldFN5bSgpO251bGwhPT1uJiZ0aGlzLnJlbW92ZShuKSx0aGlzLmRpckVkZ2VzLnJlbW92ZShvKTt2YXIgYT1vLmdldEVkZ2UoKTtudWxsIT09YSYmdGhpcy5lZGdlcy5yZW1vdmUoYSl9dGhpcy5ub2RlTWFwLnJlbW92ZShpLmdldENvb3JkaW5hdGUoKSksaS5yZW1vdmUoKX19LGZpbmROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAuZmluZCh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sbm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC5pdGVyYXRvcigpfSxjb250YWluczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5lZGdlcy5jb250YWlucyh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGlyRWRnZXMuY29udGFpbnMoZSl9fSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1yKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlTWFwLmFkZCh0KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmVkZ2VzLmFkZChlKSx0aGlzLmFkZChlLmdldERpckVkZ2UoMCkpLHRoaXMuYWRkKGUuZ2V0RGlyRWRnZSgxKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5kaXJFZGdlcy5hZGQobil9fSxnZXROb2RlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVNYXAudmFsdWVzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVyfX0pLGgoSXIsRXIpLGUoSXIucHJvdG90eXBlLHthZGRFZGdlOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModC5nZXRDb29yZGluYXRlcygpKTtpZihlLmxlbmd0aDw9MSlyZXR1cm4gbnVsbDt2YXIgbj1lWzBdLGk9ZVtlLmxlbmd0aC0xXSxyPXRoaXMuZ2V0Tm9kZShuKSxzPXRoaXMuZ2V0Tm9kZShpKSxvPW5ldyBkcihyLHMsZVsxXSwhMCksYT1uZXcgZHIocyxyLGVbZS5sZW5ndGgtMl0sITEpLHU9bmV3IHlyKHQpO3Uuc2V0RGlyZWN0ZWRFZGdlcyhvLGEpLHRoaXMuYWRkKHUpfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgbXIodCksdGhpcy5hZGQoZSkpLGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElyfX0pLGUoTnIucHJvdG90eXBlLHtidWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuaXNNYXJrZWQoKXx8KGYuaXNUcnVlKDI9PT1lLmdldERlZ3JlZSgpKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yTm9uRGVncmVlMk5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7MiE9PWUuZ2V0RGVncmVlKCkmJih0aGlzLmJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0KGUpLGUuc2V0TWFya2VkKCEwKSl9fSxidWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXM6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXMoKX0sZ2V0TWVyZ2VkTGluZVN0cmluZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tZXJnZSgpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3N9LGJ1aWxkRWRnZVN0cmluZ3NTdGFydGluZ0F0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZSgpLmlzTWFya2VkKCl8fHRoaXMuZWRnZVN0cmluZ3MuYWRkKHRoaXMuYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoKG4pKX19LG1lcmdlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMubWVyZ2VkTGluZVN0cmluZ3MpcmV0dXJuIG51bGw7ZnIuc2V0TWFya2VkKHRoaXMuZ3JhcGgubm9kZUl0ZXJhdG9yKCksITEpLGZyLnNldE1hcmtlZCh0aGlzLmdyYXBoLmVkZ2VJdGVyYXRvcigpLCExKSx0aGlzLmVkZ2VTdHJpbmdzPW5ldyBJLHRoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck9idmlvdXNTdGFydE5vZGVzKCksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9ySXNvbGF0ZWRMb29wcygpLHRoaXMubWVyZ2VkTGluZVN0cmluZ3M9bmV3IEk7Zm9yKHZhciB0PXRoaXMuZWRnZVN0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO3RoaXMubWVyZ2VkTGluZVN0cmluZ3MuYWRkKGUudG9MaW5lU3RyaW5nKCkpfX0sYnVpbGRFZGdlU3RyaW5nU3RhcnRpbmdXaXRoOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBjcih0aGlzLmZhY3RvcnkpLG49dDtkbyBlLmFkZChuKSxuLmdldEVkZ2UoKS5zZXRNYXJrZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobnVsbCE9PW4mJm4hPT10KTtyZXR1cm4gZX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dC5hcHBseSh7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlZExpbmVTdHJpbmdzPW51bGw7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe1xudmFyIGk9bi5uZXh0KCk7dGhpcy5hZGQoaSl9fWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHI9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9ci5nZXRGYWN0b3J5KCkpLHRoaXMuZ3JhcGguYWRkRWRnZShyKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yVW5wcm9jZXNzZWROb2RlcygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOcn19KTt2YXIgd289T2JqZWN0LmZyZWV6ZSh7TGluZU1lcmdlcjpOcn0pLExvPU9iamVjdC5mcmVlemUoe092ZXJsYXlPcDppaX0pO2goQ3IsZ3IpLGUoQ3IucHJvdG90eXBlLHtnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0saXNJblJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZWRnZVJpbmd9LHNldFJpbmc6ZnVuY3Rpb24odCl7dGhpcy5lZGdlUmluZz10fSxzZXRMYWJlbDpmdW5jdGlvbih0KXt0aGlzLmxhYmVsPXR9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5uZXh0PXR9LGdldFJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlUmluZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ3J9fSksaChTcixwciksZShTci5wcm90b3R5cGUse2dldExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTcn19KSxlKHdyLnByb3RvdHlwZSx7aXNJbmNsdWRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLnJpbmdQdHMpe2Zvcih2YXIgdD1uZXcgTixlPXRoaXMuZGVMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpO3dyLmFkZEVkZ2UoaS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuLmdldEVkZ2VEaXJlY3Rpb24oKSx0KX10aGlzLnJpbmdQdHM9dC50b0Nvb3JkaW5hdGVBcnJheSgpfXJldHVybiB0aGlzLnJpbmdQdHN9LGlzSW5jbHVkZWRTZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJbmNsdWRlZFNldH0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5yaW5nUHRzLmxlbmd0aDw9Mz8hMToodGhpcy5nZXRSaW5nKCksdGhpcy5yaW5nLmlzVmFsaWQoKSl9LGJ1aWxkOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7ZG8gdGhpcy5hZGQoZSksZS5zZXRSaW5nKHRoaXMpLGU9ZS5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PWUsXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUoZT09PXR8fCFlLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIik7d2hpbGUoZSE9PXQpfSxpc091dGVySG9sZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0hvbGU/IXRoaXMuaGFzU2hlbGwoKTohMX0sZ2V0UG9seWdvbjpmdW5jdGlvbigpe3ZhciB0PW51bGw7aWYobnVsbCE9PXRoaXMuaG9sZXMpe3Q9bmV3IEFycmF5KHRoaXMuaG9sZXMuc2l6ZSgpKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dGhpcy5ob2xlcy5zaXplKCk7ZSsrKXRbZV09dGhpcy5ob2xlcy5nZXQoZSl9dmFyIG49dGhpcy5mYWN0b3J5LmNyZWF0ZVBvbHlnb24odGhpcy5yaW5nLHQpO3JldHVybiBufSxpc0hvbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNIb2xlfSxpc1Byb2Nlc3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Byb2Nlc3NlZH0sYWRkSG9sZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciB0PWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5ob2xlcyYmKHRoaXMuaG9sZXM9bmV3IEkpLHRoaXMuaG9sZXMuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB3cil7dmFyIGU9YXJndW1lbnRzWzBdO2Uuc2V0U2hlbGwodGhpcyk7dmFyIG49ZS5nZXRSaW5nKCk7bnVsbD09PXRoaXMuaG9sZXMmJih0aGlzLmhvbGVzPW5ldyBJKSx0aGlzLmhvbGVzLmFkZChuKX19LHNldEluY2x1ZGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzSW5jbHVkZWQ9dCx0aGlzLl9pc0luY2x1ZGVkU2V0PSEwfSxnZXRPdXRlckhvbGU6ZnVuY3Rpb24oKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2Zvcih2YXIgdD0wO3Q8dGhpcy5kZUxpc3Quc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5kZUxpc3QuZ2V0KHQpLG49ZS5nZXRTeW0oKS5nZXRSaW5nKCk7aWYobi5pc091dGVySG9sZSgpKXJldHVybiBufXJldHVybiBudWxsfSxjb21wdXRlSG9sZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2V0UmluZygpO3RoaXMuX2lzSG9sZT1oZS5pc0NDVyh0LmdldENvb3JkaW5hdGVzKCkpfSxoYXNTaGVsbDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5zaGVsbH0saXNPdXRlclNoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmdldE91dGVySG9sZSgpfSxnZXRMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLnJpbmdQdHMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSkpfSxnZXRTaGVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzSG9sZSgpP3RoaXMuc2hlbGw6dGhpc30sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZGVMaXN0LmFkZCh0KX0sZ2V0UmluZzpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnJpbmcpcmV0dXJuIHRoaXMucmluZzt0aGlzLmdldENvb3JkaW5hdGVzKCksdGhpcy5yaW5nUHRzLmxlbmd0aDwzJiZBLm91dC5wcmludGxuKHRoaXMucmluZ1B0cyk7dHJ5e3RoaXMucmluZz10aGlzLmZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0aGlzLnJpbmdQdHMpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIFMpKXRocm93IHQ7QS5vdXQucHJpbnRsbih0aGlzLnJpbmdQdHMpfWZpbmFsbHl7fXJldHVybiB0aGlzLnJpbmd9LHVwZGF0ZUluY2x1ZGVkOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0hvbGUoKSlyZXR1cm4gbnVsbDtmb3IodmFyIHQ9MDt0PHRoaXMuZGVMaXN0LnNpemUoKTt0Kyspe3ZhciBlPXRoaXMuZGVMaXN0LmdldCh0KSxuPWUuZ2V0U3ltKCkuZ2V0UmluZygpLmdldFNoZWxsKCk7aWYobnVsbCE9PW4mJm4uaXNJbmNsdWRlZFNldCgpKXJldHVybiB0aGlzLnNldEluY2x1ZGVkKCFuLmlzSW5jbHVkZWQoKSksbnVsbH19LHNldFNoZWxsOmZ1bmN0aW9uKHQpe3RoaXMuc2hlbGw9dH0sc2V0UHJvY2Vzc2VkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzUHJvY2Vzc2VkPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdyfX0pLHdyLmZpbmREaXJFZGdlc0luUmluZz1mdW5jdGlvbih0KXt2YXIgZT10LG49bmV3IEk7ZG8gbi5hZGQoZSksZT1lLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKTt3aGlsZShlIT09dCk7cmV0dXJuIG59LHdyLmFkZEVkZ2U9ZnVuY3Rpb24odCxlLG4pe2lmKGUpZm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspbi5hZGQodFtpXSwhMSk7ZWxzZSBmb3IodmFyIGk9dC5sZW5ndGgtMTtpPj0wO2ktLSluLmFkZCh0W2ldLCExKX0sd3IuZmluZEVkZ2VSaW5nQ29udGFpbmluZz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldFJpbmcoKSxpPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9bi5nZXRDb29yZGluYXRlTigwKSxzPW51bGwsbz1udWxsLGE9ZS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCksbD11LmdldFJpbmcoKSxoPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFoLmVxdWFscyhpKSYmaC5jb250YWlucyhpKSl7cj1ILnB0Tm90SW5MaXN0KG4uZ2V0Q29vcmRpbmF0ZXMoKSxsLmdldENvb3JkaW5hdGVzKCkpO3ZhciBjPSExO2hlLmlzUG9pbnRJblJpbmcocixsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1zfHxvLmNvbnRhaW5zKGgpKSYmKHM9dSxvPXMuZ2V0UmluZygpLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9fXJldHVybiBzfSxlKExyLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO3JldHVybiBuLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpLmNvbXBhcmVUbyhpLmdldFJpbmcoKS5nZXRFbnZlbG9wZSgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExyfX0pLHdyLkVudmVsb3BlQ29tcGFyYXRvcj1McixoKFJyLEVyKSxlKFJyLnByb3RvdHlwZSx7ZmluZEVkZ2VSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB3cih0aGlzLmZhY3RvcnkpO3JldHVybiBlLmJ1aWxkKHQpLGV9LGNvbXB1dGVEZXB0aFBhcml0eTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcig7Oyl7dmFyIHQ9bnVsbDtpZihudWxsPT09dClyZXR1cm4gbnVsbDt0aGlzLmNvbXB1dGVEZXB0aFBhcml0eSh0KX1lbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19fSxjb21wdXRlTmV4dENXRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlSXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO1JyLmNvbXB1dGVOZXh0Q1dFZGdlcyhlKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPDIpcmV0dXJuIG51bGw7dmFyIG49ZVswXSxpPWVbZS5sZW5ndGgtMV0scj10aGlzLmdldE5vZGUobikscz10aGlzLmdldE5vZGUoaSksbz1uZXcgQ3IocixzLGVbMV0sITApLGE9bmV3IENyKHMscixlW2UubGVuZ3RoLTJdLCExKSx1PW5ldyBTcih0KTt1LnNldERpcmVjdGVkRWRnZXMobyxhKSx0aGlzLmFkZCh1KX0sZGVsZXRlQ3V0RWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLFJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuZGlyRWRnZXMpO2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMuZGlyRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKCFuLmlzTWFya2VkKCkpe3ZhciBpPW4uZ2V0U3ltKCk7aWYobi5nZXRMYWJlbCgpPT09aS5nZXRMYWJlbCgpKXtuLnNldE1hcmtlZCghMCksaS5zZXRNYXJrZWQoITApO3ZhciByPW4uZ2V0RWRnZSgpO3QuYWRkKHIuZ2V0TGluZSgpKX19fXJldHVybiB0fSxnZXRFZGdlUmluZ3M6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVOZXh0Q1dFZGdlcygpLFJyLmxhYmVsKHRoaXMuZGlyRWRnZXMsLTEpO3ZhciB0PVJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzKHRoaXMuZGlyRWRnZXMpO3RoaXMuY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3ModCk7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5kaXJFZGdlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoIWkuaXNNYXJrZWQoKSYmIWkuaXNJblJpbmcoKSl7dmFyIHI9dGhpcy5maW5kRWRnZVJpbmcoaSk7ZS5hZGQocil9fXJldHVybiBlfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZmluZE5vZGUodCk7cmV0dXJuIG51bGw9PT1lJiYoZT1uZXcgbXIodCksdGhpcy5hZGQoZSkpLGV9LGNvbnZlcnRNYXhpbWFsVG9NaW5pbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKSxyPVJyLmZpbmRJbnRlcnNlY3Rpb25Ob2RlcyhuLGkpO2lmKG51bGwhPT1yKWZvcih2YXIgcz1yLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKTtSci5jb21wdXRlTmV4dENDV0VkZ2VzKG8saSl9fX0sZGVsZXRlRGFuZ2xlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmZpbmROb2Rlc09mRGVncmVlKDEpLGU9bmV3IEosbj1uZXcgcGUsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KW4ucHVzaChpLm5leHQoKSk7Zm9yKDshbi5pc0VtcHR5KCk7KXt2YXIgcj1uLnBvcCgpO1JyLmRlbGV0ZUFsbEVkZ2VzKHIpO2Zvcih2YXIgcz1yLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxpPXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciBvPWkubmV4dCgpO28uc2V0TWFya2VkKCEwKTt2YXIgYT1vLmdldFN5bSgpO251bGwhPT1hJiZhLnNldE1hcmtlZCghMCk7dmFyIHU9by5nZXRFZGdlKCk7ZS5hZGQodS5nZXRMaW5lKCkpO3ZhciBsPW8uZ2V0VG9Ob2RlKCk7MT09PVJyLmdldERlZ3JlZU5vbkRlbGV0ZWQobCkmJm4ucHVzaChsKX19cmV0dXJuIGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJyfX0pLFJyLmZpbmRMYWJlbGVkRWRnZVJpbmdzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTEsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZighKHIuaXNNYXJrZWQoKXx8ci5nZXRMYWJlbCgpPj0wKSl7ZS5hZGQocik7dmFyIHM9d3IuZmluZERpckVkZ2VzSW5SaW5nKHIpO1JyLmxhYmVsKHMsbiksbisrfX1yZXR1cm4gZX0sUnIuZ2V0RGVncmVlTm9uRGVsZXRlZD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksbj0wLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc01hcmtlZCgpfHxuKyt9cmV0dXJuIG59LFJyLmRlbGV0ZUFsbEVkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0TWFya2VkKCEwKTt2YXIgcj1pLmdldFN5bSgpO251bGwhPT1yJiZyLnNldE1hcmtlZCghMCl9fSxSci5sYWJlbD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLnNldExhYmVsKGUpfX0sUnIuY29tcHV0ZU5leHRDV0VkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCksbj1udWxsLGk9bnVsbCxyPWUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYoIXMuaXNNYXJrZWQoKSl7aWYobnVsbD09PW4mJihuPXMpLG51bGwhPT1pKXt2YXIgbz1pLmdldFN5bSgpO28uc2V0TmV4dChzKX1pPXN9fWlmKG51bGwhPT1pKXt2YXIgbz1pLmdldFN5bSgpO28uc2V0TmV4dChuKX19LFJyLmNvbXB1dGVOZXh0Q0NXRWRnZXM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRPdXRFZGdlcygpLGk9bnVsbCxyPW51bGwscz1uLmdldEVkZ2VzKCksbz1zLnNpemUoKS0xO28+PTA7by0tKXt2YXIgYT1zLmdldChvKSx1PWEuZ2V0U3ltKCksbD1udWxsO2EuZ2V0TGFiZWwoKT09PWUmJihsPWEpO3ZhciBoPW51bGw7dS5nZXRMYWJlbCgpPT09ZSYmKGg9dSksbnVsbD09PWwmJm51bGw9PT1ofHwobnVsbCE9PWgmJihyPWgpLG51bGwhPT1sJiYobnVsbCE9PXImJihyLnNldE5leHQobCkscj1udWxsKSxudWxsPT09aSYmKGk9bCkpKX1udWxsIT09ciYmKGYuaXNUcnVlKG51bGwhPT1pKSxyLnNldE5leHQoaSkpfSxSci5nZXREZWdyZWU9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCksaT0wLHI9bi5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7cy5nZXRMYWJlbCgpPT09ZSYmaSsrfXJldHVybiBpfSxSci5maW5kSW50ZXJzZWN0aW9uTm9kZXM9ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9bnVsbDtkb3t2YXIgcj1uLmdldEZyb21Ob2RlKCk7UnIuZ2V0RGVncmVlKHIsZSk+MSYmKG51bGw9PT1pJiYoaT1uZXcgSSksaS5hZGQocikpLG49bi5nZXROZXh0KCksZi5pc1RydWUobnVsbCE9PW4sXCJmb3VuZCBudWxsIERFIGluIHJpbmdcIiksZi5pc1RydWUobj09PXR8fCFuLmlzSW5SaW5nKCksXCJmb3VuZCBERSBhbHJlYWR5IGluIHJpbmdcIil9d2hpbGUobiE9PXQpO3JldHVybiBpfSxlKFRyLnByb3RvdHlwZSx7Z2V0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuZ2VvbUZhY3RvcnkmJih0aGlzLmdlb21GYWN0b3J5PW5ldyBpZSksdGhpcy5wb2x5Z29uaXplKCksdGhpcy5leHRyYWN0T25seVBvbHlnb25hbD90aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkodGhpcy5wb2x5TGlzdCk6dGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KHRoaXMucG9seUxpc3QpKX0sZ2V0SW52YWxpZFJpbmdMaW5lczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLmludmFsaWRSaW5nTGluZXN9LGZpbmRWYWxpZFJpbmdzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5pc1ZhbGlkKCk/ZS5hZGQocik6bi5hZGQoci5nZXRMaW5lU3RyaW5nKCkpfX0scG9seWdvbml6ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnBvbHlMaXN0KXJldHVybiBudWxsO2lmKHRoaXMucG9seUxpc3Q9bmV3IEksbnVsbD09PXRoaXMuZ3JhcGgpcmV0dXJuIG51bGw7dGhpcy5kYW5nbGVzPXRoaXMuZ3JhcGguZGVsZXRlRGFuZ2xlcygpLHRoaXMuY3V0RWRnZXM9dGhpcy5ncmFwaC5kZWxldGVDdXRFZGdlcygpO3ZhciB0PXRoaXMuZ3JhcGguZ2V0RWRnZVJpbmdzKCksZT1uZXcgSTt0aGlzLmludmFsaWRSaW5nTGluZXM9bmV3IEksdGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD90aGlzLmZpbmRWYWxpZFJpbmdzKHQsZSx0aGlzLmludmFsaWRSaW5nTGluZXMpOmU9dCx0aGlzLmZpbmRTaGVsbHNBbmRIb2xlcyhlKSxUci5hc3NpZ25Ib2xlc1RvU2hlbGxzKHRoaXMuaG9sZUxpc3QsdGhpcy5zaGVsbExpc3QpLGhvLnNvcnQodGhpcy5zaGVsbExpc3QsbmV3IHdyLkVudmVsb3BlQ29tcGFyYXRvcik7dmFyIG49ITA7dGhpcy5leHRyYWN0T25seVBvbHlnb25hbCYmKFRyLmZpbmREaXNqb2ludFNoZWxscyh0aGlzLnNoZWxsTGlzdCksbj0hMSksdGhpcy5wb2x5TGlzdD1Uci5leHRyYWN0UG9seWdvbnModGhpcy5zaGVsbExpc3Qsbil9LGdldERhbmdsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2x5Z29uaXplKCksdGhpcy5kYW5nbGVzfSxnZXRDdXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLmN1dEVkZ2VzfSxnZXRQb2x5Z29uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLnBvbHlMaXN0fSxhZGQ6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx2KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5hZGQobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5nZW9tRmFjdG9yeT1pLmdldEZhY3RvcnkoKSxudWxsPT09dGhpcy5ncmFwaCYmKHRoaXMuZ3JhcGg9bmV3IFJyKHRoaXMuZ2VvbUZhY3RvcnkpKSx0aGlzLmdyYXBoLmFkZEVkZ2UoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciByPWFyZ3VtZW50c1swXTtyLmFwcGx5KHRoaXMubGluZVN0cmluZ0FkZGVyKX19LHNldENoZWNrUmluZ3NWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzQ2hlY2tpbmdSaW5nc1ZhbGlkPXR9LGZpbmRTaGVsbHNBbmRIb2xlczpmdW5jdGlvbih0KXt0aGlzLmhvbGVMaXN0PW5ldyBJLHRoaXMuc2hlbGxMaXN0PW5ldyBJO2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmNvbXB1dGVIb2xlKCksbi5pc0hvbGUoKT90aGlzLmhvbGVMaXN0LmFkZChuKTp0aGlzLnNoZWxsTGlzdC5hZGQobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBUcn19KSxUci5maW5kT3V0ZXJTaGVsbHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRPdXRlckhvbGUoKTtudWxsPT09aXx8aS5pc1Byb2Nlc3NlZCgpfHwobi5zZXRJbmNsdWRlZCghMCksaS5zZXRQcm9jZXNzZWQoITApKX19LFRyLmV4dHJhY3RQb2x5Z29ucz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpOyhlfHxyLmlzSW5jbHVkZWQoKSkmJm4uYWRkKHIuZ2V0UG9seWdvbigpKX1yZXR1cm4gbn0sVHIuYXNzaWduSG9sZXNUb1NoZWxscz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtUci5hc3NpZ25Ib2xlVG9TaGVsbChpLGUpfX0sVHIuYXNzaWduSG9sZVRvU2hlbGw9ZnVuY3Rpb24odCxlKXt2YXIgbj13ci5maW5kRWRnZVJpbmdDb250YWluaW5nKHQsZSk7bnVsbCE9PW4mJm4uYWRkSG9sZSh0KX0sVHIuZmluZERpc2pvaW50U2hlbGxzPWZ1bmN0aW9uKHQpe1RyLmZpbmRPdXRlclNoZWxscyh0KTt2YXIgZT1udWxsO2Rve2U9ITE7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuaXNJbmNsdWRlZFNldCgpfHwoaS51cGRhdGVJbmNsdWRlZCgpLGkuaXNJbmNsdWRlZFNldCgpfHwoZT0hMCkpfX13aGlsZShlKX0sZShQci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMucC5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQcn19KSxUci5MaW5lU3RyaW5nQWRkZXI9UHI7dmFyIFJvPU9iamVjdC5mcmVlemUoe1BvbHlnb25pemVyOlRyfSk7ZShici5wcm90b3R5cGUse2NyZWF0ZUVkZ2VFbmRGb3JOZXh0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW4uc2VnbWVudEluZGV4KzE7aWYocj49dC5nZXROdW1Qb2ludHMoKSYmbnVsbD09PWkpcmV0dXJuIG51bGw7dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD09PW4uc2VnbWVudEluZGV4JiYocz1pLmNvb3JkKTt2YXIgbz1uZXcgRW4odCxuLmNvb3JkLHMsbmV3IGduKHQuZ2V0TGFiZWwoKSkpO2UuYWRkKG8pfSxjcmVhdGVFZGdlRW5kRm9yUHJldjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uLnNlZ21lbnRJbmRleDtpZigwPT09bi5kaXN0KXtpZigwPT09cilyZXR1cm4gbnVsbDtyLS19dmFyIHM9dC5nZXRDb29yZGluYXRlKHIpO251bGwhPT1pJiZpLnNlZ21lbnRJbmRleD49ciYmKHM9aS5jb29yZCk7dmFyIG89bmV3IGduKHQuZ2V0TGFiZWwoKSk7by5mbGlwKCk7dmFyIGE9bmV3IEVuKHQsbi5jb29yZCxzLG8pO2UuYWRkKGEpfSxjb21wdXRlRWRnZUVuZHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBJLG49dDtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuY29tcHV0ZUVkZ2VFbmRzKGksZSl9cmV0dXJuIGV9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPXIuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKTtvLmFkZEVuZHBvaW50cygpO3ZhciBhPW8uaXRlcmF0b3IoKSx1PW51bGwsbD1udWxsO2lmKCFhLmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgaD1hLm5leHQoKTtkbyB1PWwsbD1oLGg9bnVsbCxhLmhhc05leHQoKSYmKGg9YS5uZXh0KCkpLG51bGwhPT1sJiYodGhpcy5jcmVhdGVFZGdlRW5kRm9yUHJldihyLHMsbCx1KSx0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JOZXh0KHIscyxsLGgpKTt3aGlsZShudWxsIT09bCl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBicn19KSxoKE9yLEVuKSxlKE9yLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQpe3RoaXMuZWRnZUVuZHMuYWRkKHQpfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJFZGdlRW5kQnVuZGxlLS0+IExhYmVsOiBcIit0aGlzLmxhYmVsKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KSx0LnByaW50bG4oKX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZUVuZHMuaXRlcmF0b3IoKX0sZ2V0RWRnZUVuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kc30sY29tcHV0ZUxhYmVsT246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MCxpPSExLHI9dGhpcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCk7bz09PUwuQk9VTkRBUlkmJm4rKyxvPT09TC5JTlRFUklPUiYmKGk9ITApfXZhciBvPUwuTk9ORTtpJiYobz1MLklOVEVSSU9SKSxuPjAmJihvPSRuLmRldGVybWluZUJvdW5kYXJ5KGUsbikpLHRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxvKX0sY29tcHV0ZUxhYmVsU2lkZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmdldExhYmVsKCkuaXNBcmVhKCkpe3ZhciByPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0LGUpO2lmKHI9PT1MLklOVEVSSU9SKXJldHVybiB0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLklOVEVSSU9SKSxudWxsO3I9PT1MLkVYVEVSSU9SJiZ0aGlzLmxhYmVsLnNldExvY2F0aW9uKHQsZSxMLkVYVEVSSU9SKX19fSxnZXRMYWJlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxhYmVsfSxjb21wdXRlTGFiZWxTaWRlczpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5MRUZUKSx0aGlzLmNvbXB1dGVMYWJlbFNpZGUodCxjbi5SSUdIVCl9LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe0puLnVwZGF0ZUlNKHRoaXMubGFiZWwsdCl9LGNvbXB1dGVMYWJlbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9ITEsbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmdldExhYmVsKCkuaXNBcmVhKCkmJihlPSEwKX1lP3RoaXMubGFiZWw9bmV3IGduKEwuTk9ORSxMLk5PTkUsTC5OT05FKTp0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgcj0wOzI+cjtyKyspdGhpcy5jb21wdXRlTGFiZWxPbihyLHQpLGUmJnRoaXMuY29tcHV0ZUxhYmVsU2lkZXMocil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9yfX0pLGgoX3IsUG4pLGUoX3IucHJvdG90eXBlLHt1cGRhdGVJTTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi51cGRhdGVJTSh0KX19LGluc2VydDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VNYXAuZ2V0KHQpO251bGw9PT1lPyhlPW5ldyBPcih0KSx0aGlzLmluc2VydEVkZ2VFbmQodCxlKSk6ZS5pbnNlcnQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9yfX0pLGgoTXIseW4pLGUoTXIucHJvdG90eXBlLHt1cGRhdGVJTUZyb21FZGdlczpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLnVwZGF0ZUlNKHQpfSxjb21wdXRlSU06ZnVuY3Rpb24odCl7dC5zZXRBdExlYXN0SWZWYWxpZCh0aGlzLmxhYmVsLmdldExvY2F0aW9uKDApLHRoaXMubGFiZWwuZ2V0TG9jYXRpb24oMSksMCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1yfX0pLGgoRHIsTm4pLGUoRHIucHJvdG90eXBlLHtjcmVhdGVOb2RlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgTXIodCxuZXcgX3IpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEcn19KSxlKEFyLnByb3RvdHlwZSx7aW5zZXJ0RWRnZUVuZHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMubm9kZXMuYWRkKG4pfX0sY29tcHV0ZVByb3BlckludGVyc2VjdGlvbklNOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxpPXRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RGltZW5zaW9uKCkscj10Lmhhc1Byb3BlckludGVyc2VjdGlvbigpLHM9dC5oYXNQcm9wZXJJbnRlcmlvckludGVyc2VjdGlvbigpOzI9PT1uJiYyPT09aT9yJiZlLnNldEF0TGVhc3QoXCIyMTIxMDEyMTJcIik6Mj09PW4mJjE9PT1pPyhyJiZlLnNldEF0TGVhc3QoXCJGRkYwRkZGRjJcIikscyYmZS5zZXRBdExlYXN0KFwiMUZGRkZGMUZGXCIpKToxPT09biYmMj09PWk/KHImJmUuc2V0QXRMZWFzdChcIkYwRkZGRkZGMlwiKSxzJiZlLnNldEF0TGVhc3QoXCIxRjFGRkZGRkZcIikpOjE9PT1uJiYxPT09aSYmcyYmZS5zZXRBdExlYXN0KFwiMEZGRkZGRkZGXCIpfSxsYWJlbElzb2xhdGVkRWRnZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpLmlzSXNvbGF0ZWQoKSYmKHRoaXMubGFiZWxJc29sYXRlZEVkZ2UoaSxlLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpLHRoaXMuaXNvbGF0ZWRFZGdlcy5hZGQoaSkpfX0sbGFiZWxJc29sYXRlZEVkZ2U6ZnVuY3Rpb24odCxlLG4pe2lmKG4uZ2V0RGltZW5zaW9uKCk+MCl7dmFyIGk9dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLG4pO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxpKX1lbHNlIHQuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxMLkVYVEVSSU9SKX0sY29tcHV0ZUlNOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGZlO2lmKHQuc2V0KEwuRVhURVJJT1IsTC5FWFRFUklPUiwyKSwhdGhpcy5hcmdbMF0uZ2V0R2VvbWV0cnkoKS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuIHRoaXMuY29tcHV0ZURpc2pvaW50SU0odCksdDt0aGlzLmFyZ1swXS5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITEpLHRoaXMuYXJnWzFdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSk7dmFyIGU9dGhpcy5hcmdbMF0uY29tcHV0ZUVkZ2VJbnRlcnNlY3Rpb25zKHRoaXMuYXJnWzFdLHRoaXMubGksITEpO3RoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDApLHRoaXMuY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzKDEpLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKDEpLHRoaXMubGFiZWxJc29sYXRlZE5vZGVzKCksdGhpcy5jb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU0oZSx0KTt2YXIgbj1uZXcgYnIsaT1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLmFyZ1swXS5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhpKTt2YXIgcj1uLmNvbXB1dGVFZGdlRW5kcyh0aGlzLmFyZ1sxXS5nZXRFZGdlSXRlcmF0b3IoKSk7cmV0dXJuIHRoaXMuaW5zZXJ0RWRnZUVuZHMociksdGhpcy5sYWJlbE5vZGVFZGdlcygpLHRoaXMubGFiZWxJc29sYXRlZEVkZ2VzKDAsMSksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMSwwKSx0aGlzLnVwZGF0ZUlNKHQpLHR9LGxhYmVsTm9kZUVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuYXJnKX19LGNvcHlOb2Rlc0FuZExhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0Tm9kZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPXRoaXMubm9kZXMuYWRkTm9kZShuLmdldENvb3JkaW5hdGUoKSk7aS5zZXRMYWJlbCh0LG4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSl9fSxsYWJlbEludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMubm9kZXMuZmluZChzLmNvb3JkKTtvLmdldExhYmVsKCkuaXNOdWxsKHQpJiYoaT09PUwuQk9VTkRBUlk/by5zZXRMYWJlbEJvdW5kYXJ5KHQpOm8uc2V0TGFiZWwodCxMLklOVEVSSU9SKSl9fSxsYWJlbElzb2xhdGVkTm9kZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LmdldENvb3JkaW5hdGUoKSx0aGlzLmFyZ1tlXS5nZXRHZW9tZXRyeSgpKTt0LmdldExhYmVsKCkuc2V0QWxsTG9jYXRpb25zKGUsbil9LGNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5hcmdbdF0uZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KSxyPW4uZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz10aGlzLm5vZGVzLmFkZE5vZGUocy5jb29yZCk7aT09PUwuQk9VTkRBUlk/by5zZXRMYWJlbEJvdW5kYXJ5KHQpOm8uZ2V0TGFiZWwoKS5pc051bGwodCkmJm8uc2V0TGFiZWwodCxMLklOVEVSSU9SKX19LGxhYmVsSXNvbGF0ZWROb2RlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKTtmLmlzVHJ1ZShuLmdldEdlb21ldHJ5Q291bnQoKT4wLFwibm9kZSB3aXRoIGVtcHR5IGxhYmVsIGZvdW5kXCIpLGUuaXNJc29sYXRlZCgpJiYobi5pc051bGwoMCk/dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDApOnRoaXMubGFiZWxJc29sYXRlZE5vZGUoZSwxKSl9fSx1cGRhdGVJTTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pc29sYXRlZEVkZ2VzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpfWZvcih2YXIgaT10aGlzLm5vZGVzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLnVwZGF0ZUlNKHQpLHIudXBkYXRlSU1Gcm9tRWRnZXModCl9fSxjb21wdXRlRGlzam9pbnRJTTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpO2UuaXNFbXB0eSgpfHwodC5zZXQoTC5JTlRFUklPUixMLkVYVEVSSU9SLGUuZ2V0RGltZW5zaW9uKCkpLHQuc2V0KEwuQk9VTkRBUlksTC5FWFRFUklPUixlLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKTt2YXIgbj10aGlzLmFyZ1sxXS5nZXRHZW9tZXRyeSgpO24uaXNFbXB0eSgpfHwodC5zZXQoTC5FWFRFUklPUixMLklOVEVSSU9SLG4uZ2V0RGltZW5zaW9uKCkpLHQuc2V0KEwuRVhURVJJT1IsTC5CT1VOREFSWSxuLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQXJ9fSksZShGci5wcm90b3R5cGUse2lzQ29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVHQpcmV0dXJuITE7aWYodCBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLmlzUG9pbnRDb250YWluZWRJbkJvdW5kYXJ5KHQpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy5pc0xpbmVTdHJpbmdDb250YWluZWRJbkJvdW5kYXJ5KHQpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkobikpcmV0dXJuITF9cmV0dXJuITB9LGlzTGluZVNlZ21lbnRDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQsZSl7aWYodC5lcXVhbHMoZSkpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodC54PT09ZS54KXtpZih0Lng9PT10aGlzLnJlY3RFbnYuZ2V0TWluWCgpfHx0Lng9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpKXJldHVybiEwfWVsc2UgaWYodC55PT09ZS55JiYodC55PT09dGhpcy5yZWN0RW52LmdldE1pblkoKXx8dC55PT09dGhpcy5yZWN0RW52LmdldE1heFkoKSkpcmV0dXJuITA7cmV0dXJuITF9LGlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj1uZXcgZyxpPW5ldyBnLHI9MDtyPGUuc2l6ZSgpLTE7cisrKWlmKGUuZ2V0Q29vcmRpbmF0ZShyLG4pLGUuZ2V0Q29vcmRpbmF0ZShyKzEsaSksIXRoaXMuaXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnkobixpKSlyZXR1cm4hMTtyZXR1cm4hMH0saXNQb2ludENvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodC5nZXRDb29yZGluYXRlKCkpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBlLng9PT10aGlzLnJlY3RFbnYuZ2V0TWluWCgpfHxlLng9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WCgpfHxlLnk9PT10aGlzLnJlY3RFbnYuZ2V0TWluWSgpfHxlLnk9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpfX0sY29udGFpbnM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVjdEVudi5jb250YWlucyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk/IXRoaXMuaXNDb250YWluZWRJbkJvdW5kYXJ5KHQpOiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGcn19KSxGci5jb250YWlucz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBGcih0KTtyZXR1cm4gbi5jb250YWlucyhlKX0sZShHci5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgQyh0LGUpO2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhuKSlyZXR1cm4hMTtpZih0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyh0KSlyZXR1cm4hMDtpZih0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyhlKSlyZXR1cm4hMDtpZih0LmNvbXBhcmVUbyhlKT4wKXt2YXIgaT10O3Q9ZSxlPWl9dmFyIHI9ITE7cmV0dXJuIGUueT50LnkmJihyPSEwKSxyP3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5kaWFnRG93bjAsdGhpcy5kaWFnRG93bjEpOnRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5kaWFnVXAwLHRoaXMuZGlhZ1VwMSksISF0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHcn19KSxlKHFyLnByb3RvdHlwZSx7YXBwbHlUbzpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHQuZ2V0TnVtR2VvbWV0cmllcygpJiYhdGhpcy5faXNEb25lO2UrKyl7dmFyIG49dC5nZXRHZW9tZXRyeU4oZSk7aWYobiBpbnN0YW5jZW9mIGZ0KXRoaXMuYXBwbHlUbyhuKTtlbHNlIGlmKHRoaXMudmlzaXQobiksdGhpcy5pc0RvbmUoKSlyZXR1cm4gdGhpcy5faXNEb25lPSEwLG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxcn19KSxlKEJyLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbih0KXtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpKXJldHVybiExO3ZhciBlPW5ldyB6cih0aGlzLnJlY3RFbnYpO2lmKGUuYXBwbHlUbyh0KSxlLmludGVyc2VjdHMoKSlyZXR1cm4hMDt2YXIgbj1uZXcgVnIodGhpcy5yZWN0YW5nbGUpO2lmKG4uYXBwbHlUbyh0KSxuLmNvbnRhaW5zUG9pbnQoKSlyZXR1cm4hMDt2YXIgaT1uZXcga3IodGhpcy5yZWN0YW5nbGUpO3JldHVybiBpLmFwcGx5VG8odCksISFpLmludGVyc2VjdHMoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQnJ9fSksQnIuaW50ZXJzZWN0cz1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBCcih0KTtyZXR1cm4gbi5pbnRlcnNlY3RzKGUpfSxoKHpyLHFyKSxlKHpyLnByb3RvdHlwZSx7aXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHM9PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7cmV0dXJuIHRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpP3RoaXMucmVjdEVudi5jb250YWlucyhlKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTplLmdldE1pblgoKT49dGhpcy5yZWN0RW52LmdldE1pblgoKSYmZS5nZXRNYXhYKCk8PXRoaXMucmVjdEVudi5nZXRNYXhYKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6ZS5nZXRNaW5ZKCk+PXRoaXMucmVjdEVudi5nZXRNaW5ZKCkmJmUuZ2V0TWF4WSgpPD10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOnZvaWQgMDpudWxsfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2ludGVyc2VjdHN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpyfX0pLGgoVnIscXIpLGUoVnIucHJvdG90eXBlLHtpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD09PSEwfSx2aXNpdDpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBUdCkpcmV0dXJuIG51bGw7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO2Zvcih2YXIgbj1uZXcgZyxpPTA7ND5pO2krKylpZih0aGlzLnJlY3RTZXEuZ2V0Q29vcmRpbmF0ZShpLG4pLGUuY29udGFpbnMobikmJlRuLmNvbnRhaW5zUG9pbnRJblBvbHlnb24obix0KSlyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludD0hMCxudWxsfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2NvbnRhaW5zUG9pbnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZyfX0pLGgoa3IscXIpLGUoa3IucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb249PT0hMH0sdmlzaXQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiBudWxsO3ZhciBuPWtuLmdldExpbmVzKHQpO3RoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3Mobil9LGNoZWNrSW50ZXJzZWN0aW9uV2l0aExpbmVTdHJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZih0aGlzLmNoZWNrSW50ZXJzZWN0aW9uV2l0aFNlZ21lbnRzKG4pLHRoaXMuaGFzSW50ZXJzZWN0aW9uKXJldHVybiBudWxsfX0sY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksbj0xO248ZS5zaXplKCk7bisrKWlmKGUuZ2V0Q29vcmRpbmF0ZShuLTEsdGhpcy5wMCksZS5nZXRDb29yZGluYXRlKG4sdGhpcy5wMSksdGhpcy5yZWN0SW50ZXJzZWN0b3IuaW50ZXJzZWN0cyh0aGlzLnAwLHRoaXMucDEpKXJldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbj0hMCxudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrcn19KSxoKFlyLHRpKSxlKFlyLnByb3RvdHlwZSx7Z2V0SW50ZXJzZWN0aW9uTWF0cml4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JlbGF0ZS5jb21wdXRlSU0oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXJ9fSksWXIuY292ZXJzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvdmVycyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpPyEwOllyLnJlbGF0ZSh0LGUpLmlzQ292ZXJzKCk6ITF9LFlyLmludGVyc2VjdHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/dC5pc1JlY3RhbmdsZSgpP0JyLmludGVyc2VjdHModCxlKTplLmlzUmVjdGFuZ2xlKCk/QnIuaW50ZXJzZWN0cyhlLHQpOllyLnJlbGF0ZSh0LGUpLmlzSW50ZXJzZWN0cygpOiExfSxZci50b3VjaGVzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0LGUpLmlzVG91Y2hlcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxZci53aXRoaW49ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5jb250YWlucyh0KX0sWXIuY292ZXJlZEJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIFlyLmNvdmVycyhlLHQpfSxZci5yZWxhdGU9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFlyKHQsZSksaT1uLmdldEludGVyc2VjdGlvbk1hdHJpeCgpO3JldHVybiBpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcInN0cmluZ1wiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQil7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3JldHVybiBZci5yZWxhdGVXaXRoQ2hlY2socixzKS5tYXRjaGVzKG8pfWlmKFIoYXJndW1lbnRzWzJdLFYpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQil7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLG49bmV3IFlyKGEsdSxsKSxpPW4uZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCk7cmV0dXJuIGl9fX0sWXIub3ZlcmxhcHM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHQsZSkuaXNPdmVybGFwcyh0LmdldERpbWVuc2lvbigpLGUuZ2V0RGltZW5zaW9uKCkpOiExfSxZci5kaXNqb2ludD1mdW5jdGlvbih0LGUpe3JldHVybiF0LmludGVyc2VjdHMoZSl9LFlyLnJlbGF0ZVdpdGhDaGVjaz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksWXIucmVsYXRlKHQsZSl9LFlyLmNyb3NzZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHQsZSkuaXNDcm9zc2VzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk6ITF9LFlyLmNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmNvbnRhaW5zKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT90LmlzUmVjdGFuZ2xlKCk/RnIuY29udGFpbnModCxlKTpZci5yZWxhdGUodCxlKS5pc0NvbnRhaW5zKCk6ITF9O3ZhciBUbz1PYmplY3QuZnJlZXplKHtSZWxhdGVPcDpZcn0pO2UoVXIucHJvdG90eXBlLHtleHRyYWN0RWxlbWVudHM6ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dClyZXR1cm4gbnVsbDtmb3IodmFyIG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dC5nZXRHZW9tZXRyeU4obik7dGhpcy5za2lwRW1wdHkmJmkuaXNFbXB0eSgpfHxlLmFkZChpKX19LGNvbWJpbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEksZT10aGlzLmlucHV0R2VvbXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdEVsZW1lbnRzKG4sdCl9cmV0dXJuIDA9PT10LnNpemUoKT9udWxsIT09dGhpcy5nZW9tRmFjdG9yeT90aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKTpudWxsOnRoaXMuZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXJ9fSksVXIuY29tYmluZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgVXIodCk7cmV0dXJuIGUuY29tYmluZSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uZXcgVXIoVXIuY3JlYXRlTGlzdChuLGkpKTtyZXR1cm4gZS5jb21iaW5lKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxlPW5ldyBVcihVci5jcmVhdGVMaXN0KHIscyxvKSk7cmV0dXJuIGUuY29tYmluZSgpfX0sVXIuZXh0cmFjdEZhY3Rvcnk9ZnVuY3Rpb24odCl7cmV0dXJuIHQuaXNFbXB0eSgpP251bGw6dC5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCl9LFVyLmNyZWF0ZUxpc3Q9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IEk7cmV0dXJuIG4uYWRkKHQpLG4uYWRkKGUpLG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxuPW5ldyBJO3JldHVybiBuLmFkZChpKSxuLmFkZChyKSxuLmFkZChzKSxufX0sZShYci5wcm90b3R5cGUse3VuaW9uOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBUZSxlPW5ldyBhdCxuPTA7bjx0aGlzLnBvaW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10aGlzLnBvaW50R2VvbS5nZXRHZW9tZXRyeU4obikscj1pLmdldENvb3JkaW5hdGUoKSxzPXQubG9jYXRlKHIsdGhpcy5vdGhlckdlb20pO3M9PT1MLkVYVEVSSU9SJiZlLmFkZChyKX1pZigwPT09ZS5zaXplKCkpcmV0dXJuIHRoaXMub3RoZXJHZW9tO3ZhciBvPW51bGwsYT1ILnRvQ29vcmRpbmF0ZUFycmF5KGUpO3JldHVybiBvPTE9PT1hLmxlbmd0aD90aGlzLmdlb21GYWN0LmNyZWF0ZVBvaW50KGFbMF0pOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoYSksVXIuY29tYmluZShvLHRoaXMub3RoZXJHZW9tKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWHJ9fSksWHIudW5pb249ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgWHIodCxlKTtyZXR1cm4gbi51bmlvbigpfSxlKEhyLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpey0xIT09dGhpcy5zb3J0SW5kZXgmJnQuZ2V0U29ydEluZGV4KCkhPT10aGlzLnNvcnRJbmRleHx8dGhpcy5jb21wcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSHJ9fSksSHIuZXh0cmFjdD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIEhyLmV4dHJhY3QodCxlLG5ldyBJKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3JldHVybiBuLmdldFNvcnRJbmRleCgpPT09aT9yLmFkZChuKTpuIGluc3RhbmNlb2YgZnQmJm4uYXBwbHkobmV3IEhyKGkscikpLHJ9fSxlKFdyLnByb3RvdHlwZSx7cmVkdWNlVG9HZW9tZXRyaWVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9bnVsbDtSKGkseSk/cj10aGlzLnVuaW9uVHJlZShpKTppIGluc3RhbmNlb2YgQiYmKHI9aSksZS5hZGQocil9cmV0dXJuIGV9LGV4dHJhY3RCeUVudmVsb3BlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9bmV3IEkscj0wO3I8ZS5nZXROdW1HZW9tZXRyaWVzKCk7cisrKXt2YXIgcz1lLmdldEdlb21ldHJ5TihyKTtzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHQpP2kuYWRkKHMpOm4uYWRkKHMpfXJldHVybiB0aGlzLmdlb21GYWN0b3J5LmJ1aWxkR2VvbWV0cnkoaSl9LHVuaW9uT3B0aW1pemVkOmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRFbnZlbG9wZUludGVybmFsKCksaT1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighbi5pbnRlcnNlY3RzKGkpKXt2YXIgcj1Vci5jb21iaW5lKHQsZSk7cmV0dXJuIHJ9aWYodC5nZXROdW1HZW9tZXRyaWVzKCk8PTEmJmUuZ2V0TnVtR2VvbWV0cmllcygpPD0xKXJldHVybiB0aGlzLnVuaW9uQWN0dWFsKHQsZSk7dmFyIHM9bi5pbnRlcnNlY3Rpb24oaSk7cmV0dXJuIHRoaXMudW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uKHQsZSxzKX0sdW5pb246ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5pbnB1dFBvbHlzKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJ1bmlvbigpIG1ldGhvZCBjYW5ub3QgYmUgY2FsbGVkIHR3aWNlXCIpO2lmKHRoaXMuaW5wdXRQb2x5cy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dGhpcy5nZW9tRmFjdG9yeT10aGlzLmlucHV0UG9seXMuaXRlcmF0b3IoKS5uZXh0KCkuZ2V0RmFjdG9yeSgpO2Zvcih2YXIgdD1uZXcga2UoV3IuU1RSVFJFRV9OT0RFX0NBUEFDSVRZKSxlPXRoaXMuaW5wdXRQb2x5cy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dC5pbnNlcnQobi5nZXRFbnZlbG9wZUludGVybmFsKCksbil9dGhpcy5pbnB1dFBvbHlzPW51bGw7dmFyIGk9dC5pdGVtc1RyZWUoKSxyPXRoaXMudW5pb25UcmVlKGkpO3JldHVybiByfSxiaW5hcnlVbmlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYmluYXJ5VW5pb24odCwwLHQuc2l6ZSgpKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdO2lmKDE+PWktbil7dmFyIHI9V3IuZ2V0R2VvbWV0cnkoZSxuKTtyZXR1cm4gdGhpcy51bmlvblNhZmUocixudWxsKX1pZihpLW49PT0yKXJldHVybiB0aGlzLnVuaW9uU2FmZShXci5nZXRHZW9tZXRyeShlLG4pLFdyLmdldEdlb21ldHJ5KGUsbisxKSk7dmFyIHM9TWF0aC50cnVuYygoaStuKS8yKSxyPXRoaXMuYmluYXJ5VW5pb24oZSxuLHMpLG89dGhpcy5iaW5hcnlVbmlvbihlLHMsaSk7cmV0dXJuIHRoaXMudW5pb25TYWZlKHIsbyl9fSxyZXBlYXRlZFVuaW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZT1udWxsPT09ZT9pLmNvcHkoKTplLnVuaW9uKGkpfXJldHVybiBlfSx1bmlvblNhZmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXQmJm51bGw9PT1lP251bGw6bnVsbD09PXQ/ZS5jb3B5KCk6bnVsbD09PWU/dC5jb3B5KCk6dGhpcy51bmlvbk9wdGltaXplZCh0LGUpfSx1bmlvbkFjdHVhbDpmdW5jdGlvbih0LGUpe3JldHVybiBXci5yZXN0cmljdFRvUG9seWdvbnModC51bmlvbihlKSl9LHVuaW9uVHJlZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVRvR2VvbWV0cmllcyh0KSxuPXRoaXMuYmluYXJ5VW5pb24oZSk7cmV0dXJuIG59LHVuaW9uVXNpbmdFbnZlbG9wZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEkscj10aGlzLmV4dHJhY3RCeUVudmVsb3BlKG4sdCxpKSxzPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobixlLGkpLG89dGhpcy51bmlvbkFjdHVhbChyLHMpO2kuYWRkKG8pO3ZhciBhPVVyLmNvbWJpbmUoaSk7cmV0dXJuIGF9LGJ1ZmZlclVuaW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0KDApLmdldEZhY3RvcnkoKSxuPWUuYnVpbGRHZW9tZXRyeSh0KSxpPW4uYnVmZmVyKDApO3JldHVybiBpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sZT1yLmdldEZhY3RvcnkoKSxuPWUuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKFtyLHNdKSxpPW4uYnVmZmVyKDApO3JldHVybiBpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3J9fSksV3IucmVzdHJpY3RUb1BvbHlnb25zPWZ1bmN0aW9uKHQpe2lmKFIodCxSdCkpcmV0dXJuIHQ7dmFyIGU9b3IuZ2V0UG9seWdvbnModCk7cmV0dXJuIDE9PT1lLnNpemUoKT9lLmdldCgwKTp0LmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aVBvbHlnb24oaWUudG9Qb2x5Z29uQXJyYXkoZSkpfSxXci5nZXRHZW9tZXRyeT1mdW5jdGlvbih0LGUpe3JldHVybiBlPj10LnNpemUoKT9udWxsOnQuZ2V0KGUpfSxXci51bmlvbj1mdW5jdGlvbih0KXt2YXIgZT1uZXcgV3IodCk7cmV0dXJuIGUudW5pb24oKX0sV3IuU1RSVFJFRV9OT0RFX0NBUEFDSVRZPTQsZShqci5wcm90b3R5cGUse3VuaW9uTm9PcHQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZW9tRmFjdC5jcmVhdGVQb2ludCgpO3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sdW5pb25XaXRoTnVsbDpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09ZT90Om51bGw9PT10P2U6dC51bmlvbihlKX0sZXh0cmFjdDpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmV4dHJhY3Qobil9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBpPWFyZ3VtZW50c1swXTtudWxsPT09dGhpcy5nZW9tRmFjdCYmKHRoaXMuZ2VvbUZhY3Q9aS5nZXRGYWN0b3J5KCkpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0xZR09OLHRoaXMucG9seWdvbnMpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9MSU5FU1RSSU5HLHRoaXMubGluZXMpLEhyLmV4dHJhY3QoaSxCLlNPUlRJTkRFWF9QT0lOVCx0aGlzLnBvaW50cyl9fSx1bmlvbjpmdW5jdGlvbiB0KCl7aWYobnVsbD09PXRoaXMuZ2VvbUZhY3QpcmV0dXJuIG51bGw7dmFyIGU9bnVsbDtpZih0aGlzLnBvaW50cy5zaXplKCk+MCl7dmFyIG49dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMucG9pbnRzKTtlPXRoaXMudW5pb25Ob09wdChuKX12YXIgaT1udWxsO2lmKHRoaXMubGluZXMuc2l6ZSgpPjApe3ZhciByPXRoaXMuZ2VvbUZhY3QuYnVpbGRHZW9tZXRyeSh0aGlzLmxpbmVzKTtpPXRoaXMudW5pb25Ob09wdChyKX12YXIgcz1udWxsO3RoaXMucG9seWdvbnMuc2l6ZSgpPjAmJihzPVdyLnVuaW9uKHRoaXMucG9seWdvbnMpKTt2YXIgbz10aGlzLnVuaW9uV2l0aE51bGwoaSxzKSx0PW51bGw7cmV0dXJuIHQ9bnVsbD09PWU/bzpudWxsPT09bz9lOlhyLnVuaW9uKGUsbyksbnVsbD09PXQ/dGhpcy5nZW9tRmFjdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTp0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqcn19KSxqci51bmlvbj1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGpyKHQpO3JldHVybiBlLnVuaW9uKCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgbj1hcmd1bWVudHNbMF0sZT1uZXcganIobik7cmV0dXJuIGUudW5pb24oKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLGU9bmV3IGpyKGkscik7cmV0dXJuIGUudW5pb24oKX19O3ZhciBQbz1PYmplY3QuZnJlZXplKHtVbmFyeVVuaW9uT3A6anJ9KTtlKEtyLnByb3RvdHlwZSx7dmlzaXRJbnRlcmlvclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGVzKCksaT1uWzBdLHI9S3IuZmluZERpZmZlcmVudFBvaW50KG4saSkscz1lLmZpbmRFZGdlSW5TYW1lRGlyZWN0aW9uKGksciksbz1lLmZpbmRFZGdlRW5kKHMpLGE9bnVsbDtvLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SP2E9bzpvLmdldFN5bSgpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiYoYT1vLmdldFN5bSgpKSxmLmlzVHJ1ZShudWxsIT09YSxcInVuYWJsZSB0byBmaW5kIGRpckVkZ2Ugd2l0aCBJbnRlcmlvciBvbiBSSFNcIiksdGhpcy52aXNpdExpbmtlZERpcmVjdGVkRWRnZXMoYSl9LHZpc2l0U2hlbGxJbnRlcmlvcnM6ZnVuY3Rpb24odCxlKXtpZih0IGluc3RhbmNlb2YgVHQpe3ZhciBuPXQ7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfWlmKHQgaW5zdGFuY2VvZiBPdClmb3IodmFyIGk9dCxyPTA7cjxpLmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBuPWkuZ2V0R2VvbWV0cnlOKHIpO3RoaXMudmlzaXRJbnRlcmlvclJpbmcobi5nZXRFeHRlcmlvclJpbmcoKSxlKX19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWRSaW5nY29vcmR9LHNldEludGVyaW9yRWRnZXNJblJlc3VsdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SJiZuLnNldEluUmVzdWx0KCEwKX19LHZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0KXt2YXIgZT10LG49dDtkbyBmLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgRGlyZWN0ZWQgRWRnZVwiKSxuLnNldFZpc2l0ZWQoITApLG49bi5nZXROZXh0KCk7d2hpbGUobiE9PWUpfSxidWlsZEVkZ2VSaW5nczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzSW5SZXN1bHQoKSYmbnVsbD09PWkuZ2V0RWRnZVJpbmcoKSl7dmFyIHI9bmV3IHZuKGksdGhpcy5nZW9tZXRyeUZhY3RvcnkpO3IubGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzKCk7dmFyIHM9ci5idWlsZE1pbmltYWxSaW5ncygpO2UuYWRkQWxsKHMpfX1yZXR1cm4gZX0saGFzVW52aXNpdGVkU2hlbGxFZGdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5zaXplKCk7ZSsrKXt2YXIgbj10LmdldChlKTtpZighbi5pc0hvbGUoKSl7dmFyIGk9bi5nZXRFZGdlcygpLHI9aS5nZXQoMCk7aWYoci5nZXRMYWJlbCgpLmdldExvY2F0aW9uKDAsY24uUklHSFQpPT09TC5JTlRFUklPUilmb3IodmFyIHM9MDtzPGkuc2l6ZSgpO3MrKylpZihyPWkuZ2V0KHMpLFxuIXIuaXNWaXNpdGVkKCkpcmV0dXJuIHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPXIuZ2V0Q29vcmRpbmF0ZSgpLCEwfX1yZXR1cm4hMX0saXNJbnRlcmlvcnNDb25uZWN0ZWQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTt0aGlzLmdlb21HcmFwaC5jb21wdXRlU3BsaXRFZGdlcyh0KTt2YXIgZT1uZXcgQ24obmV3IE9uKTtlLmFkZEVkZ2VzKHQpLHRoaXMuc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0KGUpLGUubGlua1Jlc3VsdERpcmVjdGVkRWRnZXMoKTt2YXIgbj10aGlzLmJ1aWxkRWRnZVJpbmdzKGUuZ2V0RWRnZUVuZHMoKSk7cmV0dXJuIHRoaXMudmlzaXRTaGVsbEludGVyaW9ycyh0aGlzLmdlb21HcmFwaC5nZXRHZW9tZXRyeSgpLGUpLCF0aGlzLmhhc1VudmlzaXRlZFNoZWxsRWRnZShuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS3J9fSksS3IuZmluZERpZmZlcmVudFBvaW50PWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGUpKXJldHVybiB0W25dO3JldHVybiBudWxsfSxlKFpyLnByb3RvdHlwZSx7aGFzQ2hpbGRyZW46ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDsyPnQ7dCsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9LGlzUHJ1bmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX0sYWRkQWxsSXRlbXM6ZnVuY3Rpb24odCl7dC5hZGRBbGwodGhpcy5pdGVtcyk7Zm9yKHZhciBlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiZ0aGlzLnN1Ym5vZGVbZV0uYWRkQWxsSXRlbXModCk7cmV0dXJuIHR9LHNpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7Mj5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodCs9dGhpcy5zdWJub2RlW2VdLnNpemUoKSk7cmV0dXJuIHQrdGhpcy5pdGVtcy5zaXplKCl9LGFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10fHx0aGlzLmlzU2VhcmNoTWF0Y2godCk/KGUuYWRkQWxsKHRoaXMuaXRlbXMpLG51bGwhPT10aGlzLnN1Ym5vZGVbMF0mJnRoaXMuc3Vibm9kZVswXS5hZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZyh0LGUpLHZvaWQobnVsbCE9PXRoaXMuc3Vibm9kZVsxXSYmdGhpcy5zdWJub2RlWzFdLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSkpKTpudWxsfSxoYXNJdGVtczpmdW5jdGlvbigpe3JldHVybiF0aGlzLml0ZW1zLmlzRW1wdHkoKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7aWYoIXRoaXMuaXNTZWFyY2hNYXRjaCh0KSlyZXR1cm4hMTtmb3IodmFyIG49ITEsaT0wOzI+aTtpKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtpXSYmKG49dGhpcy5zdWJub2RlW2ldLnJlbW92ZSh0LGUpKSl7dGhpcy5zdWJub2RlW2ldLmlzUHJ1bmFibGUoKSYmKHRoaXMuc3Vibm9kZVtpXT1udWxsKTticmVha31yZXR1cm4gbj9uOm49dGhpcy5pdGVtcy5yZW1vdmUoZSl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGRlcHRoOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzI+ZTtlKyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdLmRlcHRoKCk7bj50JiYodD1uKX1yZXR1cm4gdCsxfSxub2RlU2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDsyPmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0ubm9kZVNpemUoKSk7cmV0dXJuIHQrMX0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBacn19KSxaci5nZXRTdWJub2RlSW5kZXg9ZnVuY3Rpb24odCxlKXt2YXIgbj0tMTtyZXR1cm4gdC5taW4+PWUmJihuPTEpLHQubWF4PD1lJiYobj0wKSxufSxlKFFyLnByb3RvdHlwZSx7ZXhwYW5kVG9JbmNsdWRlOmZ1bmN0aW9uKHQpe3QubWF4PnRoaXMubWF4JiYodGhpcy5tYXg9dC5tYXgpLHQubWluPHRoaXMubWluJiYodGhpcy5taW49dC5taW4pfSxnZXRXaWR0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heC10aGlzLm1pbn0sb3ZlcmxhcHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm92ZXJsYXBzKHQubWluLHQubWF4KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiEodGhpcy5taW4+bnx8dGhpcy5tYXg8ZSl9fSxnZXRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW59LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJbXCIrdGhpcy5taW4rXCIsIFwiK3RoaXMubWF4K1wiXVwifSxjb250YWluczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFFyKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY29udGFpbnModC5taW4sdC5tYXgpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gZT49dGhpcy5taW4mJmU8PXRoaXMubWF4fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIG4+PXRoaXMubWluJiZpPD10aGlzLm1heH19LGluaXQ6ZnVuY3Rpb24odCxlKXt0aGlzLm1pbj10LHRoaXMubWF4PWUsdD5lJiYodGhpcy5taW49ZSx0aGlzLm1heD10KX0sZ2V0TWF4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRcn19KSxlKEpyLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZ2V0TGV2ZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sZXZlbH0sY29tcHV0ZUtleTpmdW5jdGlvbih0KXtmb3IodGhpcy5sZXZlbD1Kci5jb21wdXRlTGV2ZWwodCksdGhpcy5pbnRlcnZhbD1uZXcgUXIsdGhpcy5jb21wdXRlSW50ZXJ2YWwodGhpcy5sZXZlbCx0KTshdGhpcy5pbnRlcnZhbC5jb250YWlucyh0KTspdGhpcy5sZXZlbCs9MSx0aGlzLmNvbXB1dGVJbnRlcnZhbCh0aGlzLmxldmVsLHQpfSxjb21wdXRlSW50ZXJ2YWw6ZnVuY3Rpb24odCxlKXt2YXIgbj1DaS5wb3dlck9mMih0KTt0aGlzLnB0PU1hdGguZmxvb3IoZS5nZXRNaW4oKS9uKSpuLHRoaXMuaW50ZXJ2YWwuaW5pdCh0aGlzLnB0LHRoaXMucHQrbil9LGdldFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEpyfX0pLEpyLmNvbXB1dGVMZXZlbD1mdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj1DaS5leHBvbmVudChlKSsxO3JldHVybiBufSxoKCRyLFpyKSxlKCRyLnByb3RvdHlwZSx7Z2V0SW50ZXJ2YWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnZhbH0sZmluZDpmdW5jdGlvbih0KXt2YXIgZT1aci5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTE9PT1lKXJldHVybiB0aGlzO2lmKG51bGwhPT10aGlzLnN1Ym5vZGVbZV0pe3ZhciBuPXRoaXMuc3Vibm9kZVtlXTtyZXR1cm4gbi5maW5kKHQpfXJldHVybiB0aGlzfSxpbnNlcnQ6ZnVuY3Rpb24odCl7Zi5pc1RydWUobnVsbD09PXRoaXMuaW50ZXJ2YWx8fHRoaXMuaW50ZXJ2YWwuY29udGFpbnModC5pbnRlcnZhbCkpO3ZhciBlPVpyLmdldFN1Ym5vZGVJbmRleCh0LmludGVydmFsLHRoaXMuY2VudHJlKTtpZih0LmxldmVsPT09dGhpcy5sZXZlbC0xKXRoaXMuc3Vibm9kZVtlXT10O2Vsc2V7dmFyIG49dGhpcy5jcmVhdGVTdWJub2RlKGUpO24uaW5zZXJ0KHQpLHRoaXMuc3Vibm9kZVtlXT1ufX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4gdC5vdmVybGFwcyh0aGlzLmludGVydmFsKX0sZ2V0U3Vibm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbnVsbD09PXRoaXMuc3Vibm9kZVt0XSYmKHRoaXMuc3Vibm9kZVt0XT10aGlzLmNyZWF0ZVN1Ym5vZGUodCkpLHRoaXMuc3Vibm9kZVt0XX0sZ2V0Tm9kZTpmdW5jdGlvbih0KXt2YXIgZT1aci5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZSk7aWYoLTEhPT1lKXt2YXIgbj10aGlzLmdldFN1Ym5vZGUoZSk7cmV0dXJuIG4uZ2V0Tm9kZSh0KX1yZXR1cm4gdGhpc30sY3JlYXRlU3Vibm9kZTpmdW5jdGlvbih0KXt2YXIgZT0wLG49MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5pbnRlcnZhbC5nZXRNaW4oKSxuPXRoaXMuY2VudHJlO2JyZWFrO2Nhc2UgMTplPXRoaXMuY2VudHJlLG49dGhpcy5pbnRlcnZhbC5nZXRNYXgoKX12YXIgaT1uZXcgUXIoZSxuKSxyPW5ldyAkcihpLHRoaXMubGV2ZWwtMSk7cmV0dXJuIHJ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRyfX0pLCRyLmNyZWF0ZU5vZGU9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEpyKHQpLG49bmV3ICRyKGUuZ2V0SW50ZXJ2YWwoKSxlLmdldExldmVsKCkpO3JldHVybiBufSwkci5jcmVhdGVFeHBhbmRlZD1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBRcihlKTtudWxsIT09dCYmbi5leHBhbmRUb0luY2x1ZGUodC5pbnRlcnZhbCk7dmFyIGk9JHIuY3JlYXRlTm9kZShuKTtyZXR1cm4gbnVsbCE9PXQmJmkuaW5zZXJ0KHQpLGl9LGgodHMsWnIpLGUodHMucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1aci5nZXRTdWJub2RlSW5kZXgodCx0cy5vcmlnaW4pO2lmKC0xPT09bilyZXR1cm4gdGhpcy5hZGQoZSksbnVsbDt2YXIgaT10aGlzLnN1Ym5vZGVbbl07aWYobnVsbD09PWl8fCFpLmdldEludGVydmFsKCkuY29udGFpbnModCkpe3ZhciByPSRyLmNyZWF0ZUV4cGFuZGVkKGksdCk7dGhpcy5zdWJub2RlW25dPXJ9dGhpcy5pbnNlcnRDb250YWluZWQodGhpcy5zdWJub2RlW25dLHQsZSl9LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuITB9LGluc2VydENvbnRhaW5lZDpmdW5jdGlvbih0LGUsbil7Zi5pc1RydWUodC5nZXRJbnRlcnZhbCgpLmNvbnRhaW5zKGUpKTt2YXIgaT1SaS5pc1plcm9XaWR0aChlLmdldE1pbigpLGUuZ2V0TWF4KCkpLHI9bnVsbDtyPWk/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxyLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdHN9fSksdHMub3JpZ2luPTAsZShlcy5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPWVzLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5xdWVyeShuZXcgUXIodCx0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBRcil7dmFyIGU9YXJndW1lbnRzWzBdLG49bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkoZSxuKSxufX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy5yb290LmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKGkscil9fSxpdGVyYXRvcjpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3JldHVybiB0aGlzLnJvb3QuYWRkQWxsSXRlbXModCksdC5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXt2YXIgbj1lcy5lbnN1cmVFeHRlbnQodCx0aGlzLm1pbkV4dGVudCk7cmV0dXJuIHRoaXMucm9vdC5yZW1vdmUobixlKX0sY29sbGVjdFN0YXRzOmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKTtlPHRoaXMubWluRXh0ZW50JiZlPjAmJih0aGlzLm1pbkV4dGVudD1lKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3QuZGVwdGgoKTowfSxub2RlU2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5ub2RlU2l6ZSgpOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVzfX0pLGVzLmVuc3VyZUV4dGVudD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TWluKCksaT10LmdldE1heCgpO3JldHVybiBuIT09aT90OihuPT09aSYmKG4tPWUvMixpPW4rZS8yKSxuZXcgUXIobixpKSl9LGUobnMucHJvdG90eXBlLHtpc0luc2lkZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG5zfX0pLGUoaXMucHJvdG90eXBlLHt0ZXN0TGluZVNlZ21lbnQ6ZnVuY3Rpb24odCxlKXt2YXIgbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPWUucDAsdT1lLnAxO2k9YS54LXQueCxyPWEueS10Lnkscz11LngtdC54LG89dS55LXQueSwocj4wJiYwPj1vfHxvPjAmJjA+PXIpJiYobj11ZS5zaWduT2ZEZXQyeDIoaSxyLHMsbykvKG8tciksbj4wJiZ0aGlzLmNyb3NzaW5ncysrKX0sYnVpbGRJbmRleDpmdW5jdGlvbigpe3RoaXMudHJlZT1uZXcgZXM7Zm9yKHZhciB0PUgucmVtb3ZlUmVwZWF0ZWRQb2ludHModGhpcy5yaW5nLmdldENvb3JkaW5hdGVzKCkpLGU9JGUuZ2V0Q2hhaW5zKHQpLG49MDtuPGUuc2l6ZSgpO24rKyl7dmFyIGk9ZS5nZXQobikscj1pLmdldEVudmVsb3BlKCk7dGhpcy5pbnRlcnZhbC5taW49ci5nZXRNaW5ZKCksdGhpcy5pbnRlcnZhbC5tYXg9ci5nZXRNYXhZKCksdGhpcy50cmVlLmluc2VydCh0aGlzLmludGVydmFsLGkpfX0sdGVzdE1vbm90b25lQ2hhaW46ZnVuY3Rpb24odCxlLG4pe24uc2VsZWN0KHQsZSl9LGlzSW5zaWRlOmZ1bmN0aW9uKHQpe3RoaXMuY3Jvc3NpbmdzPTA7dmFyIGU9bmV3IEMoci5ORUdBVElWRV9JTkZJTklUWSxyLlBPU0lUSVZFX0lORklOSVRZLHQueSx0LnkpO3RoaXMuaW50ZXJ2YWwubWluPXQueSx0aGlzLmludGVydmFsLm1heD10Lnk7Zm9yKHZhciBuPXRoaXMudHJlZS5xdWVyeSh0aGlzLmludGVydmFsKSxpPW5ldyBycyh0aGlzLHQpLHM9bi5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7dGhpcy50ZXN0TW9ub3RvbmVDaGFpbihlLGksbyl9cmV0dXJuIHRoaXMuY3Jvc3NpbmdzJTI9PT0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltuc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGlzfX0pLGgocnMsdHIpLGUocnMucHJvdG90eXBlLHtzZWxlY3Q6ZnVuY3Rpb24oKXtpZigxIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdHIucHJvdG90eXBlLnNlbGVjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWNwLnRlc3RMaW5lU2VnbWVudCh0aGlzLnAsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHJzfX0pLGlzLk1DU2VsZWN0ZXI9cnMsZShzcy5wcm90b3R5cGUse2luc2VydEVkZ2VFbmRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLm5vZGVzLmFkZChuKX19LGdldE5vZGVJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLml0ZXJhdG9yKCl9LGNvcHlOb2Rlc0FuZExhYmVsczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj10aGlzLm5vZGVzLmFkZE5vZGUoaS5nZXRDb29yZGluYXRlKCkpO3Iuc2V0TGFiZWwoZSxpLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkpfX0sYnVpbGQ6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXModCwwKSx0aGlzLmNvcHlOb2Rlc0FuZExhYmVscyh0LDApO3ZhciBlPW5ldyBicixuPWUuY29tcHV0ZUVkZ2VFbmRzKHQuZ2V0RWRnZUl0ZXJhdG9yKCkpO3RoaXMuaW5zZXJ0RWRnZUVuZHMobil9LGNvbXB1dGVJbnRlcnNlY3Rpb25Ob2RlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldEVkZ2VJdGVyYXRvcigpO24uaGFzTmV4dCgpOylmb3IodmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oZSkscz1pLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLGE9dGhpcy5ub2Rlcy5hZGROb2RlKG8uY29vcmQpO3I9PT1MLkJPVU5EQVJZP2Euc2V0TGFiZWxCb3VuZGFyeShlKTphLmdldExhYmVsKCkuaXNOdWxsKGUpJiZhLnNldExhYmVsKGUsTC5JTlRFUklPUil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzc319KSxlKG9zLnByb3RvdHlwZSx7aXNOb2RlRWRnZUFyZWFMYWJlbHNDb25zaXN0ZW50OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7aWYoIWUuZ2V0RWRnZXMoKS5pc0FyZWFMYWJlbHNDb25zaXN0ZW50KHRoaXMuZ2VvbUdyYXBoKSlyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnQ9ZS5nZXRDb29yZGluYXRlKCkuY29weSgpLCExfXJldHVybiEwfSxnZXRJbnZhbGlkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnR9LGhhc0R1cGxpY2F0ZVJpbmdzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZUdyYXBoLmdldE5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOylmb3IodmFyIGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuZ2V0RWRnZUVuZHMoKS5zaXplKCk+MSlyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnQ9aS5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZSgwKSwhMH1yZXR1cm4hMX0saXNOb2RlQ29uc2lzdGVudEFyZWE6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdlb21HcmFwaC5jb21wdXRlU2VsZk5vZGVzKHRoaXMubGksITAsITApO3JldHVybiB0Lmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLmludmFsaWRQb2ludD10LmdldFByb3BlckludGVyc2VjdGlvblBvaW50KCksITEpOih0aGlzLm5vZGVHcmFwaC5idWlsZCh0aGlzLmdlb21HcmFwaCksdGhpcy5pc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9zfX0pLGUoYXMucHJvdG90eXBlLHtidWlsZEluZGV4OmZ1bmN0aW9uKCl7dGhpcy5pbmRleD1uZXcga2U7Zm9yKHZhciB0PTA7dDx0aGlzLnJpbmdzLnNpemUoKTt0Kyspe3ZhciBlPXRoaXMucmluZ3MuZ2V0KHQpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7dGhpcy5pbmRleC5pbnNlcnQobixlKX19LGdldE5lc3RlZFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmVzdGVkUHR9LGlzTm9uTmVzdGVkOmZ1bmN0aW9uKCl7dGhpcy5idWlsZEluZGV4KCk7Zm9yKHZhciB0PTA7dDx0aGlzLnJpbmdzLnNpemUoKTt0KyspZm9yKHZhciBlPXRoaXMucmluZ3MuZ2V0KHQpLG49ZS5nZXRDb29yZGluYXRlcygpLGk9dGhpcy5pbmRleC5xdWVyeShlLmdldEVudmVsb3BlSW50ZXJuYWwoKSkscj0wO3I8aS5zaXplKCk7cisrKXt2YXIgcz1pLmdldChyKSxvPXMuZ2V0Q29vcmRpbmF0ZXMoKTtpZihlIT09cyYmZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhzLmdldEVudmVsb3BlSW50ZXJuYWwoKSkpe3ZhciBhPWxzLmZpbmRQdE5vdE5vZGUobixzLHRoaXMuZ3JhcGgpO2lmKG51bGwhPT1hKXt2YXIgdT1oZS5pc1BvaW50SW5SaW5nKGEsbyk7aWYodSlyZXR1cm4gdGhpcy5uZXN0ZWRQdD1hLCExfX19cmV0dXJuITB9LGFkZDpmdW5jdGlvbih0KXt0aGlzLnJpbmdzLmFkZCh0KSx0aGlzLnRvdGFsRW52LmV4cGFuZFRvSW5jbHVkZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFzfX0pLGUodXMucHJvdG90eXBlLHtnZXRFcnJvclR5cGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lcnJvclR5cGV9LGdldE1lc3NhZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdXMuZXJyTXNnW3RoaXMuZXJyb3JUeXBlXX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PVwiXCI7cmV0dXJuIG51bGwhPT10aGlzLnB0JiYodD1cIiBhdCBvciBuZWFyIHBvaW50IFwiK3RoaXMucHQpLHRoaXMuZ2V0TWVzc2FnZSgpK3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVzfX0pLHVzLkVSUk9SPTAsdXMuUkVQRUFURURfUE9JTlQ9MSx1cy5IT0xFX09VVFNJREVfU0hFTEw9Mix1cy5ORVNURURfSE9MRVM9Myx1cy5ESVNDT05ORUNURURfSU5URVJJT1I9NCx1cy5TRUxGX0lOVEVSU0VDVElPTj01LHVzLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT049Nix1cy5ORVNURURfU0hFTExTPTcsdXMuRFVQTElDQVRFX1JJTkdTPTgsdXMuVE9PX0ZFV19QT0lOVFM9OSx1cy5JTlZBTElEX0NPT1JESU5BVEU9MTAsdXMuUklOR19OT1RfQ0xPU0VEPTExLHVzLmVyck1zZz1bXCJUb3BvbG9neSBWYWxpZGF0aW9uIEVycm9yXCIsXCJSZXBlYXRlZCBQb2ludFwiLFwiSG9sZSBsaWVzIG91dHNpZGUgc2hlbGxcIixcIkhvbGVzIGFyZSBuZXN0ZWRcIixcIkludGVyaW9yIGlzIGRpc2Nvbm5lY3RlZFwiLFwiU2VsZi1pbnRlcnNlY3Rpb25cIixcIlJpbmcgU2VsZi1pbnRlcnNlY3Rpb25cIixcIk5lc3RlZCBzaGVsbHNcIixcIkR1cGxpY2F0ZSBSaW5nc1wiLFwiVG9vIGZldyBkaXN0aW5jdCBwb2ludHMgaW4gZ2VvbWV0cnkgY29tcG9uZW50XCIsXCJJbnZhbGlkIENvb3JkaW5hdGVcIixcIlJpbmcgaXMgbm90IGNsb3NlZFwiXSxlKGxzLnByb3RvdHlwZSx7Y2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHQubGVuZ3RoO2UrKylpZighbHMuaXNWYWxpZCh0W2VdKSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuSU5WQUxJRF9DT09SRElOQVRFLHRbZV0pLG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8bi5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldEludGVyaW9yUmluZ04oZSkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9fSxjaGVja0hvbGVzTm90TmVzdGVkOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBhcyhlKSxpPTA7aTx0LmdldE51bUludGVyaW9yUmluZygpO2krKyl7dmFyIHI9dC5nZXRJbnRlcmlvclJpbmdOKGkpO24uYWRkKHIpfXZhciBzPW4uaXNOb25OZXN0ZWQoKTtzfHwodGhpcy52YWxpZEVycj1uZXcgdXModXMuTkVTVEVEX0hPTEVTLG4uZ2V0TmVzdGVkUG9pbnQoKSkpfSxjaGVja0NvbnNpc3RlbnRBcmVhOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBvcyh0KSxuPWUuaXNOb2RlQ29uc2lzdGVudEFyZWEoKTtyZXR1cm4gbj92b2lkKGUuaGFzRHVwbGljYXRlUmluZ3MoKSYmKHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkRVUExJQ0FURV9SSU5HUyxlLmdldEludmFsaWRQb2ludCgpKSkpOih0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5TRUxGX0lOVEVSU0VDVElPTixlLmdldEludmFsaWRQb2ludCgpKSxudWxsKX0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNoZWNrVmFsaWQodGhpcy5wYXJlbnRHZW9tZXRyeSksbnVsbD09PXRoaXMudmFsaWRFcnJ9LGNoZWNrU2hlbGxJbnNpZGVIb2xlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldENvb3JkaW5hdGVzKCkscj1lLmdldENvb3JkaW5hdGVzKCkscz1scy5maW5kUHROb3ROb2RlKGksZSxuKTtpZihudWxsIT09cyl7dmFyIG89aGUuaXNQb2ludEluUmluZyhzLHIpO2lmKCFvKXJldHVybiBzfXZhciBhPWxzLmZpbmRQdE5vdE5vZGUocix0LG4pO2lmKG51bGwhPT1hKXt2YXIgdT1oZS5pc1BvaW50SW5SaW5nKGEsaSk7cmV0dXJuIHU/YTpudWxsfXJldHVybiBmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwicG9pbnRzIGluIHNoZWxsIGFuZCBob2xlIGFwcGVhciB0byBiZSBlcXVhbFwiKSxudWxsfSxjaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1Jpbmcobi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGNoZWNrQ29ubmVjdGVkSW50ZXJpb3JzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBLcih0KTtlLmlzSW50ZXJpb3JzQ29ubmVjdGVkKCl8fCh0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ESVNDT05ORUNURURfSU5URVJJT1IsZS5nZXRDb29yZGluYXRlKCkpKX0sY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgYXQsbj0hMCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKG4pbj0hMTtlbHNle2lmKGUuY29udGFpbnMoci5jb29yZCkpcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlJJTkdfU0VMRl9JTlRFUlNFQ1RJT04sci5jb29yZCksbnVsbDtlLmFkZChyLmNvb3JkKX19fSxjaGVja0hvbGVzSW5TaGVsbDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldEV4dGVyaW9yUmluZygpLGk9bmV3IGlzKG4pLHI9MDtyPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cisrKXt2YXIgcz10LmdldEludGVyaW9yUmluZ04ociksbz1scy5maW5kUHROb3ROb2RlKHMuZ2V0Q29vcmRpbmF0ZXMoKSxuLGUpO2lmKG51bGw9PT1vKXJldHVybiBudWxsO3ZhciBhPSFpLmlzSW5zaWRlKG8pO2lmKGEpcmV0dXJuIHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkhPTEVfT1VUU0lERV9TSEVMTCxvKSxudWxsfX0sY2hlY2tUb29GZXdQb2ludHM6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaGFzVG9vRmV3UG9pbnRzKCk/KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlRPT19GRVdfUE9JTlRTLHQuZ2V0SW52YWxpZFBvaW50KCkpLG51bGwpOnZvaWQgMH0sZ2V0VmFsaWRhdGlvbkVycm9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLnBhcmVudEdlb21ldHJ5KSx0aGlzLnZhbGlkRXJyfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUHQpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgbj1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhuLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKG4pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciBpPW5ldyAkbigwLG4pO2lmKHRoaXMuY2hlY2tUb29GZXdQb2ludHMoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIHI9bmV3IGFlO2kuY29tcHV0ZVNlbGZOb2RlcyhyLCEwLCEwKSx0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3MoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgcz1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhzLmdldENvb3JkaW5hdGVzKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3ZhciBpPW5ldyAkbigwLHMpO3RoaXMuY2hlY2tUb29GZXdQb2ludHMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFR0KXt2YXIgbz1hcmd1bWVudHNbMF07aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhvKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobyksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAsbyk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKSxudWxsIT09dGhpcy52YWxpZEVycikpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChvLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tIb2xlc05vdE5lc3RlZChvLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE90KXtmb3IodmFyIGE9YXJndW1lbnRzWzBdLHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyhsKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ2xvc2VkUmluZ3MobCksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9dmFyIGk9bmV3ICRuKDAsYSk7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrQ29uc2lzdGVudEFyZWEoaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYoIXRoaXMuaXNTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZCYmKHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKSxudWxsIT09dGhpcy52YWxpZEVycikpcmV0dXJuIG51bGw7Zm9yKHZhciB1PTA7dTxhLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBsPWEuZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tIb2xlc0luU2hlbGwobCxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1mb3IodmFyIHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKGwsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9aWYodGhpcy5jaGVja1NoZWxsc05vdE5lc3RlZChhLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO3RoaXMuY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnMoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGZ0KWZvcih2YXIgaD1hcmd1bWVudHNbMF0sdT0wO3U8aC5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgYz1oLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrVmFsaWQoYyksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGx9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBmPWFyZ3VtZW50c1swXTtpZih0aGlzLnZhbGlkRXJyPW51bGwsZi5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYoZiBpbnN0YW5jZW9mIEx0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBQdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgYnQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFN0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBUdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgT3QpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2V7aWYoIShmIGluc3RhbmNlb2YgZnQpKXRocm93IG5ldyBVbnN1cHBvcnRlZE9wZXJhdGlvbkV4Y2VwdGlvbihmLmdldENsYXNzKCkuZ2V0TmFtZSgpKTt0aGlzLmNoZWNrVmFsaWQoZil9fX0sc2V0U2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPXR9LGNoZWNrU2hlbGxOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0RXh0ZXJpb3JSaW5nKCkscz1yLmdldENvb3JkaW5hdGVzKCksbz1scy5maW5kUHROb3ROb2RlKGkscixuKTtpZihudWxsPT09bylyZXR1cm4gbnVsbDt2YXIgYT1oZS5pc1BvaW50SW5SaW5nKG8scyk7aWYoIWEpcmV0dXJuIG51bGw7aWYoZS5nZXROdW1JbnRlcmlvclJpbmcoKTw9MClyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuTkVTVEVEX1NIRUxMUyxvKSxudWxsO2Zvcih2YXIgdT1udWxsLGw9MDtsPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7bCsrKXt2YXIgaD1lLmdldEludGVyaW9yUmluZ04obCk7aWYodT10aGlzLmNoZWNrU2hlbGxJbnNpZGVIb2xlKHQsaCxuKSxudWxsPT09dSlyZXR1cm4gbnVsbH10aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfU0hFTExTLHUpfSxjaGVja0Nsb3NlZFJpbmdzOmZ1bmN0aW9uKHQpe2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspaWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRJbnRlcmlvclJpbmdOKGUpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH0sY2hlY2tDbG9zZWRSaW5nOmZ1bmN0aW9uKHQpe2lmKCF0LmlzQ2xvc2VkKCkpe3ZhciBlPW51bGw7dC5nZXROdW1Qb2ludHMoKT49MSYmKGU9dC5nZXRDb29yZGluYXRlTigwKSksdGhpcy52YWxpZEVycj1uZXcgdXModXMuUklOR19OT1RfQ0xPU0VELGUpfX0sY2hlY2tTaGVsbHNOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKylmb3IodmFyIGk9dC5nZXRHZW9tZXRyeU4obikscj1pLmdldEV4dGVyaW9yUmluZygpLHM9MDtzPHQuZ2V0TnVtR2VvbWV0cmllcygpO3MrKylpZihuIT09cyl7dmFyIG89dC5nZXRHZW9tZXRyeU4ocyk7aWYodGhpcy5jaGVja1NoZWxsTm90TmVzdGVkKHIsbyxlKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxzfX0pLGxzLmZpbmRQdE5vdE5vZGU9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uLmZpbmRFZGdlKGUpLHI9aS5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLHM9MDtzPHQubGVuZ3RoO3MrKyl7dmFyIG89dFtzXTtpZighci5pc0ludGVyc2VjdGlvbihvKSlyZXR1cm4gb31yZXR1cm4gbnVsbH0sbHMuaXNWYWxpZD1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGxzKHQpO3JldHVybiBlLmlzVmFsaWQoKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihuLngpPyExOnIuaXNJbmZpbml0ZShuLngpPyExOnIuaXNOYU4obi55KT8hMTohci5pc0luZmluaXRlKG4ueSl9fTt2YXIgYm89T2JqZWN0LmZyZWV6ZSh7SXNWYWxpZE9wOmxzfSksT289T2JqZWN0LmZyZWV6ZSh7Qm91bmRhcnlPcDpkdCxJc1NpbXBsZU9wOkdpLGJ1ZmZlcjpDbyxkaXN0YW5jZTpTbyxsaW5lbWVyZ2U6d28sb3ZlcmxheTpMbyxwb2x5Z29uaXplOlJvLHJlbGF0ZTpUbyx1bmlvbjpQbyx2YWxpZDpib30pO2goaHMsX3QuQ29vcmRpbmF0ZU9wZXJhdGlvbiksZShocy5wcm90b3R5cGUse2VkaXRDb29yZGluYXRlczpmdW5jdGlvbih0LGUpe2lmKDA9PT10Lmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIG49bmV3IEFycmF5KHQubGVuZ3RoKS5maWxsKG51bGwpLGk9MDtpPHQubGVuZ3RoO2krKyl7dmFyIHI9bmV3IGcodFtpXSk7dGhpcy50YXJnZXRQTS5tYWtlUHJlY2lzZShyKSxuW2ldPXJ9dmFyIHM9bmV3IE4obiwhMSksbz1zLnRvQ29vcmRpbmF0ZUFycmF5KCksYT0wO2UgaW5zdGFuY2VvZiBTdCYmKGE9MiksZSBpbnN0YW5jZW9mIGJ0JiYoYT00KTt2YXIgdT1uO3JldHVybiB0aGlzLnJlbW92ZUNvbGxhcHNlZCYmKHU9bnVsbCksby5sZW5ndGg8YT91Om99LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhzfX0pLGUoY3MucHJvdG90eXBlLHtmaXhQb2x5Z29uYWxUb3BvbG9neTpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChlPXRoaXMuY2hhbmdlUE0odCx0aGlzLnRhcmdldFBNKSk7dmFyIG49ZS5idWZmZXIoMCksaT1uO3JldHVybiB0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsfHwoaT10LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeShuKSksaX0scmVkdWNlUG9pbnR3aXNlOmZ1bmN0aW9uKHQpe3ZhciBlPW51bGw7aWYodGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbCl7dmFyIG49dGhpcy5jcmVhdGVGYWN0b3J5KHQuZ2V0RmFjdG9yeSgpLHRoaXMudGFyZ2V0UE0pO2U9bmV3IF90KG4pfWVsc2UgZT1uZXcgX3Q7dmFyIGk9dGhpcy5yZW1vdmVDb2xsYXBzZWQ7dC5nZXREaW1lbnNpb24oKT49MiYmKGk9ITApO3ZhciByPWUuZWRpdCh0LG5ldyBocyh0aGlzLnRhcmdldFBNLGkpKTtyZXR1cm4gcn0sY2hhbmdlUE06ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmNyZWF0ZUVkaXRvcih0LmdldEZhY3RvcnkoKSxlKTtyZXR1cm4gbi5lZGl0KHQsbmV3IF90Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbil9LHNldFJlbW92ZUNvbGxhcHNlZENvbXBvbmVudHM6ZnVuY3Rpb24odCl7dGhpcy5yZW1vdmVDb2xsYXBzZWQ9dH0sY3JlYXRlRmFjdG9yeTpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBpZShlLHQuZ2V0U1JJRCgpLHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpKTtyZXR1cm4gbn0sc2V0Q2hhbmdlUHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbD10fSxyZWR1Y2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZWR1Y2VQb2ludHdpc2UodCk7cmV0dXJuIHRoaXMuaXNQb2ludHdpc2U/ZTpSKGUsUnQpP2UuaXNWYWxpZCgpP2U6dGhpcy5maXhQb2x5Z29uYWxUb3BvbG9neShlKTplfSxzZXRQb2ludHdpc2U6ZnVuY3Rpb24odCl7dGhpcy5pc1BvaW50d2lzZT10fSxjcmVhdGVFZGl0b3I6ZnVuY3Rpb24odCxlKXtpZih0LmdldFByZWNpc2lvbk1vZGVsKCk9PT1lKXJldHVybiBuZXcgX3Q7dmFyIG49dGhpcy5jcmVhdGVGYWN0b3J5KHQsZSksaT1uZXcgX3Qobik7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNzfX0pLGNzLnJlZHVjZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjcyhlKTtyZXR1cm4gbi5yZWR1Y2UodCl9LGNzLnJlZHVjZVBvaW50d2lzZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjcyhlKTtyZXR1cm4gbi5zZXRQb2ludHdpc2UoITApLG4ucmVkdWNlKHQpfTt2YXIgX289T2JqZWN0LmZyZWV6ZSh7R2VvbWV0cnlQcmVjaXNpb25SZWR1Y2VyOmNzfSk7ZShmcy5wcm90b3R5cGUse3NpbXBsaWZ5U2VjdGlvbjpmdW5jdGlvbih0LGUpe2lmKHQrMT09PWUpcmV0dXJuIG51bGw7dGhpcy5zZWcucDA9dGhpcy5wdHNbdF0sdGhpcy5zZWcucDE9dGhpcy5wdHNbZV07Zm9yKHZhciBuPS0xLGk9dCxyPXQrMTtlPnI7cisrKXt2YXIgcz10aGlzLnNlZy5kaXN0YW5jZSh0aGlzLnB0c1tyXSk7cz5uJiYobj1zLGk9cil9aWYobjw9dGhpcy5kaXN0YW5jZVRvbGVyYW5jZSlmb3IodmFyIHI9dCsxO2U+cjtyKyspdGhpcy51c2VQdFtyXT0hMTtlbHNlIHRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsaSksdGhpcy5zaW1wbGlmeVNlY3Rpb24oaSxlKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeTpmdW5jdGlvbigpe3RoaXMudXNlUHQ9bmV3IEFycmF5KHRoaXMucHRzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IodmFyIHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy51c2VQdFt0XT0hMDt0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMucHRzLmxlbmd0aC0xKTtmb3IodmFyIGU9bmV3IE4sdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLnVzZVB0W3RdJiZlLmFkZChuZXcgZyh0aGlzLnB0c1t0XSkpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZzfX0pLGZzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGZzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uc2ltcGxpZnkoKX0sZShncy5wcm90b3R5cGUse3NldEVuc3VyZVZhbGlkOmZ1bmN0aW9uKHQpe3RoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PXR9LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmlzRW1wdHkoKT90aGlzLmlucHV0R2VvbS5jb3B5KCk6bmV3IGRzKHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5LHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSl9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKDA+dCl0aHJvdyBuZXcgaShcIlRvbGVyYW5jZSBtdXN0IGJlIG5vbi1uZWdhdGl2ZVwiKTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdzfX0pLGdzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGdzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX0saChkcyx4ZSksZShkcy5wcm90b3R5cGUse3RyYW5zZm9ybVBvbHlnb246ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtUG9seWdvbi5jYWxsKHRoaXMsdCxlKTtyZXR1cm4gZSBpbnN0YW5jZW9mIE90P246dGhpcy5jcmVhdGVWYWxpZEFyZWEobil9LGNyZWF0ZVZhbGlkQXJlYTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k/dC5idWZmZXIoMCk6dH0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCksaT1udWxsO3JldHVybiBpPTA9PT1uLmxlbmd0aD9uZXcgQXJyYXkoMCkuZmlsbChudWxsKTpmcy5zaW1wbGlmeShuLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSx0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtTGluZWFyUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPWUgaW5zdGFuY2VvZiBUdCxpPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1MaW5lYXJSaW5nLmNhbGwodGhpcyx0LGUpO3JldHVybiFufHxpIGluc3RhbmNlb2YgYnQ/aTpudWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkc319KSxncy5EUFRyYW5zZm9ybWVyPWRzLGgocHMsY2UpLGUocHMucHJvdG90eXBlLHtnZXRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluZGV4fSxnZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHBzfX0pLGUodnMucHJvdG90eXBlLHthZGRUb1Jlc3VsdDpmdW5jdGlvbih0KXt0aGlzLnJlc3VsdFNlZ3MuYWRkKHQpfSxhc0xpbmVTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpKX0sZ2V0UmVzdWx0U2l6ZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMucmVzdWx0U2Vncy5zaXplKCk7cmV0dXJuIDA9PT10PzA6dCsxfSxnZXRQYXJlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lfSxnZXRTZWdtZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnNlZ3NbdF19LGdldFBhcmVudENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyZW50TGluZS5nZXRDb29yZGluYXRlcygpfSxnZXRNaW5pbXVtU2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbmltdW1TaXplfSxhc0xpbmVhclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpKX0sZ2V0U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdzfSxpbml0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCk7dGhpcy5zZWdzPW5ldyBBcnJheSh0Lmxlbmd0aC0xKS5maWxsKG51bGwpO2Zvcih2YXIgZT0wO2U8dC5sZW5ndGgtMTtlKyspe3ZhciBuPW5ldyBwcyh0W2VdLHRbZSsxXSx0aGlzLnBhcmVudExpbmUsZSk7dGhpcy5zZWdzW2VdPW59fSxnZXRSZXN1bHRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB2cy5leHRyYWN0Q29vcmRpbmF0ZXModGhpcy5yZXN1bHRTZWdzKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdnN9fSksdnMuZXh0cmFjdENvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkrMSkuZmlsbChudWxsKSxuPW51bGwsaT0wO2k8dC5zaXplKCk7aSsrKW49dC5nZXQoaSksZVtpXT1uLnAwO3JldHVybiBlW2UubGVuZ3RoLTFdPW4ucDEsZX0sZShtcy5wcm90b3R5cGUse3JlbW92ZTpmdW5jdGlvbih0KXt0aGlzLmluZGV4LnJlbW92ZShuZXcgQyh0LnAwLHQucDEpLHQpfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHZzKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10LmdldFNlZ21lbnRzKCksbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1lW25dO3RoaXMuYWRkKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIHI9YXJndW1lbnRzWzBdO3RoaXMuaW5kZXguaW5zZXJ0KG5ldyBDKHIucDAsci5wMSkscil9fSxxdWVyeTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQyh0LnAwLHQucDEpLG49bmV3IHlzKHQpO3RoaXMuaW5kZXgucXVlcnkoZSxuKTt2YXIgaT1uLmdldEl0ZW1zKCk7cmV0dXJuIGl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1zfX0pLGUoeXMucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDtDLmludGVyc2VjdHMoZS5wMCxlLnAxLHRoaXMucXVlcnlTZWcucDAsdGhpcy5xdWVyeVNlZy5wMSkmJnRoaXMuaXRlbXMuYWRkKHQpfSxnZXRJdGVtczpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW1zfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlzfX0pLGUoeHMucHJvdG90eXBlLHtmbGF0dGVuOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5saW5lUHRzW3RdLGk9dGhpcy5saW5lUHRzW2VdLHI9bmV3IGNlKG4saSk7cmV0dXJuIHRoaXMucmVtb3ZlKHRoaXMubGluZSx0LGUpLHRoaXMub3V0cHV0SW5kZXguYWRkKHIpLHJ9LGhhc0JhZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMuaGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uKG4pPyEwOiEhdGhpcy5oYXNCYWRJbnB1dEludGVyc2VjdGlvbih0LGUsbil9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0sc2ltcGxpZnlTZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtuKz0xO3ZhciBpPW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHQrMT09PWUpe3ZhciByPXRoaXMubGluZS5nZXRTZWdtZW50KHQpO3JldHVybiB0aGlzLmxpbmUuYWRkVG9SZXN1bHQociksbnVsbH12YXIgcz0hMDtpZih0aGlzLmxpbmUuZ2V0UmVzdWx0U2l6ZSgpPHRoaXMubGluZS5nZXRNaW5pbXVtU2l6ZSgpKXt2YXIgbz1uKzE7bzx0aGlzLmxpbmUuZ2V0TWluaW11bVNpemUoKSYmKHM9ITEpfXZhciBhPW5ldyBBcnJheSgxKS5maWxsKG51bGwpLHU9dGhpcy5maW5kRnVydGhlc3RQb2ludCh0aGlzLmxpbmVQdHMsdCxlLGEpO2FbMF0+dGhpcy5kaXN0YW5jZVRvbGVyYW5jZSYmKHM9ITEpO3ZhciBsPW5ldyBjZTtpZihsLnAwPXRoaXMubGluZVB0c1t0XSxsLnAxPXRoaXMubGluZVB0c1tlXSxpWzBdPXQsaVsxXT1lLHRoaXMuaGFzQmFkSW50ZXJzZWN0aW9uKHRoaXMubGluZSxpLGwpJiYocz0hMSkscyl7dmFyIHI9dGhpcy5mbGF0dGVuKHQsZSk7cmV0dXJuIHRoaXMubGluZS5hZGRUb1Jlc3VsdChyKSxudWxsfXRoaXMuc2ltcGxpZnlTZWN0aW9uKHQsdSxuKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbih1LGUsbil9LGhhc0JhZE91dHB1dEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5vdXRwdXRJbmRleC5xdWVyeSh0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24oaSx0KSlyZXR1cm4hMH1yZXR1cm4hMX0sZmluZEZ1cnRoZXN0UG9pbnQ6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGNlO3IucDA9dFtlXSxyLnAxPXRbbl07Zm9yKHZhciBzPS0xLG89ZSxhPWUrMTtuPmE7YSsrKXt2YXIgdT10W2FdLGw9ci5kaXN0YW5jZSh1KTtsPnMmJihzPWwsbz1hKX1yZXR1cm4gaVswXT1zLG99LHNpbXBsaWZ5OmZ1bmN0aW9uKHQpe3RoaXMubGluZT10LHRoaXMubGluZVB0cz10LmdldFBhcmVudENvb3JkaW5hdGVzKCksdGhpcy5zaW1wbGlmeVNlY3Rpb24oMCx0aGlzLmxpbmVQdHMubGVuZ3RoLTEsMCl9LHJlbW92ZTpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPWU7bj5pO2krKyl7dmFyIHI9dC5nZXRTZWdtZW50KGkpO3RoaXMuaW5wdXRJbmRleC5yZW1vdmUocil9fSxoYXNJbnRlcmlvckludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24odC5wMCx0LnAxLGUucDAsZS5wMSksdGhpcy5saS5pc0ludGVyaW9ySW50ZXJzZWN0aW9uKCl9LGhhc0JhZElucHV0SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9dGhpcy5pbnB1dEluZGV4LnF1ZXJ5KG4pLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihzLG4pKXtpZih4cy5pc0luTGluZVNlY3Rpb24odCxlLHMpKWNvbnRpbnVlO3JldHVybiEwfX1yZXR1cm4hMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geHN9fSkseHMuaXNJbkxpbmVTZWN0aW9uPWZ1bmN0aW9uKHQsZSxuKXtpZihuLmdldFBhcmVudCgpIT09dC5nZXRQYXJlbnQoKSlyZXR1cm4hMTt2YXIgaT1uLmdldEluZGV4KCk7cmV0dXJuIGk+PWVbMF0mJmk8ZVsxXX0sZShFcy5wcm90b3R5cGUse3NldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0sc2ltcGxpZnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5pbnB1dEluZGV4LmFkZChlLm5leHQoKSk7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPW5ldyB4cyh0aGlzLmlucHV0SW5kZXgsdGhpcy5vdXRwdXRJbmRleCk7bi5zZXREaXN0YW5jZVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlVG9sZXJhbmNlKSxuLnNpbXBsaWZ5KGUubmV4dCgpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVzfX0pLGUoSXMucHJvdG90eXBlLHtnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbigpe2lmKHRoaXMuaW5wdXRHZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5pbnB1dEdlb20uY29weSgpO3RoaXMubGluZXN0cmluZ01hcD1uZXcgdGUsdGhpcy5pbnB1dEdlb20uYXBwbHkobmV3IENzKHRoaXMpKSx0aGlzLmxpbmVTaW1wbGlmaWVyLnNpbXBsaWZ5KHRoaXMubGluZXN0cmluZ01hcC52YWx1ZXMoKSk7dmFyIHQ9bmV3IE5zKHRoaXMubGluZXN0cmluZ01hcCkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKTtyZXR1cm4gdH0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYoMD50KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMubGluZVNpbXBsaWZpZXIuc2V0RGlzdGFuY2VUb2xlcmFuY2UodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElzfX0pLElzLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IElzKHQpO3JldHVybiBuLnNldERpc3RhbmNlVG9sZXJhbmNlKGUpLG4uZ2V0UmVzdWx0R2VvbWV0cnkoKX0saChOcyx4ZSksZShOcy5wcm90b3R5cGUse3RyYW5zZm9ybUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PXQuc2l6ZSgpKXJldHVybiBudWxsO2lmKGUgaW5zdGFuY2VvZiBTdCl7dmFyIG49dGhpcy5saW5lc3RyaW5nTWFwLmdldChlKTtyZXR1cm4gdGhpcy5jcmVhdGVDb29yZGluYXRlU2VxdWVuY2Uobi5nZXRSZXN1bHRDb29yZGluYXRlcygpKX1yZXR1cm4geGUucHJvdG90eXBlLnRyYW5zZm9ybUNvb3JkaW5hdGVzLmNhbGwodGhpcyx0LGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBOc319KSxlKENzLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBTdCl7dmFyIGU9dDtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgbj1lLmlzQ2xvc2VkKCk/NDoyLGk9bmV3IHZzKGUsbik7dGhpcy50cHMubGluZXN0cmluZ01hcC5wdXQoZSxpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDc319KSxJcy5MaW5lU3RyaW5nVHJhbnNmb3JtZXI9TnMsSXMuTGluZVN0cmluZ01hcEJ1aWxkZXJGaWx0ZXI9Q3M7dmFyIE1vPU9iamVjdC5mcmVlemUoe0RvdWdsYXNQZXVja2VyU2ltcGxpZmllcjpncyxUb3BvbG9neVByZXNlcnZpbmdTaW1wbGlmaWVyOklzfSk7ZShTcy5wcm90b3R5cGUse3NwbGl0QXQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5taW5pbXVtTGVuL3RoaXMuc2VnTGVuO2lmKHQuZGlzdGFuY2UodGhpcy5zZWcucDApPHRoaXMubWluaW11bUxlbilyZXR1cm4gdGhpcy5zcGxpdFB0PXRoaXMuc2VnLnBvaW50QWxvbmcoZSksbnVsbDtpZih0LmRpc3RhbmNlKHRoaXMuc2VnLnAxKTx0aGlzLm1pbmltdW1MZW4pcmV0dXJuIHRoaXMuc3BsaXRQdD1Tcy5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLnNlZyxlKSxudWxsO3RoaXMuc3BsaXRQdD10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPXRoaXMuZ2V0Q29uc3RyYWluZWRMZW5ndGgobikscz1yL3RoaXMuc2VnTGVuO2kuZXF1YWxzMkQodGhpcy5zZWcucDApP3RoaXMuc3BsaXRQdD10aGlzLnNlZy5wb2ludEFsb25nKHMpOnRoaXMuc3BsaXRQdD1Tcy5wb2ludEFsb25nUmV2ZXJzZSh0aGlzLnNlZyxzKX19LHNldE1pbmltdW1MZW5ndGg6ZnVuY3Rpb24odCl7dGhpcy5taW5pbXVtTGVuPXR9LGdldENvbnN0cmFpbmVkTGVuZ3RoOmZ1bmN0aW9uKHQpe3JldHVybiB0PHRoaXMubWluaW11bUxlbj90aGlzLm1pbmltdW1MZW46dH0sZ2V0U3BsaXRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNwbGl0UHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNzfX0pLFNzLnBvaW50QWxvbmdSZXZlcnNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGc7cmV0dXJuIG4ueD10LnAxLngtZSoodC5wMS54LXQucDAueCksbi55PXQucDEueS1lKih0LnAxLnktdC5wMC55KSxufSxlKHdzLnByb3RvdHlwZSx7ZmluZFNwbGl0UG9pbnQ6ZnVuY3Rpb24odCxlKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdzfX0pLGUoTHMucHJvdG90eXBlLHtmaW5kU3BsaXRQb2ludDpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TGluZVNlZ21lbnQoKSxpPW4uZ2V0TGVuZ3RoKCkscj1pLzIscz1uZXcgU3Mobiksbz1Mcy5wcm9qZWN0ZWRTcGxpdFBvaW50KHQsZSksYT0yKm8uZGlzdGFuY2UoZSkqLjgsdT1hO3JldHVybiB1PnImJih1PXIpLHMuc2V0TWluaW11bUxlbmd0aCh1KSxzLnNwbGl0QXQobykscy5nZXRTcGxpdFBvaW50KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3dzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHN9fSksTHMucHJvamVjdGVkU3BsaXRQb2ludD1mdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0TGluZVNlZ21lbnQoKSxpPW4ucHJvamVjdChlKTtyZXR1cm4gaX0sZShScy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFJzfX0pLFJzLnRyaUFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybihlLngtdC54KSoobi55LXQueSktKGUueS10LnkpKihuLngtdC54KX0sUnMuaXNJbkNpcmNsZURETm9ybWFsaXplZD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1fLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3QoaS54KSxzPV8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChpLnkpLG89Xy52YWx1ZU9mKGUueCkuc2VsZlN1YnRyYWN0KGkueCksYT1fLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QoaS55KSx1PV8udmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdChpLngpLGw9Xy52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KGkueSksaD1yLm11bHRpcGx5KGEpLnNlbGZTdWJ0cmFjdChvLm11bHRpcGx5KHMpKSxjPW8ubXVsdGlwbHkobCkuc2VsZlN1YnRyYWN0KHUubXVsdGlwbHkoYSkpLGY9dS5tdWx0aXBseShzKS5zZWxmU3VidHJhY3Qoci5tdWx0aXBseShsKSksZz1yLm11bHRpcGx5KHIpLnNlbGZBZGQocy5tdWx0aXBseShzKSksZD1vLm11bHRpcGx5KG8pLnNlbGZBZGQoYS5tdWx0aXBseShhKSkscD11Lm11bHRpcGx5KHUpLnNlbGZBZGQobC5tdWx0aXBseShsKSksdj1nLnNlbGZNdWx0aXBseShjKS5zZWxmQWRkKGQuc2VsZk11bHRpcGx5KGYpKS5zZWxmQWRkKHAuc2VsZk11bHRpcGx5KGgpKSxtPXYuZG91YmxlVmFsdWUoKT4wO3JldHVybiBtfSxScy5jaGVja1JvYnVzdEluQ2lyY2xlPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPVJzLmlzSW5DaXJjbGVOb25Sb2J1c3QodCxlLG4saSkscz1Scy5pc0luQ2lyY2xlRERTbG93KHQsZSxuLGkpLG89UnMuaXNJbkNpcmNsZUNDKHQsZSxuLGkpLGE9Y2kuY2lyY3VtY2VudHJlKHQsZSxuKTtBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS10LmRpc3RhbmNlKGEpKS90LmRpc3RhbmNlKGEpKSxyPT09cyYmcj09PW98fChBLm91dC5wcmludGxuKFwiaW5DaXJjbGUgcm9idXN0bmVzcyBmYWlsdXJlIChkb3VibGUgcmVzdWx0ID0gXCIrcitcIiwgREQgcmVzdWx0ID0gXCIrcytcIiwgQ0MgcmVzdWx0ID0gXCIrbytcIilcIiksQS5vdXQucHJpbnRsbihzZS50b0xpbmVTdHJpbmcobmV3IEd0KFt0LGUsbixpXSkpKSxBLm91dC5wcmludGxuKFwiQ2lyY3VtY2VudHJlID0gXCIrc2UudG9Qb2ludChhKStcIiByYWRpdXMgPSBcIit0LmRpc3RhbmNlKGEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBhID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS90LmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBiID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS9lLmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKFwicCByYWRpdXMgZGlmZiBjID0gXCIrTWF0aC5hYnMoaS5kaXN0YW5jZShhKS9uLmRpc3RhbmNlKGEpLTEpKSxBLm91dC5wcmludGxuKCkpfSxScy5pc0luQ2lyY2xlRERGYXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8uc3FyKHQueCkuc2VsZkFkZChfLnNxcih0LnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdChlLG4saSkpLHM9Xy5zcXIoZS54KS5zZWxmQWRkKF8uc3FyKGUueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsbixpKSksbz1fLnNxcihuLngpLnNlbGZBZGQoXy5zcXIobi55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxlLGkpKSxhPV8uc3FyKGkueCkuc2VsZkFkZChfLnNxcihpLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LGUsbikpLHU9ci5zZWxmU3VidHJhY3Qocykuc2VsZkFkZChvKS5zZWxmU3VidHJhY3QoYSksbD11LmRvdWJsZVZhbHVlKCk+MDtyZXR1cm4gbH0sUnMuaXNJbkNpcmNsZUNDPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWNpLmNpcmN1bWNlbnRyZSh0LGUsbikscz10LmRpc3RhbmNlKHIpLG89aS5kaXN0YW5jZShyKS1zO3JldHVybiAwPj1vfSxScy5pc0luQ2lyY2xlTm9ybWFsaXplZD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LngtaS54LHM9dC55LWkueSxvPWUueC1pLngsYT1lLnktaS55LHU9bi54LWkueCxsPW4ueS1pLnksaD1yKmEtbypzLGM9bypsLXUqYSxmPXUqcy1yKmwsZz1yKnIrcypzLGQ9bypvK2EqYSxwPXUqdStsKmwsdj1nKmMrZCpmK3AqaDtyZXR1cm4gdj4wfSxScy5pc0luQ2lyY2xlRERTbG93PWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZihpLngpLHM9Xy52YWx1ZU9mKGkueSksbz1fLnZhbHVlT2YodC54KSxhPV8udmFsdWVPZih0LnkpLHU9Xy52YWx1ZU9mKGUueCksbD1fLnZhbHVlT2YoZS55KSxoPV8udmFsdWVPZihuLngpLGM9Xy52YWx1ZU9mKG4ueSksZj1vLm11bHRpcGx5KG8pLmFkZChhLm11bHRpcGx5KGEpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KHUsbCxoLGMscixzKSksZz11Lm11bHRpcGx5KHUpLmFkZChsLm11bHRpcGx5KGwpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSxoLGMscixzKSksZD1oLm11bHRpcGx5KGgpLmFkZChjLm11bHRpcGx5KGMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwscixzKSkscD1yLm11bHRpcGx5KHIpLmFkZChzLm11bHRpcGx5KHMpKS5tdWx0aXBseShScy50cmlBcmVhRERTbG93KG8sYSx1LGwsaCxjKSksdj1mLnN1YnRyYWN0KGcpLmFkZChkKS5zdWJ0cmFjdChwKSxtPXYuZG91YmxlVmFsdWUoKT4wO1xucmV0dXJuIG19LFJzLmlzSW5DaXJjbGVOb25Sb2J1c3Q9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9KHQueCp0LngrdC55KnQueSkqUnMudHJpQXJlYShlLG4saSktKGUueCplLngrZS55KmUueSkqUnMudHJpQXJlYSh0LG4saSkrKG4ueCpuLngrbi55Km4ueSkqUnMudHJpQXJlYSh0LGUsaSktKGkueCppLngraS55KmkueSkqUnMudHJpQXJlYSh0LGUsbik+MDtyZXR1cm4gcn0sUnMuaXNJbkNpcmNsZVJvYnVzdD1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gUnMuaXNJbkNpcmNsZU5vcm1hbGl6ZWQodCxlLG4saSl9LFJzLnRyaUFyZWFERFNsb3c9ZnVuY3Rpb24odCxlLG4saSxyLHMpe3JldHVybiBuLnN1YnRyYWN0KHQpLm11bHRpcGx5KHMuc3VidHJhY3QoZSkpLnN1YnRyYWN0KGkuc3VidHJhY3QoZSkubXVsdGlwbHkoci5zdWJ0cmFjdCh0KSkpfSxScy50cmlBcmVhRERGYXN0PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QodC54KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKG4ueSkuc2VsZlN1YnRyYWN0KHQueSkpLHI9Xy52YWx1ZU9mKGUueSkuc2VsZlN1YnRyYWN0KHQueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihuLngpLnNlbGZTdWJ0cmFjdCh0LngpKTtyZXR1cm4gaS5zZWxmU3VidHJhY3Qocil9LGUoVHMucHJvdG90eXBlLHtjaXJjbGVDZW50ZXI6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgVHModGhpcy5nZXRYKCksdGhpcy5nZXRZKCkpLGk9dGhpcy5iaXNlY3RvcihuLHQpLHI9dGhpcy5iaXNlY3Rvcih0LGUpLHM9bmV3IEYoaSxyKSxvPW51bGw7dHJ5e289bmV3IFRzKHMuZ2V0WCgpLHMuZ2V0WSgpKX1jYXRjaChpKXtpZighKGkgaW5zdGFuY2VvZiB3KSl0aHJvdyBpO0EuZXJyLnByaW50bG4oXCJhOiBcIituK1wiICBiOiBcIit0K1wiICBjOiBcIitlKSxBLmVyci5wcmludGxuKGkpfWZpbmFsbHl7fXJldHVybiBvfSxkb3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucC54KnQuZ2V0WCgpK3RoaXMucC55KnQuZ2V0WSgpfSxtYWduOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGguc3FydCh0aGlzLnAueCp0aGlzLnAueCt0aGlzLnAueSp0aGlzLnAueSl9LGdldFo6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnp9LGJpc2VjdG9yOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5nZXRYKCktdC5nZXRYKCksaT1lLmdldFkoKS10LmdldFkoKSxyPW5ldyBGKHQuZ2V0WCgpK24vMix0LmdldFkoKStpLzIsMSkscz1uZXcgRih0LmdldFgoKS1pK24vMix0LmdldFkoKStuK2kvMiwxKTtyZXR1cm4gbmV3IEYocixzKX0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5wLng9PT10LmdldFgoKSYmdGhpcy5wLnk9PT10LmdldFkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLnAuZGlzdGFuY2UoZS5nZXRDb29yZGluYXRlKCkpPG59fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucH0saXNJbkNpcmNsZTpmdW5jdGlvbih0LGUsbil7cmV0dXJuIFJzLmlzSW5DaXJjbGVSb2J1c3QodC5wLGUucCxuLnAsdGhpcy5wKX0saW50ZXJwb2xhdGVaVmFsdWU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0WCgpLHI9dC5nZXRZKCkscz1lLmdldFgoKS1pLG89bi5nZXRYKCktaSxhPWUuZ2V0WSgpLXIsdT1uLmdldFkoKS1yLGw9cyp1LW8qYSxoPXRoaXMuZ2V0WCgpLWksYz10aGlzLmdldFkoKS1yLGY9KHUqaC1vKmMpL2wsZz0oLWEqaCtzKmMpL2wsZD10LmdldFooKStmKihlLmdldFooKS10LmdldFooKSkrZyoobi5nZXRaKCktdC5nZXRaKCkpO3JldHVybiBkfSxtaWRQb2ludDpmdW5jdGlvbih0KXt2YXIgZT0odGhpcy5wLngrdC5nZXRYKCkpLzIsbj0odGhpcy5wLnkrdC5nZXRZKCkpLzIsaT0odGhpcy5wLnordC5nZXRaKCkpLzI7cmV0dXJuIG5ldyBUcyhlLG4saSl9LHJpZ2h0T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDQ1codC5kZXN0KCksdC5vcmlnKCkpfSxpc0NDVzpmdW5jdGlvbih0LGUpe3JldHVybih0LnAueC10aGlzLnAueCkqKGUucC55LXRoaXMucC55KS0odC5wLnktdGhpcy5wLnkpKihlLnAueC10aGlzLnAueCk+MH0sZ2V0WDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueH0sY3Jvc3NQcm9kdWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnAueCp0LmdldFkoKS10aGlzLnAueSp0LmdldFgoKX0sc2V0WjpmdW5jdGlvbih0KXt0aGlzLnAuej10fSx0aW1lczpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFRzKHQqdGhpcy5wLngsdCp0aGlzLnAueSl9LGNyb3NzOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueSwtdGhpcy5wLngpfSxsZWZ0T2Y6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaXNDQ1codC5vcmlnKCksdC5kZXN0KCkpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiUE9JTlQgKFwiK3RoaXMucC54K1wiIFwiK3RoaXMucC55K1wiKVwifSxzdWI6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueC10LmdldFgoKSx0aGlzLnAueS10LmdldFkoKSl9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGNsYXNzaWZ5OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcyxpPWUuc3ViKHQpLHI9bi5zdWIodCkscz1pLmNyb3NzUHJvZHVjdChyKTtyZXR1cm4gcz4wP1RzLkxFRlQ6MD5zP1RzLlJJR0hUOmkuZ2V0WCgpKnIuZ2V0WCgpPDB8fGkuZ2V0WSgpKnIuZ2V0WSgpPDA/VHMuQkVISU5EOmkubWFnbigpPHIubWFnbigpP1RzLkJFWU9ORDp0LmVxdWFscyhuKT9Ucy5PUklHSU46ZS5lcXVhbHMobik/VHMuREVTVElOQVRJT046VHMuQkVUV0VFTn0sc3VtOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModGhpcy5wLngrdC5nZXRYKCksdGhpcy5wLnkrdC5nZXRZKCkpfSxkaXN0YW5jZTpmdW5jdGlvbih0LGUpe3JldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coZS5nZXRYKCktdC5nZXRYKCksMikrTWF0aC5wb3coZS5nZXRZKCktdC5nZXRZKCksMikpfSxjaXJjdW1SYWRpdXNSYXRpbzpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY2lyY2xlQ2VudGVyKHQsZSksaT10aGlzLmRpc3RhbmNlKG4sdCkscj10aGlzLmRpc3RhbmNlKHRoaXMsdCkscz10aGlzLmRpc3RhbmNlKHQsZSk7cmV0dXJuIHI+cyYmKHI9cykscz10aGlzLmRpc3RhbmNlKGUsdGhpcykscj5zJiYocj1zKSxpL3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRzfX0pLFRzLmludGVycG9sYXRlWj1mdW5jdGlvbigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1lLmRpc3RhbmNlKG4pLHI9dC5kaXN0YW5jZShlKSxzPW4uei1lLnosbz1lLnorcyooci9pKTtyZXR1cm4gb31pZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLGg9YXJndW1lbnRzWzNdLGM9dS54LGY9dS55LGc9bC54LWMsZD1oLngtYyxwPWwueS1mLHY9aC55LWYsbT1nKnYtZCpwLHk9YS54LWMseD1hLnktZixFPSh2KnktZCp4KS9tLEk9KC1wKnkrZyp4KS9tLE49dS56K0UqKGwuei11LnopK0kqKGguei11LnopO3JldHVybiBOfX0sVHMuTEVGVD0wLFRzLlJJR0hUPTEsVHMuQkVZT05EPTIsVHMuQkVISU5EPTMsVHMuQkVUV0VFTj00LFRzLk9SSUdJTj01LFRzLkRFU1RJTkFUSU9OPTYsaChQcyxUcyksZShQcy5wcm90b3R5cGUse2dldENvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb25zdHJhaW50fSxzZXRPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9dH0sbWVyZ2U6ZnVuY3Rpb24odCl7dC5faXNPbkNvbnN0cmFpbnQmJih0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLmNvbnN0cmFpbnQ9dC5jb25zdHJhaW50KX0saXNPbkNvbnN0cmFpbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNPbkNvbnN0cmFpbnR9LHNldENvbnN0cmFpbnQ6ZnVuY3Rpb24odCl7dGhpcy5faXNPbkNvbnN0cmFpbnQ9ITAsdGhpcy5jb25zdHJhaW50PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBzfX0pLGUoYnMucHJvdG90eXBlLHtlcXVhbHNOb25PcmllbnRlZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lcXVhbHNPcmllbnRlZCh0KT8hMDohIXRoaXMuZXF1YWxzT3JpZW50ZWQodC5zeW0oKSl9LHRvTGluZVNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGNlKHRoaXMudmVydGV4LmdldENvb3JkaW5hdGUoKSx0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpfSxkZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub3JpZygpfSxvTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHR9LGVxdWFsc09yaWVudGVkOmZ1bmN0aW9uKHQpe3JldHVybiEoIXRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRCh0Lm9yaWcoKS5nZXRDb29yZGluYXRlKCkpfHwhdGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSkpfSxkTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCkuc3ltKCl9LGxQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dC5zeW0oKX0sclByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vTmV4dCgpfSxyb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90fSxvUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QubmV4dC5fcm90fSxzeW06ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90Ll9yb3R9LHNldE9yaWc6ZnVuY3Rpb24odCl7dGhpcy52ZXJ0ZXg9dH0sbE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLnJvdCgpfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9LGludlJvdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3Quc3ltKCl9LHNldERlc3Q6ZnVuY3Rpb24odCl7dGhpcy5zeW0oKS5zZXRPcmlnKHQpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZGVsZXRlOmZ1bmN0aW9uKCl7dGhpcy5fcm90PW51bGx9LG9yaWc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXh9LHJOZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0LmludlJvdCgpfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PXRoaXMudmVydGV4LmdldENvb3JkaW5hdGUoKSxlPXRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKTtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKHQsZSl9LGlzTGl2ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5fcm90fSxnZXRQcmltYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZygpLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8odGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKTw9MD90aGlzOnRoaXMuc3ltKCl9LGRQcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW52Um90KCkub05leHQoKS5pbnZSb3QoKX0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYnN9fSksYnMubWFrZUVkZ2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgYnMsaT1uZXcgYnMscj1uZXcgYnMscz1uZXcgYnM7bi5fcm90PWksaS5fcm90PXIsci5fcm90PXMscy5fcm90PW4sbi5zZXROZXh0KG4pLGkuc2V0TmV4dChzKSxyLnNldE5leHQocikscy5zZXROZXh0KGkpO3ZhciBvPW47cmV0dXJuIG8uc2V0T3JpZyh0KSxvLnNldERlc3QoZSksb30sYnMuc3dhcD1mdW5jdGlvbih0KXt2YXIgZT10Lm9QcmV2KCksbj10LnN5bSgpLm9QcmV2KCk7YnMuc3BsaWNlKHQsZSksYnMuc3BsaWNlKHQuc3ltKCksbiksYnMuc3BsaWNlKHQsZS5sTmV4dCgpKSxicy5zcGxpY2UodC5zeW0oKSxuLmxOZXh0KCkpLHQuc2V0T3JpZyhlLmRlc3QoKSksdC5zZXREZXN0KG4uZGVzdCgpKX0sYnMuc3BsaWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5vTmV4dCgpLnJvdCgpLGk9ZS5vTmV4dCgpLnJvdCgpLHI9ZS5vTmV4dCgpLHM9dC5vTmV4dCgpLG89aS5vTmV4dCgpLGE9bi5vTmV4dCgpO3Quc2V0TmV4dChyKSxlLnNldE5leHQocyksbi5zZXROZXh0KG8pLGkuc2V0TmV4dChhKX0sYnMuY29ubmVjdD1mdW5jdGlvbih0LGUpe3ZhciBuPWJzLm1ha2VFZGdlKHQuZGVzdCgpLGUub3JpZygpKTtyZXR1cm4gYnMuc3BsaWNlKG4sdC5sTmV4dCgpKSxicy5zcGxpY2Uobi5zeW0oKSxlKSxufSxlKE9zLnByb3RvdHlwZSx7aW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnN1YmRpdi5sb2NhdGUodCk7aWYodGhpcy5zdWJkaXYuaXNWZXJ0ZXhPZkVkZ2UoZSx0KSlyZXR1cm4gZTt0aGlzLnN1YmRpdi5pc09uRWRnZShlLHQuZ2V0Q29vcmRpbmF0ZSgpKSYmKGU9ZS5vUHJldigpLHRoaXMuc3ViZGl2LmRlbGV0ZShlLm9OZXh0KCkpKTt2YXIgbj10aGlzLnN1YmRpdi5tYWtlRWRnZShlLm9yaWcoKSx0KTticy5zcGxpY2UobixlKTt2YXIgaT1uO2RvIG49dGhpcy5zdWJkaXYuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpO3doaWxlKGUubE5leHQoKSE9PWkpO2Zvcig7Oyl7dmFyIHI9ZS5vUHJldigpO2lmKHIuZGVzdCgpLnJpZ2h0T2YoZSkmJnQuaXNJbkNpcmNsZShlLm9yaWcoKSxyLmRlc3QoKSxlLmRlc3QoKSkpYnMuc3dhcChlKSxlPWUub1ByZXYoKTtlbHNle2lmKGUub05leHQoKT09PWkpcmV0dXJuIG47ZT1lLm9OZXh0KCkubFByZXYoKX19fSxpbnNlcnRTaXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3N9fSksZShfcy5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIF9zfX0pLGUoTXMucHJvdG90eXBlLHtpbml0OmZ1bmN0aW9uKCl7dGhpcy5sYXN0RWRnZT10aGlzLmZpbmRFZGdlKCl9LGxvY2F0ZTpmdW5jdGlvbih0KXt0aGlzLmxhc3RFZGdlLmlzTGl2ZSgpfHx0aGlzLmluaXQoKTt2YXIgZT10aGlzLnN1YmRpdi5sb2NhdGVGcm9tRWRnZSh0LHRoaXMubGFzdEVkZ2UpO3JldHVybiB0aGlzLmxhc3RFZGdlPWUsZX0sZmluZEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnN1YmRpdi5nZXRFZGdlcygpO3JldHVybiB0Lml0ZXJhdG9yKCkubmV4dCgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltfc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1zfX0pLGgoRHMsbCksZShEcy5wcm90b3R5cGUse2dldFNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWd9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERzfX0pLERzLm1zZ1dpdGhTcGF0aWFsPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGwhPT1lP3QrXCIgWyBcIitlK1wiIF1cIjp0fSxlKEFzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBc319KSxlKEZzLnByb3RvdHlwZSx7Z2V0VHJpYW5nbGVWZXJ0aWNlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQnM7cmV0dXJuIHRoaXMudmlzaXRUcmlhbmdsZXMoZSx0KSxlLmdldFRyaWFuZ2xlVmVydGljZXMoKX0saXNGcmFtZVZlcnRleDpmdW5jdGlvbih0KXtyZXR1cm4gdC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFswXSk/ITA6dC5lcXVhbHModGhpcy5mcmFtZVZlcnRleFsxXSk/ITA6ISF0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzJdKX0saXNWZXJ0ZXhPZkVkZ2U6ZnVuY3Rpb24odCxlKXtyZXR1cm4hKCFlLmVxdWFscyh0Lm9yaWcoKSx0aGlzLnRvbGVyYW5jZSkmJiFlLmVxdWFscyh0LmRlc3QoKSx0aGlzLnRvbGVyYW5jZSkpfSxjb25uZWN0OmZ1bmN0aW9uKHQsZSl7dmFyIG49YnMuY29ubmVjdCh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sZ2V0Vm9yb25vaUNlbGxQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEksaT10O2Rve3ZhciByPXQucm90KCkub3JpZygpLmdldENvb3JkaW5hdGUoKTtuLmFkZChyKSx0PXQub1ByZXYoKX13aGlsZSh0IT09aSk7dmFyIHM9bmV3IE47cy5hZGRBbGwobiwhMSkscy5jbG9zZVJpbmcoKSxzLnNpemUoKTw0JiYoQS5vdXQucHJpbnRsbihzKSxzLmFkZChzLmdldChzLnNpemUoKS0xKSwhMCkpO3ZhciBvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPWUuY3JlYXRlUG9seWdvbihlLmNyZWF0ZUxpbmVhclJpbmcobyksbnVsbCksdT1pLm9yaWcoKTtyZXR1cm4gYS5zZXRVc2VyRGF0YSh1LmdldENvb3JkaW5hdGUoKSksYX0sc2V0TG9jYXRvcjpmdW5jdGlvbih0KXt0aGlzLmxvY2F0b3I9dH0saW5pdFN1YmRpdjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFswXSx0aGlzLmZyYW1lVmVydGV4WzFdKSxlPXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFsxXSx0aGlzLmZyYW1lVmVydGV4WzJdKTticy5zcGxpY2UodC5zeW0oKSxlKTt2YXIgbj10aGlzLm1ha2VFZGdlKHRoaXMuZnJhbWVWZXJ0ZXhbMl0sdGhpcy5mcmFtZVZlcnRleFswXSk7cmV0dXJuIGJzLnNwbGljZShlLnN5bSgpLG4pLGJzLnNwbGljZShuLnN5bSgpLHQpLHR9LGlzRnJhbWVCb3JkZXJFZGdlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO0ZzLmdldFRyaWFuZ2xlRWRnZXModCxlKTt2YXIgbj1uZXcgQXJyYXkoMykuZmlsbChudWxsKTtGcy5nZXRUcmlhbmdsZUVkZ2VzKHQuc3ltKCksbik7dmFyIGk9dC5sTmV4dCgpLmRlc3QoKTtpZih0aGlzLmlzRnJhbWVWZXJ0ZXgoaSkpcmV0dXJuITA7dmFyIHI9dC5zeW0oKS5sTmV4dCgpLmRlc3QoKTtyZXR1cm4hIXRoaXMuaXNGcmFtZVZlcnRleChyKX0sbWFrZUVkZ2U6ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5tYWtlRWRnZSh0LGUpO3JldHVybiB0aGlzLnF1YWRFZGdlcy5hZGQobiksbn0sdmlzaXRUcmlhbmdsZXM6ZnVuY3Rpb24odCxlKXt0aGlzLnZpc2l0ZWRLZXkrKzt2YXIgbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXRoaXMuZmV0Y2hUcmlhbmdsZVRvVmlzaXQocixuLGUsaSk7bnVsbCE9PXMmJnQudmlzaXQocyl9fX0saXNGcmFtZUVkZ2U6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5pc0ZyYW1lVmVydGV4KHQub3JpZygpKSYmIXRoaXMuaXNGcmFtZVZlcnRleCh0LmRlc3QoKSkpfSxpc09uRWRnZTpmdW5jdGlvbih0LGUpe3RoaXMuc2VnLnNldENvb3JkaW5hdGVzKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSx0LmRlc3QoKS5nZXRDb29yZGluYXRlKCkpO3ZhciBuPXRoaXMuc2VnLmRpc3RhbmNlKGUpO3JldHVybiBuPHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiBuZXcgQyh0aGlzLmZyYW1lRW52KX0sY3JlYXRlRnJhbWU6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxpPTA7aT1lPm4/MTAqZToxMCpuLHRoaXMuZnJhbWVWZXJ0ZXhbMF09bmV3IFRzKCh0LmdldE1heFgoKSt0LmdldE1pblgoKSkvMix0LmdldE1heFkoKStpKSx0aGlzLmZyYW1lVmVydGV4WzFdPW5ldyBUcyh0LmdldE1pblgoKS1pLHQuZ2V0TWluWSgpLWkpLHRoaXMuZnJhbWVWZXJ0ZXhbMl09bmV3IFRzKHQuZ2V0TWF4WCgpK2ksdC5nZXRNaW5ZKCktaSksdGhpcy5mcmFtZUVudj1uZXcgQyh0aGlzLmZyYW1lVmVydGV4WzBdLmdldENvb3JkaW5hdGUoKSx0aGlzLmZyYW1lVmVydGV4WzFdLmdldENvb3JkaW5hdGUoKSksdGhpcy5mcmFtZUVudi5leHBhbmRUb0luY2x1ZGUodGhpcy5mcmFtZVZlcnRleFsyXS5nZXRDb29yZGluYXRlKCkpfSxnZXRUcmlhbmdsZUNvb3JkaW5hdGVzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB6cztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVzKCl9LGdldFZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSixuPXRoaXMucXVhZEVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkub3JpZygpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocil8fGUuYWRkKHIpO3ZhciBzPWkuZGVzdCgpOyF0JiZ0aGlzLmlzRnJhbWVWZXJ0ZXgocyl8fGUuYWRkKHMpfXJldHVybiBlfSxmZXRjaFRyaWFuZ2xlVG9WaXNpdDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LHM9MCxvPSExO2Rve3RoaXMudHJpRWRnZXNbc109cix0aGlzLmlzRnJhbWVFZGdlKHIpJiYobz0hMCk7dmFyIGE9ci5zeW0oKTtpLmNvbnRhaW5zKGEpfHxlLnB1c2goYSksaS5hZGQocikscysrLHI9ci5sTmV4dCgpfXdoaWxlKHIhPT10KTtyZXR1cm4gbyYmIW4/bnVsbDp0aGlzLnRyaUVkZ2VzfSxnZXRFZGdlczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnF1YWRFZGdlcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuZ2V0UHJpbWFyeUVkZ2VzKCExKSxuPW5ldyBBcnJheShlLnNpemUoKSkuZmlsbChudWxsKSxpPTAscj1lLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtuW2krK109dC5jcmVhdGVMaW5lU3RyaW5nKFtzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpXSl9cmV0dXJuIHQuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKG4pfX0sZ2V0VmVydGV4VW5pcXVlRWRnZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49bmV3IEosaT10aGlzLnF1YWRFZGdlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCkscz1yLm9yaWcoKTtuLmNvbnRhaW5zKHMpfHwobi5hZGQocyksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChzKXx8ZS5hZGQocikpO3ZhciBvPXIuc3ltKCksYT1vLm9yaWcoKTtuLmNvbnRhaW5zKGEpfHwobi5hZGQoYSksIXQmJnRoaXMuaXNGcmFtZVZlcnRleChhKXx8ZS5hZGQobykpfXJldHVybiBlfSxnZXRUcmlhbmdsZUVkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBxcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVFZGdlcygpfSxnZXRQcmltYXJ5RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdGVkS2V5Kys7dmFyIGU9bmV3IEksbj1uZXcgcGU7bi5wdXNoKHRoaXMuc3RhcnRpbmdFZGdlKTtmb3IodmFyIGk9bmV3IEo7IW4uZW1wdHkoKTspe3ZhciByPW4ucG9wKCk7aWYoIWkuY29udGFpbnMocikpe3ZhciBzPXIuZ2V0UHJpbWFyeSgpOyF0JiZ0aGlzLmlzRnJhbWVFZGdlKHMpfHxlLmFkZChzKSxuLnB1c2goci5vTmV4dCgpKSxuLnB1c2goci5zeW0oKS5vTmV4dCgpKSxpLmFkZChyKSxpLmFkZChyLnN5bSgpKX19cmV0dXJuIGV9LGRlbGV0ZTpmdW5jdGlvbih0KXticy5zcGxpY2UodCx0Lm9QcmV2KCkpLGJzLnNwbGljZSh0LnN5bSgpLHQuc3ltKCkub1ByZXYoKSk7dmFyIGU9dC5zeW0oKSxuPXQucm90KCksaT10LnJvdCgpLnN5bSgpO3RoaXMucXVhZEVkZ2VzLnJlbW92ZSh0KSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUoZSksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKG4pLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShpKSx0LmRlbGV0ZSgpLGUuZGVsZXRlKCksbi5kZWxldGUoKSxpLmRlbGV0ZSgpfSxsb2NhdGVGcm9tRWRnZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9dGhpcy5xdWFkRWRnZXMuc2l6ZSgpLHI9ZTs7KXtpZihuKyssbj5pKXRocm93IG5ldyBEcyhyLnRvTGluZVNlZ21lbnQoKSk7aWYodC5lcXVhbHMoci5vcmlnKCkpfHx0LmVxdWFscyhyLmRlc3QoKSkpYnJlYWs7aWYodC5yaWdodE9mKHIpKXI9ci5zeW0oKTtlbHNlIGlmKHQucmlnaHRPZihyLm9OZXh0KCkpKXtpZih0LnJpZ2h0T2Yoci5kUHJldigpKSlicmVhaztyPXIuZFByZXYoKX1lbHNlIHI9ci5vTmV4dCgpfXJldHVybiByfSxnZXRUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9LGdldFZvcm9ub2lDZWxsUG9seWdvbnM6ZnVuY3Rpb24odCl7dGhpcy52aXNpdFRyaWFuZ2xlcyhuZXcgR3MsITApO2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuZ2V0VmVydGV4VW5pcXVlRWRnZXMoITEpLGk9bi5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ZS5hZGQodGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb24ocix0KSl9cmV0dXJuIGV9LGdldFZvcm9ub2lEaWFncmFtOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0Vm9yb25vaUNlbGxQb2x5Z29ucyh0KTtyZXR1cm4gdC5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGUpKX0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmdldFRyaWFuZ2xlQ29vcmRpbmF0ZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpLGk9MCxyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO25baSsrXT10LmNyZWF0ZVBvbHlnb24odC5jcmVhdGVMaW5lYXJSaW5nKHMpLG51bGwpfXJldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX0saW5zZXJ0U2l0ZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmxvY2F0ZSh0KTtpZih0LmVxdWFscyhlLm9yaWcoKSx0aGlzLnRvbGVyYW5jZSl8fHQuZXF1YWxzKGUuZGVzdCgpLHRoaXMudG9sZXJhbmNlKSlyZXR1cm4gZTt2YXIgbj10aGlzLm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLmNvbm5lY3QoZSxuLnN5bSgpKSxlPW4ub1ByZXYoKTt3aGlsZShlLmxOZXh0KCkhPT1pKTtyZXR1cm4gaX0sbG9jYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHMpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZSh0KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5sb2NhdG9yLmxvY2F0ZShuZXcgVHMoZSkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj10aGlzLmxvY2F0b3IubG9jYXRlKG5ldyBUcyhuKSk7aWYobnVsbD09PXIpcmV0dXJuIG51bGw7dmFyIHM9cjtyLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQobikmJihzPXIuc3ltKCkpO3ZhciBvPXM7ZG97aWYoby5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKGkpKXJldHVybiBvO289by5vTmV4dCgpfXdoaWxlKG8hPT1zKTtyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZzfX0pLEZzLmdldFRyaWFuZ2xlRWRnZXM9ZnVuY3Rpb24odCxlKXtpZihlWzBdPXQsZVsxXT1lWzBdLmxOZXh0KCksZVsyXT1lWzFdLmxOZXh0KCksZVsyXS5sTmV4dCgpIT09ZVswXSl0aHJvdyBuZXcgaShcIkVkZ2VzIGRvIG5vdCBmb3JtIGEgdHJpYW5nbGVcIil9LGUoR3MucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dFswXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLG49dFsxXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLGk9dFsyXS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHI9Y2kuY2lyY3VtY2VudHJlKGUsbixpKSxzPW5ldyBUcyhyKSxvPTA7Mz5vO28rKyl0W29dLnJvdCgpLnNldE9yaWcocyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR3N9fSksZShxcy5wcm90b3R5cGUse2dldFRyaWFuZ2xlRWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLnRyaUxpc3QuYWRkKHQuY2xvbmUoKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcXN9fSksZShCcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe3RoaXMudHJpTGlzdC5hZGQoW3RbMF0ub3JpZygpLHRbMV0ub3JpZygpLHRbMl0ub3JpZygpXSl9LGdldFRyaWFuZ2xlVmVydGljZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50cmlMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJzfX0pLGUoenMucHJvdG90eXBlLHtjaGVja1RyaWFuZ2xlU2l6ZTpmdW5jdGlvbih0KXt2YXIgZT1cIlwiO3QubGVuZ3RoPj0yP2U9c2UudG9MaW5lU3RyaW5nKHRbMF0sdFsxXSk6dC5sZW5ndGg+PTEmJihlPXNlLnRvUG9pbnQodFswXSkpfSx2aXNpdDpmdW5jdGlvbih0KXt0aGlzLmNvb3JkTGlzdC5jbGVhcigpO2Zvcih2YXIgZT0wOzM+ZTtlKyspe3ZhciBuPXRbZV0ub3JpZygpO3RoaXMuY29vcmRMaXN0LmFkZChuLmdldENvb3JkaW5hdGUoKSl9aWYodGhpcy5jb29yZExpc3Quc2l6ZSgpPjApe3RoaXMuY29vcmRMaXN0LmNsb3NlUmluZygpO3ZhciBpPXRoaXMuY29vcmRMaXN0LnRvQ29vcmRpbmF0ZUFycmF5KCk7aWYoNCE9PWkubGVuZ3RoKXJldHVybiBudWxsO3RoaXMudHJpQ29vcmRzLmFkZChpKX19LGdldFRyaWFuZ2xlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUNvb3Jkc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB6c319KSxGcy5UcmlhbmdsZUNpcmN1bWNlbnRyZVZpc2l0b3I9R3MsRnMuVHJpYW5nbGVFZGdlc0xpc3RWaXNpdG9yPXFzLEZzLlRyaWFuZ2xlVmVydGV4TGlzdFZpc2l0b3I9QnMsRnMuVHJpYW5nbGVDb29yZGluYXRlc1Zpc2l0b3I9enMsRnMuRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SPTFlMyxlKFZzLnByb3RvdHlwZSx7Z2V0TGluZVNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sc30sZ2V0RW5kWjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC56fSxnZXRTdGFydFo6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQuen0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxzLmludGVyc2VjdGlvbih0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMCl9LGdldEVuZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLmdldENvb3JkaW5hdGUoMSl9LGdldEVuZFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueX0sZ2V0U3RhcnRYOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDApO3JldHVybiB0Lnh9LGVxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubHMuZXF1YWxzVG9wbyh0LmdldExpbmVTZWdtZW50KCkpfSxnZXRTdGFydFk6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQueX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGdldEVuZFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMSk7cmV0dXJuIHQueH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5scy50b1N0cmluZygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWc319KSxlKGtzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrc319KSxlKFlzLnByb3RvdHlwZSx7aXNSZXBlYXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50PjF9LGdldFJpZ2h0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucmlnaHR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wfSxzZXRMZWZ0OmZ1bmN0aW9uKHQpe3RoaXMubGVmdD10fSxnZXRYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC54fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZ2V0Q291bnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb3VudH0sZ2V0TGVmdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxlZnR9LGdldFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnl9LGluY3JlbWVudDpmdW5jdGlvbigpe3RoaXMuY291bnQ9dGhpcy5jb3VudCsxfSxzZXRSaWdodDpmdW5jdGlvbih0KXt0aGlzLnJpZ2h0PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlzfX0pLGUoVXMucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluc2VydCh0LG51bGwpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYobnVsbD09PXRoaXMucm9vdClyZXR1cm4gdGhpcy5yb290PW5ldyBZcyhlLG4pLHRoaXMucm9vdDtpZih0aGlzLnRvbGVyYW5jZT4wKXt2YXIgaT10aGlzLmZpbmRCZXN0TWF0Y2hOb2RlKGUpO2lmKG51bGwhPT1pKXJldHVybiBpLmluY3JlbWVudCgpLGl9cmV0dXJuIHRoaXMuaW5zZXJ0RXhhY3QoZSxuKX19LHF1ZXJ5OmZ1bmN0aW9uKCl7dmFyIHQ9YXJndW1lbnRzLGU9dGhpcztpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9bmV3IEk7cmV0dXJuIHRoaXMucXVlcnkobixpKSxpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyYmUihhcmd1bWVudHNbMV0seSkpIWZ1bmN0aW9uKCl7dmFyIG49dFswXSxpPXRbMV07ZS5xdWVyeU5vZGUoZS5yb290LG4sITAse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2tzXX0sdmlzaXQ6ZnVuY3Rpb24odCl7aS5hZGQodCl9fSl9KCk7ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMmJlIoYXJndW1lbnRzWzFdLGtzKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3RoaXMucXVlcnlOb2RlKHRoaXMucm9vdCxyLCEwLHMpfX0scXVlcnlOb2RlOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKG51bGw9PT10KXJldHVybiBudWxsO3ZhciByPW51bGwscz1udWxsLG89bnVsbDtuPyhyPWUuZ2V0TWluWCgpLHM9ZS5nZXRNYXhYKCksbz10LmdldFgoKSk6KHI9ZS5nZXRNaW5ZKCkscz1lLmdldE1heFkoKSxvPXQuZ2V0WSgpKTt2YXIgYT1vPnIsdT1zPj1vO2EmJnRoaXMucXVlcnlOb2RlKHQuZ2V0TGVmdCgpLGUsIW4saSksZS5jb250YWlucyh0LmdldENvb3JkaW5hdGUoKSkmJmkudmlzaXQodCksdSYmdGhpcy5xdWVyeU5vZGUodC5nZXRSaWdodCgpLGUsIW4saSl9LGZpbmRCZXN0TWF0Y2hOb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBYcyh0LHRoaXMudG9sZXJhbmNlKTtyZXR1cm4gdGhpcy5xdWVyeShlLnF1ZXJ5RW52ZWxvcGUoKSxlKSxlLmdldE5vZGUoKX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5yb290fSxpbnNlcnRFeGFjdDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLnJvb3QsaT10aGlzLnJvb3Qscj0hMCxzPSEwO251bGwhPT1uOyl7aWYobnVsbCE9PW4pe3ZhciBvPXQuZGlzdGFuY2Uobi5nZXRDb29yZGluYXRlKCkpPD10aGlzLnRvbGVyYW5jZTtpZihvKXJldHVybiBuLmluY3JlbWVudCgpLG59cz1yP3QueDxuLmdldFgoKTp0Lnk8bi5nZXRZKCksaT1uLG49cz9uLmdldExlZnQoKTpuLmdldFJpZ2h0KCkscj0hcn10aGlzLm51bWJlck9mTm9kZXM9dGhpcy5udW1iZXJPZk5vZGVzKzE7dmFyIGE9bmV3IFlzKHQsZSk7cmV0dXJuIHM/aS5zZXRMZWZ0KGEpOmkuc2V0UmlnaHQoYSksYX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVXN9fSksVXMudG9Db29yZGluYXRlcz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIFVzLnRvQ29vcmRpbmF0ZXModCwhMSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uZXcgTixyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspZm9yKHZhciBzPXIubmV4dCgpLG89bj9zLmdldENvdW50KCk6MSxhPTA7bz5hO2ErKylpLmFkZChzLmdldENvb3JkaW5hdGUoKSwhMCk7cmV0dXJuIGkudG9Db29yZGluYXRlQXJyYXkoKX19LGUoWHMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnAuZGlzdGFuY2UodC5nZXRDb29yZGluYXRlKCkpLG49ZTw9dGhpcy50b2xlcmFuY2U7aWYoIW4pcmV0dXJuIG51bGw7dmFyIGk9ITE7KG51bGw9PT10aGlzLm1hdGNoTm9kZXx8ZTx0aGlzLm1hdGNoRGlzdHx8bnVsbCE9PXRoaXMubWF0Y2hOb2RlJiZlPT09dGhpcy5tYXRjaERpc3QmJnQuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLm1hdGNoTm9kZS5nZXRDb29yZGluYXRlKCkpPDEpJiYoaT0hMCksaSYmKHRoaXMubWF0Y2hOb2RlPXQsdGhpcy5tYXRjaERpc3Q9ZSl9LHF1ZXJ5RW52ZWxvcGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQyh0aGlzLnApO3JldHVybiB0LmV4cGFuZEJ5KHRoaXMudG9sZXJhbmNlKSx0fSxnZXROb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF0Y2hOb2RlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltrc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhzfX0pLFVzLkJlc3RNYXRjaFZpc2l0b3I9WHMsZShIcy5wcm90b3R5cGUse2dldEluaXRpYWxWZXJ0aWNlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmluaXRpYWxWZXJ0aWNlc30sZ2V0S0RUOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMua2R0fSxlbmZvcmNlQ29uc3RyYWludHM6ZnVuY3Rpb24oKXt0aGlzLmFkZENvbnN0cmFpbnRWZXJ0aWNlcygpO3ZhciB0PTAsZT0wO2RvIGU9dGhpcy5lbmZvcmNlR2FicmllbCh0aGlzLnNlZ21lbnRzKSx0Kys7d2hpbGUoZT4wJiZ0PEhzLk1BWF9TUExJVF9JVEVSKX0saW5zZXJ0U2l0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuaW5zZXJ0U2l0ZShuKX19LGdldFZlcnRleEZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy52ZXJ0ZXhGYWN0b3J5fSxnZXRQb2ludEFycmF5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmluaXRpYWxWZXJ0aWNlcy5zaXplKCkrdGhpcy5zZWdWZXJ0aWNlcy5zaXplKCkpLmZpbGwobnVsbCksZT0wLG49dGhpcy5pbml0aWFsVmVydGljZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RbZSsrXT1pLmdldENvb3JkaW5hdGUoKX1mb3IodmFyIHI9dGhpcy5zZWdWZXJ0aWNlcy5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIGk9ci5uZXh0KCk7dFtlKytdPWkuZ2V0Q29vcmRpbmF0ZSgpfXJldHVybiB0fSxzZXRDb25zdHJhaW50czpmdW5jdGlvbih0LGUpe3RoaXMuc2VnbWVudHM9dCx0aGlzLnNlZ1ZlcnRpY2VzPWV9LGNvbXB1dGVDb252ZXhIdWxsOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGllLGU9dGhpcy5nZXRQb2ludEFycmF5KCksbj1uZXcgbWUoZSx0KTt0aGlzLmNvbnZleEh1bGw9bi5nZXRDb252ZXhIdWxsKCl9LGFkZENvbnN0cmFpbnRWZXJ0aWNlczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZUNvbnZleEh1bGwoKSx0aGlzLmluc2VydFNpdGVzKHRoaXMuc2VnVmVydGljZXMpfSxmaW5kTm9uR2FicmllbFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0U3RhcnQoKSxuPXQuZ2V0RW5kKCksaT1uZXcgZygoZS54K24ueCkvMiwoZS55K24ueSkvMikscz1lLmRpc3RhbmNlKGkpLG89bmV3IEMoaSk7by5leHBhbmRCeShzKTtmb3IodmFyIGE9dGhpcy5rZHQucXVlcnkobyksdT1udWxsLGw9ci5NQVhfVkFMVUUsaD1hLml0ZXJhdG9yKCk7aC5oYXNOZXh0KCk7KXt2YXIgYz1oLm5leHQoKSxmPWMuZ2V0Q29vcmRpbmF0ZSgpO2lmKCFmLmVxdWFsczJEKGUpJiYhZi5lcXVhbHMyRChuKSl7dmFyIGQ9aS5kaXN0YW5jZShmKTtpZihzPmQpe3ZhciBwPWQ7KG51bGw9PT11fHxsPnApJiYodT1mLGw9cCl9fX1yZXR1cm4gdX0sZ2V0Q29uc3RyYWludFNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnbWVudHN9LHNldFNwbGl0UG9pbnRGaW5kZXI6ZnVuY3Rpb24odCl7dGhpcy5zcGxpdEZpbmRlcj10fSxnZXRDb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29udmV4SHVsbH0sZ2V0VG9sZXJhbmNlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudG9sZXJhbmNlfSxlbmZvcmNlR2FicmllbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj0wLGk9bmV3IEkscj10Lml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMuZmluZE5vbkdhYnJpZWxQb2ludChzKTtpZihudWxsIT09byl7dGhpcy5zcGxpdFB0PXRoaXMuc3BsaXRGaW5kZXIuZmluZFNwbGl0UG9pbnQocyxvKTt2YXIgYT10aGlzLmNyZWF0ZVZlcnRleCh0aGlzLnNwbGl0UHQscyksdT0odGhpcy5pbnNlcnRTaXRlKGEpLG5ldyBWcyhzLmdldFN0YXJ0WCgpLHMuZ2V0U3RhcnRZKCkscy5nZXRTdGFydFooKSxhLmdldFgoKSxhLmdldFkoKSxhLmdldFooKSxzLmdldERhdGEoKSkpLGw9bmV3IFZzKGEuZ2V0WCgpLGEuZ2V0WSgpLGEuZ2V0WigpLHMuZ2V0RW5kWCgpLHMuZ2V0RW5kWSgpLHMuZ2V0RW5kWigpLHMuZ2V0RGF0YSgpKTtlLmFkZCh1KSxlLmFkZChsKSxpLmFkZChzKSxuKz0xfX1yZXR1cm4gdC5yZW1vdmVBbGwoaSksdC5hZGRBbGwoZSksbn0sY3JlYXRlVmVydGV4OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMudmVydGV4RmFjdG9yeT90aGlzLnZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KHQsbnVsbCk6bmV3IFBzKHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1udWxsO3JldHVybiBlPW51bGwhPT10aGlzLnZlcnRleEZhY3Rvcnk/dGhpcy52ZXJ0ZXhGYWN0b3J5LmNyZWF0ZVZlcnRleChuLGkpOm5ldyBQcyhuKSxlLnNldE9uQ29uc3RyYWludCghMCksZX19LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ViZGl2fSxjb21wdXRlQm91bmRpbmdCb3g6ZnVuY3Rpb24oKXt2YXIgdD1Icy5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5pbml0aWFsVmVydGljZXMpLGU9SHMuY29tcHV0ZVZlcnRleEVudmVsb3BlKHRoaXMuc2VnVmVydGljZXMpLG49bmV3IEModCk7bi5leHBhbmRUb0luY2x1ZGUoZSk7dmFyIGk9LjIqbi5nZXRXaWR0aCgpLHI9LjIqbi5nZXRIZWlnaHQoKSxzPU1hdGgubWF4KGkscik7dGhpcy5jb21wdXRlQXJlYUVudj1uZXcgQyhuKSx0aGlzLmNvbXB1dGVBcmVhRW52LmV4cGFuZEJ5KHMpfSxzZXRWZXJ0ZXhGYWN0b3J5OmZ1bmN0aW9uKHQpe3RoaXMudmVydGV4RmFjdG9yeT10fSxmb3JtSW5pdGlhbERlbGF1bmF5OmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQm91bmRpbmdCb3goKSx0aGlzLnN1YmRpdj1uZXcgRnModGhpcy5jb21wdXRlQXJlYUVudix0aGlzLnRvbGVyYW5jZSksdGhpcy5zdWJkaXYuc2V0TG9jYXRvcihuZXcgTXModGhpcy5zdWJkaXYpKSx0aGlzLmluY0RlbD1uZXcgT3ModGhpcy5zdWJkaXYpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5pbml0aWFsVmVydGljZXMpfSxpbnNlcnRTaXRlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQcyl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5rZHQuaW5zZXJ0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpO2lmKGUuaXNSZXBlYXRlZCgpKXt2YXIgbj1lLmdldERhdGEoKTtyZXR1cm4gbi5tZXJnZSh0KSxufXJldHVybiB0aGlzLmluY0RlbC5pbnNlcnRTaXRlKHQpLHR9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgaT1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRTaXRlKHRoaXMuY3JlYXRlVmVydGV4KGkpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhzfX0pLEhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEMsbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlLmV4cGFuZFRvSW5jbHVkZShpLmdldENvb3JkaW5hdGUoKSl9cmV0dXJuIGV9LEhzLk1BWF9TUExJVF9JVEVSPTk5LGUoV3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKSxlPVdzLnRvVmVydGljZXModGhpcy5zaXRlQ29vcmRzKTt0aGlzLnN1YmRpdj1uZXcgRnModCx0aGlzLnRvbGVyYW5jZSk7dmFyIG49bmV3IE9zKHRoaXMuc3ViZGl2KTtuLmluc2VydFNpdGVzKGUpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MudW5pcXVlKEgudG9Db29yZGluYXRlQXJyYXkoZSkpfX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdzfX0pLFdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcz1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbmV3IE47dmFyIGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiBXcy51bmlxdWUoZSl9LFdzLmVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKGkpfXJldHVybiBlfSxXcy51bmlxdWU9ZnVuY3Rpb24odCl7dmFyIGU9SC5jb3B5RGVlcCh0KTt1dC5zb3J0KGUpO3ZhciBuPW5ldyBOKGUsITEpO3JldHVybiBufSxXcy50b1ZlcnRpY2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBUcyhpKSl9cmV0dXJuIGV9LGUoanMucHJvdG90eXBlLHtjcmVhdGVTaXRlVmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5jb25zdHJhaW50VmVydGV4TWFwLmNvbnRhaW5zS2V5KGkpfHxlLmFkZChuZXcgUHMoaSkpfXJldHVybiBlfSxjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKSxlPW5ldyBJO251bGwhPT10aGlzLmNvbnN0cmFpbnRMaW5lcyYmKHQuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY29uc3RyYWludExpbmVzLmdldEVudmVsb3BlSW50ZXJuYWwoKSksdGhpcy5jcmVhdGVWZXJ0aWNlcyh0aGlzLmNvbnN0cmFpbnRMaW5lcyksZT1qcy5jcmVhdGVDb25zdHJhaW50U2VnbWVudHModGhpcy5jb25zdHJhaW50TGluZXMpKTt2YXIgbj10aGlzLmNyZWF0ZVNpdGVWZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpLGk9bmV3IEhzKG4sdGhpcy50b2xlcmFuY2UpO2kuc2V0Q29uc3RyYWludHMoZSxuZXcgSSh0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAudmFsdWVzKCkpKSxpLmZvcm1Jbml0aWFsRGVsYXVuYXkoKSxpLmVuZm9yY2VDb25zdHJhaW50cygpLHRoaXMuc3ViZGl2PWkuZ2V0U3ViZGl2aXNpb24oKX0sc2V0VG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3RoaXMudG9sZXJhbmNlPXR9LHNldENvbnN0cmFpbnRzOmZ1bmN0aW9uKHQpe3RoaXMuY29uc3RyYWludExpbmVzPXR9LHNldFNpdGVzOmZ1bmN0aW9uKHQpe3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9LGdldEVkZ2VzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldEVkZ2VzKHQpfSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2fSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0VHJpYW5nbGVzKHQpfSxjcmVhdGVWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlcygpLG49MDtuPGUubGVuZ3RoO24rKyl7dmFyIGk9bmV3IFBzKGVbbl0pO3RoaXMuY29uc3RyYWludFZlcnRleE1hcC5wdXQoZVtuXSxpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpzfX0pLGpzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9a24uZ2V0TGluZXModCksbj1uZXcgSSxpPWUuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2pzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyhyLG4pfXJldHVybiBufWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1zLmdldENvb3JkaW5hdGVzKCksaT0xO2k8YS5sZW5ndGg7aSsrKW8uYWRkKG5ldyBWcyhhW2ktMV0sYVtpXSkpfSxlKEtzLnByb3RvdHlwZSx7Y3JlYXRlOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMuc3ViZGl2KXJldHVybiBudWxsO3ZhciB0PVdzLmVudmVsb3BlKHRoaXMuc2l0ZUNvb3Jkcyk7dGhpcy5kaWFncmFtRW52PXQ7dmFyIGU9TWF0aC5tYXgodGhpcy5kaWFncmFtRW52LmdldFdpZHRoKCksdGhpcy5kaWFncmFtRW52LmdldEhlaWdodCgpKTt0aGlzLmRpYWdyYW1FbnYuZXhwYW5kQnkoZSksbnVsbCE9PXRoaXMuY2xpcEVudiYmdGhpcy5kaWFncmFtRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNsaXBFbnYpO3ZhciBuPVdzLnRvVmVydGljZXModGhpcy5zaXRlQ29vcmRzKTt0aGlzLnN1YmRpdj1uZXcgRnModCx0aGlzLnRvbGVyYW5jZSk7dmFyIGk9bmV3IE9zKHRoaXMuc3ViZGl2KTtpLmluc2VydFNpdGVzKG4pfSxnZXREaWFncmFtOmZ1bmN0aW9uKHQpe3RoaXMuY3JlYXRlKCk7dmFyIGU9dGhpcy5zdWJkaXYuZ2V0Vm9yb25vaURpYWdyYW0odCk7cmV0dXJuIEtzLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb24oZSx0aGlzLmRpYWdyYW1FbnYpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzKHQpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLnNpdGVDb29yZHM9V3MudW5pcXVlKEgudG9Db29yZGluYXRlQXJyYXkoZSkpfX0sc2V0Q2xpcEVudmVsb3BlOmZ1bmN0aW9uKHQpe3RoaXMuY2xpcEVudj10fSxnZXRTdWJkaXZpc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLc319KSxLcy5jbGlwR2VvbWV0cnlDb2xsZWN0aW9uPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RmFjdG9yeSgpLnRvR2VvbWV0cnkoZSksaT1uZXcgSSxyPTA7cjx0LmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBzPXQuZ2V0R2VvbWV0cnlOKHIpLG89bnVsbDtlLmNvbnRhaW5zKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9vPXM6ZS5pbnRlcnNlY3RzKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSYmKG89bi5pbnRlcnNlY3Rpb24ocyksby5zZXRVc2VyRGF0YShzLmdldFVzZXJEYXRhKCkpKSxudWxsPT09b3x8by5pc0VtcHR5KCl8fGkuYWRkKG8pfXJldHVybiB0LmdldEZhY3RvcnkoKS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KGkpKX07dmFyIERvPU9iamVjdC5mcmVlemUoe0NvbmZvcm1pbmdEZWxhdW5heVRyaWFuZ3VsYXRpb25CdWlsZGVyOmpzLERlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6V3MsVm9yb25vaURpYWdyYW1CdWlsZGVyOktzfSk7ZShacy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFpzfX0pLFpzLnVuaW9uPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlVOSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIGUuY29weSgpO2lmKGUuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKX1yZXR1cm4gdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSxlKEIucHJvdG90eXBlLHtlcXVhbHNUb3BvOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5lcXVhbHModC5nZXRFbnZlbG9wZUludGVybmFsKCkpP1lyLnJlbGF0ZSh0aGlzLHQpLmlzRXF1YWxzKHRoaXMuZ2V0RGltZW5zaW9uKCksdC5nZXREaW1lbnNpb24oKSk6ITF9LHVuaW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIGpyLnVuaW9uKHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIFpzLnVuaW9uKHRoaXMsdCl9fSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIGxzLmlzVmFsaWQodGhpcyl9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtpZih0aGlzLmlzRW1wdHkoKXx8dC5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLklOVEVSU0VDVElPTix0aGlzLHQsdGhpcy5mYWN0b3J5KTtpZih0aGlzLmlzR2VvbWV0cnlDb2xsZWN0aW9uKCkpe3ZhciBlPXQ7cmV0dXJuIGhuLm1hcCh0aGlzLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNYXBPcF19LG1hcDpmdW5jdGlvbih0KXtyZXR1cm4gdC5pbnRlcnNlY3Rpb24oZSl9fSl9cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLklOVEVSU0VDVElPTil9LGNvdmVyczpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY292ZXJzKHRoaXMsdCl9LGNvdmVyZWRCeTpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY292ZXJlZEJ5KHRoaXMsdCl9LHRvdWNoZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLnRvdWNoZXModGhpcyx0KX0saW50ZXJzZWN0czpmdW5jdGlvbih0KXtyZXR1cm4gWXIuaW50ZXJzZWN0cyh0aGlzLHQpfSx3aXRoaW46ZnVuY3Rpb24odCl7cmV0dXJuIFlyLndpdGhpbih0aGlzLHQpfSxvdmVybGFwczpmdW5jdGlvbih0KXtyZXR1cm4gWXIub3ZlcmxhcHModGhpcyx0KX0sZGlzam9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmRpc2pvaW50KHRoaXMsdCl9LGNyb3NzZXM6ZnVuY3Rpb24odCl7cmV0dXJuIFlyLmNyb3NzZXModGhpcyx0KX0sYnVmZmVyOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gc3IuYnVmZmVyT3AodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBzci5idWZmZXJPcCh0aGlzLGUsbil9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtyZXR1cm4gc3IuYnVmZmVyT3AodGhpcyxpLHIscyl9fSxjb252ZXhIdWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBtZSh0aGlzKS5nZXRDb252ZXhIdWxsKCl9LHJlbGF0ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLGU9QXJyYXkodCksbj0wO3Q+bjtuKyspZVtuXT1hcmd1bWVudHNbbl07cmV0dXJuIFlyLnJlbGF0ZS5hcHBseShZcixbdGhpc10uY29uY2F0KGUpKX0sZ2V0Q2VudHJvaWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIHQ9Z2UuZ2V0Q2VudHJvaWQodGhpcyk7cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVQb2ludCgpO3ZhciB0PW51bGwsZT10aGlzLmdldERpbWVuc2lvbigpO2lmKDA9PT1lKXt2YXIgbj1uZXcgbGkodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1lbHNlIGlmKDE9PT1lKXt2YXIgbj1uZXcgdWkodGhpcyk7dD1uLmdldEludGVyaW9yUG9pbnQoKX1lbHNle3ZhciBuPW5ldyBvaSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfXJldHVybiB0aGlzLmNyZWF0ZVBvaW50RnJvbUludGVybmFsQ29vcmQodCx0aGlzKX0sc3ltRGlmZmVyZW5jZTpmdW5jdGlvbih0KXtpZih0aGlzLmlzRW1wdHkoKXx8dC5pc0VtcHR5KCkpe2lmKHRoaXMuaXNFbXB0eSgpJiZ0LmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuU1lNRElGRkVSRU5DRSx0aGlzLHQsdGhpcy5mYWN0b3J5KTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdC5jb3B5KCk7aWYodC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuY29weSgpfXJldHVybiB0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5TWU1ESUZGRVJFTkNFKX0sY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZDpmdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LHRvVGV4dDpmdW5jdGlvbigpe3ZhciB0PW5ldyBzZTtyZXR1cm4gdC53cml0ZSh0aGlzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt0aGlzLnRvVGV4dCgpfSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY29udGFpbnModGhpcyx0KX0sZGlmZmVyZW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/aWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuRElGRkVSRU5DRSx0aGlzLHQsdGhpcy5mYWN0b3J5KTp0LmlzRW1wdHkoKT90aGlzLmNvcHkoKToodGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuRElGRkVSRU5DRSkpfSxpc1NpbXBsZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBHaSh0aGlzKTtyZXR1cm4gdC5pc1NpbXBsZSgpfSxpc1dpdGhpbkRpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UodC5nZXRFbnZlbG9wZUludGVybmFsKCkpO3JldHVybiBuPmU/ITE6aHIuaXNXaXRoaW5EaXN0YW5jZSh0aGlzLHQsZSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQpe3JldHVybiBoci5kaXN0YW5jZSh0aGlzLHQpfSxpc0VxdWl2YWxlbnRDbGFzczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRDbGFzcygpPT09dC5nZXRDbGFzcygpfX0pO3ZhciBBbz1cIjEuMS4yICgyNDhkYWI4KVwiO3QudmVyc2lvbj1Bbyx0LmFsZ29yaXRobT1jbyx0LmRlbnNpZnk9Zm8sdC5kaXNzb2x2ZT1nbyx0Lmdlb209bG8sdC5pbmRleD1tbyx0LmlvPUlvLHQubm9kaW5nPU5vLHQub3BlcmF0aW9uPU9vLHQucHJlY2lzaW9uPV9vLHQuc2ltcGxpZnk9TW8sdC50cmlhbmd1bGF0ZT1Eb30pO1xuIiwiJ3VzZSBzdHJpY3QnXG5cbm1vZHVsZS5leHBvcnRzID0gbW9ub3RvbmVDb252ZXhIdWxsMkRcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpWzNdXG5cbmZ1bmN0aW9uIG1vbm90b25lQ29udmV4SHVsbDJEKHBvaW50cykge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcblxuICBpZihuIDwgMykge1xuICAgIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgICBmb3IodmFyIGk9MDsgaTxuOyArK2kpIHtcbiAgICAgIHJlc3VsdFtpXSA9IGlcbiAgICB9XG5cbiAgICBpZihuID09PSAyICYmXG4gICAgICAgcG9pbnRzWzBdWzBdID09PSBwb2ludHNbMV1bMF0gJiZcbiAgICAgICBwb2ludHNbMF1bMV0gPT09IHBvaW50c1sxXVsxXSkge1xuICAgICAgcmV0dXJuIFswXVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHRcbiAgfVxuXG4gIC8vU29ydCBwb2ludCBpbmRpY2VzIGFsb25nIHgtYXhpc1xuICB2YXIgc29ydGVkID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHNvcnRlZFtpXSA9IGlcbiAgfVxuICBzb3J0ZWQuc29ydChmdW5jdGlvbihhLGIpIHtcbiAgICB2YXIgZCA9IHBvaW50c1thXVswXS1wb2ludHNbYl1bMF1cbiAgICBpZihkKSB7XG4gICAgICByZXR1cm4gZFxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzW2FdWzFdIC0gcG9pbnRzW2JdWzFdXG4gIH0pXG5cbiAgLy9Db25zdHJ1Y3QgdXBwZXIgYW5kIGxvd2VyIGh1bGxzXG4gIHZhciBsb3dlciA9IFtzb3J0ZWRbMF0sIHNvcnRlZFsxXV1cbiAgdmFyIHVwcGVyID0gW3NvcnRlZFswXSwgc29ydGVkWzFdXVxuXG4gIGZvcih2YXIgaT0yOyBpPG47ICsraSkge1xuICAgIHZhciBpZHggPSBzb3J0ZWRbaV1cbiAgICB2YXIgcCAgID0gcG9pbnRzW2lkeF1cblxuICAgIC8vSW5zZXJ0IGludG8gbG93ZXIgbGlzdFxuICAgIHZhciBtID0gbG93ZXIubGVuZ3RoXG4gICAgd2hpbGUobSA+IDEgJiYgb3JpZW50KFxuICAgICAgICBwb2ludHNbbG93ZXJbbS0yXV0sIFxuICAgICAgICBwb2ludHNbbG93ZXJbbS0xXV0sIFxuICAgICAgICBwKSA8PSAwKSB7XG4gICAgICBtIC09IDFcbiAgICAgIGxvd2VyLnBvcCgpXG4gICAgfVxuICAgIGxvd2VyLnB1c2goaWR4KVxuXG4gICAgLy9JbnNlcnQgaW50byB1cHBlciBsaXN0XG4gICAgbSA9IHVwcGVyLmxlbmd0aFxuICAgIHdoaWxlKG0gPiAxICYmIG9yaWVudChcbiAgICAgICAgcG9pbnRzW3VwcGVyW20tMl1dLCBcbiAgICAgICAgcG9pbnRzW3VwcGVyW20tMV1dLCBcbiAgICAgICAgcCkgPj0gMCkge1xuICAgICAgbSAtPSAxXG4gICAgICB1cHBlci5wb3AoKVxuICAgIH1cbiAgICB1cHBlci5wdXNoKGlkeClcbiAgfVxuXG4gIC8vTWVyZ2UgbGlzdHMgdG9nZXRoZXJcbiAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheSh1cHBlci5sZW5ndGggKyBsb3dlci5sZW5ndGggLSAyKVxuICB2YXIgcHRyICAgID0gMFxuICBmb3IodmFyIGk9MCwgbmw9bG93ZXIubGVuZ3RoOyBpPG5sOyArK2kpIHtcbiAgICByZXN1bHRbcHRyKytdID0gbG93ZXJbaV1cbiAgfVxuICBmb3IodmFyIGo9dXBwZXIubGVuZ3RoLTI7IGo+MDsgLS1qKSB7XG4gICAgcmVzdWx0W3B0cisrXSA9IHVwcGVyW2pdXG4gIH1cblxuICAvL1JldHVybiByZXN1bHRcbiAgcmV0dXJuIHJlc3VsdFxufSIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC5xdWlja3NlbGVjdCA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gcXVpY2tzZWxlY3QoYXJyLCBrLCBsZWZ0LCByaWdodCwgY29tcGFyZSkge1xuICAgIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIGxlZnQgfHwgMCwgcmlnaHQgfHwgKGFyci5sZW5ndGggLSAxKSwgY29tcGFyZSB8fCBkZWZhdWx0Q29tcGFyZSk7XG59XG5cbmZ1bmN0aW9uIHF1aWNrc2VsZWN0U3RlcChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG5cbiAgICB3aGlsZSAocmlnaHQgPiBsZWZ0KSB7XG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPiA2MDApIHtcbiAgICAgICAgICAgIHZhciBuID0gcmlnaHQgLSBsZWZ0ICsgMTtcbiAgICAgICAgICAgIHZhciBtID0gayAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIHogPSBNYXRoLmxvZyhuKTtcbiAgICAgICAgICAgIHZhciBzID0gMC41ICogTWF0aC5leHAoMiAqIHogLyAzKTtcbiAgICAgICAgICAgIHZhciBzZCA9IDAuNSAqIE1hdGguc3FydCh6ICogcyAqIChuIC0gcykgLyBuKSAqIChtIC0gbiAvIDIgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgICAgIHZhciBuZXdMZWZ0ID0gTWF0aC5tYXgobGVmdCwgTWF0aC5mbG9vcihrIC0gbSAqIHMgLyBuICsgc2QpKTtcbiAgICAgICAgICAgIHZhciBuZXdSaWdodCA9IE1hdGgubWluKHJpZ2h0LCBNYXRoLmZsb29yKGsgKyAobiAtIG0pICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbmV3TGVmdCwgbmV3UmlnaHQsIGNvbXBhcmUpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBhcnJba107XG4gICAgICAgIHZhciBpID0gbGVmdDtcbiAgICAgICAgdmFyIGogPSByaWdodDtcblxuICAgICAgICBzd2FwKGFyciwgbGVmdCwgayk7XG4gICAgICAgIGlmIChjb21wYXJlKGFycltyaWdodF0sIHQpID4gMCkgc3dhcChhcnIsIGxlZnQsIHJpZ2h0KTtcblxuICAgICAgICB3aGlsZSAoaSA8IGopIHtcbiAgICAgICAgICAgIHN3YXAoYXJyLCBpLCBqKTtcbiAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgIGotLTtcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltpXSwgdCkgPCAwKSBpKys7XG4gICAgICAgICAgICB3aGlsZSAoY29tcGFyZShhcnJbal0sIHQpID4gMCkgai0tO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW2xlZnRdLCB0KSA9PT0gMCkgc3dhcChhcnIsIGxlZnQsIGopO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIHN3YXAoYXJyLCBqLCByaWdodCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaiA8PSBrKSBsZWZ0ID0gaiArIDE7XG4gICAgICAgIGlmIChrIDw9IGopIHJpZ2h0ID0gaiAtIDE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzd2FwKGFyciwgaSwgaikge1xuICAgIHZhciB0bXAgPSBhcnJbaV07XG4gICAgYXJyW2ldID0gYXJyW2pdO1xuICAgIGFycltqXSA9IHRtcDtcbn1cblxuZnVuY3Rpb24gZGVmYXVsdENvbXBhcmUoYSwgYikge1xuICAgIHJldHVybiBhIDwgYiA/IC0xIDogYSA+IGIgPyAxIDogMDtcbn1cblxucmV0dXJuIHF1aWNrc2VsZWN0O1xuXG59KSkpO1xuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHJidXNoO1xubW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHJidXNoO1xuXG52YXIgcXVpY2tzZWxlY3QgPSByZXF1aXJlKCdxdWlja3NlbGVjdCcpO1xuXG5mdW5jdGlvbiByYnVzaChtYXhFbnRyaWVzLCBmb3JtYXQpIHtcbiAgICBpZiAoISh0aGlzIGluc3RhbmNlb2YgcmJ1c2gpKSByZXR1cm4gbmV3IHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCk7XG5cbiAgICAvLyBtYXggZW50cmllcyBpbiBhIG5vZGUgaXMgOSBieSBkZWZhdWx0OyBtaW4gbm9kZSBmaWxsIGlzIDQwJSBmb3IgYmVzdCBwZXJmb3JtYW5jZVxuICAgIHRoaXMuX21heEVudHJpZXMgPSBNYXRoLm1heCg0LCBtYXhFbnRyaWVzIHx8IDkpO1xuICAgIHRoaXMuX21pbkVudHJpZXMgPSBNYXRoLm1heCgyLCBNYXRoLmNlaWwodGhpcy5fbWF4RW50cmllcyAqIDAuNCkpO1xuXG4gICAgaWYgKGZvcm1hdCkge1xuICAgICAgICB0aGlzLl9pbml0Rm9ybWF0KGZvcm1hdCk7XG4gICAgfVxuXG4gICAgdGhpcy5jbGVhcigpO1xufVxuXG5yYnVzaC5wcm90b3R5cGUgPSB7XG5cbiAgICBhbGw6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FsbCh0aGlzLmRhdGEsIFtdKTtcbiAgICB9LFxuXG4gICAgc2VhcmNoOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiByZXN1bHQ7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgcmVzdWx0LnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSB0aGlzLl9hbGwoY2hpbGQsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2Ugbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIGNvbGxpZGVzOiBmdW5jdGlvbiAoYmJveCkge1xuXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5kYXRhLFxuICAgICAgICAgICAgdG9CQm94ID0gdGhpcy50b0JCb3g7XG5cbiAgICAgICAgaWYgKCFpbnRlcnNlY3RzKGJib3gsIG5vZGUpKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXSxcbiAgICAgICAgICAgIGksIGxlbiwgY2hpbGQsIGNoaWxkQkJveDtcblxuICAgICAgICB3aGlsZSAobm9kZSkge1xuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGNoaWxkQkJveCA9IG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZDtcblxuICAgICAgICAgICAgICAgIGlmIChpbnRlcnNlY3RzKGJib3gsIGNoaWxkQkJveCkpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5vZGUubGVhZiB8fCBjb250YWlucyhiYm94LCBjaGlsZEJCb3gpKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZXNUb1NlYXJjaC5wdXNoKGNoaWxkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub2RlID0gbm9kZXNUb1NlYXJjaC5wb3AoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4gICAgbG9hZDogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgaWYgKCEoZGF0YSAmJiBkYXRhLmxlbmd0aCkpIHJldHVybiB0aGlzO1xuXG4gICAgICAgIGlmIChkYXRhLmxlbmd0aCA8IHRoaXMuX21pbkVudHJpZXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBkYXRhLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5pbnNlcnQoZGF0YVtpXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIHJlY3Vyc2l2ZWx5IGJ1aWxkIHRoZSB0cmVlIHdpdGggdGhlIGdpdmVuIGRhdGEgZnJvbSBzY3JhdGNoIHVzaW5nIE9NVCBhbGdvcml0aG1cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9idWlsZChkYXRhLnNsaWNlKCksIDAsIGRhdGEubGVuZ3RoIC0gMSwgMCk7XG5cbiAgICAgICAgaWYgKCF0aGlzLmRhdGEuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGFzIGlzIGlmIHRyZWUgaXMgZW1wdHlcbiAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG5cbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLmRhdGEuaGVpZ2h0ID09PSBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgLy8gc3BsaXQgcm9vdCBpZiB0cmVlcyBoYXZlIHRoZSBzYW1lIGhlaWdodFxuICAgICAgICAgICAgdGhpcy5fc3BsaXRSb290KHRoaXMuZGF0YSwgbm9kZSk7XG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmRhdGEuaGVpZ2h0IDwgbm9kZS5oZWlnaHQpIHtcbiAgICAgICAgICAgICAgICAvLyBzd2FwIHRyZWVzIGlmIGluc2VydGVkIG9uZSBpcyBiaWdnZXJcbiAgICAgICAgICAgICAgICB2YXIgdG1wTm9kZSA9IHRoaXMuZGF0YTtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGEgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSB0bXBOb2RlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBpbnNlcnQgdGhlIHNtYWxsIHRyZWUgaW50byB0aGUgbGFyZ2UgdHJlZSBhdCBhcHByb3ByaWF0ZSBsZXZlbFxuICAgICAgICAgICAgdGhpcy5faW5zZXJ0KG5vZGUsIHRoaXMuZGF0YS5oZWlnaHQgLSBub2RlLmhlaWdodCAtIDEsIHRydWUpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGluc2VydDogZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgaWYgKGl0ZW0pIHRoaXMuX2luc2VydChpdGVtLCB0aGlzLmRhdGEuaGVpZ2h0IC0gMSk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhcjogZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbW92ZTogZnVuY3Rpb24gKGl0ZW0sIGVxdWFsc0ZuKSB7XG4gICAgICAgIGlmICghaXRlbSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICBiYm94ID0gdGhpcy50b0JCb3goaXRlbSksXG4gICAgICAgICAgICBwYXRoID0gW10sXG4gICAgICAgICAgICBpbmRleGVzID0gW10sXG4gICAgICAgICAgICBpLCBwYXJlbnQsIGluZGV4LCBnb2luZ1VwO1xuXG4gICAgICAgIC8vIGRlcHRoLWZpcnN0IGl0ZXJhdGl2ZSB0cmVlIHRyYXZlcnNhbFxuICAgICAgICB3aGlsZSAobm9kZSB8fCBwYXRoLmxlbmd0aCkge1xuXG4gICAgICAgICAgICBpZiAoIW5vZGUpIHsgLy8gZ28gdXBcbiAgICAgICAgICAgICAgICBub2RlID0gcGF0aC5wb3AoKTtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBwYXRoW3BhdGgubGVuZ3RoIC0gMV07XG4gICAgICAgICAgICAgICAgaSA9IGluZGV4ZXMucG9wKCk7XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IHRydWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHsgLy8gY2hlY2sgY3VycmVudCBub2RlXG4gICAgICAgICAgICAgICAgaW5kZXggPSBmaW5kSXRlbShpdGVtLCBub2RlLmNoaWxkcmVuLCBlcXVhbHNGbik7XG5cbiAgICAgICAgICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGl0ZW0gZm91bmQsIHJlbW92ZSB0aGUgaXRlbSBhbmQgY29uZGVuc2UgdHJlZSB1cHdhcmRzXG4gICAgICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4uc3BsaWNlKGluZGV4LCAxKTtcbiAgICAgICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9jb25kZW5zZShwYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIWdvaW5nVXAgJiYgIW5vZGUubGVhZiAmJiBjb250YWlucyhub2RlLCBiYm94KSkgeyAvLyBnbyBkb3duXG4gICAgICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuICAgICAgICAgICAgICAgIGluZGV4ZXMucHVzaChpKTtcbiAgICAgICAgICAgICAgICBpID0gMDtcbiAgICAgICAgICAgICAgICBwYXJlbnQgPSBub2RlO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBub2RlLmNoaWxkcmVuWzBdO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhcmVudCkgeyAvLyBnbyByaWdodFxuICAgICAgICAgICAgICAgIGkrKztcbiAgICAgICAgICAgICAgICBub2RlID0gcGFyZW50LmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGdvaW5nVXAgPSBmYWxzZTtcblxuICAgICAgICAgICAgfSBlbHNlIG5vZGUgPSBudWxsOyAvLyBub3RoaW5nIGZvdW5kXG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgdG9CQm94OiBmdW5jdGlvbiAoaXRlbSkgeyByZXR1cm4gaXRlbTsgfSxcblxuICAgIGNvbXBhcmVNaW5YOiBjb21wYXJlTm9kZU1pblgsXG4gICAgY29tcGFyZU1pblk6IGNvbXBhcmVOb2RlTWluWSxcblxuICAgIHRvSlNPTjogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5kYXRhOyB9LFxuXG4gICAgZnJvbUpTT046IGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBfYWxsOiBmdW5jdGlvbiAobm9kZSwgcmVzdWx0KSB7XG4gICAgICAgIHZhciBub2Rlc1RvU2VhcmNoID0gW107XG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaC5hcHBseShyZXN1bHQsIG5vZGUuY2hpbGRyZW4pO1xuICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2guYXBwbHkobm9kZXNUb1NlYXJjaCwgbm9kZS5jaGlsZHJlbik7XG5cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSxcblxuICAgIF9idWlsZDogZnVuY3Rpb24gKGl0ZW1zLCBsZWZ0LCByaWdodCwgaGVpZ2h0KSB7XG5cbiAgICAgICAgdmFyIE4gPSByaWdodCAtIGxlZnQgKyAxLFxuICAgICAgICAgICAgTSA9IHRoaXMuX21heEVudHJpZXMsXG4gICAgICAgICAgICBub2RlO1xuXG4gICAgICAgIGlmIChOIDw9IE0pIHtcbiAgICAgICAgICAgIC8vIHJlYWNoZWQgbGVhZiBsZXZlbDsgcmV0dXJuIGxlYWZcbiAgICAgICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKGl0ZW1zLnNsaWNlKGxlZnQsIHJpZ2h0ICsgMSkpO1xuICAgICAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoIWhlaWdodCkge1xuICAgICAgICAgICAgLy8gdGFyZ2V0IGhlaWdodCBvZiB0aGUgYnVsay1sb2FkZWQgdHJlZVxuICAgICAgICAgICAgaGVpZ2h0ID0gTWF0aC5jZWlsKE1hdGgubG9nKE4pIC8gTWF0aC5sb2coTSkpO1xuXG4gICAgICAgICAgICAvLyB0YXJnZXQgbnVtYmVyIG9mIHJvb3QgZW50cmllcyB0byBtYXhpbWl6ZSBzdG9yYWdlIHV0aWxpemF0aW9uXG4gICAgICAgICAgICBNID0gTWF0aC5jZWlsKE4gLyBNYXRoLnBvdyhNLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgIH1cblxuICAgICAgICBub2RlID0gY3JlYXRlTm9kZShbXSk7XG4gICAgICAgIG5vZGUubGVhZiA9IGZhbHNlO1xuICAgICAgICBub2RlLmhlaWdodCA9IGhlaWdodDtcblxuICAgICAgICAvLyBzcGxpdCB0aGUgaXRlbXMgaW50byBNIG1vc3RseSBzcXVhcmUgdGlsZXNcblxuICAgICAgICB2YXIgTjIgPSBNYXRoLmNlaWwoTiAvIE0pLFxuICAgICAgICAgICAgTjEgPSBOMiAqIE1hdGguY2VpbChNYXRoLnNxcnQoTSkpLFxuICAgICAgICAgICAgaSwgaiwgcmlnaHQyLCByaWdodDM7XG5cbiAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGxlZnQsIHJpZ2h0LCBOMSwgdGhpcy5jb21wYXJlTWluWCk7XG5cbiAgICAgICAgZm9yIChpID0gbGVmdDsgaSA8PSByaWdodDsgaSArPSBOMSkge1xuXG4gICAgICAgICAgICByaWdodDIgPSBNYXRoLm1pbihpICsgTjEgLSAxLCByaWdodCk7XG5cbiAgICAgICAgICAgIG11bHRpU2VsZWN0KGl0ZW1zLCBpLCByaWdodDIsIE4yLCB0aGlzLmNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAgICAgZm9yIChqID0gaTsgaiA8PSByaWdodDI7IGogKz0gTjIpIHtcblxuICAgICAgICAgICAgICAgIHJpZ2h0MyA9IE1hdGgubWluKGogKyBOMiAtIDEsIHJpZ2h0Mik7XG5cbiAgICAgICAgICAgICAgICAvLyBwYWNrIGVhY2ggZW50cnkgcmVjdXJzaXZlbHlcbiAgICAgICAgICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2godGhpcy5fYnVpbGQoaXRlbXMsIGosIHJpZ2h0MywgaGVpZ2h0IC0gMSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3VidHJlZTogZnVuY3Rpb24gKGJib3gsIG5vZGUsIGxldmVsLCBwYXRoKSB7XG5cbiAgICAgICAgdmFyIGksIGxlbiwgY2hpbGQsIHRhcmdldE5vZGUsIGFyZWEsIGVubGFyZ2VtZW50LCBtaW5BcmVhLCBtaW5FbmxhcmdlbWVudDtcblxuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgICAgcGF0aC5wdXNoKG5vZGUpO1xuXG4gICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IHBhdGgubGVuZ3RoIC0gMSA9PT0gbGV2ZWwpIGJyZWFrO1xuXG4gICAgICAgICAgICBtaW5BcmVhID0gbWluRW5sYXJnZW1lbnQgPSBJbmZpbml0eTtcblxuICAgICAgICAgICAgZm9yIChpID0gMCwgbGVuID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoY2hpbGQpO1xuICAgICAgICAgICAgICAgIGVubGFyZ2VtZW50ID0gZW5sYXJnZWRBcmVhKGJib3gsIGNoaWxkKSAtIGFyZWE7XG5cbiAgICAgICAgICAgICAgICAvLyBjaG9vc2UgZW50cnkgd2l0aCB0aGUgbGVhc3QgYXJlYSBlbmxhcmdlbWVudFxuICAgICAgICAgICAgICAgIGlmIChlbmxhcmdlbWVudCA8IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIG1pbkVubGFyZ2VtZW50ID0gZW5sYXJnZW1lbnQ7XG4gICAgICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGVubGFyZ2VtZW50ID09PSBtaW5FbmxhcmdlbWVudCkge1xuICAgICAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIG9uZSB3aXRoIHRoZSBzbWFsbGVzdCBhcmVhXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlID0gY2hpbGQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIG5vZGUgPSB0YXJnZXROb2RlIHx8IG5vZGUuY2hpbGRyZW5bMF07XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbm9kZTtcbiAgICB9LFxuXG4gICAgX2luc2VydDogZnVuY3Rpb24gKGl0ZW0sIGxldmVsLCBpc05vZGUpIHtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBiYm94ID0gaXNOb2RlID8gaXRlbSA6IHRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIGluc2VydFBhdGggPSBbXTtcblxuICAgICAgICAvLyBmaW5kIHRoZSBiZXN0IG5vZGUgZm9yIGFjY29tbW9kYXRpbmcgdGhlIGl0ZW0sIHNhdmluZyBhbGwgbm9kZXMgYWxvbmcgdGhlIHBhdGggdG9vXG4gICAgICAgIHZhciBub2RlID0gdGhpcy5fY2hvb3NlU3VidHJlZShiYm94LCB0aGlzLmRhdGEsIGxldmVsLCBpbnNlcnRQYXRoKTtcblxuICAgICAgICAvLyBwdXQgdGhlIGl0ZW0gaW50byB0aGUgbm9kZVxuICAgICAgICBub2RlLmNoaWxkcmVuLnB1c2goaXRlbSk7XG4gICAgICAgIGV4dGVuZChub2RlLCBiYm94KTtcblxuICAgICAgICAvLyBzcGxpdCBvbiBub2RlIG92ZXJmbG93OyBwcm9wYWdhdGUgdXB3YXJkcyBpZiBuZWNlc3NhcnlcbiAgICAgICAgd2hpbGUgKGxldmVsID49IDApIHtcbiAgICAgICAgICAgIGlmIChpbnNlcnRQYXRoW2xldmVsXS5jaGlsZHJlbi5sZW5ndGggPiB0aGlzLl9tYXhFbnRyaWVzKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fc3BsaXQoaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgICAgICAgICAgICAgIGxldmVsLS07XG4gICAgICAgICAgICB9IGVsc2UgYnJlYWs7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBpbnNlcnRpb24gcGF0aFxuICAgICAgICB0aGlzLl9hZGp1c3RQYXJlbnRCQm94ZXMoYmJveCwgaW5zZXJ0UGF0aCwgbGV2ZWwpO1xuICAgIH0sXG5cbiAgICAvLyBzcGxpdCBvdmVyZmxvd2VkIG5vZGUgaW50byB0d29cbiAgICBfc3BsaXQ6IGZ1bmN0aW9uIChpbnNlcnRQYXRoLCBsZXZlbCkge1xuXG4gICAgICAgIHZhciBub2RlID0gaW5zZXJ0UGF0aFtsZXZlbF0sXG4gICAgICAgICAgICBNID0gbm9kZS5jaGlsZHJlbi5sZW5ndGgsXG4gICAgICAgICAgICBtID0gdGhpcy5fbWluRW50cmllcztcblxuICAgICAgICB0aGlzLl9jaG9vc2VTcGxpdEF4aXMobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIHNwbGl0SW5kZXggPSB0aGlzLl9jaG9vc2VTcGxpdEluZGV4KG5vZGUsIG0sIE0pO1xuXG4gICAgICAgIHZhciBuZXdOb2RlID0gY3JlYXRlTm9kZShub2RlLmNoaWxkcmVuLnNwbGljZShzcGxpdEluZGV4LCBub2RlLmNoaWxkcmVuLmxlbmd0aCAtIHNwbGl0SW5kZXgpKTtcbiAgICAgICAgbmV3Tm9kZS5oZWlnaHQgPSBub2RlLmhlaWdodDtcbiAgICAgICAgbmV3Tm9kZS5sZWFmID0gbm9kZS5sZWFmO1xuXG4gICAgICAgIGNhbGNCQm94KG5vZGUsIHRoaXMudG9CQm94KTtcbiAgICAgICAgY2FsY0JCb3gobmV3Tm9kZSwgdGhpcy50b0JCb3gpO1xuXG4gICAgICAgIGlmIChsZXZlbCkgaW5zZXJ0UGF0aFtsZXZlbCAtIDFdLmNoaWxkcmVuLnB1c2gobmV3Tm9kZSk7XG4gICAgICAgIGVsc2UgdGhpcy5fc3BsaXRSb290KG5vZGUsIG5ld05vZGUpO1xuICAgIH0sXG5cbiAgICBfc3BsaXRSb290OiBmdW5jdGlvbiAobm9kZSwgbmV3Tm9kZSkge1xuICAgICAgICAvLyBzcGxpdCByb290IG5vZGVcbiAgICAgICAgdGhpcy5kYXRhID0gY3JlYXRlTm9kZShbbm9kZSwgbmV3Tm9kZV0pO1xuICAgICAgICB0aGlzLmRhdGEuaGVpZ2h0ID0gbm9kZS5oZWlnaHQgKyAxO1xuICAgICAgICB0aGlzLmRhdGEubGVhZiA9IGZhbHNlO1xuICAgICAgICBjYWxjQkJveCh0aGlzLmRhdGEsIHRoaXMudG9CQm94KTtcbiAgICB9LFxuXG4gICAgX2Nob29zZVNwbGl0SW5kZXg6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGksIGJib3gxLCBiYm94Miwgb3ZlcmxhcCwgYXJlYSwgbWluT3ZlcmxhcCwgbWluQXJlYSwgaW5kZXg7XG5cbiAgICAgICAgbWluT3ZlcmxhcCA9IG1pbkFyZWEgPSBJbmZpbml0eTtcblxuICAgICAgICBmb3IgKGkgPSBtOyBpIDw9IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGJib3gxID0gZGlzdEJCb3gobm9kZSwgMCwgaSwgdGhpcy50b0JCb3gpO1xuICAgICAgICAgICAgYmJveDIgPSBkaXN0QkJveChub2RlLCBpLCBNLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgICAgIG92ZXJsYXAgPSBpbnRlcnNlY3Rpb25BcmVhKGJib3gxLCBiYm94Mik7XG4gICAgICAgICAgICBhcmVhID0gYmJveEFyZWEoYmJveDEpICsgYmJveEFyZWEoYmJveDIpO1xuXG4gICAgICAgICAgICAvLyBjaG9vc2UgZGlzdHJpYnV0aW9uIHdpdGggbWluaW11bSBvdmVybGFwXG4gICAgICAgICAgICBpZiAob3ZlcmxhcCA8IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICBtaW5PdmVybGFwID0gb3ZlcmxhcDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG5cbiAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYSA8IG1pbkFyZWEgPyBhcmVhIDogbWluQXJlYTtcblxuICAgICAgICAgICAgfSBlbHNlIGlmIChvdmVybGFwID09PSBtaW5PdmVybGFwKSB7XG4gICAgICAgICAgICAgICAgLy8gb3RoZXJ3aXNlIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIGFyZWFcbiAgICAgICAgICAgICAgICBpZiAoYXJlYSA8IG1pbkFyZWEpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWE7XG4gICAgICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgfSxcblxuICAgIC8vIHNvcnRzIG5vZGUgY2hpbGRyZW4gYnkgdGhlIGJlc3QgYXhpcyBmb3Igc3BsaXRcbiAgICBfY2hvb3NlU3BsaXRBeGlzOiBmdW5jdGlvbiAobm9kZSwgbSwgTSkge1xuXG4gICAgICAgIHZhciBjb21wYXJlTWluWCA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblggOiBjb21wYXJlTm9kZU1pblgsXG4gICAgICAgICAgICBjb21wYXJlTWluWSA9IG5vZGUubGVhZiA/IHRoaXMuY29tcGFyZU1pblkgOiBjb21wYXJlTm9kZU1pblksXG4gICAgICAgICAgICB4TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWCksXG4gICAgICAgICAgICB5TWFyZ2luID0gdGhpcy5fYWxsRGlzdE1hcmdpbihub2RlLCBtLCBNLCBjb21wYXJlTWluWSk7XG5cbiAgICAgICAgLy8gaWYgdG90YWwgZGlzdHJpYnV0aW9ucyBtYXJnaW4gdmFsdWUgaXMgbWluaW1hbCBmb3IgeCwgc29ydCBieSBtaW5YLFxuICAgICAgICAvLyBvdGhlcndpc2UgaXQncyBhbHJlYWR5IHNvcnRlZCBieSBtaW5ZXG4gICAgICAgIGlmICh4TWFyZ2luIDwgeU1hcmdpbikgbm9kZS5jaGlsZHJlbi5zb3J0KGNvbXBhcmVNaW5YKTtcbiAgICB9LFxuXG4gICAgLy8gdG90YWwgbWFyZ2luIG9mIGFsbCBwb3NzaWJsZSBzcGxpdCBkaXN0cmlidXRpb25zIHdoZXJlIGVhY2ggbm9kZSBpcyBhdCBsZWFzdCBtIGZ1bGxcbiAgICBfYWxsRGlzdE1hcmdpbjogZnVuY3Rpb24gKG5vZGUsIG0sIE0sIGNvbXBhcmUpIHtcblxuICAgICAgICBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZSk7XG5cbiAgICAgICAgdmFyIHRvQkJveCA9IHRoaXMudG9CQm94LFxuICAgICAgICAgICAgbGVmdEJCb3ggPSBkaXN0QkJveChub2RlLCAwLCBtLCB0b0JCb3gpLFxuICAgICAgICAgICAgcmlnaHRCQm94ID0gZGlzdEJCb3gobm9kZSwgTSAtIG0sIE0sIHRvQkJveCksXG4gICAgICAgICAgICBtYXJnaW4gPSBiYm94TWFyZ2luKGxlZnRCQm94KSArIGJib3hNYXJnaW4ocmlnaHRCQm94KSxcbiAgICAgICAgICAgIGksIGNoaWxkO1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPCBNIC0gbTsgaSsrKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQobGVmdEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihsZWZ0QkJveCk7XG4gICAgICAgIH1cblxuICAgICAgICBmb3IgKGkgPSBNIC0gbSAtIDE7IGkgPj0gbTsgaS0tKSB7XG4gICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICBleHRlbmQocmlnaHRCQm94LCBub2RlLmxlYWYgPyB0b0JCb3goY2hpbGQpIDogY2hpbGQpO1xuICAgICAgICAgICAgbWFyZ2luICs9IGJib3hNYXJnaW4ocmlnaHRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBtYXJnaW47XG4gICAgfSxcblxuICAgIF9hZGp1c3RQYXJlbnRCQm94ZXM6IGZ1bmN0aW9uIChiYm94LCBwYXRoLCBsZXZlbCkge1xuICAgICAgICAvLyBhZGp1c3QgYmJveGVzIGFsb25nIHRoZSBnaXZlbiB0cmVlIHBhdGhcbiAgICAgICAgZm9yICh2YXIgaSA9IGxldmVsOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgZXh0ZW5kKHBhdGhbaV0sIGJib3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9jb25kZW5zZTogZnVuY3Rpb24gKHBhdGgpIHtcbiAgICAgICAgLy8gZ28gdGhyb3VnaCB0aGUgcGF0aCwgcmVtb3ZpbmcgZW1wdHkgbm9kZXMgYW5kIHVwZGF0aW5nIGJib3hlc1xuICAgICAgICBmb3IgKHZhciBpID0gcGF0aC5sZW5ndGggLSAxLCBzaWJsaW5nczsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICAgIGlmIChwYXRoW2ldLmNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncyA9IHBhdGhbaSAtIDFdLmNoaWxkcmVuO1xuICAgICAgICAgICAgICAgICAgICBzaWJsaW5ncy5zcGxpY2Uoc2libGluZ3MuaW5kZXhPZihwYXRoW2ldKSwgMSk7XG5cbiAgICAgICAgICAgICAgICB9IGVsc2UgdGhpcy5jbGVhcigpO1xuXG4gICAgICAgICAgICB9IGVsc2UgY2FsY0JCb3gocGF0aFtpXSwgdGhpcy50b0JCb3gpO1xuICAgICAgICB9XG4gICAgfSxcblxuICAgIF9pbml0Rm9ybWF0OiBmdW5jdGlvbiAoZm9ybWF0KSB7XG4gICAgICAgIC8vIGRhdGEgZm9ybWF0IChtaW5YLCBtaW5ZLCBtYXhYLCBtYXhZIGFjY2Vzc29ycylcblxuICAgICAgICAvLyB1c2VzIGV2YWwtdHlwZSBmdW5jdGlvbiBjb21waWxhdGlvbiBpbnN0ZWFkIG9mIGp1c3QgYWNjZXB0aW5nIGEgdG9CQm94IGZ1bmN0aW9uXG4gICAgICAgIC8vIGJlY2F1c2UgdGhlIGFsZ29yaXRobXMgYXJlIHZlcnkgc2Vuc2l0aXZlIHRvIHNvcnRpbmcgZnVuY3Rpb25zIHBlcmZvcm1hbmNlLFxuICAgICAgICAvLyBzbyB0aGV5IHNob3VsZCBiZSBkZWFkIHNpbXBsZSBhbmQgd2l0aG91dCBpbm5lciBjYWxsc1xuXG4gICAgICAgIHZhciBjb21wYXJlQXJyID0gWydyZXR1cm4gYScsICcgLSBiJywgJzsnXTtcblxuICAgICAgICB0aGlzLmNvbXBhcmVNaW5YID0gbmV3IEZ1bmN0aW9uKCdhJywgJ2InLCBjb21wYXJlQXJyLmpvaW4oZm9ybWF0WzBdKSk7XG4gICAgICAgIHRoaXMuY29tcGFyZU1pblkgPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMV0pKTtcblxuICAgICAgICB0aGlzLnRvQkJveCA9IG5ldyBGdW5jdGlvbignYScsXG4gICAgICAgICAgICAncmV0dXJuIHttaW5YOiBhJyArIGZvcm1hdFswXSArXG4gICAgICAgICAgICAnLCBtaW5ZOiBhJyArIGZvcm1hdFsxXSArXG4gICAgICAgICAgICAnLCBtYXhYOiBhJyArIGZvcm1hdFsyXSArXG4gICAgICAgICAgICAnLCBtYXhZOiBhJyArIGZvcm1hdFszXSArICd9OycpO1xuICAgIH1cbn07XG5cbmZ1bmN0aW9uIGZpbmRJdGVtKGl0ZW0sIGl0ZW1zLCBlcXVhbHNGbikge1xuICAgIGlmICghZXF1YWxzRm4pIHJldHVybiBpdGVtcy5pbmRleE9mKGl0ZW0pO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBpdGVtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZXF1YWxzRm4oaXRlbSwgaXRlbXNbaV0pKSByZXR1cm4gaTtcbiAgICB9XG4gICAgcmV0dXJuIC0xO1xufVxuXG4vLyBjYWxjdWxhdGUgbm9kZSdzIGJib3ggZnJvbSBiYm94ZXMgb2YgaXRzIGNoaWxkcmVuXG5mdW5jdGlvbiBjYWxjQkJveChub2RlLCB0b0JCb3gpIHtcbiAgICBkaXN0QkJveChub2RlLCAwLCBub2RlLmNoaWxkcmVuLmxlbmd0aCwgdG9CQm94LCBub2RlKTtcbn1cblxuLy8gbWluIGJvdW5kaW5nIHJlY3RhbmdsZSBvZiBub2RlIGNoaWxkcmVuIGZyb20gayB0byBwLTFcbmZ1bmN0aW9uIGRpc3RCQm94KG5vZGUsIGssIHAsIHRvQkJveCwgZGVzdE5vZGUpIHtcbiAgICBpZiAoIWRlc3ROb2RlKSBkZXN0Tm9kZSA9IGNyZWF0ZU5vZGUobnVsbCk7XG4gICAgZGVzdE5vZGUubWluWCA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1pblkgPSBJbmZpbml0eTtcbiAgICBkZXN0Tm9kZS5tYXhYID0gLUluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFkgPSAtSW5maW5pdHk7XG5cbiAgICBmb3IgKHZhciBpID0gaywgY2hpbGQ7IGkgPCBwOyBpKyspIHtcbiAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICBleHRlbmQoZGVzdE5vZGUsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRlc3ROb2RlO1xufVxuXG5mdW5jdGlvbiBleHRlbmQoYSwgYikge1xuICAgIGEubWluWCA9IE1hdGgubWluKGEubWluWCwgYi5taW5YKTtcbiAgICBhLm1pblkgPSBNYXRoLm1pbihhLm1pblksIGIubWluWSk7XG4gICAgYS5tYXhYID0gTWF0aC5tYXgoYS5tYXhYLCBiLm1heFgpO1xuICAgIGEubWF4WSA9IE1hdGgubWF4KGEubWF4WSwgYi5tYXhZKTtcbiAgICByZXR1cm4gYTtcbn1cblxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5YKGEsIGIpIHsgcmV0dXJuIGEubWluWCAtIGIubWluWDsgfVxuZnVuY3Rpb24gY29tcGFyZU5vZGVNaW5ZKGEsIGIpIHsgcmV0dXJuIGEubWluWSAtIGIubWluWTsgfVxuXG5mdW5jdGlvbiBiYm94QXJlYShhKSAgIHsgcmV0dXJuIChhLm1heFggLSBhLm1pblgpICogKGEubWF4WSAtIGEubWluWSk7IH1cbmZ1bmN0aW9uIGJib3hNYXJnaW4oYSkgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKyAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuXG5mdW5jdGlvbiBlbmxhcmdlZEFyZWEoYSwgYikge1xuICAgIHJldHVybiAoTWF0aC5tYXgoYi5tYXhYLCBhLm1heFgpIC0gTWF0aC5taW4oYi5taW5YLCBhLm1pblgpKSAqXG4gICAgICAgICAgIChNYXRoLm1heChiLm1heFksIGEubWF4WSkgLSBNYXRoLm1pbihiLm1pblksIGEubWluWSkpO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3Rpb25BcmVhKGEsIGIpIHtcbiAgICB2YXIgbWluWCA9IE1hdGgubWF4KGEubWluWCwgYi5taW5YKSxcbiAgICAgICAgbWluWSA9IE1hdGgubWF4KGEubWluWSwgYi5taW5ZKSxcbiAgICAgICAgbWF4WCA9IE1hdGgubWluKGEubWF4WCwgYi5tYXhYKSxcbiAgICAgICAgbWF4WSA9IE1hdGgubWluKGEubWF4WSwgYi5tYXhZKTtcblxuICAgIHJldHVybiBNYXRoLm1heCgwLCBtYXhYIC0gbWluWCkgKlxuICAgICAgICAgICBNYXRoLm1heCgwLCBtYXhZIC0gbWluWSk7XG59XG5cbmZ1bmN0aW9uIGNvbnRhaW5zKGEsIGIpIHtcbiAgICByZXR1cm4gYS5taW5YIDw9IGIubWluWCAmJlxuICAgICAgICAgICBhLm1pblkgPD0gYi5taW5ZICYmXG4gICAgICAgICAgIGIubWF4WCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5tYXhZIDw9IGEubWF4WTtcbn1cblxuZnVuY3Rpb24gaW50ZXJzZWN0cyhhLCBiKSB7XG4gICAgcmV0dXJuIGIubWluWCA8PSBhLm1heFggJiZcbiAgICAgICAgICAgYi5taW5ZIDw9IGEubWF4WSAmJlxuICAgICAgICAgICBiLm1heFggPj0gYS5taW5YICYmXG4gICAgICAgICAgIGIubWF4WSA+PSBhLm1pblk7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZU5vZGUoY2hpbGRyZW4pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICBjaGlsZHJlbjogY2hpbGRyZW4sXG4gICAgICAgIGhlaWdodDogMSxcbiAgICAgICAgbGVhZjogdHJ1ZSxcbiAgICAgICAgbWluWDogSW5maW5pdHksXG4gICAgICAgIG1pblk6IEluZmluaXR5LFxuICAgICAgICBtYXhYOiAtSW5maW5pdHksXG4gICAgICAgIG1heFk6IC1JbmZpbml0eVxuICAgIH07XG59XG5cbi8vIHNvcnQgYW4gYXJyYXkgc28gdGhhdCBpdGVtcyBjb21lIGluIGdyb3VwcyBvZiBuIHVuc29ydGVkIGl0ZW1zLCB3aXRoIGdyb3VwcyBzb3J0ZWQgYmV0d2VlbiBlYWNoIG90aGVyO1xuLy8gY29tYmluZXMgc2VsZWN0aW9uIGFsZ29yaXRobSB3aXRoIGJpbmFyeSBkaXZpZGUgJiBjb25xdWVyIGFwcHJvYWNoXG5cbmZ1bmN0aW9uIG11bHRpU2VsZWN0KGFyciwgbGVmdCwgcmlnaHQsIG4sIGNvbXBhcmUpIHtcbiAgICB2YXIgc3RhY2sgPSBbbGVmdCwgcmlnaHRdLFxuICAgICAgICBtaWQ7XG5cbiAgICB3aGlsZSAoc3RhY2subGVuZ3RoKSB7XG4gICAgICAgIHJpZ2h0ID0gc3RhY2sucG9wKCk7XG4gICAgICAgIGxlZnQgPSBzdGFjay5wb3AoKTtcblxuICAgICAgICBpZiAocmlnaHQgLSBsZWZ0IDw9IG4pIGNvbnRpbnVlO1xuXG4gICAgICAgIG1pZCA9IGxlZnQgKyBNYXRoLmNlaWwoKHJpZ2h0IC0gbGVmdCkgLyBuIC8gMikgKiBuO1xuICAgICAgICBxdWlja3NlbGVjdChhcnIsIG1pZCwgbGVmdCwgcmlnaHQsIGNvbXBhcmUpO1xuXG4gICAgICAgIHN0YWNrLnB1c2gobGVmdCwgbWlkLCBtaWQsIHJpZ2h0KTtcbiAgICB9XG59XG4iLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHJvYnVzdFN1bSA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VtXCIpXG52YXIgcm9idXN0U2NhbGUgPSByZXF1aXJlKFwicm9idXN0LXNjYWxlXCIpXG52YXIgcm9idXN0U3VidHJhY3QgPSByZXF1aXJlKFwicm9idXN0LXN1YnRyYWN0XCIpXG5cbnZhciBOVU1fRVhQQU5EID0gNVxuXG52YXIgRVBTSUxPTiAgICAgPSAxLjExMDIyMzAyNDYyNTE1NjVlLTE2XG52YXIgRVJSQk9VTkQzICAgPSAoMy4wICsgMTYuMCAqIEVQU0lMT04pICogRVBTSUxPTlxudmFyIEVSUkJPVU5ENCAgID0gKDcuMCArIDU2LjAgKiBFUFNJTE9OKSAqIEVQU0lMT05cblxuZnVuY3Rpb24gY29mYWN0b3IobSwgYykge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG0ubGVuZ3RoLTEpXG4gIGZvcih2YXIgaT0xOyBpPG0ubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgciA9IHJlc3VsdFtpLTFdID0gbmV3IEFycmF5KG0ubGVuZ3RoLTEpXG4gICAgZm9yKHZhciBqPTAsaz0wOyBqPG0ubGVuZ3RoOyArK2opIHtcbiAgICAgIGlmKGogPT09IGMpIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHJbaysrXSA9IG1baV1bal1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBtYXRyaXgobikge1xuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KG4pXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIHJlc3VsdFtpXSA9IG5ldyBBcnJheShuKVxuICAgIGZvcih2YXIgaj0wOyBqPG47ICsraikge1xuICAgICAgcmVzdWx0W2ldW2pdID0gW1wibVwiLCBqLCBcIltcIiwgKG4taS0xKSwgXCJdXCJdLmpvaW4oXCJcIilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdFxufVxuXG5mdW5jdGlvbiBzaWduKG4pIHtcbiAgaWYobiAmIDEpIHtcbiAgICByZXR1cm4gXCItXCJcbiAgfVxuICByZXR1cm4gXCJcIlxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZVN1bShleHByKSB7XG4gIGlmKGV4cHIubGVuZ3RoID09PSAxKSB7XG4gICAgcmV0dXJuIGV4cHJbMF1cbiAgfSBlbHNlIGlmKGV4cHIubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFtcInN1bShcIiwgZXhwclswXSwgXCIsXCIsIGV4cHJbMV0sIFwiKVwiXS5qb2luKFwiXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG0gPSBleHByLmxlbmd0aD4+MVxuICAgIHJldHVybiBbXCJzdW0oXCIsIGdlbmVyYXRlU3VtKGV4cHIuc2xpY2UoMCwgbSkpLCBcIixcIiwgZ2VuZXJhdGVTdW0oZXhwci5zbGljZShtKSksIFwiKVwiXS5qb2luKFwiXCIpXG4gIH1cbn1cblxuZnVuY3Rpb24gZGV0ZXJtaW5hbnQobSkge1xuICBpZihtLmxlbmd0aCA9PT0gMikge1xuICAgIHJldHVybiBbW1wic3VtKHByb2QoXCIsIG1bMF1bMF0sIFwiLFwiLCBtWzFdWzFdLCBcIikscHJvZCgtXCIsIG1bMF1bMV0sIFwiLFwiLCBtWzFdWzBdLCBcIikpXCJdLmpvaW4oXCJcIildXG4gIH0gZWxzZSB7XG4gICAgdmFyIGV4cHIgPSBbXVxuICAgIGZvcih2YXIgaT0wOyBpPG0ubGVuZ3RoOyArK2kpIHtcbiAgICAgIGV4cHIucHVzaChbXCJzY2FsZShcIiwgZ2VuZXJhdGVTdW0oZGV0ZXJtaW5hbnQoY29mYWN0b3IobSwgaSkpKSwgXCIsXCIsIHNpZ24oaSksIG1bMF1baV0sIFwiKVwiXS5qb2luKFwiXCIpKVxuICAgIH1cbiAgICByZXR1cm4gZXhwclxuICB9XG59XG5cbmZ1bmN0aW9uIG9yaWVudGF0aW9uKG4pIHtcbiAgdmFyIHBvcyA9IFtdXG4gIHZhciBuZWcgPSBbXVxuICB2YXIgbSA9IG1hdHJpeChuKVxuICB2YXIgYXJncyA9IFtdXG4gIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgIGlmKChpJjEpPT09MCkge1xuICAgICAgcG9zLnB1c2guYXBwbHkocG9zLCBkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpXG4gICAgfSBlbHNlIHtcbiAgICAgIG5lZy5wdXNoLmFwcGx5KG5lZywgZGV0ZXJtaW5hbnQoY29mYWN0b3IobSwgaSkpKVxuICAgIH1cbiAgICBhcmdzLnB1c2goXCJtXCIgKyBpKVxuICB9XG4gIHZhciBwb3NFeHByID0gZ2VuZXJhdGVTdW0ocG9zKVxuICB2YXIgbmVnRXhwciA9IGdlbmVyYXRlU3VtKG5lZylcbiAgdmFyIGZ1bmNOYW1lID0gXCJvcmllbnRhdGlvblwiICsgbiArIFwiRXhhY3RcIlxuICB2YXIgY29kZSA9IFtcImZ1bmN0aW9uIFwiLCBmdW5jTmFtZSwgXCIoXCIsIGFyZ3Muam9pbigpLCBcIil7dmFyIHA9XCIsIHBvc0V4cHIsIFwiLG49XCIsIG5lZ0V4cHIsIFwiLGQ9c3ViKHAsbik7XFxcbnJldHVybiBkW2QubGVuZ3RoLTFdO307cmV0dXJuIFwiLCBmdW5jTmFtZV0uam9pbihcIlwiKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcInN1bVwiLCBcInByb2RcIiwgXCJzY2FsZVwiLCBcInN1YlwiLCBjb2RlKVxuICByZXR1cm4gcHJvYyhyb2J1c3RTdW0sIHR3b1Byb2R1Y3QsIHJvYnVzdFNjYWxlLCByb2J1c3RTdWJ0cmFjdClcbn1cblxudmFyIG9yaWVudGF0aW9uM0V4YWN0ID0gb3JpZW50YXRpb24oMylcbnZhciBvcmllbnRhdGlvbjRFeGFjdCA9IG9yaWVudGF0aW9uKDQpXG5cbnZhciBDQUNIRUQgPSBbXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMCgpIHsgcmV0dXJuIDAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24xKCkgeyByZXR1cm4gMCB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjIoYSwgYikgeyBcbiAgICByZXR1cm4gYlswXSAtIGFbMF1cbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24zKGEsIGIsIGMpIHtcbiAgICB2YXIgbCA9IChhWzFdIC0gY1sxXSkgKiAoYlswXSAtIGNbMF0pXG4gICAgdmFyIHIgPSAoYVswXSAtIGNbMF0pICogKGJbMV0gLSBjWzFdKVxuICAgIHZhciBkZXQgPSBsIC0gclxuICAgIHZhciBzXG4gICAgaWYobCA+IDApIHtcbiAgICAgIGlmKHIgPD0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gbCArIHJcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYobCA8IDApIHtcbiAgICAgIGlmKHIgPj0gMCkge1xuICAgICAgICByZXR1cm4gZGV0XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzID0gLShsICsgcilcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICB2YXIgdG9sID0gRVJSQk9VTkQzICogc1xuICAgIGlmKGRldCA+PSB0b2wgfHwgZGV0IDw9IC10b2wpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uM0V4YWN0KGEsIGIsIGMpXG4gIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uNChhLGIsYyxkKSB7XG4gICAgdmFyIGFkeCA9IGFbMF0gLSBkWzBdXG4gICAgdmFyIGJkeCA9IGJbMF0gLSBkWzBdXG4gICAgdmFyIGNkeCA9IGNbMF0gLSBkWzBdXG4gICAgdmFyIGFkeSA9IGFbMV0gLSBkWzFdXG4gICAgdmFyIGJkeSA9IGJbMV0gLSBkWzFdXG4gICAgdmFyIGNkeSA9IGNbMV0gLSBkWzFdXG4gICAgdmFyIGFkeiA9IGFbMl0gLSBkWzJdXG4gICAgdmFyIGJkeiA9IGJbMl0gLSBkWzJdXG4gICAgdmFyIGNkeiA9IGNbMl0gLSBkWzJdXG4gICAgdmFyIGJkeGNkeSA9IGJkeCAqIGNkeVxuICAgIHZhciBjZHhiZHkgPSBjZHggKiBiZHlcbiAgICB2YXIgY2R4YWR5ID0gY2R4ICogYWR5XG4gICAgdmFyIGFkeGNkeSA9IGFkeCAqIGNkeVxuICAgIHZhciBhZHhiZHkgPSBhZHggKiBiZHlcbiAgICB2YXIgYmR4YWR5ID0gYmR4ICogYWR5XG4gICAgdmFyIGRldCA9IGFkeiAqIChiZHhjZHkgLSBjZHhiZHkpIFxuICAgICAgICAgICAgKyBiZHogKiAoY2R4YWR5IC0gYWR4Y2R5KVxuICAgICAgICAgICAgKyBjZHogKiAoYWR4YmR5IC0gYmR4YWR5KVxuICAgIHZhciBwZXJtYW5lbnQgPSAoTWF0aC5hYnMoYmR4Y2R5KSArIE1hdGguYWJzKGNkeGJkeSkpICogTWF0aC5hYnMoYWR6KVxuICAgICAgICAgICAgICAgICAgKyAoTWF0aC5hYnMoY2R4YWR5KSArIE1hdGguYWJzKGFkeGNkeSkpICogTWF0aC5hYnMoYmR6KVxuICAgICAgICAgICAgICAgICAgKyAoTWF0aC5hYnMoYWR4YmR5KSArIE1hdGguYWJzKGJkeGFkeSkpICogTWF0aC5hYnMoY2R6KVxuICAgIHZhciB0b2wgPSBFUlJCT1VORDQgKiBwZXJtYW5lbnRcbiAgICBpZiAoKGRldCA+IHRvbCkgfHwgKC1kZXQgPiB0b2wpKSB7XG4gICAgICByZXR1cm4gZGV0XG4gICAgfVxuICAgIHJldHVybiBvcmllbnRhdGlvbjRFeGFjdChhLGIsYyxkKVxuICB9XG5dXG5cbmZ1bmN0aW9uIHNsb3dPcmllbnQoYXJncykge1xuICB2YXIgcHJvYyA9IENBQ0hFRFthcmdzLmxlbmd0aF1cbiAgaWYoIXByb2MpIHtcbiAgICBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXSA9IG9yaWVudGF0aW9uKGFyZ3MubGVuZ3RoKVxuICB9XG4gIHJldHVybiBwcm9jLmFwcGx5KHVuZGVmaW5lZCwgYXJncylcbn1cblxuZnVuY3Rpb24gZ2VuZXJhdGVPcmllbnRhdGlvblByb2MoKSB7XG4gIHdoaWxlKENBQ0hFRC5sZW5ndGggPD0gTlVNX0VYUEFORCkge1xuICAgIENBQ0hFRC5wdXNoKG9yaWVudGF0aW9uKENBQ0hFRC5sZW5ndGgpKVxuICB9XG4gIHZhciBhcmdzID0gW11cbiAgdmFyIHByb2NBcmdzID0gW1wic2xvd1wiXVxuICBmb3IodmFyIGk9MDsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgYXJncy5wdXNoKFwiYVwiICsgaSlcbiAgICBwcm9jQXJncy5wdXNoKFwib1wiICsgaSlcbiAgfVxuICB2YXIgY29kZSA9IFtcbiAgICBcImZ1bmN0aW9uIGdldE9yaWVudGF0aW9uKFwiLCBhcmdzLmpvaW4oKSwgXCIpe3N3aXRjaChhcmd1bWVudHMubGVuZ3RoKXtjYXNlIDA6Y2FzZSAxOnJldHVybiAwO1wiXG4gIF1cbiAgZm9yKHZhciBpPTI7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIGNvZGUucHVzaChcImNhc2UgXCIsIGksIFwiOnJldHVybiBvXCIsIGksIFwiKFwiLCBhcmdzLnNsaWNlKDAsIGkpLmpvaW4oKSwgXCIpO1wiKVxuICB9XG4gIGNvZGUucHVzaChcIn12YXIgcz1uZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCk7Zm9yKHZhciBpPTA7aTxhcmd1bWVudHMubGVuZ3RoOysraSl7c1tpXT1hcmd1bWVudHNbaV19O3JldHVybiBzbG93KHMpO31yZXR1cm4gZ2V0T3JpZW50YXRpb25cIilcbiAgcHJvY0FyZ3MucHVzaChjb2RlLmpvaW4oXCJcIikpXG5cbiAgdmFyIHByb2MgPSBGdW5jdGlvbi5hcHBseSh1bmRlZmluZWQsIHByb2NBcmdzKVxuICBtb2R1bGUuZXhwb3J0cyA9IHByb2MuYXBwbHkodW5kZWZpbmVkLCBbc2xvd09yaWVudF0uY29uY2F0KENBQ0hFRCkpXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBtb2R1bGUuZXhwb3J0c1tpXSA9IENBQ0hFRFtpXVxuICB9XG59XG5cbmdlbmVyYXRlT3JpZW50YXRpb25Qcm9jKCkiLCJcInVzZSBzdHJpY3RcIlxuXG52YXIgdHdvUHJvZHVjdCA9IHJlcXVpcmUoXCJ0d28tcHJvZHVjdFwiKVxudmFyIHR3b1N1bSA9IHJlcXVpcmUoXCJ0d28tc3VtXCIpXG5cbm1vZHVsZS5leHBvcnRzID0gc2NhbGVMaW5lYXJFeHBhbnNpb25cblxuZnVuY3Rpb24gc2NhbGVMaW5lYXJFeHBhbnNpb24oZSwgc2NhbGUpIHtcbiAgdmFyIG4gPSBlLmxlbmd0aFxuICBpZihuID09PSAxKSB7XG4gICAgdmFyIHRzID0gdHdvUHJvZHVjdChlWzBdLCBzY2FsZSlcbiAgICBpZih0c1swXSkge1xuICAgICAgcmV0dXJuIHRzXG4gICAgfVxuICAgIHJldHVybiBbIHRzWzFdIF1cbiAgfVxuICB2YXIgZyA9IG5ldyBBcnJheSgyICogbilcbiAgdmFyIHEgPSBbMC4xLCAwLjFdXG4gIHZhciB0ID0gWzAuMSwgMC4xXVxuICB2YXIgY291bnQgPSAwXG4gIHR3b1Byb2R1Y3QoZVswXSwgc2NhbGUsIHEpXG4gIGlmKHFbMF0pIHtcbiAgICBnW2NvdW50KytdID0gcVswXVxuICB9XG4gIGZvcih2YXIgaT0xOyBpPG47ICsraSkge1xuICAgIHR3b1Byb2R1Y3QoZVtpXSwgc2NhbGUsIHQpXG4gICAgdmFyIHBxID0gcVsxXVxuICAgIHR3b1N1bShwcSwgdFswXSwgcSlcbiAgICBpZihxWzBdKSB7XG4gICAgICBnW2NvdW50KytdID0gcVswXVxuICAgIH1cbiAgICB2YXIgYSA9IHRbMV1cbiAgICB2YXIgYiA9IHFbMV1cbiAgICB2YXIgeCA9IGEgKyBiXG4gICAgdmFyIGJ2ID0geCAtIGFcbiAgICB2YXIgeSA9IGIgLSBidlxuICAgIHFbMV0gPSB4XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gIH1cbiAgaWYocVsxXSkge1xuICAgIGdbY291bnQrK10gPSBxWzFdXG4gIH1cbiAgaWYoY291bnQgPT09IDApIHtcbiAgICBnW2NvdW50KytdID0gMC4wXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gcm9idXN0U3VidHJhY3RcblxuLy9FYXN5IGNhc2U6IEFkZCB0d28gc2NhbGFyc1xuZnVuY3Rpb24gc2NhbGFyU2NhbGFyKGEsIGIpIHtcbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgYXYgPSB4IC0gYnZcbiAgdmFyIGJyID0gYiAtIGJ2XG4gIHZhciBhciA9IGEgLSBhdlxuICB2YXIgeSA9IGFyICsgYnJcbiAgaWYoeSkge1xuICAgIHJldHVybiBbeSwgeF1cbiAgfVxuICByZXR1cm4gW3hdXG59XG5cbmZ1bmN0aW9uIHJvYnVzdFN1YnRyYWN0KGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCAtZlswXSlcbiAgfVxuICB2YXIgbiA9IG5lICsgbmZcbiAgdmFyIGcgPSBuZXcgQXJyYXkobilcbiAgdmFyIGNvdW50ID0gMFxuICB2YXIgZXB0ciA9IDBcbiAgdmFyIGZwdHIgPSAwXG4gIHZhciBhYnMgPSBNYXRoLmFic1xuICB2YXIgZWkgPSBlW2VwdHJdXG4gIHZhciBlYSA9IGFicyhlaSlcbiAgdmFyIGZpID0gLWZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IC1mW2ZwdHJdXG4gICAgICBmYSA9IGFicyhmaSlcbiAgICB9XG4gIH1cbiAgdmFyIHggPSBhICsgYlxuICB2YXIgYnYgPSB4IC0gYVxuICB2YXIgeSA9IGIgLSBidlxuICB2YXIgcTAgPSB5XG4gIHZhciBxMSA9IHhcbiAgdmFyIF94LCBfYnYsIF9hdiwgX2JyLCBfYXJcbiAgd2hpbGUoZXB0ciA8IG5lICYmIGZwdHIgPCBuZikge1xuICAgIGlmKGVhIDwgZmEpIHtcbiAgICAgIGEgPSBlaVxuICAgICAgZXB0ciArPSAxXG4gICAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICAgIGVhID0gYWJzKGVpKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBhID0gZmlcbiAgICAgIGZwdHIgKz0gMVxuICAgICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGxpbmVhckV4cGFuc2lvblN1bVxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gbGluZWFyRXhwYW5zaW9uU3VtKGUsIGYpIHtcbiAgdmFyIG5lID0gZS5sZW5ndGh8MFxuICB2YXIgbmYgPSBmLmxlbmd0aHwwXG4gIGlmKG5lID09PSAxICYmIG5mID09PSAxKSB7XG4gICAgcmV0dXJuIHNjYWxhclNjYWxhcihlWzBdLCBmWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSBmW2ZwdHJdXG4gIHZhciBmYSA9IGFicyhmaSlcbiAgdmFyIGEsIGJcbiAgaWYoZWEgPCBmYSkge1xuICAgIGIgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYiA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICBpZigoZXB0ciA8IG5lICYmIGVhIDwgZmEpIHx8IChmcHRyID49IG5mKSkge1xuICAgIGEgPSBlaVxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgICBlYSA9IGFicyhlaSlcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgYSA9IGZpXG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSBmW2ZwdHJdXG4gICAgICAgIGZhID0gYWJzKGZpKVxuICAgICAgfVxuICAgIH1cbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gIH1cbiAgd2hpbGUoZXB0ciA8IG5lKSB7XG4gICAgYSA9IGVpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGVwdHIgKz0gMVxuICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgZWkgPSBlW2VwdHJdXG4gICAgfVxuICB9XG4gIHdoaWxlKGZwdHIgPCBuZikge1xuICAgIGEgPSBmaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9IFxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZnB0ciArPSAxXG4gICAgaWYoZnB0ciA8IG5mKSB7XG4gICAgICBmaSA9IGZbZnB0cl1cbiAgICB9XG4gIH1cbiAgaWYocTApIHtcbiAgICBnW2NvdW50KytdID0gcTBcbiAgfVxuICBpZihxMSkge1xuICAgIGdbY291bnQrK10gPSBxMVxuICB9XG4gIGlmKCFjb3VudCkge1xuICAgIGdbY291bnQrK10gPSAwLjAgIFxuICB9XG4gIGcubGVuZ3RoID0gY291bnRcbiAgcmV0dXJuIGdcbn0iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxudmFyIGJpdHMgICAgICA9IHJlcXVpcmUoXCJiaXQtdHdpZGRsZVwiKVxuICAsIFVuaW9uRmluZCA9IHJlcXVpcmUoXCJ1bmlvbi1maW5kXCIpXG5cbi8vUmV0dXJucyB0aGUgZGltZW5zaW9uIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBkaW1lbnNpb24oY2VsbHMpIHtcbiAgdmFyIGQgPSAwXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBkID0gbWF4KGQsIGNlbGxzW2ldLmxlbmd0aClcbiAgfVxuICByZXR1cm4gZC0xXG59XG5leHBvcnRzLmRpbWVuc2lvbiA9IGRpbWVuc2lvblxuXG4vL0NvdW50cyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGluIGZhY2VzXG5mdW5jdGlvbiBjb3VudFZlcnRpY2VzKGNlbGxzKSB7XG4gIHZhciB2YyA9IC0xXG4gICAgLCBtYXggPSBNYXRoLm1heFxuICBmb3IodmFyIGk9MCwgaWw9Y2VsbHMubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsIGpsPWMubGVuZ3RoOyBqPGpsOyArK2opIHtcbiAgICAgIHZjID0gbWF4KHZjLCBjW2pdKVxuICAgIH1cbiAgfVxuICByZXR1cm4gdmMrMVxufVxuZXhwb3J0cy5jb3VudFZlcnRpY2VzID0gY291bnRWZXJ0aWNlc1xuXG4vL1JldHVybnMgYSBkZWVwIGNvcHkgb2YgY2VsbHNcbmZ1bmN0aW9uIGNsb25lQ2VsbHMoY2VsbHMpIHtcbiAgdmFyIG5jZWxscyA9IG5ldyBBcnJheShjZWxscy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIG5jZWxsc1tpXSA9IGNlbGxzW2ldLnNsaWNlKDApXG4gIH1cbiAgcmV0dXJuIG5jZWxsc1xufVxuZXhwb3J0cy5jbG9uZUNlbGxzID0gY2xvbmVDZWxsc1xuXG4vL1JhbmtzIGEgcGFpciBvZiBjZWxscyB1cCB0byBwZXJtdXRhdGlvblxuZnVuY3Rpb24gY29tcGFyZUNlbGxzKGEsIGIpIHtcbiAgdmFyIG4gPSBhLmxlbmd0aFxuICAgICwgdCA9IGEubGVuZ3RoIC0gYi5sZW5ndGhcbiAgICAsIG1pbiA9IE1hdGgubWluXG4gIGlmKHQpIHtcbiAgICByZXR1cm4gdFxuICB9XG4gIHN3aXRjaChuKSB7XG4gICAgY2FzZSAwOlxuICAgICAgcmV0dXJuIDA7XG4gICAgY2FzZSAxOlxuICAgICAgcmV0dXJuIGFbMF0gLSBiWzBdO1xuICAgIGNhc2UgMjpcbiAgICAgIHZhciBkID0gYVswXSthWzFdLWJbMF0tYlsxXVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihhWzBdLGFbMV0pIC0gbWluKGJbMF0sYlsxXSlcbiAgICBjYXNlIDM6XG4gICAgICB2YXIgbDEgPSBhWzBdK2FbMV1cbiAgICAgICAgLCBtMSA9IGJbMF0rYlsxXVxuICAgICAgZCA9IGwxK2FbMl0gLSAobTErYlsyXSlcbiAgICAgIGlmKGQpIHtcbiAgICAgICAgcmV0dXJuIGRcbiAgICAgIH1cbiAgICAgIHZhciBsMCA9IG1pbihhWzBdLCBhWzFdKVxuICAgICAgICAsIG0wID0gbWluKGJbMF0sIGJbMV0pXG4gICAgICAgICwgZCAgPSBtaW4obDAsIGFbMl0pIC0gbWluKG0wLCBiWzJdKVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgcmV0dXJuIG1pbihsMCthWzJdLCBsMSkgLSBtaW4obTArYlsyXSwgbTEpXG4gICAgXG4gICAgLy9UT0RPOiBNYXliZSBvcHRpbWl6ZSBuPTQgYXMgd2VsbD9cbiAgICBcbiAgICBkZWZhdWx0OlxuICAgICAgdmFyIGFzID0gYS5zbGljZSgwKVxuICAgICAgYXMuc29ydCgpXG4gICAgICB2YXIgYnMgPSBiLnNsaWNlKDApXG4gICAgICBicy5zb3J0KClcbiAgICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgICB0ID0gYXNbaV0gLSBic1tpXVxuICAgICAgICBpZih0KSB7XG4gICAgICAgICAgcmV0dXJuIHRcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDBcbiAgfVxufVxuZXhwb3J0cy5jb21wYXJlQ2VsbHMgPSBjb21wYXJlQ2VsbHNcblxuZnVuY3Rpb24gY29tcGFyZVppcHBlZChhLCBiKSB7XG4gIHJldHVybiBjb21wYXJlQ2VsbHMoYVswXSwgYlswXSlcbn1cblxuLy9QdXRzIGEgY2VsbCBjb21wbGV4IGludG8gbm9ybWFsIG9yZGVyIGZvciB0aGUgcHVycG9zZXMgb2YgZmluZENlbGwgcXVlcmllc1xuZnVuY3Rpb24gbm9ybWFsaXplKGNlbGxzLCBhdHRyKSB7XG4gIGlmKGF0dHIpIHtcbiAgICB2YXIgbGVuID0gY2VsbHMubGVuZ3RoXG4gICAgdmFyIHppcHBlZCA9IG5ldyBBcnJheShsZW4pXG4gICAgZm9yKHZhciBpPTA7IGk8bGVuOyArK2kpIHtcbiAgICAgIHppcHBlZFtpXSA9IFtjZWxsc1tpXSwgYXR0cltpXV1cbiAgICB9XG4gICAgemlwcGVkLnNvcnQoY29tcGFyZVppcHBlZClcbiAgICBmb3IodmFyIGk9MDsgaTxsZW47ICsraSkge1xuICAgICAgY2VsbHNbaV0gPSB6aXBwZWRbaV1bMF1cbiAgICAgIGF0dHJbaV0gPSB6aXBwZWRbaV1bMV1cbiAgICB9XG4gICAgcmV0dXJuIGNlbGxzXG4gIH0gZWxzZSB7XG4gICAgY2VsbHMuc29ydChjb21wYXJlQ2VsbHMpXG4gICAgcmV0dXJuIGNlbGxzXG4gIH1cbn1cbmV4cG9ydHMubm9ybWFsaXplID0gbm9ybWFsaXplXG5cbi8vUmVtb3ZlcyBhbGwgZHVwbGljYXRlIGNlbGxzIGluIHRoZSBjb21wbGV4XG5mdW5jdGlvbiB1bmlxdWUoY2VsbHMpIHtcbiAgaWYoY2VsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHB0ciA9IDFcbiAgICAsIGxlbiA9IGNlbGxzLmxlbmd0aFxuICBmb3IodmFyIGk9MTsgaTxsZW47ICsraSkge1xuICAgIHZhciBhID0gY2VsbHNbaV1cbiAgICBpZihjb21wYXJlQ2VsbHMoYSwgY2VsbHNbaS0xXSkpIHtcbiAgICAgIGlmKGkgPT09IHB0cikge1xuICAgICAgICBwdHIrK1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgY2VsbHNbcHRyKytdID0gYVxuICAgIH1cbiAgfVxuICBjZWxscy5sZW5ndGggPSBwdHJcbiAgcmV0dXJuIGNlbGxzXG59XG5leHBvcnRzLnVuaXF1ZSA9IHVuaXF1ZTtcblxuLy9GaW5kcyBhIGNlbGwgaW4gYSBub3JtYWxpemVkIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gZmluZENlbGwoY2VsbHMsIGMpIHtcbiAgdmFyIGxvID0gMFxuICAgICwgaGkgPSBjZWxscy5sZW5ndGgtMVxuICAgICwgciAgPSAtMVxuICB3aGlsZSAobG8gPD0gaGkpIHtcbiAgICB2YXIgbWlkID0gKGxvICsgaGkpID4+IDFcbiAgICAgICwgcyAgID0gY29tcGFyZUNlbGxzKGNlbGxzW21pZF0sIGMpXG4gICAgaWYocyA8PSAwKSB7XG4gICAgICBpZihzID09PSAwKSB7XG4gICAgICAgIHIgPSBtaWRcbiAgICAgIH1cbiAgICAgIGxvID0gbWlkICsgMVxuICAgIH0gZWxzZSBpZihzID4gMCkge1xuICAgICAgaGkgPSBtaWQgLSAxXG4gICAgfVxuICB9XG4gIHJldHVybiByXG59XG5leHBvcnRzLmZpbmRDZWxsID0gZmluZENlbGw7XG5cbi8vQnVpbGRzIGFuIGluZGV4IGZvciBhbiBuLWNlbGwuICBUaGlzIGlzIG1vcmUgZ2VuZXJhbCB0aGFuIGR1YWwsIGJ1dCBsZXNzIGVmZmljaWVudFxuZnVuY3Rpb24gaW5jaWRlbmNlKGZyb21fY2VsbHMsIHRvX2NlbGxzKSB7XG4gIHZhciBpbmRleCA9IG5ldyBBcnJheShmcm9tX2NlbGxzLmxlbmd0aClcbiAgZm9yKHZhciBpPTAsIGlsPWluZGV4Lmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgaW5kZXhbaV0gPSBbXVxuICB9XG4gIHZhciBiID0gW11cbiAgZm9yKHZhciBpPTAsIG49dG9fY2VsbHMubGVuZ3RoOyBpPG47ICsraSkge1xuICAgIHZhciBjID0gdG9fY2VsbHNbaV1cbiAgICB2YXIgY2wgPSBjLmxlbmd0aFxuICAgIGZvcih2YXIgaz0xLCBrbj0oMTw8Y2wpOyBrPGtuOyArK2spIHtcbiAgICAgIGIubGVuZ3RoID0gYml0cy5wb3BDb3VudChrKVxuICAgICAgdmFyIGwgPSAwXG4gICAgICBmb3IodmFyIGo9MDsgajxjbDsgKytqKSB7XG4gICAgICAgIGlmKGsgJiAoMTw8aikpIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2pdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBpZHg9ZmluZENlbGwoZnJvbV9jZWxscywgYilcbiAgICAgIGlmKGlkeCA8IDApIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHdoaWxlKHRydWUpIHtcbiAgICAgICAgaW5kZXhbaWR4KytdLnB1c2goaSlcbiAgICAgICAgaWYoaWR4ID49IGZyb21fY2VsbHMubGVuZ3RoIHx8IGNvbXBhcmVDZWxscyhmcm9tX2NlbGxzW2lkeF0sIGIpICE9PSAwKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn1cbmV4cG9ydHMuaW5jaWRlbmNlID0gaW5jaWRlbmNlXG5cbi8vQ29tcHV0ZXMgdGhlIGR1YWwgb2YgdGhlIG1lc2guICBUaGlzIGlzIGJhc2ljYWxseSBhbiBvcHRpbWl6ZWQgdmVyc2lvbiBvZiBidWlsZEluZGV4IGZvciB0aGUgc2l0dWF0aW9uIHdoZXJlIGZyb21fY2VsbHMgaXMganVzdCB0aGUgbGlzdCBvZiB2ZXJ0aWNlc1xuZnVuY3Rpb24gZHVhbChjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKCF2ZXJ0ZXhfY291bnQpIHtcbiAgICByZXR1cm4gaW5jaWRlbmNlKHVuaXF1ZShza2VsZXRvbihjZWxscywgMCkpLCBjZWxscywgMClcbiAgfVxuICB2YXIgcmVzID0gbmV3IEFycmF5KHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8dmVydGV4X2NvdW50OyArK2kpIHtcbiAgICByZXNbaV0gPSBbXVxuICB9XG4gIGZvcih2YXIgaT0wLCBsZW49Y2VsbHMubGVuZ3RoOyBpPGxlbjsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLCBjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICByZXNbY1tqXV0ucHVzaChpKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5leHBvcnRzLmR1YWwgPSBkdWFsXG5cbi8vRW51bWVyYXRlcyBhbGwgY2VsbHMgaW4gdGhlIGNvbXBsZXhcbmZ1bmN0aW9uIGV4cGxvZGUoY2VsbHMpIHtcbiAgdmFyIHJlc3VsdCA9IFtdXG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICAgICwgY2wgPSBjLmxlbmd0aHwwXG4gICAgZm9yKHZhciBqPTEsIGpsPSgxPDxjbCk7IGo8amw7ICsraikge1xuICAgICAgdmFyIGIgPSBbXVxuICAgICAgZm9yKHZhciBrPTA7IGs8Y2w7ICsraykge1xuICAgICAgICBpZigoaiA+Pj4gaykgJiAxKSB7XG4gICAgICAgICAgYi5wdXNoKGNba10pXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzdWx0KVxufVxuZXhwb3J0cy5leHBsb2RlID0gZXhwbG9kZVxuXG4vL0VudW1lcmF0ZXMgYWxsIG9mIHRoZSBuLWNlbGxzIG9mIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBza2VsZXRvbihjZWxscywgbikge1xuICBpZihuIDwgMCkge1xuICAgIHJldHVybiBbXVxuICB9XG4gIHZhciByZXN1bHQgPSBbXVxuICAgICwgazAgICAgID0gKDE8PChuKzEpKS0xXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaz1rMDsgazwoMTw8Yy5sZW5ndGgpOyBrPWJpdHMubmV4dENvbWJpbmF0aW9uKGspKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShuKzEpXG4gICAgICAgICwgbCA9IDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaWYoayAmICgxPDxqKSkge1xuICAgICAgICAgIGJbbCsrXSA9IGNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShyZXN1bHQpXG59XG5leHBvcnRzLnNrZWxldG9uID0gc2tlbGV0b247XG5cbi8vQ29tcHV0ZXMgdGhlIGJvdW5kYXJ5IG9mIGFsbCBjZWxscywgZG9lcyBub3QgcmVtb3ZlIGR1cGxpY2F0ZXNcbmZ1bmN0aW9uIGJvdW5kYXJ5KGNlbGxzKSB7XG4gIHZhciByZXMgPSBbXVxuICBmb3IodmFyIGk9MCxpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCxjbD1jLmxlbmd0aDsgajxjbDsgKytqKSB7XG4gICAgICB2YXIgYiA9IG5ldyBBcnJheShjLmxlbmd0aC0xKVxuICAgICAgZm9yKHZhciBrPTAsIGw9MDsgazxjbDsgKytrKSB7XG4gICAgICAgIGlmKGsgIT09IGopIHtcbiAgICAgICAgICBiW2wrK10gPSBjW2tdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJlcy5wdXNoKGIpXG4gICAgfVxuICB9XG4gIHJldHVybiBub3JtYWxpemUocmVzKVxufVxuZXhwb3J0cy5ib3VuZGFyeSA9IGJvdW5kYXJ5O1xuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGRlbnNlIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19kZW5zZShjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIHZhciBsYWJlbHMgPSBuZXcgVW5pb25GaW5kKHZlcnRleF9jb3VudClcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKGNbal0sIGNba10pXG4gICAgICB9XG4gICAgfVxuICB9XG4gIHZhciBjb21wb25lbnRzID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgPSBsYWJlbHMucmFua3NcbiAgZm9yKHZhciBpPTA7IGk8Y29tcG9uZW50X2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbXBvbmVudF9sYWJlbHNbaV0gPSAtMVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGwgPSBsYWJlbHMuZmluZChjZWxsc1tpXVswXSlcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIHNwYXJzZSBncmFwaFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50c19zcGFyc2UoY2VsbHMpIHtcbiAgdmFyIHZlcnRpY2VzICA9IHVuaXF1ZShub3JtYWxpemUoc2tlbGV0b24oY2VsbHMsIDApKSlcbiAgICAsIGxhYmVscyAgICA9IG5ldyBVbmlvbkZpbmQodmVydGljZXMubGVuZ3RoKVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgdmogPSBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nbal1dKVxuICAgICAgZm9yKHZhciBrPWorMTsgazxjLmxlbmd0aDsgKytrKSB7XG4gICAgICAgIGxhYmVscy5saW5rKHZqLCBmaW5kQ2VsbCh2ZXJ0aWNlcywgW2Nba11dKSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbXBvbmVudHMgICAgICAgID0gW11cbiAgICAsIGNvbXBvbmVudF9sYWJlbHMgID0gbGFiZWxzLnJhbmtzXG4gIGZvcih2YXIgaT0wOyBpPGNvbXBvbmVudF9sYWJlbHMubGVuZ3RoOyArK2kpIHtcbiAgICBjb21wb25lbnRfbGFiZWxzW2ldID0gLTFcbiAgfVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBsID0gbGFiZWxzLmZpbmQoZmluZENlbGwodmVydGljZXMsIFtjZWxsc1tpXVswXV0pKTtcbiAgICBpZihjb21wb25lbnRfbGFiZWxzW2xdIDwgMCkge1xuICAgICAgY29tcG9uZW50X2xhYmVsc1tsXSA9IGNvbXBvbmVudHMubGVuZ3RoXG4gICAgICBjb21wb25lbnRzLnB1c2goW2NlbGxzW2ldLnNsaWNlKDApXSlcbiAgICB9IGVsc2Uge1xuICAgICAgY29tcG9uZW50c1tjb21wb25lbnRfbGFiZWxzW2xdXS5wdXNoKGNlbGxzW2ldLnNsaWNlKDApKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY29tcG9uZW50c1xufVxuXG4vL0NvbXB1dGVzIGNvbm5lY3RlZCBjb21wb25lbnRzIGZvciBhIGNlbGwgY29tcGxleFxuZnVuY3Rpb24gY29ubmVjdGVkQ29tcG9uZW50cyhjZWxscywgdmVydGV4X2NvdW50KSB7XG4gIGlmKHZlcnRleF9jb3VudCkge1xuICAgIHJldHVybiBjb25uZWN0ZWRDb21wb25lbnRzX2RlbnNlKGNlbGxzLCB2ZXJ0ZXhfY291bnQpXG4gIH1cbiAgcmV0dXJuIGNvbm5lY3RlZENvbXBvbmVudHNfc3BhcnNlKGNlbGxzKVxufVxuZXhwb3J0cy5jb25uZWN0ZWRDb21wb25lbnRzID0gY29ubmVjdGVkQ29tcG9uZW50c1xuIiwiLypcbiAoYykgMjAxNywgVmxhZGltaXIgQWdhZm9ua2luXG4gU2ltcGxpZnkuanMsIGEgaGlnaC1wZXJmb3JtYW5jZSBKUyBwb2x5bGluZSBzaW1wbGlmaWNhdGlvbiBsaWJyYXJ5XG4gbW91cm5lci5naXRodWIuaW8vc2ltcGxpZnktanNcbiovXG5cbihmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxuLy8gdG8gc3VpdCB5b3VyIHBvaW50IGZvcm1hdCwgcnVuIHNlYXJjaC9yZXBsYWNlIGZvciAnLngnIGFuZCAnLnknO1xuLy8gZm9yIDNEIHZlcnNpb24sIHNlZSAzZCBicmFuY2ggKGNvbmZpZ3VyYWJpbGl0eSB3b3VsZCBkcmF3IHNpZ25pZmljYW50IHBlcmZvcm1hbmNlIG92ZXJoZWFkKVxuXG4vLyBzcXVhcmUgZGlzdGFuY2UgYmV0d2VlbiAyIHBvaW50c1xuZnVuY3Rpb24gZ2V0U3FEaXN0KHAxLCBwMikge1xuXG4gICAgdmFyIGR4ID0gcDEueCAtIHAyLngsXG4gICAgICAgIGR5ID0gcDEueSAtIHAyLnk7XG5cbiAgICByZXR1cm4gZHggKiBkeCArIGR5ICogZHk7XG59XG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBmcm9tIGEgcG9pbnQgdG8gYSBzZWdtZW50XG5mdW5jdGlvbiBnZXRTcVNlZ0Rpc3QocCwgcDEsIHAyKSB7XG5cbiAgICB2YXIgeCA9IHAxLngsXG4gICAgICAgIHkgPSBwMS55LFxuICAgICAgICBkeCA9IHAyLnggLSB4LFxuICAgICAgICBkeSA9IHAyLnkgLSB5O1xuXG4gICAgaWYgKGR4ICE9PSAwIHx8IGR5ICE9PSAwKSB7XG5cbiAgICAgICAgdmFyIHQgPSAoKHAueCAtIHgpICogZHggKyAocC55IC0geSkgKiBkeSkgLyAoZHggKiBkeCArIGR5ICogZHkpO1xuXG4gICAgICAgIGlmICh0ID4gMSkge1xuICAgICAgICAgICAgeCA9IHAyLng7XG4gICAgICAgICAgICB5ID0gcDIueTtcblxuICAgICAgICB9IGVsc2UgaWYgKHQgPiAwKSB7XG4gICAgICAgICAgICB4ICs9IGR4ICogdDtcbiAgICAgICAgICAgIHkgKz0gZHkgKiB0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZHggPSBwLnggLSB4O1xuICAgIGR5ID0gcC55IC0geTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cbi8vIHJlc3Qgb2YgdGhlIGNvZGUgZG9lc24ndCBjYXJlIGFib3V0IHBvaW50IGZvcm1hdFxuXG4vLyBiYXNpYyBkaXN0YW5jZS1iYXNlZCBzaW1wbGlmaWNhdGlvblxuZnVuY3Rpb24gc2ltcGxpZnlSYWRpYWxEaXN0KHBvaW50cywgc3FUb2xlcmFuY2UpIHtcblxuICAgIHZhciBwcmV2UG9pbnQgPSBwb2ludHNbMF0sXG4gICAgICAgIG5ld1BvaW50cyA9IFtwcmV2UG9pbnRdLFxuICAgICAgICBwb2ludDtcblxuICAgIGZvciAodmFyIGkgPSAxLCBsZW4gPSBwb2ludHMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgcG9pbnQgPSBwb2ludHNbaV07XG5cbiAgICAgICAgaWYgKGdldFNxRGlzdChwb2ludCwgcHJldlBvaW50KSA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgICAgICBuZXdQb2ludHMucHVzaChwb2ludCk7XG4gICAgICAgICAgICBwcmV2UG9pbnQgPSBwb2ludDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2UG9pbnQgIT09IHBvaW50KSBuZXdQb2ludHMucHVzaChwb2ludCk7XG5cbiAgICByZXR1cm4gbmV3UG9pbnRzO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeURQU3RlcChwb2ludHMsIGZpcnN0LCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCkge1xuICAgIHZhciBtYXhTcURpc3QgPSBzcVRvbGVyYW5jZSxcbiAgICAgICAgaW5kZXg7XG5cbiAgICBmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDwgbGFzdDsgaSsrKSB7XG4gICAgICAgIHZhciBzcURpc3QgPSBnZXRTcVNlZ0Rpc3QocG9pbnRzW2ldLCBwb2ludHNbZmlyc3RdLCBwb2ludHNbbGFzdF0pO1xuXG4gICAgICAgIGlmIChzcURpc3QgPiBtYXhTcURpc3QpIHtcbiAgICAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgICAgICAgIG1heFNxRGlzdCA9IHNxRGlzdDtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGlmIChtYXhTcURpc3QgPiBzcVRvbGVyYW5jZSkge1xuICAgICAgICBpZiAoaW5kZXggLSBmaXJzdCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGluZGV4LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbaW5kZXhdKTtcbiAgICAgICAgaWYgKGxhc3QgLSBpbmRleCA+IDEpIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgaW5kZXgsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICB9XG59XG5cbi8vIHNpbXBsaWZpY2F0aW9uIHVzaW5nIFJhbWVyLURvdWdsYXMtUGV1Y2tlciBhbGdvcml0aG1cbmZ1bmN0aW9uIHNpbXBsaWZ5RG91Z2xhc1BldWNrZXIocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuICAgIHZhciBsYXN0ID0gcG9pbnRzLmxlbmd0aCAtIDE7XG5cbiAgICB2YXIgc2ltcGxpZmllZCA9IFtwb2ludHNbMF1dO1xuICAgIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgMCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIHNpbXBsaWZpZWQucHVzaChwb2ludHNbbGFzdF0pO1xuXG4gICAgcmV0dXJuIHNpbXBsaWZpZWQ7XG59XG5cbi8vIGJvdGggYWxnb3JpdGhtcyBjb21iaW5lZCBmb3IgYXdlc29tZSBwZXJmb3JtYW5jZVxuZnVuY3Rpb24gc2ltcGxpZnkocG9pbnRzLCB0b2xlcmFuY2UsIGhpZ2hlc3RRdWFsaXR5KSB7XG5cbiAgICBpZiAocG9pbnRzLmxlbmd0aCA8PSAyKSByZXR1cm4gcG9pbnRzO1xuXG4gICAgdmFyIHNxVG9sZXJhbmNlID0gdG9sZXJhbmNlICE9PSB1bmRlZmluZWQgPyB0b2xlcmFuY2UgKiB0b2xlcmFuY2UgOiAxO1xuXG4gICAgcG9pbnRzID0gaGlnaGVzdFF1YWxpdHkgPyBwb2ludHMgOiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSk7XG4gICAgcG9pbnRzID0gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKTtcblxuICAgIHJldHVybiBwb2ludHM7XG59XG5cbi8vIGV4cG9ydCBhcyBBTUQgbW9kdWxlIC8gTm9kZSBtb2R1bGUgLyBicm93c2VyIG9yIHdvcmtlciB2YXJpYWJsZVxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkgZGVmaW5lKGZ1bmN0aW9uKCkgeyByZXR1cm4gc2ltcGxpZnk7IH0pO1xuZWxzZSBpZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IHNpbXBsaWZ5O1xuICAgIG1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBzaW1wbGlmeTtcbn0gZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBzZWxmLnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5lbHNlIHdpbmRvdy5zaW1wbGlmeSA9IHNpbXBsaWZ5O1xuXG59KSgpO1xuIiwidmFyIG1lYXN1cmVEaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xudmFyIGJlYXJpbmcgPSByZXF1aXJlKCd0dXJmLWJlYXJpbmcnKTtcbnZhciBkZXN0aW5hdGlvbiA9IHJlcXVpcmUoJ3R1cmYtZGVzdGluYXRpb24nKTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9IGFuZCByZXR1cm5zIGEge0BsaW5rIFBvaW50fHBvaW50fSBhdCBhIHNwZWNpZmllZCBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZS5cbiAqXG4gKiBAbmFtZSBhbG9uZ1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGlucHV0IGxpbmVcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZVxuICogQHBhcmFtIHtTdHJpbmd9IFt1bml0cz1taWxlc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gUG9pbnQgYGRpc3RhbmNlYCBgdW5pdHNgIGFsb25nIHRoZSBsaW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGFsb25nID0gdHVyZi5hbG9uZyhsaW5lLCAxLCAnbWlsZXMnKTtcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtsaW5lLCBhbG9uZ11cbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpbmUsIGRpc3RhbmNlLCB1bml0cykge1xuICAgIHZhciBjb29yZHM7XG4gICAgaWYgKGxpbmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSBjb29yZHMgPSBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSBjb29yZHMgPSBsaW5lLmNvb3JkaW5hdGVzO1xuICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZyBGZWF0dXJlIG9yIEdlb21ldHJ5Jyk7XG5cbiAgICB2YXIgdHJhdmVsbGVkID0gMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBpZiAoZGlzdGFuY2UgPj0gdHJhdmVsbGVkICYmIGkgPT09IGNvb3Jkcy5sZW5ndGggLSAxKSBicmVhaztcbiAgICAgICAgZWxzZSBpZiAodHJhdmVsbGVkID49IGRpc3RhbmNlKSB7XG4gICAgICAgICAgICB2YXIgb3ZlcnNob3QgPSBkaXN0YW5jZSAtIHRyYXZlbGxlZDtcbiAgICAgICAgICAgIGlmICghb3ZlcnNob3QpIHJldHVybiBwb2ludChjb29yZHNbaV0pO1xuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGJlYXJpbmcoY29vcmRzW2ldLCBjb29yZHNbaSAtIDFdKSAtIDE4MDtcbiAgICAgICAgICAgICAgICB2YXIgaW50ZXJwb2xhdGVkID0gZGVzdGluYXRpb24oY29vcmRzW2ldLCBvdmVyc2hvdCwgZGlyZWN0aW9uLCB1bml0cyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGludGVycG9sYXRlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRyYXZlbGxlZCArPSBtZWFzdXJlRGlzdGFuY2UoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdLCB1bml0cyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvaW50KGNvb3Jkc1tjb29yZHMubGVuZ3RoIC0gMV0pO1xufTtcbiIsInZhciBnZW9tZXRyeUFyZWEgPSByZXF1aXJlKCdnZW9qc29uLWFyZWEnKS5nZW9tZXRyeTtcblxuLyoqXG4gKiBUYWtlcyBhIG9uZSBvciBtb3JlIGZlYXR1cmVzIGFuZCByZXR1cm5zIHRoZWlyIGFyZWFcbiAqIGluIHNxdWFyZSBtZXRlcnMuXG4gKlxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGlucHV0IGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGFyZWEgaW4gc3F1YXJlIG1ldGVyc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29ucyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgICAgIFstNjcuMDMxMDIxLCAxMC40NTgxMDJdLFxuICogICAgICAgICAgIFstNjcuMDMxMDIxLCAxMC41MzM3Ml0sXG4gKiAgICAgICAgICAgWy02Ni45MjkzOTcsIDEwLjUzMzcyXSxcbiAqICAgICAgICAgICBbLTY2LjkyOTM5NywgMTAuNDU4MTAyXSxcbiAqICAgICAgICAgICBbLTY3LjAzMTAyMSwgMTAuNDU4MTAyXVxuICogICAgICAgICBdXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgICAgICBbLTY2LjkxOTc4NCwgMTAuMzk3MzI1XSxcbiAqICAgICAgICAgICBbLTY2LjkxOTc4NCwgMTAuNTEzNDY3XSxcbiAqICAgICAgICAgICBbLTY2LjgwNTExNCwgMTAuNTEzNDY3XSxcbiAqICAgICAgICAgICBbLTY2LjgwNTExNCwgMTAuMzk3MzI1XSxcbiAqICAgICAgICAgICBbLTY2LjkxOTc4NCwgMTAuMzk3MzI1XVxuICogICAgICAgICBdXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgYXJlYSA9IHR1cmYuYXJlYShwb2x5Z29ucyk7XG4gKlxuICogLy89YXJlYVxuICovXG5mdW5jdGlvbiBhcmVhKGlucHV0KSB7XG4gICAgaWYgKGlucHV0LnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIHN1bSA9IDA7IGkgPCBpbnB1dC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlucHV0LmZlYXR1cmVzW2ldLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICAgICAgc3VtICs9IGdlb21ldHJ5QXJlYShpbnB1dC5mZWF0dXJlc1tpXS5nZW9tZXRyeSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHN1bTtcbiAgICB9IGVsc2UgaWYgKGlucHV0LnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnlBcmVhKGlucHV0Lmdlb21ldHJ5KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZ2VvbWV0cnlBcmVhKGlucHV0KTtcbiAgICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IGFyZWE7XG4iLCJ2YXIgcG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvbHlnb247XG5cbi8qKlxuICogVGFrZXMgYSBiYm94IGFuZCByZXR1cm5zIGFuIGVxdWl2YWxlbnQge0BsaW5rIFBvbHlnb258cG9seWdvbn0uXG4gKlxuICogQG5hbWUgYmJveFBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBhbiBBcnJheSBvZiBib3VuZGluZyBib3ggY29vcmRpbmF0ZXMgaW4gdGhlIGZvcm06IGBgYFt4TG93LCB5TG93LCB4SGlnaCwgeUhpZ2hdYGBgXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvbHlnb24+fSBhIFBvbHlnb24gcmVwcmVzZW50YXRpb24gb2YgdGhlIGJvdW5kaW5nIGJveFxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gWzAsIDAsIDEwLCAxMF07XG4gKlxuICogdmFyIHBvbHkgPSB0dXJmLmJib3hQb2x5Z29uKGJib3gpO1xuICpcbiAqIC8vPXBvbHlcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiYm94KSB7XG4gICAgdmFyIGxvd0xlZnQgPSBbYmJveFswXSwgYmJveFsxXV07XG4gICAgdmFyIHRvcExlZnQgPSBbYmJveFswXSwgYmJveFszXV07XG4gICAgdmFyIHRvcFJpZ2h0ID0gW2Jib3hbMl0sIGJib3hbM11dO1xuICAgIHZhciBsb3dSaWdodCA9IFtiYm94WzJdLCBiYm94WzFdXTtcblxuICAgIHJldHVybiBwb2x5Z29uKFtbXG4gICAgICAgIGxvd0xlZnQsXG4gICAgICAgIGxvd1JpZ2h0LFxuICAgICAgICB0b3BSaWdodCxcbiAgICAgICAgdG9wTGVmdCxcbiAgICAgICAgbG93TGVmdFxuICAgIF1dKTtcbn07XG4iLCJ2YXIgZWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaDtcblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiBmZWF0dXJlcywgY2FsY3VsYXRlcyB0aGUgYmJveCBvZiBhbGwgaW5wdXQgZmVhdHVyZXMsIGFuZCByZXR1cm5zIGEgYm91bmRpbmcgYm94LlxuICpcbiAqIEBuYW1lIGJib3hcbiAqIEBwYXJhbSB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBnZW9qc29uIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtBcnJheTxudW1iZXI+fSB0aGUgYm91bmRpbmcgYm94IG9mIGBpbnB1dGAgZ2l2ZW5cbiAqIGFzIGFuIGFycmF5IGluIFdTRU4gb3JkZXIgKHdlc3QsIHNvdXRoLCBlYXN0LCBub3J0aClcbiAqIEBleGFtcGxlXG4gKiB2YXIgaW5wdXQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMTc1MzI5LCAyMi4yNTI0XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMTcwMDA3LCAyMi4yNjc5NjldXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4yMDA2NDksIDIyLjI3NDY0MV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTE0LjE4Njc0NCwgMjIuMjY1NzQ1XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgYmJveCA9IHR1cmYuYmJveChpbnB1dCk7XG4gKlxuICogdmFyIGJib3hQb2x5Z29uID0gdHVyZi5iYm94UG9seWdvbihiYm94KTtcbiAqXG4gKiB2YXIgcmVzdWx0RmVhdHVyZXMgPSBpbnB1dC5mZWF0dXJlcy5jb25jYXQoYmJveFBvbHlnb24pO1xuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2VvanNvbikge1xuICAgIHZhciBiYm94ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIGVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGlmIChiYm94WzBdID4gY29vcmRbMF0pIGJib3hbMF0gPSBjb29yZFswXTtcbiAgICAgICAgaWYgKGJib3hbMV0gPiBjb29yZFsxXSkgYmJveFsxXSA9IGNvb3JkWzFdO1xuICAgICAgICBpZiAoYmJveFsyXSA8IGNvb3JkWzBdKSBiYm94WzJdID0gY29vcmRbMF07XG4gICAgICAgIGlmIChiYm94WzNdIDwgY29vcmRbMV0pIGJib3hbM10gPSBjb29yZFsxXTtcbiAgICB9KTtcbiAgICByZXR1cm4gYmJveDtcbn07XG4iLCJ2YXIgZ2V0Q29vcmQgPSByZXF1aXJlKCd0dXJmLWludmFyaWFudCcpLmdldENvb3JkO1xuLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vL2h0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG5cbi8qKlxuICogVGFrZXMgdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBmaW5kcyB0aGUgZ2VvZ3JhcGhpYyBiZWFyaW5nIGJldHdlZW4gdGhlbS5cbiAqXG4gKiBAbmFtZSBiZWFyaW5nXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBzdGFydCBzdGFydGluZyBQb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gZW5kIGVuZGluZyBQb2ludFxuICogQHJldHVybnMge051bWJlcn0gYmVhcmluZyBpbiBkZWNpbWFsIGRlZ3JlZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogJyNmMDAnXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvaW50MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6ICcjMGYwJ1xuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS41MzQsIDM5LjEyM11cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2ludDEsIHBvaW50Ml1cbiAqIH07XG4gKlxuICogLy89cG9pbnRzXG4gKlxuICogdmFyIGJlYXJpbmcgPSB0dXJmLmJlYXJpbmcocG9pbnQxLCBwb2ludDIpO1xuICpcbiAqIC8vPWJlYXJpbmdcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RhcnQsIGVuZCkge1xuICAgIHZhciBkZWdyZWVzMnJhZGlhbnMgPSBNYXRoLlBJIC8gMTgwO1xuICAgIHZhciByYWRpYW5zMmRlZ3JlZXMgPSAxODAgLyBNYXRoLlBJO1xuICAgIHZhciBjb29yZGluYXRlczEgPSBnZXRDb29yZChzdGFydCk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMiA9IGdldENvb3JkKGVuZCk7XG5cbiAgICB2YXIgbG9uMSA9IGRlZ3JlZXMycmFkaWFucyAqIGNvb3JkaW5hdGVzMVswXTtcbiAgICB2YXIgbG9uMiA9IGRlZ3JlZXMycmFkaWFucyAqIGNvb3JkaW5hdGVzMlswXTtcbiAgICB2YXIgbGF0MSA9IGRlZ3JlZXMycmFkaWFucyAqIGNvb3JkaW5hdGVzMVsxXTtcbiAgICB2YXIgbGF0MiA9IGRlZ3JlZXMycmFkaWFucyAqIGNvb3JkaW5hdGVzMlsxXTtcbiAgICB2YXIgYSA9IE1hdGguc2luKGxvbjIgLSBsb24xKSAqIE1hdGguY29zKGxhdDIpO1xuICAgIHZhciBiID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLnNpbihsYXQyKSAtXG4gICAgICAgIE1hdGguc2luKGxhdDEpICogTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsb24yIC0gbG9uMSk7XG5cbiAgICB2YXIgYmVhcmluZyA9IHJhZGlhbnMyZGVncmVlcyAqIE1hdGguYXRhbjIoYSwgYik7XG5cbiAgICByZXR1cm4gYmVhcmluZztcbn07XG4iLCJ2YXIgbGluZXN0cmluZyA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmxpbmVTdHJpbmc7XG52YXIgU3BsaW5lID0gcmVxdWlyZSgnLi9zcGxpbmUuanMnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9IGFuZCByZXR1cm5zIGEgY3VydmVkIHZlcnNpb25cbiAqIGJ5IGFwcGx5aW5nIGEgW0JlemllciBzcGxpbmVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQiVDMyVBOXppZXJfc3BsaW5lKVxuICogYWxnb3JpdGhtLlxuICpcbiAqIFRoZSBiZXppZXIgc3BsaW5lIGltcGxlbWVudGF0aW9uIGlzIGJ5IFtMZXN6ZWsgUnliaWNraV0oaHR0cDovL2xlc3play5yeWJpY2tpLmNjLykuXG4gKlxuICogQG5hbWUgYmV6aWVyXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgaW5wdXQgTGluZVN0cmluZ1xuICogQHBhcmFtIHtOdW1iZXJ9IFtyZXNvbHV0aW9uPTEwMDAwXSB0aW1lIGluIG1pbGxpc2Vjb25kcyBiZXR3ZWVuIHBvaW50c1xuICogQHBhcmFtIHtOdW1iZXJ9IFtzaGFycG5lc3M9MC44NV0gYSBtZWFzdXJlIG9mIGhvdyBjdXJ2eSB0aGUgcGF0aCBzaG91bGQgYmUgYmV0d2VlbiBzcGxpbmVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VydmVkIGxpbmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwic3Ryb2tlXCI6IFwiI2YwMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzYuMDkxMzA4LCAxOC40Mjc1MDFdLFxuICogICAgICAgWy03Ni42OTU1NTYsIDE4LjcyOTUwMV0sXG4gKiAgICAgICBbLTc2LjU1MjczNCwgMTkuNDA0NDNdLFxuICogICAgICAgWy03NC42MTkxNCwgMTkuMTM0Nzg5XSxcbiAqICAgICAgIFstNzMuNjUyMzQzLCAyMC4wNzY1N10sXG4gKiAgICAgICBbLTczLjE1Nzk1OCwgMjAuMjEwNjU2XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgY3VydmVkID0gdHVyZi5iZXppZXIobGluZSk7XG4gKiBjdXJ2ZWQucHJvcGVydGllcyA9IHsgc3Ryb2tlOiAnIzBmMCcgfTtcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtsaW5lLCBjdXJ2ZWRdXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaW5lLCByZXNvbHV0aW9uLCBzaGFycG5lc3MpIHtcbiAgICB2YXIgbGluZU91dCA9IGxpbmVzdHJpbmcoW10pO1xuXG4gICAgbGluZU91dC5wcm9wZXJ0aWVzID0gbGluZS5wcm9wZXJ0aWVzO1xuXG4gICAgdmFyIHNwbGluZSA9IG5ldyBTcGxpbmUoe1xuICAgICAgICBwb2ludHM6IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICAgICAgcmV0dXJuIHt4OiBwdFswXSwgeTogcHRbMV19O1xuICAgICAgICB9KSxcbiAgICAgICAgZHVyYXRpb246IHJlc29sdXRpb24sXG4gICAgICAgIHNoYXJwbmVzczogc2hhcnBuZXNzXG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNwbGluZS5kdXJhdGlvbjsgaSArPSAxMCkge1xuICAgICAgICB2YXIgcG9zID0gc3BsaW5lLnBvcyhpKTtcbiAgICAgICAgaWYgKE1hdGguZmxvb3IoaSAvIDEwMCkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICBsaW5lT3V0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLnB1c2goW3Bvcy54LCBwb3MueV0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGxpbmVPdXQ7XG59O1xuIiwiLyogZXNsaW50LWRpc2FibGUgKi9cblxuIC8qKlxuICAgKiBCZXppZXJTcGxpbmVcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2xlc3pla3IvYmV6aWVyLXNwbGluZS1qc1xuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAY29weXJpZ2h0XG4gICAqIENvcHlyaWdodCAoYykgMjAxMyBMZXN6ZWsgUnliaWNraVxuICAgKlxuICAgKiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gICAqIG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlIFwiU29mdHdhcmVcIiksIHRvIGRlYWxcbiAgICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICAgKiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gICAqIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXQgcGVyc29ucyB0byB3aG9tIHRoZSBTb2Z0d2FyZSBpc1xuICAgKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICAgKlxuICAgKiBUaGUgYWJvdmUgY29weXJpZ2h0IG5vdGljZSBhbmQgdGhpcyBwZXJtaXNzaW9uIG5vdGljZSBzaGFsbCBiZSBpbmNsdWRlZCBpbiBhbGxcbiAgICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAgICpcbiAgICogVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiwgV0lUSE9VVCBXQVJSQU5UWSBPRiBBTlkgS0lORCwgRVhQUkVTUyBPUlxuICAgKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAgICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFXG4gICAqIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiAgICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAgICogT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFIFVTRSBPUiBPVEhFUiBERUFMSU5HUyBJTiBUSEVcbiAgICogU09GVFdBUkUuXG4gICAqL1xudmFyIFNwbGluZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgdGhpcy5wb2ludHMgPSBvcHRpb25zLnBvaW50cyB8fCBbXTtcbiAgICB0aGlzLmR1cmF0aW9uID0gb3B0aW9ucy5kdXJhdGlvbiB8fCAxMDAwMDtcbiAgICB0aGlzLnNoYXJwbmVzcyA9IG9wdGlvbnMuc2hhcnBuZXNzIHx8IDAuODU7XG4gICAgdGhpcy5jZW50ZXJzID0gW107XG4gICAgdGhpcy5jb250cm9scyA9IFtdO1xuICAgIHRoaXMuc3RlcExlbmd0aCA9IG9wdGlvbnMuc3RlcExlbmd0aCB8fCA2MDtcbiAgICB0aGlzLmxlbmd0aCA9IHRoaXMucG9pbnRzLmxlbmd0aDtcbiAgICB0aGlzLmRlbGF5ID0gMDtcbiAgICAvLyB0aGlzIGlzIHRvIGVuc3VyZSBjb21wYXRpYmlsaXR5IHdpdGggdGhlIDJkIHZlcnNpb25cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoOyBpKyspIHRoaXMucG9pbnRzW2ldLnogPSB0aGlzLnBvaW50c1tpXS56IHx8IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgcDEgPSB0aGlzLnBvaW50c1tpXTtcbiAgICAgICAgdmFyIHAyID0gdGhpcy5wb2ludHNbaSArIDFdO1xuICAgICAgICB0aGlzLmNlbnRlcnMucHVzaCh7XG4gICAgICAgICAgICB4OiAocDEueCArIHAyLngpIC8gMixcbiAgICAgICAgICAgIHk6IChwMS55ICsgcDIueSkgLyAyLFxuICAgICAgICAgICAgejogKHAxLnogKyBwMi56KSAvIDJcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbHMucHVzaChbdGhpcy5wb2ludHNbMF0sIHRoaXMucG9pbnRzWzBdXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNlbnRlcnMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMuY2VudGVyc1tpXTtcbiAgICAgICAgdmFyIHAyID0gdGhpcy5jZW50ZXJzW2kgKyAxXTtcbiAgICAgICAgdmFyIGR4ID0gdGhpcy5wb2ludHNbaSArIDFdLnggLSAodGhpcy5jZW50ZXJzW2ldLnggKyB0aGlzLmNlbnRlcnNbaSArIDFdLngpIC8gMjtcbiAgICAgICAgdmFyIGR5ID0gdGhpcy5wb2ludHNbaSArIDFdLnkgLSAodGhpcy5jZW50ZXJzW2ldLnkgKyB0aGlzLmNlbnRlcnNbaSArIDFdLnkpIC8gMjtcbiAgICAgICAgdmFyIGR6ID0gdGhpcy5wb2ludHNbaSArIDFdLnogLSAodGhpcy5jZW50ZXJzW2ldLnkgKyB0aGlzLmNlbnRlcnNbaSArIDFdLnopIC8gMjtcbiAgICAgICAgdGhpcy5jb250cm9scy5wdXNoKFt7XG4gICAgICAgICAgICB4OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnggKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaV0ueCArIGR4KSxcbiAgICAgICAgICAgIHk6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueSArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpXS55ICsgZHkpLFxuICAgICAgICAgICAgejogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS56ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2ldLnogKyBkeil9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIHg6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueCArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpICsgMV0ueCArIGR4KSxcbiAgICAgICAgICAgICAgICB5OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnkgKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaSArIDFdLnkgKyBkeSksXG4gICAgICAgICAgICAgICAgejogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS56ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2kgKyAxXS56ICsgZHopfV0pO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xzLnB1c2goW3RoaXMucG9pbnRzW3RoaXMubGVuZ3RoIC0gMV0sIHRoaXMucG9pbnRzW3RoaXMubGVuZ3RoIC0gMV1dKTtcbiAgICB0aGlzLnN0ZXBzID0gdGhpcy5jYWNoZVN0ZXBzKHRoaXMuc3RlcExlbmd0aCk7XG4gICAgcmV0dXJuIHRoaXM7XG59O1xuXG4gIC8qXG4gICAgQ2FjaGVzIGFuIGFycmF5IG9mIGVxdWlkaXN0YW50IChtb3JlIG9yIGxlc3MpIHBvaW50cyBvbiB0aGUgY3VydmUuXG4gICovXG5TcGxpbmUucHJvdG90eXBlLmNhY2hlU3RlcHMgPSBmdW5jdGlvbiAobWluZGlzdCkge1xuICAgIHZhciBzdGVwcyA9IFtdO1xuICAgIHZhciBsYXN0c3RlcCA9IHRoaXMucG9zKDApO1xuICAgIHN0ZXBzLnB1c2goMCk7XG4gICAgZm9yICh2YXIgdCA9IDA7IHQgPCB0aGlzLmR1cmF0aW9uOyB0ICs9IDEwKSB7XG4gICAgICAgIHZhciBzdGVwID0gdGhpcy5wb3ModCk7XG4gICAgICAgIHZhciBkaXN0ID0gTWF0aC5zcXJ0KChzdGVwLnggLSBsYXN0c3RlcC54KSAqIChzdGVwLnggLSBsYXN0c3RlcC54KSArIChzdGVwLnkgLSBsYXN0c3RlcC55KSAqIChzdGVwLnkgLSBsYXN0c3RlcC55KSArIChzdGVwLnogLSBsYXN0c3RlcC56KSAqIChzdGVwLnogLSBsYXN0c3RlcC56KSk7XG4gICAgICAgIGlmIChkaXN0ID4gbWluZGlzdCkge1xuICAgICAgICAgICAgc3RlcHMucHVzaCh0KTtcbiAgICAgICAgICAgIGxhc3RzdGVwID0gc3RlcDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gc3RlcHM7XG59O1xuXG4gIC8qXG4gICAgcmV0dXJucyBhbmdsZSBhbmQgc3BlZWQgaW4gdGhlIGdpdmVuIHBvaW50IGluIHRoZSBjdXJ2ZVxuICAqL1xuU3BsaW5lLnByb3RvdHlwZS52ZWN0b3IgPSBmdW5jdGlvbiAodCkge1xuICAgIHZhciBwMSA9IHRoaXMucG9zKHQgKyAxMCk7XG4gICAgdmFyIHAyID0gdGhpcy5wb3ModCAtIDEwKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhbmdsZToxODAgKiBNYXRoLmF0YW4yKHAxLnkgLSBwMi55LCBwMS54IC0gcDIueCkgLyAzLjE0LFxuICAgICAgICBzcGVlZDpNYXRoLnNxcnQoKHAyLnggLSBwMS54KSAqIChwMi54IC0gcDEueCkgKyAocDIueSAtIHAxLnkpICogKHAyLnkgLSBwMS55KSArIChwMi56IC0gcDEueikgKiAocDIueiAtIHAxLnopKVxuICAgIH07XG59O1xuXG4gIC8qXG4gICAgR2V0cyB0aGUgcG9zaXRpb24gb2YgdGhlIHBvaW50LCBnaXZlbiB0aW1lLlxuXG4gICAgV0FSTklORzogVGhlIHNwZWVkIGlzIG5vdCBjb25zdGFudC4gVGhlIHRpbWUgaXQgdGFrZXMgYmV0d2VlbiBjb250cm9sIHBvaW50cyBpcyBjb25zdGFudC5cblxuICAgIEZvciBjb25zdGFudCBzcGVlZCwgdXNlIFNwbGluZS5zdGVwc1tpXTtcbiAgKi9cblNwbGluZS5wcm90b3R5cGUucG9zID0gZnVuY3Rpb24gKHRpbWUpIHtcblxuICAgIGZ1bmN0aW9uIGJlemllcih0LCBwMSwgYzEsIGMyLCBwMikge1xuICAgICAgICB2YXIgQiA9IGZ1bmN0aW9uICh0KSB7XG4gICAgICAgICAgICB2YXIgdDIgPSB0ICogdCwgdDMgPSB0MiAqIHQ7XG4gICAgICAgICAgICByZXR1cm4gWyh0MyksICgzICogdDIgKiAoMSAtIHQpKSwgKDMgKiB0ICogKDEgLSB0KSAqICgxIC0gdCkpLCAoKDEgLSB0KSAqICgxIC0gdCkgKiAoMSAtIHQpKV07XG4gICAgICAgIH07XG4gICAgICAgIHZhciBiID0gQih0KTtcbiAgICAgICAgdmFyIHBvcyA9IHtcbiAgICAgICAgICAgIHggOiBwMi54ICogYlswXSArIGMyLnggKiBiWzFdICsgYzEueCAqIGJbMl0gKyBwMS54ICogYlszXSxcbiAgICAgICAgICAgIHkgOiBwMi55ICogYlswXSArIGMyLnkgKiBiWzFdICsgYzEueSAqIGJbMl0gKyBwMS55ICogYlszXSxcbiAgICAgICAgICAgIHogOiBwMi56ICogYlswXSArIGMyLnogKiBiWzFdICsgYzEueiAqIGJbMl0gKyBwMS56ICogYlszXVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gcG9zO1xuICAgIH1cbiAgICB2YXIgdCA9IHRpbWUgLSB0aGlzLmRlbGF5O1xuICAgIGlmICh0IDwgMCkgdCA9IDA7XG4gICAgaWYgKHQgPiB0aGlzLmR1cmF0aW9uKSB0ID0gdGhpcy5kdXJhdGlvbiAtIDE7XG4gICAgLy90ID0gdC10aGlzLmRlbGF5O1xuICAgIHZhciB0MiA9ICh0KSAvIHRoaXMuZHVyYXRpb247XG4gICAgaWYgKHQyID49IDEpIHJldHVybiB0aGlzLnBvaW50c1t0aGlzLmxlbmd0aCAtIDFdO1xuXG4gICAgdmFyIG4gPSBNYXRoLmZsb29yKCh0aGlzLnBvaW50cy5sZW5ndGggLSAxKSAqIHQyKTtcbiAgICB2YXIgdDEgPSAodGhpcy5sZW5ndGggLSAxKSAqIHQyIC0gbjtcbiAgICByZXR1cm4gYmV6aWVyKHQxLCB0aGlzLnBvaW50c1tuXSwgdGhpcy5jb250cm9sc1tuXVsxXSwgdGhpcy5jb250cm9sc1tuICsgMV1bMF0sIHRoaXMucG9pbnRzW24gKyAxXSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IFNwbGluZTtcbiIsIi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvODM5ODk5L2hvdy1kby1pLWNhbGN1bGF0ZS1hLXBvaW50LW9uLWEtY2lyY2xlcy1jaXJjdW1mZXJlbmNlXG4vLyByYWRpYW5zID0gZGVncmVlcyAqIChwaS8xODApXG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL2J1ZmZlci5odG1sXG5cbnZhciBoZWxwZXJzID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJyk7XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIGpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG52YXIgbm9ybWFsaXplID0gcmVxdWlyZSgnZ2VvanNvbi1ub3JtYWxpemUnKTtcblxuLyoqXG4gKiBDYWxjdWxhdGVzIGEgYnVmZmVyIGZvciBpbnB1dCBmZWF0dXJlcyBmb3IgYSBnaXZlbiByYWRpdXMuIFVuaXRzIHN1cHBvcnRlZCBhcmUgbWlsZXMsIGtpbG9tZXRlcnMsIGFuZCBkZWdyZWVzLlxuICpcbiAqIEBuYW1lIGJ1ZmZlclxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGZlYXR1cmUgaW5wdXQgdG8gYmUgYnVmZmVyZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBkaXN0YW5jZSB0byBkcmF3IHRoZSBidWZmZXJcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0IGFueSBvZiB0aGUgb3B0aW9ucyBzdXBwb3J0ZWQgYnkgdHVyZiB1bml0c1xuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj58RmVhdHVyZUNvbGxlY3Rpb248TXVsdGlQb2x5Z29uPnxQb2x5Z29ufE11bHRpUG9seWdvbn0gYnVmZmVyZWQgZmVhdHVyZXNcbiAqXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTAuNTQ4NjMwLCAxNC42MTY1OTldXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgdW5pdCA9ICdtaWxlcyc7XG4gKlxuICogdmFyIGJ1ZmZlcmVkID0gdHVyZi5idWZmZXIocHQsIDUwMCwgdW5pdCk7XG4gKiB2YXIgcmVzdWx0ID0gdHVyZi5mZWF0dXJlY29sbGVjdGlvbihbYnVmZmVyZWQsIHB0XSk7XG4gKlxuICogLy89cmVzdWx0XG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgcmFkaXVzLCB1bml0cykge1xuXG4gICAgdmFyIGRlZ3JlZXMgPSBoZWxwZXJzLmRpc3RhbmNlVG9EZWdyZWVzKHJhZGl1cywgdW5pdHMpO1xuICAgIHZhciBmYyA9IG5vcm1hbGl6ZShmZWF0dXJlKTtcbiAgICB2YXIgYnVmZmVyZWQgPSBub3JtYWxpemUoZmVhdHVyZUNvbGxlY3Rpb24oZmMuZmVhdHVyZXMubWFwKGZ1bmN0aW9uIChmKSB7XG4gICAgICAgIHJldHVybiBidWZmZXJPcChmLCBkZWdyZWVzKTtcbiAgICB9KSkpO1xuXG4gICAgaWYgKGJ1ZmZlcmVkLmZlYXR1cmVzLmxlbmd0aCA+IDEpIHJldHVybiBidWZmZXJlZDtcbiAgICBlbHNlIGlmIChidWZmZXJlZC5mZWF0dXJlcy5sZW5ndGggPT09IDEpIHJldHVybiBidWZmZXJlZC5mZWF0dXJlc1swXTtcbn07XG5cbmZ1bmN0aW9uIGJ1ZmZlck9wKGZlYXR1cmUsIHJhZGl1cykge1xuICAgIHZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG4gICAgdmFyIGdlb20gPSByZWFkZXIucmVhZChmZWF0dXJlLmdlb21ldHJ5KTtcbiAgICB2YXIgYnVmZmVyZWQgPSBnZW9tLmJ1ZmZlcihyYWRpdXMpO1xuICAgIHZhciB3cml0ZXIgPSBuZXcganN0cy5pby5HZW9KU09OV3JpdGVyKCk7XG4gICAgYnVmZmVyZWQgPSB3cml0ZXIud3JpdGUoYnVmZmVyZWQpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBnZW9tZXRyeTogYnVmZmVyZWQsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9XG4gICAgfTtcbn1cbiIsInZhciBiYm94ID0gcmVxdWlyZSgndHVyZi1iYm94JyksXG4gICAgcG9pbnQgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2ludDtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gYW5kIHJldHVybnMgdGhlIGFic29sdXRlIGNlbnRlciBwb2ludCBvZiBhbGwgZmVhdHVyZXMuXG4gKlxuICogQG5hbWUgY2VudGVyXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybiB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZSBhdCB0aGVcbiAqIGFic29sdXRlIGNlbnRlciBwb2ludCBvZiBhbGwgaW5wdXQgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTIyMjU5LCAzNS40NjkxXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTAyNzU0LCAzNS40NjM0NTVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MDgyNjksIDM1LjQ2MzI0NV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxNjgwOSwgMzUuNDY1Nzc5XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE1MzcyLCAzNS40NjcwNzJdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MDkzNjMsIDM1LjQ2MzA1M11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxMTEyMywgMzUuNDY2NjAxXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE4NTQ3LCAzNS40NjkzMjddXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTk3MDYsIDM1LjQ2OTY1OV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxNzgzOSwgMzUuNDY2OTk4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTA4Njc4LCAzNS40NjQ5NDJdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTQ5MTQsIDM1LjQ2MzQ1M11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIGNlbnRlclB0ID0gdHVyZi5jZW50ZXIoZmVhdHVyZXMpO1xuICogY2VudGVyUHQucHJvcGVydGllc1snbWFya2VyLXNpemUnXSA9ICdsYXJnZSc7XG4gKiBjZW50ZXJQdC5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjMDAwJztcbiAqXG4gKiB2YXIgcmVzdWx0RmVhdHVyZXMgPSBmZWF0dXJlcy5mZWF0dXJlcy5jb25jYXQoY2VudGVyUHQpO1xuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsYXllcikge1xuICAgIHZhciBleHQgPSBiYm94KGxheWVyKTtcbiAgICB2YXIgeCA9IChleHRbMF0gKyBleHRbMl0pIC8gMjtcbiAgICB2YXIgeSA9IChleHRbMV0gKyBleHRbM10pIC8gMjtcbiAgICByZXR1cm4gcG9pbnQoW3gsIHldKTtcbn07XG4iLCJ2YXIgZWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaDtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIGZlYXR1cmVzIGFuZCBjYWxjdWxhdGVzIHRoZSBjZW50cm9pZCB1c2luZ1xuICogdGhlIG1lYW4gb2YgYWxsIHZlcnRpY2VzLlxuICogVGhpcyBsZXNzZW5zIHRoZSBlZmZlY3Qgb2Ygc21hbGwgaXNsYW5kcyBhbmQgYXJ0aWZhY3RzIHdoZW4gY2FsY3VsYXRpbmdcbiAqIHRoZSBjZW50cm9pZCBvZiBhIHNldCBvZiBwb2x5Z29ucy5cbiAqXG4gKiBAbmFtZSBjZW50cm9pZFxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gdGhlIGNlbnRyb2lkIG9mIHRoZSBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjAwNDcxNF0sXG4gKiAgICAgICBbMTA1LjgxODkzOSwyMS4wNjE3NTRdLFxuICogICAgICAgWzEwNS44OTAwMDcsMjEuMDYxNzU0XSxcbiAqICAgICAgIFsxMDUuODkwMDA3LDIxLjAwNDcxNF0sXG4gKiAgICAgICBbMTA1LjgxODkzOSwyMS4wMDQ3MTRdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgY2VudHJvaWRQdCA9IHR1cmYuY2VudHJvaWQocG9seSk7XG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seSwgY2VudHJvaWRQdF1cbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgdmFyIHhTdW0gPSAwLCB5U3VtID0gMCwgbGVuID0gMDtcbiAgICBlYWNoKGZlYXR1cmVzLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgeFN1bSArPSBjb29yZFswXTtcbiAgICAgICAgeVN1bSArPSBjb29yZFsxXTtcbiAgICAgICAgbGVuKys7XG4gICAgfSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHBvaW50KFt4U3VtIC8gbGVuLCB5U3VtIC8gbGVuXSk7XG59O1xuIiwidmFyIGluc2lkZSA9IHJlcXVpcmUoJ3R1cmYtaW5zaWRlJyk7XG5cbi8qKlxuICogSm9pbnMgYXR0cmlidXRlcyBGZWF0dXJlQ29sbGVjdGlvbiBvZiBwb2x5Z29ucyB3aXRoIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2ZcbiAqIHBvaW50cy4gR2l2ZW4gYW4gYGluUHJvcGVydHlgIG9uIHBvaW50cyBhbmQgYW4gYG91dFByb3BlcnR5YCBmb3IgcG9seWdvbnMsXG4gKiB0aGlzIGZpbmRzIGV2ZXJ5IHBvaW50IHRoYXQgbGllcyB3aXRoaW4gZWFjaCBwb2x5Z29uLCBjb2xsZWN0cyB0aGUgYGluUHJvcGVydHlgXG4gKiB2YWx1ZXMgZnJvbSB0aG9zZSBwb2ludHMsIGFuZCBhZGRzIHRoZW0gYXMgYW4gYXJyYXkgdG8gYG91dFByb3BlcnR5YCBvbiB0aGVcbiAqIHBvbHlnb24uXG4gKlxuICogQG5hbWUgY29sbGVjdFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gcG9seWdvbnMgcG9seWdvbnMgd2l0aCB2YWx1ZXMgb24gd2hpY2ggdG8gYWdncmVnYXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gcG9pbnRzIHBvaW50cyB0byBiZSBhZ2dyZWdhdGVkXG4gKiBAcGFyYW0ge3N0cmluZ30gaW5Qcm9wZXJ0eSBwcm9wZXJ0eSB0byBiZSBuZXN0ZWQgZnJvbVxuICogQHBhcmFtIHtzdHJpbmd9IG91dFByb3BlcnR5IHByb3BlcnR5IHRvIGJlIG5lc3RlZCBpbnRvXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gcG9seWdvbnMgd2l0aCBwcm9wZXJ0aWVzIGxpc3RlZCBiYXNlZCBvbiBgb3V0RmllbGRgXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkxID0gcG9seWdvbihbW1swLDBdLFsxMCwwXSxbMTAsMTBdLFswLDEwXSxbMCwwXV1dKTtcbiAqIHZhciBwb2x5MiA9IHBvbHlnb24oW1tbMTAsMF0sWzIwLDEwXSxbMjAsMjBdLFsyMCwwXSxbMTAsMF1dXSk7XG4gKiB2YXIgcG9seUZDID0gZmVhdHVyZWNvbGxlY3Rpb24oW3BvbHkxLCBwb2x5Ml0pO1xuICogdmFyIHB0MSA9IHBvaW50KFs1LDVdLCB7cG9wdWxhdGlvbjogMjAwfSk7XG4gKiB2YXIgcHQyID0gcG9pbnQoWzEsM10sIHtwb3B1bGF0aW9uOiA2MDB9KTtcbiAqIHZhciBwdDMgPSBwb2ludChbMTQsMl0sIHtwb3B1bGF0aW9uOiAxMDB9KTtcbiAqIHZhciBwdDQgPSBwb2ludChbMTMsMV0sIHtwb3B1bGF0aW9uOiAyMDB9KTtcbiAqIHZhciBwdDUgPSBwb2ludChbMTksN10sIHtwb3B1bGF0aW9uOiAzMDB9KTtcbiAqIHZhciBwdEZDID0gZmVhdHVyZWNvbGxlY3Rpb24oW3B0MSwgcHQyLCBwdDMsIHB0NCwgcHQ1XSk7XG4gKiB2YXIgYWdncmVnYXRlZCA9IGFnZ3JlZ2F0ZShwb2x5RkMsIHB0RkMsICdwb3B1bGF0aW9uJywgJ3ZhbHVlcycpO1xuICpcbiAqIGFnZ3JlZ2F0ZWQuZmVhdHVyZXNbMF0ucHJvcGVydGllcy52YWx1ZXMgLy8gPT4gWzIwMCwgNjAwXSk7XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29sbGVjdChwb2x5Z29ucywgcG9pbnRzLCBpblByb3BlcnR5LCBvdXRQcm9wZXJ0eSkge1xuICAgIHBvbHlnb25zLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHBvbHkpIHtcbiAgICAgICAgdmFyIHZhbHVlcyA9IHBvaW50cy5mZWF0dXJlcy5maWx0ZXIoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgICAgICByZXR1cm4gaW5zaWRlKHB0LCBwb2x5KTtcbiAgICAgICAgfSkubWFwKGZ1bmN0aW9uIChwdCkge1xuICAgICAgICAgICAgcmV0dXJuIHB0LnByb3BlcnRpZXNbaW5Qcm9wZXJ0eV07XG4gICAgICAgIH0pO1xuXG4gICAgICAgIGlmICghcG9seS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBwb2x5LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgfVxuXG4gICAgICAgIHBvbHkucHJvcGVydGllc1tvdXRQcm9wZXJ0eV0gPSB2YWx1ZXM7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcG9seWdvbnM7XG59O1xuIiwidmFyIG1ldGEgPSByZXF1aXJlKCd0dXJmLW1ldGEnKTtcblxuLyoqXG4gKiBDb21iaW5lcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gb2Yge0BsaW5rIFBvaW50fSxcbiAqIHtAbGluayBMaW5lU3RyaW5nfSwgb3Ige0BsaW5rIFBvbHlnb259IGZlYXR1cmVzXG4gKiBpbnRvIHtAbGluayBNdWx0aVBvaW50fSwge0BsaW5rIE11bHRpTGluZVN0cmluZ30sIG9yXG4gKiB7QGxpbmsgTXVsdGlQb2x5Z29ufSBmZWF0dXJlcy5cbiAqXG4gKiBAbmFtZSBjb21iaW5lXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPChQb2ludHxMaW5lU3RyaW5nfFBvbHlnb24pPn0gZmMgYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBhbnkgdHlwZVxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248KE11bHRpUG9pbnR8TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbik+fSBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGNvcnJlc3BvbmRpbmcgdHlwZSB0byBpbnB1dFxuICogQGV4YW1wbGVcbiAqIHZhciBmYyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzE5LjAyNjQzMiwgNDcuNDkxMzRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzE5LjA3NDQ5NywgNDcuNTA5NTQ4XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgY29tYmluZWQgPSB0dXJmLmNvbWJpbmUoZmMpO1xuICpcbiAqIC8vPWNvbWJpbmVkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmMpIHtcbiAgICB2YXIgZ3JvdXBzID0ge1xuICAgICAgICBNdWx0aVBvaW50OiB7Y29vcmRpbmF0ZXM6IFtdLCBwcm9wZXJ0aWVzOiBbXX0sXG4gICAgICAgIE11bHRpTGluZVN0cmluZzoge2Nvb3JkaW5hdGVzOiBbXSwgcHJvcGVydGllczogW119LFxuICAgICAgICBNdWx0aVBvbHlnb246IHtjb29yZGluYXRlczogW10sIHByb3BlcnRpZXM6IFtdfVxuICAgIH07XG5cbiAgICB2YXIgbXVsdGlNYXBwaW5nID0gT2JqZWN0LmtleXMoZ3JvdXBzKS5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGl0ZW0pIHtcbiAgICAgICAgbWVtb1tpdGVtLnJlcGxhY2UoJ011bHRpJywgJycpXSA9IGl0ZW07XG4gICAgICAgIHJldHVybiBtZW1vO1xuICAgIH0sIHt9KTtcblxuICAgIGZ1bmN0aW9uIGFkZFRvR3JvdXAoZmVhdHVyZSwga2V5LCBtdWx0aSkge1xuICAgICAgICBpZiAoIW11bHRpKSB7XG4gICAgICAgICAgICBncm91cHNba2V5XS5jb29yZGluYXRlcy5wdXNoKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZ3JvdXBzW2tleV0uY29vcmRpbmF0ZXMgPSBncm91cHNba2V5XS5jb29yZGluYXRlcy5jb25jYXQoZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgICAgIH1cbiAgICAgICAgZ3JvdXBzW2tleV0ucHJvcGVydGllcy5wdXNoKGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgfVxuXG4gICAgbWV0YS5mZWF0dXJlRWFjaChmYywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5KSByZXR1cm47XG4gICAgICAgIGlmIChncm91cHNbZmVhdHVyZS5nZW9tZXRyeS50eXBlXSkge1xuICAgICAgICAgICAgYWRkVG9Hcm91cChmZWF0dXJlLCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUsIHRydWUpO1xuICAgICAgICB9IGVsc2UgaWYgKG11bHRpTWFwcGluZ1tmZWF0dXJlLmdlb21ldHJ5LnR5cGVdKSB7XG4gICAgICAgICAgICBhZGRUb0dyb3VwKGZlYXR1cmUsIG11bHRpTWFwcGluZ1tmZWF0dXJlLmdlb21ldHJ5LnR5cGVdLCBmYWxzZSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBPYmplY3Qua2V5cyhncm91cHMpXG4gICAgICAgICAgICAuZmlsdGVyKGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ3JvdXBzW2tleV0uY29vcmRpbmF0ZXMubGVuZ3RoO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIC5zb3J0KClcbiAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgcHJvcGVydGllczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29sbGVjdGVkUHJvcGVydGllczogZ3JvdXBzW2tleV0ucHJvcGVydGllc1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeToge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHlwZToga2V5LFxuICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGdyb3Vwc1trZXldLmNvb3JkaW5hdGVzXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfSlcbiAgICB9O1xufTtcbiIsIi8vIDEuIHJ1biB0aW4gb24gcG9pbnRzXG4vLyAyLiBjYWxjdWxhdGUgbGVudGggb2YgYWxsIGVkZ2VzIGFuZCBhcmVhIG9mIGFsbCB0cmlhbmdsZXNcbi8vIDMuIHJlbW92ZSB0cmlhbmdsZXMgdGhhdCBmYWlsIHRoZSBtYXggbGVuZ3RoIHRlc3Rcbi8vIDQuIGJ1ZmZlciB0aGUgcmVzdWx0cyBzbGlnaHRseVxuLy8gNS4gbWVyZ2UgdGhlIHJlc3VsdHNcbnZhciB0aW4gPSByZXF1aXJlKCd0dXJmLXRpbicpO1xudmFyIHVuaW9uID0gcmVxdWlyZSgndHVyZi11bmlvbicpO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCByZXR1cm5zIGEgY29uY2F2ZSBodWxsIHBvbHlnb24uXG4gKlxuICogSW50ZXJuYWxseSwgdGhpcyB1c2VzIFt0dXJmLXRpbl0oaHR0cHM6Ly9naXRodWIuY29tL1R1cmZqcy90dXJmLXRpbikgdG8gZ2VuZXJhdGUgZ2VvbWV0cmllcy5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gcG9pbnRzIGlucHV0IHBvaW50c1xuICogQHBhcmFtIHtudW1iZXJ9IG1heEVkZ2UgdGhlIHNpemUgb2YgYW4gZWRnZSBuZWNlc3NhcnkgZm9yIHBhcnQgb2YgdGhlXG4gKiBodWxsIHRvIGJlY29tZSBjb25jYXZlIChpbiBtaWxlcylcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0cyB1c2VkIGZvciBtYXhFZGdlIGRpc3RhbmNlIChtaWxlcyBvciBraWxvbWV0ZXJzKVxuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IGEgY29uY2F2ZSBodWxsXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbWF4RWRnZSBwYXJhbWV0ZXIgaXMgbWlzc2luZ1xuICogQHRocm93cyB7RXJyb3J9IGlmIHVuaXRzIHBhcmFtZXRlciBpcyBtaXNzaW5nXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My42MDEyMjYsIDQ0LjY0MjY0M11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU5MTQ0MiwgNDQuNjUxNDM2XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNjMuNTgwNzk5LCA0NC42NDg3NDldXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My41NzM1ODksIDQ0LjY0MTc4OF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU4NzY2NSwgNDQuNjQ1MzNdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My41OTUyMTgsIDQ0LjY0NzY1XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgaHVsbCA9IHR1cmYuY29uY2F2ZShwb2ludHMsIDEsICdtaWxlcycpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IHBvaW50cy5mZWF0dXJlcy5jb25jYXQoaHVsbCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5mdW5jdGlvbiBjb25jYXZlKHBvaW50cywgbWF4RWRnZSwgdW5pdHMpIHtcbiAgICBpZiAodHlwZW9mIG1heEVkZ2UgIT09ICdudW1iZXInKSB0aHJvdyBuZXcgRXJyb3IoJ21heEVkZ2UgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG4gICAgaWYgKHR5cGVvZiB1bml0cyAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBFcnJvcigndW5pdHMgcGFyYW1ldGVyIGlzIHJlcXVpcmVkJyk7XG5cbiAgICB2YXIgdGluUG9seXMgPSB0aW4ocG9pbnRzKTtcbiAgICB2YXIgZmlsdGVyZWRQb2x5cyA9IHRpblBvbHlzLmZlYXR1cmVzLmZpbHRlcihmaWx0ZXJUcmlhbmdsZXMpO1xuICAgIHRpblBvbHlzLmZlYXR1cmVzID0gZmlsdGVyZWRQb2x5cztcblxuICAgIGZ1bmN0aW9uIGZpbHRlclRyaWFuZ2xlcyh0cmlhbmdsZSkge1xuICAgICAgICB2YXIgcHQxID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF07XG4gICAgICAgIHZhciBwdDIgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXTtcbiAgICAgICAgdmFyIHB0MyA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzJdO1xuICAgICAgICB2YXIgZGlzdDEgPSBkaXN0YW5jZShwdDEsIHB0MiwgdW5pdHMpO1xuICAgICAgICB2YXIgZGlzdDIgPSBkaXN0YW5jZShwdDIsIHB0MywgdW5pdHMpO1xuICAgICAgICB2YXIgZGlzdDMgPSBkaXN0YW5jZShwdDEsIHB0MywgdW5pdHMpO1xuICAgICAgICByZXR1cm4gKGRpc3QxIDw9IG1heEVkZ2UgJiYgZGlzdDIgPD0gbWF4RWRnZSAmJiBkaXN0MyA8PSBtYXhFZGdlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbWVyZ2UodGluUG9seXMpO1xufVxuXG5mdW5jdGlvbiBtZXJnZShwb2x5Z29ucykge1xuICAgIHZhciBtZXJnZWQgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBvbHlnb25zLmZlYXR1cmVzWzBdKSksXG4gICAgICAgIGZlYXR1cmVzID0gcG9seWdvbnMuZmVhdHVyZXM7XG5cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gZmVhdHVyZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgdmFyIHBvbHkgPSBmZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKHBvbHkuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIG1lcmdlZCA9IHVuaW9uKG1lcmdlZCwgcG9seSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlZDtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb25jYXZlO1xuIiwidmFyIGVhY2ggPSByZXF1aXJlKCd0dXJmLW1ldGEnKS5jb29yZEVhY2gsXG4gICAgY29udmV4SHVsbCA9IHJlcXVpcmUoJ2NvbnZleC1odWxsJyksXG4gICAgcG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvbHlnb247XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIHJldHVybnMgYVxuICogW2NvbnZleCBodWxsXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbnZleF9odWxsKSBwb2x5Z29uLlxuICpcbiAqIEludGVybmFsbHkgdGhpcyB1c2VzXG4gKiB0aGUgW2NvbnZleC1odWxsXShodHRwczovL2dpdGh1Yi5jb20vbWlrb2xhbHlzZW5rby9jb252ZXgtaHVsbCkgbW9kdWxlIHRoYXRcbiAqIGltcGxlbWVudHMgYSBbbW9ub3RvbmUgY2hhaW4gaHVsbF0oaHR0cDovL2VuLndpa2lib29rcy5vcmcvd2lraS9BbGdvcml0aG1fSW1wbGVtZW50YXRpb24vR2VvbWV0cnkvQ29udmV4X2h1bGwvTW9ub3RvbmVfY2hhaW4pLlxuICpcbiAqIEBuYW1lIGNvbnZleFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IGZlYXR1cmVjb2xsZWN0aW9uIGlucHV0IHBvaW50c1xuICogQHJldHVybnMge0ZlYXR1cmU8UG9seWdvbj59IGEgY29udmV4IGh1bGxcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuMTk1MzEyLCA0My43NTUyMjVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjQwNDA1MiwgNDMuODQyNDUxMV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuNTc5ODMzLCA0My42NTk5MjRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjM2MDEwNywgNDMuNTE2Njg4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC4xNDAzOCwgNDMuNTg4MzQ4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC4xOTUzMTIsIDQzLjc1NTIyNV1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIGh1bGwgPSB0dXJmLmNvbnZleChwb2ludHMpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IHBvaW50cy5mZWF0dXJlcy5jb25jYXQoaHVsbCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlY29sbGVjdGlvbikge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBlYWNoKGZlYXR1cmVjb2xsZWN0aW9uLCBmdW5jdGlvbiAoY29vcmQpIHsgcG9pbnRzLnB1c2goY29vcmQpOyB9KTtcbiAgICB2YXIgaHVsbCA9IGNvbnZleEh1bGwocG9pbnRzKTtcbiAgICBpZiAoaHVsbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciByaW5nID0gW107XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaHVsbC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmluZy5wdXNoKHBvaW50c1todWxsW2ldWzBdXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmluZy5wdXNoKHBvaW50c1todWxsW2h1bGwubGVuZ3RoIC0gMV1bMV1dKTtcbiAgICAgICAgcmV0dXJuIHBvbHlnb24oW3JpbmddKTtcbiAgICB9XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG4iLCIvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcbnZhciBnZXRDb29yZCA9IHJlcXVpcmUoJ3R1cmYtaW52YXJpYW50JykuZ2V0Q29vcmQ7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpO1xudmFyIHBvaW50ID0gaGVscGVycy5wb2ludDtcbnZhciBkaXN0YW5jZVRvUmFkaWFucyA9IGhlbHBlcnMuZGlzdGFuY2VUb1JhZGlhbnM7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBjYWxjdWxhdGVzIHRoZSBsb2NhdGlvbiBvZiBhIGRlc3RpbmF0aW9uIHBvaW50IGdpdmVuIGEgZGlzdGFuY2UgaW4gZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnM7IGFuZCBiZWFyaW5nIGluIGRlZ3JlZXMuIFRoaXMgdXNlcyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKSB0byBhY2NvdW50IGZvciBnbG9iYWwgY3VydmF0dXJlLlxuICpcbiAqIEBuYW1lIGRlc3RpbmF0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBmcm9tIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgZGlzdGFuY2UgZnJvbSB0aGUgc3RhcnRpbmcgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBiZWFyaW5nIHJhbmdpbmcgZnJvbSAtMTgwIHRvIDE4MFxuICogQHBhcmFtIHtTdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBtaWxlcywga2lsb21ldGVycywgZGVncmVlcywgb3IgcmFkaWFuc1xuICogQHJldHVybnMge0ZlYXR1cmU8UG9pbnQ+fSBkZXN0aW5hdGlvbiBwb2ludFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICB9XG4gKiB9O1xuICogdmFyIGRpc3RhbmNlID0gNTA7XG4gKiB2YXIgYmVhcmluZyA9IDkwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgZGVzdGluYXRpb24gPSB0dXJmLmRlc3RpbmF0aW9uKHBvaW50LCBkaXN0YW5jZSwgYmVhcmluZywgdW5pdHMpO1xuICogZGVzdGluYXRpb24ucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCc7XG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9pbnQsIGRlc3RpbmF0aW9uXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbSwgZGlzdGFuY2UsIGJlYXJpbmcsIHVuaXRzKSB7XG4gICAgdmFyIGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHJhZGlhbnMyZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGdldENvb3JkKGZyb20pO1xuICAgIHZhciBsb25naXR1ZGUxID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMxWzBdO1xuICAgIHZhciBsYXRpdHVkZTEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMV07XG4gICAgdmFyIGJlYXJpbmdfcmFkID0gZGVncmVlczJyYWRpYW5zICogYmVhcmluZztcblxuICAgIHZhciByYWRpYW5zID0gZGlzdGFuY2VUb1JhZGlhbnMoZGlzdGFuY2UsIHVuaXRzKTtcblxuICAgIHZhciBsYXRpdHVkZTIgPSBNYXRoLmFzaW4oTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguY29zKHJhZGlhbnMpICtcbiAgICAgICAgTWF0aC5jb3MobGF0aXR1ZGUxKSAqIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MoYmVhcmluZ19yYWQpKTtcbiAgICB2YXIgbG9uZ2l0dWRlMiA9IGxvbmdpdHVkZTEgKyBNYXRoLmF0YW4yKE1hdGguc2luKGJlYXJpbmdfcmFkKSAqXG4gICAgICAgIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MobGF0aXR1ZGUxKSxcbiAgICAgICAgTWF0aC5jb3MocmFkaWFucykgLSBNYXRoLnNpbihsYXRpdHVkZTEpICogTWF0aC5zaW4obGF0aXR1ZGUyKSk7XG5cbiAgICByZXR1cm4gcG9pbnQoW3JhZGlhbnMyZGVncmVlcyAqIGxvbmdpdHVkZTIsIHJhZGlhbnMyZGVncmVlcyAqIGxhdGl0dWRlMl0pO1xufTtcbiIsIi8vIGRlcGVuZCBvbiBqc3RzIGZvciBub3cgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9leGFtcGxlcy9vdmVybGF5Lmh0bWxcbnZhciBqc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG4vKipcbiAqIEZpbmRzIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdHdvIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBieSBjbGlwcGluZyB0aGUgc2Vjb25kXG4gKiBwb2x5Z29uIGZyb20gdGhlIGZpcnN0LlxuICpcbiAqIEBuYW1lIGRpZmZlcmVuY2VcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seTEgaW5wdXQgUG9seWdvbiBmZWF1cmVcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seTIgUG9seWdvbiBmZWF0dXJlIHRvIGRpZmZlcmVuY2UgZnJvbSBgcG9seTFgXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvbHlnb24+fSBhIFBvbHlnb24gZmVhdHVyZSBzaG93aW5nIHRoZSBhcmVhIG9mIGBwb2x5MWAgZXhjbHVkaW5nIHRoZSBhcmVhIG9mIGBwb2x5MmBcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImZpbGxcIjogXCIjMGYwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstNDYuNzM4NTg2LCAtMjMuNTk2NzExXSxcbiAqICAgICAgIFstNDYuNzM4NTg2LCAtMjMuNDU4MjA3XSxcbiAqICAgICAgIFstNDYuNTYwMDU4LCAtMjMuNDU4MjA3XSxcbiAqICAgICAgIFstNDYuNTYwMDU4LCAtMjMuNTk2NzExXSxcbiAqICAgICAgIFstNDYuNzM4NTg2LCAtMjMuNTk2NzExXVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcG9seTIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImZpbGxcIjogXCIjMDBmXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstNDYuNjUwMDA5LCAtMjMuNjMxMzE0XSxcbiAqICAgICAgIFstNDYuNjUwMDA5LCAtMjMuNTIzN10sXG4gKiAgICAgICBbLTQ2LjUwOTI0NiwgLTIzLjUyMzddLFxuICogICAgICAgWy00Ni41MDkyNDYsIC0yMy42MzEzMTRdLFxuICogICAgICAgWy00Ni42NTAwMDksIC0yMy42MzEzMTRdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgZGlmZmVyZW5jZWQgPSB0dXJmLmRpZmZlcmVuY2UocG9seTEsIHBvbHkyKTtcbiAqIGRpZmZlcmVuY2VkLnByb3BlcnRpZXMuZmlsbCA9ICcjZjAwJztcbiAqXG4gKiB2YXIgcG9seWdvbnMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW3BvbHkxLCBwb2x5Ml1cbiAqIH07XG4gKlxuICogLy89cG9seWdvbnNcbiAqXG4gKiAvLz1kaWZmZXJlbmNlZFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgIHZhciBwb2x5MSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocDEpKTtcbiAgICB2YXIgcG9seTIgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHAyKSk7XG4gICAgaWYgKHBvbHkxLnR5cGUgIT09ICdGZWF0dXJlJykge1xuICAgICAgICBwb2x5MSA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHBvbHkxXG4gICAgICAgIH07XG4gICAgfVxuICAgIGlmIChwb2x5Mi50eXBlICE9PSAnRmVhdHVyZScpIHtcbiAgICAgICAgcG9seTIgPSB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgICAgIGdlb21ldHJ5OiBwb2x5MlxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG4gICAgdmFyIGEgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShwb2x5MS5nZW9tZXRyeSkpO1xuICAgIHZhciBiID0gcmVhZGVyLnJlYWQoSlNPTi5zdHJpbmdpZnkocG9seTIuZ2VvbWV0cnkpKTtcbiAgICB2YXIgZGlmZmVyZW5jZWQgPSBhLmRpZmZlcmVuY2UoYik7XG5cbiAgICBpZiAoZGlmZmVyZW5jZWQuaXNFbXB0eSgpKSByZXR1cm4gdW5kZWZpbmVkO1xuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcbiAgICB2YXIgZ2VvanNvbkdlb21ldHJ5ID0gd3JpdGVyLndyaXRlKGRpZmZlcmVuY2VkKTtcblxuICAgIHBvbHkxLmdlb21ldHJ5ID0gZGlmZmVyZW5jZWQ7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHBvbHkxLnByb3BlcnRpZXMsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9qc29uR2VvbWV0cnlcbiAgICB9O1xufTtcbiIsInZhciBnZXRDb29yZCA9IHJlcXVpcmUoJ3R1cmYtaW52YXJpYW50JykuZ2V0Q29vcmQ7XG52YXIgcmFkaWFuc1RvRGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5yYWRpYW5zVG9EaXN0YW5jZTtcbi8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuLy9odHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuXG4vKipcbiAqIENhbGN1bGF0ZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGluIGRlZ3JlZXMsIHJhZGlhbnMsXG4gKiBtaWxlcywgb3Iga2lsb21ldGVycy4gVGhpcyB1c2VzIHRoZVxuICogW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKVxuICogdG8gYWNjb3VudCBmb3IgZ2xvYmFsIGN1cnZhdHVyZS5cbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gZnJvbSBvcmlnaW4gcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHRvIGRlc3RpbmF0aW9uIHBvaW50XG4gKiBAcGFyYW0ge1N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyc1xuICogQHJldHVybiB7TnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZyb20gPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS4zNDMsIDM5Ljk4NF1cbiAqICAgfVxuICogfTtcbiAqIHZhciB0byA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjUzNCwgMzkuMTIzXVxuICogICB9XG4gKiB9O1xuICogdmFyIHVuaXRzID0gXCJtaWxlc1wiO1xuICpcbiAqIHZhciBwb2ludHMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW2Zyb20sIHRvXVxuICogfTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiB2YXIgZGlzdGFuY2UgPSB0dXJmLmRpc3RhbmNlKGZyb20sIHRvLCB1bml0cyk7XG4gKlxuICogLy89ZGlzdGFuY2VcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZnJvbSwgdG8sIHVuaXRzKSB7XG4gICAgdmFyIGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGdldENvb3JkKGZyb20pO1xuICAgIHZhciBjb29yZGluYXRlczIgPSBnZXRDb29yZCh0byk7XG4gICAgdmFyIGRMYXQgPSBkZWdyZWVzMnJhZGlhbnMgKiAoY29vcmRpbmF0ZXMyWzFdIC0gY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgZExvbiA9IGRlZ3JlZXMycmFkaWFucyAqIChjb29yZGluYXRlczJbMF0gLSBjb29yZGluYXRlczFbMF0pO1xuICAgIHZhciBsYXQxID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMxWzFdO1xuICAgIHZhciBsYXQyID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMyWzFdO1xuXG4gICAgdmFyIGEgPSBNYXRoLnBvdyhNYXRoLnNpbihkTGF0IC8gMiksIDIpICtcbiAgICAgICAgICBNYXRoLnBvdyhNYXRoLnNpbihkTG9uIC8gMiksIDIpICogTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsYXQyKTtcblxuICAgIHJldHVybiByYWRpYW5zVG9EaXN0YW5jZSgyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpLCB1bml0cyk7XG59O1xuIiwidmFyIGJib3ggPSByZXF1aXJlKCd0dXJmLWJib3gnKTtcbnZhciBiYm94UG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtYmJveC1wb2x5Z29uJyk7XG5cbi8qKlxuICogVGFrZXMgYW55IG51bWJlciBvZiBmZWF0dXJlcyBhbmQgcmV0dXJucyBhIHJlY3Rhbmd1bGFyIHtAbGluayBQb2x5Z29ufSB0aGF0IGVuY29tcGFzc2VzIGFsbCB2ZXJ0aWNlcy5cbiAqXG4gKiBAbmFtZSBlbnZlbG9wZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmMgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9seWdvbj59IGEgcmVjdGFuZ3VsYXIgUG9seWdvbiBmZWF0dXJlIHRoYXQgZW5jb21wYXNzZXMgYWxsIHZlcnRpY2VzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZjID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICogICAgICAgICBcIm5hbWVcIjogXCJMb2NhdGlvbiBBXCJcbiAqICAgICAgIH0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgICAgIFwibmFtZVwiOiBcIkxvY2F0aW9uIEJcIlxuICogICAgICAgfSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuODMzLCAzOS4yODRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICAgICAgXCJuYW1lXCI6IFwiTG9jYXRpb24gQ1wiXG4gKiAgICAgICB9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS41MzQsIDM5LjEyM11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIGVudmVsb3BlZCA9IHR1cmYuZW52ZWxvcGUoZmMpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGZjLmZlYXR1cmVzLmNvbmNhdChlbnZlbG9wZWQpO1xuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgIHJldHVybiBiYm94UG9seWdvbihiYm94KGZlYXR1cmVzKSk7XG59O1xuIiwidmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgZWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaDtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIGEgZmVhdHVyZSBvciBzZXQgb2YgZmVhdHVyZXMgYW5kIHJldHVybnMgYWxsIHBvc2l0aW9ucyBhc1xuICoge0BsaW5rIFBvaW50fHBvaW50c30uXG4gKlxuICogQG5hbWUgZXhwbG9kZVxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGdlb2pzb24gaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPHBvaW50Pn0gcG9pbnRzIHJlcHJlc2VudGluZyB0aGUgZXhwbG9kZWQgaW5wdXQgZmVhdHVyZXNcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBpdCBlbmNvdW50ZXJzIGFuIHVua25vd24gZ2VvbWV0cnkgdHlwZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFsxNzcuNDM0NjkyLCAtMTcuNzc1MTddLFxuICogICAgICAgWzE3Ny40MDIwNzYsIC0xNy43NzkwOTNdLFxuICogICAgICAgWzE3Ny4zODA3OSwgLTE3LjgwMzkzN10sXG4gKiAgICAgICBbMTc3LjQwMjQyLCAtMTcuODI2MTY0XSxcbiAqICAgICAgIFsxNzcuNDM4NDY4LCAtMTcuODI0ODU3XSxcbiAqICAgICAgIFsxNzcuNDU0OTQ4LCAtMTcuNzk2NzQ2XSxcbiAqICAgICAgIFsxNzcuNDM0NjkyLCAtMTcuNzc1MTddXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5leHBsb2RlKHBvbHkpO1xuICpcbiAqIC8vPXBvbHlcbiAqXG4gKiAvLz1wb2ludHNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZ2VvanNvbikge1xuICAgIHZhciBwb2ludHMgPSBbXTtcbiAgICBlYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBwb2ludHMucHVzaChwb2ludChjb29yZCkpO1xuICAgIH0pO1xuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihwb2ludHMpO1xufTtcbiIsInZhciBjb29yZEVhY2ggPSByZXF1aXJlKCd0dXJmLW1ldGEnKS5jb29yZEVhY2g7XG5cbi8qKlxuICogVGFrZXMgaW5wdXQgZmVhdHVyZXMgYW5kIGZsaXBzIGFsbCBvZiB0aGVpciBjb29yZGluYXRlc1xuICogZnJvbSBgW3gsIHldYCB0byBgW3ksIHhdYC5cbiAqXG4gKiBAbmFtZSBmbGlwXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gaW5wdXQgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGEgZmVhdHVyZSBvciBzZXQgb2YgZmVhdHVyZXMgb2YgdGhlIHNhbWUgdHlwZSBhcyBgaW5wdXRgIHdpdGggZmxpcHBlZCBjb29yZGluYXRlc1xuICogQGV4YW1wbGVcbiAqIHZhciBzZXJiaWEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzIwLjU2NjQwNiwgNDMuNDIxMDA4XVxuICogICB9XG4gKiB9O1xuICpcbiAqIC8vPXNlcmJpYVxuICpcbiAqIHZhciBzYXVkaUFyYWJpYSA9IHR1cmYuZmxpcChzZXJiaWEpO1xuICpcbiAqIC8vPXNhdWRpQXJhYmlhXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZmxpcChpbnB1dCkge1xuICAgIC8vIGVuc3VyZSB0aGF0IHdlIGRvbid0IG1vZGlmeSBmZWF0dXJlcyBpbi1wbGFjZSBhbmQgY2hhbmdlcyB0byB0aGVcbiAgICAvLyBvdXRwdXQgZG8gbm90IGNoYW5nZSB0aGUgcHJldmlvdXMgZmVhdHVyZSwgaW5jbHVkaW5nIGNoYW5nZXMgdG8gbmVzdGVkXG4gICAgLy8gcHJvcGVydGllcy5cbiAgICBpbnB1dCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoaW5wdXQpKTtcblxuICAgIGNvb3JkRWFjaChpbnB1dCwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGNvb3JkLnJldmVyc2UoKTtcbiAgICB9KTtcbiAgICByZXR1cm4gaW5wdXQ7XG59O1xuIiwidmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1wb2ludCcpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBhIGNlbGwgZGVwdGggYW5kIHJldHVybnMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIHtAbGluayBQb2ludH0gZmVhdHVyZXMgaW4gYSBncmlkLlxuICpcbiAqIEBtb2R1bGUgdHVyZi9ncmlkXG4gKiBAY2F0ZWdvcnkgaW50ZXJwb2xhdGlvblxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBleHRlbnQgZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHBhcmFtIHtOdW1iZXJ9IGRlcHRoIGhvdyBtYW55IGNlbGxzIHRvIG91dHB1dFxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb259IGdyaWQgYXMgRmVhdHVyZUNvbGxlY3Rpb24gd2l0aCB7QGxpbmsgUG9pbnR9IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dGVudCA9IFstNzAuODIzMzY0LCAtMzMuNTUzOTg0LCAtNzAuNDczMTc1LCAtMzMuMzAyOTg2XTtcbiAqIHZhciBkZXB0aCA9IDEwO1xuICpcbiAqIHZhciBncmlkID0gdHVyZi5ncmlkKGV4dGVudCwgZGVwdGgpO1xuICpcbiAqIC8vPWdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihleHRlbnRzLCBkZXB0aCkge1xuICB2YXIgeG1pbiA9IGV4dGVudHNbMF07XG4gIHZhciB5bWluID0gZXh0ZW50c1sxXTtcbiAgdmFyIHhtYXggPSBleHRlbnRzWzJdO1xuICB2YXIgeW1heCA9IGV4dGVudHNbM107XG4gIHZhciBpbnRlcnZhbCA9ICh4bWF4IC0geG1pbikgLyBkZXB0aDtcbiAgdmFyIGNvb3JkcyA9IFtdO1xuICB2YXIgZmMgPSB7XG4gICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICBmZWF0dXJlczogW11cbiAgfTtcblxuICBmb3IgKHZhciB4PTA7IHg8PWRlcHRoOyB4Kyspe1xuICAgIGZvciAodmFyIHk9MDt5PD1kZXB0aDsgeSsrKXtcbiAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9pbnQoWyh4ICogaW50ZXJ2YWwpICsgeG1pbiwgKHkgKiBpbnRlcnZhbCkgKyB5bWluXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmM7XG59XG4iLCIvKipcbiAqIFdyYXBzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGluIGEgR2VvSlNPTiB7QGxpbmsgRmVhdHVyZX0uXG4gKlxuICogQG5hbWUgZmVhdHVyZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgaW5wdXQgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBnZW9tZXRyeSA9IHtcbiAqICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICAgNjcuNSxcbiAqICAgICAgICAzMi44NDI2NzM2MzE5NTQzMVxuICogICAgICBdXG4gKiAgICB9XG4gKlxuICogdmFyIGZlYXR1cmUgPSB0dXJmLmZlYXR1cmUoZ2VvbWV0cnkpO1xuICpcbiAqIC8vPWZlYXR1cmVcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZShnZW9tZXRyeSwgcHJvcGVydGllcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllcyB8fCB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb21ldHJ5XG4gICAgfTtcbn1cblxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZSA9IGZlYXR1cmU7XG5cbi8qKlxuICogVGFrZXMgY29vcmRpbmF0ZXMgYW5kIHByb3BlcnRpZXMgKG9wdGlvbmFsKSBhbmQgcmV0dXJucyBhIG5ldyB7QGxpbmsgUG9pbnR9IGZlYXR1cmUuXG4gKlxuICogQG5hbWUgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyW119IGNvb3JkaW5hdGVzIGxvbmdpdHVkZSwgbGF0aXR1ZGUgcG9zaXRpb24gKGVhY2ggaW4gZGVjaW1hbCBkZWdyZWVzKVxuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCB0aGF0IGlzIHVzZWQgYXMgdGhlIHtAbGluayBGZWF0dXJlfSdzXG4gKiBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wdDFcbiAqL1xubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nJyk7XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMuc2xpY2UoKVxuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5ncyBhbmQgb3B0aW9uYWxseSBhbiB7QGxpbmsgT2JqZWN0fSB3aXRoIHByb3BlcnRpZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZS5cbiAqXG4gKiBAbmFtZSBwb2x5Z29uXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZWFyUmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhIHByb3BlcnRpZXMgb2JqZWN0XG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gYSBQb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSB0aHJvdyBhbiBlcnJvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIHBvbHlnb24gaGFzIHRvbyBmZXcgcG9zaXRpb25zXG4gKiBvciBpZiBhIExpbmVhclJpbmcgb2YgdGhlIFBvbHlnb24gZG9lcyBub3QgaGF2ZSBtYXRjaGluZyBQb3NpdGlvbnMgYXQgdGhlXG4gKiBiZWdpbm5pbmcgJiBlbmQuXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tcbiAqICBbLTIuMjc1NTQzLCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ4OTI3MV0sXG4gKiAgWy0yLjIxNTExOCwgNTMuNDg5MjcxXSxcbiAqICBbLTIuMjE1MTE4LCA1My40NjQ1NDddLFxuICogIFstMi4yNzU1NDMsIDUzLjQ2NDU0N11cbiAqIF1dLCB7IG5hbWU6ICdwb2x5MScsIHBvcHVsYXRpb246IDQwMH0pO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqL1xubW9kdWxlLmV4cG9ydHMucG9seWdvbiA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuXG4gICAgaWYgKCFjb29yZGluYXRlcykgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHJpbmcgPSBjb29yZGluYXRlc1tpXTtcbiAgICAgICAgaWYgKHJpbmcubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLicpO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcmluZ1tyaW5nLmxlbmd0aCAtIDFdLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICBpZiAocmluZ1tyaW5nLmxlbmd0aCAtIDFdW2pdICE9PSByaW5nWzBdW2pdKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdGaXJzdCBhbmQgbGFzdCBQb3NpdGlvbiBhcmUgbm90IGVxdWl2YWxlbnQuJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBsaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb3NpdGlvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gYSBMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmVzdHJpbmcxID0gdHVyZi5saW5lU3RyaW5nKFtcbiAqXHRbLTIxLjk2NDQxNiwgNjQuMTQ4MjAzXSxcbiAqXHRbLTIxLjk1NjE3NiwgNjQuMTQxMzE2XSxcbiAqXHRbLTIxLjkzOTAxLCA2NC4xMzU5MjRdLFxuICpcdFstMjEuOTI3MzM3LCA2NC4xMzY2NzNdXG4gKiBdKTtcbiAqIHZhciBsaW5lc3RyaW5nMiA9IHR1cmYubGluZVN0cmluZyhbXG4gKlx0Wy0yMS45MjkwNTQsIDY0LjEyNzk4NV0sXG4gKlx0Wy0yMS45MTI5MTgsIDY0LjEzNDcyNl0sXG4gKlx0Wy0yMS45MTYwMDcsIDY0LjE0MTAxNl0sXG4gKiBcdFstMjEuOTMwMDg0LCA2NC4xNDQ0Nl1cbiAqIF0sIHtuYW1lOiAnbGluZSAxJywgZGlzdGFuY2U6IDE0NX0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKlxuICogLy89bGluZXN0cmluZzJcbiAqL1xubW9kdWxlLmV4cG9ydHMubGluZVN0cmluZyA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBUYWtlcyBvbmUgb3IgbW9yZSB7QGxpbmsgRmVhdHVyZXxGZWF0dXJlc30gYW5kIGNyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259LlxuICpcbiAqIEBuYW1lIGZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmVbXX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbn0gYSBGZWF0dXJlQ29sbGVjdGlvbiBvZiBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IFtcbiAqICB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdLCB7bmFtZTogJ0xvY2F0aW9uIEEnfSksXG4gKiAgdHVyZi5wb2ludChbLTc1LjgzMywgMzkuMjg0XSwge25hbWU6ICdMb2NhdGlvbiBCJ30pLFxuICogIHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10sIHtuYW1lOiAnTG9jYXRpb24gQyd9KVxuICogXTtcbiAqXG4gKiB2YXIgZmMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAqXG4gKiAvLz1mY1xuICovXG5tb2R1bGUuZXhwb3J0cy5mZWF0dXJlQ29sbGVjdGlvbiA9IGZ1bmN0aW9uIChmZWF0dXJlcykge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICAgIH07XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpTGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIExpbmVTdHJpbmdzXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYSBNdWx0aUxpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlMaW5lID0gdHVyZi5tdWx0aUxpbmVTdHJpbmcoW1tbMCwwXSxbMTAsMTBdXV0pO1xuICpcbiAqIC8vPW11bHRpTGluZVxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGlMaW5lU3RyaW5nID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdNdWx0aUxpbmVTdHJpbmcnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9pbnQ+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9pbnQ+fSBhIE11bHRpUG9pbnQgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQdCA9IHR1cmYubXVsdGlQb2ludChbWzAsMF0sWzEwLDEwXV0pO1xuICpcbiAqIC8vPW11bHRpUHRcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLm11bHRpUG9pbnQgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2x5Z29uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aVBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbnNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aVBvbHlnb24+fSBhIG11bHRpcG9seWdvbiBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbW1tbMCwwXSxbMCwxMF0sWzEwLDEwXSxbMTAsMF0sWzAsMF1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aVBvbHlnb24gPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8e0dlb21ldHJ5fT59IGdlb21ldHJpZXMgYW4gYXJyYXkgb2YgR2VvSlNPTiBHZW9tZXRyaWVzXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYSBnZW9tZXRyeWNvbGxlY3Rpb24gZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAwLCAwXVxuICogICAgIH07XG4gKiB2YXIgbGluZSA9IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbIFsxMDEsIDBdLCBbMTAyLCAxXSBdXG4gKiAgIH07XG4gKiB2YXIgY29sbGVjdGlvbiA9IHR1cmYuZ2VvbWV0cnljb2xsZWN0aW9uKFtbMCwwXSxbMTAsMTBdXSk7XG4gKlxuICogLy89Y29sbGVjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeUNvbGxlY3Rpb24gPSBmdW5jdGlvbiAoZ2VvbWV0cmllcywgcHJvcGVydGllcykge1xuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbnZhciBmYWN0b3JzID0ge1xuICAgIG1pbGVzOiAzOTYwLFxuICAgIG5hdXRpY2FsbWlsZXM6IDM0NDEuMTQ1LFxuICAgIGRlZ3JlZXM6IDU3LjI5NTc3OTUsXG4gICAgcmFkaWFuczogMSxcbiAgICBpbmNoZXM6IDI1MDkwNTYwMCxcbiAgICB5YXJkczogNjk2OTYwMCxcbiAgICBtZXRlcnM6IDYzNzMwMDAsXG4gICAgbWV0cmVzOiA2MzczMDAwLFxuICAgIGtpbG9tZXRlcnM6IDYzNzMsXG4gICAga2lsb21ldHJlczogNjM3M1xufTtcblxuLypcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCBmcm9tIHJhZGlhbnMgdG8gYSBtb3JlIGZyaWVuZGx5IHVuaXQuXG4gKlxuICogQG5hbWUgcmFkaWFuc1RvRGlzdGFuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByYWRpYW5zIGFjcm9zcyB0aGUgc3BoZXJlXG4gKiBAcGFyYW0ge3N0cmluZz1raWxvbWV0ZXJzfSB1bml0czogb25lIG9mIG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBkZWdyZWVzLCByYWRpYW5zLFxuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5tb2R1bGUuZXhwb3J0cy5yYWRpYW5zVG9EaXN0YW5jZSA9IGZ1bmN0aW9uIChyYWRpYW5zLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiByYWRpYW5zICogZmFjdG9yO1xufTtcblxuLypcbiAqIENvbnZlcnQgYSBkaXN0YW5jZSBtZWFzdXJlbWVudCBmcm9tIGEgcmVhbC13b3JsZCB1bml0IGludG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRpc3RhbmNlVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmc9a2lsb21ldGVyc30gdW5pdHM6IG9uZSBvZiBtaWxlcywgbmF1dGljYWxtaWxlcywgZGVncmVlcywgcmFkaWFucyxcbiAqIGluY2hlcywgeWFyZHMsIG1ldHJlcywgbWV0ZXJzLCBraWxvbWV0cmVzLCBraWxvbWV0ZXJzLlxuICogQHJldHVybnMge251bWJlcn0gcmFkaWFuc1xuICovXG5tb2R1bGUuZXhwb3J0cy5kaXN0YW5jZVRvUmFkaWFucyA9IGZ1bmN0aW9uIChkaXN0YW5jZSwgdW5pdHMpIHtcbiAgICB2YXIgZmFjdG9yID0gZmFjdG9yc1t1bml0cyB8fCAna2lsb21ldGVycyddO1xuICAgIGlmIChmYWN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgdW5pdCcpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byBkZWdyZWVzXG4gKlxuICogQG5hbWUgZGlzdGFuY2VUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZz1raWxvbWV0ZXJzfSB1bml0czogb25lIG9mIG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBkZWdyZWVzLCByYWRpYW5zLFxuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkZWdyZWVzXG4gKi9cbm1vZHVsZS5leHBvcnRzLmRpc3RhbmNlVG9EZWdyZWVzID0gZnVuY3Rpb24gKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoZGlzdGFuY2UgLyBmYWN0b3IpICogNTcuMjk1ODtcbn07XG4iLCJ2YXIgcG9pbnQgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2ludDtcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcbnZhciBmZWF0dXJlY29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vL1ByZWNvbXB1dGUgY29zaW5lcyBhbmQgc2luZXMgb2YgYW5nbGVzIHVzZWQgaW4gaGV4YWdvbiBjcmVhdGlvblxuLy8gZm9yIHBlcmZvcm1hbmNlIGdhaW5cbnZhciBjb3NpbmVzID0gW107XG52YXIgc2luZXMgPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgdmFyIGFuZ2xlID0gMiAqIE1hdGguUEkgLyA2ICogaTtcbiAgICBjb3NpbmVzLnB1c2goTWF0aC5jb3MoYW5nbGUpKTtcbiAgICBzaW5lcy5wdXNoKE1hdGguc2luKGFuZ2xlKSk7XG59XG5cbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGEgY2VsbCBzaXplIGluIGRlZ3JlZXMgYW5kIHJldHVybnMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIGZsYXQtdG9wcGVkXG4gKiBoZXhhZ29ucyAoe0BsaW5rIFBvbHlnb259IGZlYXR1cmVzKSBhbGlnbmVkIGluIGFuIFwib2RkLXFcIiB2ZXJ0aWNhbCBncmlkIGFzXG4gKiBkZXNjcmliZWQgaW4gW0hleGFnb25hbCBHcmlkc10oaHR0cDovL3d3dy5yZWRibG9iZ2FtZXMuY29tL2dyaWRzL2hleGFnb25zLykuXG4gKlxuICogQG5hbWUgaGV4R3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGJvdW5kaW5nIGJveCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSBkaW1lbnNpb24gb2YgY2VsbCBpbiBzcGVjaWZpZWQgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0cyB1c2VkIGluIGNhbGN1bGF0aW5nIGNlbGxXaWR0aCAoJ21pbGVzJyBvciAna2lsb21ldGVycycpXG4gKiBAcGFyYW0ge2Jvb2xlYW59IHRyaWFuZ2xlcyB3aGV0aGVyIHRvIHJldHVybiBhcyB0cmlhbmdsZXMgaW5zdGVhZCBvZiBoZXhhZ29uc1xuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGEgaGV4YWdvbmFsIGdyaWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgYmJveCA9IFstOTYsMzEsLTg0LDQwXTtcbiAqIHZhciBjZWxsV2lkdGggPSA1MDtcbiAqIHZhciB1bml0cyA9ICdtaWxlcyc7XG4gKlxuICogdmFyIGhleGdyaWQgPSB0dXJmLmhleEdyaWQoYmJveCwgY2VsbFdpZHRoLCB1bml0cyk7XG4gKlxuICogLy89aGV4Z3JpZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhleEdyaWQoYmJveCwgY2VsbFNpemUsIHVuaXRzLCB0cmlhbmdsZXMpIHtcbiAgICB2YXIgeEZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMl0sIGJib3hbMV1dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbFdpZHRoID0geEZyYWN0aW9uICogKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMF0sIGJib3hbM11dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IHlGcmFjdGlvbiAqIChiYm94WzNdIC0gYmJveFsxXSk7XG4gICAgdmFyIHJhZGl1cyA9IGNlbGxXaWR0aCAvIDI7XG5cbiAgICB2YXIgaGV4X3dpZHRoID0gcmFkaXVzICogMjtcbiAgICB2YXIgaGV4X2hlaWdodCA9IE1hdGguc3FydCgzKSAvIDIgKiBjZWxsSGVpZ2h0O1xuXG4gICAgdmFyIGJveF93aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgIHZhciBib3hfaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG5cbiAgICB2YXIgeF9pbnRlcnZhbCA9IDMgLyA0ICogaGV4X3dpZHRoO1xuICAgIHZhciB5X2ludGVydmFsID0gaGV4X2hlaWdodDtcblxuICAgIHZhciB4X3NwYW4gPSBib3hfd2lkdGggLyAoaGV4X3dpZHRoIC0gcmFkaXVzIC8gMik7XG4gICAgdmFyIHhfY291bnQgPSBNYXRoLmNlaWwoeF9zcGFuKTtcbiAgICBpZiAoTWF0aC5yb3VuZCh4X3NwYW4pID09PSB4X2NvdW50KSB7XG4gICAgICAgIHhfY291bnQrKztcbiAgICB9XG5cbiAgICB2YXIgeF9hZGp1c3QgPSAoKHhfY291bnQgKiB4X2ludGVydmFsIC0gcmFkaXVzIC8gMikgLSBib3hfd2lkdGgpIC8gMiAtIHJhZGl1cyAvIDI7XG5cbiAgICB2YXIgeV9jb3VudCA9IE1hdGguY2VpbChib3hfaGVpZ2h0IC8gaGV4X2hlaWdodCk7XG5cbiAgICB2YXIgeV9hZGp1c3QgPSAoYm94X2hlaWdodCAtIHlfY291bnQgKiBoZXhfaGVpZ2h0KSAvIDI7XG5cbiAgICB2YXIgaGFzT2Zmc2V0WSA9IHlfY291bnQgKiBoZXhfaGVpZ2h0IC0gYm94X2hlaWdodCA+IGhleF9oZWlnaHQgLyAyO1xuICAgIGlmIChoYXNPZmZzZXRZKSB7XG4gICAgICAgIHlfYWRqdXN0IC09IGhleF9oZWlnaHQgLyA0O1xuICAgIH1cblxuICAgIHZhciBmYyA9IGZlYXR1cmVjb2xsZWN0aW9uKFtdKTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IHhfY291bnQ7IHgrKykge1xuICAgICAgICBmb3IgKHZhciB5ID0gMDsgeSA8PSB5X2NvdW50OyB5KyspIHtcblxuICAgICAgICAgICAgdmFyIGlzT2RkID0geCAlIDIgPT09IDE7XG4gICAgICAgICAgICBpZiAoeSA9PT0gMCAmJiBpc09kZCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoeSA9PT0gMCAmJiBoYXNPZmZzZXRZKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHZhciBjZW50ZXJfeCA9IHggKiB4X2ludGVydmFsICsgYmJveFswXSAtIHhfYWRqdXN0O1xuICAgICAgICAgICAgdmFyIGNlbnRlcl95ID0geSAqIHlfaW50ZXJ2YWwgKyBiYm94WzFdICsgeV9hZGp1c3Q7XG5cbiAgICAgICAgICAgIGlmIChpc09kZCkge1xuICAgICAgICAgICAgICAgIGNlbnRlcl95IC09IGhleF9oZWlnaHQgLyAyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHRyaWFuZ2xlcykge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2guYXBwbHkoZmMuZmVhdHVyZXMsIGhleFRyaWFuZ2xlcyhbY2VudGVyX3gsIGNlbnRlcl95XSwgY2VsbFdpZHRoIC8gMiwgY2VsbEhlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChoZXhhZ29uKFtjZW50ZXJfeCwgY2VudGVyX3ldLCBjZWxsV2lkdGggLyAyLCBjZWxsSGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGZjO1xufTtcblxuLy9DZW50ZXIgc2hvdWxkIGJlIFt4LCB5XVxuZnVuY3Rpb24gaGV4YWdvbihjZW50ZXIsIHJ4LCByeSkge1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG4gICAgICAgIHZhciB4ID0gY2VudGVyWzBdICsgcnggKiBjb3NpbmVzW2ldO1xuICAgICAgICB2YXIgeSA9IGNlbnRlclsxXSArIHJ5ICogc2luZXNbaV07XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW3gsIHldKTtcbiAgICB9XG4gICAgLy9maXJzdCBhbmQgbGFzdCB2ZXJ0ZXggbXVzdCBiZSB0aGUgc2FtZVxuICAgIHZlcnRpY2VzLnB1c2godmVydGljZXNbMF0pO1xuICAgIHJldHVybiBwb2x5Z29uKFt2ZXJ0aWNlc10pO1xufVxuXG4vL0NlbnRlciBzaG91bGQgYmUgW3gsIHldXG5mdW5jdGlvbiBoZXhUcmlhbmdsZXMoY2VudGVyLCByeCwgcnkpIHtcbiAgICB2YXIgdHJpYW5nbGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgICAgIHZlcnRpY2VzLnB1c2goY2VudGVyKTtcbiAgICAgICAgdmVydGljZXMucHVzaChbXG4gICAgICAgICAgICBjZW50ZXJbMF0gKyByeCAqIGNvc2luZXNbaV0sXG4gICAgICAgICAgICBjZW50ZXJbMV0gKyByeSAqIHNpbmVzW2ldXG4gICAgICAgIF0pO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgIGNlbnRlclswXSArIHJ4ICogY29zaW5lc1soaSArIDEpICUgNl0sXG4gICAgICAgICAgICBjZW50ZXJbMV0gKyByeSAqIHNpbmVzWyhpICsgMSkgJSA2XVxuICAgICAgICBdKTtcbiAgICAgICAgdmVydGljZXMucHVzaChjZW50ZXIpO1xuICAgICAgICB0cmlhbmdsZXMucHVzaChwb2x5Z29uKFt2ZXJ0aWNlc10pKTtcbiAgICB9XG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cbiIsInZhciBpbnZhcmlhbnQgPSByZXF1aXJlKCd0dXJmLWludmFyaWFudCcpO1xuXG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0V2ZW4lRTIlODAlOTNvZGRfcnVsZVxuLy8gbW9kaWZpZWQgZnJvbTogaHR0cHM6Ly9naXRodWIuY29tL3N1YnN0YWNrL3BvaW50LWluLXBvbHlnb24vYmxvYi9tYXN0ZXIvaW5kZXguanNcbi8vIHdoaWNoIHdhcyBtb2RpZmllZCBmcm9tIGh0dHA6Ly93d3cuZWNzZS5ycGkuZWR1L0hvbWVwYWdlcy93cmYvUmVzZWFyY2gvU2hvcnRfTm90ZXMvcG5wb2x5Lmh0bWxcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGEge0BsaW5rIFBvbHlnb259IG9yIHtAbGluayBNdWx0aVBvbHlnb259IGFuZCBkZXRlcm1pbmVzIGlmIHRoZSBwb2ludCByZXNpZGVzIGluc2lkZSB0aGUgcG9seWdvbi4gVGhlIHBvbHlnb24gY2FuXG4gKiBiZSBjb252ZXggb3IgY29uY2F2ZS4gVGhlIGZ1bmN0aW9uIGFjY291bnRzIGZvciBob2xlcy5cbiAqXG4gKiBAbmFtZSBpbnNpZGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHBvaW50IGlucHV0IHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8KFBvbHlnb258TXVsdGlQb2x5Z29uKT59IHBvbHlnb24gaW5wdXQgcG9seWdvbiBvciBtdWx0aXBvbHlnb25cbiAqIEByZXR1cm4ge0Jvb2xlYW59IGB0cnVlYCBpZiB0aGUgUG9pbnQgaXMgaW5zaWRlIHRoZSBQb2x5Z29uOyBgZmFsc2VgIGlmIHRoZSBQb2ludCBpcyBub3QgaW5zaWRlIHRoZSBQb2x5Z29uXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6IFwiI2YwMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTExMS40NjcyODUsIDQwLjc1NzY2XVxuICogICB9XG4gKiB9O1xuICogdmFyIHB0MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTExMS44NzM3NzksIDQwLjY0NzMwM11cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstMTEyLjA3NDI3OSwgNDAuNTIyMTVdLFxuICogICAgICAgWy0xMTIuMDc0Mjc5LCA0MC44NTMyOTNdLFxuICogICAgICAgWy0xMTEuNjEwMTA3LCA0MC44NTMyOTNdLFxuICogICAgICAgWy0xMTEuNjEwMTA3LCA0MC41MjIxNV0sXG4gKiAgICAgICBbLTExMi4wNzQyNzksIDQwLjUyMjE1XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwdDEsIHB0MiwgcG9seV1cbiAqIH07XG4gKlxuICogLy89ZmVhdHVyZXNcbiAqXG4gKiB2YXIgaXNJbnNpZGUxID0gdHVyZi5pbnNpZGUocHQxLCBwb2x5KTtcbiAqIC8vPWlzSW5zaWRlMVxuICpcbiAqIHZhciBpc0luc2lkZTIgPSB0dXJmLmluc2lkZShwdDIsIHBvbHkpO1xuICogLy89aXNJbnNpZGUyXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5wdXQocG9pbnQsIHBvbHlnb24pIHtcbiAgICB2YXIgcHQgPSBpbnZhcmlhbnQuZ2V0Q29vcmQocG9pbnQpO1xuICAgIHZhciBwb2x5cyA9IHBvbHlnb24uZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgLy8gbm9ybWFsaXplIHRvIG11bHRpcG9seWdvblxuICAgIGlmIChwb2x5Z29uLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykgcG9seXMgPSBbcG9seXNdO1xuXG4gICAgZm9yICh2YXIgaSA9IDAsIGluc2lkZVBvbHkgPSBmYWxzZTsgaSA8IHBvbHlzLmxlbmd0aCAmJiAhaW5zaWRlUG9seTsgaSsrKSB7XG4gICAgICAgIC8vIGNoZWNrIGlmIGl0IGlzIGluIHRoZSBvdXRlciByaW5nIGZpcnN0XG4gICAgICAgIGlmIChpblJpbmcocHQsIHBvbHlzW2ldWzBdKSkge1xuICAgICAgICAgICAgdmFyIGluSG9sZSA9IGZhbHNlO1xuICAgICAgICAgICAgdmFyIGsgPSAxO1xuICAgICAgICAgICAgLy8gY2hlY2sgZm9yIHRoZSBwb2ludCBpbiBhbnkgb2YgdGhlIGhvbGVzXG4gICAgICAgICAgICB3aGlsZSAoayA8IHBvbHlzW2ldLmxlbmd0aCAmJiAhaW5Ib2xlKSB7XG4gICAgICAgICAgICAgICAgaWYgKGluUmluZyhwdCwgcG9seXNbaV1ba10pKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5Ib2xlKSBpbnNpZGVQb2x5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gaW5zaWRlUG9seTtcbn07XG5cbi8vIHB0IGlzIFt4LHldIGFuZCByaW5nIGlzIFtbeCx5XSwgW3gseV0sLi5dXG5mdW5jdGlvbiBpblJpbmcocHQsIHJpbmcpIHtcbiAgICB2YXIgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHJpbmdbaV1bMF0sIHlpID0gcmluZ1tpXVsxXTtcbiAgICAgICAgdmFyIHhqID0gcmluZ1tqXVswXSwgeWogPSByaW5nW2pdWzFdO1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gKCh5aSA+IHB0WzFdKSAhPT0gKHlqID4gcHRbMV0pKSAmJlxuICAgICAgICAocHRbMF0gPCAoeGogLSB4aSkgKiAocHRbMV0gLSB5aSkgLyAoeWogLSB5aSkgKyB4aSk7XG4gICAgICAgIGlmIChpbnRlcnNlY3QpIGlzSW5zaWRlID0gIWlzSW5zaWRlO1xuICAgIH1cbiAgICByZXR1cm4gaXNJbnNpZGU7XG59XG4iLCIvLyBkZXBlbmQgb24ganN0cyBmb3Igbm93IGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvb3ZlcmxheS5odG1sXG52YXIganN0cyA9IHJlcXVpcmUoJ2pzdHMnKTtcblxuLyoqXG4gKiBUYWtlcyB0d28ge0BsaW5rIFBvbHlnb258cG9seWdvbnN9IGFuZCBmaW5kcyB0aGVpciBpbnRlcnNlY3Rpb24uIElmIHRoZXkgc2hhcmUgYSBib3JkZXIsIHJldHVybnMgdGhlIGJvcmRlcjsgaWYgdGhleSBkb24ndCBpbnRlcnNlY3QsIHJldHVybnMgdW5kZWZpbmVkLlxuICpcbiAqIEBuYW1lIGludGVyc2VjdFxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5MSB0aGUgZmlyc3QgcG9seWdvblxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5MiB0aGUgc2Vjb25kIHBvbHlnb25cbiAqIEByZXR1cm4geyhGZWF0dXJlPFBvbHlnb24+fHVuZGVmaW5lZHxGZWF0dXJlPE11bHRpTGluZVN0cmluZz4pfSBpZiBgcG9seTFgIGFuZCBgcG9seTJgIG92ZXJsYXAsIHJldHVybnMgYSBQb2x5Z29uIGZlYXR1cmUgcmVwcmVzZW50aW5nIHRoZSBhcmVhIHRoZXkgb3ZlcmxhcDsgaWYgYHBvbHkxYCBhbmQgYHBvbHkyYCBkbyBub3Qgb3ZlcmxhcCwgcmV0dXJucyBgdW5kZWZpbmVkYDsgaWYgYHBvbHkxYCBhbmQgYHBvbHkyYCBzaGFyZSBhIGJvcmRlciwgYSBNdWx0aUxpbmVTdHJpbmcgb2YgdGhlIGxvY2F0aW9ucyB3aGVyZSB0aGVpciBib3JkZXJzIGFyZSBzaGFyZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImZpbGxcIjogXCIjMGYwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstMTIyLjgwMTc0MiwgNDUuNDg1NjVdLFxuICogICAgICAgWy0xMjIuODAxNzQyLCA0NS42MDQ5MV0sXG4gKiAgICAgICBbLTEyMi41ODQ3NjIsIDQ1LjYwNDkxXSxcbiAqICAgICAgIFstMTIyLjU4NDc2MiwgNDUuNDg1NjVdLFxuICogICAgICAgWy0xMjIuODAxNzQyLCA0NS40ODU2NV1cbiAqICAgICBdXVxuICogICB9XG4gKiB9XG4gKiB2YXIgcG9seTIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImZpbGxcIjogXCIjMDBmXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstMTIyLjUyMDIxNywgNDUuNTM1NjkzXSxcbiAqICAgICAgIFstMTIyLjY0MDM4LCA0NS41NTM5NjddLFxuICogICAgICAgWy0xMjIuNzIwMDMxLCA0NS41MjY1NTRdLFxuICogICAgICAgWy0xMjIuNjY5OTA2LCA0NS41MDczMDldLFxuICogICAgICAgWy0xMjIuNzIzNDY0LCA0NS40NDY2NDNdLFxuICogICAgICAgWy0xMjIuNTMyNTc3LCA0NS40MDg1NzRdLFxuICogICAgICAgWy0xMjIuNDg3MjU4LCA0NS40Nzc0NjZdLFxuICogICAgICAgWy0xMjIuNTIwMjE3LCA0NS41MzU2OTNdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfVxuICpcbiAqIHZhciBwb2x5Z29ucyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seTEsIHBvbHkyXVxuICogfTtcbiAqXG4gKiB2YXIgaW50ZXJzZWN0aW9uID0gdHVyZi5pbnRlcnNlY3QocG9seTEsIHBvbHkyKTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICpcbiAqIC8vPWludGVyc2VjdGlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGludGVyc2VjdChwb2x5MSwgcG9seTIpIHtcbiAgICB2YXIgZ2VvbTEsIGdlb20yO1xuICAgIGlmIChwb2x5MS50eXBlID09PSAnRmVhdHVyZScpIGdlb20xID0gcG9seTEuZ2VvbWV0cnk7XG4gICAgZWxzZSBnZW9tMSA9IHBvbHkxO1xuICAgIGlmIChwb2x5Mi50eXBlID09PSAnRmVhdHVyZScpIGdlb20yID0gcG9seTIuZ2VvbWV0cnk7XG4gICAgZWxzZSBnZW9tMiA9IHBvbHkyO1xuICAgIHZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG4gICAgdmFyIGEgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShnZW9tMSkpO1xuICAgIHZhciBiID0gcmVhZGVyLnJlYWQoSlNPTi5zdHJpbmdpZnkoZ2VvbTIpKTtcbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYS5pbnRlcnNlY3Rpb24oYik7XG5cbiAgICBpZiAoaW50ZXJzZWN0aW9uLmlzRW1wdHkoKSkge1xuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIHZhciB3cml0ZXIgPSBuZXcganN0cy5pby5HZW9KU09OV3JpdGVyKCk7XG5cbiAgICB2YXIgZ2VvanNvbkdlb21ldHJ5ID0gd3JpdGVyLndyaXRlKGludGVyc2VjdGlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fSxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb2pzb25HZW9tZXRyeVxuICAgIH07XG59O1xuIiwiLyoqXG4gKiBVbndyYXAgYSBjb29yZGluYXRlIGZyb20gYSBGZWF0dXJlIHdpdGggYSBQb2ludCBnZW9tZXRyeSwgYSBQb2ludFxuICogZ2VvbWV0cnksIG9yIGEgc2luZ2xlIGNvb3JkaW5hdGUuXG4gKlxuICogQHBhcmFtIHsqfSBvYmogYW55IHZhbHVlXG4gKiBAcmV0dXJucyB7QXJyYXk8bnVtYmVyPn0gYSBjb29yZGluYXRlXG4gKi9cbmZ1bmN0aW9uIGdldENvb3JkKG9iaikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG9iaikgJiZcbiAgICAgICAgdHlwZW9mIG9ialswXSA9PT0gJ251bWJlcicgJiZcbiAgICAgICAgdHlwZW9mIG9ialsxXSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9IGVsc2UgaWYgKG9iaikge1xuICAgICAgICBpZiAob2JqLnR5cGUgPT09ICdGZWF0dXJlJyAmJlxuICAgICAgICAgICAgb2JqLmdlb21ldHJ5ICYmXG4gICAgICAgICAgICBvYmouZ2VvbWV0cnkudHlwZSA9PT0gJ1BvaW50JyAmJlxuICAgICAgICAgICAgQXJyYXkuaXNBcnJheShvYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXMpKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICB9IGVsc2UgaWYgKG9iai50eXBlID09PSAnUG9pbnQnICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG9iai5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouY29vcmRpbmF0ZXM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdBIGNvb3JkaW5hdGUsIGZlYXR1cmUsIG9yIHBvaW50IGdlb21ldHJ5IGlzIHJlcXVpcmVkJyk7XG59XG5cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2YgR2VvSlNPTiBvYmplY3RzIGZvciBUdXJmLlxuICpcbiAqIEBhbGlhcyBnZW9qc29uVHlwZVxuICogQHBhcmFtIHtHZW9KU09OfSB2YWx1ZSBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgbmFtZSBvZiBjYWxsaW5nIGZ1bmN0aW9uXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxuICovXG5mdW5jdGlvbiBnZW9qc29uVHlwZSh2YWx1ZSwgdHlwZSwgbmFtZSkge1xuICAgIGlmICghdHlwZSB8fCAhbmFtZSkgdGhyb3cgbmV3IEVycm9yKCd0eXBlIGFuZCBuYW1lIHJlcXVpcmVkJyk7XG5cbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJzogbXVzdCBiZSBhICcgKyB0eXBlICsgJywgZ2l2ZW4gJyArIHZhbHVlLnR5cGUpO1xuICAgIH1cbn1cblxuLyoqXG4gKiBFbmZvcmNlIGV4cGVjdGF0aW9ucyBhYm91dCB0eXBlcyBvZiB7QGxpbmsgRmVhdHVyZX0gaW5wdXRzIGZvciBUdXJmLlxuICogSW50ZXJuYWxseSB0aGlzIHVzZXMge0BsaW5rIGdlb2pzb25UeXBlfSB0byBqdWRnZSBnZW9tZXRyeSB0eXBlcy5cbiAqXG4gKiBAYWxpYXMgZmVhdHVyZU9mXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgYSBmZWF0dXJlIHdpdGggYW4gZXhwZWN0ZWQgZ2VvbWV0cnkgdHlwZVxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBlcnJvciBpZiB2YWx1ZSBpcyBub3QgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVPZihmZWF0dXJlLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJy5mZWF0dXJlT2YoKSByZXF1aXJlcyBhIG5hbWUnKTtcbiAgICBpZiAoIWZlYXR1cmUgfHwgZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJywgRmVhdHVyZSB3aXRoIGdlb21ldHJ5IHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJzogbXVzdCBiZSBhICcgKyB0eXBlICsgJywgZ2l2ZW4gJyArIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gaW5wdXRzIGZvciBUdXJmLlxuICogSW50ZXJuYWxseSB0aGlzIHVzZXMge0BsaW5rIGdlb2pzb25UeXBlfSB0byBqdWRnZSBnZW9tZXRyeSB0eXBlcy5cbiAqXG4gKiBAYWxpYXMgY29sbGVjdGlvbk9mXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufSBmZWF0dXJlY29sbGVjdGlvbiBhIGZlYXR1cmVjb2xsZWN0aW9uIGZvciB3aGljaCBmZWF0dXJlcyB3aWxsIGJlIGp1ZGdlZFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB2YWx1ZSBpcyBub3QgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGNvbGxlY3Rpb25PZihmZWF0dXJlY29sbGVjdGlvbiwgdHlwZSwgbmFtZSkge1xuICAgIGlmICghbmFtZSkgdGhyb3cgbmV3IEVycm9yKCcuY29sbGVjdGlvbk9mKCkgcmVxdWlyZXMgYSBuYW1lJyk7XG4gICAgaWYgKCFmZWF0dXJlY29sbGVjdGlvbiB8fCBmZWF0dXJlY29sbGVjdGlvbi50eXBlICE9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICcsIEZlYXR1cmVDb2xsZWN0aW9uIHJlcXVpcmVkJyk7XG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZmVhdHVyZWNvbGxlY3Rpb24uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBmZWF0dXJlY29sbGVjdGlvbi5mZWF0dXJlc1tpXTtcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gJ0ZlYXR1cmUnIHx8ICFmZWF0dXJlLmdlb21ldHJ5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnLCBGZWF0dXJlIHdpdGggZ2VvbWV0cnkgcmVxdWlyZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnOiBtdXN0IGJlIGEgJyArIHR5cGUgKyAnLCBnaXZlbiAnICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuZ2VvanNvblR5cGUgPSBnZW9qc29uVHlwZTtcbm1vZHVsZS5leHBvcnRzLmNvbGxlY3Rpb25PZiA9IGNvbGxlY3Rpb25PZjtcbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVPZiA9IGZlYXR1cmVPZjtcbm1vZHVsZS5leHBvcnRzLmdldENvb3JkID0gZ2V0Q29vcmQ7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAyMDEwLCBKYXNvbiBEYXZpZXMuXG4gKlxuICogQWxsIHJpZ2h0cyByZXNlcnZlZC4gIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBCcmFkbGV5IFdoaXRlJ3MgSmF2YSB2ZXJzaW9uLFxuICogd2hpY2ggaXMgaW4gdHVybiBiYXNlZCBvbiBOaWNob2xhcyBZdWUncyBDKysgdmVyc2lvbiwgd2hpY2ggaW4gdHVybiBpcyBiYXNlZFxuICogb24gUGF1bCBELiBCb3Vya2UncyBvcmlnaW5hbCBGb3J0cmFuIHZlcnNpb24uICBTZWUgYmVsb3cgZm9yIHRoZSByZXNwZWN0aXZlXG4gKiBjb3B5cmlnaHQgbm90aWNlcy5cbiAqXG4gKiBTZWUgaHR0cDovL2xvY2FsLndhc3AudXdhLmVkdS5hdS9+cGJvdXJrZS9wYXBlcnMvY29ucmVjLyBmb3IgdGhlIG9yaWdpbmFsXG4gKiBwYXBlciBieSBQYXVsIEQuIEJvdXJrZS5cbiAqXG4gKiBUaGUgdmVjdG9yIGNvbnZlcnNpb24gY29kZSBpcyBiYXNlZCBvbiBodHRwOi8vYXBwdHJlZS5uZXQvY29ucmVjLmh0bSBieVxuICogR3JhaGFtIENveC5cbiAqXG4gKiBSZWRpc3RyaWJ1dGlvbiBhbmQgdXNlIGluIHNvdXJjZSBhbmQgYmluYXJ5IGZvcm1zLCB3aXRoIG9yIHdpdGhvdXRcbiAqIG1vZGlmaWNhdGlvbiwgYXJlIHBlcm1pdHRlZCBwcm92aWRlZCB0aGF0IHRoZSBmb2xsb3dpbmcgY29uZGl0aW9ucyBhcmUgbWV0OlxuICogICAgICogUmVkaXN0cmlidXRpb25zIG9mIHNvdXJjZSBjb2RlIG11c3QgcmV0YWluIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lci5cbiAqICAgICAqIFJlZGlzdHJpYnV0aW9ucyBpbiBiaW5hcnkgZm9ybSBtdXN0IHJlcHJvZHVjZSB0aGUgYWJvdmUgY29weXJpZ2h0XG4gKiAgICAgICBub3RpY2UsIHRoaXMgbGlzdCBvZiBjb25kaXRpb25zIGFuZCB0aGUgZm9sbG93aW5nIGRpc2NsYWltZXIgaW4gdGhlXG4gKiAgICAgICBkb2N1bWVudGF0aW9uIGFuZC9vciBvdGhlciBtYXRlcmlhbHMgcHJvdmlkZWQgd2l0aCB0aGUgZGlzdHJpYnV0aW9uLlxuICogICAgICogTmVpdGhlciB0aGUgbmFtZSBvZiB0aGUgPG9yZ2FuaXphdGlvbj4gbm9yIHRoZVxuICogICAgICAgbmFtZXMgb2YgaXRzIGNvbnRyaWJ1dG9ycyBtYXkgYmUgdXNlZCB0byBlbmRvcnNlIG9yIHByb21vdGUgcHJvZHVjdHNcbiAqICAgICAgIGRlcml2ZWQgZnJvbSB0aGlzIHNvZnR3YXJlIHdpdGhvdXQgc3BlY2lmaWMgcHJpb3Igd3JpdHRlbiBwZXJtaXNzaW9uLlxuICpcbiAqIFRISVMgU09GVFdBUkUgSVMgUFJPVklERUQgQlkgVEhFIENPUFlSSUdIVCBIT0xERVJTIEFORCBDT05UUklCVVRPUlMgXCJBUyBJU1wiXG4gKiBBTkQgQU5ZIEVYUFJFU1MgT1IgSU1QTElFRCBXQVJSQU5USUVTLCBJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgVEhFXG4gKiBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZIEFORCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRVxuICogQVJFIERJU0NMQUlNRUQuIElOIE5PIEVWRU5UIFNIQUxMIDxDT1BZUklHSFQgSE9MREVSPiBCRSBMSUFCTEUgRk9SIEFOWVxuICogRElSRUNULCBJTkRJUkVDVCwgSU5DSURFTlRBTCwgU1BFQ0lBTCwgRVhFTVBMQVJZLCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVNcbiAqIChJTkNMVURJTkcsIEJVVCBOT1QgTElNSVRFRCBUTywgUFJPQ1VSRU1FTlQgT0YgU1VCU1RJVFVURSBHT09EUyBPUiBTRVJWSUNFUztcbiAqIExPU1MgT0YgVVNFLCBEQVRBLCBPUiBQUk9GSVRTOyBPUiBCVVNJTkVTUyBJTlRFUlJVUFRJT04pIEhPV0VWRVIgQ0FVU0VEIEFORFxuICogT04gQU5ZIFRIRU9SWSBPRiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQ09OVFJBQ1QsIFNUUklDVCBMSUFCSUxJVFksIE9SIFRPUlRcbiAqIChJTkNMVURJTkcgTkVHTElHRU5DRSBPUiBPVEhFUldJU0UpIEFSSVNJTkcgSU4gQU5ZIFdBWSBPVVQgT0YgVEhFIFVTRSBPRlxuICogVEhJUyBTT0ZUV0FSRSwgRVZFTiBJRiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqL1xuXG4vKlxuICogQ29weXJpZ2h0IChjKSAxOTk2LTE5OTcgTmljaG9sYXMgWXVlXG4gKlxuICogVGhpcyBzb2Z0d2FyZSBpcyBjb3B5cmlnaHRlZCBieSBOaWNob2xhcyBZdWUuIFRoaXMgY29kZSBpcyBiYXNlZCBvbiBQYXVsIEQuXG4gKiBCb3Vya2UncyBDT05SRUMuRiByb3V0aW5lLlxuICpcbiAqIFRoZSBhdXRob3JzIGhlcmVieSBncmFudCBwZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgYW5kIGRpc3RyaWJ1dGUgdGhpc1xuICogc29mdHdhcmUgYW5kIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbnkgcHVycG9zZSwgcHJvdmlkZWQgdGhhdCBleGlzdGluZ1xuICogY29weXJpZ2h0IG5vdGljZXMgYXJlIHJldGFpbmVkIGluIGFsbCBjb3BpZXMgYW5kIHRoYXQgdGhpcyBub3RpY2UgaXNcbiAqIGluY2x1ZGVkIHZlcmJhdGltIGluIGFueSBkaXN0cmlidXRpb25zLiBBZGRpdGlvbmFsbHksIHRoZSBhdXRob3JzIGdyYW50XG4gKiBwZXJtaXNzaW9uIHRvIG1vZGlmeSB0aGlzIHNvZnR3YXJlIGFuZCBpdHMgZG9jdW1lbnRhdGlvbiBmb3IgYW55IHB1cnBvc2UsXG4gKiBwcm92aWRlZCB0aGF0IHN1Y2ggbW9kaWZpY2F0aW9ucyBhcmUgbm90IGRpc3RyaWJ1dGVkIHdpdGhvdXQgdGhlIGV4cGxpY2l0XG4gKiBjb25zZW50IG9mIHRoZSBhdXRob3JzIGFuZCB0aGF0IGV4aXN0aW5nIGNvcHlyaWdodCBub3RpY2VzIGFyZSByZXRhaW5lZCBpblxuICogYWxsIGNvcGllcy4gU29tZSBvZiB0aGUgYWxnb3JpdGhtcyBpbXBsZW1lbnRlZCBieSB0aGlzIHNvZnR3YXJlIGFyZVxuICogcGF0ZW50ZWQsIG9ic2VydmUgYWxsIGFwcGxpY2FibGUgcGF0ZW50IGxhdy5cbiAqXG4gKiBJTiBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBESVNUUklCVVRPUlMgQkUgTElBQkxFIFRPIEFOWSBQQVJUWSBGT1JcbiAqIERJUkVDVCwgSU5ESVJFQ1QsIFNQRUNJQUwsIElOQ0lERU5UQUwsIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFUyBBUklTSU5HIE9VVFxuICogT0YgVEhFIFVTRSBPRiBUSElTIFNPRlRXQVJFLCBJVFMgRE9DVU1FTlRBVElPTiwgT1IgQU5ZIERFUklWQVRJVkVTIFRIRVJFT0YsXG4gKiBFVkVOIElGIFRIRSBBVVRIT1JTIEhBVkUgQkVFTiBBRFZJU0VEIE9GIFRIRSBQT1NTSUJJTElUWSBPRiBTVUNIIERBTUFHRS5cbiAqXG4gKiBUSEUgQVVUSE9SUyBBTkQgRElTVFJJQlVUT1JTIFNQRUNJRklDQUxMWSBESVNDTEFJTSBBTlkgV0FSUkFOVElFUyxcbiAqIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEUgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFLCBBTkQgTk9OLUlORlJJTkdFTUVOVC4gIFRISVMgU09GVFdBUkUgSVNcbiAqIFBST1ZJREVEIE9OIEFOIFwiQVMgSVNcIiBCQVNJUywgQU5EIFRIRSBBVVRIT1JTIEFORCBESVNUUklCVVRPUlMgSEFWRSBOT1xuICogT0JMSUdBVElPTiBUTyBQUk9WSURFIE1BSU5URU5BTkNFLCBTVVBQT1JULCBVUERBVEVTLCBFTkhBTkNFTUVOVFMsIE9SXG4gKiBNT0RJRklDQVRJT05TLlxuICovXG5cblxuICBtb2R1bGUuZXhwb3J0cyA9IENvbnJlYztcblxuICB2YXIgRVBTSUxPTiA9IDFlLTEwO1xuXG4gIGZ1bmN0aW9uIHBvaW50c0VxdWFsKGEsIGIpIHtcbiAgICAgIHZhciB4ID0gYS54IC0gYi54LCB5ID0gYS55IC0gYi55O1xuICAgICAgcmV0dXJuIHggKiB4ICsgeSAqIHkgPCBFUFNJTE9OO1xuICB9XG5cbiAgZnVuY3Rpb24gcmV2ZXJzZUxpc3QobGlzdCkge1xuICAgICAgdmFyIHBwID0gbGlzdC5oZWFkO1xuXG4gICAgICB3aGlsZSAocHApIHtcbiAgICAgIC8vIHN3YXAgcHJldi9uZXh0IHBvaW50ZXJzXG4gICAgICAgICAgdmFyIHRlbXAgPSBwcC5uZXh0O1xuICAgICAgICAgIHBwLm5leHQgPSBwcC5wcmV2O1xuICAgICAgICAgIHBwLnByZXYgPSB0ZW1wO1xuXG4gICAgICAvLyBjb250aW51ZSB0aHJvdWdoIHRoZSBsaXN0XG4gICAgICAgICAgcHAgPSB0ZW1wO1xuICAgICAgfVxuXG4gICAgLy8gc3dhcCBoZWFkL3RhaWwgcG9pbnRlcnNcbiAgICAgIHZhciB0ZW1wID0gbGlzdC5oZWFkO1xuICAgICAgbGlzdC5oZWFkID0gbGlzdC50YWlsO1xuICAgICAgbGlzdC50YWlsID0gdGVtcDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRvdXJCdWlsZGVyKGxldmVsKSB7XG4gICAgICB0aGlzLmxldmVsID0gbGV2ZWw7XG4gICAgICB0aGlzLnMgPSBudWxsO1xuICAgICAgdGhpcy5jb3VudCA9IDA7XG4gIH1cbiAgQ29udG91ckJ1aWxkZXIucHJvdG90eXBlLnJlbW92ZV9zZXEgPSBmdW5jdGlvbiAobGlzdCkge1xuICAgIC8vIGlmIGxpc3QgaXMgdGhlIGZpcnN0IGl0ZW0sIHN0YXRpYyBwdHIgcyBpcyB1cGRhdGVkXG4gICAgICBpZiAobGlzdC5wcmV2KSB7XG4gICAgICAgICAgbGlzdC5wcmV2Lm5leHQgPSBsaXN0Lm5leHQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucyA9IGxpc3QubmV4dDtcbiAgICAgIH1cblxuICAgICAgaWYgKGxpc3QubmV4dCkge1xuICAgICAgICAgIGxpc3QubmV4dC5wcmV2ID0gbGlzdC5wcmV2O1xuICAgICAgfVxuICAgICAgLS10aGlzLmNvdW50O1xuICB9O1xuICBDb250b3VyQnVpbGRlci5wcm90b3R5cGUuYWRkU2VnbWVudCA9IGZ1bmN0aW9uIChhLCBiKSB7XG4gICAgICB2YXIgc3MgPSB0aGlzLnM7XG4gICAgICB2YXIgbWEgPSBudWxsO1xuICAgICAgdmFyIG1iID0gbnVsbDtcbiAgICAgIHZhciBwcmVwZW5kQSA9IGZhbHNlO1xuICAgICAgdmFyIHByZXBlbmRCID0gZmFsc2U7XG5cbiAgICAgIHdoaWxlIChzcykge1xuICAgICAgICAgIGlmIChtYSA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vIG1hdGNoIGZvciBhIHlldFxuICAgICAgICAgICAgICBpZiAocG9pbnRzRXF1YWwoYSwgc3MuaGVhZC5wKSkge1xuICAgICAgICAgICAgICAgICAgbWEgPSBzcztcbiAgICAgICAgICAgICAgICAgIHByZXBlbmRBID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludHNFcXVhbChhLCBzcy50YWlsLnApKSB7XG4gICAgICAgICAgICAgICAgICBtYSA9IHNzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtYiA9PSBudWxsKSB7XG4gICAgICAgIC8vIG5vIG1hdGNoIGZvciBiIHlldFxuICAgICAgICAgICAgICBpZiAocG9pbnRzRXF1YWwoYiwgc3MuaGVhZC5wKSkge1xuICAgICAgICAgICAgICAgICAgbWIgPSBzcztcbiAgICAgICAgICAgICAgICAgIHByZXBlbmRCID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChwb2ludHNFcXVhbChiLCBzcy50YWlsLnApKSB7XG4gICAgICAgICAgICAgICAgICBtYiA9IHNzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgLy8gaWYgd2UgbWF0Y2hlZCBib3RoIG5vIG5lZWQgdG8gY29udGludWUgc2VhcmNoaW5nXG4gICAgICAgICAgaWYgKG1iICE9IG51bGwgJiYgbWEgIT0gbnVsbCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBzcyA9IHNzLm5leHQ7XG4gICAgICAgICAgfVxuICAgICAgfVxuXG4gICAgLy8gYyBpcyB0aGUgY2FzZSBzZWxlY3RvciBiYXNlZCBvbiB3aGljaCBvZiBtYSBhbmQvb3IgbWIgYXJlIHNldFxuICAgICAgdmFyIGMgPSAoKG1hICE9IG51bGwpID8gMSA6IDApIHwgKChtYiAhPSBudWxsKSA/IDIgOiAwKTtcblxuICAgICAgc3dpdGNoIChjKSB7XG4gICAgICBjYXNlIDA6ICAgLy8gYm90aCB1bm1hdGNoZWQsIGFkZCBhcyBuZXcgc2VxdWVuY2VcbiAgICAgICAgICB2YXIgYWEgPSB7cDogYSwgcHJldjogbnVsbH07XG4gICAgICAgICAgdmFyIGJiID0ge3A6IGIsIG5leHQ6IG51bGx9O1xuICAgICAgICAgIGFhLm5leHQgPSBiYjtcbiAgICAgICAgICBiYi5wcmV2ID0gYWE7XG5cbiAgICAgICAgLy8gY3JlYXRlIHNlcXVlbmNlIGVsZW1lbnQgYW5kIHB1c2ggb250byBoZWFkIG9mIG1haW4gbGlzdC4gVGhlIG9yZGVyXG4gICAgICAgIC8vIG9mIGl0ZW1zIGluIHRoaXMgbGlzdCBpcyB1bmltcG9ydGFudFxuICAgICAgICAgIG1hID0ge2hlYWQ6IGFhLCB0YWlsOiBiYiwgbmV4dDogdGhpcy5zLCBwcmV2OiBudWxsLCBjbG9zZWQ6IGZhbHNlfTtcbiAgICAgICAgICBpZiAodGhpcy5zKSB7XG4gICAgICAgICAgICAgIHRoaXMucy5wcmV2ID0gbWE7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMucyA9IG1hO1xuXG4gICAgICAgICAgKyt0aGlzLmNvdW50OyAgICAvLyBub3QgZXNzZW50aWFsIC0gdHJhY2tzIG51bWJlciBvZiB1bm1lcmdlZCBzZXF1ZW5jZXNcbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAxOiAgIC8vIGEgbWF0Y2hlZCwgYiBkaWQgbm90IC0gdGh1cyBiIGV4dGVuZHMgc2VxdWVuY2UgbWFcbiAgICAgICAgICB2YXIgcHAgPSB7cDogYn07XG5cbiAgICAgICAgICBpZiAocHJlcGVuZEEpIHtcbiAgICAgICAgICAgICAgcHAubmV4dCA9IG1hLmhlYWQ7XG4gICAgICAgICAgICAgIHBwLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgICBtYS5oZWFkLnByZXYgPSBwcDtcbiAgICAgICAgICAgICAgbWEuaGVhZCA9IHBwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBwLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICBwcC5wcmV2ID0gbWEudGFpbDtcbiAgICAgICAgICAgICAgbWEudGFpbC5uZXh0ID0gcHA7XG4gICAgICAgICAgICAgIG1hLnRhaWwgPSBwcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMjogICAvLyBiIG1hdGNoZWQsIGEgZGlkIG5vdCAtIHRodXMgYSBleHRlbmRzIHNlcXVlbmNlIG1iXG4gICAgICAgICAgdmFyIHBwID0ge3A6IGF9O1xuXG4gICAgICAgICAgaWYgKHByZXBlbmRCKSB7XG4gICAgICAgICAgICAgIHBwLm5leHQgPSBtYi5oZWFkO1xuICAgICAgICAgICAgICBwcC5wcmV2ID0gbnVsbDtcbiAgICAgICAgICAgICAgbWIuaGVhZC5wcmV2ID0gcHA7XG4gICAgICAgICAgICAgIG1iLmhlYWQgPSBwcDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICBwcC5uZXh0ID0gbnVsbDtcbiAgICAgICAgICAgICAgcHAucHJldiA9IG1iLnRhaWw7XG4gICAgICAgICAgICAgIG1iLnRhaWwubmV4dCA9IHBwO1xuICAgICAgICAgICAgICBtYi50YWlsID0gcHA7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDM6ICAgLy8gYm90aCBtYXRjaGVkLCBjYW4gbWVyZ2Ugc2VxdWVuY2VzXG4gICAgICAgIC8vIGlmIHRoZSBzZXF1ZW5jZXMgYXJlIHRoZSBzYW1lLCBkbyBub3RoaW5nLCBhcyB3ZSBhcmUgc2ltcGx5IGNsb3NpbmcgdGhpcyBwYXRoIChjb3VsZCBzZXQgYSBmbGFnKVxuXG4gICAgICAgICAgaWYgKG1hID09PSBtYikge1xuICAgICAgICAgICAgICB2YXIgcHAgPSB7cDogbWEudGFpbC5wLCBuZXh0OiBtYS5oZWFkLCBwcmV2OiBudWxsfTtcbiAgICAgICAgICAgICAgbWEuaGVhZC5wcmV2ID0gcHA7XG4gICAgICAgICAgICAgIG1hLmhlYWQgPSBwcDtcbiAgICAgICAgICAgICAgbWEuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuXG4gICAgICAgIC8vIHRoZXJlIGFyZSA0IHdheXMgdGhlIHNlcXVlbmNlIHBhaXIgY2FuIGJlIGpvaW5lZC4gVGhlIGN1cnJlbnQgc2V0dGluZyBvZiBwcmVwZW5kQSBhbmRcbiAgICAgICAgLy8gcHJlcGVuZEIgd2lsbCB0ZWxsIHVzIHdoaWNoIHR5cGUgb2Ygam9pbiBpcyBuZWVkZWQuIEZvciBoZWFkL2hlYWQgYW5kIHRhaWwvdGFpbCBqb2luc1xuICAgICAgICAvLyBvbmUgc2VxdWVuY2UgbmVlZHMgdG8gYmUgcmV2ZXJzZWRcbiAgICAgICAgICBzd2l0Y2ggKChwcmVwZW5kQSA/IDEgOiAwKSB8IChwcmVwZW5kQiA/IDIgOiAwKSkge1xuICAgICAgICAgIGNhc2UgMDogICAvLyB0YWlsLXRhaWxcbiAgICAgICAgICAgIC8vIHJldmVyc2UgbWEgYW5kIGFwcGVuZCB0byBtYlxuICAgICAgICAgICAgICByZXZlcnNlTGlzdChtYSk7XG4gICAgICAgICAgICAvLyBmYWxsIHRocm91Z2ggdG8gaGVhZC90YWlsIGNhc2VcbiAgICAgICAgICBjYXNlIDE6ICAgLy8gaGVhZC10YWlsXG4gICAgICAgICAgICAvLyBtYSBpcyBhcHBlbmRlZCB0byBtYiBhbmQgbWEgZGlzY2FyZGVkXG4gICAgICAgICAgICAgIG1iLnRhaWwubmV4dCA9IG1hLmhlYWQ7XG4gICAgICAgICAgICAgIG1hLmhlYWQucHJldiA9IG1iLnRhaWw7XG4gICAgICAgICAgICAgIG1iLnRhaWwgPSBtYS50YWlsO1xuXG4gICAgICAgICAgICAvL2Rpc2NhcmQgbWEgc2VxdWVuY2UgcmVjb3JkXG4gICAgICAgICAgICAgIHRoaXMucmVtb3ZlX3NlcShtYSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgICAgY2FzZSAzOiAgIC8vIGhlYWQtaGVhZFxuICAgICAgICAgICAgLy8gcmV2ZXJzZSBtYSBhbmQgYXBwZW5kIG1iIHRvIGl0XG4gICAgICAgICAgICAgIHJldmVyc2VMaXN0KG1hKTtcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byB0YWlsL2hlYWQgY2FzZVxuICAgICAgICAgIGNhc2UgMjogICAvLyB0YWlsLWhlYWRcbiAgICAgICAgICAgIC8vIG1iIGlzIGFwcGVuZGVkIHRvIG1hIGFuZCBtYiBpcyBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgbWEudGFpbC5uZXh0ID0gbWIuaGVhZDtcbiAgICAgICAgICAgICAgbWIuaGVhZC5wcmV2ID0gbWEudGFpbDtcbiAgICAgICAgICAgICAgbWEudGFpbCA9IG1iLnRhaWw7XG5cbiAgICAgICAgICAgIC8vZGlzY2FyZCBtYiBzZXF1ZW5jZSByZWNvcmRcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVfc2VxKG1iKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xuXG4gIC8qXG4gICAqIEltcGxlbWVudHMgQ09OUkVDLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge2Z1bmN0aW9ufSBkcmF3Q29udG91ciBmdW5jdGlvbiBmb3IgZHJhd2luZyBjb250b3VyLiAgRGVmYXVsdHMgdG8gYVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjdXN0b20gXCJjb250b3VyIGJ1aWxkZXJcIiwgd2hpY2ggcG9wdWxhdGVzIHRoZVxuICAgKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250b3VycyBwcm9wZXJ0eS5cbiAgICovXG4gIGZ1bmN0aW9uIENvbnJlYyhkcmF3Q29udG91cikge1xuICAgICAgaWYgKCFkcmF3Q29udG91cikge1xuICAgICAgICAgIHZhciBjID0gdGhpcztcbiAgICAgICAgICBjLmNvbnRvdXJzID0ge307XG4gICAgICAvKipcbiAgICAgICAqIGRyYXdDb250b3VyIC0gaW50ZXJmYWNlIGZvciBpbXBsZW1lbnRpbmcgdGhlIHVzZXIgc3VwcGxpZWQgbWV0aG9kIHRvXG4gICAgICAgKiByZW5kZXIgdGhlIGNvdW50b3Vycy5cbiAgICAgICAqXG4gICAgICAgKiBEcmF3cyBhIGxpbmUgYmV0d2VlbiB0aGUgc3RhcnQgYW5kIGVuZCBjb29yZGluYXRlcy5cbiAgICAgICAqXG4gICAgICAgKiBAcHJpdmF0ZVxuICAgICAgICogQHBhcmFtIHN0YXJ0WCAgICAtIHN0YXJ0IGNvb3JkaW5hdGUgZm9yIFhcbiAgICAgICAqIEBwYXJhbSBzdGFydFkgICAgLSBzdGFydCBjb29yZGluYXRlIGZvciBZXG4gICAgICAgKiBAcGFyYW0gZW5kWCAgICAgIC0gZW5kIGNvb3JkaW5hdGUgZm9yIFhcbiAgICAgICAqIEBwYXJhbSBlbmRZICAgICAgLSBlbmQgY29vcmRpbmF0ZSBmb3IgWVxuICAgICAgICogQHBhcmFtIGNvbnRvdXJMZXZlbCAtIENvbnRvdXIgbGV2ZWwgZm9yIGxpbmUuXG4gICAgICAgKi9cbiAgICAgICAgICB0aGlzLmRyYXdDb250b3VyID0gZnVuY3Rpb24gKHN0YXJ0WCwgc3RhcnRZLCBlbmRYLCBlbmRZLCBjb250b3VyTGV2ZWwsIGspIHtcbiAgICAgICAgICAgICAgdmFyIGNiID0gYy5jb250b3Vyc1trXTtcbiAgICAgICAgICAgICAgaWYgKCFjYikge1xuICAgICAgICAgICAgICAgICAgY2IgPSBjLmNvbnRvdXJzW2tdID0gbmV3IENvbnRvdXJCdWlsZGVyKGNvbnRvdXJMZXZlbCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY2IuYWRkU2VnbWVudCh7eDogc3RhcnRYLCB5OiBzdGFydFl9LCB7eDogZW5kWCwgeTogZW5kWX0pO1xuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5jb250b3VyTGlzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgdmFyIGwgPSBbXTtcbiAgICAgICAgICAgICAgdmFyIGEgPSBjLmNvbnRvdXJzO1xuICAgICAgICAgICAgICBmb3IgKHZhciBrIGluIGEpIHtcbiAgICAgICAgICAgICAgICAgIHZhciBzID0gYVtrXS5zO1xuICAgICAgICAgICAgICAgICAgdmFyIGxldmVsID0gYVtrXS5sZXZlbDtcbiAgICAgICAgICAgICAgICAgIHdoaWxlIChzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGggPSBzLmhlYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgdmFyIGwyID0gW107XG4gICAgICAgICAgICAgICAgICAgICAgbDIubGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgICAgICAgICAgICAgICBsMi5rID0gaztcbiAgICAgICAgICAgICAgICAgICAgICB3aGlsZSAoaCAmJiBoLnApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgbDIucHVzaChoLnApO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBoID0gaC5uZXh0O1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBsLnB1c2gobDIpO1xuICAgICAgICAgICAgICAgICAgICAgIHMgPSBzLm5leHQ7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgbC5zb3J0KGZ1bmN0aW9uIChhLCBiKSB7IHJldHVybiBhLmsgLSBiLms7IH0pO1xuICAgICAgICAgICAgICByZXR1cm4gbDtcbiAgICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLmRyYXdDb250b3VyID0gZHJhd0NvbnRvdXI7XG4gICAgICB9XG4gICAgICB0aGlzLmggID0gbmV3IEFycmF5KDUpO1xuICAgICAgdGhpcy5zaCA9IG5ldyBBcnJheSg1KTtcbiAgICAgIHRoaXMueGggPSBuZXcgQXJyYXkoNSk7XG4gICAgICB0aGlzLnloID0gbmV3IEFycmF5KDUpO1xuICB9XG5cbiAgLypcbiAgICogY29udG91ciBpcyBhIGNvbnRvdXJpbmcgc3Vicm91dGluZSBmb3IgcmVjdGFuZ3VsYXJpbHkgc3BhY2VkIGRhdGFcbiAgICpcbiAgICogSXQgZW1pdHMgY2FsbHMgdG8gYSBsaW5lIGRyYXdpbmcgc3Vicm91dGluZSBzdXBwbGllZCBieSB0aGUgdXNlciB3aGljaFxuICAgKiBkcmF3cyBhIGNvbnRvdXIgbWFwIGNvcnJlc3BvbmRpbmcgdG8gcmVhbCo0ZGF0YSBvbiBhIHJhbmRvbWx5IHNwYWNlZFxuICAgKiByZWN0YW5ndWxhciBncmlkLiBUaGUgY29vcmRpbmF0ZXMgZW1pdHRlZCBhcmUgaW4gdGhlIHNhbWUgdW5pdHMgZ2l2ZW4gaW5cbiAgICogdGhlIHgoKSBhbmQgeSgpIGFycmF5cy5cbiAgICpcbiAgICogQW55IG51bWJlciBvZiBjb250b3VyIGxldmVscyBtYXkgYmUgc3BlY2lmaWVkIGJ1dCB0aGV5IG11c3QgYmUgaW4gb3JkZXIgb2ZcbiAgICogaW5jcmVhc2luZyB2YWx1ZS5cbiAgICpcbiAgICpcbiAgICogQHBhcmFtIHtudW1iZXJbXVtdfSBkIC0gbWF0cml4IG9mIGRhdGEgdG8gY29udG91clxuICAgKiBAcGFyYW0ge251bWJlcn0gaWxiLGl1YixqbGIsanViIC0gaW5kZXggYm91bmRzIG9mIGRhdGEgbWF0cml4XG4gICAqXG4gICAqICAgICAgICAgICAgIFRoZSBmb2xsb3dpbmcgdHdvLCBvbmUgZGltZW5zaW9uYWwgYXJyYXlzICh4IGFuZCB5KSBjb250YWluXG4gICAqICAgICAgICAgICAgIHRoZSBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBjb29yZGluYXRlcyBvZiBlYWNoIHNhbXBsZSBwb2ludHMuXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHggIC0gZGF0YSBtYXRyaXggY29sdW1uIGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHkgIC0gZGF0YSBtYXRyaXggcm93IGNvb3JkaW5hdGVzXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBuYyAgIC0gbnVtYmVyIG9mIGNvbnRvdXIgbGV2ZWxzXG4gICAqIEBwYXJhbSB7bnVtYmVyW119IHogIC0gY29udG91ciBsZXZlbHMgaW4gaW5jcmVhc2luZyBvcmRlci5cbiAgICovXG4gIENvbnJlYy5wcm90b3R5cGUuY29udG91ciA9IGZ1bmN0aW9uIChkLCBpbGIsIGl1YiwgamxiLCBqdWIsIHgsIHksIG5jLCB6KSB7XG4gICAgICB2YXIgaCA9IHRoaXMuaCwgc2ggPSB0aGlzLnNoLCB4aCA9IHRoaXMueGgsIHloID0gdGhpcy55aDtcbiAgICAgIHZhciBkcmF3Q29udG91ciA9IHRoaXMuZHJhd0NvbnRvdXI7XG4gICAgICB0aGlzLmNvbnRvdXJzID0ge307XG5cbiAgICAgIHZhciB4c2VjdCA9IGZ1bmN0aW9uIChwMSwgcDIpIHtcbiAgICAgICAgICByZXR1cm4gKGhbcDJdICogeGhbcDFdIC0gaFtwMV0gKiB4aFtwMl0pIC8gKGhbcDJdIC0gaFtwMV0pO1xuICAgICAgfTtcblxuICAgICAgdmFyIHlzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICAgIHJldHVybiAoaFtwMl0gKiB5aFtwMV0gLSBoW3AxXSAqIHloW3AyXSkgLyAoaFtwMl0gLSBoW3AxXSk7XG4gICAgICB9O1xuICAgICAgdmFyIG0xO1xuICAgICAgdmFyIG0yO1xuICAgICAgdmFyIG0zO1xuICAgICAgdmFyIGNhc2VfdmFsdWU7XG4gICAgICB2YXIgZG1pbjtcbiAgICAgIHZhciBkbWF4O1xuICAgICAgdmFyIHgxID0gMC4wO1xuICAgICAgdmFyIHgyID0gMC4wO1xuICAgICAgdmFyIHkxID0gMC4wO1xuICAgICAgdmFyIHkyID0gMC4wO1xuXG4gICAgLy8gVGhlIGluZGV4aW5nIG9mIGltIGFuZCBqbSBzaG91bGQgYmUgbm90ZWQgYXMgaXQgaGFzIHRvIHN0YXJ0IGZyb20gemVyb1xuICAgIC8vIHVubGlrZSB0aGUgZm9ydHJhbiBjb3VudGVyIHBhcnRcbiAgICAgIHZhciBpbSA9IFswLCAxLCAxLCAwXTtcbiAgICAgIHZhciBqbSA9IFswLCAwLCAxLCAxXTtcblxuICAgIC8vIE5vdGUgdGhhdCBjYXN0YWIgaXMgYXJyYW5nZWQgZGlmZmVyZW50bHkgZnJvbSB0aGUgRk9SVFJBTiBjb2RlIGJlY2F1c2VcbiAgICAvLyBGb3J0cmFuIGFuZCBDL0MrKyBhcnJheXMgYXJlIHRyYW5zcG9zZWQgb2YgZWFjaCBvdGhlciwgaW4gdGhpcyBjYXNlXG4gICAgLy8gaXQgaXMgbW9yZSB0cmlja3kgYXMgY2FzdGFiIGlzIGluIDMgZGltZW5zaW9uc1xuICAgICAgdmFyIGNhc3RhYiA9IFtcbiAgICAgICAgICBbXG4gICAgICAgIFswLCAwLCA4XSwgWzAsIDIsIDVdLCBbNywgNiwgOV1cbiAgICAgICAgICBdLFxuICAgICAgICAgIFtcbiAgICAgICAgWzAsIDMsIDRdLCBbMSwgMywgMV0sIFs0LCAzLCAwXVxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICBbOSwgNiwgN10sIFs1LCAyLCAwXSwgWzgsIDAsIDBdXG4gICAgICAgICAgXVxuICAgICAgXTtcblxuICAgICAgZm9yICh2YXIgaiA9IChqdWIgLSAxKTsgaiA+PSBqbGI7IGotLSkge1xuICAgICAgICAgIGZvciAodmFyIGkgPSBpbGI7IGkgPD0gaXViIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAgIHZhciB0ZW1wMSwgdGVtcDI7XG4gICAgICAgICAgICAgIHRlbXAxID0gTWF0aC5taW4oZFtpXVtqXSwgZFtpXVtqICsgMV0pO1xuICAgICAgICAgICAgICB0ZW1wMiA9IE1hdGgubWluKGRbaSArIDFdW2pdLCBkW2kgKyAxXVtqICsgMV0pO1xuICAgICAgICAgICAgICBkbWluICA9IE1hdGgubWluKHRlbXAxLCB0ZW1wMik7XG4gICAgICAgICAgICAgIHRlbXAxID0gTWF0aC5tYXgoZFtpXVtqXSwgZFtpXVtqICsgMV0pO1xuICAgICAgICAgICAgICB0ZW1wMiA9IE1hdGgubWF4KGRbaSArIDFdW2pdLCBkW2kgKyAxXVtqICsgMV0pO1xuICAgICAgICAgICAgICBkbWF4ICA9IE1hdGgubWF4KHRlbXAxLCB0ZW1wMik7XG5cbiAgICAgICAgICAgICAgaWYgKGRtYXggPj0gelswXSAmJiBkbWluIDw9IHpbbmMgLSAxXSkge1xuICAgICAgICAgICAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBuYzsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHpba10gPj0gZG1pbiAmJiB6W2tdIDw9IGRtYXgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbSA9IDQ7IG0gPj0gMDsgbS0tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG0gPiAwKSB7XG4gICAgICAgICAgICAgICAgICAvLyBUaGUgaW5kZXhpbmcgb2YgaW0gYW5kIGptIHNob3VsZCBiZSBub3RlZCBhcyBpdCBoYXMgdG9cbiAgICAgICAgICAgICAgICAgIC8vIHN0YXJ0IGZyb20gemVyb1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaFttXSA9IGRbaSArIGltW20gLSAxXV1baiArIGptW20gLSAxXV0gLSB6W2tdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeGhbbV0gPSB4W2kgKyBpbVttIC0gMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWhbbV0gPSB5W2ogKyBqbVttIC0gMV1dO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaFswXSA9IDAuMjUgKiAoaFsxXSArIGhbMl0gKyBoWzNdICsgaFs0XSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aFswXSA9IDAuNSAqICh4W2ldICsgeFtpICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeWhbMF0gPSAwLjUgKiAoeVtqXSArIHlbaiArIDFdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoW21dID4gRVBTSUxPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hbbV0gPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGhbbV0gPCAtRVBTSUxPTikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNoW21dID0gLTE7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2VcbiAgICAgICAgICAgICAgICAgIHNoW21dID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gTm90ZTogYXQgdGhpcyBzdGFnZSB0aGUgcmVsYXRpdmUgaGVpZ2h0cyBvZiB0aGUgY29ybmVycyBhbmQgdGhlXG4gICAgICAgICAgICAgIC8vIGNlbnRyZSBhcmUgaW4gdGhlIGggYXJyYXksIGFuZCB0aGUgY29ycmVzcG9uZGluZyBjb29yZGluYXRlcyBhcmVcbiAgICAgICAgICAgICAgLy8gaW4gdGhlIHhoIGFuZCB5aCBhcnJheXMuIFRoZSBjZW50cmUgb2YgdGhlIGJveCBpcyBpbmRleGVkIGJ5IDBcbiAgICAgICAgICAgICAgLy8gYW5kIHRoZSA0IGNvcm5lcnMgYnkgMSB0byA0IGFzIHNob3duIGJlbG93LlxuICAgICAgICAgICAgICAvLyBFYWNoIHRyaWFuZ2xlIGlzIHRoZW4gaW5kZXhlZCBieSB0aGUgcGFyYW1ldGVyIG0sIGFuZCB0aGUgM1xuICAgICAgICAgICAgICAvLyB2ZXJ0aWNlcyBvZiBlYWNoIHRyaWFuZ2xlIGFyZSBpbmRleGVkIGJ5IHBhcmFtZXRlcnMgbTEsbTIsYW5kXG4gICAgICAgICAgICAgIC8vIG0zLlxuICAgICAgICAgICAgICAvLyBJdCBpcyBhc3N1bWVkIHRoYXQgdGhlIGNlbnRyZSBvZiB0aGUgYm94IGlzIGFsd2F5cyB2ZXJ0ZXggMlxuICAgICAgICAgICAgICAvLyB0aG91Z2ggdGhpcyBpc2ltcG9ydGFudCBvbmx5IHdoZW4gYWxsIDMgdmVydGljZXMgbGllIGV4YWN0bHkgb25cbiAgICAgICAgICAgICAgLy8gdGhlIHNhbWUgY29udG91ciBsZXZlbCwgaW4gd2hpY2ggY2FzZSBvbmx5IHRoZSBzaWRlIG9mIHRoZSBib3hcbiAgICAgICAgICAgICAgLy8gaXMgZHJhd24uXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgICAgdmVydGV4IDQgKy0tLS0tLS0tLS0tLS0tLS0tLS0rIHZlcnRleCAzXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCBcXCAgICAgICAgICAgICAgIC8gfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICBcXCAgICBtLTMgICAgLyAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgICBcXCAgICAgICAvICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgICAgICBcXCAgIC8gICAgICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgIG09MiAgICBYICAgbT0yICAgfCAgICAgICB0aGUgY2VudHJlIGlzIHZlcnRleCAwXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgICAgICAvICAgXFwgICAgICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICAgIC8gICAgICAgXFwgICAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgLyAgICBtPTEgICAgXFwgICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAvICAgICAgICAgICAgICAgXFwgfFxuICAgICAgICAgICAgICAvLyAgICAgIHZlcnRleCAxICstLS0tLS0tLS0tLS0tLS0tLS0tKyB2ZXJ0ZXggMlxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIFNjYW4gZWFjaCB0cmlhbmdsZSBpbiB0aGUgYm94XG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobSA9IDE7IG0gPD0gNDsgbSsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTEgPSBtO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0yID0gMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSAhPSA0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMyA9IG0gKyAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbTMgPSAxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZV92YWx1ZSA9IGNhc3RhYltzaFttMV0gKyAxXVtzaFttMl0gKyAxXVtzaFttM10gKyAxXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2FzZV92YWx1ZSAhPSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKGNhc2VfdmFsdWUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IC8vIExpbmUgYmV0d2VlbiB2ZXJ0aWNlcyAxIGFuZCAyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geWhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6IC8vIExpbmUgYmV0d2VlbiB2ZXJ0aWNlcyAyIGFuZCAzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geWhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IC8vIExpbmUgYmV0d2VlbiB2ZXJ0aWNlcyAzIGFuZCAxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geWhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IC8vIExpbmUgYmV0d2VlbiB2ZXJ0ZXggMSBhbmQgc2lkZSAyLTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA1OiAvLyBMaW5lIGJldHdlZW4gdmVydGV4IDIgYW5kIHNpZGUgMy0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geGhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHloW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNjogLy8gIExpbmUgYmV0d2VlbiB2ZXJ0ZXggMyBhbmQgc2lkZSAxLTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiAvLyBMaW5lIGJldHdlZW4gc2lkZXMgMS0yIGFuZCAyLTNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHlzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDg6IC8vIExpbmUgYmV0d2VlbiBzaWRlcyAyLTMgYW5kIDMtMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geXNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgOTogLy8gTGluZSBiZXR3ZWVuIHNpZGVzIDMtMSBhbmQgMS0yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geHNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgLy8gUHV0IHlvdXIgcHJvY2Vzc2luZyBjb2RlIGhlcmUgYW5kIGNvbW1lbnQgb3V0IHRoZSBwcmludGZcbiAgICAgICAgICAgICAgICAgIC8vcHJpbnRmKFwiJWYgJWYgJWYgJWYgJWZcXG5cIix4MSx5MSx4Mix5Mix6W2tdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRyYXdDb250b3VyKHgxLCB5MSwgeDIsIHkyLCB6W2tdLCBrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgIH1cbiAgfTtcbiIsIi8vaHR0cHM6Ly9naXRodWIuY29tL2phc29uZGF2aWVzL2NvbnJlYy5qc1xuLy9odHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzI2MzMwNS9kcmF3aW5nLWEtdG9wb2dyYXBoaWNhbC1tYXBcbnZhciB0aW4gPSByZXF1aXJlKCd0dXJmLXRpbicpO1xudmFyIGluc2lkZSA9IHJlcXVpcmUoJ3R1cmYtaW5zaWRlJyk7XG52YXIgZ3JpZCA9IHJlcXVpcmUoJ3R1cmYtZ3JpZCcpO1xudmFyIGJib3ggPSByZXF1aXJlKCd0dXJmLWJib3gnKTtcbnZhciBwbGFuZXBvaW50ID0gcmVxdWlyZSgndHVyZi1wbGFuZXBvaW50Jyk7XG52YXIgZmVhdHVyZWNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBsaW5lc3RyaW5nID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykubGluZVN0cmluZztcbnZhciBzcXVhcmUgPSByZXF1aXJlKCd0dXJmLXNxdWFyZScpO1xudmFyIENvbnJlYyA9IHJlcXVpcmUoJy4vY29ucmVjJyk7XG5cbi8qKlxuICogVGFrZXMge0BsaW5rIFBvaW50fHBvaW50c30gd2l0aCB6LXZhbHVlcyBhbmQgYW4gYXJyYXkgb2ZcbiAqIHZhbHVlIGJyZWFrcyBhbmQgZ2VuZXJhdGVzIFtpc29saW5lc10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Jc29saW5lKS5cbiAqXG4gKiBAbmFtZSBpc29saW5lc1xuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7c3RyaW5nfSB6IHRoZSBwcm9wZXJ0eSBuYW1lIGluIGBwb2ludHNgIGZyb20gd2hpY2ggei12YWx1ZXMgd2lsbCBiZSBwdWxsZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSByZXNvbHV0aW9uIHJlc29sdXRpb24gb2YgdGhlIHVuZGVybHlpbmcgZ3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBicmVha3Mgd2hlcmUgdG8gZHJhdyBjb250b3Vyc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSBpc29saW5lc1xuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSByYW5kb20gcG9pbnRzIHdpdGggcmFuZG9tXG4gKiAvLyB6LXZhbHVlcyBpbiB0aGVpciBwcm9wZXJ0aWVzXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5yYW5kb20oJ3BvaW50JywgMTAwLCB7XG4gKiAgIGJib3g6IFswLCAzMCwgMjAsIDUwXVxuICogfSk7XG4gKiBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICogICBwb2ludHMuZmVhdHVyZXNbaV0ucHJvcGVydGllcy56ID0gTWF0aC5yYW5kb20oKSAqIDEwO1xuICogfVxuICogdmFyIGJyZWFrcyA9IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5LCAxMF07XG4gKiB2YXIgaXNvbGluZWQgPSB0dXJmLmlzb2xpbmVzKHBvaW50cywgJ3onLCAxNSwgYnJlYWtzKTtcbiAqIC8vPWlzb2xpbmVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgeiwgcmVzb2x1dGlvbiwgYnJlYWtzKSB7XG4gICAgdmFyIHRpblJlc3VsdCA9IHRpbihwb2ludHMsIHopO1xuICAgIHZhciBiYm94QkJveCA9IGJib3gocG9pbnRzKTtcbiAgICB2YXIgc3F1YXJlQkJveCA9IHNxdWFyZShiYm94QkJveCk7XG4gICAgdmFyIGdyaWRSZXN1bHQgPSBncmlkKHNxdWFyZUJCb3gsIHJlc29sdXRpb24pO1xuICAgIHZhciBkYXRhID0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyaWRSZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHB0ID0gZ3JpZFJlc3VsdC5mZWF0dXJlc1tpXTtcbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCB0aW5SZXN1bHQuZmVhdHVyZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIHZhciB0cmlhbmdsZSA9IHRpblJlc3VsdC5mZWF0dXJlc1tqXTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUocHQsIHRyaWFuZ2xlKSkge1xuICAgICAgICAgICAgICAgIHB0LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgICAgICBwdC5wcm9wZXJ0aWVzW3pdID0gcGxhbmVwb2ludChwdCwgdHJpYW5nbGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGRlcHRoID0gTWF0aC5zcXJ0KGdyaWRSZXN1bHQuZmVhdHVyZXMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciB4ID0gMDsgeCA8IGRlcHRoOyB4KyspIHtcbiAgICAgICAgdmFyIHhHcm91cCA9IGdyaWRSZXN1bHQuZmVhdHVyZXMuc2xpY2UoeCAqIGRlcHRoLCAoeCArIDEpICogZGVwdGgpO1xuICAgICAgICB2YXIgeEZsYXQgPSBbXTtcblxuICAgICAgICBmb3IgKHZhciBnID0gMDsgZyA8IHhHcm91cC5sZW5ndGg7IGcrKykge1xuICAgICAgICAgICAgaWYgKHhHcm91cFtnXS5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICAgICAgeEZsYXQucHVzaCh4R3JvdXBbZ10ucHJvcGVydGllc1t6XSk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHhGbGF0LnB1c2goMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZGF0YS5wdXNoKHhGbGF0KTtcbiAgICB9XG4gICAgdmFyIGludGVydmFsID0gKHNxdWFyZUJCb3hbMl0gLSBzcXVhcmVCQm94WzBdKSAvIGRlcHRoO1xuICAgIHZhciB4Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICB2YXIgeUNvb3JkaW5hdGVzID0gW107XG4gICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkZXB0aDsgZCsrKSB7XG4gICAgICAgIHhDb29yZGluYXRlcy5wdXNoKGQgKiBpbnRlcnZhbCArIHNxdWFyZUJCb3hbMF0pO1xuICAgICAgICB5Q29vcmRpbmF0ZXMucHVzaChkICogaW50ZXJ2YWwgKyBzcXVhcmVCQm94WzFdKTtcbiAgICB9XG5cbiAgICB2YXIgYyA9IG5ldyBDb25yZWMoKTtcbiAgICBjLmNvbnRvdXIoZGF0YSwgMCwgcmVzb2x1dGlvbiwgMCwgcmVzb2x1dGlvbiwgeENvb3JkaW5hdGVzLCB5Q29vcmRpbmF0ZXMsIGJyZWFrcy5sZW5ndGgsIGJyZWFrcyk7XG4gICAgdmFyIGNvbnRvdXJMaXN0ID0gYy5jb250b3VyTGlzdCgpO1xuXG4gICAgdmFyIGZjID0gZmVhdHVyZWNvbGxlY3Rpb24oW10pO1xuICAgIGNvbnRvdXJMaXN0LmZvckVhY2goZnVuY3Rpb24gKGMpIHtcbiAgICAgICAgaWYgKGMubGVuZ3RoID4gMikge1xuICAgICAgICAgICAgdmFyIHBvbHlDb29yZGluYXRlcyA9IFtdO1xuICAgICAgICAgICAgYy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgICAgIHBvbHlDb29yZGluYXRlcy5wdXNoKFtjb29yZC54LCBjb29yZC55XSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHZhciBwb2x5ID0gbGluZXN0cmluZyhwb2x5Q29vcmRpbmF0ZXMpO1xuICAgICAgICAgICAgcG9seS5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgICAgICBwb2x5LnByb3BlcnRpZXNbel0gPSBjLmxldmVsO1xuXG4gICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvbHkpO1xuICAgICAgICB9XG4gICAgfSk7XG5cbiAgICByZXR1cm4gZmM7XG59O1xuIiwiLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2x5Z29ufHBvbHlnb259IGFuZCByZXR1cm5zIHtAbGluayBQb2ludHxwb2ludHN9IGF0IGFsbCBzZWxmLWludGVyc2VjdGlvbnMuXG4gKlxuICogQG5hbWUga2lua3NcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPnxQb2x5Z29ufSBwb2x5Z29uIGlucHV0IHBvbHlnb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHNlbGYtaW50ZXJzZWN0aW9uc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstMTIuMDM0ODM1LCA4LjkwMTE4M10sXG4gKiAgICAgICBbLTEyLjA2MDQxMywgOC44OTk4MjZdLFxuICogICAgICAgWy0xMi4wMzYzOCwgOC44NzMxOTldLFxuICogICAgICAgWy0xMi4wNTkzODMsIDguODcxNDE4XSxcbiAqICAgICAgIFstMTIuMDM0ODM1LCA4LjkwMTE4M11cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBraW5rcyA9IHR1cmYua2lua3MocG9seSk7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0ga2lua3MuaW50ZXJzZWN0aW9ucy5mZWF0dXJlcy5jb25jYXQocG9seSk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5cbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5SW4pIHtcbiAgICB2YXIgcG9seTtcbiAgICB2YXIgcmVzdWx0cyA9IHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IFtdXG4gICAgfTtcbiAgICBpZiAocG9seUluLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBwb2x5ID0gcG9seUluLmdlb21ldHJ5O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHBvbHkgPSBwb2x5SW47XG4gICAgfVxuICAgIHBvbHkuY29vcmRpbmF0ZXMuZm9yRWFjaChmdW5jdGlvbiAocmluZzEpIHtcbiAgICAgICAgcG9seS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaW5nMikge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCByaW5nMS5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IHJpbmcyLmxlbmd0aCAtIDE7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAvLyBkb24ndCBjaGVjayBhZGphY2VudCBzaWRlcyBvZiBhIGdpdmVuIHJpbmcsIHNpbmNlIG9mIGNvdXJzZSB0aGV5IGludGVyc2VjdCBpbiBhIHZlcnRleC5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJpbmcxID09PSByaW5nMiAmJiAoTWF0aC5hYnMoaSAtIGspID09PSAxIHx8IE1hdGguYWJzKGkgLSBrKSA9PT0gcmluZzEubGVuZ3RoIC0gMikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGludGVyc2VjdGlvbiA9IGxpbmVJbnRlcnNlY3RzKHJpbmcxW2ldWzBdLCByaW5nMVtpXVsxXSwgcmluZzFbaSArIDFdWzBdLCByaW5nMVtpICsgMV1bMV0sXG4gICAgICAgICAgICAgICAgICAgICAgICByaW5nMltrXVswXSwgcmluZzJba11bMV0sIHJpbmcyW2sgKyAxXVswXSwgcmluZzJbayArIDFdWzFdKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0cy5mZWF0dXJlcy5wdXNoKHBvaW50KFtpbnRlcnNlY3Rpb25bMF0sIGludGVyc2VjdGlvblsxXV0pKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdHM7XG59O1xuXG5cbi8vIG1vZGlmaWVkIGZyb20gaHR0cDovL2pzZmlkZGxlLm5ldC9qdXN0aW5fY19yb3VuZHMvR2QyUzIvbGlnaHQvXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0cyhsaW5lMVN0YXJ0WCwgbGluZTFTdGFydFksIGxpbmUxRW5kWCwgbGluZTFFbmRZLCBsaW5lMlN0YXJ0WCwgbGluZTJTdGFydFksIGxpbmUyRW5kWCwgbGluZTJFbmRZKSB7XG4gICAgLy8gaWYgdGhlIGxpbmVzIGludGVyc2VjdCwgdGhlIHJlc3VsdCBjb250YWlucyB0aGUgeCBhbmQgeSBvZiB0aGUgaW50ZXJzZWN0aW9uICh0cmVhdGluZyB0aGUgbGluZXMgYXMgaW5maW5pdGUpIGFuZCBib29sZWFucyBmb3Igd2hldGhlciBsaW5lIHNlZ21lbnQgMSBvciBsaW5lIHNlZ21lbnQgMiBjb250YWluIHRoZSBwb2ludFxuICAgIHZhciBkZW5vbWluYXRvciwgYSwgYiwgbnVtZXJhdG9yMSwgbnVtZXJhdG9yMixcbiAgICAgICAgcmVzdWx0ID0ge1xuICAgICAgICAgICAgeDogbnVsbCxcbiAgICAgICAgICAgIHk6IG51bGwsXG4gICAgICAgICAgICBvbkxpbmUxOiBmYWxzZSxcbiAgICAgICAgICAgIG9uTGluZTI6IGZhbHNlXG4gICAgICAgIH07XG4gICAgZGVub21pbmF0b3IgPSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpIC0gKChsaW5lMkVuZFggLSBsaW5lMlN0YXJ0WCkgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgaWYgKHJlc3VsdC54ICE9PSBudWxsICYmIHJlc3VsdC55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEgPSBsaW5lMVN0YXJ0WSAtIGxpbmUyU3RhcnRZO1xuICAgIGIgPSBsaW5lMVN0YXJ0WCAtIGxpbmUyU3RhcnRYO1xuICAgIG51bWVyYXRvcjEgPSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIGEpIC0gKChsaW5lMkVuZFkgLSBsaW5lMlN0YXJ0WSkgKiBiKTtcbiAgICBudW1lcmF0b3IyID0gKChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkgKiBhKSAtICgobGluZTFFbmRZIC0gbGluZTFTdGFydFkpICogYik7XG4gICAgYSA9IG51bWVyYXRvcjEgLyBkZW5vbWluYXRvcjtcbiAgICBiID0gbnVtZXJhdG9yMiAvIGRlbm9taW5hdG9yO1xuXG4gICAgLy8gaWYgd2UgY2FzdCB0aGVzZSBsaW5lcyBpbmZpbml0ZWx5IGluIGJvdGggZGlyZWN0aW9ucywgdGhleSBpbnRlcnNlY3QgaGVyZTpcbiAgICByZXN1bHQueCA9IGxpbmUxU3RhcnRYICsgKGEgKiAobGluZTFFbmRYIC0gbGluZTFTdGFydFgpKTtcbiAgICByZXN1bHQueSA9IGxpbmUxU3RhcnRZICsgKGEgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcblxuICAgIC8vIGlmIGxpbmUxIGlzIGEgc2VnbWVudCBhbmQgbGluZTIgaXMgaW5maW5pdGUsIHRoZXkgaW50ZXJzZWN0IGlmOlxuICAgIGlmIChhID49IDAgJiYgYSA8PSAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUxID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTIgaXMgYSBzZWdtZW50IGFuZCBsaW5lMSBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGIgPj0gMCAmJiBiIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0Lm9uTGluZTIgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBpZiBsaW5lMSBhbmQgbGluZTIgYXJlIHNlZ21lbnRzLCB0aGV5IGludGVyc2VjdCBpZiBib3RoIG9mIHRoZSBhYm92ZSBhcmUgdHJ1ZVxuICAgIGlmIChyZXN1bHQub25MaW5lMSAmJiByZXN1bHQub25MaW5lMikge1xuICAgICAgICByZXR1cm4gW3Jlc3VsdC54LCByZXN1bHQueV07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbn1cbiIsInZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIExpbmVTdHJpbmd8bGluZX0gYW5kIG1lYXN1cmVzIGl0cyBsZW5ndGggaW4gdGhlIHNwZWNpZmllZCB1bml0cy5cbiAqXG4gKiBAbmFtZSBsaW5lRGlzdGFuY2VcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZSBsaW5lIHRvIG1lYXN1cmVcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGxlbmd0aCBvZiB0aGUgaW5wdXQgbGluZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgWy03Ny4wMzE2NjksIDM4Ljg3ODYwNV0sXG4gKiAgICAgICBbLTc3LjAyOTYwOSwgMzguODgxOTQ2XSxcbiAqICAgICAgIFstNzcuMDIwMzM5LCAzOC44ODQwODRdLFxuICogICAgICAgWy03Ny4wMjU2NjEsIDM4Ljg4NTgyMV0sXG4gKiAgICAgICBbLTc3LjAyMTg4NCwgMzguODg5NTYzXSxcbiAqICAgICAgIFstNzcuMDE5ODI0LCAzOC44OTIzNjhdXG4gKiAgICAgXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBsZW5ndGggPSB0dXJmLmxpbmVEaXN0YW5jZShsaW5lLCAnbWlsZXMnKTtcbiAqXG4gKiAvLz1saW5lXG4gKlxuICogLy89bGVuZ3RoXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGluZURpc3RhbmNlKGxpbmUsIHVuaXRzKSB7XG4gICAgaWYgKGxpbmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICByZXR1cm4gbGluZS5mZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24gKG1lbW8sIGZlYXR1cmUpIHtcbiAgICAgICAgICAgIHJldHVybiBtZW1vICsgbGluZURpc3RhbmNlKGZlYXR1cmUsIHVuaXRzKTtcbiAgICAgICAgfSwgMCk7XG4gICAgfVxuXG4gICAgdmFyIGdlb21ldHJ5ID0gbGluZS50eXBlID09PSAnRmVhdHVyZScgPyBsaW5lLmdlb21ldHJ5IDogbGluZTtcbiAgICB2YXIgZCwgaTtcblxuICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aChnZW9tZXRyeS5jb29yZGluYXRlcywgdW5pdHMpO1xuICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIGQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGQgKz0gbGVuZ3RoKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldLCB1bml0cyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIGlmIChsaW5lLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgIGQgPSAwO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICBkICs9IGxlbmd0aChnZW9tZXRyeS5jb29yZGluYXRlc1tpXVtqXSwgdW5pdHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBhIExpbmVTdHJpbmcsIE11bHRpTGluZVN0cmluZywgJyArXG4gICAgICAgICAgICAnUG9seWdvbiwgb3IgTXVsdGlQb2x5Z29uIEZlYXR1cmUgb3IgR2VvbWV0cnkgKG9yIGEgRmVhdHVyZUNvbGxlY3Rpb24gJyArXG4gICAgICAgICAgICAnY29udGFpbmluZyBvbmx5IHRob3NlIHR5cGVzKScpO1xuICAgIH1cblxufTtcblxuZnVuY3Rpb24gbGVuZ3RoKGNvb3JkcywgdW5pdHMpIHtcbiAgICB2YXIgdHJhdmVsbGVkID0gMDtcbiAgICB2YXIgcHJldkNvb3JkcyA9IHBvaW50KGNvb3Jkc1swXSk7XG4gICAgdmFyIGN1ckNvb3JkcyA9IHBvaW50KGNvb3Jkc1swXSk7XG4gICAgdmFyIHRlbXA7XG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBjb29yZHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3VyQ29vcmRzLmdlb21ldHJ5LmNvb3JkaW5hdGVzID0gY29vcmRzW2ldO1xuICAgICAgICB0cmF2ZWxsZWQgKz0gZGlzdGFuY2UocHJldkNvb3JkcywgY3VyQ29vcmRzLCB1bml0cyk7XG4gICAgICAgIHRlbXAgPSBwcmV2Q29vcmRzO1xuICAgICAgICBwcmV2Q29vcmRzID0gY3VyQ29vcmRzO1xuICAgICAgICBjdXJDb29yZHMgPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gdHJhdmVsbGVkO1xufVxuIiwidmFyIGxpbmVzdHJpbmcgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5saW5lU3RyaW5nO1xudmFyIHBvaW50T25MaW5lID0gcmVxdWlyZSgndHVyZi1wb2ludC1vbi1saW5lJyk7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgTGluZVN0cmluZ3xsaW5lfSwgYSBzdGFydCB7QGxpbmsgUG9pbnR9LCBhbmQgYSBzdG9wIHBvaW50XG4gKiBhbmQgcmV0dXJucyBhIHN1YnNlY3Rpb24gb2YgdGhlIGxpbmUgaW4tYmV0d2VlbiB0aG9zZSBwb2ludHMuXG4gKiBUaGUgc3RhcnQgJiBzdG9wIHBvaW50cyBkb24ndCBuZWVkIHRvIGZhbGwgZXhhY3RseSBvbiB0aGUgbGluZS5cbiAqXG4gKiBUaGlzIGNhbiBiZSB1c2VmdWwgZm9yIGV4dHJhY3Rpbmcgb25seSB0aGUgcGFydCBvZiBhIHJvdXRlIGJldHdlZW4gd2F5cG9pbnRzLlxuICpcbiAqIEBuYW1lIGxpbmVTbGljZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQxIHN0YXJ0aW5nIHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBwb2ludDIgc3RvcHBpbmcgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPnxMaW5lU3RyaW5nfSBsaW5lIGxpbmUgdG8gc2xpY2VcbiAqIEByZXR1cm4ge0ZlYXR1cmU8TGluZVN0cmluZz59IHNsaWNlZCBsaW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgc3RhcnQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl1cbiAqICAgfVxuICogfTtcbiAqIHZhciBzdG9wID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzcuMDIxODg0LCAzOC44ODk1NjNdXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIHNsaWNlZCA9IHR1cmYubGluZVNsaWNlKHN0YXJ0LCBzdG9wLCBsaW5lKTtcbiAqXG4gKiAvLz1saW5lXG4gKlxuICogLy89c2xpY2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5lU2xpY2Uoc3RhcnRQdCwgc3RvcFB0LCBsaW5lKSB7XG4gICAgdmFyIGNvb3JkcztcbiAgICBpZiAobGluZS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29vcmRzID0gbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB9IGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIGNvb3JkcyA9IGxpbmUuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZyBGZWF0dXJlIG9yIEdlb21ldHJ5Jyk7XG4gICAgfVxuXG4gICAgdmFyIHN0YXJ0VmVydGV4ID0gcG9pbnRPbkxpbmUobGluZSwgc3RhcnRQdCk7XG4gICAgdmFyIHN0b3BWZXJ0ZXggPSBwb2ludE9uTGluZShsaW5lLCBzdG9wUHQpO1xuICAgIHZhciBlbmRzO1xuICAgIGlmIChzdGFydFZlcnRleC5wcm9wZXJ0aWVzLmluZGV4IDw9IHN0b3BWZXJ0ZXgucHJvcGVydGllcy5pbmRleCkge1xuICAgICAgICBlbmRzID0gW3N0YXJ0VmVydGV4LCBzdG9wVmVydGV4XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBlbmRzID0gW3N0b3BWZXJ0ZXgsIHN0YXJ0VmVydGV4XTtcbiAgICB9XG4gICAgdmFyIGNsaXBMaW5lID0gbGluZXN0cmluZyhbZW5kc1swXS5nZW9tZXRyeS5jb29yZGluYXRlc10sIHt9KTtcbiAgICBmb3IgKHZhciBpID0gZW5kc1swXS5wcm9wZXJ0aWVzLmluZGV4ICsgMTsgaSA8IGVuZHNbMV0ucHJvcGVydGllcy5pbmRleCArIDE7IGkrKykge1xuICAgICAgICBjbGlwTGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5wdXNoKGNvb3Jkc1tpXSk7XG4gICAgfVxuICAgIGNsaXBMaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnB1c2goZW5kc1sxXS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgcmV0dXJuIGNsaXBMaW5lO1xufTtcbiIsIi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzICh2YWx1ZSlcbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVXcmFwQ29vcmQgd2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxuICogdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ1BvaW50JywgY29vcmRpbmF0ZXM6IFswLCAwXSB9O1xuICogY29vcmRFYWNoKHBvaW50LCBmdW5jdGlvbihjb29yZHMpIHtcbiAqICAgLy8gY29vcmRzIGlzIGVxdWFsIHRvIFswLCAwXVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChsYXllciwgY2FsbGJhY2ssIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICB2YXIgaSwgaiwgaywgZywgbCwgZ2VvbWV0cnksIHN0b3BHLCBjb29yZHMsXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLFxuICAgICAgICB3cmFwU2hyaW5rID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSBsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSBsYXllci50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gbGF5ZXIuZmVhdHVyZXMubGVuZ3RoIDogMTtcblxuICAvLyBUaGlzIGxvZ2ljIG1heSBsb29rIGEgbGl0dGxlIHdlaXJkLiBUaGUgcmVhc29uIHdoeSBpdCBpcyB0aGF0IHdheVxuICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgLy8gb2Ygb2JqZWN0cyBhdCBpdHMgcm9vdDogRmVhdHVyZUNvbGxlY3Rpb24sIEZlYXR1cmVzLCBHZW9tZXRyaWVzLlxuICAvLyBUaGlzIGZ1bmN0aW9uIGhhcyB0aGUgcmVzcG9uc2liaWxpdHkgb2YgaGFuZGxpbmcgYWxsIG9mIHRoZW0sIGFuZCB0aGF0XG4gIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gIC8vIHRvIGNlcnRhaW4gaW5wdXRzLiBGb3IgaW5zdGFuY2UsIGlmIHlvdSBnaXZlIHRoaXMganVzdCBhXG4gIC8vIFBvaW50IGdlb21ldHJ5LCB0aGVuIGJvdGggbG9vcHMgYXJlIHNob3J0LWNpcmN1aXRlZCBhbmQgYWxsIHdlIGRvXG4gIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gIC8vXG4gIC8vIFRoaXMgYWxzbyBhaW1zIHRvIGFsbG9jYXRlIGFzIGZldyByZXNvdXJjZXMgYXMgcG9zc2libGU6IGp1c3QgYVxuICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gIC8vIGJlIHJlcXVpcmVkIHdpdGggdGhlIG5vcm1hbGl6YXRpb24gYXBwcm9hY2guXG4gICAgZm9yIChpID0gMDsgaSA8IHN0b3A7IGkrKykge1xuXG4gICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlc1tpXS5nZW9tZXRyeSA6XG4gICAgICAgIChpc0ZlYXR1cmUgPyBsYXllci5nZW9tZXRyeSA6IGxheWVyKSk7XG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbic7XG4gICAgICAgIHN0b3BHID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzLmxlbmd0aCA6IDE7XG5cbiAgICAgICAgZm9yIChnID0gMDsgZyA8IHN0b3BHOyBnKyspIHtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuICAgICAgICAgICAgY29vcmRzID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG5cbiAgICAgICAgICAgIHdyYXBTaHJpbmsgPSAoZXhjbHVkZVdyYXBDb29yZCAmJlxuICAgICAgICAgICAgICAgIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpKSA/XG4gICAgICAgICAgICAgICAgMSA6IDA7XG5cbiAgICAgICAgICAgIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvaW50Jykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIGNhbGxiYWNrKGNvb3Jkc1tqXSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoIC0gd3JhcFNocmluazsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgY29vcmRzLmxlbmd0aDsgaisrKVxuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aDsgaysrKVxuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChsID0gMDsgbCA8IGNvb3Jkc1tqXVtrXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBsKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2soY29vcmRzW2pdW2tdW2xdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb21ldHJ5IFR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmNvb3JkRWFjaCA9IGNvb3JkRWFjaDtcblxuLyoqXG4gKiBSZWR1Y2UgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgY29vcmRpbmF0ZXMgaXMgdW5uZWNlc3NhcnkuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAobWVtbywgdmFsdWUpIGFuZCByZXR1cm5zXG4gKiBhIG5ldyBtZW1vXG4gKiBAcGFyYW0geyp9IG1lbW8gdGhlIHN0YXJ0aW5nIHZhbHVlIG9mIG1lbW86IGNhbiBiZSBhbnkgdHlwZS5cbiAqIEBwYXJhbSB7Ym9vbGVhbj19IGV4Y2x1ZGVXcmFwQ29vcmQgd2hldGhlciBvciBub3QgdG8gaW5jbHVkZVxuICogdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybiB7Kn0gY29tYmluZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UobGF5ZXIsIGNhbGxiYWNrLCBtZW1vLCBleGNsdWRlV3JhcENvb3JkKSB7XG4gICAgY29vcmRFYWNoKGxheWVyLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIGNvb3JkKTtcbiAgICB9LCBleGNsdWRlV3JhcENvb3JkKTtcbiAgICByZXR1cm4gbWVtbztcbn1cbm1vZHVsZS5leHBvcnRzLmNvb3JkUmVkdWNlID0gY29vcmRSZWR1Y2U7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIHByb3BlcnR5IG9iamVjdHMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHZhbHVlKVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHsgdHlwZTogJ0ZlYXR1cmUnLCBnZW9tZXRyeTogbnVsbCwgcHJvcGVydGllczogeyBmb286IDEgfSB9O1xuICogcHJvcEVhY2gocG9pbnQsIGZ1bmN0aW9uKHByb3BzKSB7XG4gKiAgIC8vIHByb3BzIGlzIGVxdWFsIHRvIHsgZm9vOiAxfVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BFYWNoKGxheWVyLCBjYWxsYmFjaykge1xuICAgIHZhciBpO1xuICAgIHN3aXRjaCAobGF5ZXIudHlwZSkge1xuICAgIGNhc2UgJ0ZlYXR1cmVDb2xsZWN0aW9uJzpcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IGxheWVyLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhsYXllci5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgY2FsbGJhY2sobGF5ZXIucHJvcGVydGllcyk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLnByb3BFYWNoID0gcHJvcEVhY2g7XG5cbi8qKlxuICogUmVkdWNlIHByb3BlcnRpZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0IGludG8gYSBzaW5nbGUgdmFsdWUsXG4gKiBzaW1pbGFyIHRvIGhvdyBBcnJheS5yZWR1Y2Ugd29ya3MuIEhvd2V2ZXIsIGluIHRoaXMgY2FzZSB3ZSBsYXppbHkgcnVuXG4gKiB0aGUgcmVkdWN0aW9uLCBzbyBhbiBhcnJheSBvZiBhbGwgcHJvcGVydGllcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChtZW1vLCBjb29yZCkgYW5kIHJldHVybnNcbiAqIGEgbmV3IG1lbW9cbiAqIEBwYXJhbSB7Kn0gbWVtbyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgbWVtbzogY2FuIGJlIGFueSB0eXBlLlxuICogQHJldHVybiB7Kn0gY29tYmluZWQgdmFsdWVcbiAqL1xuZnVuY3Rpb24gcHJvcFJlZHVjZShsYXllciwgY2FsbGJhY2ssIG1lbW8pIHtcbiAgICBwcm9wRWFjaChsYXllciwgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgbWVtbyA9IGNhbGxiYWNrKG1lbW8sIHByb3ApO1xuICAgIH0pO1xuICAgIHJldHVybiBtZW1vO1xufVxubW9kdWxlLmV4cG9ydHMucHJvcFJlZHVjZSA9IHByb3BSZWR1Y2U7XG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0b1xuICogQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzICh2YWx1ZSlcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZSA9IHsgdHlwZTogJ0ZlYXR1cmUnLCBnZW9tZXRyeTogbnVsbCwgcHJvcGVydGllczoge30gfTtcbiAqIGZlYXR1cmVFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uKGZlYXR1cmUpIHtcbiAqICAgLy8gZmVhdHVyZSA9PSBmZWF0dXJlXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUVhY2gobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGxheWVyLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjYWxsYmFjayhsYXllcik7XG4gICAgfSBlbHNlIGlmIChsYXllci50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF5ZXIuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyLmZlYXR1cmVzW2ldKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVFYWNoID0gZmVhdHVyZUVhY2g7XG5cbi8qKlxuICogR2V0IGFsbCBjb29yZGluYXRlcyBmcm9tIGFueSBHZW9KU09OIG9iamVjdCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGNvb3JkaW5hdGVcbiAqIGFycmF5cy5cbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm4ge0FycmF5PEFycmF5PE51bWJlcj4+fSBjb29yZGluYXRlIHBvc2l0aW9uIGFycmF5XG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGxheWVyKSB7XG4gICAgdmFyIGNvb3JkcyA9IFtdO1xuICAgIGNvb3JkRWFjaChsYXllciwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGNvb3Jkcy5wdXNoKGNvb3JkKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY29vcmRzO1xufVxubW9kdWxlLmV4cG9ydHMuY29vcmRBbGwgPSBjb29yZEFsbDtcbiIsInZhciBiZWFyaW5nID0gcmVxdWlyZSgndHVyZi1iZWFyaW5nJyk7XG52YXIgZGVzdGluYXRpb24gPSByZXF1aXJlKCd0dXJmLWRlc3RpbmF0aW9uJyk7XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG5cbi8qKlxuICogVGFrZXMgdHdvIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCByZXR1cm5zIGEgcG9pbnQgbWlkd2F5IGJldHdlZW4gdGhlbS5cbiAqIFRoZSBtaWRwb2ludCBpcyBjYWxjdWxhdGVkIGdlb2Rlc2ljYWxseSwgbWVhbmluZyB0aGUgY3VydmF0dXJlIG9mIHRoZSBlYXJ0aCBpcyB0YWtlbiBpbnRvIGFjY291bnQuXG4gKlxuICogQG5hbWUgbWlkcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGZyb20gZmlyc3QgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHRvIHNlY29uZCBwb2ludFxuICogQHJldHVybiB7RmVhdHVyZTxQb2ludD59IGEgcG9pbnQgbWlkd2F5IGJldHdlZW4gYHB0MWAgYW5kIGBwdDJgXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbMTQ0LjgzNDgyMywgLTM3Ljc3MTI1N11cbiAqICAgfVxuICogfTtcbiAqIHZhciBwdDIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzE0NS4xNDI0NCwgLTM3LjgzMDkzN11cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgbWlkcG9pbnRlZCA9IHR1cmYubWlkcG9pbnQocHQxLCBwdDIpO1xuICogbWlkcG9pbnRlZC5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjZjAwJztcbiAqXG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcHQxLCBwdDIsIG1pZHBvaW50ZWRdXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tLCB0bykge1xuICAgIHZhciBkaXN0ID0gZGlzdGFuY2UoZnJvbSwgdG8sICdtaWxlcycpO1xuICAgIHZhciBoZWFkaW5nID0gYmVhcmluZyhmcm9tLCB0byk7XG4gICAgdmFyIG1pZHBvaW50ID0gZGVzdGluYXRpb24oZnJvbSwgZGlzdCAvIDIsIGhlYWRpbmcsICdtaWxlcycpO1xuXG4gICAgcmV0dXJuIG1pZHBvaW50O1xufTtcbiIsInZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHJlZmVyZW5jZSB7QGxpbmsgUG9pbnR8cG9pbnR9IGFuZCBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIEZlYXR1cmVzXG4gKiB3aXRoIFBvaW50IGdlb21ldHJpZXMgYW5kIHJldHVybnMgdGhlXG4gKiBwb2ludCBmcm9tIHRoZSBGZWF0dXJlQ29sbGVjdGlvbiBjbG9zZXN0IHRvIHRoZSByZWZlcmVuY2UuIFRoaXMgY2FsY3VsYXRpb25cbiAqIGlzIGdlb2Rlc2ljLlxuICpcbiAqIEBuYW1lIG5lYXJlc3RcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHRhcmdldFBvaW50IHRoZSByZWZlcmVuY2UgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgYWdhaW5zdCBpbnB1dCBwb2ludCBzZXRcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9pbnQ+fSB0aGUgY2xvc2VzdCBwb2ludCBpbiB0aGUgc2V0IHRvIHRoZSByZWZlcmVuY2UgcG9pbnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcIm1hcmtlci1jb2xvclwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWzI4Ljk2NTc5NywgNDEuMDEwMDg2XVxuICogICB9XG4gKiB9O1xuICogdmFyIGFnYWluc3QgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyOC45NzM4NjUsIDQxLjAxMTEyMl1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjguOTQ4NDU5LCA0MS4wMjQyMDRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI4LjkzODY3NCwgNDEuMDEzMzI0XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgbmVhcmVzdCA9IHR1cmYubmVhcmVzdChwb2ludCwgYWdhaW5zdCk7XG4gKiBuZWFyZXN0LnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyNmMDAnO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGFnYWluc3QuZmVhdHVyZXMuY29uY2F0KHBvaW50KTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldFBvaW50LCBwb2ludHMpIHtcbiAgICB2YXIgbmVhcmVzdFBvaW50LCBtaW5EaXN0ID0gSW5maW5pdHk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGRpc3RhbmNlVG9Qb2ludCA9IGRpc3RhbmNlKHRhcmdldFBvaW50LCBwb2ludHMuZmVhdHVyZXNbaV0sICdtaWxlcycpO1xuICAgICAgICBpZiAoZGlzdGFuY2VUb1BvaW50IDwgbWluRGlzdCkge1xuICAgICAgICAgICAgbmVhcmVzdFBvaW50ID0gcG9pbnRzLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgbWluRGlzdCA9IGRpc3RhbmNlVG9Qb2ludDtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbmVhcmVzdFBvaW50O1xufTtcbiIsIi8qKlxuICogVGFrZXMgYSB0cmlhbmd1bGFyIHBsYW5lIGFzIGEge0BsaW5rIFBvbHlnb259XG4gKiBhbmQgYSB7QGxpbmsgUG9pbnR9IHdpdGhpbiB0aGF0IHRyaWFuZ2xlIGFuZCByZXR1cm5zIHRoZSB6LXZhbHVlXG4gKiBhdCB0aGF0IHBvaW50LiBUaGUgUG9seWdvbiBuZWVkcyB0byBoYXZlIHByb3BlcnRpZXMgYGFgLCBgYmAsIGFuZCBgY2BcbiAqIHRoYXQgZGVmaW5lIHRoZSB2YWx1ZXMgYXQgaXRzIHRocmVlIGNvcm5lcnMuXG4gKlxuICogQG5hbWUgcGxhbmVwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgdGhlIFBvaW50IGZvciB3aGljaCBhIHotdmFsdWUgd2lsbCBiZSBjYWxjdWxhdGVkXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHRyaWFuZ2xlIGEgUG9seWdvbiBmZWF0dXJlIHdpdGggdGhyZWUgdmVydGljZXNcbiAqIEByZXR1cm4ge051bWJlcn0gdGhlIHotdmFsdWUgZm9yIGBpbnRlcnBvbGF0ZWRQb2ludGBcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS4zMjIxLCAzOS41MjldXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFstNzUuMzIyMSwgMzkuNTI5XSk7XG4gKiAvLyB0cmlhbmdsZSBpcyBhIHBvbHlnb24gd2l0aCBcImFcIiwgXCJiXCIsXG4gKiAvLyBhbmQgXCJjXCIgdmFsdWVzIHJlcHJlc2VudGluZ1xuICogLy8gdGhlIHZhbHVlcyBvZiB0aGUgY29vcmRpbmF0ZXMgaW4gb3JkZXIuXG4gKiB2YXIgdHJpYW5nbGUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImFcIjogMTEsXG4gKiAgICAgXCJiXCI6IDEyMixcbiAqICAgICBcImNcIjogNDRcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstNzUuMTIyMSwgMzkuNTddLFxuICogICAgICAgWy03NS41OCwgMzkuMThdLFxuICogICAgICAgWy03NS45NywgMzkuODZdLFxuICogICAgICAgWy03NS4xMjIxLCAzOS41N11cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbdHJpYW5nbGUsIHBvaW50XVxuICogfTtcbiAqXG4gKiB2YXIgelZhbHVlID0gdHVyZi5wbGFuZXBvaW50KHBvaW50LCB0cmlhbmdsZSk7XG4gKlxuICogLy89ZmVhdHVyZXNcbiAqXG4gKiAvLz16VmFsdWVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnQsIHRyaWFuZ2xlKSB7XG4gICAgdmFyIHggPSBwb2ludC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgeSA9IHBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxuICAgICAgICB4MSA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdWzBdLFxuICAgICAgICB5MSA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzBdWzFdLFxuICAgICAgICB6MSA9IHRyaWFuZ2xlLnByb3BlcnRpZXMuYSxcbiAgICAgICAgeDIgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXVswXSxcbiAgICAgICAgeTIgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsxXVsxXSxcbiAgICAgICAgejIgPSB0cmlhbmdsZS5wcm9wZXJ0aWVzLmIsXG4gICAgICAgIHgzID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMl1bMF0sXG4gICAgICAgIHkzID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMl1bMV0sXG4gICAgICAgIHozID0gdHJpYW5nbGUucHJvcGVydGllcy5jO1xuXG4gICAgdmFyIHogPSAoejMgKiAoeCAtIHgxKSAqICh5IC0geTIpICsgejEgKiAoeCAtIHgyKSAqICh5IC0geTMpICsgejIgKiAoeCAtIHgzKSAqICh5IC0geTEpIC1cbiAgICAgIHoyICogKHggLSB4MSkgKiAoeSAtIHkzKSAtIHozICogKHggLSB4MikgKiAoeSAtIHkxKSAtIHoxICogKHggLSB4MykgKiAoeSAtIHkyKSkgL1xuICAgICAgKCh4IC0geDEpICogKHkgLSB5MikgKyAoeCAtIHgyKSAqICh5IC0geTMpICsgKHggLSB4MykgKiAoeSAtIHkxKSAtXG4gICAgICAgKHggLSB4MSkgKiAoeSAtIHkzKSAtICh4IC0geDIpICogKHkgLSB5MSkgLSAoeCAtIHgzKSAqICh5IC0geTIpKTtcblxuICAgIHJldHVybiB6O1xufTtcbiIsInZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xudmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBhIGNlbGwgZGVwdGggYW5kIHJldHVybnMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gaW4gYSBncmlkLlxuICpcbiAqIEBuYW1lIHBvaW50R3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSB0aGUgZGlzdGFuY2UgYWNyb3NzIGVhY2ggY2VsbFxuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSB1c2VkIGluIGNhbGN1bGF0aW5nIGNlbGxXaWR0aCwgY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IGdyaWQgb2YgcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dGVudCA9IFstNzAuODIzMzY0LCAtMzMuNTUzOTg0LCAtNzAuNDczMTc1LCAtMzMuMzAyOTg2XTtcbiAqIHZhciBjZWxsV2lkdGggPSAzO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgZ3JpZCA9IHR1cmYucG9pbnRHcmlkKGV4dGVudCwgY2VsbFdpZHRoLCB1bml0cyk7XG4gKlxuICogLy89Z3JpZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBvaW50R3JpZChiYm94LCBjZWxsU2l6ZSwgdW5pdHMpIHtcbiAgICB2YXIgZmMgPSBmZWF0dXJlY29sbGVjdGlvbihbXSk7XG4gICAgdmFyIHhGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzJdLCBiYm94WzFdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxXaWR0aCA9IHhGcmFjdGlvbiAqIChiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdmFyIHlGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzBdLCBiYm94WzNdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAoYmJveFszXSAtIGJib3hbMV0pO1xuXG4gICAgdmFyIGN1cnJlbnRYID0gYmJveFswXTtcbiAgICB3aGlsZSAoY3VycmVudFggPD0gYmJveFsyXSkge1xuICAgICAgICB2YXIgY3VycmVudFkgPSBiYm94WzFdO1xuICAgICAgICB3aGlsZSAoY3VycmVudFkgPD0gYmJveFszXSkge1xuICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2ludChbY3VycmVudFgsIGN1cnJlbnRZXSkpO1xuXG4gICAgICAgICAgICBjdXJyZW50WSArPSBjZWxsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRYICs9IGNlbGxXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmM7XG59O1xuIiwidmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG52YXIgYmVhcmluZyA9IHJlcXVpcmUoJ3R1cmYtYmVhcmluZycpO1xudmFyIGRlc3RpbmF0aW9uID0gcmVxdWlyZSgndHVyZi1kZXN0aW5hdGlvbicpO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIFBvaW50fSBhbmQgYSB7QGxpbmsgTGluZVN0cmluZ30gYW5kIGNhbGN1bGF0ZXMgdGhlIGNsb3Nlc3QgUG9pbnQgb24gdGhlIExpbmVTdHJpbmcuXG4gKlxuICogQG5hbWUgcG9pbnRPbkxpbmVcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZSBsaW5lIHRvIHNuYXAgdG9cbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHBvaW50IHBvaW50IHRvIHNuYXAgZnJvbVxuICogQHJldHVybiB7RmVhdHVyZTxQb2ludD59IGNsb3Nlc3QgcG9pbnQgb24gdGhlIGBsaW5lYCB0byBgcG9pbnRgXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03Ny4wMzcwNzYsIDM4Ljg4NDAxN11cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgc25hcHBlZCA9IHR1cmYucG9pbnRPbkxpbmUobGluZSwgcHQpO1xuICogc25hcHBlZC5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjMDBmJ1xuICpcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW2xpbmUsIHB0LCBzbmFwcGVkXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaW5lLCBwdCkge1xuICAgIHZhciBjb29yZHM7XG4gICAgaWYgKGxpbmUudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNvb3JkcyA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIGlmIChsaW5lLnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICBjb29yZHMgPSBsaW5lLmNvb3JkaW5hdGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBhIExpbmVTdHJpbmcgRmVhdHVyZSBvciBHZW9tZXRyeScpO1xuICAgIH1cblxuICAgIHJldHVybiBwb2ludE9uTGluZShwdCwgY29vcmRzKTtcbn07XG5cbmZ1bmN0aW9uIHBvaW50T25MaW5lKHB0LCBjb29yZHMpIHtcbiAgICB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICAgIHZhciBjbG9zZXN0UHQgPSBwb2ludChbSW5maW5pdHksIEluZmluaXR5XSwge1xuICAgICAgICBkaXN0OiBJbmZpbml0eVxuICAgIH0pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICB2YXIgc3RhcnQgPSBwb2ludChjb29yZHNbaV0pO1xuICAgICAgICB2YXIgc3RvcCA9IHBvaW50KGNvb3Jkc1tpICsgMV0pO1xuICAgICAgICAvL3N0YXJ0XG4gICAgICAgIHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlKHB0LCBzdGFydCwgdW5pdHMpO1xuICAgICAgICAvL3N0b3BcbiAgICAgICAgc3RvcC5wcm9wZXJ0aWVzLmRpc3QgPSBkaXN0YW5jZShwdCwgc3RvcCwgdW5pdHMpO1xuICAgICAgICAvL3BlcnBlbmRpY3VsYXJcbiAgICAgICAgdmFyIGhlaWdodERpc3RhbmNlID0gTWF0aC5tYXgoc3RhcnQucHJvcGVydGllcy5kaXN0LCBzdG9wLnByb3BlcnRpZXMuZGlzdCk7XG4gICAgICAgIHZhciBkaXJlY3Rpb24gPSBiZWFyaW5nKHN0YXJ0LCBzdG9wKTtcbiAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJQdDEgPSBkZXN0aW5hdGlvbihwdCwgaGVpZ2h0RGlzdGFuY2UsIGRpcmVjdGlvbiArIDkwLCB1bml0cyk7XG4gICAgICAgIHZhciBwZXJwZW5kaWN1bGFyUHQyID0gZGVzdGluYXRpb24ocHQsIGhlaWdodERpc3RhbmNlLCBkaXJlY3Rpb24gLSA5MCwgdW5pdHMpO1xuICAgICAgICB2YXIgaW50ZXJzZWN0ID0gbGluZUludGVyc2VjdHMoXG4gICAgICAgIHBlcnBlbmRpY3VsYXJQdDEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIHBlcnBlbmRpY3VsYXJQdDEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgIHBlcnBlbmRpY3VsYXJQdDIuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIHBlcnBlbmRpY3VsYXJQdDIuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgIHN0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICBzdGFydC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgc3RvcC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgc3RvcC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXVxuICAgICAgICApO1xuICAgICAgICB2YXIgaW50ZXJzZWN0UHQ7XG4gICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgIGludGVyc2VjdFB0ID0gcG9pbnQoaW50ZXJzZWN0KTtcbiAgICAgICAgICAgIGludGVyc2VjdFB0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlKHB0LCBpbnRlcnNlY3RQdCwgdW5pdHMpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RQdCA9IHN0YXJ0O1xuICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMuaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdG9wLnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RQdCA9IHN0b3A7XG4gICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVyc2VjdFB0ICYmIGludGVyc2VjdFB0LnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgIGNsb3Nlc3RQdCA9IGludGVyc2VjdFB0O1xuICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMuaW5kZXggPSBpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIGNsb3Nlc3RQdDtcbn1cblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwOi8vanNmaWRkbGUubmV0L2p1c3Rpbl9jX3JvdW5kcy9HZDJTMi9saWdodC9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzKGxpbmUxU3RhcnRYLCBsaW5lMVN0YXJ0WSwgbGluZTFFbmRYLCBsaW5lMUVuZFksIGxpbmUyU3RhcnRYLCBsaW5lMlN0YXJ0WSwgbGluZTJFbmRYLCBsaW5lMkVuZFkpIHtcbiAgICAvLyBpZiB0aGUgbGluZXMgaW50ZXJzZWN0LCB0aGUgcmVzdWx0IGNvbnRhaW5zIHRoZSB4IGFuZCB5IG9mIHRoZSBpbnRlcnNlY3Rpb24gKHRyZWF0aW5nIHRoZSBsaW5lcyBhcyBpbmZpbml0ZSkgYW5kIGJvb2xlYW5zIGZvciB3aGV0aGVyIGxpbmUgc2VnbWVudCAxIG9yIGxpbmUgc2VnbWVudCAyIGNvbnRhaW4gdGhlIHBvaW50XG4gICAgdmFyIGRlbm9taW5hdG9yLCBhLCBiLCBudW1lcmF0b3IxLCBudW1lcmF0b3IyO1xuICAgIHZhciByZXN1bHQgPSB7XG4gICAgICAgIHg6IG51bGwsXG4gICAgICAgIHk6IG51bGwsXG4gICAgICAgIG9uTGluZTE6IGZhbHNlLFxuICAgICAgICBvbkxpbmUyOiBmYWxzZVxuICAgIH07XG4gICAgZGVub21pbmF0b3IgPSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpIC0gKChsaW5lMkVuZFggLSBsaW5lMlN0YXJ0WCkgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcbiAgICBpZiAoZGVub21pbmF0b3IgPT09IDApIHtcbiAgICAgICAgaWYgKHJlc3VsdC54ICE9PSBudWxsICYmIHJlc3VsdC55ICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGEgPSBsaW5lMVN0YXJ0WSAtIGxpbmUyU3RhcnRZO1xuICAgIGIgPSBsaW5lMVN0YXJ0WCAtIGxpbmUyU3RhcnRYO1xuICAgIG51bWVyYXRvcjEgPSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIGEpIC0gKChsaW5lMkVuZFkgLSBsaW5lMlN0YXJ0WSkgKiBiKTtcbiAgICBudW1lcmF0b3IyID0gKChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkgKiBhKSAtICgobGluZTFFbmRZIC0gbGluZTFTdGFydFkpICogYik7XG4gICAgYSA9IG51bWVyYXRvcjEgLyBkZW5vbWluYXRvcjtcbiAgICBiID0gbnVtZXJhdG9yMiAvIGRlbm9taW5hdG9yO1xuXG4gICAgLy8gaWYgd2UgY2FzdCB0aGVzZSBsaW5lcyBpbmZpbml0ZWx5IGluIGJvdGggZGlyZWN0aW9ucywgdGhleSBpbnRlcnNlY3QgaGVyZTpcbiAgICByZXN1bHQueCA9IGxpbmUxU3RhcnRYICsgKGEgKiAobGluZTFFbmRYIC0gbGluZTFTdGFydFgpKTtcbiAgICByZXN1bHQueSA9IGxpbmUxU3RhcnRZICsgKGEgKiAobGluZTFFbmRZIC0gbGluZTFTdGFydFkpKTtcblxuICAgIC8vIGlmIGxpbmUxIGlzIGEgc2VnbWVudCBhbmQgbGluZTIgaXMgaW5maW5pdGUsIHRoZXkgaW50ZXJzZWN0IGlmOlxuICAgIGlmIChhID4gMCAmJiBhIDwgMSkge1xuICAgICAgICByZXN1bHQub25MaW5lMSA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlmIGxpbmUyIGlzIGEgc2VnbWVudCBhbmQgbGluZTEgaXMgaW5maW5pdGUsIHRoZXkgaW50ZXJzZWN0IGlmOlxuICAgIGlmIChiID4gMCAmJiBiIDwgMSkge1xuICAgICAgICByZXN1bHQub25MaW5lMiA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlmIGxpbmUxIGFuZCBsaW5lMiBhcmUgc2VnbWVudHMsIHRoZXkgaW50ZXJzZWN0IGlmIGJvdGggb2YgdGhlIGFib3ZlIGFyZSB0cnVlXG4gICAgaWYgKHJlc3VsdC5vbkxpbmUxICYmIHJlc3VsdC5vbkxpbmUyKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0LngsIHJlc3VsdC55XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwidmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgY2VudHJvaWQgPSByZXF1aXJlKCd0dXJmLWNlbnRlcicpO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xudmFyIGluc2lkZSA9IHJlcXVpcmUoJ3R1cmYtaW5zaWRlJyk7XG52YXIgZXhwbG9kZSA9IHJlcXVpcmUoJ3R1cmYtZXhwbG9kZScpO1xuXG4vKipcbiAqIFRha2VzIGEgZmVhdHVyZSBhbmQgcmV0dXJucyBhIHtAbGluayBQb2ludH0gZ3VhcmFudGVlZCB0byBiZSBvbiB0aGUgc3VyZmFjZSBvZiB0aGUgZmVhdHVyZS5cbiAqXG4gKiAqIEdpdmVuIGEge0BsaW5rIFBvbHlnb259LCB0aGUgcG9pbnQgd2lsbCBiZSBpbiB0aGUgYXJlYSBvZiB0aGUgcG9seWdvblxuICogKiBHaXZlbiBhIHtAbGluayBMaW5lU3RyaW5nfSwgdGhlIHBvaW50IHdpbGwgYmUgYWxvbmcgdGhlIHN0cmluZ1xuICogKiBHaXZlbiBhIHtAbGluayBQb2ludH0sIHRoZSBwb2ludCB3aWxsIHRoZSBzYW1lIGFzIHRoZSBpbnB1dFxuICpcbiAqIEBwYXJhbSB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBmYyBhbnkgZmVhdHVyZSBvciBzZXQgb2YgZmVhdHVyZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlfSBhIHBvaW50IG9uIHRoZSBzdXJmYWNlIG9mIGBpbnB1dGBcbiAqIEBleGFtcGxlXG4gKiAvLyBjcmVhdGUgYSByYW5kb20gcG9seWdvblxuICogdmFyIHBvbHlnb24gPSB0dXJmLnJhbmRvbSgncG9seWdvbicpO1xuICpcbiAqIC8vPXBvbHlnb25cbiAqXG4gKiB2YXIgcG9pbnRPblBvbHlnb24gPSB0dXJmLnBvaW50T25TdXJmYWNlKHBvbHlnb24pO1xuICpcbiogdmFyIHJlc3VsdEZlYXR1cmVzID0gcG9seWdvbi5mZWF0dXJlcy5jb25jYXQocG9pbnRPblBvbHlnb24pO1xuKiB2YXIgcmVzdWx0ID0ge1xuKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4qICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xuKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5mdW5jdGlvbiBwb2ludE9uU3VyZmFjZShmYykge1xuICAgIC8vIG5vcm1hbGl6ZVxuICAgIGlmIChmYy50eXBlICE9PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGlmIChmYy50eXBlICE9PSAnRmVhdHVyZScpIHtcbiAgICAgICAgICAgIGZjID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZmMsXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZmMgPSBmZWF0dXJlQ29sbGVjdGlvbihbZmNdKTtcbiAgICB9XG5cbiAgICAvL2dldCBjZW50cm9pZFxuICAgIHZhciBjZW50ID0gY2VudHJvaWQoZmMpO1xuXG4gICAgLy8gY2hlY2sgdG8gc2VlIGlmIGNlbnRyb2lkIGlzIG9uIHN1cmZhY2VcbiAgICB2YXIgb25TdXJmYWNlID0gZmFsc2U7XG4gICAgdmFyIGkgPSAwO1xuICAgIHdoaWxlICghb25TdXJmYWNlICYmIGkgPCBmYy5mZWF0dXJlcy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGdlb20gPSBmYy5mZWF0dXJlc1tpXS5nZW9tZXRyeTtcbiAgICAgICAgdmFyIHgsIHksIHgxLCB5MSwgeDIsIHkyLCBrO1xuICAgICAgICB2YXIgb25MaW5lID0gZmFsc2U7XG4gICAgICAgIGlmIChnZW9tLnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgIGlmIChjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdID09PSBnZW9tLmNvb3JkaW5hdGVzWzBdICYmXG4gICAgICAgIGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0gPT09IGdlb20uY29vcmRpbmF0ZXNbMV0pIHtcbiAgICAgICAgICAgICAgICBvblN1cmZhY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb20udHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgICAgICB2YXIgb25NdWx0aVBvaW50ID0gZmFsc2U7XG4gICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgIHdoaWxlICghb25NdWx0aVBvaW50ICYmIGsgPCBnZW9tLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIGlmIChjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdID09PSBnZW9tLmNvb3JkaW5hdGVzW2tdWzBdICYmXG4gICAgICAgICAgY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSA9PT0gZ2VvbS5jb29yZGluYXRlc1trXVsxXSkge1xuICAgICAgICAgICAgICAgICAgICBvblN1cmZhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbk11bHRpUG9pbnQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCFvbkxpbmUgJiYgayA8IGdlb20uY29vcmRpbmF0ZXMubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgIHggPSBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgIHkgPSBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdO1xuICAgICAgICAgICAgICAgIHgxID0gZ2VvbS5jb29yZGluYXRlc1trXVswXTtcbiAgICAgICAgICAgICAgICB5MSA9IGdlb20uY29vcmRpbmF0ZXNba11bMV07XG4gICAgICAgICAgICAgICAgeDIgPSBnZW9tLmNvb3JkaW5hdGVzW2sgKyAxXVswXTtcbiAgICAgICAgICAgICAgICB5MiA9IGdlb20uY29vcmRpbmF0ZXNbayArIDFdWzFdO1xuICAgICAgICAgICAgICAgIGlmIChwb2ludE9uU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5MikpIHtcbiAgICAgICAgICAgICAgICAgICAgb25MaW5lID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgb25TdXJmYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb20udHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgICAgIHZhciBqID0gMDtcbiAgICAgICAgICAgIHdoaWxlIChqIDwgZ2VvbS5jb29yZGluYXRlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBvbkxpbmUgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBrID0gMDtcbiAgICAgICAgICAgICAgICB2YXIgbGluZSA9IGdlb20uY29vcmRpbmF0ZXNbal07XG4gICAgICAgICAgICAgICAgd2hpbGUgKCFvbkxpbmUgJiYgayA8IGxpbmUubGVuZ3RoIC0gMSkge1xuICAgICAgICAgICAgICAgICAgICB4ID0gY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1swXTtcbiAgICAgICAgICAgICAgICAgICAgeSA9IGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgICAgIHgxID0gbGluZVtrXVswXTtcbiAgICAgICAgICAgICAgICAgICAgeTEgPSBsaW5lW2tdWzFdO1xuICAgICAgICAgICAgICAgICAgICB4MiA9IGxpbmVbayArIDFdWzBdO1xuICAgICAgICAgICAgICAgICAgICB5MiA9IGxpbmVbayArIDFdWzFdO1xuICAgICAgICAgICAgICAgICAgICBpZiAocG9pbnRPblNlZ21lbnQoeCwgeSwgeDEsIHkxLCB4MiwgeTIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgb25TdXJmYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGorKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9tLnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tLnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XG4gICAgICAgICAgICB2YXIgZiA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgZ2VvbWV0cnk6IGdlb20sXG4gICAgICAgICAgICAgICAgcHJvcGVydGllczoge31cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoaW5zaWRlKGNlbnQsIGYpKSB7XG4gICAgICAgICAgICAgICAgb25TdXJmYWNlID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpKys7XG4gICAgfVxuICAgIGlmIChvblN1cmZhY2UpIHtcbiAgICAgICAgcmV0dXJuIGNlbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHZlcnRpY2VzID0gZmVhdHVyZUNvbGxlY3Rpb24oW10pO1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgZmMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZlcnRpY2VzLmZlYXR1cmVzID0gdmVydGljZXMuZmVhdHVyZXMuY29uY2F0KGV4cGxvZGUoZmMuZmVhdHVyZXNbaV0pLmZlYXR1cmVzKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2xvc2VzdFZlcnRleDtcbiAgICAgICAgdmFyIGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdmVydGljZXMuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBkaXN0ID0gZGlzdGFuY2UoY2VudCwgdmVydGljZXMuZmVhdHVyZXNbaV0sICdtaWxlcycpO1xuICAgICAgICAgICAgaWYgKGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RWZXJ0ZXggPSB2ZXJ0aWNlcy5mZWF0dXJlc1tpXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2xvc2VzdFZlcnRleDtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHBvaW50T25TZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgdmFyIGFiID0gTWF0aC5zcXJ0KCh4MiAtIHgxKSAqICh4MiAtIHgxKSArICh5MiAtIHkxKSAqICh5MiAtIHkxKSk7XG4gICAgdmFyIGFwID0gTWF0aC5zcXJ0KCh4IC0geDEpICogKHggLSB4MSkgKyAoeSAtIHkxKSAqICh5IC0geTEpKTtcbiAgICB2YXIgcGIgPSBNYXRoLnNxcnQoKHgyIC0geCkgKiAoeDIgLSB4KSArICh5MiAtIHkpICogKHkyIC0geSkpO1xuICAgIGlmIChhYiA9PT0gYXAgKyBwYikge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcG9pbnRPblN1cmZhY2U7XG4iLCIvKipcbiAqIFRha2VzIGNvb3JkaW5hdGVzIGFuZCBwcm9wZXJ0aWVzIChvcHRpb25hbCkgYW5kIHJldHVybnMgYSBuZXcge0BsaW5rIFBvaW50fSBmZWF0dXJlLlxuICpcbiAqIEBtb2R1bGUgdHVyZi9wb2ludFxuICogQGNhdGVnb3J5IGhlbHBlclxuICogQHBhcmFtIHtudW1iZXJ9IGxvbmdpdHVkZSBwb3NpdGlvbiB3ZXN0IHRvIGVhc3QgaW4gZGVjaW1hbCBkZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gbGF0aXR1ZGUgcG9zaXRpb24gc291dGggdG8gbm9ydGggaW4gZGVjaW1hbCBkZWdyZWVzXG4gKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBhbiBPYmplY3QgdGhhdCBpcyB1c2VkIGFzIHRoZSB7QGxpbmsgRmVhdHVyZX0nc1xuICogcHJvcGVydGllc1xuICogQHJldHVybiB7UG9pbnR9IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdDEgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqXG4gKiAvLz1wdDFcbiAqL1xudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uKGFyZykge1xuICByZXR1cm4gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZykgPT09ICdbb2JqZWN0IEFycmF5XSc7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbihjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICBpZiAoIWlzQXJyYXkoY29vcmRpbmF0ZXMpKSB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIG11c3QgYmUgYW4gYXJyYXknKTtcbiAgaWYgKGNvb3JkaW5hdGVzLmxlbmd0aCA8IDIpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBiZSBhdCBsZWFzdCAyIG51bWJlcnMgbG9uZycpO1xuICByZXR1cm4ge1xuICAgIHR5cGU6IFwiRmVhdHVyZVwiLFxuICAgIGdlb21ldHJ5OiB7XG4gICAgICB0eXBlOiBcIlBvaW50XCIsXG4gICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LFxuICAgIHByb3BlcnRpZXM6IHByb3BlcnRpZXMgfHwge31cbiAgfTtcbn07XG4iLCJ2YXIgcmFuZG9tID0gcmVxdWlyZSgnZ2VvanNvbi1yYW5kb20nKTtcblxuLyoqXG4gKiBHZW5lcmF0ZXMgcmFuZG9tIHtAbGluayBHZW9KU09OfSBkYXRhLCBpbmNsdWRpbmcge0BsaW5rIFBvaW50fFBvaW50c30gYW5kIHtAbGluayBQb2x5Z29ufFBvbHlnb25zfSwgZm9yIHRlc3RpbmdcbiAqIGFuZCBleHBlcmltZW50YXRpb24uXG4gKlxuICogQG5hbWUgcmFuZG9tXG4gKiBAcGFyYW0ge1N0cmluZ30gW3R5cGU9J3BvaW50J10gdHlwZSBvZiBmZWF0dXJlcyBkZXNpcmVkOiAncG9pbnRzJyBvciAncG9seWdvbnMnXG4gKiBAcGFyYW0ge051bWJlcn0gW2NvdW50PTFdIGhvdyBtYW55IGdlb21ldHJpZXMgc2hvdWxkIGJlIGdlbmVyYXRlZC5cbiAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIG9wdGlvbnMgcmVsZXZhbnQgdG8gdGhlIGZlYXR1cmUgZGVzaXJlZC4gQ2FuIGluY2x1ZGU6XG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IG9wdGlvbnMuYmJveCBhIGJvdW5kaW5nIGJveCBpbnNpZGUgb2Ygd2hpY2ggZ2VvbWV0cmllc1xuICogYXJlIHBsYWNlZC4gSW4gdGhlIGNhc2Ugb2Yge0BsaW5rIFBvaW50fSBmZWF0dXJlcywgdGhleSBhcmUgZ3VhcmFudGVlZCB0byBiZSB3aXRoaW4gdGhpcyBib3VuZHMsXG4gKiB3aGlsZSB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZXMgaGF2ZSB0aGVpciBjZW50cm9pZCB3aXRoaW4gdGhlIGJvdW5kcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5udW1fdmVydGljZXM9MTBdIG9wdGlvbnMudmVydGljZXMgdGhlIG51bWJlciBvZiB2ZXJ0aWNlcyBhZGRlZFxuICogdG8gcG9seWdvbiBmZWF0dXJlcy5cbiAqIEBwYXJhbSB7TnVtYmVyfSBbb3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aD0xMF0gdGhlIHRvdGFsIG51bWJlciBvZiBkZWNpbWFsXG4gKiBkZWdyZWVzIGxvbmdpdHVkZSBvciBsYXRpdHVkZSB0aGF0IGEgcG9seWdvbiBjYW4gZXh0ZW50IG91dHdhcmRzIHRvXG4gKiBmcm9tIGl0cyBjZW50ZXIuXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbn0gZ2VuZXJhdGVkIHJhbmRvbSBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMgPSB0dXJmLnJhbmRvbSgncG9pbnRzJywgMTAwLCB7XG4gKiAgIGJib3g6IFstNzAsIDQwLCAtNjAsIDYwXVxuICogfSk7XG4gKlxuICogLy89cG9pbnRzXG4gKlxuICogdmFyIHBvbHlnb25zID0gdHVyZi5yYW5kb20oJ3BvbHlnb25zJywgNCwge1xuICogICBiYm94OiBbLTcwLCA0MCwgLTYwLCA2MF1cbiAqIH0pO1xuICpcbiAqIC8vPXBvbHlnb25zXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHR5cGUsIGNvdW50LCBvcHRpb25zKSB7XG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgY291bnQgPSBjb3VudCB8fCAxO1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ3BvaW50JzpcbiAgICBjYXNlICdwb2ludHMnOlxuICAgIGNhc2UgdW5kZWZpbmVkOlxuICAgICAgICByZXR1cm4gcmFuZG9tLnBvaW50KGNvdW50LCBvcHRpb25zLmJib3gpO1xuICAgIGNhc2UgJ3BvbHlnb24nOlxuICAgIGNhc2UgJ3BvbHlnb25zJzpcbiAgICAgICAgcmV0dXJuIHJhbmRvbS5wb2x5Z29uKFxuICAgICAgICAgICAgICAgIGNvdW50LFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubnVtX3ZlcnRpY2VzLFxuICAgICAgICAgICAgICAgIG9wdGlvbnMubWF4X3JhZGlhbF9sZW5ndGgsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5iYm94KTtcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSBnaXZlbjogdmFsaWQgb3B0aW9ucyBhcmUgcG9pbnRzIGFuZCBwb2x5Z29ucycpO1xuICAgIH1cbn07XG4iLCIvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzExOTM1MTc1L3NhbXBsaW5nLWEtcmFuZG9tLXN1YnNldC1mcm9tLWFuLWFycmF5XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gYW5kIHJldHVybnMgYSBGZWF0dXJlQ29sbGVjdGlvbiB3aXRoIGdpdmVuIG51bWJlciBvZiB7QGxpbmsgRmVhdHVyZXxmZWF0dXJlc30gYXQgcmFuZG9tLlxuICpcbiAqIEBuYW1lIHNhbXBsZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmVhdHVyZWNvbGxlY3Rpb24gc2V0IG9mIGlucHV0IGZlYXR1cmVzXG4gKiBAcGFyYW0ge251bWJlcn0gbnVtIG51bWJlciBvZiBmZWF0dXJlcyB0byBzZWxlY3RcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9ufSBhIEZlYXR1cmVDb2xsZWN0aW9uIHdpdGggYG5gIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludHMnLCAxMDAwKTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiB2YXIgc2FtcGxlID0gdHVyZi5zYW1wbGUocG9pbnRzLCAxMCk7XG4gKlxuICogLy89c2FtcGxlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVjb2xsZWN0aW9uLCBudW0pIHtcbiAgICB2YXIgb3V0RkMgPSBmZWF0dXJlQ29sbGVjdGlvbihnZXRSYW5kb21TdWJhcnJheShmZWF0dXJlY29sbGVjdGlvbi5mZWF0dXJlcywgbnVtKSk7XG4gICAgcmV0dXJuIG91dEZDO1xufTtcblxuZnVuY3Rpb24gZ2V0UmFuZG9tU3ViYXJyYXkoYXJyLCBzaXplKSB7XG4gICAgdmFyIHNodWZmbGVkID0gYXJyLnNsaWNlKDApLCBpID0gYXJyLmxlbmd0aCwgbWluID0gaSAtIHNpemUsIHRlbXAsIGluZGV4O1xuICAgIHdoaWxlIChpLS0gPiBtaW4pIHtcbiAgICAgICAgaW5kZXggPSBNYXRoLmZsb29yKChpICsgMSkgKiBNYXRoLnJhbmRvbSgpKTtcbiAgICAgICAgdGVtcCA9IHNodWZmbGVkW2luZGV4XTtcbiAgICAgICAgc2h1ZmZsZWRbaW5kZXhdID0gc2h1ZmZsZWRbaV07XG4gICAgICAgIHNodWZmbGVkW2ldID0gdGVtcDtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkLnNsaWNlKG1pbik7XG59XG4iLCJ2YXIgc2ltcGxpZnkgPSByZXF1aXJlKCdzaW1wbGlmeS1qcycpO1xuXG4vLyBzdXBwb3J0ZWQgR2VvSlNPTiBnZW9tZXRyaWVzLCB1c2VkIHRvIGNoZWNrIHdoZXRoZXIgdG8gd3JhcCBpbiBzaW1wbGVGZWF0dXJlKClcbnZhciBzdXBwb3J0ZWRUeXBlcyA9IFsnTGluZVN0cmluZycsICdNdWx0aUxpbmVTdHJpbmcnLCAnUG9seWdvbicsICdNdWx0aVBvbHlnb24nXTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfSBvciB7QGxpbmsgUG9seWdvbn0gYW5kIHJldHVybnMgYSBzaW1wbGlmaWVkIHZlcnNpb24uIEludGVybmFsbHkgdXNlcyBbc2ltcGxpZnktanNdKGh0dHA6Ly9tb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qcy8pIHRvIHBlcmZvcm0gc2ltcGxpZmljYXRpb24uXG4gKlxuICogQG5hbWUgc2ltcGxpZnlcbiAqIEBwYXJhbSB7RmVhdHVyZTwoTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24pPnxGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeUNvbGxlY3Rpb259IGZlYXR1cmUgZmVhdHVyZSB0byBiZSBzaW1wbGlmaWVkXG4gKiBAcGFyYW0ge251bWJlcn0gdG9sZXJhbmNlIHNpbXBsaWZpY2F0aW9uIHRvbGVyYW5jZVxuICogQHBhcmFtIHtib29sZWFufSBoaWdoUXVhbGl0eSB3aGV0aGVyIG9yIG5vdCB0byBzcGVuZCBtb3JlIHRpbWUgdG8gY3JlYXRlXG4gKiBhIGhpZ2hlci1xdWFsaXR5IHNpbXBsaWZpY2F0aW9uIHdpdGggYSBkaWZmZXJlbnQgYWxnb3JpdGhtXG4gKiBAcmV0dXJuIHtGZWF0dXJlPChMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbik+fEZlYXR1cmVDb2xsZWN0aW9ufEdlb21ldHJ5Q29sbGVjdGlvbn0gYSBzaW1wbGlmaWVkIGZlYXR1cmVcbiAqIEBleGFtcGxlXG4gICogdmFyIGZlYXR1cmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy03MC42MDM2MzcsIC0zMy4zOTk5MThdLFxuICogICAgICAgWy03MC42MTQ2MjQsIC0zMy4zOTUzMzJdLFxuICogICAgICAgWy03MC42MzkzNDMsIC0zMy4zOTI0NjZdLFxuICogICAgICAgWy03MC42NTk5NDIsIC0zMy4zOTQ3NTldLFxuICogICAgICAgWy03MC42ODM5NzUsIC0zMy40MDQ1MDRdLFxuICogICAgICAgWy03MC42OTcwMjEsIC0zMy40MTk0MDZdLFxuICogICAgICAgWy03MC43MDExNDEsIC0zMy40MzQzMDZdLFxuICogICAgICAgWy03MC43MDA0NTQsIC0zMy40NDYzMzldLFxuICogICAgICAgWy03MC42OTQyNzQsIC0zMy40NTgzNjldLFxuICogICAgICAgWy03MC42ODI2MDEsIC0zMy40NjU4MTZdLFxuICogICAgICAgWy03MC42Njg4NjksIC0zMy40NzIxMTddLFxuICogICAgICAgWy03MC42NDYyMDksIC0zMy40NzM4MzVdLFxuICogICAgICAgWy03MC42MjQ5MjMsIC0zMy40NzIxMTddLFxuICogICAgICAgWy03MC42MDk4MTcsIC0zMy40NjgxMDddLFxuICogICAgICAgWy03MC41OTUzOTcsIC0zMy40NTgzNjldLFxuICogICAgICAgWy03MC41ODcxNTgsIC0zMy40NDI5MDFdLFxuICogICAgICAgWy03MC41ODcxNTgsIC0zMy40MjYyODNdLFxuICogICAgICAgWy03MC41OTA1OTEsIC0zMy40MTQyNDhdLFxuICogICAgICAgWy03MC41OTQ3MTEsIC0zMy40MDYyMjRdLFxuICogICAgICAgWy03MC42MDM2MzcsIC0zMy4zOTk5MThdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcblxuICogdmFyIHRvbGVyYW5jZSA9IDAuMDE7XG4gKlxuICogdmFyIHNpbXBsaWZpZWQgPSB0dXJmLnNpbXBsaWZ5KFxuICogIGZlYXR1cmUsIHRvbGVyYW5jZSwgZmFsc2UpO1xuICpcbiAqIC8vPWZlYXR1cmVcbiAqXG4gKiAvLz1zaW1wbGlmaWVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmUsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpIHtcbiAgICBpZiAoZmVhdHVyZS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgcmV0dXJuIHNpbXBsZUZlYXR1cmUoXG4gICAgICAgICAgICBzaW1wbGlmeUhlbHBlcihmZWF0dXJlLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KSxcbiAgICAgICAgICAgIGZlYXR1cmUucHJvcGVydGllcyk7XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgICAgICBmZWF0dXJlczogZmVhdHVyZS5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2ltcGxpZmllZCA9IHNpbXBsaWZ5SGVscGVyKGYsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpO1xuXG4gICAgICAgICAgICAgICAgLy8gd2UgY3JlYXRlIHNpbXBsZUZlYXR1cmUgaGVyZSBiZWNhdXNlIGl0IGRvZXNuJ3QgYXBwbHkgdG8gR2VvbWV0cnlDb2xsZWN0aW9uXG4gICAgICAgICAgICAgICAgLy8gc28gd2UgY2FuJ3QgY3JlYXRlIGl0IGF0IHNpbXBsaWZ5SGVscGVyKClcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkVHlwZXMuaW5kZXhPZihzaW1wbGlmaWVkLnR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsZUZlYXR1cmUoc2ltcGxpZmllZCwgZi5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZmllZDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0dlb21ldHJ5Q29sbGVjdGlvbicsXG4gICAgICAgICAgICBnZW9tZXRyaWVzOiBmZWF0dXJlLmdlb21ldHJpZXMubWFwKGZ1bmN0aW9uIChnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHN1cHBvcnRlZFR5cGVzLmluZGV4T2YoZy50eXBlKSA+IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeUhlbHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgICAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ1xuICAgICAgICAgICAgICAgICAgICB9LCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGc7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cbn07XG5cblxuZnVuY3Rpb24gc2ltcGxpZnlIZWxwZXIoZmVhdHVyZSwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkge1xuICAgIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0xpbmVTdHJpbmcnLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHNpbXBsaWZ5TGluZShmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpTGluZVN0cmluZycsXG4gICAgICAgICAgICBjb29yZGluYXRlczogZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGxpbmVzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5TGluZShsaW5lcywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdQb2x5Z29uJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBzaW1wbGlmeVBvbHlnb24oZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6ICdNdWx0aVBvbHlnb24nLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChyaW5ncykge1xuICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmeVBvbHlnb24ocmluZ3MsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyB1bnN1cHBvcnRlZCBnZW9tZXRyeSB0eXBlIHN1cHBsaWVkXG4gICAgICAgIHJldHVybiBmZWF0dXJlO1xuICAgIH1cbn1cblxuLypcbiogcmV0dXJucyB0cnVlIGlmIHJpbmcncyBmaXJzdCBjb29yZGluYXRlIGlzIHRoZSBzYW1lIGFzIGl0cyBsYXN0XG4qL1xuZnVuY3Rpb24gY2hlY2tWYWxpZGl0eShyaW5nKSB7XG4gICAgaWYgKHJpbmcubGVuZ3RoIDwgMykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgLy9pZiB0aGUgbGFzdCBwb2ludCBpcyB0aGUgc2FtZSBhcyB0aGUgZmlyc3QsIGl0J3Mgbm90IGEgdHJpYW5nbGVcbiAgICB9IGVsc2UgaWYgKHJpbmcubGVuZ3RoID09PSAzICYmXG4gICAgICAoKHJpbmdbMl1bMF0gPT09IHJpbmdbMF1bMF0pICYmIChyaW5nWzJdWzFdID09PSByaW5nWzBdWzFdKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gc2ltcGxlRmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBnZW9tZXRyeTogZ2VvbSxcbiAgICAgICAgcHJvcGVydGllczogcHJvcGVydGllc1xuICAgIH07XG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5TGluZShjb29yZGluYXRlcywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkge1xuICAgIHJldHVybiBzaW1wbGlmeShjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIHJldHVybiB7eDogY29vcmRbMF0sIHk6IGNvb3JkWzFdfTtcbiAgICB9KSwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIFtjb29yZHMueCwgY29vcmRzLnldO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBzaW1wbGlmeVBvbHlnb24oY29vcmRpbmF0ZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpIHtcbiAgICByZXR1cm4gY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChyaW5nKSB7XG4gICAgICAgIHZhciBwdHMgPSByaW5nLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgICAgIHJldHVybiB7eDogY29vcmRbMF0sIHk6IGNvb3JkWzFdfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChwdHMubGVuZ3RoIDwgNCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHBvbHlnb24nKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2ltcGxlUmluZyA9IHNpbXBsaWZ5KHB0cywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgIHJldHVybiBbY29vcmRzLngsIGNvb3Jkcy55XTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vcmVtb3ZlIDEgcGVyY2VudCBvZiB0b2xlcmFuY2UgdW50aWwgZW5vdWdoIHBvaW50cyB0byBtYWtlIGEgdHJpYW5nbGVcbiAgICAgICAgd2hpbGUgKCFjaGVja1ZhbGlkaXR5KHNpbXBsZVJpbmcpKSB7XG4gICAgICAgICAgICB0b2xlcmFuY2UgLT0gdG9sZXJhbmNlICogMC4wMTtcbiAgICAgICAgICAgIHNpbXBsZVJpbmcgPSBzaW1wbGlmeShwdHMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFtjb29yZHMueCwgY29vcmRzLnldO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFxuICAgICAgICAgICAgKHNpbXBsZVJpbmdbc2ltcGxlUmluZy5sZW5ndGggLSAxXVswXSAhPT0gc2ltcGxlUmluZ1swXVswXSkgfHxcbiAgICAgICAgICAgICAgICAoc2ltcGxlUmluZ1tzaW1wbGVSaW5nLmxlbmd0aCAtIDFdWzFdICE9PSBzaW1wbGVSaW5nWzBdWzFdKSkge1xuICAgICAgICAgICAgc2ltcGxlUmluZy5wdXNoKHNpbXBsZVJpbmdbMF0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaW1wbGVSaW5nO1xuICAgIH0pO1xufVxuIiwidmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgcG9pbnQgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2ludDtcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcblxuLyoqXG4gKiBUYWtlcyBhIGJvdW5kaW5nIGJveCBhbmQgYSBjZWxsIGRlcHRoIGFuZCByZXR1cm5zIGEgc2V0IG9mIHNxdWFyZSB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gaW4gYSBncmlkLlxuICpcbiAqIEBuYW1lIHNxdWFyZUdyaWRcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAcGFyYW0ge251bWJlcn0gY2VsbFNpemUgd2lkdGggb2YgZWFjaCBjZWxsXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdHMgdW5pdHMgdG8gdXNlIGZvciBjZWxsV2lkdGhcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBncmlkIGEgZ3JpZCBvZiBwb2x5Z29uc1xuICogQGV4YW1wbGVcbiAqIHZhciBleHRlbnQgPSBbLTc3LjM4NzY5NTMxMjUsMzguNzE5ODA0NzQyNjQyMzksLTc2Ljk0ODI0MjE4NzUsMzkuMDI3NzE4ODQwMjExNjA1XTtcbiAqIHZhciBjZWxsV2lkdGggPSAxMDtcbiAqIHZhciB1bml0cyA9ICdtaWxlcyc7XG4gKlxuICogdmFyIHNxdWFyZUdyaWQgPSB0dXJmLnNxdWFyZUdyaWQoZXh0ZW50LCBjZWxsV2lkdGgsIHVuaXRzKTtcbiAqXG4gKiAvLz1zcXVhcmVHcmlkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3F1YXJlR3JpZChiYm94LCBjZWxsU2l6ZSwgdW5pdHMpIHtcbiAgICB2YXIgZmMgPSBmZWF0dXJlY29sbGVjdGlvbihbXSk7XG4gICAgdmFyIHhGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzJdLCBiYm94WzFdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxXaWR0aCA9IHhGcmFjdGlvbiAqIChiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdmFyIHlGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKHBvaW50KFtiYm94WzBdLCBiYm94WzFdXSksIHBvaW50KFtiYm94WzBdLCBiYm94WzNdXSksIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAoYmJveFszXSAtIGJib3hbMV0pO1xuXG4gICAgdmFyIGN1cnJlbnRYID0gYmJveFswXTtcbiAgICB3aGlsZSAoY3VycmVudFggPD0gYmJveFsyXSkge1xuICAgICAgICB2YXIgY3VycmVudFkgPSBiYm94WzFdO1xuICAgICAgICB3aGlsZSAoY3VycmVudFkgPD0gYmJveFszXSkge1xuICAgICAgICAgICAgdmFyIGNlbGxQb2x5ID0gcG9seWdvbihbW1xuICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgIF1dKTtcbiAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2goY2VsbFBvbHkpO1xuXG4gICAgICAgICAgICBjdXJyZW50WSArPSBjZWxsSGVpZ2h0O1xuICAgICAgICB9XG4gICAgICAgIGN1cnJlbnRYICs9IGNlbGxXaWR0aDtcbiAgICB9XG5cbiAgICByZXR1cm4gZmM7XG59O1xuIiwidmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBjYWxjdWxhdGVzIHRoZSBtaW5pbXVtIHNxdWFyZSBib3VuZGluZyBib3ggdGhhdFxuICogd291bGQgY29udGFpbiB0aGUgaW5wdXQuXG4gKlxuICogQG5hbWUgc3F1YXJlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggYSBib3VuZGluZyBib3hcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IGEgc3F1YXJlIHN1cnJvdW5kaW5nIGBiYm94YFxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gWy0yMCwtMjAsLTE1LDBdO1xuICpcbiAqIHZhciBzcXVhcmVkID0gdHVyZi5zcXVhcmUoYmJveCk7XG4gKlxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB0dXJmLmJib3hQb2x5Z29uKGJib3gpLFxuICogICAgIHR1cmYuYmJveFBvbHlnb24oc3F1YXJlZClcbiAqICAgXVxuICogfTtcbiAqXG4gKiAvLz1mZWF0dXJlc1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiYm94KSB7XG4gICAgdmFyIGhvcml6b250YWxEaXN0YW5jZSA9IGRpc3RhbmNlKGJib3guc2xpY2UoMCwgMiksIFtiYm94WzJdLCBiYm94WzFdXSwgJ21pbGVzJyk7XG4gICAgdmFyIHZlcnRpY2FsRGlzdGFuY2UgPSBkaXN0YW5jZShiYm94LnNsaWNlKDAsIDIpLCBbYmJveFswXSwgYmJveFszXV0sICdtaWxlcycpO1xuICAgIGlmIChob3Jpem9udGFsRGlzdGFuY2UgPj0gdmVydGljYWxEaXN0YW5jZSkge1xuICAgICAgICB2YXIgdmVydGljYWxNaWRwb2ludCA9IChiYm94WzFdICsgYmJveFszXSkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgYmJveFswXSxcbiAgICAgICAgICAgIHZlcnRpY2FsTWlkcG9pbnQgLSAoKGJib3hbMl0gLSBiYm94WzBdKSAvIDIpLFxuICAgICAgICAgICAgYmJveFsyXSxcbiAgICAgICAgICAgIHZlcnRpY2FsTWlkcG9pbnQgKyAoKGJib3hbMl0gLSBiYm94WzBdKSAvIDIpXG4gICAgICAgIF07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIGhvcml6b250YWxNaWRwb2ludCA9IChiYm94WzBdICsgYmJveFsyXSkgLyAyO1xuICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgaG9yaXpvbnRhbE1pZHBvaW50IC0gKChiYm94WzNdIC0gYmJveFsxXSkgLyAyKSxcbiAgICAgICAgICAgIGJib3hbMV0sXG4gICAgICAgICAgICBob3Jpem9udGFsTWlkcG9pbnQgKyAoKGJib3hbM10gLSBiYm94WzFdKSAvIDIpLFxuICAgICAgICAgICAgYmJveFszXVxuICAgICAgICBdO1xuICAgIH1cbn07XG4iLCJ2YXIgaW5zaWRlID0gcmVxdWlyZSgndHVyZi1pbnNpZGUnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgYSBzZXQgb2Yge0BsaW5rIFBvbHlnb258cG9seWdvbnN9IGFuZCBwZXJmb3JtcyBhIHNwYXRpYWwgam9pbi5cbiAqXG4gKiBAbmFtZSB0YWdcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgaW5wdXQgcG9pbnRzXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyBpbnB1dCBwb2x5Z29uc1xuICogQHBhcmFtIHtzdHJpbmd9IGZpZWxkIHByb3BlcnR5IGluIGBwb2x5Z29uc2AgdG8gYWRkIHRvIGpvaW5lZCBQb2ludCBmZWF0dXJlc1xuICogQHBhcmFtIHtzdHJpbmd9IG91dEZpZWxkIHByb3BlcnR5IGluIGBwb2ludHNgIGluIHdoaWNoIHRvIHN0b3JlIGpvaW5lZCBwcm9wZXJ0eSBmcm9tIGBwb2x5Z29uc1xuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgd2l0aCBgY29udGFpbmluZ1BvbHlJZGAgcHJvcGVydHkgY29udGFpbmluZyB2YWx1ZXMgZnJvbSBgcG9seUlkYFxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gWzAsIDAsIDEwLCAxMF07XG4gKiAvLyBjcmVhdGUgYSB0cmlhbmd1bGFyIGdyaWQgb2YgcG9seWdvbnNcbiAqIHZhciB0cmlhbmdsZUdyaWQgPSB0dXJmLnRyaWFuZ2xlR3JpZChiYm94LCA1MCwgJ21pbGVzJyk7XG4gKiB0cmlhbmdsZUdyaWQuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbihmKSB7XG4gKiAgIGYucHJvcGVydGllcy5maWxsID0gJyMnICtcbiAqICAgICAofn4oTWF0aC5yYW5kb20oKSAqIDE2KSkudG9TdHJpbmcoMTYpICtcbiAqICAgICAofn4oTWF0aC5yYW5kb20oKSAqIDE2KSkudG9TdHJpbmcoMTYpICtcbiAqICAgICAofn4oTWF0aC5yYW5kb20oKSAqIDE2KSkudG9TdHJpbmcoMTYpO1xuICogICBmLnByb3BlcnRpZXMuc3Ryb2tlID0gMDtcbiAqICAgZi5wcm9wZXJ0aWVzWydmaWxsLW9wYWNpdHknXSA9IDE7XG4gKiB9KTtcbiAqIHZhciByYW5kb21Qb2ludHMgPSB0dXJmLnJhbmRvbSgncG9pbnQnLCAzMCwge1xuICogICBiYm94OiBiYm94XG4gKiB9KTtcbiAqIHZhciBib3RoID0gdHVyZi5mZWF0dXJlY29sbGVjdGlvbihcbiAqICAgdHJpYW5nbGVHcmlkLmZlYXR1cmVzLmNvbmNhdChyYW5kb21Qb2ludHMuZmVhdHVyZXMpKTtcbiAqXG4gKiAvLz1ib3RoXG4gKlxuICogdmFyIHRhZ2dlZCA9IHR1cmYudGFnKHJhbmRvbVBvaW50cywgdHJpYW5nbGVHcmlkLFxuICogICAgICAgICAgICAgICAgICAgICAgICdmaWxsJywgJ21hcmtlci1jb2xvcicpO1xuICpcbiAqIC8vPXRhZ2dlZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHBvbHlnb25zLCBmaWVsZCwgb3V0RmllbGQpIHtcbiAgICAvLyBwcmV2ZW50IG11dGF0aW9uc1xuICAgIHBvaW50cyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocG9pbnRzKSk7XG4gICAgcG9seWdvbnMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHBvbHlnb25zKSk7XG4gICAgcG9pbnRzLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgIGlmICghcHQucHJvcGVydGllcykge1xuICAgICAgICAgICAgcHQucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHBvbHlnb25zLmZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKHBvbHkpIHtcbiAgICAgICAgICAgIGlmIChwdC5wcm9wZXJ0aWVzW291dEZpZWxkXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdmFyIGlzSW5zaWRlID0gaW5zaWRlKHB0LCBwb2x5KTtcbiAgICAgICAgICAgICAgICBpZiAoaXNJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgcHQucHJvcGVydGllc1tvdXRGaWVsZF0gPSBwb2x5LnByb3BlcnRpZXNbZmllbGRdO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHBvaW50cztcbn07XG4iLCJ2YXIgcG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvbHlnb247XG52YXIgZWFyY3V0ID0gcmVxdWlyZSgnZWFyY3V0Jyk7XG5cbi8qKlxuICogVGVzc2VsYXRlcyBhIHtAbGluayBGZWF0dXJlPFBvbHlnb24+fSBpbnRvIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBvZiB0cmlhbmdsZXNcbiAqIHVzaW5nIFtlYXJjdXRdKGh0dHBzOi8vZ2l0aHViLmNvbS9tYXBib3gvZWFyY3V0KS5cbiAqXG4gKiBAbmFtZSB0ZXNzZWxhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seWdvbiB0aGUgcG9seWdvbiB0byB0ZXNzZWxhdGVcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gYSBnZW9tZXRyeWNvbGxlY3Rpb24gZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0ge1widHlwZVwiOlwiRmVhdHVyZVwiLFwiaWRcIjpcIlVTQS1DQVwiLFwicHJvcGVydGllc1wiOntcIm5hbWVcIjpcIkNhbGlmb3JuaWFcIn0sXCJnZW9tZXRyeVwiOntcInR5cGVcIjpcIlBvbHlnb25cIixcImNvb3JkaW5hdGVzXCI6W1tbLTEyMy4yMzMyNTYsNDIuMDA2MTg2XSxbLTEyMi4zNzg4NTMsNDIuMDExNjYzXSxbLTEyMS4wMzcwMDMsNDEuOTk1MjMyXSxbLTEyMC4wMDE4NjEsNDEuOTk1MjMyXSxbLTExOS45OTYzODQsNDAuMjY0NTE5XSxbLTEyMC4wMDE4NjEsMzguOTk5MzQ2XSxbLTExOC43MTQ3OCwzOC4xMDExMjhdLFstMTE3LjQ5ODg5OSwzNy4yMTkzNF0sWy0xMTYuNTQwNDM1LDM2LjUwMTg2MV0sWy0xMTUuODUwMzQsMzUuOTcwNTk4XSxbLTExNC42MzQ0NTksMzUuMDAxMThdLFstMTE0LjYzNDQ1OSwzNC44NzUyMV0sWy0xMTQuNDcwMTUxLDM0LjcxMDkwMl0sWy0xMTQuMzMzMjI4LDM0LjQ0ODAwOV0sWy0xMTQuMTM2MDU4LDM0LjMwNTYwOF0sWy0xMTQuMjU2NTUxLDM0LjE3NDE2Ml0sWy0xMTQuNDE1MzgyLDM0LjEwODQzOF0sWy0xMTQuNTM1ODc0LDMzLjkzMzE3Nl0sWy0xMTQuNDk3NTM2LDMzLjY5NzY2OF0sWy0xMTQuNTI0OTIxLDMzLjU0OTc5XSxbLTExNC43Mjc1NjcsMzMuNDA3MzldLFstMTE0LjY2MTg0NCwzMy4wMzQ5NThdLFstMTE0LjUyNDkyMSwzMy4wMjk0ODFdLFstMTE0LjQ3MDE1MSwzMi44NDMyNjVdLFstMTE0LjUyNDkyMSwzMi43NTU2MzRdLFstMTE0LjcyMjA5LDMyLjcxNzI5NV0sWy0xMTYuMDQ3NTEsMzIuNjI0MTg3XSxbLTExNy4xMjY0NjcsMzIuNTM2NTU2XSxbLTExNy4yNDY5NiwzMi42NjgwMDNdLFstMTE3LjI1MjQzNywzMi44NzYxMjddLFstMTE3LjMyOTExNCwzMy4xMjI1ODldLFstMTE3LjQ3MTUxNSwzMy4yOTc4NTFdLFstMTE3Ljc4MzcsMzMuNTM4ODM2XSxbLTExOC4xODM1MTcsMzMuNzYzMzkxXSxbLTExOC4yNjAxOTQsMzMuNzAzMTQ1XSxbLTExOC40MTM1NDgsMzMuNzQxNDgzXSxbLTExOC4zOTE2NDEsMzMuODQwMDY4XSxbLTExOC41NjY5MDMsMzQuMDQyNzE1XSxbLTExOC44MDI0MTEsMzMuOTk4ODk5XSxbLTExOS4yMTg2NTksMzQuMTQ2Nzc3XSxbLTExOS4yNzg5MDUsMzQuMjY3MjddLFstMTE5LjU1ODIyOSwzNC40MTUxNDddLFstMTE5Ljg3NTg5MSwzNC40MDk2N10sWy0xMjAuMTM4Nzg0LDM0LjQ3NTM5M10sWy0xMjAuNDcyODc4LDM0LjQ0ODAwOV0sWy0xMjAuNjQ4MTQsMzQuNTc5NDU1XSxbLTEyMC42MDk4MDEsMzQuODU4Nzc5XSxbLTEyMC42NzAwNDgsMzQuOTAyNTk1XSxbLTEyMC42MzE3MDksMzUuMDk5NzY0XSxbLTEyMC44OTQ2MDIsMzUuMjQ3NjQyXSxbLTEyMC45MDU1NTYsMzUuNDUwMjg5XSxbLTEyMS4wMDQxNDEsMzUuNDYxMjQzXSxbLTEyMS4xNjg0NDksMzUuNjM2NTA1XSxbLTEyMS4yODM0NjUsMzUuNjc0ODQzXSxbLTEyMS4zMzI3NTcsMzUuNzg0MzgyXSxbLTEyMS43MTYxNDMsMzYuMTk1MTUzXSxbLTEyMS44OTY4ODIsMzYuMzE1NjQ1XSxbLTEyMS45MzUyMjEsMzYuNjM4Nzg1XSxbLTEyMS44NTg1NDQsMzYuNjExNF0sWy0xMjEuNzg3MzQ0LDM2LjgwMzA5M10sWy0xMjEuOTI5NzQ0LDM2Ljk3ODM1NV0sWy0xMjIuMTA1MDA2LDM2Ljk1NjQ0N10sWy0xMjIuMzM1MDM4LDM3LjExNTI3OV0sWy0xMjIuNDE3MTkyLDM3LjI0MTI0OF0sWy0xMjIuNDAwNzYxLDM3LjM2MTc0MV0sWy0xMjIuNTE1Nzc3LDM3LjUyMDU3Ml0sWy0xMjIuNTE1Nzc3LDM3Ljc4MzQ2NV0sWy0xMjIuMzI5NTYxLDM3Ljc4MzQ2NV0sWy0xMjIuNDA2MjM4LDM4LjE1MDQyXSxbLTEyMi40ODgzOTIsMzguMTEyMDgyXSxbLTEyMi41MDQ4MjMsMzcuOTMxMzQzXSxbLTEyMi43MDE5OTMsMzcuODkzMDA0XSxbLTEyMi45Mzc1MDEsMzguMDI5OTI4XSxbLTEyMi45NzU4NCwzOC4yNjU0MzZdLFstMTIzLjEyOTE5NCwzOC40NTE2NTJdLFstMTIzLjMzMTg0MSwzOC41NjY2NjhdLFstMTIzLjQ0MTM4LDM4LjY5ODExNF0sWy0xMjMuNzM3MTM0LDM4Ljk1NTUzXSxbLTEyMy42ODc4NDIsMzkuMDMyMjA4XSxbLTEyMy44MjQ3NjUsMzkuMzY2MzAxXSxbLTEyMy43NjQ1MTksMzkuNTUyNTE3XSxbLTEyMy44NTIxNSwzOS44MzE4NDFdLFstMTI0LjEwOTU2Niw0MC4xMDU2ODhdLFstMTI0LjM2MTUwNiw0MC4yNTkwNDJdLFstMTI0LjQxMDc5OCw0MC40Mzk3ODFdLFstMTI0LjE1ODg1OSw0MC44Nzc5MzddLFstMTI0LjEwOTU2Niw0MS4wMjU4MTRdLFstMTI0LjE1ODg1OSw0MS4xNDA4M10sWy0xMjQuMDY1NzUxLDQxLjQ0MjA2MV0sWy0xMjQuMTQ3OTA1LDQxLjcxNTkwOF0sWy0xMjQuMjU3NDQ0LDQxLjc4MTYzMl0sWy0xMjQuMjEzNjI4LDQyLjAwMDcwOV0sWy0xMjMuMjMzMjU2LDQyLjAwNjE4Nl1dXX19O1xuICpcbiAqIHZhciB0cmlhbmdsZXMgPSB0dXJmLnRlc3NlbGF0ZShwb2x5Z29uKTtcbiAqXG4gKiAvLz10cmlhbmdsZXNcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5KSB7XG4gICAgaWYgKCFwb2x5Lmdlb21ldHJ5IHx8IChwb2x5Lmdlb21ldHJ5LnR5cGUgIT09ICdQb2x5Z29uJyAmJiBwb2x5Lmdlb21ldHJ5LnR5cGUgIT09ICdNdWx0aVBvbHlnb24nKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBQb2x5Z29uIG9yIE11bHRpUG9seWdvbicpO1xuICAgIH1cblxuICAgIHZhciBmYyA9IHt0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLCBmZWF0dXJlczogW119O1xuXG4gICAgaWYgKHBvbHkuZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIGZjLmZlYXR1cmVzID0gcHJvY2Vzc1BvbHlnb24ocG9seS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9seS5nZW9tZXRyeS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZGluYXRlcykge1xuICAgICAgICAgICAgZmMuZmVhdHVyZXMgPSBmYy5mZWF0dXJlcy5jb25jYXQocHJvY2Vzc1BvbHlnb24oY29vcmRpbmF0ZXMpKTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZjO1xufTtcblxuZnVuY3Rpb24gcHJvY2Vzc1BvbHlnb24oY29vcmRpbmF0ZXMpIHtcbiAgICB2YXIgZGF0YSA9IGZsYXR0ZW5Db29yZHMoY29vcmRpbmF0ZXMpO1xuICAgIHZhciBkaW0gPSAyO1xuICAgIHZhciByZXN1bHQgPSBlYXJjdXQoZGF0YS52ZXJ0aWNlcywgZGF0YS5ob2xlcywgZGltKTtcblxuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIHZhciB2ZXJ0aWNlcyA9IFtdO1xuXG4gICAgcmVzdWx0LmZvckVhY2goZnVuY3Rpb24gKHZlcnQsIGkpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gcmVzdWx0W2ldO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtkYXRhLnZlcnRpY2VzW2luZGV4ICogZGltXSwgZGF0YS52ZXJ0aWNlc1tpbmRleCAqIGRpbSArIDFdXSk7XG4gICAgfSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZlcnRpY2VzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSB2ZXJ0aWNlcy5zbGljZShpLCBpICsgMyk7XG4gICAgICAgIGNvb3Jkcy5wdXNoKHZlcnRpY2VzW2ldKTtcbiAgICAgICAgZmVhdHVyZXMucHVzaChwb2x5Z29uKFtjb29yZHNdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZlYXR1cmVzO1xufVxuXG5mdW5jdGlvbiBmbGF0dGVuQ29vcmRzKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuIiwiLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0RlbGF1bmF5X3RyaWFuZ3VsYXRpb25cbi8vaHR0cHM6Ly9naXRodWIuY29tL2lyb253YWxsYWJ5L2RlbGF1bmF5XG52YXIgcG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvbHlnb247XG52YXIgZmVhdHVyZWNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgdGhlIG5hbWUgb2YgYSB6LXZhbHVlIHByb3BlcnR5IGFuZFxuICogY3JlYXRlcyBhIFtUcmlhbmd1bGF0ZWQgSXJyZWd1bGFyIE5ldHdvcmtdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvVHJpYW5ndWxhdGVkX2lycmVndWxhcl9uZXR3b3JrKSxcbiAqIG9yIGEgVElOIGZvciBzaG9ydCwgcmV0dXJuZWQgYXMgYSBjb2xsZWN0aW9uIG9mIFBvbHlnb25zLiBUaGVzZSBhcmUgb2Z0ZW4gdXNlZFxuICogZm9yIGRldmVsb3BpbmcgZWxldmF0aW9uIGNvbnRvdXIgbWFwcyBvciBzdGVwcGVkIGhlYXQgdmlzdWFsaXphdGlvbnMuXG4gKlxuICogVGhpcyB0cmlhbmd1bGF0ZXMgdGhlIHBvaW50cywgYXMgd2VsbCBhcyBhZGRzIHByb3BlcnRpZXMgY2FsbGVkIGBhYCwgYGJgLFxuICogYW5kIGBjYCByZXByZXNlbnRpbmcgdGhlIHZhbHVlIG9mIHRoZSBnaXZlbiBgcHJvcGVydHlOYW1lYCBhdCBlYWNoIG9mXG4gKiB0aGUgcG9pbnRzIHRoYXQgcmVwcmVzZW50IHRoZSBjb3JuZXJzIG9mIHRoZSB0cmlhbmdsZS5cbiAqXG4gKiBAbmFtZSB0aW5cbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgaW5wdXQgcG9pbnRzXG4gKiBAcGFyYW0ge1N0cmluZz19IHogbmFtZSBvZiB0aGUgcHJvcGVydHkgZnJvbSB3aGljaCB0byBwdWxsIHogdmFsdWVzXG4gKiBUaGlzIGlzIG9wdGlvbmFsOiBpZiBub3QgZ2l2ZW4sIHRoZW4gdGhlcmUgd2lsbCBiZSBubyBleHRyYSBkYXRhIGFkZGVkIHRvIHRoZSBkZXJpdmVkIHRyaWFuZ2xlcy5cbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBUSU4gb3V0cHV0XG4gKiBAZXhhbXBsZVxuICogLy8gZ2VuZXJhdGUgc29tZSByYW5kb20gcG9pbnQgZGF0YVxuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludHMnLCAzMCwge1xuICogICBiYm94OiBbNTAsIDMwLCA3MCwgNTBdXG4gKiB9KTtcbiAqIC8vPXBvaW50c1xuICogLy8gYWRkIGEgcmFuZG9tIHByb3BlcnR5IHRvIGVhY2ggcG9pbnQgYmV0d2VlbiAwIGFuZCA5XG4gKiBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICogICBwb2ludHMuZmVhdHVyZXNbaV0ucHJvcGVydGllcy56ID0gfn4oTWF0aC5yYW5kb20oKSAqIDkpO1xuICogfVxuICogdmFyIHRpbiA9IHR1cmYudGluKHBvaW50cywgJ3onKVxuICogZm9yICh2YXIgaSA9IDA7IGkgPCB0aW4uZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAqICAgdmFyIHByb3BlcnRpZXMgID0gdGluLmZlYXR1cmVzW2ldLnByb3BlcnRpZXM7XG4gKiAgIC8vIHJvdWdobHkgdHVybiB0aGUgcHJvcGVydGllcyBvZiBlYWNoXG4gKiAgIC8vIHRyaWFuZ2xlIGludG8gYSBmaWxsIGNvbG9yXG4gKiAgIC8vIHNvIHdlIGNhbiB2aXN1YWxpemUgdGhlIHJlc3VsdFxuICogICBwcm9wZXJ0aWVzLmZpbGwgPSAnIycgKyBwcm9wZXJ0aWVzLmEgK1xuICogICAgIHByb3BlcnRpZXMuYiArIHByb3BlcnRpZXMuYztcbiAqIH1cbiAqIC8vPXRpblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHopIHtcbiAgICAvL2JyZWFrIGRvd24gcG9pbnRzXG4gICAgcmV0dXJuIGZlYXR1cmVjb2xsZWN0aW9uKHRyaWFuZ3VsYXRlKHBvaW50cy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKHApIHtcbiAgICAgICAgdmFyIHBvaW50ID0ge1xuICAgICAgICAgICAgeDogcC5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgICAgIHk6IHAuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV1cbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHopIHBvaW50LnogPSBwLnByb3BlcnRpZXNbel07XG4gICAgICAgIHJldHVybiBwb2ludDtcbiAgICB9KSkubWFwKGZ1bmN0aW9uICh0cmlhbmdsZSkge1xuICAgICAgICByZXR1cm4gcG9seWdvbihbW1xuICAgICAgICBbdHJpYW5nbGUuYS54LCB0cmlhbmdsZS5hLnldLFxuICAgICAgICBbdHJpYW5nbGUuYi54LCB0cmlhbmdsZS5iLnldLFxuICAgICAgICBbdHJpYW5nbGUuYy54LCB0cmlhbmdsZS5jLnldLFxuICAgICAgICBbdHJpYW5nbGUuYS54LCB0cmlhbmdsZS5hLnldXG4gICAgICAgIF1dLCB7XG4gICAgICAgICAgICBhOiB0cmlhbmdsZS5hLnosXG4gICAgICAgICAgICBiOiB0cmlhbmdsZS5iLnosXG4gICAgICAgICAgICBjOiB0cmlhbmdsZS5jLnpcbiAgICAgICAgfSk7XG4gICAgfSkpO1xufTtcblxuZnVuY3Rpb24gVHJpYW5nbGUoYSwgYiwgYykge1xuICAgIHRoaXMuYSA9IGE7XG4gICAgdGhpcy5iID0gYjtcbiAgICB0aGlzLmMgPSBjO1xuXG4gICAgdmFyIEEgPSBiLnggLSBhLngsXG4gICAgICAgIEIgPSBiLnkgLSBhLnksXG4gICAgICAgIEMgPSBjLnggLSBhLngsXG4gICAgICAgIEQgPSBjLnkgLSBhLnksXG4gICAgICAgIEUgPSBBICogKGEueCArIGIueCkgKyBCICogKGEueSArIGIueSksXG4gICAgICAgIEYgPSBDICogKGEueCArIGMueCkgKyBEICogKGEueSArIGMueSksXG4gICAgICAgIEcgPSAyICogKEEgKiAoYy55IC0gYi55KSAtIEIgKiAoYy54IC0gYi54KSksXG4gICAgICAgIG1pbngsIG1pbnksIGR4LCBkeTtcblxuICAgIC8vIElmIHRoZSBwb2ludHMgb2YgdGhlIHRyaWFuZ2xlIGFyZSBjb2xsaW5lYXIsIHRoZW4ganVzdCBmaW5kIHRoZVxuICAgIC8vIGV4dHJlbWVzIGFuZCB1c2UgdGhlIG1pZHBvaW50IGFzIHRoZSBjZW50ZXIgb2YgdGhlIGNpcmN1bWNpcmNsZS5cbiAgICBpZiAoTWF0aC5hYnMoRykgPCAwLjAwMDAwMSkge1xuICAgICAgICBtaW54ID0gTWF0aC5taW4oYS54LCBiLngsIGMueCk7XG4gICAgICAgIG1pbnkgPSBNYXRoLm1pbihhLnksIGIueSwgYy55KTtcbiAgICAgICAgZHggPSAoTWF0aC5tYXgoYS54LCBiLngsIGMueCkgLSBtaW54KSAqIDAuNTtcbiAgICAgICAgZHkgPSAoTWF0aC5tYXgoYS55LCBiLnksIGMueSkgLSBtaW55KSAqIDAuNTtcblxuICAgICAgICB0aGlzLnggPSBtaW54ICsgZHg7XG4gICAgICAgIHRoaXMueSA9IG1pbnkgKyBkeTtcbiAgICAgICAgdGhpcy5yID0gZHggKiBkeCArIGR5ICogZHk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy54ID0gKEQgKiBFIC0gQiAqIEYpIC8gRztcbiAgICAgICAgdGhpcy55ID0gKEEgKiBGIC0gQyAqIEUpIC8gRztcbiAgICAgICAgZHggPSB0aGlzLnggLSBhLng7XG4gICAgICAgIGR5ID0gdGhpcy55IC0gYS55O1xuICAgICAgICB0aGlzLnIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGJ5WChhLCBiKSB7XG4gICAgcmV0dXJuIGIueCAtIGEueDtcbn1cblxuZnVuY3Rpb24gZGVkdXAoZWRnZXMpIHtcbiAgICB2YXIgaiA9IGVkZ2VzLmxlbmd0aCxcbiAgICAgICAgYSwgYiwgaSwgbSwgbjtcblxuICAgIG91dGVyOlxuICB3aGlsZSAoaikge1xuICAgICAgYiA9IGVkZ2VzWy0tal07XG4gICAgICBhID0gZWRnZXNbLS1qXTtcbiAgICAgIGkgPSBqO1xuICAgICAgd2hpbGUgKGkpIHtcbiAgICAgICAgICBuID0gZWRnZXNbLS1pXTtcbiAgICAgICAgICBtID0gZWRnZXNbLS1pXTtcbiAgICAgICAgICBpZiAoKGEgPT09IG0gJiYgYiA9PT0gbikgfHwgKGEgPT09IG4gJiYgYiA9PT0gbSkpIHtcbiAgICAgICAgICAgICAgZWRnZXMuc3BsaWNlKGosIDIpO1xuICAgICAgICAgICAgICBlZGdlcy5zcGxpY2UoaSwgMik7XG4gICAgICAgICAgICAgIGogLT0gMjtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRyaWFuZ3VsYXRlKHZlcnRpY2VzKSB7XG4gICAgLy8gQmFpbCBpZiB0aGVyZSBhcmVuJ3QgZW5vdWdoIHZlcnRpY2VzIHRvIGZvcm0gYW55IHRyaWFuZ2xlcy5cbiAgICBpZiAodmVydGljZXMubGVuZ3RoIDwgMylcbiAgICAgICAgcmV0dXJuIFtdO1xuXG4gICAgLy8gRW5zdXJlIHRoZSB2ZXJ0ZXggYXJyYXkgaXMgaW4gb3JkZXIgb2YgZGVzY2VuZGluZyBYIGNvb3JkaW5hdGVcbiAgICAvLyAod2hpY2ggaXMgbmVlZGVkIHRvIGVuc3VyZSBhIHN1YnF1YWRyYXRpYyBydW50aW1lKSwgYW5kIHRoZW4gZmluZFxuICAgIC8vIHRoZSBib3VuZGluZyBib3ggYXJvdW5kIHRoZSBwb2ludHMuXG4gICAgdmVydGljZXMuc29ydChieVgpO1xuXG4gICAgdmFyIGkgPSB2ZXJ0aWNlcy5sZW5ndGggLSAxLFxuICAgICAgICB4bWluID0gdmVydGljZXNbaV0ueCxcbiAgICAgICAgeG1heCA9IHZlcnRpY2VzWzBdLngsXG4gICAgICAgIHltaW4gPSB2ZXJ0aWNlc1tpXS55LFxuICAgICAgICB5bWF4ID0geW1pbjtcblxuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgICAgaWYgKHZlcnRpY2VzW2ldLnkgPCB5bWluKVxuICAgICAgICAgICAgeW1pbiA9IHZlcnRpY2VzW2ldLnk7XG4gICAgICAgIGlmICh2ZXJ0aWNlc1tpXS55ID4geW1heClcbiAgICAgICAgICAgIHltYXggPSB2ZXJ0aWNlc1tpXS55O1xuICAgIH1cblxuICAgIC8vRmluZCBhIHN1cGVydHJpYW5nbGUsIHdoaWNoIGlzIGEgdHJpYW5nbGUgdGhhdCBzdXJyb3VuZHMgYWxsIHRoZVxuICAgIC8vdmVydGljZXMuIFRoaXMgaXMgdXNlZCBsaWtlIHNvbWV0aGluZyBvZiBhIHNlbnRpbmVsIHZhbHVlIHRvIHJlbW92ZVxuICAgIC8vY2FzZXMgaW4gdGhlIG1haW4gYWxnb3JpdGhtLCBhbmQgaXMgcmVtb3ZlZCBiZWZvcmUgd2UgcmV0dXJuIGFueVxuICAgIC8vIHJlc3VsdHMuXG5cbiAgICAvLyBPbmNlIGZvdW5kLCBwdXQgaXQgaW4gdGhlIFwib3BlblwiIGxpc3QuIChUaGUgXCJvcGVuXCIgbGlzdCBpcyBmb3JcbiAgICAvLyB0cmlhbmdsZXMgd2hvIG1heSBzdGlsbCBuZWVkIHRvIGJlIGNvbnNpZGVyZWQ7IHRoZSBcImNsb3NlZFwiIGxpc3QgaXNcbiAgICAvLyBmb3IgdHJpYW5nbGVzIHdoaWNoIGRvIG5vdC4pXG4gICAgdmFyIGR4ID0geG1heCAtIHhtaW4sXG4gICAgICAgIGR5ID0geW1heCAtIHltaW4sXG4gICAgICAgIGRtYXggPSAoZHggPiBkeSkgPyBkeCA6IGR5LFxuICAgICAgICB4bWlkID0gKHhtYXggKyB4bWluKSAqIDAuNSxcbiAgICAgICAgeW1pZCA9ICh5bWF4ICsgeW1pbikgKiAwLjUsXG4gICAgICAgIG9wZW4gPSBbXG4gICAgICAgICAgICBuZXcgVHJpYW5nbGUoe1xuICAgICAgICAgICAgICAgIHg6IHhtaWQgLSAyMCAqIGRtYXgsXG4gICAgICAgICAgICAgICAgeTogeW1pZCAtIGRtYXgsXG4gICAgICAgICAgICAgICAgX19zZW50aW5lbDogdHJ1ZVxuICAgICAgICAgICAgfSwge1xuICAgICAgICAgICAgICAgIHg6IHhtaWQsXG4gICAgICAgICAgICAgICAgeTogeW1pZCArIDIwICogZG1heCxcbiAgICAgICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogeG1pZCArIDIwICogZG1heCxcbiAgICAgICAgICAgICAgICB5OiB5bWlkIC0gZG1heCxcbiAgICAgICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlXG4gICAgICAgICAgICB9XG4gICAgICAgICldLFxuICAgICAgICBjbG9zZWQgPSBbXSxcbiAgICAgICAgZWRnZXMgPSBbXSxcbiAgICAgICAgaiwgYSwgYjtcblxuICAgIC8vIEluY3JlbWVudGFsbHkgYWRkIGVhY2ggdmVydGV4IHRvIHRoZSBtZXNoLlxuICAgIGkgPSB2ZXJ0aWNlcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICAvLyBGb3IgZWFjaCBvcGVuIHRyaWFuZ2xlLCBjaGVjayB0byBzZWUgaWYgdGhlIGN1cnJlbnQgcG9pbnQgaXNcbiAgICAgICAgLy8gaW5zaWRlIGl0J3MgY2lyY3VtY2lyY2xlLiBJZiBpdCBpcywgcmVtb3ZlIHRoZSB0cmlhbmdsZSBhbmQgYWRkXG4gICAgICAgIC8vIGl0J3MgZWRnZXMgdG8gYW4gZWRnZSBsaXN0LlxuICAgICAgICBlZGdlcy5sZW5ndGggPSAwO1xuICAgICAgICBqID0gb3Blbi5sZW5ndGg7XG4gICAgICAgIHdoaWxlIChqLS0pIHtcbiAgICAgICAgICAgIC8vIElmIHRoaXMgcG9pbnQgaXMgdG8gdGhlIHJpZ2h0IG9mIHRoaXMgdHJpYW5nbGUncyBjaXJjdW1jaXJjbGUsXG4gICAgICAgICAgICAvLyB0aGVuIHRoaXMgdHJpYW5nbGUgc2hvdWxkIG5ldmVyIGdldCBjaGVja2VkIGFnYWluLiBSZW1vdmUgaXRcbiAgICAgICAgICAgIC8vIGZyb20gdGhlIG9wZW4gbGlzdCwgYWRkIGl0IHRvIHRoZSBjbG9zZWQgbGlzdCwgYW5kIHNraXAuXG4gICAgICAgICAgICBkeCA9IHZlcnRpY2VzW2ldLnggLSBvcGVuW2pdLng7XG4gICAgICAgICAgICBpZiAoZHggPiAwICYmIGR4ICogZHggPiBvcGVuW2pdLnIpIHtcbiAgICAgICAgICAgICAgICBjbG9zZWQucHVzaChvcGVuW2pdKTtcbiAgICAgICAgICAgICAgICBvcGVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gSWYgbm90LCBza2lwIHRoaXMgdHJpYW5nbGUuXG4gICAgICAgICAgICBkeSA9IHZlcnRpY2VzW2ldLnkgLSBvcGVuW2pdLnk7XG4gICAgICAgICAgICBpZiAoZHggKiBkeCArIGR5ICogZHkgPiBvcGVuW2pdLnIpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG5cbiAgICAgICAgICAgIC8vIFJlbW92ZSB0aGUgdHJpYW5nbGUgYW5kIGFkZCBpdCdzIGVkZ2VzIHRvIHRoZSBlZGdlIGxpc3QuXG4gICAgICAgICAgICBlZGdlcy5wdXNoKFxuICAgICAgICBvcGVuW2pdLmEsIG9wZW5bal0uYixcbiAgICAgICAgb3BlbltqXS5iLCBvcGVuW2pdLmMsXG4gICAgICAgIG9wZW5bal0uYywgb3BlbltqXS5hXG4gICAgICApO1xuICAgICAgICAgICAgb3Blbi5zcGxpY2UoaiwgMSk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW1vdmUgYW55IGRvdWJsZWQgZWRnZXMuXG4gICAgICAgIGRlZHVwKGVkZ2VzKTtcblxuICAgICAgICAvLyBBZGQgYSBuZXcgdHJpYW5nbGUgZm9yIGVhY2ggZWRnZS5cbiAgICAgICAgaiA9IGVkZ2VzLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGopIHtcbiAgICAgICAgICAgIGIgPSBlZGdlc1stLWpdO1xuICAgICAgICAgICAgYSA9IGVkZ2VzWy0tal07XG4gICAgICAgICAgICBvcGVuLnB1c2gobmV3IFRyaWFuZ2xlKGEsIGIsIHZlcnRpY2VzW2ldKSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBDb3B5IGFueSByZW1haW5pbmcgb3BlbiB0cmlhbmdsZXMgdG8gdGhlIGNsb3NlZCBsaXN0LCBhbmQgdGhlblxuICAgIC8vIHJlbW92ZSBhbnkgdHJpYW5nbGVzIHRoYXQgc2hhcmUgYSB2ZXJ0ZXggd2l0aCB0aGUgc3VwZXJ0cmlhbmdsZS5cbiAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseShjbG9zZWQsIG9wZW4pO1xuXG4gICAgaSA9IGNsb3NlZC5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSlcbiAgICAgICAgaWYgKGNsb3NlZFtpXS5hLl9fc2VudGluZWwgfHxcbiAgICAgIGNsb3NlZFtpXS5iLl9fc2VudGluZWwgfHxcbiAgICAgIGNsb3NlZFtpXS5jLl9fc2VudGluZWwpXG4gICAgICAgICAgICBjbG9zZWQuc3BsaWNlKGksIDEpO1xuXG4gICAgcmV0dXJuIGNsb3NlZDtcbn1cbiIsInZhciBmZWF0dXJlY29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIHBvbHlnb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2x5Z29uO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBhIGNlbGwgZGVwdGggYW5kIHJldHVybnMgYSBzZXQgb2YgdHJpYW5ndWxhciB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gaW4gYSBncmlkLlxuICpcbiAqIEBuYW1lIHRyaWFuZ2xlR3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSBkaW1lbnNpb24gb2YgZWFjaCBjZWxsXG4gKiBAcGFyYW0ge3N0cmluZ30gdW5pdHMgdW5pdHMgdG8gdXNlIGZvciBjZWxsV2lkdGhcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBncmlkIG9mIHBvbHlnb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dGVudCA9IFstNzcuMzg3Njk1MzEyNSwzOC43MTk4MDQ3NDI2NDIzOSwtNzYuOTQ4MjQyMTg3NSwzOS4wMjc3MTg4NDAyMTE2MDVdO1xuICogdmFyIGNlbGxXaWR0aCA9IDEwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgdHJpYW5nbGVHcmlkID0gdHVyZi50cmlhbmdsZUdyaWQoZXh0ZW50LCBjZWxsV2lkdGgsIHVuaXRzKTtcbiAqXG4gKiAvLz10cmlhbmdsZUdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYmJveCwgY2VsbFNpemUsIHVuaXRzKSB7XG4gICAgdmFyIGZjID0gZmVhdHVyZWNvbGxlY3Rpb24oW10pO1xuICAgIHZhciB4RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShbYmJveFswXSwgYmJveFsxXV0sIFtiYm94WzJdLCBiYm94WzFdXSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbFdpZHRoID0geEZyYWN0aW9uICogKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UoW2Jib3hbMF0sIGJib3hbMV1dLCBbYmJveFswXSwgYmJveFszXV0sIHVuaXRzKSk7XG4gICAgdmFyIGNlbGxIZWlnaHQgPSB5RnJhY3Rpb24gKiAoYmJveFszXSAtIGJib3hbMV0pO1xuXG4gICAgdmFyIHhpID0gMDtcbiAgICB2YXIgY3VycmVudFggPSBiYm94WzBdO1xuICAgIHdoaWxlIChjdXJyZW50WCA8PSBiYm94WzJdKSB7XG4gICAgICAgIHZhciB5aSA9IDA7XG4gICAgICAgIHZhciBjdXJyZW50WSA9IGJib3hbMV07XG4gICAgICAgIHdoaWxlIChjdXJyZW50WSA8PSBiYm94WzNdKSB7XG4gICAgICAgICAgICBpZiAoeGkgJSAyID09PSAwICYmIHlpICUgMiA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICBdXSksIHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF1cbiAgICAgICAgICAgICAgICBdXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh4aSAlIDIgPT09IDAgJiYgeWkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgICAgIF1dKSwgcG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeWkgJSAyID09PSAwICYmIHhpICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pLCBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgICAgIF1dKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHlpICUgMiA9PT0gMSAmJiB4aSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pLCBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdXG4gICAgICAgICAgICAgICAgXV0pKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGN1cnJlbnRZICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgICAgICB5aSsrO1xuICAgICAgICB9XG4gICAgICAgIHhpKys7XG4gICAgICAgIGN1cnJlbnRYICs9IGNlbGxXaWR0aDtcbiAgICB9XG4gICAgcmV0dXJuIGZjO1xufTtcblxuIiwiLy8gbG9vayBoZXJlIGZvciBoZWxwIGh0dHA6Ly9zdm4ub3NnZW8ub3JnL2dyYXNzL2dyYXNzL2JyYW5jaGVzL3JlbGVhc2VicmFuY2hfNl80L3ZlY3Rvci92Lm92ZXJsYXkvbWFpbi5jXG4vL211c3QgYmUgYXJyYXkgb2YgcG9seWdvbnNcblxuLy8gZGVwZW5kIG9uIGpzdHMgZm9yIG5vdyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL292ZXJsYXkuaHRtbFxuXG52YXIganN0cyA9IHJlcXVpcmUoJ2pzdHMnKTtcblxuLyoqXG4gKiBUYWtlcyB0d28ge0BsaW5rIFBvbHlnb258cG9seWdvbnN9IGFuZCByZXR1cm5zIGEgY29tYmluZWQgcG9seWdvbi4gSWYgdGhlIGlucHV0IHBvbHlnb25zIGFyZSBub3QgY29udGlndW91cywgdGhpcyBmdW5jdGlvbiByZXR1cm5zIGEge0BsaW5rIE11bHRpUG9seWdvbn0gZmVhdHVyZS5cbiAqXG4gKiBAbmFtZSB1bmlvblxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5MSBpbnB1dCBwb2x5Z29uXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHBvbHkyIGFub3RoZXIgaW5wdXQgcG9seWdvblxuICogQHJldHVybiB7RmVhdHVyZTwoUG9seWdvbnxNdWx0aVBvbHlnb24pPn0gYSBjb21iaW5lZCB7QGxpbmsgUG9seWdvbn0gb3Ige0BsaW5rIE11bHRpUG9seWdvbn0gZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy04Mi41NzQ3ODcsIDM1LjU5NDA4N10sXG4gKiAgICAgICBbLTgyLjU3NDc4NywgMzUuNjE1NTgxXSxcbiAqICAgICAgIFstODIuNTQ1MjYxLCAzNS42MTU1ODFdLFxuICogICAgICAgWy04Mi41NDUyNjEsIDM1LjU5NDA4N10sXG4gKiAgICAgICBbLTgyLjU3NDc4NywgMzUuNTk0MDg3XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcG9seTIgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcImZpbGxcIjogXCIjMDBmXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgIFstODIuNTYwMDI0LCAzNS41ODUxNTNdLFxuICogICAgICAgWy04Mi41NjAwMjQsIDM1LjYwMjYwMl0sXG4gKiAgICAgICBbLTgyLjUyOTY0LCAzNS42MDI2MDJdLFxuICogICAgICAgWy04Mi41Mjk2NCwgMzUuNTg1MTUzXSxcbiAqICAgICAgIFstODIuNTYwMDI0LCAzNS41ODUxNTNdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5Z29ucyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seTEsIHBvbHkyXVxuICogfTtcbiAqXG4gKiB2YXIgdW5pb24gPSB0dXJmLnVuaW9uKHBvbHkxLCBwb2x5Mik7XG4gKlxuICogLy89cG9seWdvbnNcbiAqXG4gKiAvLz11bmlvblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2x5MSwgcG9seTIpIHtcbiAgICB2YXIgcmVhZGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTlJlYWRlcigpO1xuICAgIHZhciBhID0gcmVhZGVyLnJlYWQoSlNPTi5zdHJpbmdpZnkocG9seTEuZ2VvbWV0cnkpKTtcbiAgICB2YXIgYiA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KHBvbHkyLmdlb21ldHJ5KSk7XG4gICAgdmFyIHVuaW9uID0gYS51bmlvbihiKTtcbiAgICB2YXIgd3JpdGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTldyaXRlcigpO1xuXG4gICAgdW5pb24gPSB3cml0ZXIud3JpdGUodW5pb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgZ2VvbWV0cnk6IHVuaW9uLFxuICAgICAgICBwcm9wZXJ0aWVzOiBwb2x5MS5wcm9wZXJ0aWVzXG4gICAgfTtcbn07XG4iLCJ2YXIgaW5zaWRlID0gcmVxdWlyZSgndHVyZi1pbnNpZGUnKTtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBhIHNldCBvZiB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gYW5kIHJldHVybnMgdGhlIHBvaW50cyB0aGF0IGZhbGwgd2l0aGluIHRoZSBwb2x5Z29ucy5cbiAqXG4gKiBAbmFtZSB3aXRoaW5cbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgaW5wdXQgcG9pbnRzXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyBpbnB1dCBwb2x5Z29uc1xuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgdGhhdCBsYW5kIHdpdGhpbiBhdCBsZWFzdCBvbmUgcG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBzZWFyY2hXaXRoaW4gPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogW1tcbiAqICAgICAgICAgICBbLTQ2LjY1MywtMjMuNTQzXSxcbiAqICAgICAgICAgICBbLTQ2LjYzNCwtMjMuNTM0Nl0sXG4gKiAgICAgICAgICAgWy00Ni42MTMsLTIzLjU0M10sXG4gKiAgICAgICAgICAgWy00Ni42MTQsLTIzLjU1OV0sXG4gKiAgICAgICAgICAgWy00Ni42MzEsLTIzLjU2N10sXG4gKiAgICAgICAgICAgWy00Ni42NTMsLTIzLjU2MF0sXG4gKiAgICAgICAgICAgWy00Ni42NTMsLTIzLjU0M11cbiAqICAgICAgICAgXV1cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjYzMTgsIC0yMy41NTIzXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNDYuNjI0NiwgLTIzLjUzMjVdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy00Ni42MDYyLCAtMjMuNTUxM11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjY2MywgLTIzLjU1NF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjY0MywgLTIzLjU1N11cbiAqICAgICAgIH1cbiAqICAgICB9XG4gKiAgIF1cbiAqIH07XG4gKlxuICogdmFyIHB0c1dpdGhpbiA9IHR1cmYud2l0aGluKHBvaW50cywgc2VhcmNoV2l0aGluKTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiAvLz1zZWFyY2hXaXRoaW5cbiAqXG4gKiAvLz1wdHNXaXRoaW5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCBwb2x5Z29ucykge1xuICAgIHZhciBwb2ludHNXaXRoaW4gPSBmZWF0dXJlQ29sbGVjdGlvbihbXSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2x5Z29ucy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHBvaW50cy5mZWF0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIGlzSW5zaWRlID0gaW5zaWRlKHBvaW50cy5mZWF0dXJlc1tqXSwgcG9seWdvbnMuZmVhdHVyZXNbaV0pO1xuICAgICAgICAgICAgaWYgKGlzSW5zaWRlKSB7XG4gICAgICAgICAgICAgICAgcG9pbnRzV2l0aGluLmZlYXR1cmVzLnB1c2gocG9pbnRzLmZlYXR1cmVzW2pdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnRzV2l0aGluO1xufTtcbiIsIi8qZXNsaW50IGdsb2JhbC1yZXF1aXJlOiAwKi9cblxuLyoqXG4gKiBUdXJmIGlzIGEgbW9kdWxhciBnZW9zcGF0aWFsIGFuYWx5c2lzIGVuZ2luZSB3cml0dGVuIGluIEphdmFTY3JpcHQuIEl0IHBlcmZvcm1zIGdlb3NwYXRpYWxcbiAqIHByb2Nlc3NpbmcgdGFza3Mgd2l0aCBHZW9KU09OIGRhdGEgYW5kIGNhbiBiZSBydW4gb24gYSBzZXJ2ZXIgb3IgaW4gYSBicm93c2VyLlxuICpcbiAqIEBtb2R1bGUgdHVyZlxuICogQHN1bW1hcnkgR2Vvc3BhdGlhbCBhbmFseXNpcyBmb3IgSmF2YVNjcmlwdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICBpc29saW5lczogcmVxdWlyZSgndHVyZi1pc29saW5lcycpLFxuICAgIGNvbnZleDogcmVxdWlyZSgndHVyZi1jb252ZXgnKSxcbiAgICB3aXRoaW46IHJlcXVpcmUoJ3R1cmYtd2l0aGluJyksXG4gICAgY29uY2F2ZTogcmVxdWlyZSgndHVyZi1jb25jYXZlJyksXG4gICAgZGlmZmVyZW5jZTogcmVxdWlyZSgndHVyZi1kaWZmZXJlbmNlJyksXG4gICAgY29sbGVjdDogcmVxdWlyZSgndHVyZi1jb2xsZWN0JyksXG4gICAgZmxpcDogcmVxdWlyZSgndHVyZi1mbGlwJyksXG4gICAgc2ltcGxpZnk6IHJlcXVpcmUoJ3R1cmYtc2ltcGxpZnknKSxcbiAgICBiZXppZXI6IHJlcXVpcmUoJ3R1cmYtYmV6aWVyJyksXG4gICAgdGFnOiByZXF1aXJlKCd0dXJmLXRhZycpLFxuICAgIHNhbXBsZTogcmVxdWlyZSgndHVyZi1zYW1wbGUnKSxcbiAgICBlbnZlbG9wZTogcmVxdWlyZSgndHVyZi1lbnZlbG9wZScpLFxuICAgIHNxdWFyZTogcmVxdWlyZSgndHVyZi1zcXVhcmUnKSxcbiAgICBtaWRwb2ludDogcmVxdWlyZSgndHVyZi1taWRwb2ludCcpLFxuICAgIGJ1ZmZlcjogcmVxdWlyZSgndHVyZi1idWZmZXInKSxcbiAgICBjZW50ZXI6IHJlcXVpcmUoJ3R1cmYtY2VudGVyJyksXG4gICAgY2VudHJvaWQ6IHJlcXVpcmUoJ3R1cmYtY2VudHJvaWQnKSxcbiAgICBjb21iaW5lOiByZXF1aXJlKCd0dXJmLWNvbWJpbmUnKSxcbiAgICBkaXN0YW5jZTogcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpLFxuICAgIGV4cGxvZGU6IHJlcXVpcmUoJ3R1cmYtZXhwbG9kZScpLFxuICAgIGJib3g6IHJlcXVpcmUoJ3R1cmYtYmJveCcpLFxuICAgIHRlc3NlbGF0ZTogcmVxdWlyZSgndHVyZi10ZXNzZWxhdGUnKSxcbiAgICBiYm94UG9seWdvbjogcmVxdWlyZSgndHVyZi1iYm94LXBvbHlnb24nKSxcbiAgICBpbnNpZGU6IHJlcXVpcmUoJ3R1cmYtaW5zaWRlJyksXG4gICAgaW50ZXJzZWN0OiByZXF1aXJlKCd0dXJmLWludGVyc2VjdCcpLFxuICAgIG5lYXJlc3Q6IHJlcXVpcmUoJ3R1cmYtbmVhcmVzdCcpLFxuICAgIHBsYW5lcG9pbnQ6IHJlcXVpcmUoJ3R1cmYtcGxhbmVwb2ludCcpLFxuICAgIHJhbmRvbTogcmVxdWlyZSgndHVyZi1yYW5kb20nKSxcbiAgICB0aW46IHJlcXVpcmUoJ3R1cmYtdGluJyksXG4gICAgdW5pb246IHJlcXVpcmUoJ3R1cmYtdW5pb24nKSxcbiAgICBiZWFyaW5nOiByZXF1aXJlKCd0dXJmLWJlYXJpbmcnKSxcbiAgICBkZXN0aW5hdGlvbjogcmVxdWlyZSgndHVyZi1kZXN0aW5hdGlvbicpLFxuICAgIGtpbmtzOiByZXF1aXJlKCd0dXJmLWtpbmtzJyksXG4gICAgcG9pbnRPblN1cmZhY2U6IHJlcXVpcmUoJ3R1cmYtcG9pbnQtb24tc3VyZmFjZScpLFxuICAgIGFyZWE6IHJlcXVpcmUoJ3R1cmYtYXJlYScpLFxuICAgIGFsb25nOiByZXF1aXJlKCd0dXJmLWFsb25nJyksXG4gICAgbGluZURpc3RhbmNlOiByZXF1aXJlKCd0dXJmLWxpbmUtZGlzdGFuY2UnKSxcbiAgICBsaW5lU2xpY2U6IHJlcXVpcmUoJ3R1cmYtbGluZS1zbGljZScpLFxuICAgIHBvaW50T25MaW5lOiByZXF1aXJlKCd0dXJmLXBvaW50LW9uLWxpbmUnKSxcbiAgICBwb2ludEdyaWQ6IHJlcXVpcmUoJ3R1cmYtcG9pbnQtZ3JpZCcpLFxuICAgIHNxdWFyZUdyaWQ6IHJlcXVpcmUoJ3R1cmYtc3F1YXJlLWdyaWQnKSxcbiAgICB0cmlhbmdsZUdyaWQ6IHJlcXVpcmUoJ3R1cmYtdHJpYW5nbGUtZ3JpZCcpLFxuICAgIGhleEdyaWQ6IHJlcXVpcmUoJ3R1cmYtaGV4LWdyaWQnKVxufTtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKTtcblxubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBoZWxwZXJzLnBvaW50O1xubW9kdWxlLmV4cG9ydHMucG9seWdvbiA9IGhlbHBlcnMucG9seWdvbjtcbm1vZHVsZS5leHBvcnRzLmxpbmVTdHJpbmcgPSBoZWxwZXJzLmxpbmVTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cy5tdWx0aVBvaW50ID0gaGVscGVycy5tdWx0aVBvaW50O1xubW9kdWxlLmV4cG9ydHMubXVsdGlQb2x5Z29uID0gaGVscGVycy5tdWx0aVBvbHlnb247XG5tb2R1bGUuZXhwb3J0cy5tdWx0aUxpbmVTdHJpbmcgPSBoZWxwZXJzLm11bHRpTGluZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLmZlYXR1cmUgPSBoZWxwZXJzLmZlYXR1cmU7XG5tb2R1bGUuZXhwb3J0cy5mZWF0dXJlQ29sbGVjdGlvbiA9IGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb247XG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeUNvbGxlY3Rpb24gPSBoZWxwZXJzLmdlb21ldHJ5Q29sbGVjdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gdHdvUHJvZHVjdFxuXG52YXIgU1BMSVRURVIgPSArKE1hdGgucG93KDIsIDI3KSArIDEuMClcblxuZnVuY3Rpb24gdHdvUHJvZHVjdChhLCBiLCByZXN1bHQpIHtcbiAgdmFyIHggPSBhICogYlxuXG4gIHZhciBjID0gU1BMSVRURVIgKiBhXG4gIHZhciBhYmlnID0gYyAtIGFcbiAgdmFyIGFoaSA9IGMgLSBhYmlnXG4gIHZhciBhbG8gPSBhIC0gYWhpXG5cbiAgdmFyIGQgPSBTUExJVFRFUiAqIGJcbiAgdmFyIGJiaWcgPSBkIC0gYlxuICB2YXIgYmhpID0gZCAtIGJiaWdcbiAgdmFyIGJsbyA9IGIgLSBiaGlcblxuICB2YXIgZXJyMSA9IHggLSAoYWhpICogYmhpKVxuICB2YXIgZXJyMiA9IGVycjEgLSAoYWxvICogYmhpKVxuICB2YXIgZXJyMyA9IGVycjIgLSAoYWhpICogYmxvKVxuXG4gIHZhciB5ID0gYWxvICogYmxvIC0gZXJyM1xuXG4gIGlmKHJlc3VsdCkge1xuICAgIHJlc3VsdFswXSA9IHlcbiAgICByZXN1bHRbMV0gPSB4XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgcmV0dXJuIFsgeSwgeCBdXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSBmYXN0VHdvU3VtXG5cbmZ1bmN0aW9uIGZhc3RUd29TdW0oYSwgYiwgcmVzdWx0KSB7XG5cdHZhciB4ID0gYSArIGJcblx0dmFyIGJ2ID0geCAtIGFcblx0dmFyIGF2ID0geCAtIGJ2XG5cdHZhciBiciA9IGIgLSBidlxuXHR2YXIgYXIgPSBhIC0gYXZcblx0aWYocmVzdWx0KSB7XG5cdFx0cmVzdWx0WzBdID0gYXIgKyBiclxuXHRcdHJlc3VsdFsxXSA9IHhcblx0XHRyZXR1cm4gcmVzdWx0XG5cdH1cblx0cmV0dXJuIFthciticiwgeF1cbn0iLCJcInVzZSBzdHJpY3RcIjsgXCJ1c2UgcmVzdHJpY3RcIjtcblxubW9kdWxlLmV4cG9ydHMgPSBVbmlvbkZpbmQ7XG5cbmZ1bmN0aW9uIFVuaW9uRmluZChjb3VudCkge1xuICB0aGlzLnJvb3RzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgdGhpcy5yYW5rcyA9IG5ldyBBcnJheShjb3VudCk7XG4gIFxuICBmb3IodmFyIGk9MDsgaTxjb3VudDsgKytpKSB7XG4gICAgdGhpcy5yb290c1tpXSA9IGk7XG4gICAgdGhpcy5yYW5rc1tpXSA9IDA7XG4gIH1cbn1cblxudmFyIHByb3RvID0gVW5pb25GaW5kLnByb3RvdHlwZVxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkocHJvdG8sIFwibGVuZ3RoXCIsIHtcbiAgXCJnZXRcIjogZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMucm9vdHMubGVuZ3RoXG4gIH1cbn0pXG5cbnByb3RvLm1ha2VTZXQgPSBmdW5jdGlvbigpIHtcbiAgdmFyIG4gPSB0aGlzLnJvb3RzLmxlbmd0aDtcbiAgdGhpcy5yb290cy5wdXNoKG4pO1xuICB0aGlzLnJhbmtzLnB1c2goMCk7XG4gIHJldHVybiBuO1xufVxuXG5wcm90by5maW5kID0gZnVuY3Rpb24oeCkge1xuICB2YXIgeDAgPSB4XG4gIHZhciByb290cyA9IHRoaXMucm9vdHM7XG4gIHdoaWxlKHJvb3RzW3hdICE9PSB4KSB7XG4gICAgeCA9IHJvb3RzW3hdXG4gIH1cbiAgd2hpbGUocm9vdHNbeDBdICE9PSB4KSB7XG4gICAgdmFyIHkgPSByb290c1t4MF1cbiAgICByb290c1t4MF0gPSB4XG4gICAgeDAgPSB5XG4gIH1cbiAgcmV0dXJuIHg7XG59XG5cbnByb3RvLmxpbmsgPSBmdW5jdGlvbih4LCB5KSB7XG4gIHZhciB4ciA9IHRoaXMuZmluZCh4KVxuICAgICwgeXIgPSB0aGlzLmZpbmQoeSk7XG4gIGlmKHhyID09PSB5cikge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgcmFua3MgPSB0aGlzLnJhbmtzXG4gICAgLCByb290cyA9IHRoaXMucm9vdHNcbiAgICAsIHhkICAgID0gcmFua3NbeHJdXG4gICAgLCB5ZCAgICA9IHJhbmtzW3lyXTtcbiAgaWYoeGQgPCB5ZCkge1xuICAgIHJvb3RzW3hyXSA9IHlyO1xuICB9IGVsc2UgaWYoeWQgPCB4ZCkge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICB9IGVsc2Uge1xuICAgIHJvb3RzW3lyXSA9IHhyO1xuICAgICsrcmFua3NbeHJdO1xuICB9XG59IiwiLyoqXG4gKiBDb252ZXJ0IGFycmF5IG9mIDE2IGJ5dGUgdmFsdWVzIHRvIFVVSUQgc3RyaW5nIGZvcm1hdCBvZiB0aGUgZm9ybTpcbiAqIFhYWFhYWFhYLVhYWFgtWFhYWC1YWFhYLVhYWFhYWFhYWFhYWFxuICovXG52YXIgYnl0ZVRvSGV4ID0gW107XG5mb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgKytpKSB7XG4gIGJ5dGVUb0hleFtpXSA9IChpICsgMHgxMDApLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSk7XG59XG5cbmZ1bmN0aW9uIGJ5dGVzVG9VdWlkKGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gb2Zmc2V0IHx8IDA7XG4gIHZhciBidGggPSBieXRlVG9IZXg7XG4gIC8vIGpvaW4gdXNlZCB0byBmaXggbWVtb3J5IGlzc3VlIGNhdXNlZCBieSBjb25jYXRlbmF0aW9uOiBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMTc1I2M0XG4gIHJldHVybiAoW2J0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sIFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcblx0YnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuXHRidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sXG5cdGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1dKS5qb2luKCcnKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBieXRlc1RvVXVpZDtcbiIsIi8vIFVuaXF1ZSBJRCBjcmVhdGlvbiByZXF1aXJlcyBhIGhpZ2ggcXVhbGl0eSByYW5kb20gIyBnZW5lcmF0b3IuICBJbiB0aGVcbi8vIGJyb3dzZXIgdGhpcyBpcyBhIGxpdHRsZSBjb21wbGljYXRlZCBkdWUgdG8gdW5rbm93biBxdWFsaXR5IG9mIE1hdGgucmFuZG9tKClcbi8vIGFuZCBpbmNvbnNpc3RlbnQgc3VwcG9ydCBmb3IgdGhlIGBjcnlwdG9gIEFQSS4gIFdlIGRvIHRoZSBiZXN0IHdlIGNhbiB2aWFcbi8vIGZlYXR1cmUtZGV0ZWN0aW9uXG5cbi8vIGdldFJhbmRvbVZhbHVlcyBuZWVkcyB0byBiZSBpbnZva2VkIGluIGEgY29udGV4dCB3aGVyZSBcInRoaXNcIiBpcyBhIENyeXB0b1xuLy8gaW1wbGVtZW50YXRpb24uIEFsc28sIGZpbmQgdGhlIGNvbXBsZXRlIGltcGxlbWVudGF0aW9uIG9mIGNyeXB0byBvbiBJRTExLlxudmFyIGdldFJhbmRvbVZhbHVlcyA9ICh0eXBlb2YoY3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICYmIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMuYmluZChjcnlwdG8pKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YobXNDcnlwdG8pICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiB3aW5kb3cubXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzID09ICdmdW5jdGlvbicgJiYgbXNDcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQobXNDcnlwdG8pKTtcblxuaWYgKGdldFJhbmRvbVZhbHVlcykge1xuICAvLyBXSEFUV0cgY3J5cHRvIFJORyAtIGh0dHA6Ly93aWtpLndoYXR3Zy5vcmcvd2lraS9DcnlwdG9cbiAgdmFyIHJuZHM4ID0gbmV3IFVpbnQ4QXJyYXkoMTYpOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXVuZGVmXG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB3aGF0d2dSTkcoKSB7XG4gICAgZ2V0UmFuZG9tVmFsdWVzKHJuZHM4KTtcbiAgICByZXR1cm4gcm5kczg7XG4gIH07XG59IGVsc2Uge1xuICAvLyBNYXRoLnJhbmRvbSgpLWJhc2VkIChSTkcpXG4gIC8vXG4gIC8vIElmIGFsbCBlbHNlIGZhaWxzLCB1c2UgTWF0aC5yYW5kb20oKS4gIEl0J3MgZmFzdCwgYnV0IGlzIG9mIHVuc3BlY2lmaWVkXG4gIC8vIHF1YWxpdHkuXG4gIHZhciBybmRzID0gbmV3IEFycmF5KDE2KTtcblxuICBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG1hdGhSTkcoKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIHI7IGkgPCAxNjsgaSsrKSB7XG4gICAgICBpZiAoKGkgJiAweDAzKSA9PT0gMCkgciA9IE1hdGgucmFuZG9tKCkgKiAweDEwMDAwMDAwMDtcbiAgICAgIHJuZHNbaV0gPSByID4+PiAoKGkgJiAweDAzKSA8PCAzKSAmIDB4ZmY7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJuZHM7XG4gIH07XG59XG4iLCJ2YXIgcm5nID0gcmVxdWlyZSgnLi9saWIvcm5nJyk7XG52YXIgYnl0ZXNUb1V1aWQgPSByZXF1aXJlKCcuL2xpYi9ieXRlc1RvVXVpZCcpO1xuXG4vLyAqKmB2MSgpYCAtIEdlbmVyYXRlIHRpbWUtYmFzZWQgVVVJRCoqXG4vL1xuLy8gSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL0xpb3NLL1VVSUQuanNcbi8vIGFuZCBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvdXVpZC5odG1sXG5cbnZhciBfbm9kZUlkO1xudmFyIF9jbG9ja3NlcTtcblxuLy8gUHJldmlvdXMgdXVpZCBjcmVhdGlvbiB0aW1lXG52YXIgX2xhc3RNU2VjcyA9IDA7XG52YXIgX2xhc3ROU2VjcyA9IDA7XG5cbi8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vYnJvb2ZhL25vZGUtdXVpZCBmb3IgQVBJIGRldGFpbHNcbmZ1bmN0aW9uIHYxKG9wdGlvbnMsIGJ1Ziwgb2Zmc2V0KSB7XG4gIHZhciBpID0gYnVmICYmIG9mZnNldCB8fCAwO1xuICB2YXIgYiA9IGJ1ZiB8fCBbXTtcblxuICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdmFyIG5vZGUgPSBvcHRpb25zLm5vZGUgfHwgX25vZGVJZDtcbiAgdmFyIGNsb2Nrc2VxID0gb3B0aW9ucy5jbG9ja3NlcSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5jbG9ja3NlcSA6IF9jbG9ja3NlcTtcblxuICAvLyBub2RlIGFuZCBjbG9ja3NlcSBuZWVkIHRvIGJlIGluaXRpYWxpemVkIHRvIHJhbmRvbSB2YWx1ZXMgaWYgdGhleSdyZSBub3RcbiAgLy8gc3BlY2lmaWVkLiAgV2UgZG8gdGhpcyBsYXppbHkgdG8gbWluaW1pemUgaXNzdWVzIHJlbGF0ZWQgdG8gaW5zdWZmaWNpZW50XG4gIC8vIHN5c3RlbSBlbnRyb3B5LiAgU2VlICMxODlcbiAgaWYgKG5vZGUgPT0gbnVsbCB8fCBjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgdmFyIHNlZWRCeXRlcyA9IHJuZygpO1xuICAgIGlmIChub2RlID09IG51bGwpIHtcbiAgICAgIC8vIFBlciA0LjUsIGNyZWF0ZSBhbmQgNDgtYml0IG5vZGUgaWQsICg0NyByYW5kb20gYml0cyArIG11bHRpY2FzdCBiaXQgPSAxKVxuICAgICAgbm9kZSA9IF9ub2RlSWQgPSBbXG4gICAgICAgIHNlZWRCeXRlc1swXSB8IDB4MDEsXG4gICAgICAgIHNlZWRCeXRlc1sxXSwgc2VlZEJ5dGVzWzJdLCBzZWVkQnl0ZXNbM10sIHNlZWRCeXRlc1s0XSwgc2VlZEJ5dGVzWzVdXG4gICAgICBdO1xuICAgIH1cbiAgICBpZiAoY2xvY2tzZXEgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuMi4yLCByYW5kb21pemUgKDE0IGJpdCkgY2xvY2tzZXFcbiAgICAgIGNsb2Nrc2VxID0gX2Nsb2Nrc2VxID0gKHNlZWRCeXRlc1s2XSA8PCA4IHwgc2VlZEJ5dGVzWzddKSAmIDB4M2ZmZjtcbiAgICB9XG4gIH1cblxuICAvLyBVVUlEIHRpbWVzdGFtcHMgYXJlIDEwMCBuYW5vLXNlY29uZCB1bml0cyBzaW5jZSB0aGUgR3JlZ29yaWFuIGVwb2NoLFxuICAvLyAoMTU4Mi0xMC0xNSAwMDowMCkuICBKU051bWJlcnMgYXJlbid0IHByZWNpc2UgZW5vdWdoIGZvciB0aGlzLCBzb1xuICAvLyB0aW1lIGlzIGhhbmRsZWQgaW50ZXJuYWxseSBhcyAnbXNlY3MnIChpbnRlZ2VyIG1pbGxpc2Vjb25kcykgYW5kICduc2VjcydcbiAgLy8gKDEwMC1uYW5vc2Vjb25kcyBvZmZzZXQgZnJvbSBtc2Vjcykgc2luY2UgdW5peCBlcG9jaCwgMTk3MC0wMS0wMSAwMDowMC5cbiAgdmFyIG1zZWNzID0gb3B0aW9ucy5tc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5tc2VjcyA6IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIC8vIFBlciA0LjIuMS4yLCB1c2UgY291bnQgb2YgdXVpZCdzIGdlbmVyYXRlZCBkdXJpbmcgdGhlIGN1cnJlbnQgY2xvY2tcbiAgLy8gY3ljbGUgdG8gc2ltdWxhdGUgaGlnaGVyIHJlc29sdXRpb24gY2xvY2tcbiAgdmFyIG5zZWNzID0gb3B0aW9ucy5uc2VjcyAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uc2VjcyA6IF9sYXN0TlNlY3MgKyAxO1xuXG4gIC8vIFRpbWUgc2luY2UgbGFzdCB1dWlkIGNyZWF0aW9uIChpbiBtc2VjcylcbiAgdmFyIGR0ID0gKG1zZWNzIC0gX2xhc3RNU2VjcykgKyAobnNlY3MgLSBfbGFzdE5TZWNzKS8xMDAwMDtcblxuICAvLyBQZXIgNC4yLjEuMiwgQnVtcCBjbG9ja3NlcSBvbiBjbG9jayByZWdyZXNzaW9uXG4gIGlmIChkdCA8IDAgJiYgb3B0aW9ucy5jbG9ja3NlcSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xvY2tzZXEgPSBjbG9ja3NlcSArIDEgJiAweDNmZmY7XG4gIH1cblxuICAvLyBSZXNldCBuc2VjcyBpZiBjbG9jayByZWdyZXNzZXMgKG5ldyBjbG9ja3NlcSkgb3Igd2UndmUgbW92ZWQgb250byBhIG5ld1xuICAvLyB0aW1lIGludGVydmFsXG4gIGlmICgoZHQgPCAwIHx8IG1zZWNzID4gX2xhc3RNU2VjcykgJiYgb3B0aW9ucy5uc2VjcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgbnNlY3MgPSAwO1xuICB9XG5cbiAgLy8gUGVyIDQuMi4xLjIgVGhyb3cgZXJyb3IgaWYgdG9vIG1hbnkgdXVpZHMgYXJlIHJlcXVlc3RlZFxuICBpZiAobnNlY3MgPj0gMTAwMDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3V1aWQudjEoKTogQ2FuXFwndCBjcmVhdGUgbW9yZSB0aGFuIDEwTSB1dWlkcy9zZWMnKTtcbiAgfVxuXG4gIF9sYXN0TVNlY3MgPSBtc2VjcztcbiAgX2xhc3ROU2VjcyA9IG5zZWNzO1xuICBfY2xvY2tzZXEgPSBjbG9ja3NlcTtcblxuICAvLyBQZXIgNC4xLjQgLSBDb252ZXJ0IGZyb20gdW5peCBlcG9jaCB0byBHcmVnb3JpYW4gZXBvY2hcbiAgbXNlY3MgKz0gMTIyMTkyOTI4MDAwMDA7XG5cbiAgLy8gYHRpbWVfbG93YFxuICB2YXIgdGwgPSAoKG1zZWNzICYgMHhmZmZmZmZmKSAqIDEwMDAwICsgbnNlY3MpICUgMHgxMDAwMDAwMDA7XG4gIGJbaSsrXSA9IHRsID4+PiAyNCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiAxNiAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRsID4+PiA4ICYgMHhmZjtcbiAgYltpKytdID0gdGwgJiAweGZmO1xuXG4gIC8vIGB0aW1lX21pZGBcbiAgdmFyIHRtaCA9IChtc2VjcyAvIDB4MTAwMDAwMDAwICogMTAwMDApICYgMHhmZmZmZmZmO1xuICBiW2krK10gPSB0bWggPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bWggJiAweGZmO1xuXG4gIC8vIGB0aW1lX2hpZ2hfYW5kX3ZlcnNpb25gXG4gIGJbaSsrXSA9IHRtaCA+Pj4gMjQgJiAweGYgfCAweDEwOyAvLyBpbmNsdWRlIHZlcnNpb25cbiAgYltpKytdID0gdG1oID4+PiAxNiAmIDB4ZmY7XG5cbiAgLy8gYGNsb2NrX3NlcV9oaV9hbmRfcmVzZXJ2ZWRgIChQZXIgNC4yLjIgLSBpbmNsdWRlIHZhcmlhbnQpXG4gIGJbaSsrXSA9IGNsb2Nrc2VxID4+PiA4IHwgMHg4MDtcblxuICAvLyBgY2xvY2tfc2VxX2xvd2BcbiAgYltpKytdID0gY2xvY2tzZXEgJiAweGZmO1xuXG4gIC8vIGBub2RlYFxuICBmb3IgKHZhciBuID0gMDsgbiA8IDY7ICsrbikge1xuICAgIGJbaSArIG5dID0gbm9kZVtuXTtcbiAgfVxuXG4gIHJldHVybiBidWYgPyBidWYgOiBieXRlc1RvVXVpZChiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSB2MTtcbiIsIm1vZHVsZS5leHBvcnRzLlJBRElVUyA9IDYzNzgxMzc7XG5tb2R1bGUuZXhwb3J0cy5GTEFUVEVOSU5HID0gMS8yOTguMjU3MjIzNTYzO1xubW9kdWxlLmV4cG9ydHMuUE9MQVJfUkFESVVTID0gNjM1Njc1Mi4zMTQyO1xuIiwiaW1wb3J0IElFbmdpbmUgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUVuZ2luZSc7XHJcbmltcG9ydCBJS2V5Ym9hcmRBZGFwdG9yIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lLZXlib2FyZEFkYXB0b3InO1xyXG5pbXBvcnQgSU1vdXNlQWRhcHRvciBmcm9tICcuLi9lbmdpbmUvaW50ZXJmYWNlcy9JTW91c2VBZGFwdG9yJztcclxuaW1wb3J0IElWaWV3cG9ydEFkYXB0b3IgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSVZpZXdwb3J0QWRhcHRvcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBcHAge1xyXG5cclxuICAgIHB1YmxpYyB2aWV3cG9ydDogSVZpZXdwb3J0QWRhcHRvcjtcclxuICAgIHB1YmxpYyBtb3VzZTogSU1vdXNlQWRhcHRvcjtcclxuICAgIHB1YmxpYyBrZXlib2FyZDogSUtleWJvYXJkQWRhcHRvcjtcclxuICAgIHB1YmxpYyBlbmdpbmU6IElFbmdpbmU7XHJcblxyXG4gICAgcHJpdmF0ZSBfX29uTG9vcDogKCkgPT4gdm9pZDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7IHZpZXdwb3J0LCBtb3VzZSwga2V5Ym9hcmQsIGdhbWUgfVxyXG4gICAgICAgIDogeyB2aWV3cG9ydDogSVZpZXdwb3J0QWRhcHRvciwgbW91c2U6IElNb3VzZUFkYXB0b3IsIGtleWJvYXJkOiBJS2V5Ym9hcmRBZGFwdG9yLCBnYW1lOiBJRW5naW5lIH0sXHJcbiAgICApIHtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICAgICAgdGhpcy5tb3VzZSA9IG1vdXNlO1xyXG4gICAgICAgIHRoaXMua2V5Ym9hcmQgPSBrZXlib2FyZDtcclxuICAgICAgICB0aGlzLmVuZ2luZSA9IGdhbWU7XHJcbiAgICAgICAgdGhpcy5fX29uTG9vcCA9ICgpID0+IHVuZGVmaW5lZDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25Mb29wKG9uTG9vcDogKCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19vbkxvb3AgPSBvbkxvb3A7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy52aWV3cG9ydC5yZWZyZXNoKCk7XHJcbiAgICAgICAgdGhpcy5tb3VzZS5vbmNlKCk7XHJcbiAgICAgICAgdGhpcy5rZXlib2FyZC5vbmNlKCk7XHJcbiAgICAgICAgdGhpcy5lbmdpbmUub25jZSgpO1xyXG4gICAgICAgIHRoaXMuZW5naW5lLmRyYXcoKTtcclxuICAgICAgICB0aGlzLl9fb25Mb29wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xyXG4gICAgICAgIHNldEludGVydmFsKHRoaXMub25jZS5iaW5kKHRoaXMpLCAxMDAwIC8gMjQwKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQ29tcG9uZW50IH0gZnJvbSAnLi4vZW5naW5lL0NvbXBvbmVudCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElSaXZldFJlbmRlcmluZ1Byb2ZpbGUge1xyXG4gICAgY29sb3VyOiBzdHJpbmc7XHJcbiAgICByYWRpdXM6IG51bWJlcjtcclxuICAgIHpJbmRleD86IG51bWJlcjtcclxufVxyXG5leHBvcnQgY2xhc3MgUml2ZXRDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQ8SVJpdmV0UmVuZGVyaW5nUHJvZmlsZT4ge31cclxuIiwiaW1wb3J0IEVudGl0eSBmcm9tICcuLi8uLi9lbmdpbmUvRW50aXR5JztcclxuaW1wb3J0IHsgUG9zZSwgU2hhcGUsIFNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9IGZyb20gJy4uLy4uL2VuZ2luZS9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgZ2V0RXVjbGlkZWFuRGlzdGFuY2VCZXR3ZWVuUG9pbnRzIH0gZnJvbSAnLi4vLi4vZW5naW5lL2dlb21ldHJ5JztcclxuaW1wb3J0IHsgSW5wdXRUZXJtaW5hbCwgT3V0cHV0VGVybWluYWwgfSBmcm9tICcuL3Rlcm1pbmFscyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBXaXJlIGV4dGVuZHMgRW50aXR5IHtcclxuXHJcbiAgICBwdWJsaWMgaW5wdXQ6IElucHV0VGVybWluYWw7XHJcbiAgICBwdWJsaWMgb3V0cHV0OiBPdXRwdXRUZXJtaW5hbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7IGlucHV0LCBvdXRwdXQgfTogeyBpbnB1dDogSW5wdXRUZXJtaW5hbCwgb3V0cHV0OiBPdXRwdXRUZXJtaW5hbCB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSBvdXRwdXQ7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdXSElURScgfSk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVQb3NlKCk7XHJcbiAgICAgICAgdGhpcy51cGRhdGVTaGFwZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBoaWdoKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJG11dGF0ZShTaGFwZVJlbmRlcmluZ1Byb2ZpbGUpKHsgY29sb3VyOiAnR1JFRU4nIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBsb3coKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kbXV0YXRlKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdSRUQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kbXV0YXRlKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdXSElURScgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVBvc2UoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaW5Qb3NlID0gdGhpcy5pbnB1dC4kY29weShQb3NlKTtcclxuICAgICAgICBjb25zdCBvdXRQb3NlID0gdGhpcy5vdXRwdXQuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgY29uc3QgeCA9IChpblBvc2UueCArIG91dFBvc2UueCkgLyAyO1xyXG4gICAgICAgIGNvbnN0IHkgPSAoaW5Qb3NlLnkgKyBvdXRQb3NlLnkpIC8gMjtcclxuICAgICAgICBjb25zdCBhID0gTWF0aC5hdGFuMihpblBvc2UueSAtIG91dFBvc2UueSwgaW5Qb3NlLnggLSBvdXRQb3NlLngpO1xyXG4gICAgICAgIHRoaXMuJGFkZChQb3NlKSh7IHgsIHksIGEgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVwZGF0ZVNoYXBlKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGluUG9zZSA9IHRoaXMuaW5wdXQuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgY29uc3Qgb3V0UG9zZSA9IHRoaXMub3V0cHV0LiRjb3B5KFBvc2UpO1xyXG4gICAgICAgIGNvbnN0IGxlbmd0aCA9IGdldEV1Y2xpZGVhbkRpc3RhbmNlQmV0d2VlblBvaW50cyhpblBvc2UsIG91dFBvc2UpO1xyXG4gICAgICAgIHRoaXMuJGFkZChTaGFwZSkoeyBwb2ludHM6IFtcclxuICAgICAgICAgICAgeyB4OiBsZW5ndGggLyAyLCB5OiAyIH0sXHJcbiAgICAgICAgICAgIHsgeDogLSBsZW5ndGggLyAyLCB5OiAyIH0sXHJcbiAgICAgICAgICAgIHsgeDogLSBsZW5ndGggLyAyLCB5OiAtMiB9LFxyXG4gICAgICAgICAgICB7IHg6IGxlbmd0aCAvIDIsIHk6IC0yIH0sXHJcbiAgICAgICAgXX0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQud2lyZXMuZGVsZXRlKHRoaXMuaWQpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0LndpcmVzLmRlbGV0ZSh0aGlzLmlkKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBJbWFnZVJlbmRlcmluZ1Byb2ZpbGUsIFBvc2UsIFNoYXBlLCBTaGFwZVJlbmRlcmluZ1Byb2ZpbGUgfSBmcm9tICcuLi8uLi9lbmdpbmUvY29tcG9uZW50cyc7XHJcbmltcG9ydCB7IEludGVyYWN0aXZlRWxlbWVudCB9IGZyb20gJy4uLy4uL2VuZ2luZS9lbnRpdGllcyc7XHJcbmltcG9ydCB7IEFuZEdhdGUsIEdhdGUsIE5hbmRHYXRlLCBPckdhdGUsIFhvckdhdGUgfSBmcm9tICcuL2dhdGVzJztcclxuaW1wb3J0IHsgSW5wdXRUZXJtaW5hbCwgT3V0cHV0VGVybWluYWwgfSBmcm9tICcuL3Rlcm1pbmFscyc7XHJcbmltcG9ydCB7IEdhdGVDcmVhdG9ySGFuZGxlLCBHYXRlRGVzdHJ1Y3RvckhhbmRsZSwgVG9vbEhhbmRsZSwgV2lyZURlc3RydWN0b3JIYW5kbGUgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgQ3RvciB9IGZyb20gJy4uLy4uL2ZyYW1ld29yay90eXBlcyc7XHJcbmltcG9ydCB7IEJ1dHRvbiwgUGFuZWwgfSBmcm9tICcuL3VpJztcclxuXHJcbmV4cG9ydCBjbGFzcyBUb29sQnV0dG9uIGV4dGVuZHMgQnV0dG9uIHtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5LCBzcmMgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgc3JjOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKEltYWdlUmVuZGVyaW5nUHJvZmlsZSkoeyBzcmMgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRjbGljaygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoVG9vbEhhbmRsZSkoKGhhbmRsZSkgPT4ge1xyXG4gICAgICAgICAgICBoYW5kbGUuJGRlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRkaXNhYmxlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHYXRlQ3JlYXRvckJ1dHRvbiBleHRlbmRzIFRvb2xCdXR0b24ge1xyXG5cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxyXG4gICAgcHJpdmF0ZSBfX0dhdGVDdG9yOiBDdG9yPEdhdGUsIHt9PjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyBHYXRlQ3RvciB9OiB7IEdhdGVDdG9yOiBDdG9yPEdhdGUsIHt9PiB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLl9fR2F0ZUN0b3IgPSBHYXRlQ3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGNsaWNrKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRjbGljaygpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoR2F0ZUNyZWF0b3JIYW5kbGUsIHtcclxuICAgICAgICAgICAgR2F0ZUN0b3I6IHRoaXMuX19HYXRlQ3RvcixcclxuICAgICAgICAgICAgeDogdGhpcy4kZW5naW5lLm1vdXNlLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMuJGVuZ2luZS5tb3VzZS55LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW5kR2F0ZUNyZWF0b3JCdXR0b24gZXh0ZW5kcyBHYXRlQ3JlYXRvckJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBHYXRlQ3RvcjogQW5kR2F0ZSwgc3JjOiAnLi9BbmRHYXRlLnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBOYW5kR2F0ZUNyZWF0b3JCdXR0b24gZXh0ZW5kcyBHYXRlQ3JlYXRvckJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBHYXRlQ3RvcjogTmFuZEdhdGUsIHNyYzogJy4vTmFuZEdhdGUucG5nJyB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9yR2F0ZUNyZWF0b3JCdXR0b24gZXh0ZW5kcyBHYXRlQ3JlYXRvckJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBHYXRlQ3RvcjogT3JHYXRlLCBzcmM6ICcuL09yR2F0ZS5wbmcnIH0sIGFyZ3VtZW50c1swXSkpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgWG9yR2F0ZUNyZWF0b3JCdXR0b24gZXh0ZW5kcyBHYXRlQ3JlYXRvckJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBHYXRlQ3RvcjogWG9yR2F0ZSwgc3JjOiAnLi9Yb3JHYXRlLnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBHYXRlRGVzdHJ1Y3RvckJ1dHRvbiBleHRlbmRzIFRvb2xCdXR0b24ge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9UUkFTSENBTi5wbmcnIH0sIGFyZ3VtZW50c1swXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkY2xpY2soKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuJGNsaWNrKCk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShHYXRlRGVzdHJ1Y3RvckhhbmRsZSwge1xyXG4gICAgICAgICAgICB4OiB0aGlzLiRlbmdpbmUubW91c2UueCxcclxuICAgICAgICAgICAgeTogdGhpcy4kZW5naW5lLm1vdXNlLnksXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBXaXJlRGVzdHJ1Y3RvckJ1dHRvbiBleHRlbmRzIFRvb2xCdXR0b24ge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9DVVRURVJfQ0xPU0VELnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRjbGljaygpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci4kY2xpY2soKTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKFdpcmVEZXN0cnVjdG9ySGFuZGxlLCB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuJGVuZ2luZS5tb3VzZS54LFxyXG4gICAgICAgICAgICB5OiB0aGlzLiRlbmdpbmUubW91c2UueSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhdGVNYXNrIGV4dGVuZHMgSW50ZXJhY3RpdmVFbGVtZW50IHtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7IHgsIHkgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9KSB7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IHdpZHRoOiA0MCwgaGVpZ2h0OiA0MCB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgICAgICB0aGlzLiRhZGQoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IGNvbG91cjogJ0xJR0hUQkxVRScgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBCdWlsZEFyZWEgZXh0ZW5kcyBQYW5lbCB7XHJcblxyXG4gICAgcHVibGljIGlucHV0czogSW5wdXRUZXJtaW5hbFtdID0gW107XHJcbiAgICBwdWJsaWMgb3V0cHV0czogT3V0cHV0VGVybWluYWxbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBpbml0KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19pbml0SW5wdXRzKCk7XHJcbiAgICAgICAgdGhpcy5fX2luaXRPdXRwdXRzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2luaXRJbnB1dHMoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgcG9zZSA9IHRoaXMuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgY29uc3QgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLiRjb3B5KFNoYXBlKS5wb2ludHMubWFwKChwKSA9PiAoeyB3aWR0aDogMiAqIHAueCwgaGVpZ2h0OiAyICogcC55IH0pKVswXTtcclxuICAgICAgICBjb25zdCBob3Jpem9udGFsU3BhY2VyID0gd2lkdGggLyAodGhpcy5pbnB1dHMubGVuZ3RoICsgMSk7XHJcbiAgICAgICAgY29uc3QgdmVydGljYWxTcGFjZXIgPSAyMDtcclxuICAgICAgICBsZXQgY3Vyc29yID0gMTtcclxuICAgICAgICBmb3IgKGNvbnN0IGlucHV0IG9mIHRoaXMuaW5wdXRzKSB7XHJcbiAgICAgICAgICAgIGlucHV0LiRtdXRhdGUoUG9zZSkoe1xyXG4gICAgICAgICAgICAgICAgeDogcG9zZS54IC0gd2lkdGggLyAyICsgY3Vyc29yICogaG9yaXpvbnRhbFNwYWNlcixcclxuICAgICAgICAgICAgICAgIHk6IHBvc2UueSAtIGhlaWdodCAvIDIgKyB2ZXJ0aWNhbFNwYWNlcixcclxuICAgICAgICAgICAgICAgIGE6IDAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBjdXJzb3IrKztcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2luaXRPdXRwdXRzKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IHBvc2UgPSB0aGlzLiRjb3B5KFBvc2UpO1xyXG4gICAgICAgIGNvbnN0IHsgd2lkdGgsIGhlaWdodCB9ID0gdGhpcy4kY29weShTaGFwZSkucG9pbnRzLm1hcCgocCkgPT4gKHsgd2lkdGg6IDIgKiBwLngsIGhlaWdodDogMiAqIHAueSB9KSlbMF07XHJcbiAgICAgICAgY29uc3QgaG9yaXpvbnRhbFNwYWNlciA9IHdpZHRoIC8gKHRoaXMub3V0cHV0cy5sZW5ndGggKyAxKTtcclxuICAgICAgICBjb25zdCB2ZXJ0aWNhbFNwYWNlciA9IDIwO1xyXG4gICAgICAgIGxldCBjdXJzb3IgPSAxO1xyXG4gICAgICAgIGZvciAoY29uc3Qgb3V0cHV0IG9mIHRoaXMub3V0cHV0cykge1xyXG4gICAgICAgICAgICBvdXRwdXQuJG11dGF0ZShQb3NlKSh7XHJcbiAgICAgICAgICAgICAgICB4OiBwb3NlLnggLSB3aWR0aCAvIDIgKyBjdXJzb3IgKiBob3Jpem9udGFsU3BhY2VyLFxyXG4gICAgICAgICAgICAgICAgeTogcG9zZS55ICsgaGVpZ2h0IC8gMiAtIHZlcnRpY2FsU3BhY2VyLFxyXG4gICAgICAgICAgICAgICAgYTogMCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIGN1cnNvcisrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBTVEFURSB9IGZyb20gJy4uL2VudW1zL1NUQVRFJztcclxuaW1wb3J0IHsgSVBvc2UsIEltYWdlUmVuZGVyaW5nUHJvZmlsZSwgUG9zZSB9IGZyb20gJy4uLy4uL2VuZ2luZS9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgSW50ZXJhY3RpdmVFbGVtZW50IH0gZnJvbSAnLi4vLi4vZW5naW5lL2VudGl0aWVzJztcclxuaW1wb3J0IHsgSW5wdXRUZXJtaW5hbCwgT3V0cHV0VGVybWluYWwgfSBmcm9tICcuL3Rlcm1pbmFscyc7XHJcbmltcG9ydCB7IEdhdGVQbGFjZXJIYW5kbGUsIFRvb2xIYW5kbGUgfSBmcm9tICcuL3Rvb2xzJztcclxuXHJcbmV4cG9ydCBjbGFzcyBHYXRlIGV4dGVuZHMgSW50ZXJhY3RpdmVFbGVtZW50IHtcclxuXHJcbiAgICBwdWJsaWMgaW5wdXQ6IElucHV0VGVybWluYWw7XHJcbiAgICBwdWJsaWMgb3V0cHV0OiBPdXRwdXRUZXJtaW5hbDtcclxuXHJcbiAgICBwcml2YXRlIF9fc3RhdGU6IFNUQVRFID0gU1RBVEUuT0ZGO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHsgeCwgeSwgc3JjIH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHNyYzogc3RyaW5nIH0pIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgd2lkdGg6IDMwLCBoZWlnaHQ6IDMwIH0sIGFyZ3VtZW50c1swXSkpO1xyXG4gICAgICAgIHRoaXMuJGFkZChJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHsgc3JjIH0pO1xyXG4gICAgICAgIHRoaXMuaW5wdXQgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKElucHV0VGVybWluYWwsIHsgZ2F0ZTogdGhpcywgeCwgeTogeSArIDMwIH0pO1xyXG4gICAgICAgIHRoaXMub3V0cHV0ID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShPdXRwdXRUZXJtaW5hbCwgeyB4LCB5OiB5IC0gMzAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7IHJldHVybjsgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNIaWdoKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9fc3RhdGUgPT09IFNUQVRFLkhJR0g7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0xvdygpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlID09PSBTVEFURS5MT1c7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc09mZigpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlID09PSBTVEFURS5PRkY7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGhpZ2goKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gU1RBVEUuSElHSDtcclxuICAgICAgICB0aGlzLmlucHV0LmhpZ2goKTtcclxuICAgICAgICB0aGlzLm91dHB1dC5oaWdoKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvdygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fc3RhdGUgPSBTVEFURS5MT1c7XHJcbiAgICAgICAgdGhpcy5pbnB1dC5sb3coKTtcclxuICAgICAgICB0aGlzLm91dHB1dC5sb3coKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb2ZmKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IFNUQVRFLk9GRjtcclxuICAgICAgICB0aGlzLmlucHV0Lm9mZigpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0Lm9mZigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2Vkb3duKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGhhbmRsZSA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5maW5kKFRvb2xIYW5kbGUpKCgpID0+IHRydWUpO1xyXG4gICAgICAgIGlmIChoYW5kbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKEdhdGVQbGFjZXJIYW5kbGUsIHtcclxuICAgICAgICAgICAgeDogdGhpcy4kZW5naW5lLm1vdXNlLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMuJGVuZ2luZS5tb3VzZS55LFxyXG4gICAgICAgICAgICBnYXRlOiB0aGlzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtb3ZlKHBvc2U6IElQb3NlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kbXV0YXRlKFBvc2UpKHBvc2UpO1xyXG4gICAgICAgIHRoaXMuaW5wdXQubW92ZSh7XHJcbiAgICAgICAgICAgIHg6IHBvc2UueCxcclxuICAgICAgICAgICAgeTogcG9zZS55ICsgMzAsXHJcbiAgICAgICAgICAgIGE6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQubW92ZSh7XHJcbiAgICAgICAgICAgIHg6IHBvc2UueCxcclxuICAgICAgICAgICAgeTogcG9zZS55IC0gMzAsXHJcbiAgICAgICAgICAgIGE6IDAsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuaW5wdXQuJGRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLm91dHB1dC4kZGVzdHJveSgpO1xyXG4gICAgICAgIHJldHVybiBzdXBlci4kZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgQW5kR2F0ZSBleHRlbmRzIEdhdGUge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9BbmRHYXRlLnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LndpcmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd2lyZXMgPSB0aGlzLmlucHV0LndpcmVzLnRvQXJyYXkoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHdpcmUgb2Ygd2lyZXMpIHtcclxuICAgICAgICAgICAgaWYgKHdpcmUub3V0cHV0LmlzTG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb3coKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAod2lyZXMuZmluZCgod2lyZSkgPT4gd2lyZS5vdXRwdXQuaXNIaWdoKSkge1xyXG4gICAgICAgICAgICB0aGlzLmhpZ2goKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9mZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE5hbmRHYXRlIGV4dGVuZHMgR2F0ZSB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBzcmM6ICcuL05hbmRHYXRlLnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgaWYgKCF0aGlzLmlucHV0LndpcmVzLmxlbmd0aCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3Qgd2lyZXMgPSB0aGlzLmlucHV0LndpcmVzLnRvQXJyYXkoKTtcclxuICAgICAgICBmb3IgKGNvbnN0IHdpcmUgb2Ygd2lyZXMpIHtcclxuICAgICAgICAgICAgaWYgKHdpcmUub3V0cHV0LmlzTG93KSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5oaWdoKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHdpcmVzLmZpbmQoKHdpcmUpID0+IHdpcmUub3V0cHV0LmlzSGlnaCkpIHtcclxuICAgICAgICAgICAgdGhpcy5sb3coKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLm9mZigpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIE9yR2F0ZSBleHRlbmRzIEdhdGUge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9PckdhdGUucG5nJyB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcclxuICAgICAgICAvLyBpZiAoIXRoaXMuaW5wdXQud2lyZXMubGVuZ3RoKSB7XHJcbiAgICAgICAgLy8gICAgIHRoaXMub2ZmKCk7XHJcbiAgICAgICAgLy8gICAgIHJldHVybjtcclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gZm9yIChjb25zdCB3aXJlIG9mIHRoaXMuaW5wdXQud2lyZXMpIHtcclxuICAgICAgICAvLyAgICAgaWYgKHdpcmUub3V0cHV0LmlzTG93KSB7XHJcbiAgICAgICAgLy8gICAgICAgICB0aGlzLmhpZ2goKTtcclxuICAgICAgICAvLyAgICAgICAgIHJldHVybjtcclxuICAgICAgICAvLyAgICAgfVxyXG4gICAgICAgIC8vIH1cclxuICAgICAgICAvLyB0aGlzLmxvdygpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgWG9yR2F0ZSBleHRlbmRzIEdhdGUge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9Yb3JHYXRlLnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgLy8gaWYgKCF0aGlzLmlucHV0LndpcmVzLmxlbmd0aCkge1xyXG4gICAgICAgIC8vICAgICB0aGlzLm9mZigpO1xyXG4gICAgICAgIC8vICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gfVxyXG4gICAgICAgIC8vIGZvciAoY29uc3Qgd2lyZSBvZiB0aGlzLmlucHV0LndpcmVzKSB7XHJcbiAgICAgICAgLy8gICAgIGlmICh3aXJlLm91dHB1dC5pc0xvdykge1xyXG4gICAgICAgIC8vICAgICAgICAgdGhpcy5oaWdoKCk7XHJcbiAgICAgICAgLy8gICAgICAgICByZXR1cm47XHJcbiAgICAgICAgLy8gICAgIH1cclxuICAgICAgICAvLyB9XHJcbiAgICAgICAgLy8gdGhpcy5sb3coKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgRW50aXR5IGZyb20gJy4uLy4uL2VuZ2luZS9FbnRpdHknO1xyXG5pbXBvcnQge1xyXG4gICAgQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUsIElTaGFwZSwgTGFiZWwsIFBvc2UsIFBvc2VTdGVwcGVyQ29tcG9uZW50LCBTaGFwZSwgU2hhcGVSZW5kZXJpbmdQcm9maWxlLFxyXG59IGZyb20gJy4uLy4uL2VuZ2luZS9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgUml2ZXRDb21wb25lbnQgfSBmcm9tICcuLi9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgZW50aXRpZXNUb3VjaCB9IGZyb20gJy4uLy4uL2VuZ2luZS9lbnRpdGllcyc7XHJcbmltcG9ydCB7IElucHV0VGVybWluYWwsIE91dHB1dFRlcm1pbmFsIH0gZnJvbSAnLi90ZXJtaW5hbHMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFBvd2VyU3VwcGx5IGV4dGVuZHMgT3V0cHV0VGVybWluYWwge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHRoaXMuJGFkZChMYWJlbCkoe1xyXG4gICAgICAgICAgICB0ZXh0OiAncG93ZXInLFxyXG4gICAgICAgICAgICBmb250U2l6ZTogMjAsXHJcbiAgICAgICAgICAgIG9mZnNldDogeyB4OiAxNSwgeTogNyB9LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGFkZChTaGFwZVJlbmRlcmluZ1Byb2ZpbGUpKHsgY29sb3VyOiAnV0hJVEUnIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWFjaGluZSBleHRlbmRzIEVudGl0eSB7XHJcblxyXG4gICAgcHVibGljIGlucHV0czogSW5wdXRUZXJtaW5hbFtdID0gW107XHJcbiAgICBwdWJsaWMgb3V0cHV0czogT3V0cHV0VGVybWluYWxbXSA9IFtdO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcih7IHgsIHkgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLiRhZGQoUG9zZSkoeyB4LCB5LCBhOiAwIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQgeyByZXR1cm47IH1cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7IHJldHVybjsgfVxyXG5cclxuICAgIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBpbnB1dC4kZGVzdHJveSgpKTtcclxuICAgICAgICB0aGlzLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0KSA9PiBvdXRwdXQuJGRlc3Ryb3koKSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBNYWNoaW5lUGFydCBleHRlbmRzIEVudGl0eSB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSwgc2hhcGUgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgc2hhcGU6IElTaGFwZSB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLiRhZGQoUG9zZSkoeyB4LCB5LCBhOiAwIH0pO1xyXG4gICAgICAgIGlmIChzaGFwZSkge1xyXG4gICAgICAgICAgICB0aGlzLiRhZGQoU2hhcGUpKHNoYXBlKTtcclxuICAgICAgICAgICAgdGhpcy4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdXSElURScsIGZpbGxTdHlsZTogJ0JMQUNLJyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy4kYWRkKFBvc2VTdGVwcGVyQ29tcG9uZW50KSh7IHg6IDAsIHk6IDAsIGE6IDAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBIb3Jpem9udGFsVGhyZWFkZWRBeGxlIGV4dGVuZHMgTWFjaGluZVBhcnQge1xyXG5cclxuICAgIHByaXZhdGUgX190aHJlYWRzOiBNYWNoaW5lUGFydFtdID0gW107XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICBmb3IgKGxldCBpID0gMCwgTCA9IHdpZHRoIC8gMTA7IGkgPCBMOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGhyZWFkID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShNYWNoaW5lUGFydCwge1xyXG4gICAgICAgICAgICAgICAgeDogeCAtIHdpZHRoIC8gMiArIGkgKiAxMCArIDUsXHJcbiAgICAgICAgICAgICAgICB5LFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhyZWFkLiRhZGQoQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHtcclxuICAgICAgICAgICAgICAgIHNyYzogW1xyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMS5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMi5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMy5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNC5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNS5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNi5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNy5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtOC5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtOS5wbmcnLFxyXG4gICAgICAgICAgICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMTAucG5nJyxcclxuICAgICAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICAgICBmcmFtZTogMCxcclxuICAgICAgICAgICAgICAgIHNwZWVkOiAxLFxyXG4gICAgICAgICAgICAgICAgY29vbGRvd246IDAsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMTAsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX190aHJlYWRzLnB1c2godGhyZWFkKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxlZnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHRocmVhZC4kcGF0Y2goQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHtcclxuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzUmV2ZXJzZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmlnaHQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHRocmVhZC4kcGF0Y2goQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHtcclxuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzUmV2ZXJzZWQ6IHRydWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHRocmVhZC4kcGF0Y2goQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHtcclxuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiB0cnVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgc3RlcChwb3NlU3RlcDoge30pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkocG9zZVN0ZXApO1xyXG4gICAgICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xyXG4gICAgICAgICAgICB0aHJlYWQuJHBhdGNoKFBvc2VTdGVwcGVyQ29tcG9uZW50KShwb3NlU3RlcCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRkZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRkZXN0cm95KCk7XHJcbiAgICAgICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHRocmVhZC4kZGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVmVydGljYWxUaHJlYWRlZEF4bGUgZXh0ZW5kcyBNYWNoaW5lUGFydCB7XHJcblxyXG4gICAgcHJpdmF0ZSBfX3RocmVhZHM6IE1hY2hpbmVQYXJ0W10gPSBbXTtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBMID0gaGVpZ2h0IC8gMTA7IGkgPCBMOyBpKyspIHtcclxuICAgICAgICAgICAgY29uc3QgdGhyZWFkID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShNYWNoaW5lUGFydCwge1xyXG4gICAgICAgICAgICAgICAgeCxcclxuICAgICAgICAgICAgICAgIHk6IHkgLSBoZWlnaHQgLyAyICsgaSAqIDEwICsgNSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRocmVhZC4kYWRkKEFuaW1hdGVkSW1hZ2VSZW5kZXJpbmdQcm9maWxlKSh7XHJcbiAgICAgICAgICAgICAgICBzcmM6IFtcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTEucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTIucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTMucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTQucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTUucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTYucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTcucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTgucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTkucG5nJyxcclxuICAgICAgICAgICAgICAgICAgICAnLi90aHJlYWRlZC1heGxlLTEwLnBuZycsXHJcbiAgICAgICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICAgICAgZnJhbWU6IDAsXHJcbiAgICAgICAgICAgICAgICBzcGVlZDogMSxcclxuICAgICAgICAgICAgICAgIGNvb2xkb3duOiAwLFxyXG4gICAgICAgICAgICAgICAgd2lkdGg6IDEwLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiB3aWR0aCxcclxuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgcm90YXRlOiAtTWF0aC5QSSAvIDIsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLl9fdGhyZWFkcy5wdXNoKHRocmVhZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyB1cCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fdGhyZWFkcy5mb3JFYWNoKCh0aHJlYWQpID0+IHtcclxuICAgICAgICAgICAgdGhyZWFkLiRwYXRjaChBbmltYXRlZEltYWdlUmVuZGVyaW5nUHJvZmlsZSkoe1xyXG4gICAgICAgICAgICAgICAgaXNQYXVzZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNSZXZlcnNlZDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRvd24oKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XHJcbiAgICAgICAgICAgIHRocmVhZC4kcGF0Y2goQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKHtcclxuICAgICAgICAgICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcclxuICAgICAgICAgICAgICAgIGlzUmV2ZXJzZWQ6IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb2ZmKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xyXG4gICAgICAgICAgICB0aHJlYWQuJHBhdGNoKEFuaW1hdGVkSW1hZ2VSZW5kZXJpbmdQcm9maWxlKSh7XHJcbiAgICAgICAgICAgICAgICBpc1BhdXNlZDogdHJ1ZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0ZXAocG9zZVN0ZXA6IHt9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fdGhyZWFkcy5mb3JFYWNoKCh0aHJlYWQpID0+IHtcclxuICAgICAgICAgICAgdGhyZWFkLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkocG9zZVN0ZXApO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xyXG4gICAgICAgICAgICB0aHJlYWQuJGRlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFjdHVhdG9yIGV4dGVuZHMgSW5wdXRUZXJtaW5hbCB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgbGFiZWwgfTogeyBsYWJlbDogc3RyaW5nIH0pIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgeDogMCwgeTogMCB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgICAgICB0aGlzLiRhZGQoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IGNvbG91cjogJ1dISVRFJyB9KTtcclxuICAgICAgICB0aGlzLiRhZGQoTGFiZWwpKHtcclxuICAgICAgICAgICAgdGV4dDogbGFiZWwsXHJcbiAgICAgICAgICAgIGZvbnRTaXplOiAyMCxcclxuICAgICAgICAgICAgb2Zmc2V0OiB7IHg6IDE1LCB5OiA3IH0sXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTZW5zb3IgZXh0ZW5kcyBNYWNoaW5lUGFydCB7XHJcblxyXG4gICAgcHVibGljIG91dHB1dDogT3V0cHV0VGVybWluYWw7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSwgc2hhcGUsIGxhYmVsIH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHNoYXBlOiBJU2hhcGUsIGxhYmVsOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKE91dHB1dFRlcm1pbmFsLCB7IHg6IDAsIHk6IDAgfSk7XHJcbiAgICAgICAgdGhpcy5vdXRwdXQuJGFkZChMYWJlbCkoe1xyXG4gICAgICAgICAgICB0ZXh0OiBsYWJlbCxcclxuICAgICAgICAgICAgZm9udFNpemU6IDIwLFxyXG4gICAgICAgICAgICBvZmZzZXQ6IHsgeDogMTUsIHk6IDcgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLm91dHB1dC4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdXSElURScgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGdldCBpc0hpZ2goKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0cHV0LmlzSGlnaDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzTG93KCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5pc0xvdztcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzT2ZmKCk6IGJvb2xlYW4ge1xyXG4gICAgICAgIHJldHVybiB0aGlzLm91dHB1dC5pc09mZjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZmluZChUb3VjaEFjdGl2YXRvcikoKGFjdGl2YXRvcikgPT4ge1xyXG4gICAgICAgICAgICByZXR1cm4gZW50aXRpZXNUb3VjaCh0aGlzLCBhY3RpdmF0b3IpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgdGhpcy5vdXRwdXQuaGlnaCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMub3V0cHV0LmxvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLm91dHB1dC4kZGVzdHJveSgpO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgVG91Y2hTZW5zb3IgZXh0ZW5kcyBTZW5zb3Ige1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFRvdWNoQWN0aXZhdG9yIGV4dGVuZHMgTWFjaGluZVBhcnQge1xyXG5cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENsYXcgZXh0ZW5kcyBNYWNoaW5lIHtcclxuXHJcbiAgICBwdWJsaWMgaW5wdXRzOiBJbnB1dFRlcm1pbmFsW10gPSBbXTtcclxuICAgIHB1YmxpYyBvdXRwdXRzOiBPdXRwdXRUZXJtaW5hbFtdID0gW107XHJcblxyXG4gICAgcHJpdmF0ZSBfX3dyaXN0OiBNYWNoaW5lUGFydDtcclxuICAgIHByaXZhdGUgX19wYWxtOiBUb3VjaEFjdGl2YXRvcjtcclxuICAgIHByaXZhdGUgX19sZWZ0SHViOiBUb3VjaEFjdGl2YXRvcjtcclxuICAgIHByaXZhdGUgX19sZWZ0VGhyZWFkOiBIb3Jpem9udGFsVGhyZWFkZWRBeGxlO1xyXG4gICAgcHJpdmF0ZSBfX3JpZ2h0VGhyZWFkOiBIb3Jpem9udGFsVGhyZWFkZWRBeGxlO1xyXG4gICAgcHJpdmF0ZSBfX2xlZnRUb290aDogVG91Y2hTZW5zb3I7XHJcbiAgICBwcml2YXRlIF9fcmlnaHRUb290aDogVG91Y2hTZW5zb3I7XHJcbiAgICBwcml2YXRlIF9fb3Blbk1vdG9yOiBBY3R1YXRvcjtcclxuICAgIHByaXZhdGUgX19jbG9zZU1vdG9yOiBBY3R1YXRvcjtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy5fX3dyaXN0ID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShNYWNoaW5lUGFydCwge1xyXG4gICAgICAgICAgICB4LCB5OiB5IC0gMTUsIHNoYXBlOiB7IHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgeyB4OiAxMCwgeTogNSB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMTAsIHk6IDUgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTIwLCB5OiAtNSB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAyMCwgeTogLTUgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3BhbG0gPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKFRvdWNoQWN0aXZhdG9yLCB7XHJcbiAgICAgICAgICAgIHgsIHk6IHkgKyAxMCwgc2hhcGU6IHsgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IDEwLCB5OiAxMCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMTAsIHk6IDEwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDEwLCB5OiAtMjAgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2xlZnRIdWIgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKFRvdWNoQWN0aXZhdG9yLCB7XHJcbiAgICAgICAgICAgIHg6IHggLSA1MiwgeTogeSArIDEwLCBzaGFwZTogeyBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgIHsgeDogMiwgeTogMTAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTIsIHk6IDEwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0yLCB5OiAtMTAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogMiwgeTogLTEwIH0sXHJcbiAgICAgICAgICAgIF19LFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19sZWZ0VGhyZWFkID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShIb3Jpem9udGFsVGhyZWFkZWRBeGxlLCB7XHJcbiAgICAgICAgICAgIHg6IHggLSAzMCwgeTogeSArIDEwLCB3aWR0aDogNDAsIGhlaWdodDogMjAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3JpZ2h0VGhyZWFkID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShIb3Jpem9udGFsVGhyZWFkZWRBeGxlLCB7XHJcbiAgICAgICAgICAgIHg6IHggKyAzMCwgeTogeSArIDEwLCB3aWR0aDogNDAsIGhlaWdodDogMjAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2xlZnRUb290aCA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcclxuICAgICAgICAgICAgeDogeCAtIDQwLCB5OiB5ICsgMTAsIHNoYXBlOiB7IHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgeyB4OiAxMCwgeTogNjAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTAsIHk6IDYwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0wLCB5OiAyMCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMTAsIHk6IDIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDEwLCB5OiAtMjAgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgICAgIGxhYmVsOiAnbGVmdC10b290aCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2xlZnRUb290aC4kcGF0Y2goU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IHpJbmRleDogMSB9KTtcclxuICAgICAgICB0aGlzLl9fcmlnaHRUb290aCA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcclxuICAgICAgICAgICAgeDogeCArIDQwLCB5OiB5ICsgMTAsIHNoYXBlOiB7IHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiAyMCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAwLCB5OiA2MCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMTAsIHk6IDYwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDEwLCB5OiAtMjAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogMTAsIHk6IDIwIH0sXHJcbiAgICAgICAgICAgIF19LFxyXG4gICAgICAgICAgICBsYWJlbDogJ3JpZ2h0LXRvb3RoJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9fcmlnaHRUb290aC4kcGF0Y2goU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IHpJbmRleDogMSB9KTtcclxuICAgICAgICB0aGlzLl9fb3Blbk1vdG9yID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShBY3R1YXRvciwge1xyXG4gICAgICAgICAgICBsYWJlbDogJ29wZW4nLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19jbG9zZU1vdG9yID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShBY3R1YXRvciwge1xyXG4gICAgICAgICAgICBsYWJlbDogJ2Nsb3NlJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmlucHV0cyA9IFt0aGlzLl9fb3Blbk1vdG9yLCB0aGlzLl9fY2xvc2VNb3Rvcl07XHJcbiAgICAgICAgdGhpcy5vdXRwdXRzID0gW3RoaXMuX19sZWZ0VG9vdGgub3V0cHV0LCB0aGlzLl9fcmlnaHRUb290aC5vdXRwdXRdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9fbGVmdFRvb3RoLmlzSGlnaCAmJiB0aGlzLl9fcmlnaHRUb290aC5pc0hpZ2ggJiYgdGhpcy5fX2Nsb3NlTW90b3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fX29wZW5Nb3Rvci5pc0hpZ2ggJiYgdGhpcy5fX2Nsb3NlTW90b3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm9mZigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fX29wZW5Nb3Rvci5pc0hpZ2ggJiYgdGhpcy5fX2xlZnRUb290aC5pc0hpZ2ggJiYgIXRoaXMuX19yaWdodFRvb3RoLmlzSGlnaCkge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5vZmYoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX19jbG9zZU1vdG9yLmlzSGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fbGVmdFRocmVhZC5yaWdodCgpO1xyXG4gICAgICAgICAgICB0aGlzLl9fcmlnaHRUaHJlYWQubGVmdCgpO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0VG9vdGhQb3NlID0gdGhpcy5fX2xlZnRUb290aC4kY29weShQb3NlKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHRUb290aFBvc2UgPSB0aGlzLl9fcmlnaHRUb290aC4kY29weShQb3NlKTtcclxuICAgICAgICAgICAgdGhpcy5fX2xlZnRUb290aC4kcGF0Y2goUG9zZSkoe1xyXG4gICAgICAgICAgICAgICAgeDogbGVmdFRvb3RoUG9zZS54ICsgMSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX19yaWdodFRvb3RoLiRwYXRjaChQb3NlKSh7XHJcbiAgICAgICAgICAgICAgICB4OiByaWdodFRvb3RoUG9zZS54IC0gMSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9fb3Blbk1vdG9yLmlzSGlnaCkge1xyXG4gICAgICAgICAgICB0aGlzLl9fbGVmdFRocmVhZC5sZWZ0KCk7XHJcbiAgICAgICAgICAgIHRoaXMuX19yaWdodFRocmVhZC5yaWdodCgpO1xyXG4gICAgICAgICAgICBjb25zdCBsZWZ0VG9vdGhQb3NlID0gdGhpcy5fX2xlZnRUb290aC4kY29weShQb3NlKTtcclxuICAgICAgICAgICAgY29uc3QgcmlnaHRUb290aFBvc2UgPSB0aGlzLl9fcmlnaHRUb290aC4kY29weShQb3NlKTtcclxuICAgICAgICAgICAgdGhpcy5fX2xlZnRUb290aC4kcGF0Y2goUG9zZSkoe1xyXG4gICAgICAgICAgICAgICAgeDogbGVmdFRvb3RoUG9zZS54IC0gMSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuX19yaWdodFRvb3RoLiRwYXRjaChQb3NlKSh7XHJcbiAgICAgICAgICAgICAgICB4OiByaWdodFRvb3RoUG9zZS54ICsgMSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2xlZnRUaHJlYWQub2ZmKCk7XHJcbiAgICAgICAgdGhpcy5fX3JpZ2h0VGhyZWFkLm9mZigpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBzdGVwKHBvc2VTdGVwOiB7fSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX193cmlzdC4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fcGFsbS4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fbGVmdEh1Yi4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fbGVmdFRocmVhZC5zdGVwKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fcmlnaHRUaHJlYWQuc3RlcChwb3NlU3RlcCk7XHJcbiAgICAgICAgdGhpcy5fX2xlZnRUb290aC4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgICAgICB0aGlzLl9fcmlnaHRUb290aC4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHBvc2VTdGVwKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIENsYXdNYWNoaW5lIGV4dGVuZHMgTWFjaGluZSB7XHJcblxyXG4gICAgcHJpdmF0ZSBfX2hvcml6b250YWxSYWlsOiBIb3Jpem9udGFsVGhyZWFkZWRBeGxlO1xyXG4gICAgcHJpdmF0ZSBfX3ZlcnRpY2FsUmFpbDogVmVydGljYWxUaHJlYWRlZEF4bGU7XHJcbiAgICBwcml2YXRlIF9fY2FycmlhZ2U6IFRvdWNoQWN0aXZhdG9yO1xyXG5cclxuICAgIHByaXZhdGUgX19sZWZ0TW90b3I6IEFjdHVhdG9yO1xyXG4gICAgcHJpdmF0ZSBfX3JpZ2h0TW90b3I6IEFjdHVhdG9yO1xyXG4gICAgcHJpdmF0ZSBfX3RvcE1vdG9yOiBBY3R1YXRvcjtcclxuICAgIHByaXZhdGUgX19ib3R0b21Nb3RvcjogQWN0dWF0b3I7XHJcblxyXG4gICAgcHJpdmF0ZSBfX2xlZnRTZW5zb3I6IFRvdWNoU2Vuc29yO1xyXG4gICAgcHJpdmF0ZSBfX3JpZ2h0U2Vuc29yOiBUb3VjaFNlbnNvcjtcclxuICAgIHByaXZhdGUgX190b3BTZW5zb3I6IFRvdWNoU2Vuc29yO1xyXG4gICAgcHJpdmF0ZSBfX2JvdHRvbVNlbnNvcjogVG91Y2hTZW5zb3I7XHJcblxyXG4gICAgcHJpdmF0ZSBfX2NsYXc6IENsYXc7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyIH0pIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHRoaXMuX19ob3Jpem9udGFsUmFpbCA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoSG9yaXpvbnRhbFRocmVhZGVkQXhsZSwgeyB4LCB5LCB3aWR0aDogMzAwLCBoZWlnaHQ6IDIwIH0pO1xyXG4gICAgICAgIHRoaXMuX19jYXJyaWFnZSA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVG91Y2hBY3RpdmF0b3IsIHtcclxuICAgICAgICAgICAgeDogeCAtIDEzMCwgeSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiAzMCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMjAsIHk6IDMwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0yMCwgeTogLTMwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiAtMzAgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2NhcnJpYWdlLiRhZGQoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IGNvbG91cjogJ1dISVRFJywgZmlsbFN0eWxlOiAnQkxBQ0snLCB6SW5kZXg6IDEgfSk7XHJcbiAgICAgICAgdGhpcy5fX3ZlcnRpY2FsUmFpbCA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVmVydGljYWxUaHJlYWRlZEF4bGUsIHtcclxuICAgICAgICAgICAgeDogeCAtIDEzMCwgeSwgd2lkdGg6IDIwLCBoZWlnaHQ6IDIwMCxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9fbGVmdFNlbnNvciA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcclxuICAgICAgICAgICAgeDogeCAtIDE3MCwgeSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiAyMCB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMjAsIHk6IDIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0yMCwgeTogLTIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiAtMjAgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgICAgIGxhYmVsOiAnbGVmdC1zZW5zb3InLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19sZWZ0U2Vuc29yLiRhZGQoUml2ZXRDb21wb25lbnQpKHtcclxuICAgICAgICAgICAgY29sb3VyOiAnV0hJVEUnLCByYWRpdXM6IDMsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3JpZ2h0U2Vuc29yID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShUb3VjaFNlbnNvciwge1xyXG4gICAgICAgICAgICB4OiB4ICsgMTcwLCB5LFxyXG4gICAgICAgICAgICBzaGFwZTogeyBwb2ludHM6IFtcclxuICAgICAgICAgICAgICAgIHsgeDogMjAsIHk6IDIwIH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0yMCwgeTogMjAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTIwLCB5OiAtMjAgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogMjAsIHk6IC0yMCB9LFxyXG4gICAgICAgICAgICBdfSxcclxuICAgICAgICAgICAgbGFiZWw6ICdyaWdodC1zZW5zb3InLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19yaWdodFNlbnNvci4kYWRkKFJpdmV0Q29tcG9uZW50KSh7XHJcbiAgICAgICAgICAgIGNvbG91cjogJ1dISVRFJywgcmFkaXVzOiAzLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX190b3BTZW5zb3IgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKFRvdWNoU2Vuc29yLCB7XHJcbiAgICAgICAgICAgIHg6IHggLSAxMzAsIHk6IHkgLSAxMDUsXHJcbiAgICAgICAgICAgIHNoYXBlOiB7IHBvaW50czogW1xyXG4gICAgICAgICAgICAgICAgeyB4OiAyMCwgeTogNSB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMjAsIHk6IDUgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTIwLCB5OiAtNSB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAyMCwgeTogLTUgfSxcclxuICAgICAgICAgICAgXX0sXHJcbiAgICAgICAgICAgIGxhYmVsOiAndG9wLXNlbnNvcicsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2JvdHRvbVNlbnNvciA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcclxuICAgICAgICAgICAgeDogeCAtIDEzMCwgeTogeSArIDEwNSxcclxuICAgICAgICAgICAgc2hhcGU6IHsgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiA1IH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IC0yMCwgeTogNSB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiAtMjAsIHk6IC01IH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDIwLCB5OiAtNSB9LFxyXG4gICAgICAgICAgICBdfSxcclxuICAgICAgICAgICAgbGFiZWw6ICdib3R0b20tc2Vuc29yJyxcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLl9fbGVmdE1vdG9yID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShBY3R1YXRvciwge1xyXG4gICAgICAgICAgICBsYWJlbDogJ21vdmUtbGVmdCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3JpZ2h0TW90b3IgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKEFjdHVhdG9yLCB7XHJcbiAgICAgICAgICAgIGxhYmVsOiAnbW92ZS1yaWdodCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3RvcE1vdG9yID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShBY3R1YXRvciwge1xyXG4gICAgICAgICAgICBsYWJlbDogJ21vdmUtdXAnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19ib3R0b21Nb3RvciA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoQWN0dWF0b3IsIHtcclxuICAgICAgICAgICAgbGFiZWw6ICdtb3ZlLWRvd24nLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX19jbGF3ID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShDbGF3LCB7XHJcbiAgICAgICAgICAgIHg6IHggLSAxMzAsIHk6IHkgKyAxMzAsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy5pbnB1dHMgPSBbXHJcbiAgICAgICAgICAgIHRoaXMuX19sZWZ0TW90b3IsXHJcbiAgICAgICAgICAgIHRoaXMuX19yaWdodE1vdG9yLFxyXG4gICAgICAgICAgICB0aGlzLl9fdG9wTW90b3IsXHJcbiAgICAgICAgICAgIHRoaXMuX19ib3R0b21Nb3RvcixcclxuICAgICAgICBdLmNvbmNhdCh0aGlzLl9fY2xhdy5pbnB1dHMpO1xyXG4gICAgICAgIHRoaXMub3V0cHV0cyA9IFtcclxuICAgICAgICAgICAgdGhpcy5fX2xlZnRTZW5zb3Iub3V0cHV0LFxyXG4gICAgICAgICAgICB0aGlzLl9fcmlnaHRTZW5zb3Iub3V0cHV0LFxyXG4gICAgICAgICAgICB0aGlzLl9fdG9wU2Vuc29yLm91dHB1dCxcclxuICAgICAgICAgICAgdGhpcy5fX2JvdHRvbVNlbnNvci5vdXRwdXQsXHJcbiAgICAgICAgXS5jb25jYXQodGhpcy5fX2NsYXcub3V0cHV0cyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3VwZGF0ZUhvcml6b250YWxTdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX191cGRhdGVWZXJ0aWNhbFN0YXRlKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9mZigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fb2ZmWCgpO1xyXG4gICAgICAgIHRoaXMuX19vZmZZKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX3VwZGF0ZUhvcml6b250YWxTdGF0ZSgpOiB2b2lkIHtcclxuICAgICAgICBpZiAodGhpcy5fX2xlZnRNb3Rvci5pc0hpZ2ggJiYgdGhpcy5fX3JpZ2h0TW90b3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fX2xlZnRNb3Rvci5pc0xvdyAmJiB0aGlzLl9fcmlnaHRNb3Rvci5pc0xvdykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX29mZlgoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX19sZWZ0TW90b3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9fbGVmdFNlbnNvci5pc0hpZ2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWCgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fbGVmdCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fX3JpZ2h0TW90b3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9fcmlnaHRTZW5zb3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX29mZlgoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX3JpZ2h0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX191cGRhdGVWZXJ0aWNhbFN0YXRlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9fdG9wTW90b3IuaXNIaWdoICYmIHRoaXMuX19ib3R0b21Nb3Rvci5pc0hpZ2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19vZmZZKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9fdG9wTW90b3IuaXNMb3cgJiYgdGhpcy5fX2JvdHRvbU1vdG9yLmlzTG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fX3RvcE1vdG9yLmlzSGlnaCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fX2JvdHRvbVNlbnNvci5pc0hpZ2gpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fdXAoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX19ib3R0b21Nb3Rvci5pc0hpZ2gpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX190b3BTZW5zb3IuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fX29mZlkoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2Rvd24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19vZmZZKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2xlZnQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2NhcnJpYWdlLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB4OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fdmVydGljYWxSYWlsLnN0ZXAoeyB4OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fdG9wU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB4OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fYm90dG9tU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB4OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9faG9yaXpvbnRhbFJhaWwubGVmdCgpO1xyXG4gICAgICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB4OiAtMSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9fcmlnaHQoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2NhcnJpYWdlLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB4OiAxIH0pO1xyXG4gICAgICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuc3RlcCh7IHg6IDEgfSk7XHJcbiAgICAgICAgdGhpcy5fX3RvcFNlbnNvci4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHsgeDogMSB9KTtcclxuICAgICAgICB0aGlzLl9fYm90dG9tU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB4OiAxIH0pO1xyXG4gICAgICAgIHRoaXMuX19ob3Jpem9udGFsUmFpbC5yaWdodCgpO1xyXG4gICAgICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB4OiAxIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX191cCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fdmVydGljYWxSYWlsLnN0ZXAoeyB5OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fdG9wU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB5OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fYm90dG9tU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB5OiAtMSB9KTtcclxuICAgICAgICB0aGlzLl9fdmVydGljYWxSYWlsLnVwKCk7XHJcbiAgICAgICAgdGhpcy5fX2NsYXcuc3RlcCh7IHk6IC0xIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX19kb3duKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuc3RlcCh7IHk6IDEgfSk7XHJcbiAgICAgICAgdGhpcy5fX3RvcFNlbnNvci4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHsgeTogMSB9KTtcclxuICAgICAgICB0aGlzLl9fYm90dG9tU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB5OiAxIH0pO1xyXG4gICAgICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuZG93bigpO1xyXG4gICAgICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB5OiAxIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX19vZmZYKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19jYXJyaWFnZS4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHsgeDogMCB9KTtcclxuICAgICAgICB0aGlzLl9fdmVydGljYWxSYWlsLnN0ZXAoeyB4OiAwIH0pO1xyXG4gICAgICAgIHRoaXMuX190b3BTZW5zb3IuJHBhdGNoKFBvc2VTdGVwcGVyQ29tcG9uZW50KSh7IHg6IDAgfSk7XHJcbiAgICAgICAgdGhpcy5fX2JvdHRvbVNlbnNvci4kcGF0Y2goUG9zZVN0ZXBwZXJDb21wb25lbnQpKHsgeDogMCB9KTtcclxuICAgICAgICB0aGlzLl9faG9yaXpvbnRhbFJhaWwub2ZmKCk7XHJcbiAgICAgICAgdGhpcy5fX2NsYXcuc3RlcCh7IHg6IDAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX29mZlkoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3ZlcnRpY2FsUmFpbC5zdGVwKHsgeTogMCB9KTtcclxuICAgICAgICB0aGlzLl9fdG9wU2Vuc29yLiRwYXRjaChQb3NlU3RlcHBlckNvbXBvbmVudCkoeyB5OiAwIH0pO1xyXG4gICAgICAgIHRoaXMuX19ib3R0b21TZW5zb3IuJHBhdGNoKFBvc2VTdGVwcGVyQ29tcG9uZW50KSh7IHk6IDAgfSk7XHJcbiAgICAgICAgdGhpcy5fX3ZlcnRpY2FsUmFpbC5vZmYoKTtcclxuICAgICAgICB0aGlzLl9fY2xhdy5zdGVwKHsgeTogMCB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBUb29sQnV0dG9uIH0gZnJvbSAnLi9lZGl0b3InO1xyXG5pbXBvcnQgeyBHYXRlIH0gZnJvbSAnLi9nYXRlcyc7XHJcbmltcG9ydCB7IE1hY2hpbmUsIFBvd2VyU3VwcGx5IH0gZnJvbSAnLi9tYWNoaW5lcyc7XHJcbmltcG9ydCB7IEFjdHVhdG9yU3lzdGVtLCBHYXRlU3lzdGVtLCBNYWNoaW5lU3lzdGVtLCBTZW5zb3JTeXN0ZW0gfSBmcm9tICcuLi9zeXN0ZW1zJztcclxuaW1wb3J0IHsgVGVybWluYWwgfSBmcm9tICcuL3Rlcm1pbmFscyc7XHJcbmltcG9ydCB7IFRvb2xIYW5kbGUgfSBmcm9tICcuL3Rvb2xzJztcclxuaW1wb3J0IHsgQnV0dG9uLCBQYW5lbCB9IGZyb20gJy4vdWknO1xyXG5cclxuZXhwb3J0IGNsYXNzIFNjZW5lQXJlYSBleHRlbmRzIFBhbmVsIHtcclxuXHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBTY2VuZUJ1dHRvbiBleHRlbmRzIEJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljICRjbGljaygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoU2NlbmVCdXR0b24pKChidXR0b24pID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uLiRlbmFibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRkaXNhYmxlKCk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBQbGF5QnV0dG9uIGV4dGVuZHMgU2NlbmVCdXR0b24ge1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcclxuICAgICAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgbGFiZWw6ICdwbGF5JyB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGNsaWNrKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRjbGljaygpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShUb29sSGFuZGxlKSgoaGFuZGxlKSA9PiB7XHJcbiAgICAgICAgICAgIGhhbmRsZS4kZGVzdHJveSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShUb29sQnV0dG9uKSgoYnV0dG9uKSA9PiB7XHJcbiAgICAgICAgICAgIGJ1dHRvbi4kZGlzYWJsZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShHYXRlKSgoZ2F0ZSkgPT4ge1xyXG4gICAgICAgICAgICBnYXRlLiRkaXNhYmxlKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KFRlcm1pbmFsKSgodGVybWluYWwpID0+IHtcclxuICAgICAgICAgICAgdGVybWluYWwuJGRpc2FibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoUG93ZXJTdXBwbHkpKChwb3dlcikgPT4ge1xyXG4gICAgICAgICAgICBwb3dlci5oaWdoKCk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmFkZChBY3R1YXRvclN5c3RlbSk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmFkZChTZW5zb3JTeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5hZGQoR2F0ZVN5c3RlbSk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmFkZChNYWNoaW5lU3lzdGVtKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFN0b3BCdXR0b24gZXh0ZW5kcyBTY2VuZUJ1dHRvbiB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBsYWJlbDogJ3N0b3AnIH0sIGFyZ3VtZW50c1swXSkpO1xyXG4gICAgICAgIHRoaXMuJGRpc2FibGUoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGNsaWNrKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRjbGljaygpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5yZW1vdmUoQWN0dWF0b3JTeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5yZW1vdmUoU2Vuc29yU3lzdGVtKTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUucmVtb3ZlKEdhdGVTeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5yZW1vdmUoTWFjaGluZVN5c3RlbSk7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KFRvb2xCdXR0b24pKChidXR0b24pID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uLiRlbmFibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoVGVybWluYWwpKCh0ZXJtaW5hbCkgPT4ge1xyXG4gICAgICAgICAgICB0ZXJtaW5hbC4kZW5hYmxlKCk7XHJcbiAgICAgICAgICAgIHRlcm1pbmFsLm9mZigpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShHYXRlKSgoZ2F0ZSkgPT4ge1xyXG4gICAgICAgICAgICBnYXRlLiRlbmFibGUoKTtcclxuICAgICAgICAgICAgZ2F0ZS5vZmYoKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoTWFjaGluZSkoKG1hY2hpbmUpID0+IHtcclxuICAgICAgICAgICAgbWFjaGluZS5vZmYoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgRGljdGlvbmFyeSBmcm9tICcuLi8uLi9mcmFtZXdvcmsvY29uY3JldGVzL0RpY3Rpb25hcnknO1xyXG5pbXBvcnQgeyBTVEFURSB9IGZyb20gJy4uL2VudW1zL1NUQVRFJztcclxuaW1wb3J0IFdpcmUgZnJvbSAnLi9XaXJlJztcclxuaW1wb3J0IHsgSVBvc2UsIEltYWdlUmVuZGVyaW5nUHJvZmlsZSwgTGFiZWwsIFBvc2UsIFNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9IGZyb20gJy4uLy4uL2VuZ2luZS9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgSW50ZXJhY3RpdmVFbGVtZW50IH0gZnJvbSAnLi4vLi4vZW5naW5lL2VudGl0aWVzJztcclxuaW1wb3J0IHsgR2F0ZSB9IGZyb20gJy4vZ2F0ZXMnO1xyXG5pbXBvcnQgeyBJbnB1dFRlcm1pbmFsSGFuZGxlLCBPdXRwdXRUZXJtaW5hbEhhbmRsZSB9IGZyb20gJy4vdG9vbHMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIFRlcm1pbmFsIGV4dGVuZHMgSW50ZXJhY3RpdmVFbGVtZW50IHtcclxuXHJcbiAgICBwdWJsaWMgd2lyZXM6IERpY3Rpb25hcnk8V2lyZT4gPSBuZXcgRGljdGlvbmFyeSgpO1xyXG5cclxuICAgIHByaXZhdGUgX19zdGF0ZTogU1RBVEUgPSBTVEFURS5PRkY7XHJcbiAgICBwcml2YXRlIF9fc3JjOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeyB4LCB5LCBzcmMgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgc3JjOiBzdHJpbmcgfSkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyB3aWR0aDogMjAsIGhlaWdodDogMjAgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICAgICAgdGhpcy5fX3NyYyA9IHNyYztcclxuICAgICAgICB0aGlzLiRhZGQoSW1hZ2VSZW5kZXJpbmdQcm9maWxlKSh7IHNyYyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZ2V0IGlzSGlnaCgpOiBib29sZWFuIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3N0YXRlID09PSBTVEFURS5ISUdIO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNMb3coKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZSA9PT0gU1RBVEUuTE9XO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgaXNPZmYoKTogYm9vbGVhbiB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19zdGF0ZSA9PT0gU1RBVEUuT0ZGO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBoaWdoKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19zdGF0ZSA9IFNUQVRFLkhJR0g7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLiRjb3B5KExhYmVsKTtcclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy4kbXV0YXRlKExhYmVsKShPYmplY3QuYXNzaWduKGxhYmVsLCB7XHJcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdHUkVFTicsXHJcbiAgICAgICAgICAgIH0pKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvdygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fc3RhdGUgPSBTVEFURS5MT1c7XHJcbiAgICAgICAgY29uc3QgbGFiZWwgPSB0aGlzLiRjb3B5KExhYmVsKTtcclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy4kbXV0YXRlKExhYmVsKShPYmplY3QuYXNzaWduKGxhYmVsLCB7XHJcbiAgICAgICAgICAgICAgICBjb2xvdXI6ICdSRUQnLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3N0YXRlID0gU1RBVEUuT0ZGO1xyXG4gICAgICAgIGNvbnN0IGxhYmVsID0gdGhpcy4kY29weShMYWJlbCk7XHJcbiAgICAgICAgaWYgKGxhYmVsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuJG11dGF0ZShMYWJlbCkoT2JqZWN0LmFzc2lnbihsYWJlbCwge1xyXG4gICAgICAgICAgICAgICAgY29sb3VyOiAnV0hJVEUnLFxyXG4gICAgICAgICAgICB9KSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBtb3ZlKHBvc2U6IElQb3NlKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kbXV0YXRlKFBvc2UpKHBvc2UpO1xyXG4gICAgICAgIHRoaXMud2lyZXMuZm9yRWFjaCgod2lyZSkgPT4ge1xyXG4gICAgICAgICAgICB3aXJlLnVwZGF0ZVBvc2UoKTtcclxuICAgICAgICAgICAgd2lyZS51cGRhdGVTaGFwZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2VlbnRlcigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRtdXRhdGUoSW1hZ2VSZW5kZXJpbmdQcm9maWxlKSh7IHNyYzogJy4vVGVybWluYWxfaG92ZXJlZC5wbmcnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2VsZWF2ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRtdXRhdGUoSW1hZ2VSZW5kZXJpbmdQcm9maWxlKSh7IHNyYzogdGhpcy5fX3NyYyB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy53aXJlcy5mb3JFYWNoKCh3aXJlKSA9PiB7XHJcbiAgICAgICAgICAgIHdpcmUuJGRlc3Ryb3koKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICByZXR1cm4gc3VwZXIuJGRlc3Ryb3koKTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIElucHV0VGVybWluYWwgZXh0ZW5kcyBUZXJtaW5hbCB7XHJcblxyXG4gICAgcHVibGljICRnYXRlOiBHYXRlO1xyXG5cclxuICAgIHB1YmxpYyBjb25zdHJ1Y3Rvcih7IGdhdGUsIHgsIHkgfTogeyBnYXRlOiBHYXRlLCB4OiBudW1iZXIsIHk6IG51bWJlciB9KSB7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IHNyYzogJy4vVGVybWluYWxfaW4ucG5nJyB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgICAgICB0aGlzLiRnYXRlID0gZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJG1vdXNlZG93bigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuY3JlYXRlKE91dHB1dFRlcm1pbmFsSGFuZGxlLCB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuJGVuZ2luZS5tb3VzZS54LFxyXG4gICAgICAgICAgICB5OiB0aGlzLiRlbmdpbmUubW91c2UueSxcclxuICAgICAgICAgICAgaW5wdXQ6IHRoaXMsXHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBPdXRwdXRUZXJtaW5hbCBleHRlbmRzIFRlcm1pbmFsIHtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyBzcmM6ICcuL1Rlcm1pbmFsX291dC5wbmcnIH0sIGFyZ3VtZW50c1swXSkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2Vkb3duKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoSW5wdXRUZXJtaW5hbEhhbmRsZSwge1xyXG4gICAgICAgICAgICB4OiB0aGlzLiRlbmdpbmUubW91c2UueCxcclxuICAgICAgICAgICAgeTogdGhpcy4kZW5naW5lLm1vdXNlLnksXHJcbiAgICAgICAgICAgIG91dHB1dDogdGhpcyxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGlnaCgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5oaWdoKCk7XHJcbiAgICAgICAgdGhpcy53aXJlcy5mb3JFYWNoKCh3aXJlKSA9PiB3aXJlLmhpZ2goKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGxvdygpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci5sb3coKTtcclxuICAgICAgICB0aGlzLndpcmVzLmZvckVhY2goKHdpcmUpID0+IHdpcmUubG93KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvZmYoKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIub2ZmKCk7XHJcbiAgICAgICAgdGhpcy53aXJlcy5mb3JFYWNoKCh3aXJlKSA9PiB3aXJlLm9mZigpKTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgV2lyZSBmcm9tICcuL1dpcmUnO1xyXG5pbXBvcnQgeyBJUG9pbnQsIFBvc2UsIFNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9IGZyb20gJy4uLy4uL2VuZ2luZS9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgQnVpbGRBcmVhLCBHYXRlQ3JlYXRvckJ1dHRvbiwgR2F0ZURlc3RydWN0b3JCdXR0b24sIFdpcmVEZXN0cnVjdG9yQnV0dG9uIH0gZnJvbSAnLi9lZGl0b3InO1xyXG5pbXBvcnQgeyBJbnRlcmFjdGl2ZUVsZW1lbnQsIGVudGl0eUNvbnRhaW5zUG9pbnQsIGVudGl0eVRvdWNoZXNMaW5lIH0gZnJvbSAnLi4vLi4vZW5naW5lL2VudGl0aWVzJztcclxuaW1wb3J0IHsgR2F0ZSB9IGZyb20gJy4vZ2F0ZXMnO1xyXG5pbXBvcnQgeyBJbnB1dFRlcm1pbmFsLCBPdXRwdXRUZXJtaW5hbCB9IGZyb20gJy4vdGVybWluYWxzJztcclxuaW1wb3J0IHsgQ3RvciB9IGZyb20gJy4uLy4uL2ZyYW1ld29yay90eXBlcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgVG9vbEhhbmRsZSBleHRlbmRzIEludGVyYWN0aXZlRWxlbWVudCB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeyB4LCB5IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oeyB3aWR0aDogMTAsIGhlaWdodDogMTAgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRtb3VzZW1vdmUoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kbXV0YXRlKFBvc2UpKHtcclxuICAgICAgICAgICAgeDogdGhpcy4kZW5naW5lLm1vdXNlLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMuJGVuZ2luZS5tb3VzZS55LFxyXG4gICAgICAgICAgICBhOiAwLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkY2xpY2soKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KEJ1aWxkQXJlYSkoKGFyZWEpID0+IHtcclxuICAgICAgICAgICAgaWYgKGVudGl0eUNvbnRhaW5zUG9pbnQoYXJlYSwgdGhpcy4kZW5naW5lLm1vdXNlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5hY3Rpb24oKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGRlc3Ryb3koKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aW9uKCk6IHZvaWQgeyByZXR1cm47IH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhdGVDcmVhdG9ySGFuZGxlIGV4dGVuZHMgVG9vbEhhbmRsZSB7XHJcblxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbiAgICBwcml2YXRlIF9fR2F0ZUN0b3I6IEN0b3I8R2F0ZSwge30+O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHsgR2F0ZUN0b3IsIHgsIHkgfTogeyBHYXRlQ3RvcjogQ3RvcjxHYXRlLCB7fT4sIHg6IG51bWJlciwgeTogbnVtYmVyIH0pIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHRoaXMuJGFkZChTaGFwZVJlbmRlcmluZ1Byb2ZpbGUpKHsgY29sb3VyOiAnWUVMTE9XJyB9KTtcclxuICAgICAgICB0aGlzLl9fR2F0ZUN0b3IgPSBHYXRlQ3RvcjtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWN0aW9uKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUodGhpcy5fX0dhdGVDdG9yLCB7XHJcbiAgICAgICAgICAgIHg6IHRoaXMuJGVuZ2luZS5tb3VzZS54LFxyXG4gICAgICAgICAgICB5OiB0aGlzLiRlbmdpbmUubW91c2UueSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoR2F0ZUNyZWF0b3JCdXR0b24pKChidXR0b24pID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uLiRlbmFibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhdGVEZXN0cnVjdG9ySGFuZGxlIGV4dGVuZHMgVG9vbEhhbmRsZSB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeyB4LCB5IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdPUkFOR0UnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmZpbmQoR2F0ZSkoKGdhdGUpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIGVudGl0eUNvbnRhaW5zUG9pbnQoZ2F0ZSwgdGhpcy4kZW5naW5lLm1vdXNlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHRhcmdldC4kZGVzdHJveSgpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XHJcbiAgICAgICAgc3VwZXIuJGRlc3Ryb3koKTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoR2F0ZURlc3RydWN0b3JCdXR0b24pKChidXR0b24pID0+IHtcclxuICAgICAgICAgICAgYnV0dG9uLiRlbmFibGUoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFdpcmVEZXN0cnVjdG9ySGFuZGxlIGV4dGVuZHMgVG9vbEhhbmRsZSB7XHJcblxyXG4gICAgcHVibGljIHBvaW50czogSVBvaW50W10gPSBbXTtcclxuXHJcbiAgICBwcml2YXRlIF9faXNDdXR0aW5nQWN0aXZlOiBib29sZWFuID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeyB4LCB5IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdSRUQnIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2Vkb3duKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19pc0N1dHRpbmdBY3RpdmUgPSB0cnVlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2Vtb3ZlKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRtb3VzZW1vdmUoKTtcclxuICAgICAgICBpZiAoIXRoaXMuX19pc0N1dHRpbmdBY3RpdmUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLnBvaW50cy5wdXNoKHtcclxuICAgICAgICAgICAgeDogdGhpcy4kZW5naW5lLm1vdXNlLngsXHJcbiAgICAgICAgICAgIHk6IHRoaXMuJGVuZ2luZS5tb3VzZS55LFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICBzdXBlci4kZGVzdHJveSgpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShXaXJlRGVzdHJ1Y3RvckJ1dHRvbikoKGJ1dHRvbikgPT4ge1xyXG4gICAgICAgICAgICBidXR0b24uJGVuYWJsZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShXaXJlKSgod2lyZSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoZW50aXR5VG91Y2hlc0xpbmUod2lyZSwgdGhpcy5wb2ludHMpKSB7XHJcbiAgICAgICAgICAgICAgICB3aXJlLiRkZXN0cm95KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEdhdGVQbGFjZXJIYW5kbGUgZXh0ZW5kcyBUb29sSGFuZGxlIHtcclxuXHJcbiAgICBwdWJsaWMgZ2F0ZTogR2F0ZTtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7IHgsIHksIGdhdGUgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgZ2F0ZTogR2F0ZSB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLiRhZGQoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IGNvbG91cjogJ0xJR0hUQkxVRScgfSk7XHJcbiAgICAgICAgdGhpcy5nYXRlID0gZ2F0ZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJG1vdXNlbW92ZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoQnVpbGRBcmVhKSgoYXJlYSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoIWVudGl0eUNvbnRhaW5zUG9pbnQoYXJlYSwgdGhpcy4kZW5naW5lLm1vdXNlKSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy4kZGVzdHJveSgpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHN1cGVyLiRtb3VzZW1vdmUoKTtcclxuICAgICAgICAgICAgdGhpcy5nYXRlLm1vdmUoe1xyXG4gICAgICAgICAgICAgICAgeDogdGhpcy4kZW5naW5lLm1vdXNlLngsXHJcbiAgICAgICAgICAgICAgICB5OiB0aGlzLiRlbmdpbmUubW91c2UueSxcclxuICAgICAgICAgICAgICAgIGE6IDAsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0VGVybWluYWxIYW5kbGUgZXh0ZW5kcyBUb29sSGFuZGxlIHtcclxuXHJcbiAgICBwdWJsaWMgaW5wdXQ6IElucHV0VGVybWluYWw7XHJcblxyXG4gICAgY29uc3RydWN0b3IoeyB4LCB5LCBpbnB1dCB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCBpbnB1dDogSW5wdXRUZXJtaW5hbCB9KSB7XHJcbiAgICAgICAgc3VwZXIoYXJndW1lbnRzWzBdKTtcclxuICAgICAgICB0aGlzLmlucHV0ID0gaW5wdXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGFjdGlvbigpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCB0YXJnZXQgPSB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZmluZChPdXRwdXRUZXJtaW5hbCkoKHRlcm1pbmFsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHlDb250YWluc1BvaW50KHRlcm1pbmFsLCB0aGlzLiRlbmdpbmUubW91c2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoV2lyZSwge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRoaXMuaW5wdXQsXHJcbiAgICAgICAgICAgICAgICBvdXRwdXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRoaXMuaW5wdXQud2lyZXMud3JpdGUoe1xyXG4gICAgICAgICAgICAgICAga2V5OiB3aXJlLmlkLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHdpcmUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0YXJnZXQud2lyZXMud3JpdGUoe1xyXG4gICAgICAgICAgICAgICAga2V5OiB3aXJlLmlkLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHdpcmUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIElucHV0VGVybWluYWxIYW5kbGUgZXh0ZW5kcyBUb29sSGFuZGxlIHtcclxuXHJcbiAgICBwdWJsaWMgb3V0cHV0OiBPdXRwdXRUZXJtaW5hbDtcclxuXHJcbiAgICBjb25zdHJ1Y3Rvcih7IHgsIHksIG91dHB1dCB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCBvdXRwdXQ6IE91dHB1dFRlcm1pbmFsIH0pIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHRoaXMub3V0cHV0ID0gb3V0cHV0O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhY3Rpb24oKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgdGFyZ2V0ID0gdGhpcy4kZW5naW5lLmVudGl0aWVzLmZpbmQoSW5wdXRUZXJtaW5hbCkoKHRlcm1pbmFsKSA9PiB7XHJcbiAgICAgICAgICAgIHJldHVybiBlbnRpdHlDb250YWluc1BvaW50KHRlcm1pbmFsLCB0aGlzLiRlbmdpbmUubW91c2UpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IHRoaXMuJGVuZ2luZS5lbnRpdGllcy5jcmVhdGUoV2lyZSwge1xyXG4gICAgICAgICAgICAgICAgaW5wdXQ6IHRhcmdldCxcclxuICAgICAgICAgICAgICAgIG91dHB1dDogdGhpcy5vdXRwdXQsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB0aGlzLm91dHB1dC53aXJlcy53cml0ZSh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IHdpcmUuaWQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogd2lyZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIHRhcmdldC53aXJlcy53cml0ZSh7XHJcbiAgICAgICAgICAgICAgICBrZXk6IHdpcmUuaWQsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogd2lyZSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbiIsImltcG9ydCBFbnRpdHkgZnJvbSAnLi4vLi4vZW5naW5lL0VudGl0eSc7XHJcbmltcG9ydCB7IExhYmVsLCBQb3NlLCBTaGFwZSwgU2hhcGVSZW5kZXJpbmdQcm9maWxlIH0gZnJvbSAnLi4vLi4vZW5naW5lL2NvbXBvbmVudHMnO1xyXG5pbXBvcnQgeyBJbnRlcmFjdGl2ZUVsZW1lbnQgfSBmcm9tICcuLi8uLi9lbmdpbmUvZW50aXRpZXMnO1xyXG5cclxuZXhwb3J0IGNsYXNzIEJ1dHRvbiBleHRlbmRzIEludGVyYWN0aXZlRWxlbWVudCB7XHJcblxyXG4gICAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSwgbGFiZWwgfTogeyB4OiBudW1iZXIsIHk6IG51bWJlciwgbGFiZWw6IHN0cmluZyB9KSB7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IHdpZHRoOiA0MCwgaGVpZ2h0OiA0MCB9LCBhcmd1bWVudHNbMF0pKTtcclxuICAgICAgICB0aGlzLiRhZGQoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IGNvbG91cjogJ1dISVRFJyB9KTtcclxuICAgICAgICBpZiAobGFiZWwpIHtcclxuICAgICAgICAgICAgdGhpcy4kYWRkKExhYmVsKSh7XHJcbiAgICAgICAgICAgICAgICBmb250U2l6ZTogMTAsXHJcbiAgICAgICAgICAgICAgICB0ZXh0OiBsYWJlbCxcclxuICAgICAgICAgICAgICAgIG9mZnNldDogeyB4OiAtMTAsIHk6IDQgfSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZW5hYmxlKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRlbmFibGUoKTtcclxuICAgICAgICBjb25zdCByZW5kZXJpbmcgPSB0aGlzLiRjb3B5KFNoYXBlUmVuZGVyaW5nUHJvZmlsZSk7XHJcbiAgICAgICAgdGhpcy4kcGF0Y2goU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IG9wYWNpdHk6IDEgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRkaXNhYmxlKCk6IHZvaWQge1xyXG4gICAgICAgIHN1cGVyLiRkaXNhYmxlKCk7XHJcbiAgICAgICAgdGhpcy4kcGF0Y2goU2hhcGVSZW5kZXJpbmdQcm9maWxlKSh7IG9wYWNpdHk6IDAuMiB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFBhbmVsIGV4dGVuZHMgRW50aXR5IHtcclxuXHJcbiAgICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH06IHsgeDogbnVtYmVyLCB5OiBudW1iZXIsIHdpZHRoOiBudW1iZXIsIGhlaWdodDogbnVtYmVyIH0pIHtcclxuICAgICAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xyXG4gICAgICAgIHRoaXMuJGFkZChQb3NlKSh7IHgsIHksIGE6IDAgfSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlKSh7IHBvaW50czogW1xyXG4gICAgICAgICAgICB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0IC8gMiB9LFxyXG4gICAgICAgICAgICB7IHg6IC13aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfSxcclxuICAgICAgICAgICAgeyB4OiAtd2lkdGggLyAyLCB5OiAtaGVpZ2h0IC8gMiB9LFxyXG4gICAgICAgICAgICB7IHg6IHdpZHRoIC8gMiwgeTogLWhlaWdodCAvIDIgfSxcclxuICAgICAgICBdfSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlUmVuZGVyaW5nUHJvZmlsZSkoeyBjb2xvdXI6ICdXSElURScgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiXHJcbmV4cG9ydCBlbnVtIFNUQVRFIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxyXG4gICAgSElHSCxcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuYW1pbmctY29udmVudGlvblxyXG4gICAgTE9XLFxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5hbWluZy1jb252ZW50aW9uXHJcbiAgICBPRkYsXHJcbn1cclxuIiwiaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XHJcbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vZW5naW5lL0VuZ2luZSc7XHJcbmltcG9ydCBIVE1MNUNhbnZhc0tleWJvYXJkQWRhcHRlciBmcm9tICcuLi9odG1sNS1jYW52YXMvSFRNTDVDYW52YXNLZXlib2FyZEFkYXB0b3InO1xyXG5pbXBvcnQgSFRNTDVDYW52YXNNb3VzZUFkYXB0b3IgZnJvbSAnLi4vaHRtbDUtY2FudmFzL0hUTUw1Q2FudmFzTW91c2VBZGFwdG9yJztcclxuaW1wb3J0IHsgSFRNTDVDYW52YXNWaWV3cG9ydEFkYXB0b3IgfSBmcm9tICcuLi9odG1sNS1jYW52YXMvSFRNTDVDYW52YXNWaWV3cG9ydEFkYXB0b3InO1xyXG5pbXBvcnQgSUFkYXB0ZWRLZXlib2FyZEV2ZW50IGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lBZGFwdGVkS2V5Ym9hcmRFdmVudCc7XHJcbmltcG9ydCBJQWRhcHRlZE1vdXNlRXZlbnQgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRNb3VzZUV2ZW50JztcclxuaW1wb3J0IHtcclxuICAgIEFuZEdhdGVDcmVhdG9yQnV0dG9uLCBCdWlsZEFyZWEsIEdhdGVEZXN0cnVjdG9yQnV0dG9uLCBOYW5kR2F0ZUNyZWF0b3JCdXR0b24sXHJcbiAgICBPckdhdGVDcmVhdG9yQnV0dG9uLCBXaXJlRGVzdHJ1Y3RvckJ1dHRvbiwgWG9yR2F0ZUNyZWF0b3JCdXR0b24sXHJcbn0gZnJvbSAnLi9lbnRpdGllcy9lZGl0b3InO1xyXG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xyXG5pbXBvcnQgeyBDbGF3TWFjaGluZSwgUG93ZXJTdXBwbHkgfSBmcm9tICcuL2VudGl0aWVzL21hY2hpbmVzJztcclxuaW1wb3J0IHsgUGxheUJ1dHRvbiwgU2NlbmVBcmVhLCBTdG9wQnV0dG9uIH0gZnJvbSAnLi9lbnRpdGllcy9zY2VuZXMnO1xyXG5pbXBvcnQge1xyXG4gICAgR2F0ZU1hc2tTeXN0ZW0sIElucHV0VGVybWluYWxIYW5kbGVTeXN0ZW0sIE91dHB1dFRlcm1pbmFsSGFuZGxlU3lzdGVtLFxyXG4gICAgUml2ZXRTeXN0ZW0sIFRlcm1pbmFsV2lyZVN5c3RlbSwgV2lyZURlc3RydWN0b3JIYW5kbGVTeXN0ZW0sXHJcbn0gZnJvbSAnLi9zeXN0ZW1zJztcclxuXHJcbmNvbnN0IGNhbnZhcyA9ICQoJyNhcHAtdGFyZ2V0JykuZ2V0KDApIGFzIEhUTUxDYW52YXNFbGVtZW50O1xyXG5jYW52YXMuZm9jdXMoKTtcclxuY2FudmFzLndpZHRoID0gMTI4MDtcclxuY2FudmFzLmhlaWdodCA9IDY4MDtcclxuXHJcbmNvbnN0IHZpZXdwb3J0ID0gbmV3IEhUTUw1Q2FudmFzVmlld3BvcnRBZGFwdG9yKGNhbnZhcyk7XHJcbmNvbnN0IG1vdXNlID0gbmV3IEhUTUw1Q2FudmFzTW91c2VBZGFwdG9yKGNhbnZhcyk7XHJcbmNvbnN0IGtleWJvYXJkID0gbmV3IEhUTUw1Q2FudmFzS2V5Ym9hcmRBZGFwdGVyKGNhbnZhcyk7XHJcbmNvbnN0IGdhbWUgPSBuZXcgRW5naW5lKHZpZXdwb3J0KTtcclxuXHJcbmNvbnN0IGFwcCA9IG5ldyBBcHAoe1xyXG4gICAgdmlld3BvcnQsXHJcbiAgICBtb3VzZSxcclxuICAgIGtleWJvYXJkLFxyXG4gICAgZ2FtZSxcclxufSk7XHJcblxyXG5jb25zdCBwcm9wYWdhdGVNb3VzZUlucHV0ID0gKG1vdXNlRXZlbnQ6IElBZGFwdGVkTW91c2VFdmVudCkgPT4gZ2FtZS5tb3VzZSA9IG1vdXNlRXZlbnQ7XHJcbm1vdXNlLmhhbmRsZXIoe1xyXG4gICAgbW91c2VlbnRlcjogcHJvcGFnYXRlTW91c2VJbnB1dCxcclxuICAgIG1vdXNlbW92ZTogcHJvcGFnYXRlTW91c2VJbnB1dCxcclxuICAgIG1vdXNlbGVhdmU6IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXHJcbiAgICBtb3VzZWRvd246IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXHJcbiAgICBtb3VzZXVwOiBwcm9wYWdhdGVNb3VzZUlucHV0LFxyXG4gICAgY2xpY2s6IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXHJcbiAgICBub25lOiBwcm9wYWdhdGVNb3VzZUlucHV0LFxyXG59KTtcclxuXHJcbmNvbnN0IHByb3BhZ2F0ZUtleWJvYXJkSW5wdXQgPSAoa2V5Ym9hcmRFdmVudDogSUFkYXB0ZWRLZXlib2FyZEV2ZW50KSA9PiBnYW1lLmtleWJvYXJkID0ga2V5Ym9hcmRFdmVudDtcclxua2V5Ym9hcmQuaGFuZGxlcih7XHJcbiAgICBrZXlkb3duOiBwcm9wYWdhdGVLZXlib2FyZElucHV0LFxyXG4gICAga2V5cHJlc3M6IHByb3BhZ2F0ZUtleWJvYXJkSW5wdXQsXHJcbiAgICBrZXl1cDogcHJvcGFnYXRlS2V5Ym9hcmRJbnB1dCxcclxufSk7XHJcblxyXG5nYW1lLmFkZChHYXRlTWFza1N5c3RlbSk7XHJcbmdhbWUuYWRkKFdpcmVEZXN0cnVjdG9ySGFuZGxlU3lzdGVtKTtcclxuZ2FtZS5hZGQoSW5wdXRUZXJtaW5hbEhhbmRsZVN5c3RlbSk7XHJcbmdhbWUuYWRkKE91dHB1dFRlcm1pbmFsSGFuZGxlU3lzdGVtKTtcclxuZ2FtZS5hZGQoVGVybWluYWxXaXJlU3lzdGVtKTtcclxuZ2FtZS5hZGQoUml2ZXRTeXN0ZW0pO1xyXG5hcHAuc3RhcnQoKTtcclxuXHJcbmFwcC5lbmdpbmUuZW50aXRpZXMuY3JlYXRlKEFuZEdhdGVDcmVhdG9yQnV0dG9uLCB7IHg6IDMwLCB5OiAzMCB9KTtcclxuYXBwLmVuZ2luZS5lbnRpdGllcy5jcmVhdGUoTmFuZEdhdGVDcmVhdG9yQnV0dG9uLCB7IHg6IDgwLCB5OiAzMCB9KTtcclxuYXBwLmVuZ2luZS5lbnRpdGllcy5jcmVhdGUoT3JHYXRlQ3JlYXRvckJ1dHRvbiwgeyB4OiAxMzAsIHk6IDMwIH0pO1xyXG5hcHAuZW5naW5lLmVudGl0aWVzLmNyZWF0ZShYb3JHYXRlQ3JlYXRvckJ1dHRvbiwgeyB4OiAxODAsIHk6IDMwIH0pO1xyXG5hcHAuZW5naW5lLmVudGl0aWVzLmNyZWF0ZShXaXJlRGVzdHJ1Y3RvckJ1dHRvbiwgeyB4OiA3MjAsIHk6IDMwIH0pO1xyXG5hcHAuZW5naW5lLmVudGl0aWVzLmNyZWF0ZShHYXRlRGVzdHJ1Y3RvckJ1dHRvbiwgeyB4OiA3NzAsIHk6IDMwIH0pO1xyXG5jb25zdCBlZGl0b3IgPSBhcHAuZW5naW5lLmVudGl0aWVzLmNyZWF0ZShCdWlsZEFyZWEsIHsgeDogNDAwLCB5OiAzNDAsIHdpZHRoOiA4MDAsIGhlaWdodDogNTYwIH0pO1xyXG5cclxuYXBwLmVuZ2luZS5lbnRpdGllcy5jcmVhdGUoUGxheUJ1dHRvbiwgeyB4OiAxMjAwLCB5OiAzMCB9KTtcclxuYXBwLmVuZ2luZS5lbnRpdGllcy5jcmVhdGUoU3RvcEJ1dHRvbiwgeyB4OiAxMjUwLCB5OiAzMCB9KTtcclxuYXBwLmVuZ2luZS5lbnRpdGllcy5jcmVhdGUoU2NlbmVBcmVhLCB7IHg6IDEwNDAsIHk6IDM0MCwgd2lkdGg6IDQ0MCwgaGVpZ2h0OiA1NjAgfSk7XHJcbmNvbnN0IGNsYXcgPSBhcHAuZW5naW5lLmVudGl0aWVzLmNyZWF0ZShDbGF3TWFjaGluZSwgeyB4OiAxMDQwLCB5OiAzNDAgfSk7XHJcblxyXG5jb25zdCBwb3dlciA9IGFwcC5lbmdpbmUuZW50aXRpZXMuY3JlYXRlKFBvd2VyU3VwcGx5LCB7IHg6IDAsIHk6IDAgfSk7XHJcblxyXG5lZGl0b3IuaW5wdXRzID0gY2xhdy5pbnB1dHM7XHJcbmVkaXRvci5vdXRwdXRzID0gW3Bvd2VyXS5jb25jYXQoY2xhdy5vdXRwdXRzKTtcclxuZWRpdG9yLmluaXQoKTtcclxuXHJcbltcclxuICAgICcuL3RocmVhZGVkLWF4bGUtMS5wbmcnLFxyXG4gICAgJy4vdGhyZWFkZWQtYXhsZS0yLnBuZycsXHJcbiAgICAnLi90aHJlYWRlZC1heGxlLTMucG5nJyxcclxuICAgICcuL3RocmVhZGVkLWF4bGUtNC5wbmcnLFxyXG4gICAgJy4vdGhyZWFkZWQtYXhsZS01LnBuZycsXHJcbiAgICAnLi90aHJlYWRlZC1heGxlLTYucG5nJyxcclxuICAgICcuL3RocmVhZGVkLWF4bGUtNy5wbmcnLFxyXG4gICAgJy4vdGhyZWFkZWQtYXhsZS04LnBuZycsXHJcbiAgICAnLi90aHJlYWRlZC1heGxlLTkucG5nJyxcclxuICAgICcuL3RocmVhZGVkLWF4bGUtMTAucG5nJyxcclxuXS5mb3JFYWNoKChzcmMpID0+IHtcclxuICAgIGFwcC5lbmdpbmUudmlld3BvcnQubG9hZChzcmMpO1xyXG59KTtcclxuIiwiaW1wb3J0IElFbnRpdHkgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUVudGl0eSc7XHJcbmltcG9ydCB7IFN5c3RlbSB9IGZyb20gJy4uL2VuZ2luZS9hYnN0cmFjdHMvU3lzdGVtJztcclxuaW1wb3J0IFdpcmUgZnJvbSAnLi9lbnRpdGllcy9XaXJlJztcclxuaW1wb3J0IHsgUG9zZSwgU2hhcGUgfSBmcm9tICcuLi9lbmdpbmUvY29tcG9uZW50cyc7XHJcbmltcG9ydCB7IFJpdmV0Q29tcG9uZW50IH0gZnJvbSAnLi9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgQnVpbGRBcmVhLCBHYXRlTWFzayB9IGZyb20gJy4vZW50aXRpZXMvZWRpdG9yJztcclxuaW1wb3J0IHsgZW50aXR5Q29udGFpbnNQb2ludCB9IGZyb20gJy4uL2VuZ2luZS9lbnRpdGllcyc7XHJcbmltcG9ydCB7IEdhdGUgfSBmcm9tICcuL2VudGl0aWVzL2dhdGVzJztcclxuaW1wb3J0IHsgZ2V0RXVjbGlkZWFuRGlzdGFuY2VCZXR3ZWVuUG9pbnRzLCB0cmFuc2Zvcm1TaGFwZSB9IGZyb20gJy4uL2VuZ2luZS9nZW9tZXRyeSc7XHJcbmltcG9ydCB7IE1hY2hpbmUsIFNlbnNvciB9IGZyb20gJy4vZW50aXRpZXMvbWFjaGluZXMnO1xyXG5pbXBvcnQgeyBHYXRlQ3JlYXRvckhhbmRsZSwgSW5wdXRUZXJtaW5hbEhhbmRsZSwgT3V0cHV0VGVybWluYWxIYW5kbGUsIFdpcmVEZXN0cnVjdG9ySGFuZGxlIH0gZnJvbSAnLi9lbnRpdGllcy90b29scyc7XHJcblxyXG5leHBvcnQgY2xhc3MgR2F0ZU1hc2tTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShCdWlsZEFyZWEpKChhcmVhKSA9PiB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLiRlbmdpbmUubW91c2UubmFtZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KEdhdGVNYXNrKSgobWFzaykgPT4ge1xyXG4gICAgICAgICAgICAgICAgbWFzay4kZGVzdHJveSgpO1xyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KEdhdGVDcmVhdG9ySGFuZGxlKSgoKSA9PiB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZW50aXR5Q29udGFpbnNQb2ludChhcmVhLCB0aGlzLiRlbmdpbmUubW91c2UpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmNyZWF0ZShHYXRlTWFzaywge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB4OiB0aGlzLiRlbmdpbmUubW91c2UueCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgeTogdGhpcy4kZW5naW5lLm1vdXNlLnksXHJcbiAgICAgICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFdpcmVEZXN0cnVjdG9ySGFuZGxlU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuXHJcbiAgICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoV2lyZURlc3RydWN0b3JIYW5kbGUpKChoYW5kbGUpID0+IHtcclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLnZpZXdwb3J0LmRyYXdMaW5lKHtcclxuICAgICAgICAgICAgICAgIHBvaW50czogaGFuZGxlLnBvaW50cyxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmluZzogeyBjb2xvdXI6ICdSRUQnIH0sXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgT3V0cHV0VGVybWluYWxIYW5kbGVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShPdXRwdXRUZXJtaW5hbEhhbmRsZSkoKGhhbmRsZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCB7IHNoYXBlLCByZW5kZXJpbmcgfSA9IGZyb21UZXJtaW5hbEhhbmRsZVRvV2lyZVJlbmRlcmluZyhoYW5kbGUsIGhhbmRsZS5pbnB1dCk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3U2hhcGUoeyBzaGFwZSwgcmVuZGVyaW5nIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgSW5wdXRUZXJtaW5hbEhhbmRsZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KElucHV0VGVybWluYWxIYW5kbGUpKChoYW5kbGUpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgeyBzaGFwZSwgcmVuZGVyaW5nIH0gPSBmcm9tVGVybWluYWxIYW5kbGVUb1dpcmVSZW5kZXJpbmcoaGFuZGxlLCBoYW5kbGUub3V0cHV0KTtcclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLnZpZXdwb3J0LmRyYXdTaGFwZSh7IHNoYXBlLCByZW5kZXJpbmcgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBUZXJtaW5hbFdpcmVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShHYXRlKSgoZ2F0ZSkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBnYXRlUG9zZSA9IGdhdGUuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IGluUG9zZSA9IGdhdGUuaW5wdXQuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgICAgIGNvbnN0IG91dFBvc2UgPSBnYXRlLm91dHB1dC4kY29weShQb3NlKTtcclxuICAgICAgICAgICAgY29uc3Qgd2lyZSA9IHsgcG9pbnRzOiBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IDUsIHk6IDUgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTUsIHk6IDUgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogLTUsIHk6IC01IH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IDUsIHk6IC01IH0sXHJcbiAgICAgICAgICAgIF19O1xyXG4gICAgICAgICAgICBjb25zdCByZW5kZXJpbmcgPSB7IGNvbG91cjogJ1dISVRFJywgb3BhY2l0eTogMSB9O1xyXG4gICAgICAgICAgICB0aGlzLiRlbmdpbmUudmlld3BvcnQuZHJhd1NoYXBlKHtcclxuICAgICAgICAgICAgICAgIHNoYXBlOiB0cmFuc2Zvcm1TaGFwZSh3aXJlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgeDogKGdhdGVQb3NlLnggKyBpblBvc2UueCkgLyAyLFxyXG4gICAgICAgICAgICAgICAgICAgIHk6IChnYXRlUG9zZS55ICsgaW5Qb3NlLnkpIC8gMiArIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLnZpZXdwb3J0LmRyYXdTaGFwZSh7XHJcbiAgICAgICAgICAgICAgICBzaGFwZTogdHJhbnNmb3JtU2hhcGUod2lyZSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHg6IChnYXRlUG9zZS54ICsgb3V0UG9zZS54KSAvIDIsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogKGdhdGVQb3NlLnkgKyBvdXRQb3NlLnkpIC8gMiAtIDUsXHJcbiAgICAgICAgICAgICAgICAgICAgYTogMCxcclxuICAgICAgICAgICAgICAgIH0pLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIEFjdHVhdG9yU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuZW50aXRpZXMuZm9yRXZlcnkoV2lyZSkoKHdpcmUpID0+IHtcclxuICAgICAgICAgICAgaWYgKHdpcmUuaW5wdXQuJGdhdGUpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAod2lyZS5vdXRwdXQuaXNIaWdoKSB7XHJcbiAgICAgICAgICAgICAgICB3aXJlLmlucHV0LmhpZ2goKTtcclxuICAgICAgICAgICAgfSBlbHNlIGlmICh3aXJlLm91dHB1dC5pc0xvdykge1xyXG4gICAgICAgICAgICAgICAgd2lyZS5pbnB1dC5sb3coKTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHdpcmUuaW5wdXQub2ZmKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG5cclxuZXhwb3J0IGNsYXNzIFNlbnNvclN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KFNlbnNvcikoKHNlbnNvcikgPT4ge1xyXG4gICAgICAgICAgICBzZW5zb3Iub25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgR2F0ZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KEdhdGUpKChnYXRlKSA9PiB7XHJcbiAgICAgICAgICAgIGdhdGUub25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgTWFjaGluZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmVudGl0aWVzLmZvckV2ZXJ5KE1hY2hpbmUpKChtYWNoaW5lKSA9PiB7XHJcbiAgICAgICAgICAgIG1hY2hpbmUub25jZSgpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG59XHJcblxyXG5jb25zdCBmcm9tVGVybWluYWxIYW5kbGVUb1dpcmVSZW5kZXJpbmcgPSAoaGFuZGxlOiBJRW50aXR5LCB0ZXJtaW5hbDogSUVudGl0eSkgPT4ge1xyXG4gICAgY29uc3QgaGFuZGxlUG9zZSA9IGhhbmRsZS4kY29weShQb3NlKTtcclxuICAgIGNvbnN0IHRlcm1pbmFsUG9zZSA9IHRlcm1pbmFsLiRjb3B5KFBvc2UpO1xyXG4gICAgY29uc3QgcG9zZSA9IHtcclxuICAgICAgICB4OiAoaGFuZGxlUG9zZS54ICsgdGVybWluYWxQb3NlLngpIC8gMixcclxuICAgICAgICB5OiAoaGFuZGxlUG9zZS55ICsgdGVybWluYWxQb3NlLnkpIC8gMixcclxuICAgICAgICBhOiBNYXRoLmF0YW4yKGhhbmRsZVBvc2UueSAtIHRlcm1pbmFsUG9zZS55LCBoYW5kbGVQb3NlLnggLSB0ZXJtaW5hbFBvc2UueCksXHJcbiAgICB9O1xyXG4gICAgY29uc3QgbGVuZ3RoID0gZ2V0RXVjbGlkZWFuRGlzdGFuY2VCZXR3ZWVuUG9pbnRzKGhhbmRsZVBvc2UsIHRlcm1pbmFsUG9zZSk7XHJcbiAgICBjb25zdCBzaGFwZSA9IHRyYW5zZm9ybVNoYXBlKHsgcG9pbnRzOiBbXHJcbiAgICAgICAgeyB4OiBsZW5ndGggLyAyLCB5OiAyIH0sXHJcbiAgICAgICAgeyB4OiAtbGVuZ3RoIC8gMiwgeTogMiB9LFxyXG4gICAgICAgIHsgeDogLWxlbmd0aCAvIDIsIHk6IC0yIH0sXHJcbiAgICAgICAgeyB4OiBsZW5ndGggLyAyLCB5OiAtMiB9LFxyXG4gICAgXX0sIHBvc2UpO1xyXG4gICAgY29uc3QgcmVuZGVyaW5nID0geyBjb2xvdXI6ICdXSElURScgfTtcclxuICAgIHJldHVybiB7IHNoYXBlLCByZW5kZXJpbmcgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjbGFzcyBSaXZldFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmNvbXBvbmVudHMuZm9yRXZlcnkoUml2ZXRDb21wb25lbnQpKChyaXZldCkgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCByZW5kZXJpbmcgPSByaXZldC5jb3B5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2UgPSByaXZldC4kZW50aXR5LiRjb3B5KFBvc2UpO1xyXG4gICAgICAgICAgICBjb25zdCBjb3JuZXJzID0gcml2ZXQuJGVudGl0eS4kY29weShTaGFwZSkucG9pbnRzO1xyXG4gICAgICAgICAgICBjb25zdCBwb2ludHMgPSBbXHJcbiAgICAgICAgICAgICAgICB7IHg6IGNvcm5lcnNbMF0ueCAtIDcsIHk6IGNvcm5lcnNbMF0ueSAtIDcgfSxcclxuICAgICAgICAgICAgICAgIHsgeDogY29ybmVyc1sxXS54ICsgNywgeTogY29ybmVyc1sxXS55IC0gNyB9LFxyXG4gICAgICAgICAgICAgICAgeyB4OiBjb3JuZXJzWzJdLnggKyA3LCB5OiBjb3JuZXJzWzJdLnkgKyA3IH0sXHJcbiAgICAgICAgICAgICAgICB7IHg6IGNvcm5lcnNbM10ueCAtIDcsIHk6IGNvcm5lcnNbM10ueSArIDcgfSxcclxuICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgcG9pbnRzLmZvckVhY2goKHBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbmdpbmUudmlld3BvcnQuZHJhd0NpcmNsZSh7XHJcbiAgICAgICAgICAgICAgICAgICAgcG9pbnQ6IHsgeDogcG9pbnQueCArIHBvc2UueCwgeTogcG9pbnQueSArIHBvc2UueSB9LFxyXG4gICAgICAgICAgICAgICAgICAgIHJhZGl1czogcmVuZGVyaW5nLnJhZGl1cyxcclxuICAgICAgICAgICAgICAgICAgICByZW5kZXJpbmcsXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IElDb21wb25lbnQgZnJvbSAnLi9pbnRlcmZhY2VzL0lDb21wb25lbnQnO1xyXG5pbXBvcnQgSUVudGl0eSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eSc7XHJcbmltcG9ydCBVbmlxdWUgZnJvbSAnLi4vZnJhbWV3b3JrL2Fic3RyYWN0cy9VbmlxdWUnO1xyXG5cclxuZXhwb3J0IGFic3RyYWN0IGNsYXNzIENvbXBvbmVudDxUIGV4dGVuZHMge30+IGV4dGVuZHMgVW5pcXVlIGltcGxlbWVudHMgSUNvbXBvbmVudDxUPiB7XHJcblxyXG4gICAgcHVibGljICRlbnRpdHk6IElFbnRpdHk7XHJcblxyXG4gICAgcHJpdmF0ZSBfX2RhdGE6IFQ7XHJcblxyXG4gICAgY29uc3RydWN0b3IoZGF0YTogVCkge1xyXG4gICAgICAgIHN1cGVyKCk7XHJcbiAgICAgICAgdGhpcy5tdXRhdGUoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGluamVjdChlbnRpdHk6IElFbnRpdHkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbnRpdHkgPSBlbnRpdHk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNvcHkoKTogVCB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19jbG9uZSh0aGlzLl9fZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG11dGF0ZShkYXRhOiBUKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2RhdGEgPSB0aGlzLl9fY2xvbmUoZGF0YSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2Nsb25lKGRhdGE6IFQpOiBUIHtcclxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBEaWN0aW9uYXJ5IGZyb20gJy4uL2ZyYW1ld29yay9jb25jcmV0ZXMvRGljdGlvbmFyeSc7XHJcbmltcG9ydCBGYWN0b3J5IGZyb20gJy4uL2ZyYW1ld29yay9jb25jcmV0ZXMvRmFjdG9yeSc7XHJcbmltcG9ydCBJQ29tcG9uZW50IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29tcG9uZW50JztcclxuaW1wb3J0IElDb21wb25lbnRGYWN0b3J5IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29tcG9uZW50RmFjdG9yeSc7XHJcbmltcG9ydCBJRGljdGlvbmFyeSBmcm9tICcuLi9mcmFtZXdvcmsvaW50ZXJmYWNlcy9JRGljdGlvbmFyeSc7XHJcbmltcG9ydCBJRmFjdG9yeSBmcm9tICcuLi9mcmFtZXdvcmsvaW50ZXJmYWNlcy9JRmFjdG9yeSc7XHJcbmltcG9ydCBXcmFwcGVyIGZyb20gJy4uL2ZyYW1ld29yay9hYnN0cmFjdHMvV3JhcHBlcic7XHJcbmltcG9ydCB7IEN0b3IgfSBmcm9tICcuLi9mcmFtZXdvcmsvdHlwZXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQ29tcG9uZW50RmFjdG9yeSBleHRlbmRzIFdyYXBwZXI8SURpY3Rpb25hcnk8SUZhY3Rvcnk8SUNvbXBvbmVudDxhbnk+Pj4+XHJcbmltcGxlbWVudHMgSUNvbXBvbmVudEZhY3Rvcnkge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKG5ldyBEaWN0aW9uYXJ5KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGU8VD4oQ29tcG9uZW50Q3RvcjogQ3RvcjxJQ29tcG9uZW50PFQ+LCBUPiwgYXJnPzogVCk6IElDb21wb25lbnQ8VD4ge1xyXG4gICAgICAgIGxldCBmYWN0b3J5ID0gdGhpcy51bndyYXAoKS5yZWFkKENvbXBvbmVudEN0b3IubmFtZSk7XHJcbiAgICAgICAgaWYgKCFmYWN0b3J5KSB7XHJcbiAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgRmFjdG9yeSgpO1xyXG4gICAgICAgICAgICB0aGlzLnVud3JhcCgpLndyaXRlKHtcclxuICAgICAgICAgICAgICAgIGtleTogQ29tcG9uZW50Q3Rvci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IGZhY3RvcnksXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFjdG9yeS5jcmVhdGUoQ29tcG9uZW50Q3RvciwgYXJnKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzdHJveShjb21wb25lbnQ6IElDb21wb25lbnQ8YW55Pik6IHZvaWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpLnJlYWQoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUpLmRlc3Ryb3koY29tcG9uZW50KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZm9yRXZlcnk8VEFyZz4oQ29tcG9uZW50Q3RvcjogQ3RvcjxJQ29tcG9uZW50PFRBcmc+LCBUQXJnPik6XHJcbiAgICAoZm46IChjb21wb25lbnQ6IElDb21wb25lbnQ8VEFyZz4pID0+IHZvaWQpID0+IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLnVud3JhcCgpLnJlYWQoQ29tcG9uZW50Q3Rvci5uYW1lKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24uZm9yRWFjaC5iaW5kKGNvbGxlY3Rpb24pIDogZnVuY3Rpb24oKTogdm9pZCB7IHJldHVybjsgfTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IHsgQW5pbWF0ZWRJbWFnZVN5c3RlbSB9IGZyb20gJy4vc3lzdGVtcy9BbmltYXRlZEltYWdlU3lzdGVtJztcclxuaW1wb3J0IENvbXBvbmVudEZhY3RvcnkgZnJvbSAnLi9Db21wb25lbnRGYWN0b3J5JztcclxuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSAnLi4vZnJhbWV3b3JrL2NvbmNyZXRlcy9EaWN0aW9uYXJ5JztcclxuaW1wb3J0IEVudGl0eU1hc3RlciBmcm9tICcuL0VudGl0eU1hc3Rlcic7XHJcbmltcG9ydCBJQWRhcHRlZEtleWJvYXJkRXZlbnQgZnJvbSAnLi9pbnRlcmZhY2VzL0lBZGFwdGVkS2V5Ym9hcmRFdmVudCc7XHJcbmltcG9ydCBJQWRhcHRlZE1vdXNlRXZlbnQgZnJvbSAnLi9pbnRlcmZhY2VzL0lBZGFwdGVkTW91c2VFdmVudCc7XHJcbmltcG9ydCBJQ29tcG9uZW50RmFjdG9yeSBmcm9tICcuL2ludGVyZmFjZXMvSUNvbXBvbmVudEZhY3RvcnknO1xyXG5pbXBvcnQgSURpY3Rpb25hcnkgZnJvbSAnLi4vZnJhbWV3b3JrL2ludGVyZmFjZXMvSURpY3Rpb25hcnknO1xyXG5pbXBvcnQgSUVuZ2luZSBmcm9tICcuL2ludGVyZmFjZXMvSUVuZ2luZSc7XHJcbmltcG9ydCBJRW50aXR5RmFjdG9yeSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eU1hc3Rlcic7XHJcbmltcG9ydCBJU3lzdGVtIGZyb20gJy4vaW50ZXJmYWNlcy9JU3lzdGVtJztcclxuaW1wb3J0IElWaWV3cG9ydEFkYXB0b3IgZnJvbSAnLi9pbnRlcmZhY2VzL0lWaWV3cG9ydEFkYXB0b3InO1xyXG5pbXBvcnQgSW1hZ2VTeXN0ZW0gZnJvbSAnLi9zeXN0ZW1zL0ltYWdlU3lzdGVtJztcclxuaW1wb3J0IHsgSW50ZXJhY3RpdmVTeXN0ZW0gfSBmcm9tICcuL3N5c3RlbXMvSW50ZXJhY3RpdmVTeXN0ZW0nO1xyXG5pbXBvcnQgTGFiZWxTeXN0ZW0gZnJvbSAnLi9zeXN0ZW1zL0xhYmVsU3lzdGVtJztcclxuaW1wb3J0IHsgUG9zZVN0ZXBwZXJTeXN0ZW0gfSBmcm9tICcuL3N5c3RlbXMvUG9zZVN0ZXBwZXJTeXN0ZW0nO1xyXG5pbXBvcnQgU2hhcGVTeXN0ZW0gZnJvbSAnLi9zeXN0ZW1zL1NoYXBlU3lzdGVtJztcclxuaW1wb3J0IHsgQ3RvciB9IGZyb20gJy4uL2ZyYW1ld29yay90eXBlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBFbmdpbmUgaW1wbGVtZW50cyBJRW5naW5lIHtcclxuXHJcbiAgICBwdWJsaWMgdmlld3BvcnQ6IElWaWV3cG9ydEFkYXB0b3I7XHJcbiAgICBwdWJsaWMgY29tcG9uZW50czogSUNvbXBvbmVudEZhY3Rvcnk7XHJcbiAgICBwdWJsaWMgZW50aXRpZXM6IElFbnRpdHlGYWN0b3J5O1xyXG5cclxuICAgIHB1YmxpYyBtb3VzZTogSUFkYXB0ZWRNb3VzZUV2ZW50O1xyXG4gICAgcHVibGljIGtleWJvYXJkOiBJQWRhcHRlZEtleWJvYXJkRXZlbnQ7XHJcblxyXG4gICAgcHVibGljIGRlbHRhOiBudW1iZXI7XHJcblxyXG4gICAgcHJpdmF0ZSBfX3Q6IERhdGU7XHJcbiAgICBwcml2YXRlIF9fc3lzdGVtczogSURpY3Rpb25hcnk8SVN5c3RlbT47XHJcblxyXG4gICAgY29uc3RydWN0b3Iodmlld3BvcnQ6IElWaWV3cG9ydEFkYXB0b3IpIHtcclxuICAgICAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XHJcbiAgICAgICAgdGhpcy5jb21wb25lbnRzID0gbmV3IENvbXBvbmVudEZhY3RvcnkoKTtcclxuICAgICAgICB0aGlzLmVudGl0aWVzID0gbmV3IEVudGl0eU1hc3Rlcih0aGlzKTtcclxuICAgICAgICB0aGlzLl9fc3lzdGVtcyA9IG5ldyBEaWN0aW9uYXJ5PElTeXN0ZW0+KCk7XHJcbiAgICAgICAgdGhpcy5fX3QgPSBuZXcgRGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX19pbml0U3lzdGVtcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IG5vdyA9IG5ldyBEYXRlKCk7XHJcbiAgICAgICAgdGhpcy5kZWx0YSA9IG5vdy5nZXRUaW1lKCkgLSB0aGlzLl9fdC5nZXRUaW1lKCk7XHJcbiAgICAgICAgdGhpcy5fX3QgPSBub3c7XHJcbiAgICAgICAgdGhpcy5fX3N5c3RlbXMuZm9yRWFjaCgoc3lzdGVtOiBJU3lzdGVtKSA9PiBzeXN0ZW0ub25jZSgpKTtcclxuICAgICAgICB0aGlzLmVudGl0aWVzLm9uY2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fc3lzdGVtcy5mb3JFYWNoKChzeXN0ZW06IElTeXN0ZW0pID0+IHN5c3RlbS5kcmF3KCkpO1xyXG4gICAgICAgIHRoaXMudmlld3BvcnQub25jZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBhZGQoU3lzdGVtQ3RvcjogQ3RvcjxJU3lzdGVtLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3N5c3RlbXMud3JpdGUoe1xyXG4gICAgICAgICAgICBrZXk6IFN5c3RlbUN0b3IubmFtZSxcclxuICAgICAgICAgICAgdmFsdWU6IG5ldyBTeXN0ZW1DdG9yKHRoaXMpLFxyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZW1vdmUoU3lzdGVtQ3RvcjogQ3RvcjxJU3lzdGVtLCBhbnk+KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3N5c3RlbXMuZGVsZXRlKFN5c3RlbUN0b3IubmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2luaXRTeXN0ZW1zKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuYWRkKExhYmVsU3lzdGVtKTtcclxuICAgICAgICB0aGlzLmFkZChTaGFwZVN5c3RlbSk7XHJcbiAgICAgICAgdGhpcy5hZGQoSW1hZ2VTeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuYWRkKEFuaW1hdGVkSW1hZ2VTeXN0ZW0pO1xyXG4gICAgICAgIHRoaXMuYWRkKEludGVyYWN0aXZlU3lzdGVtKTtcclxuICAgICAgICB0aGlzLmFkZChQb3NlU3RlcHBlclN5c3RlbSk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBJQ29tcG9uZW50IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29tcG9uZW50JztcclxuaW1wb3J0IElFbmdpbmUgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbmdpbmUnO1xyXG5pbXBvcnQgSUVudGl0eSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eSc7XHJcbmltcG9ydCBVbmlxdWUgZnJvbSAnLi4vZnJhbWV3b3JrL2Fic3RyYWN0cy9VbmlxdWUnO1xyXG5pbXBvcnQgeyBDdG9yIH0gZnJvbSAnLi4vZnJhbWV3b3JrL3R5cGVzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEVudGl0eSBleHRlbmRzIFVuaXF1ZSBpbXBsZW1lbnRzIElFbnRpdHkge1xyXG5cclxuICAgIHB1YmxpYyAkZW5naW5lOiBJRW5naW5lO1xyXG5cclxuICAgIHByaXZhdGUgX19kYXRhOiB7IFtrZXk6IHN0cmluZ106IElDb21wb25lbnQ8YW55PiB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHsgZW5naW5lIH06IHsgZW5naW5lOiBJRW5naW5lIH0pIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZSA9IGVuZ2luZTtcclxuICAgICAgICB0aGlzLl9fZGF0YSA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcclxuICAgICAgICByZXR1cm4gdGhpcy4kZW5naW5lLmVudGl0aWVzLmRlc3Ryb3kodGhpcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRhZGQ8VD4oQ29tcG9uZW50Q3RvcjogQ3RvcjxJQ29tcG9uZW50PFQ+LCBUPik6IChkYXRhOiBUKSA9PiB2b2lkIHtcclxuICAgICAgICByZXR1cm4gKGRhdGE6IFQpID0+IHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9fZGF0YVtDb21wb25lbnRDdG9yLm5hbWVdKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fZGF0YVtDb21wb25lbnRDdG9yLm5hbWVdID0gdGhpcy4kZW5naW5lLmNvbXBvbmVudHMuY3JlYXRlKENvbXBvbmVudEN0b3IsIGRhdGEpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2RhdGFbQ29tcG9uZW50Q3Rvci5uYW1lXS5pbmplY3QodGhpcyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJG11dGF0ZShDb21wb25lbnRDdG9yKShkYXRhKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkcmVtb3ZlPFQ+KENvbXBvbmVudEN0b3I6IEN0b3I8SUNvbXBvbmVudDxUPiwgVD4pOiB2b2lkIHtcclxuICAgICAgICBpZiAoIXRoaXMuX19kYXRhW0NvbXBvbmVudEN0b3IubmFtZV0pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkZWxldGUgdGhpcy5fX2RhdGFbQ29tcG9uZW50Q3Rvci5uYW1lXTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuY29tcG9uZW50cy5kZXN0cm95KHRoaXMuX19kYXRhW0NvbXBvbmVudEN0b3IubmFtZV0pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkY29weTxUPihDb21wb25lbnRDdG9yOiBDdG9yPElDb21wb25lbnQ8VD4sIFQ+KTogVCB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9fZGF0YVtDb21wb25lbnRDdG9yLm5hbWVdKVxyXG4gICAgICAgICAgICA/IHRoaXMuX19kYXRhW0NvbXBvbmVudEN0b3IubmFtZV0uY29weSgpXHJcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbXV0YXRlPFQ+KENvbXBvbmVudEN0b3I6IEN0b3I8SUNvbXBvbmVudDxUPiwgVD4pOiAoZGF0YTogVCkgPT4gdm9pZCB7XHJcbiAgICAgICAgcmV0dXJuIChkYXRhOiBUKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX19kYXRhW0NvbXBvbmVudEN0b3IubmFtZV0ubXV0YXRlKGRhdGEpO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRwYXRjaDxUPihDb21wb25lbnRDdG9yOiBDdG9yPElDb21wb25lbnQ8VD4sIFQ+KTogKGRhdGE6IHt9KSA9PiB2b2lkIHtcclxuICAgICAgICByZXR1cm4gKGRhdGE6IHt9KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX19kYXRhW0NvbXBvbmVudEN0b3IubmFtZV0ubXV0YXRlKE9iamVjdC5hc3NpZ24odGhpcy5fX2RhdGFbQ29tcG9uZW50Q3Rvci5uYW1lXS5jb3B5KCksIGRhdGEpKTtcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZm9yRWFjaChmbjogKGNvbXBvbmVudDogSUNvbXBvbmVudDxhbnk+KSA9PiB2b2lkKTogdm9pZCB7XHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fX2RhdGEpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBmbih0aGlzLl9fZGF0YVtrZXldKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IERpY3Rpb25hcnkgZnJvbSAnLi4vZnJhbWV3b3JrL2NvbmNyZXRlcy9EaWN0aW9uYXJ5JztcclxuaW1wb3J0IEZhY3RvcnkgZnJvbSAnLi4vZnJhbWV3b3JrL2NvbmNyZXRlcy9GYWN0b3J5JztcclxuaW1wb3J0IElEaWN0aW9uYXJ5IGZyb20gJy4uL2ZyYW1ld29yay9pbnRlcmZhY2VzL0lEaWN0aW9uYXJ5JztcclxuaW1wb3J0IElFbmdpbmUgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbmdpbmUnO1xyXG5pbXBvcnQgSUVudGl0eSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eSc7XHJcbmltcG9ydCBJRW50aXR5TWFzdGVyIGZyb20gJy4vaW50ZXJmYWNlcy9JRW50aXR5TWFzdGVyJztcclxuaW1wb3J0IElGYWN0b3J5IGZyb20gJy4uL2ZyYW1ld29yay9pbnRlcmZhY2VzL0lGYWN0b3J5JztcclxuaW1wb3J0IFdyYXBwZXIgZnJvbSAnLi4vZnJhbWV3b3JrL2Fic3RyYWN0cy9XcmFwcGVyJztcclxuaW1wb3J0IHsgQ3RvciwgT3B0aW9uYWwgfSBmcm9tICcuLi9mcmFtZXdvcmsvdHlwZXMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5TWFzdGVyIGV4dGVuZHMgV3JhcHBlcjxJRGljdGlvbmFyeTxJRmFjdG9yeTxJRW50aXR5Pj4+IGltcGxlbWVudHMgSUVudGl0eU1hc3RlciB7XHJcblxyXG4gICAgcHVibGljICRlbmdpbmU6IElFbmdpbmU7XHJcblxyXG4gICAgcHVibGljIGNyZWF0aW9uVGFyZ2V0czogSUVudGl0eVtdID0gW107XHJcbiAgICBwdWJsaWMgZGVzdHJ1Y3Rpb25UYXJnZXRzOiBJRW50aXR5W10gPSBbXTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmU6IElFbmdpbmUpIHtcclxuICAgICAgICBzdXBlcihuZXcgRGljdGlvbmFyeSgpKTtcclxuICAgICAgICB0aGlzLiRlbmdpbmUgPSBlbmdpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGNyZWF0ZTxUIGV4dGVuZHMgSUVudGl0eSwgVEFyZz4oRW50aXR5Q3RvcjogQ3RvcjxULCBPcHRpb25hbDxUQXJnPj4sIGFyZz86IFRBcmcpOiBUIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBFbnRpdHlDdG9yKE9iamVjdC5hc3NpZ24oe30sIGFyZywgeyBlbmdpbmU6IHRoaXMuJGVuZ2luZSB9KSk7XHJcbiAgICAgICAgdGhpcy5jcmVhdGlvblRhcmdldHMucHVzaChpbnN0YW5jZSk7XHJcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBkZXN0cm95KGVudGl0eTogSUVudGl0eSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGVzdHJ1Y3Rpb25UYXJnZXRzLnB1c2goZW50aXR5KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZm9yRXZlcnk8VCBleHRlbmRzIElFbnRpdHk+KEVudGl0eUN0b3I6IEN0b3I8VCwgYW55Pik6IChmbjogKGVudGl0eTogVCkgPT4gdm9pZCkgPT4gdm9pZCB7XHJcbiAgICAgICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMudW53cmFwKCkucmVhZChFbnRpdHlDdG9yLm5hbWUpO1xyXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5mb3JFYWNoLmJpbmQoY29sbGVjdGlvbikgOiBmdW5jdGlvbigpOiB2b2lkIHsgcmV0dXJuOyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBmaXJzdDxUIGV4dGVuZHMgSUVudGl0eT4oRW50aXR5Q3RvcjogQ3RvcjxULCBhbnk+KTogKGZuOiAoZW50aXR5OiBUKSA9PiB2b2lkKSA9PiB2b2lkIHtcclxuICAgICAgICBjb25zdCBjb2xsZWN0aW9uID0gdGhpcy51bndyYXAoKS5yZWFkKEVudGl0eUN0b3IubmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmZpcnN0LmJpbmQoY29sbGVjdGlvbikgOiBmdW5jdGlvbigpOiB2b2lkIHsgcmV0dXJuOyB9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBmaW5kPFQgZXh0ZW5kcyBJRW50aXR5PihFbnRpdHlDdG9yOiBDdG9yPFQsIGFueT4pOiAoZm46IChlbnRpdHk6IFQpID0+IGJvb2xlYW4pID0+IFQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLnVud3JhcCgpLnJlYWQoRW50aXR5Q3Rvci5uYW1lKTtcclxuICAgICAgICByZXR1cm4gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24uZmluZC5iaW5kKGNvbGxlY3Rpb24pIDogZnVuY3Rpb24oKTogdm9pZCB7IHJldHVybjsgfTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fY3JlYXRlVGFyZ2V0cygpO1xyXG4gICAgICAgIHRoaXMuX19kZXN0cm95VGFyZ2V0cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX19jcmVhdGVUYXJnZXRzKCk6IHZvaWQge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmNyZWF0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgaW5zdGFuY2UgPSB0aGlzLmNyZWF0aW9uVGFyZ2V0cy5zaGlmdCgpITtcclxuICAgICAgICAgICAgbGV0IHRhcmdldDogYW55ID0gaW5zdGFuY2U7XHJcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIGxldCBmYWN0b3J5ID0gdGhpcy51bndyYXAoKS5yZWFkKHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lKTtcclxuICAgICAgICAgICAgICAgIGlmICghZmFjdG9yeSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGZhY3RvcnkgPSBuZXcgRmFjdG9yeSgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMudW53cmFwKCkud3JpdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IHRhcmdldC5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogZmFjdG9yeSxcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGZhY3RvcnkuYWRkKGluc3RhbmNlKTtcclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IHRhcmdldC5fX3Byb3RvX187XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2Rlc3Ryb3lUYXJnZXRzKCk6IHZvaWQge1xyXG4gICAgICAgIHdoaWxlICh0aGlzLmRlc3RydWN0aW9uVGFyZ2V0cy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3QgZW50aXR5ID0gdGhpcy5kZXN0cnVjdGlvblRhcmdldHMuc2hpZnQoKSE7XHJcbiAgICAgICAgICAgIGVudGl0eS4kZm9yRWFjaCgoY29tcG9uZW50KSA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLiRlbmdpbmUuY29tcG9uZW50cy5kZXN0cm95KGNvbXBvbmVudCk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBsZXQgdGFyZ2V0OiBhbnkgPSBlbnRpdHk7XHJcbiAgICAgICAgICAgIHdoaWxlICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMudW53cmFwKCkucmVhZCh0YXJnZXQuY29uc3RydWN0b3IubmFtZSkuZGVzdHJveShlbnRpdHkpO1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0ID0gdGFyZ2V0Ll9fcHJvdG9fXztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IElBZGFwdGVkS2V5Ym9hcmRFdmVudCBmcm9tICcuL2ludGVyZmFjZXMvSUFkYXB0ZWRLZXlib2FyZEV2ZW50JztcclxuaW1wb3J0IElLZXlib2FyZEhhbmRsZXIgZnJvbSAnLi9pbnRlcmZhY2VzL0lLZXlib2FyZEhhbmRsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgS2V5Ym9hcmRIYW5kbGVyIGltcGxlbWVudHMgSUtleWJvYXJkSGFuZGxlciB7XHJcblxyXG4gICAgW2tleTogc3RyaW5nXTogYW55XHJcblxyXG4gICAgcHVibGljIGtleWRvd25zOiB7IFtrZXk6IHN0cmluZ106IChrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQpID0+IHZvaWQgfTtcclxuICAgIHB1YmxpYyBrZXlwcmVzc2VzOiB7IFtrZXk6IHN0cmluZ106IChrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQpID0+IHZvaWQgfTtcclxuICAgIHB1YmxpYyBrZXl1cHM6IHsgW2tleTogc3RyaW5nXTogKGtleWJvYXJkRXZlbnQ6IElBZGFwdGVkS2V5Ym9hcmRFdmVudCkgPT4gdm9pZCB9O1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHRoaXMua2V5ZG93bnMgPSB7fTtcclxuICAgICAgICB0aGlzLmtleXByZXNzZXMgPSB7fTtcclxuICAgICAgICB0aGlzLmtleXVwcyA9IHt9O1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBrZXlkb3duKGtleWJvYXJkRXZlbnQ6IElBZGFwdGVkS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19oYW5kbGUoa2V5Ym9hcmRFdmVudCwgdGhpcy5rZXlkb3ducyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGtleXByZXNzKGtleWJvYXJkRXZlbnQ6IElBZGFwdGVkS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19oYW5kbGUoa2V5Ym9hcmRFdmVudCwgdGhpcy5rZXlwcmVzc2VzKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMga2V5dXAoa2V5Ym9hcmRFdmVudDogSUFkYXB0ZWRLZXlib2FyZEV2ZW50KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2hhbmRsZShrZXlib2FyZEV2ZW50LCB0aGlzLmtleXVwcyk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2hhbmRsZShcclxuICAgICAgICBrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQsXHJcbiAgICAgICAga2V5czogeyBba2V5OiBzdHJpbmddOiAoa2V5Ym9hcmRFdmVudDogSUFkYXB0ZWRLZXlib2FyZEV2ZW50KSA9PiB2b2lkIH0sXHJcbiAgICApOiB2b2lkIHtcclxuICAgICAgICBpZiAoa2V5c1trZXlib2FyZEV2ZW50LmtleV0pIHtcclxuICAgICAgICAgICAga2V5c1trZXlib2FyZEV2ZW50LmtleV0oa2V5Ym9hcmRFdmVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgSUVuZ2luZSBmcm9tICcuLi9pbnRlcmZhY2VzL0lFbmdpbmUnO1xyXG5pbXBvcnQgSVN5c3RlbSBmcm9tICcuLi9pbnRlcmZhY2VzL0lTeXN0ZW0nO1xyXG5pbXBvcnQgVW5pcXVlIGZyb20gJy4uLy4uL2ZyYW1ld29yay9hYnN0cmFjdHMvVW5pcXVlJztcclxuXHJcbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBTeXN0ZW0gZXh0ZW5kcyBVbmlxdWUgaW1wbGVtZW50cyBJU3lzdGVtIHtcclxuXHJcbiAgICBwdWJsaWMgJGVuZ2luZTogSUVuZ2luZTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihlbmdpbmU6IElFbmdpbmUpIHtcclxuICAgICAgICBzdXBlcigpO1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZSA9IGVuZ2luZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHsgcmV0dXJuOyB9XHJcblxyXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7IHJldHVybjsgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgeyBDb21wb25lbnQgfSBmcm9tICcuL0NvbXBvbmVudCc7XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQb2ludCB7IHg6IG51bWJlcjsgeTogbnVtYmVyOyB9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElQb3NlIHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGE6IG51bWJlcjsgfVxyXG5leHBvcnQgY2xhc3MgUG9zZSBleHRlbmRzIENvbXBvbmVudDxJUG9zZT4ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVNoYXBlIHsgcG9pbnRzOiBJUG9pbnRbXTsgcmVuZGVyaW5nPzogSVNoYXBlUmVuZGVyaW5nUHJvZmlsZTsgfVxyXG5leHBvcnQgY2xhc3MgU2hhcGUgZXh0ZW5kcyBDb21wb25lbnQ8SVNoYXBlPiB7fVxyXG5cclxuZXhwb3J0IGludGVyZmFjZSBJTGFiZWwge1xyXG4gICAgdGV4dDogc3RyaW5nO1xyXG4gICAgZm9udFNpemU6IG51bWJlcjtcclxuICAgIG9mZnNldDogeyB4OiBudW1iZXIsIHk6IG51bWJlciB9O1xyXG4gICAgY29sb3VyPzogc3RyaW5nO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBMYWJlbCBleHRlbmRzIENvbXBvbmVudDxJTGFiZWw+IHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElTaGFwZVJlbmRlcmluZ1Byb2ZpbGUge1xyXG4gICAgY29sb3VyOiBzdHJpbmc7XHJcbiAgICBvcGFjaXR5PzogbnVtYmVyO1xyXG4gICAgZmlsbFN0eWxlPzogc3RyaW5nO1xyXG4gICAgekluZGV4PzogbnVtYmVyO1xyXG59XHJcbmV4cG9ydCBjbGFzcyBTaGFwZVJlbmRlcmluZ1Byb2ZpbGUgZXh0ZW5kcyBDb21wb25lbnQ8SVNoYXBlUmVuZGVyaW5nUHJvZmlsZT4ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUltYWdlUmVuZGVyaW5nUHJvZmlsZSB7XHJcbiAgICBzcmM6IHN0cmluZztcclxuICAgIHdpZHRoPzogbnVtYmVyO1xyXG4gICAgaGVpZ2h0PzogbnVtYmVyO1xyXG4gICAgb3BhY2l0eT86IG51bWJlcjtcclxuICAgIHpJbmRleD86IG51bWJlcjtcclxuICAgIHJvdGF0ZT86IG51bWJlcjtcclxufVxyXG5leHBvcnQgY2xhc3MgSW1hZ2VSZW5kZXJpbmdQcm9maWxlIGV4dGVuZHMgQ29tcG9uZW50PElJbWFnZVJlbmRlcmluZ1Byb2ZpbGU+IHt9XHJcblxyXG5leHBvcnQgaW50ZXJmYWNlIElBbmltYXRlZEltYWdlUmVuZGVyaW5nUHJvZmlsZSB7XHJcbiAgICBzcmM6IHN0cmluZ1tdO1xyXG4gICAgZnJhbWU6IG51bWJlcjtcclxuICAgIHNwZWVkOiBudW1iZXI7XHJcbiAgICBjb29sZG93bjogbnVtYmVyO1xyXG4gICAgd2lkdGg/OiBudW1iZXI7XHJcbiAgICBoZWlnaHQ/OiBudW1iZXI7XHJcbiAgICBvcGFjaXR5PzogbnVtYmVyO1xyXG4gICAgaXNQYXVzZWQ/OiBib29sZWFuO1xyXG4gICAgaXNSZXZlcnNlZD86IGJvb2xlYW47XHJcbiAgICB6SW5kZXg/OiBudW1iZXI7XHJcbiAgICByb3RhdGU/OiBudW1iZXI7XHJcbn1cclxuZXhwb3J0IGNsYXNzIEFuaW1hdGVkSW1hZ2VSZW5kZXJpbmdQcm9maWxlIGV4dGVuZHMgQ29tcG9uZW50PElBbmltYXRlZEltYWdlUmVuZGVyaW5nUHJvZmlsZT4ge31cclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSVBvc2VTdGVwcGVyIHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGE6IG51bWJlcjsgfVxyXG5leHBvcnQgY2xhc3MgUG9zZVN0ZXBwZXJDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQ8SVBvc2VTdGVwcGVyPiB7fVxyXG4iLCJpbXBvcnQgYm9vbGVhbkNvbnRhaW5zIGZyb20gJ0B0dXJmL2Jvb2xlYW4tY29udGFpbnMnO1xyXG5pbXBvcnQgYm9vbGVhblBvaW50SW5Qb2x5Z29uIGZyb20gJ0B0dXJmL2Jvb2xlYW4tcG9pbnQtaW4tcG9seWdvbic7XHJcbmltcG9ydCBFbnRpdHkgZnJvbSAnLi9FbnRpdHknO1xyXG5pbXBvcnQgSUVudGl0eSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eSc7XHJcbmltcG9ydCB7IElQb2ludCwgUG9zZSwgU2hhcGUsIFNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9IGZyb20gJy4vY29tcG9uZW50cyc7XHJcbmltcG9ydCB7IGZyb21Qb2ludHNUb0dlb0pTT04sIGZyb21TaGFwZVRvR2VvSlNPTiwgdHJhbnNmb3JtU2hhcGUgfSBmcm9tICcuL2dlb21ldHJ5JztcclxuaW1wb3J0IHR1cmYgZnJvbSAndHVyZic7XHJcbmNvbnN0IGJvb2xlYW5PdmVybGFwcyA9IHJlcXVpcmUoJ0B0dXJmL2Jvb2xlYW4tb3ZlcmxhcCcpLmRlZmF1bHQ7XHJcbmNvbnN0IGxpbmVJbnRlcnNlY3QgPSByZXF1aXJlKCdAdHVyZi9saW5lLWludGVyc2VjdCcpLmRlZmF1bHQ7XHJcblxyXG5leHBvcnQgY2xhc3MgSW50ZXJhY3RpdmUgZXh0ZW5kcyBFbnRpdHkge1xyXG5cclxuICAgIFtrZXk6IHN0cmluZ106IGFueTtcclxuXHJcbiAgICBwcml2YXRlIF9faXNEaXNhYmxlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG4gICAgcHJpdmF0ZSBfX2lzSG92ZXJlZDogYm9vbGVhbiA9IGZhbHNlO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHsgeCwgeSwgYSB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCBhOiBudW1iZXIgfSkge1xyXG4gICAgICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFBvc2UpKHsgeCwgeSwgYSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgJGVuYWJsZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9faXNEaXNhYmxlZCA9IGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkZGlzYWJsZSgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9faXNEaXNhYmxlZCA9IHRydWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljICRvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIGlmICh0aGlzLl9faXNEaXNhYmxlZCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLiRlbmdpbmUubW91c2UubmFtZSA9PT0gJ25vbmUnKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKCFlbnRpdHlDb250YWluc1BvaW50KHRoaXMsIHRoaXMuJGVuZ2luZS5tb3VzZSkpIHtcclxuICAgICAgICAgICAgaWYgKHRoaXMuJGVuZ2luZS5tb3VzZS5uYW1lID09PSAnbW91c2Vtb3ZlJykge1xyXG4gICAgICAgICAgICAgICAgdGhpc1snJG1vdXNlbW92ZSddKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHRoaXMuX19pc0hvdmVyZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19pc0hvdmVyZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgICAgIHRoaXMuJG1vdXNlbGVhdmUoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5fX2lzSG92ZXJlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9faXNIb3ZlcmVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy4kbW91c2VlbnRlcigpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzW2AkJHt0aGlzLiRlbmdpbmUubW91c2UubmFtZX1gXSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyAkbW91c2VlbnRlcigpOiB2b2lkIHsgcmV0dXJuOyB9XHJcbiAgICBwdWJsaWMgJG1vdXNlbGVhdmUoKTogdm9pZCB7IHJldHVybjsgfVxyXG4gICAgcHVibGljICRtb3VzZW1vdmUoKTogdm9pZCB7IHJldHVybjsgfVxyXG4gICAgcHVibGljICRtb3VzZWRvd24oKTogdm9pZCB7IHJldHVybjsgfVxyXG4gICAgcHVibGljICRtb3VzZXVwKCk6IHZvaWQgeyByZXR1cm47IH1cclxuICAgIHB1YmxpYyAkY2xpY2soKTogdm9pZCB7IHJldHVybjsgfVxyXG59XHJcblxyXG5leHBvcnQgY2xhc3MgSW50ZXJhY3RpdmVFbGVtZW50IGV4dGVuZHMgSW50ZXJhY3RpdmUge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHsgeCwgeSwgd2lkdGgsIGhlaWdodCB9OiB7IHg6IG51bWJlciwgeTogbnVtYmVyLCB3aWR0aDogbnVtYmVyLCBoZWlnaHQ6IG51bWJlciB9KSB7XHJcbiAgICAgICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IGE6IDAgfSwgYXJndW1lbnRzWzBdKSk7XHJcbiAgICAgICAgdGhpcy4kYWRkKFNoYXBlKSh7IHBvaW50czogW1xyXG4gICAgICAgICAgICB7IHg6IHdpZHRoIC8gMiwgeTogaGVpZ2h0IC8gMiB9LFxyXG4gICAgICAgICAgICB7IHg6IC13aWR0aCAvIDIsIHk6IGhlaWdodCAvIDIgfSxcclxuICAgICAgICAgICAgeyB4OiAtd2lkdGggLyAyLCB5OiAtaGVpZ2h0IC8gMiB9LFxyXG4gICAgICAgICAgICB7IHg6IHdpZHRoIC8gMiwgeTogLWhlaWdodCAvIDIgfSxcclxuICAgICAgICBdfSk7XHJcbiAgICB9XHJcbn1cclxuXHJcbmV4cG9ydCBjb25zdCBlbnRpdHlDb250YWluc1BvaW50ID0gKGVudGl0eTogSUVudGl0eSwgcG9pbnQ6IElQb2ludCk6IGJvb2xlYW4gPT4ge1xyXG4gICAgY29uc3Qgc2hhcGUgPSB0cmFuc2Zvcm1TaGFwZShlbnRpdHkuJGNvcHkoU2hhcGUpLCBlbnRpdHkuJGNvcHkoUG9zZSkpO1xyXG4gICAgcmV0dXJuIGJvb2xlYW5Qb2ludEluUG9seWdvbih0dXJmLnBvaW50KFtwb2ludC54LCBwb2ludC55XSksIGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVudGl0aWVzVG91Y2ggPSAoZW50aXR5MTogSUVudGl0eSwgZW50aXR5MjogSUVudGl0eSk6IGJvb2xlYW4gPT4ge1xyXG4gICAgY29uc3Qgc2hhcGUxID0gdHJhbnNmb3JtU2hhcGUoZW50aXR5MS4kY29weShTaGFwZSksIGVudGl0eTEuJGNvcHkoUG9zZSkpO1xyXG4gICAgY29uc3Qgc2hhcGUyID0gdHJhbnNmb3JtU2hhcGUoZW50aXR5Mi4kY29weShTaGFwZSksIGVudGl0eTIuJGNvcHkoUG9zZSkpO1xyXG4gICAgcmV0dXJuIGJvb2xlYW5Db250YWlucyhmcm9tU2hhcGVUb0dlb0pTT04oc2hhcGUxKSwgZnJvbVNoYXBlVG9HZW9KU09OKHNoYXBlMikpIHx8XHJcbiAgICAgICAgYm9vbGVhbkNvbnRhaW5zKGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZTIpLCBmcm9tU2hhcGVUb0dlb0pTT04oc2hhcGUxKSkgfHxcclxuICAgICAgICBib29sZWFuT3ZlcmxhcHMoZnJvbVNoYXBlVG9HZW9KU09OKHNoYXBlMSksIGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZTIpKSB8fFxyXG4gICAgICAgIGJvb2xlYW5PdmVybGFwcyhmcm9tU2hhcGVUb0dlb0pTT04oc2hhcGUyKSwgZnJvbVNoYXBlVG9HZW9KU09OKHNoYXBlMSkpO1xyXG59O1xyXG5cclxuZXhwb3J0IGNvbnN0IGVudGl0eVRvdWNoZXNMaW5lID0gKGVudGl0eTogSUVudGl0eSwgcG9pbnRzOiBJUG9pbnRbXSk6IGJvb2xlYW4gPT4ge1xyXG4gICAgY29uc3Qgc2hhcGUgPSB0cmFuc2Zvcm1TaGFwZShlbnRpdHkuJGNvcHkoU2hhcGUpLCBlbnRpdHkuJGNvcHkoUG9zZSkpO1xyXG4gICAgY29uc3QgcG9seWdvbiA9IGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZSk7XHJcbiAgICBjb25zdCBsaW5lID0gZnJvbVBvaW50c1RvR2VvSlNPTihwb2ludHMpO1xyXG4gICAgcmV0dXJuIGxpbmVJbnRlcnNlY3QocG9seWdvbiwgbGluZSkuZmVhdHVyZXMubGVuZ3RoID4gMDtcclxufTtcclxuIiwiaW1wb3J0IHsgSVBvaW50LCBJUG9zZSwgSVNoYXBlIH0gZnJvbSAnLi9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgRmVhdHVyZSwgR2VvSnNvblByb3BlcnRpZXMsIE11bHRpUG9seWdvbiwgUG9seWdvbiB9IGZyb20gJ2dlb2pzb24nO1xyXG5pbXBvcnQgdHVyZiBmcm9tICd0dXJmJztcclxuXHJcbmV4cG9ydCBjb25zdCByb3RhdGVQb2ludEFib3V0T3JpZ2luID0gKHsgcG9pbnQsIG9yaWVudGF0aW9uIH06IHtcclxuICAgIHBvaW50OiBJUG9pbnQsIG9yaWVudGF0aW9uOiBudW1iZXIsXHJcbn0pOiBJUG9pbnQgPT4ge1xyXG4gICAgY29uc3QgcyA9IE1hdGguc2luKG9yaWVudGF0aW9uKTtcclxuICAgIGNvbnN0IGMgPSBNYXRoLmNvcyhvcmllbnRhdGlvbik7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHg6IHBvaW50LnggKiBjIC0gcG9pbnQueSAqIHMsXHJcbiAgICAgICAgeTogcG9pbnQueCAqIHMgKyBwb2ludC55ICogYyxcclxuICAgIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdHJhbnNmb3JtU2hhcGUgPSAoc2hhcGU6IElTaGFwZSwgcG9zZTogSVBvc2UpOiBJU2hhcGUgPT4ge1xyXG4gICAgY29uc3QgcG9pbnRzID0gc2hhcGUucG9pbnRzLm1hcCgocG9pbnQpID0+IHJvdGF0ZVBvaW50QWJvdXRPcmlnaW4oeyBwb2ludCwgb3JpZW50YXRpb246IHBvc2UuYSB9KSk7XHJcbiAgICByZXR1cm4gdHJhbnNsYXRlU2hhcGUoeyBzaGFwZTogeyBwb2ludHMgfSwgcG9zaXRpb246IHBvc2UgfSk7XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgdHJhbnNsYXRlU2hhcGUgPSAoeyBzaGFwZSwgcG9zaXRpb24gfTogeyBzaGFwZTogSVNoYXBlLCBwb3NpdGlvbjogSVBvaW50IH0pOiBJU2hhcGUgPT4ge1xyXG4gICAgY29uc3QgcG9pbnRzID0gc2hhcGUucG9pbnRzLm1hcCgocG9pbnQpID0+IHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICB4OiBwb2ludC54ICsgcG9zaXRpb24ueCxcclxuICAgICAgICAgICAgeTogcG9pbnQueSArIHBvc2l0aW9uLnksXHJcbiAgICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHsgcG9pbnRzIH07XHJcbn07XHJcblxyXG5leHBvcnQgY29uc3QgZnJvbVBvaW50c1RvR2VvSlNPTiA9IChwb2ludHM6IElQb2ludFtdKSA9PiB7XHJcbiAgICByZXR1cm4gdHVyZi5saW5lU3RyaW5nKHBvaW50cy5tYXAoKHBvaW50KSA9PiBbcG9pbnQueCwgcG9pbnQueV0pKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmcm9tU2hhcGVUb0dlb0pTT04gPSAoc2hhcGU6IElTaGFwZSk6IEZlYXR1cmU8UG9seWdvbiwgR2VvSnNvblByb3BlcnRpZXM+ID0+IHtcclxuICAgIHJldHVybiB0dXJmLnBvbHlnb24oW1xyXG4gICAgICAgIHNoYXBlLnBvaW50cy5tYXAoKHZlcnRleCkgPT4gW3ZlcnRleC54LCB2ZXJ0ZXgueSBdKS5jb25jYXQoW1tzaGFwZS5wb2ludHNbMF0ueCwgc2hhcGUucG9pbnRzWzBdLnldXSksXHJcbiAgICBdKTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBmcm9tR2VvSlNPTkNvb3JkaW5hdGVzVG9TaGFwZXMgPSAoZ2VvSlNPTjogRmVhdHVyZTxQb2x5Z29ufE11bHRpUG9seWdvbiwgR2VvSnNvblByb3BlcnRpZXM+KTogSVNoYXBlW10gPT4ge1xyXG4gICAgaWYgKCFnZW9KU09OKSB7XHJcbiAgICAgICAgcmV0dXJuIFtdO1xyXG4gICAgfVxyXG4gICAgaWYgKGdlb0pTT04uZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb0pTT04uZ2VvbWV0cnkuY29vcmRpbmF0ZXMubWFwKChwb2ludHM6IG51bWJlcltdW10pID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHsgcG9pbnRzOiBwb2ludHMubWFwKCh2ZXJ0ZXg6IG51bWJlcltdKSA9PiAoeyB4OiB2ZXJ0ZXhbMF0sIHk6IHZlcnRleFsxXSB9KSkgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIGlmIChnZW9KU09OLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aVBvbHlnb24nKSB7XHJcbiAgICAgICAgY29uc3Qgc2hhcGVzOiBJU2hhcGVbXSA9IFtdO1xyXG4gICAgICAgIGdlb0pTT04uZ2VvbWV0cnkuY29vcmRpbmF0ZXMuZm9yRWFjaCgocG9seWdvbikgPT4ge1xyXG4gICAgICAgICAgICBzaGFwZXMucHVzaChwb2x5Z29uLm1hcCgocG9pbnRzOiBudW1iZXJbXVtdKSA9PiB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4geyBwb2ludHM6IHBvaW50cy5tYXAoKHZlcnRleDogbnVtYmVyW10pID0+ICh7IHg6IHZlcnRleFswXSwgeTogdmVydGV4WzFdIH0pKSB9O1xyXG4gICAgICAgICAgICB9KVswXSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIHNoYXBlcztcclxuICAgIH1cclxuICAgIHJldHVybiBbXTtcclxufTtcclxuXHJcbmV4cG9ydCBpbnRlcmZhY2UgSUJvdW5kYXJ5IHsgbWluWDogbnVtYmVyOyBtYXhYOiBudW1iZXI7IG1pblk6IG51bWJlcjsgbWF4WTogbnVtYmVyOyB9XHJcbmV4cG9ydCBjb25zdCBmcm9tU2hhcGVUb0JvdW5kYXJ5ID0gKHNoYXBlOiBJU2hhcGUpOiBJQm91bmRhcnkgPT4ge1xyXG4gICAgY29uc3QgZ2VvanNvbiA9IGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZSk7XHJcbiAgICBjb25zdCBiYm94ID0gdHVyZi5iYm94KGdlb2pzb24pO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBtaW5YOiBiYm94WzBdLFxyXG4gICAgICAgIG1pblk6IGJib3hbMV0sXHJcbiAgICAgICAgbWF4WDogYmJveFsyXSxcclxuICAgICAgICBtYXhZOiBiYm94WzNdLFxyXG4gICAgfTtcclxufTtcclxuXHJcbmV4cG9ydCBjb25zdCBnZXRFdWNsaWRlYW5EaXN0YW5jZUJldHdlZW5Qb2ludHMgPSAocDE6IElQb2ludCwgcDI6IElQb2ludCk6IG51bWJlciA9PiB7XHJcbiAgICByZXR1cm4gTWF0aC5zcXJ0KE1hdGgucG93KChwMi54IC0gcDEueCksIDIpICsgTWF0aC5wb3cocDIueSAtIHAxLnksIDIpKTtcclxufTtcclxuIiwiaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnLi4vYWJzdHJhY3RzL1N5c3RlbSc7XHJcbmltcG9ydCB7IEFuaW1hdGVkSW1hZ2VSZW5kZXJpbmdQcm9maWxlLCBQb3NlIH0gZnJvbSAnLi4vY29tcG9uZW50cyc7XHJcblxyXG5leHBvcnQgY2xhc3MgQW5pbWF0ZWRJbWFnZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmNvbXBvbmVudHMuZm9yRXZlcnkoQW5pbWF0ZWRJbWFnZVJlbmRlcmluZ1Byb2ZpbGUpKChwcm9maWxlKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGRhdGEgPSBwcm9maWxlLmNvcHkoKTtcclxuICAgICAgICAgICAgaWYgKGRhdGEuY29vbGRvd24gPT09IGRhdGEuc3BlZWQpIHtcclxuICAgICAgICAgICAgICAgIGRhdGEuY29vbGRvd24gPSAwO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuaXNSZXZlcnNlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRhdGEuZnJhbWUtLTtcclxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mcmFtZSsrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuZnJhbWUgPiBkYXRhLnNyYy5sZW5ndGggLSAxKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGF0YS5mcmFtZSA9IDA7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBpZiAoZGF0YS5mcmFtZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICBkYXRhLmZyYW1lID0gZGF0YS5zcmMubGVuZ3RoIC0gMTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSBlbHNlIGlmICghZGF0YS5pc1BhdXNlZCkge1xyXG4gICAgICAgICAgICAgICAgZGF0YS5jb29sZG93bisrO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByb2ZpbGUuJGVudGl0eS4kbXV0YXRlKEFuaW1hdGVkSW1hZ2VSZW5kZXJpbmdQcm9maWxlKShkYXRhKTtcclxuICAgICAgICAgICAgdGhpcy4kZW5naW5lLnZpZXdwb3J0LmRyYXdJbWFnZSh7XHJcbiAgICAgICAgICAgICAgICBwb3NlOiBwcm9maWxlLiRlbnRpdHkuJGNvcHkoUG9zZSksXHJcbiAgICAgICAgICAgICAgICByZW5kZXJpbmc6IE9iamVjdC5hc3NpZ24oZGF0YSwge1xyXG4gICAgICAgICAgICAgICAgICAgIHNyYzogZGF0YS5zcmNbZGF0YS5mcmFtZV0sXHJcbiAgICAgICAgICAgICAgICB9KSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnLi4vYWJzdHJhY3RzL1N5c3RlbSc7XHJcbmltcG9ydCB7IEltYWdlUmVuZGVyaW5nUHJvZmlsZSwgUG9zZSB9IGZyb20gJy4uL2NvbXBvbmVudHMnO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5jb21wb25lbnRzLmZvckV2ZXJ5KEltYWdlUmVuZGVyaW5nUHJvZmlsZSkoKHJlbmRlcmluZykgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLiRlbmdpbmUudmlld3BvcnQuZHJhd0ltYWdlKHtcclxuICAgICAgICAgICAgICAgIHBvc2U6IHJlbmRlcmluZy4kZW50aXR5LiRjb3B5KFBvc2UpLFxyXG4gICAgICAgICAgICAgICAgcmVuZGVyaW5nOiByZW5kZXJpbmcuY29weSgpLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICcuLi9hYnN0cmFjdHMvU3lzdGVtJztcclxuaW1wb3J0IHsgSW50ZXJhY3RpdmUgfSBmcm9tICcuLi9lbnRpdGllcyc7XHJcblxyXG5leHBvcnQgY2xhc3MgSW50ZXJhY3RpdmVTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5lbnRpdGllcy5mb3JFdmVyeShJbnRlcmFjdGl2ZSkoKHRhcmdldCkgPT4ge1xyXG4gICAgICAgICAgICB0YXJnZXQuJG9uY2UoKTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxufVxyXG4iLCJpbXBvcnQgeyBTeXN0ZW0gfSBmcm9tICcuLi9hYnN0cmFjdHMvU3lzdGVtJztcclxuaW1wb3J0IHsgTGFiZWwsIFBvc2UgfSBmcm9tICcuLi9jb21wb25lbnRzJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIExhYmVsU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcclxuXHJcbiAgICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLiRlbmdpbmUuY29tcG9uZW50cy5mb3JFdmVyeShMYWJlbCkoKGxhYmVsKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3TGFiZWwoe1xyXG4gICAgICAgICAgICAgICAgcG9zZTogbGFiZWwuJGVudGl0eS4kY29weShQb3NlKSxcclxuICAgICAgICAgICAgICAgIGxhYmVsOiBsYWJlbC4kZW50aXR5LiRjb3B5KExhYmVsKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnLi4vYWJzdHJhY3RzL1N5c3RlbSc7XHJcbmltcG9ydCB7IFBvc2UsIFBvc2VTdGVwcGVyQ29tcG9uZW50IH0gZnJvbSAnLi4vY29tcG9uZW50cyc7XHJcblxyXG5leHBvcnQgY2xhc3MgUG9zZVN0ZXBwZXJTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuJGVuZ2luZS5jb21wb25lbnRzLmZvckV2ZXJ5KFBvc2VTdGVwcGVyQ29tcG9uZW50KSgoc3RlcHBlcikgPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBzdGVwID0gc3RlcHBlci5jb3B5KCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHBvc2UgPSBzdGVwcGVyLiRlbnRpdHkuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgICAgIHN0ZXBwZXIuJGVudGl0eS4kbXV0YXRlKFBvc2UpKHtcclxuICAgICAgICAgICAgICAgIHg6IHBvc2UueCArIHN0ZXAueCxcclxuICAgICAgICAgICAgICAgIHk6IHBvc2UueSArIHN0ZXAueSxcclxuICAgICAgICAgICAgICAgIGE6IHBvc2UuYSArIHN0ZXAuYSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IHsgU3lzdGVtIH0gZnJvbSAnLi4vYWJzdHJhY3RzL1N5c3RlbSc7XHJcbmltcG9ydCB7IFBvc2UsIFNoYXBlLCBTaGFwZVJlbmRlcmluZ1Byb2ZpbGUgfSBmcm9tICcuLi9jb21wb25lbnRzJztcclxuaW1wb3J0IHsgdHJhbnNmb3JtU2hhcGUgfSBmcm9tICcuLi9nZW9tZXRyeSc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBTaGFwZVN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XHJcblxyXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy4kZW5naW5lLmNvbXBvbmVudHMuZm9yRXZlcnkoU2hhcGVSZW5kZXJpbmdQcm9maWxlKSgocmVuZGVyaW5nKSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IHNoYXBlID0gcmVuZGVyaW5nLiRlbnRpdHkuJGNvcHkoU2hhcGUpO1xyXG4gICAgICAgICAgICBjb25zdCBwb3NlID0gcmVuZGVyaW5nLiRlbnRpdHkuJGNvcHkoUG9zZSk7XHJcbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3U2hhcGUoe1xyXG4gICAgICAgICAgICAgICAgc2hhcGU6IHRyYW5zZm9ybVNoYXBlKHNoYXBlLCBwb3NlKSxcclxuICAgICAgICAgICAgICAgIHJlbmRlcmluZzogcmVuZGVyaW5nLmNvcHkoKSxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcbn1cclxuIiwiaW1wb3J0IElVbmlxdWUgZnJvbSAnLi4vaW50ZXJmYWNlcy9JVW5pcXVlJztcclxuXHJcbmNvbnN0IHV1aWR2MSA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFVuaXF1ZSBpbXBsZW1lbnRzIElVbmlxdWUge1xyXG5cclxuICAgIGdldCBpZCgpOiBzdHJpbmcge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9faWQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHN0YXRpYyBnZW5lcmF0ZVV1aWQoKTogc3RyaW5nIHtcclxuICAgICAgICByZXR1cm4gdXVpZHYxKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHJpdmF0ZSBfX2lkOiBzdHJpbmc7XHJcblxyXG4gICAgY29uc3RydWN0b3IoaWQ/OiBzdHJpbmcpIHtcclxuICAgICAgICB0aGlzLl9faWQgPSBpZCB8fCBVbmlxdWUuZ2VuZXJhdGVVdWlkKCk7XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBJV3JhcHBlciBmcm9tICcuLi9pbnRlcmZhY2VzL0lXcmFwcGVyJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFdyYXBwZXI8VCBleHRlbmRzIHt9PiBpbXBsZW1lbnRzIElXcmFwcGVyPFQ+IHtcclxuXHJcbiAgICBwcml2YXRlIF9fdGFyZ2V0OiBUO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKHRhcmdldDogVCkge1xyXG4gICAgICAgIHRoaXMuX190YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHVud3JhcCgpOiBUIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fX3RhcmdldDtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IElEaWN0aW9uYXJ5IGZyb20gJy4uL2ludGVyZmFjZXMvSURpY3Rpb25hcnknO1xyXG5pbXBvcnQgV3JhcHBlciBmcm9tICcuLi9hYnN0cmFjdHMvV3JhcHBlcic7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBEaWN0aW9uYXJ5PFQgZXh0ZW5kcyBvYmplY3Q+IGV4dGVuZHMgV3JhcHBlcjx7IFtrZXk6IHN0cmluZ106IFQgfT4gaW1wbGVtZW50cyBJRGljdGlvbmFyeTxUPiB7XHJcblxyXG4gICAgY29uc3RydWN0b3IoKSB7XHJcbiAgICAgICAgc3VwZXIoe30pO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMudW53cmFwKCkpLmxlbmd0aDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgcmVhZChrZXk6IHN0cmluZyk6IFQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHdyaXRlKHsga2V5LCB2YWx1ZSB9OiB7IGtleTogc3RyaW5nLCB2YWx1ZTogVCB9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51bndyYXAoKVtrZXldID0gdmFsdWU7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLnVud3JhcCgpW2tleV07XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZvckVhY2goZm46ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMudW53cmFwKCkpLmZvckVhY2goKGtleSkgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy51bndyYXAoKVtrZXldKSB7XHJcbiAgICAgICAgICAgICAgICBmbih0aGlzLnVud3JhcCgpW2tleV0pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIHRvQXJyYXkoKTogVFtdIHtcclxuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy51bndyYXAoKSkubWFwKChrZXkpID0+IHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMudW53cmFwKClba2V5XTtcclxuICAgICAgICB9KS5maWx0ZXIoKHRhcmdldCkgPT4gdGFyZ2V0ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0ICE9PSBudWxsKTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IERpY3Rpb25hcnkgZnJvbSAnLi9EaWN0aW9uYXJ5JztcclxuaW1wb3J0IElEaWN0aW9uYXJ5IGZyb20gJy4uL2ludGVyZmFjZXMvSURpY3Rpb25hcnknO1xyXG5pbXBvcnQgSUZhY3RvcnkgZnJvbSAnLi4vaW50ZXJmYWNlcy9JRmFjdG9yeSc7XHJcbmltcG9ydCBJVW5pcXVlIGZyb20gJy4uL2ludGVyZmFjZXMvSVVuaXF1ZSc7XHJcbmltcG9ydCBXcmFwcGVyIGZyb20gJy4uL2Fic3RyYWN0cy9XcmFwcGVyJztcclxuaW1wb3J0IHsgQ3RvciwgT3B0aW9uYWwgfSBmcm9tICcuLi90eXBlcyc7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBGYWN0b3J5PFQgZXh0ZW5kcyBJVW5pcXVlPiBleHRlbmRzIFdyYXBwZXI8SURpY3Rpb25hcnk8VD4+IGltcGxlbWVudHMgSUZhY3Rvcnk8VD4ge1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKCkge1xyXG4gICAgICAgIHN1cGVyKG5ldyBEaWN0aW9uYXJ5PFQ+KCkpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBjcmVhdGU8VERhdGE+KEluc3RhbmNlQ3RvcjogQ3RvcjxULCBPcHRpb25hbDxURGF0YT4+LCBkYXRhPzogVERhdGEpOiBUIHtcclxuICAgICAgICBjb25zdCBpbnN0YW5jZSA9IG5ldyBJbnN0YW5jZUN0b3IoZGF0YSk7XHJcbiAgICAgICAgdGhpcy5hZGQoaW5zdGFuY2UpO1xyXG4gICAgICAgIHJldHVybiBpbnN0YW5jZTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgYWRkKGluc3RhbmNlOiBUKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy51bndyYXAoKS53cml0ZSh7XHJcbiAgICAgICAgICAgIGtleTogaW5zdGFuY2UuaWQsXHJcbiAgICAgICAgICAgIHZhbHVlOiBpbnN0YW5jZSxcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZGVzdHJveShpbnN0YW5jZTogVCk6IHZvaWQge1xyXG4gICAgICAgIHJldHVybiB0aGlzLnVud3JhcCgpLmRlbGV0ZShpbnN0YW5jZS5pZCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZvckVhY2goZm46ICh2YWx1ZTogVCkgPT4gdm9pZCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMudW53cmFwKCkuZm9yRWFjaChmbik7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZpcnN0KGZuOiAodmFsdWU6IFQpID0+IHZvaWQpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBmaXJzdCA9IE9iamVjdC5rZXlzKHRoaXMudW53cmFwKCkudW53cmFwKCkpLmZpbmQoKCkgPT4gdHJ1ZSk7XHJcbiAgICAgICAgaWYgKGZpcnN0KSB7XHJcbiAgICAgICAgICAgIGZuKHRoaXMudW53cmFwKCkudW53cmFwKClbZmlyc3RdKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGZpbmQoZm46ICh2YWx1ZTogVCkgPT4gYm9vbGVhbik6IFQgfCB1bmRlZmluZWQge1xyXG4gICAgICAgIGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyh0aGlzLnVud3JhcCgpLnVud3JhcCgpKTtcclxuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9IHRoaXMudW53cmFwKCkudW53cmFwKClba2V5XTtcclxuICAgICAgICAgICAgaWYgKGZuKHRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG59XHJcbiIsImltcG9ydCBJQWRhcHRlZEtleWJvYXJkRXZlbnQgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRLZXlib2FyZEV2ZW50JztcclxuaW1wb3J0IElLZXlib2FyZEFkYXB0b3IgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUtleWJvYXJkQWRhcHRvcic7XHJcbmltcG9ydCBJS2V5Ym9hcmRIYW5kbGVyIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lLZXlib2FyZEhhbmRsZXInO1xyXG5pbXBvcnQgS2V5Ym9hcmRIYW5kbGVyIGZyb20gJy4uL2VuZ2luZS9LZXlib2FyZEhhbmRsZXInO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRNTDVDYW52YXNLZXlib2FyZEFkYXB0ZXIgaW1wbGVtZW50cyBJS2V5Ym9hcmRBZGFwdG9yIHtcclxuXHJcbiAgICBwcml2YXRlIF9fY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudDtcclxuICAgIHByaXZhdGUgX19idWZmZXI6IElBZGFwdGVkS2V5Ym9hcmRFdmVudFtdO1xyXG4gICAgcHJpdmF0ZSBfX2hhbmRsZXI6IElLZXlib2FyZEhhbmRsZXI7XHJcblxyXG4gICAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCkge1xyXG4gICAgICAgIHRoaXMuX19jYW52YXMgPSBjYW52YXM7XHJcbiAgICAgICAgdGhpcy5fX2J1ZmZlciA9IFtdO1xyXG4gICAgICAgIHRoaXMuX19oYW5kbGVyID0gbmV3IEtleWJvYXJkSGFuZGxlcigpO1xyXG4gICAgICAgIHRoaXMuX19iaW5kS2V5Ym9hcmRFdmVudHMoKTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcclxuICAgICAgICBjb25zdCBpbnB1dCA9IHRoaXMuX19idWZmZXIuc2hpZnQoKTtcclxuICAgICAgICBpZiAoaW5wdXQpIHtcclxuICAgICAgICAgICAgdGhpcy5fX2hhbmRsZXJbaW5wdXQubmFtZV0oaW5wdXQpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgaGFuZGxlcihoYW5kbGVyOiBJS2V5Ym9hcmRIYW5kbGVyKTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX2hhbmRsZXIgPSBoYW5kbGVyO1xyXG4gICAgfVxyXG5cclxuICAgIHByaXZhdGUgX19iaW5kS2V5Ym9hcmRFdmVudHMoKTogdm9pZCB7XHJcbiAgICAgICAgW1xyXG4gICAgICAgICAgICAna2V5ZG93bicsXHJcbiAgICAgICAgICAgICdrZXlwcmVzcycsXHJcbiAgICAgICAgICAgICdrZXl1cCcsXHJcbiAgICAgICAgXVxyXG4gICAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcclxuICAgICAgICAgICAgY29uc3QgY2FudmFzID0gKHRoaXMuX19jYW52YXMgYXMgdW5rbm93biBhcyB7IFtrZXk6IHN0cmluZ106IChrZTogS2V5Ym9hcmRFdmVudCkgPT4gdm9pZCB9KTtcclxuICAgICAgICAgICAgY2FudmFzW2BvbiR7a2V5fWBdID0gKGtlOiBLZXlib2FyZEV2ZW50KTogdm9pZCA9PiB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYnVmZmVyLnB1c2goe1xyXG4gICAgICAgICAgICAgICAgICAgIG5hbWU6IGtleSxcclxuICAgICAgICAgICAgICAgICAgICBrZXk6IGtlLmtleSxcclxuICAgICAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxufVxyXG4iLCJpbXBvcnQgSUFkYXB0ZWRNb3VzZUV2ZW50IGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lBZGFwdGVkTW91c2VFdmVudCc7XHJcbmltcG9ydCBJTW91c2VBZGFwdG9yIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lNb3VzZUFkYXB0b3InO1xyXG5pbXBvcnQgSU1vdXNlSGFuZGxlciBmcm9tICcuLi9lbmdpbmUvaW50ZXJmYWNlcy9JTW91c2VIYW5kbGVyJztcclxuXHJcbmNvbnN0IF9fZGVmYXVsdEhhbmRsZXIgPSB7XHJcbiAgICBtb3VzZWVudGVyOiAobW91c2VFdmVudDogSUFkYXB0ZWRNb3VzZUV2ZW50KSA9PiB1bmRlZmluZWQsXHJcbiAgICBtb3VzZW1vdmU6IChtb3VzZUV2ZW50OiBJQWRhcHRlZE1vdXNlRXZlbnQpID0+IHVuZGVmaW5lZCxcclxuICAgIG1vdXNlbGVhdmU6IChtb3VzZUV2ZW50OiBJQWRhcHRlZE1vdXNlRXZlbnQpID0+IHVuZGVmaW5lZCxcclxuICAgIG1vdXNlZG93bjogKG1vdXNlRXZlbnQ6IElBZGFwdGVkTW91c2VFdmVudCkgPT4gdW5kZWZpbmVkLFxyXG4gICAgbW91c2V1cDogKG1vdXNlRXZlbnQ6IElBZGFwdGVkTW91c2VFdmVudCkgPT4gdW5kZWZpbmVkLFxyXG4gICAgY2xpY2s6IChtb3VzZUV2ZW50OiBJQWRhcHRlZE1vdXNlRXZlbnQpID0+IHVuZGVmaW5lZCxcclxuICAgIG5vbmU6ICgpID0+IHVuZGVmaW5lZCxcclxufTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhUTUw1Q2FudmFzTW91c2VBZGFwdG9yIGltcGxlbWVudHMgSU1vdXNlQWRhcHRvciB7XHJcblxyXG4gICAgcHJpdmF0ZSBfX2NhbnZhczogSFRNTENhbnZhc0VsZW1lbnQ7XHJcbiAgICBwcml2YXRlIF9fYnVmZmVyOiBJQWRhcHRlZE1vdXNlRXZlbnRbXTtcclxuICAgIHByaXZhdGUgX19oYW5kbGVyOiBJTW91c2VIYW5kbGVyO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLl9fY2FudmFzID0gY2FudmFzO1xyXG4gICAgICAgIHRoaXMuX19idWZmZXIgPSBbXTtcclxuICAgICAgICB0aGlzLl9faGFuZGxlciA9IF9fZGVmYXVsdEhhbmRsZXI7XHJcbiAgICAgICAgdGhpcy5fX2JpbmRNb3VzZUV2ZW50cygpO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xyXG4gICAgICAgIGNvbnN0IGV2ZW50ID0gdGhpcy5fX2J1ZmZlci5zaGlmdCgpO1xyXG4gICAgICAgIGlmIChldmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9faGFuZGxlcltldmVudC5uYW1lXShldmVudCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fX2hhbmRsZXIubm9uZSh7XHJcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICB4OiAwLFxyXG4gICAgICAgICAgICAgICAgeTogMCxcclxuICAgICAgICAgICAgICAgIGlzQ3RybERvd246IGZhbHNlLFxyXG4gICAgICAgICAgICAgICAgaXNTaGlmdERvd246IGZhbHNlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGhhbmRsZXIoaGFuZGxlcjogSU1vdXNlSGFuZGxlcik6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX19oYW5kbGVyID0gaGFuZGxlcjtcclxuICAgIH1cclxuXHJcbiAgICBwcml2YXRlIF9fYmluZE1vdXNlRXZlbnRzKCk6IHZvaWQge1xyXG4gICAgICAgIFtcclxuICAgICAgICAgICAgJ21vdXNlZW50ZXInLFxyXG4gICAgICAgICAgICAnbW91c2Vtb3ZlJyxcclxuICAgICAgICAgICAgJ21vdXNlbGVhdmUnLFxyXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcclxuICAgICAgICAgICAgJ21vdXNldXAnLFxyXG4gICAgICAgICAgICAnY2xpY2snLFxyXG4gICAgICAgIF1cclxuICAgICAgICAuZm9yRWFjaCgoa2V5KSA9PiB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9ICh0aGlzLl9fY2FudmFzIGFzIHVua25vd24gYXMgeyBba2V5OiBzdHJpbmddOiAoZXY6IE1vdXNlRXZlbnQpID0+IHZvaWQgfSk7XHJcbiAgICAgICAgICAgIGNhbnZhc1tgb24ke2tleX1gXSA9IChldjogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xyXG4gICAgICAgICAgICAgICAgY29uc3QgYm91bmRpbmdDbGllbnRSZWN0ID0gdGhpcy5fX2NhbnZhcy5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19idWZmZXIucHVzaCh7XHJcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZXYudHlwZSxcclxuICAgICAgICAgICAgICAgICAgICB4OiBldi5jbGllbnRYIC0gYm91bmRpbmdDbGllbnRSZWN0LmxlZnQsXHJcbiAgICAgICAgICAgICAgICAgICAgeTogZXYuY2xpZW50WSAtIGJvdW5kaW5nQ2xpZW50UmVjdC50b3AsXHJcbiAgICAgICAgICAgICAgICAgICAgaXNDdHJsRG93bjogZXYuY3RybEtleSxcclxuICAgICAgICAgICAgICAgICAgICBpc1NoaWZ0RG93bjogZXYuc2hpZnRLZXksXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9KTtcclxuICAgIH1cclxuXHJcbn1cclxuIiwiaW1wb3J0IElWaWV3cG9ydEFkYXB0b3IgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSVZpZXdwb3J0QWRhcHRvcic7XHJcbmltcG9ydCB7IElJbWFnZVJlbmRlcmluZ1Byb2ZpbGUsIElMYWJlbCwgSVBvaW50LCBJUG9zZSwgSVNoYXBlLCBJU2hhcGVSZW5kZXJpbmdQcm9maWxlIH0gZnJvbSAnLi4vZW5naW5lL2NvbXBvbmVudHMnO1xyXG5cclxuZnVuY3Rpb24gQXRvbWljKHRhcmdldDogSFRNTDVDYW52YXNWaWV3cG9ydEFkYXB0b3IsIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpOiB2b2lkIHtcclxuICAgIGNvbnN0IGZuID0gZGVzY3JpcHRvci52YWx1ZTtcclxuICAgIGRlc2NyaXB0b3IudmFsdWUgPSBmdW5jdGlvbigpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XHJcbiAgICAgICAgZm4uY2FsbCh0aGlzLCAuLi5hcmd1bWVudHMpO1xyXG4gICAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcclxuICAgIH07XHJcbn1cclxuXHJcbmV4cG9ydCBjbGFzcyBIVE1MNUNhbnZhc1ZpZXdwb3J0QWRhcHRvciBpbXBsZW1lbnRzIElWaWV3cG9ydEFkYXB0b3Ige1xyXG5cclxuICAgIFtrZXk6IHN0cmluZ106IGFueTtcclxuXHJcbiAgICBwdWJsaWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XHJcbiAgICBwdWJsaWMgd2lkdGg6IG51bWJlcjtcclxuICAgIHB1YmxpYyBoZWlnaHQ6IG51bWJlcjtcclxuXHJcbiAgICBwcml2YXRlIF9faW1hZ2VCdWZmZXI6IHsgW2tleTogc3RyaW5nXTogSFRNTEltYWdlRWxlbWVudCB9ID0ge307XHJcblxyXG4gICAgcHJpdmF0ZSBfX3pCdWZmZXI6IEFycmF5PHsgbWV0aG9kOiBzdHJpbmcsIHBheWxvYWQ6IGFueSB9PiA9IFtdO1xyXG5cclxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcclxuICAgICAgICB0aGlzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xyXG4gICAgICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgbG9hZChzcmM6IHN0cmluZyk6IENhbnZhc0ltYWdlU291cmNlIHtcclxuICAgICAgICBpZiAoIXRoaXMuX19pbWFnZUJ1ZmZlcltzcmNdKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19pbWFnZUJ1ZmZlcltzcmNdID0gbmV3IEltYWdlKCk7XHJcbiAgICAgICAgICAgIHRoaXMuX19pbWFnZUJ1ZmZlcltzcmNdLnNyYyA9IHNyYztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pbWFnZUJ1ZmZlcltzcmNdO1xyXG4gICAgfVxyXG5cclxuICAgIHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIG9uY2UoKTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgekJ1ZmZlciA9IHRoaXMuX196QnVmZmVyLm1hcCgodGFyZ2V0KSA9PiB7XHJcbiAgICAgICAgICAgIGlmICghdGFyZ2V0LnBheWxvYWQucmVuZGVyaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQucGF5bG9hZC5yZW5kZXJpbmcgPSB7IHpJbmRleDogMCB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRhcmdldC5wYXlsb2FkLnJlbmRlcmluZy56SW5kZXgpIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldC5wYXlsb2FkLnJlbmRlcmluZy56SW5kZXggPSAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0O1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIGNvbnN0IHpPcmRlcmVkID0gekJ1ZmZlci5zb3J0KChhLCBiKSA9PiBhLnBheWxvYWQucmVuZGVyaW5nLnpJbmRleCAtIGIucGF5bG9hZC5yZW5kZXJpbmcuekluZGV4KTtcclxuICAgICAgICB6T3JkZXJlZC5mb3JFYWNoKCh0YXJnZXQpID0+IHtcclxuICAgICAgICAgICAgdGhpc1tgX18ke3RhcmdldC5tZXRob2R9YF0odGFyZ2V0LnBheWxvYWQpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHRoaXMuX196QnVmZmVyID0gW107XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdJbWFnZSh7IHBvc2UsIHJlbmRlcmluZyB9OiB7IHBvc2U6IElQb3NlLCByZW5kZXJpbmc6IElJbWFnZVJlbmRlcmluZ1Byb2ZpbGUgfSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX196QnVmZmVyLnB1c2goeyBtZXRob2Q6ICdkcmF3SW1hZ2UnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdTaGFwZSh7IHNoYXBlLCByZW5kZXJpbmcgfTogeyBzaGFwZTogSVNoYXBlLCByZW5kZXJpbmc6IElTaGFwZVJlbmRlcmluZ1Byb2ZpbGUgfSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX196QnVmZmVyLnB1c2goeyBtZXRob2Q6ICdkcmF3U2hhcGUnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcHVibGljIGRyYXdMaW5lKHsgcG9pbnRzLCByZW5kZXJpbmcgfTogeyBwb2ludHM6IElQb2ludFtdLCByZW5kZXJpbmc6IElTaGFwZVJlbmRlcmluZ1Byb2ZpbGUgfSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuX196QnVmZmVyLnB1c2goeyBtZXRob2Q6ICdkcmF3TGluZScsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0xhYmVsKHsgcG9zZSwgbGFiZWwgfTogeyBwb3NlOiBJUG9zZSwgbGFiZWw6IElMYWJlbCB9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5fX3pCdWZmZXIucHVzaCh7IG1ldGhvZDogJ2RyYXdMYWJlbCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBwdWJsaWMgZHJhd0NpcmNsZSh7IHBvaW50LCByYWRpdXMsIHJlbmRlcmluZyB9OiB7XHJcbiAgICAgICAgcG9pbnQ6IElQb2ludCwgcmFkaXVzOiBudW1iZXIsIHJlbmRlcmluZzogSVNoYXBlUmVuZGVyaW5nUHJvZmlsZSxcclxuICAgIH0pOiB2b2lkIHtcclxuICAgICAgICB0aGlzLl9fekJ1ZmZlci5wdXNoKHsgbWV0aG9kOiAnZHJhd0NpcmNsZScsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcclxuICAgIH1cclxuXHJcbiAgICBAQXRvbWljXHJcbiAgICBwcml2YXRlIF9fZHJhd0ltYWdlKHsgcG9zZSwgcmVuZGVyaW5nIH06IHsgcG9zZTogSVBvc2UsIHJlbmRlcmluZzogSUltYWdlUmVuZGVyaW5nUHJvZmlsZSB9KTogdm9pZCB7XHJcbiAgICAgICAgY29uc3QgaW1hZ2UgPSB0aGlzLmxvYWQocmVuZGVyaW5nLnNyYyk7XHJcbiAgICAgICAgdGhpcy5jdHgudHJhbnNsYXRlKHBvc2UueCwgcG9zZS55KTtcclxuICAgICAgICBpZiAocmVuZGVyaW5nLnJvdGF0ZSkge1xyXG4gICAgICAgICAgICB0aGlzLmN0eC5yb3RhdGUocmVuZGVyaW5nLnJvdGF0ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3R4LmRyYXdJbWFnZShcclxuICAgICAgICAgICAgaW1hZ2UsXHJcbiAgICAgICAgICAgIC0ocmVuZGVyaW5nLndpZHRoIHx8IGltYWdlLndpZHRoIGFzIG51bWJlcikgLyAyLFxyXG4gICAgICAgICAgICAtKHJlbmRlcmluZy5oZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IGFzIG51bWJlcikgLyAyLFxyXG4gICAgICAgICAgICByZW5kZXJpbmcud2lkdGggfHwgaW1hZ2Uud2lkdGggYXMgbnVtYmVyLFxyXG4gICAgICAgICAgICByZW5kZXJpbmcuaGVpZ2h0IHx8IGltYWdlLmhlaWdodCBhcyBudW1iZXIsXHJcbiAgICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBAQXRvbWljXHJcbiAgICBwcml2YXRlIF9fZHJhd1NoYXBlKHsgc2hhcGUsIHJlbmRlcmluZyB9OiB7IHNoYXBlOiBJU2hhcGUsIHJlbmRlcmluZzogSVNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9KTogdm9pZCB7XHJcbiAgICAgICAgaWYgKHJlbmRlcmluZy5vcGFjaXR5KSB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gcmVuZGVyaW5nLm9wYWNpdHk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVuZGVyaW5nLmNvbG91cjtcclxuICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgICBzaGFwZS5wb2ludHMuZm9yRWFjaCgocDogSVBvaW50KSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuY3R4LmxpbmVUbyhwLngsIHAueSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKHJlbmRlcmluZy5maWxsU3R5bGUpIHtcclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gcmVuZGVyaW5nLmZpbGxTdHlsZTtcclxuICAgICAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBAQXRvbWljXHJcbiAgICBwcml2YXRlIF9fZHJhd0xpbmUoeyBwb2ludHMsIHJlbmRlcmluZyB9OiB7IHBvaW50czogSVBvaW50W10sIHJlbmRlcmluZzogSVNoYXBlUmVuZGVyaW5nUHJvZmlsZSB9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdHguc3Ryb2tlU3R5bGUgPSByZW5kZXJpbmcuY29sb3VyO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHBvaW50cy5mb3JFYWNoKChwOiBJUG9pbnQpID0+IHtcclxuICAgICAgICAgICAgdGhpcy5jdHgubGluZVRvKHAueCwgcC55KTtcclxuICAgICAgICB9KTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbiAgICBAQXRvbWljXHJcbiAgICBwcml2YXRlIF9fZHJhd0xhYmVsKHsgcG9zZSwgbGFiZWwgfTogeyBwb3NlOiBJUG9zZSwgbGFiZWw6IElMYWJlbCB9KTogdm9pZCB7XHJcbiAgICAgICAgdGhpcy5jdHguZmlsbFN0eWxlID0gbGFiZWwuY29sb3VyIHx8ICd3aGl0ZSc7XHJcbiAgICAgICAgdGhpcy5jdHguZm9udCA9IGAke2xhYmVsLmZvbnRTaXplfXB4IEFyaWFsYDtcclxuICAgICAgICB0aGlzLmN0eC5maWxsVGV4dChsYWJlbC50ZXh0LCBwb3NlLnggKyBsYWJlbC5vZmZzZXQueCwgcG9zZS55ICsgbGFiZWwub2Zmc2V0LnkpO1xyXG4gICAgfVxyXG5cclxuICAgIEBBdG9taWNcclxuICAgIHByaXZhdGUgX19kcmF3Q2lyY2xlKHsgcG9pbnQsIHJhZGl1cywgcmVuZGVyaW5nIH06IHtcclxuICAgICAgICBwb2ludDogSVBvaW50LCByYWRpdXM6IG51bWJlciwgcmVuZGVyaW5nOiBJU2hhcGVSZW5kZXJpbmdQcm9maWxlLFxyXG4gICAgfSk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gcmVuZGVyaW5nLmNvbG91ciB8fCAnd2hpdGUnO1xyXG4gICAgICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xyXG4gICAgICAgIHRoaXMuY3R4LmFyYyhwb2ludC54LCBwb2ludC55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcclxuICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcclxuICAgIH1cclxuXHJcbn1cclxuIl0sInNvdXJjZVJvb3QiOiIifQ==