/******/ (function(modules) { // webpackBootstrap
/******/ 	function hotDisposeChunk(chunkId) {
/******/ 		delete installedChunks[chunkId];
/******/ 	}
/******/ 	var parentHotUpdateCallback = window["webpackHotUpdate"];
/******/ 	window["webpackHotUpdate"] = // eslint-disable-next-line no-unused-vars
/******/ 	function webpackHotUpdateCallback(chunkId, moreModules) {
/******/ 		hotAddUpdateChunk(chunkId, moreModules);
/******/ 		if (parentHotUpdateCallback) parentHotUpdateCallback(chunkId, moreModules);
/******/ 	} ;
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadUpdateChunk(chunkId) {
/******/ 		var script = document.createElement("script");
/******/ 		script.charset = "utf-8";
/******/ 		script.src = __webpack_require__.p + "" + chunkId + "." + hotCurrentHash + ".hot-update.js";
/******/ 		if (null) script.crossOrigin = null;
/******/ 		document.head.appendChild(script);
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotDownloadManifest(requestTimeout) {
/******/ 		requestTimeout = requestTimeout || 10000;
/******/ 		return new Promise(function(resolve, reject) {
/******/ 			if (typeof XMLHttpRequest === "undefined") {
/******/ 				return reject(new Error("No browser support"));
/******/ 			}
/******/ 			try {
/******/ 				var request = new XMLHttpRequest();
/******/ 				var requestPath = __webpack_require__.p + "" + hotCurrentHash + ".hot-update.json";
/******/ 				request.open("GET", requestPath, true);
/******/ 				request.timeout = requestTimeout;
/******/ 				request.send(null);
/******/ 			} catch (err) {
/******/ 				return reject(err);
/******/ 			}
/******/ 			request.onreadystatechange = function() {
/******/ 				if (request.readyState !== 4) return;
/******/ 				if (request.status === 0) {
/******/ 					// timeout
/******/ 					reject(
/******/ 						new Error("Manifest request to " + requestPath + " timed out.")
/******/ 					);
/******/ 				} else if (request.status === 404) {
/******/ 					// no update available
/******/ 					resolve();
/******/ 				} else if (request.status !== 200 && request.status !== 304) {
/******/ 					// other failure
/******/ 					reject(new Error("Manifest request to " + requestPath + " failed."));
/******/ 				} else {
/******/ 					// success
/******/ 					try {
/******/ 						var update = JSON.parse(request.responseText);
/******/ 					} catch (e) {
/******/ 						reject(e);
/******/ 						return;
/******/ 					}
/******/ 					resolve(update);
/******/ 				}
/******/ 			};
/******/ 		});
/******/ 	}
/******/
/******/ 	var hotApplyOnUpdate = true;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentHash = "8dcd6324c9ab601f7cb0";
/******/ 	var hotRequestTimeout = 10000;
/******/ 	var hotCurrentModuleData = {};
/******/ 	var hotCurrentChildModule;
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParents = [];
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	var hotCurrentParentsTemp = [];
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateRequire(moduleId) {
/******/ 		var me = installedModules[moduleId];
/******/ 		if (!me) return __webpack_require__;
/******/ 		var fn = function(request) {
/******/ 			if (me.hot.active) {
/******/ 				if (installedModules[request]) {
/******/ 					if (installedModules[request].parents.indexOf(moduleId) === -1) {
/******/ 						installedModules[request].parents.push(moduleId);
/******/ 					}
/******/ 				} else {
/******/ 					hotCurrentParents = [moduleId];
/******/ 					hotCurrentChildModule = request;
/******/ 				}
/******/ 				if (me.children.indexOf(request) === -1) {
/******/ 					me.children.push(request);
/******/ 				}
/******/ 			} else {
/******/ 				console.warn(
/******/ 					"[HMR] unexpected require(" +
/******/ 						request +
/******/ 						") from disposed module " +
/******/ 						moduleId
/******/ 				);
/******/ 				hotCurrentParents = [];
/******/ 			}
/******/ 			return __webpack_require__(request);
/******/ 		};
/******/ 		var ObjectFactory = function ObjectFactory(name) {
/******/ 			return {
/******/ 				configurable: true,
/******/ 				enumerable: true,
/******/ 				get: function() {
/******/ 					return __webpack_require__[name];
/******/ 				},
/******/ 				set: function(value) {
/******/ 					__webpack_require__[name] = value;
/******/ 				}
/******/ 			};
/******/ 		};
/******/ 		for (var name in __webpack_require__) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(__webpack_require__, name) &&
/******/ 				name !== "e" &&
/******/ 				name !== "t"
/******/ 			) {
/******/ 				Object.defineProperty(fn, name, ObjectFactory(name));
/******/ 			}
/******/ 		}
/******/ 		fn.e = function(chunkId) {
/******/ 			if (hotStatus === "ready") hotSetStatus("prepare");
/******/ 			hotChunksLoading++;
/******/ 			return __webpack_require__.e(chunkId).then(finishChunkLoading, function(err) {
/******/ 				finishChunkLoading();
/******/ 				throw err;
/******/ 			});
/******/
/******/ 			function finishChunkLoading() {
/******/ 				hotChunksLoading--;
/******/ 				if (hotStatus === "prepare") {
/******/ 					if (!hotWaitingFilesMap[chunkId]) {
/******/ 						hotEnsureUpdateChunk(chunkId);
/******/ 					}
/******/ 					if (hotChunksLoading === 0 && hotWaitingFiles === 0) {
/******/ 						hotUpdateDownloaded();
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 		fn.t = function(value, mode) {
/******/ 			if (mode & 1) value = fn(value);
/******/ 			return __webpack_require__.t(value, mode & ~1);
/******/ 		};
/******/ 		return fn;
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotCreateModule(moduleId) {
/******/ 		var hot = {
/******/ 			// private stuff
/******/ 			_acceptedDependencies: {},
/******/ 			_declinedDependencies: {},
/******/ 			_selfAccepted: false,
/******/ 			_selfDeclined: false,
/******/ 			_selfInvalidated: false,
/******/ 			_disposeHandlers: [],
/******/ 			_main: hotCurrentChildModule !== moduleId,
/******/
/******/ 			// Module API
/******/ 			active: true,
/******/ 			accept: function(dep, callback) {
/******/ 				if (dep === undefined) hot._selfAccepted = true;
/******/ 				else if (typeof dep === "function") hot._selfAccepted = dep;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._acceptedDependencies[dep[i]] = callback || function() {};
/******/ 				else hot._acceptedDependencies[dep] = callback || function() {};
/******/ 			},
/******/ 			decline: function(dep) {
/******/ 				if (dep === undefined) hot._selfDeclined = true;
/******/ 				else if (typeof dep === "object")
/******/ 					for (var i = 0; i < dep.length; i++)
/******/ 						hot._declinedDependencies[dep[i]] = true;
/******/ 				else hot._declinedDependencies[dep] = true;
/******/ 			},
/******/ 			dispose: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			addDisposeHandler: function(callback) {
/******/ 				hot._disposeHandlers.push(callback);
/******/ 			},
/******/ 			removeDisposeHandler: function(callback) {
/******/ 				var idx = hot._disposeHandlers.indexOf(callback);
/******/ 				if (idx >= 0) hot._disposeHandlers.splice(idx, 1);
/******/ 			},
/******/ 			invalidate: function() {
/******/ 				this._selfInvalidated = true;
/******/ 				switch (hotStatus) {
/******/ 					case "idle":
/******/ 						hotUpdate = {};
/******/ 						hotUpdate[moduleId] = modules[moduleId];
/******/ 						hotSetStatus("ready");
/******/ 						break;
/******/ 					case "ready":
/******/ 						hotApplyInvalidatedModule(moduleId);
/******/ 						break;
/******/ 					case "prepare":
/******/ 					case "check":
/******/ 					case "dispose":
/******/ 					case "apply":
/******/ 						(hotQueuedInvalidatedModules =
/******/ 							hotQueuedInvalidatedModules || []).push(moduleId);
/******/ 						break;
/******/ 					default:
/******/ 						// ignore requests in error states
/******/ 						break;
/******/ 				}
/******/ 			},
/******/
/******/ 			// Management API
/******/ 			check: hotCheck,
/******/ 			apply: hotApply,
/******/ 			status: function(l) {
/******/ 				if (!l) return hotStatus;
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			addStatusHandler: function(l) {
/******/ 				hotStatusHandlers.push(l);
/******/ 			},
/******/ 			removeStatusHandler: function(l) {
/******/ 				var idx = hotStatusHandlers.indexOf(l);
/******/ 				if (idx >= 0) hotStatusHandlers.splice(idx, 1);
/******/ 			},
/******/
/******/ 			//inherit from previous dispose call
/******/ 			data: hotCurrentModuleData[moduleId]
/******/ 		};
/******/ 		hotCurrentChildModule = undefined;
/******/ 		return hot;
/******/ 	}
/******/
/******/ 	var hotStatusHandlers = [];
/******/ 	var hotStatus = "idle";
/******/
/******/ 	function hotSetStatus(newStatus) {
/******/ 		hotStatus = newStatus;
/******/ 		for (var i = 0; i < hotStatusHandlers.length; i++)
/******/ 			hotStatusHandlers[i].call(null, newStatus);
/******/ 	}
/******/
/******/ 	// while downloading
/******/ 	var hotWaitingFiles = 0;
/******/ 	var hotChunksLoading = 0;
/******/ 	var hotWaitingFilesMap = {};
/******/ 	var hotRequestedFilesMap = {};
/******/ 	var hotAvailableFilesMap = {};
/******/ 	var hotDeferred;
/******/
/******/ 	// The update info
/******/ 	var hotUpdate, hotUpdateNewHash, hotQueuedInvalidatedModules;
/******/
/******/ 	function toModuleId(id) {
/******/ 		var isNumber = +id + "" === id;
/******/ 		return isNumber ? +id : id;
/******/ 	}
/******/
/******/ 	function hotCheck(apply) {
/******/ 		if (hotStatus !== "idle") {
/******/ 			throw new Error("check() is only allowed in idle status");
/******/ 		}
/******/ 		hotApplyOnUpdate = apply;
/******/ 		hotSetStatus("check");
/******/ 		return hotDownloadManifest(hotRequestTimeout).then(function(update) {
/******/ 			if (!update) {
/******/ 				hotSetStatus(hotApplyInvalidatedModules() ? "ready" : "idle");
/******/ 				return null;
/******/ 			}
/******/ 			hotRequestedFilesMap = {};
/******/ 			hotWaitingFilesMap = {};
/******/ 			hotAvailableFilesMap = update.c;
/******/ 			hotUpdateNewHash = update.h;
/******/
/******/ 			hotSetStatus("prepare");
/******/ 			var promise = new Promise(function(resolve, reject) {
/******/ 				hotDeferred = {
/******/ 					resolve: resolve,
/******/ 					reject: reject
/******/ 				};
/******/ 			});
/******/ 			hotUpdate = {};
/******/ 			var chunkId = "main";
/******/ 			// eslint-disable-next-line no-lone-blocks
/******/ 			{
/******/ 				hotEnsureUpdateChunk(chunkId);
/******/ 			}
/******/ 			if (
/******/ 				hotStatus === "prepare" &&
/******/ 				hotChunksLoading === 0 &&
/******/ 				hotWaitingFiles === 0
/******/ 			) {
/******/ 				hotUpdateDownloaded();
/******/ 			}
/******/ 			return promise;
/******/ 		});
/******/ 	}
/******/
/******/ 	// eslint-disable-next-line no-unused-vars
/******/ 	function hotAddUpdateChunk(chunkId, moreModules) {
/******/ 		if (!hotAvailableFilesMap[chunkId] || !hotRequestedFilesMap[chunkId])
/******/ 			return;
/******/ 		hotRequestedFilesMap[chunkId] = false;
/******/ 		for (var moduleId in moreModules) {
/******/ 			if (Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				hotUpdate[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if (--hotWaitingFiles === 0 && hotChunksLoading === 0) {
/******/ 			hotUpdateDownloaded();
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotEnsureUpdateChunk(chunkId) {
/******/ 		if (!hotAvailableFilesMap[chunkId]) {
/******/ 			hotWaitingFilesMap[chunkId] = true;
/******/ 		} else {
/******/ 			hotRequestedFilesMap[chunkId] = true;
/******/ 			hotWaitingFiles++;
/******/ 			hotDownloadUpdateChunk(chunkId);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotUpdateDownloaded() {
/******/ 		hotSetStatus("ready");
/******/ 		var deferred = hotDeferred;
/******/ 		hotDeferred = null;
/******/ 		if (!deferred) return;
/******/ 		if (hotApplyOnUpdate) {
/******/ 			// Wrap deferred object in Promise to mark it as a well-handled Promise to
/******/ 			// avoid triggering uncaught exception warning in Chrome.
/******/ 			// See https://bugs.chromium.org/p/chromium/issues/detail?id=465666
/******/ 			Promise.resolve()
/******/ 				.then(function() {
/******/ 					return hotApply(hotApplyOnUpdate);
/******/ 				})
/******/ 				.then(
/******/ 					function(result) {
/******/ 						deferred.resolve(result);
/******/ 					},
/******/ 					function(err) {
/******/ 						deferred.reject(err);
/******/ 					}
/******/ 				);
/******/ 		} else {
/******/ 			var outdatedModules = [];
/******/ 			for (var id in hotUpdate) {
/******/ 				if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 					outdatedModules.push(toModuleId(id));
/******/ 				}
/******/ 			}
/******/ 			deferred.resolve(outdatedModules);
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApply(options) {
/******/ 		if (hotStatus !== "ready")
/******/ 			throw new Error("apply() is only allowed in ready status");
/******/ 		options = options || {};
/******/ 		return hotApplyInternal(options);
/******/ 	}
/******/
/******/ 	function hotApplyInternal(options) {
/******/ 		hotApplyInvalidatedModules();
/******/
/******/ 		var cb;
/******/ 		var i;
/******/ 		var j;
/******/ 		var module;
/******/ 		var moduleId;
/******/
/******/ 		function getAffectedStuff(updateModuleId) {
/******/ 			var outdatedModules = [updateModuleId];
/******/ 			var outdatedDependencies = {};
/******/
/******/ 			var queue = outdatedModules.map(function(id) {
/******/ 				return {
/******/ 					chain: [id],
/******/ 					id: id
/******/ 				};
/******/ 			});
/******/ 			while (queue.length > 0) {
/******/ 				var queueItem = queue.pop();
/******/ 				var moduleId = queueItem.id;
/******/ 				var chain = queueItem.chain;
/******/ 				module = installedModules[moduleId];
/******/ 				if (
/******/ 					!module ||
/******/ 					(module.hot._selfAccepted && !module.hot._selfInvalidated)
/******/ 				)
/******/ 					continue;
/******/ 				if (module.hot._selfDeclined) {
/******/ 					return {
/******/ 						type: "self-declined",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				if (module.hot._main) {
/******/ 					return {
/******/ 						type: "unaccepted",
/******/ 						chain: chain,
/******/ 						moduleId: moduleId
/******/ 					};
/******/ 				}
/******/ 				for (var i = 0; i < module.parents.length; i++) {
/******/ 					var parentId = module.parents[i];
/******/ 					var parent = installedModules[parentId];
/******/ 					if (!parent) continue;
/******/ 					if (parent.hot._declinedDependencies[moduleId]) {
/******/ 						return {
/******/ 							type: "declined",
/******/ 							chain: chain.concat([parentId]),
/******/ 							moduleId: moduleId,
/******/ 							parentId: parentId
/******/ 						};
/******/ 					}
/******/ 					if (outdatedModules.indexOf(parentId) !== -1) continue;
/******/ 					if (parent.hot._acceptedDependencies[moduleId]) {
/******/ 						if (!outdatedDependencies[parentId])
/******/ 							outdatedDependencies[parentId] = [];
/******/ 						addAllToSet(outdatedDependencies[parentId], [moduleId]);
/******/ 						continue;
/******/ 					}
/******/ 					delete outdatedDependencies[parentId];
/******/ 					outdatedModules.push(parentId);
/******/ 					queue.push({
/******/ 						chain: chain.concat([parentId]),
/******/ 						id: parentId
/******/ 					});
/******/ 				}
/******/ 			}
/******/
/******/ 			return {
/******/ 				type: "accepted",
/******/ 				moduleId: updateModuleId,
/******/ 				outdatedModules: outdatedModules,
/******/ 				outdatedDependencies: outdatedDependencies
/******/ 			};
/******/ 		}
/******/
/******/ 		function addAllToSet(a, b) {
/******/ 			for (var i = 0; i < b.length; i++) {
/******/ 				var item = b[i];
/******/ 				if (a.indexOf(item) === -1) a.push(item);
/******/ 			}
/******/ 		}
/******/
/******/ 		// at begin all updates modules are outdated
/******/ 		// the "outdated" status can propagate to parents if they don't accept the children
/******/ 		var outdatedDependencies = {};
/******/ 		var outdatedModules = [];
/******/ 		var appliedUpdate = {};
/******/
/******/ 		var warnUnexpectedRequire = function warnUnexpectedRequire() {
/******/ 			console.warn(
/******/ 				"[HMR] unexpected require(" + result.moduleId + ") to disposed module"
/******/ 			);
/******/ 		};
/******/
/******/ 		for (var id in hotUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(hotUpdate, id)) {
/******/ 				moduleId = toModuleId(id);
/******/ 				/** @type {TODO} */
/******/ 				var result;
/******/ 				if (hotUpdate[id]) {
/******/ 					result = getAffectedStuff(moduleId);
/******/ 				} else {
/******/ 					result = {
/******/ 						type: "disposed",
/******/ 						moduleId: id
/******/ 					};
/******/ 				}
/******/ 				/** @type {Error|false} */
/******/ 				var abortError = false;
/******/ 				var doApply = false;
/******/ 				var doDispose = false;
/******/ 				var chainInfo = "";
/******/ 				if (result.chain) {
/******/ 					chainInfo = "\nUpdate propagation: " + result.chain.join(" -> ");
/******/ 				}
/******/ 				switch (result.type) {
/******/ 					case "self-declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of self decline: " +
/******/ 									result.moduleId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "declined":
/******/ 						if (options.onDeclined) options.onDeclined(result);
/******/ 						if (!options.ignoreDeclined)
/******/ 							abortError = new Error(
/******/ 								"Aborted because of declined dependency: " +
/******/ 									result.moduleId +
/******/ 									" in " +
/******/ 									result.parentId +
/******/ 									chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "unaccepted":
/******/ 						if (options.onUnaccepted) options.onUnaccepted(result);
/******/ 						if (!options.ignoreUnaccepted)
/******/ 							abortError = new Error(
/******/ 								"Aborted because " + moduleId + " is not accepted" + chainInfo
/******/ 							);
/******/ 						break;
/******/ 					case "accepted":
/******/ 						if (options.onAccepted) options.onAccepted(result);
/******/ 						doApply = true;
/******/ 						break;
/******/ 					case "disposed":
/******/ 						if (options.onDisposed) options.onDisposed(result);
/******/ 						doDispose = true;
/******/ 						break;
/******/ 					default:
/******/ 						throw new Error("Unexception type " + result.type);
/******/ 				}
/******/ 				if (abortError) {
/******/ 					hotSetStatus("abort");
/******/ 					return Promise.reject(abortError);
/******/ 				}
/******/ 				if (doApply) {
/******/ 					appliedUpdate[moduleId] = hotUpdate[moduleId];
/******/ 					addAllToSet(outdatedModules, result.outdatedModules);
/******/ 					for (moduleId in result.outdatedDependencies) {
/******/ 						if (
/******/ 							Object.prototype.hasOwnProperty.call(
/******/ 								result.outdatedDependencies,
/******/ 								moduleId
/******/ 							)
/******/ 						) {
/******/ 							if (!outdatedDependencies[moduleId])
/******/ 								outdatedDependencies[moduleId] = [];
/******/ 							addAllToSet(
/******/ 								outdatedDependencies[moduleId],
/******/ 								result.outdatedDependencies[moduleId]
/******/ 							);
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 				if (doDispose) {
/******/ 					addAllToSet(outdatedModules, [result.moduleId]);
/******/ 					appliedUpdate[moduleId] = warnUnexpectedRequire;
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Store self accepted outdated modules to require them later by the module system
/******/ 		var outdatedSelfAcceptedModules = [];
/******/ 		for (i = 0; i < outdatedModules.length; i++) {
/******/ 			moduleId = outdatedModules[i];
/******/ 			if (
/******/ 				installedModules[moduleId] &&
/******/ 				installedModules[moduleId].hot._selfAccepted &&
/******/ 				// removed self-accepted modules should not be required
/******/ 				appliedUpdate[moduleId] !== warnUnexpectedRequire &&
/******/ 				// when called invalidate self-accepting is not possible
/******/ 				!installedModules[moduleId].hot._selfInvalidated
/******/ 			) {
/******/ 				outdatedSelfAcceptedModules.push({
/******/ 					module: moduleId,
/******/ 					parents: installedModules[moduleId].parents.slice(),
/******/ 					errorHandler: installedModules[moduleId].hot._selfAccepted
/******/ 				});
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "dispose" phase
/******/ 		hotSetStatus("dispose");
/******/ 		Object.keys(hotAvailableFilesMap).forEach(function(chunkId) {
/******/ 			if (hotAvailableFilesMap[chunkId] === false) {
/******/ 				hotDisposeChunk(chunkId);
/******/ 			}
/******/ 		});
/******/
/******/ 		var idx;
/******/ 		var queue = outdatedModules.slice();
/******/ 		while (queue.length > 0) {
/******/ 			moduleId = queue.pop();
/******/ 			module = installedModules[moduleId];
/******/ 			if (!module) continue;
/******/
/******/ 			var data = {};
/******/
/******/ 			// Call dispose handlers
/******/ 			var disposeHandlers = module.hot._disposeHandlers;
/******/ 			for (j = 0; j < disposeHandlers.length; j++) {
/******/ 				cb = disposeHandlers[j];
/******/ 				cb(data);
/******/ 			}
/******/ 			hotCurrentModuleData[moduleId] = data;
/******/
/******/ 			// disable module (this disables requires from this module)
/******/ 			module.hot.active = false;
/******/
/******/ 			// remove module from cache
/******/ 			delete installedModules[moduleId];
/******/
/******/ 			// when disposing there is no need to call dispose handler
/******/ 			delete outdatedDependencies[moduleId];
/******/
/******/ 			// remove "parents" references from all children
/******/ 			for (j = 0; j < module.children.length; j++) {
/******/ 				var child = installedModules[module.children[j]];
/******/ 				if (!child) continue;
/******/ 				idx = child.parents.indexOf(moduleId);
/******/ 				if (idx >= 0) {
/******/ 					child.parents.splice(idx, 1);
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// remove outdated dependency from module children
/******/ 		var dependency;
/******/ 		var moduleOutdatedDependencies;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					for (j = 0; j < moduleOutdatedDependencies.length; j++) {
/******/ 						dependency = moduleOutdatedDependencies[j];
/******/ 						idx = module.children.indexOf(dependency);
/******/ 						if (idx >= 0) module.children.splice(idx, 1);
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Now in "apply" phase
/******/ 		hotSetStatus("apply");
/******/
/******/ 		if (hotUpdateNewHash !== undefined) {
/******/ 			hotCurrentHash = hotUpdateNewHash;
/******/ 			hotUpdateNewHash = undefined;
/******/ 		}
/******/ 		hotUpdate = undefined;
/******/
/******/ 		// insert new code
/******/ 		for (moduleId in appliedUpdate) {
/******/ 			if (Object.prototype.hasOwnProperty.call(appliedUpdate, moduleId)) {
/******/ 				modules[moduleId] = appliedUpdate[moduleId];
/******/ 			}
/******/ 		}
/******/
/******/ 		// call accept handlers
/******/ 		var error = null;
/******/ 		for (moduleId in outdatedDependencies) {
/******/ 			if (
/******/ 				Object.prototype.hasOwnProperty.call(outdatedDependencies, moduleId)
/******/ 			) {
/******/ 				module = installedModules[moduleId];
/******/ 				if (module) {
/******/ 					moduleOutdatedDependencies = outdatedDependencies[moduleId];
/******/ 					var callbacks = [];
/******/ 					for (i = 0; i < moduleOutdatedDependencies.length; i++) {
/******/ 						dependency = moduleOutdatedDependencies[i];
/******/ 						cb = module.hot._acceptedDependencies[dependency];
/******/ 						if (cb) {
/******/ 							if (callbacks.indexOf(cb) !== -1) continue;
/******/ 							callbacks.push(cb);
/******/ 						}
/******/ 					}
/******/ 					for (i = 0; i < callbacks.length; i++) {
/******/ 						cb = callbacks[i];
/******/ 						try {
/******/ 							cb(moduleOutdatedDependencies);
/******/ 						} catch (err) {
/******/ 							if (options.onErrored) {
/******/ 								options.onErrored({
/******/ 									type: "accept-errored",
/******/ 									moduleId: moduleId,
/******/ 									dependencyId: moduleOutdatedDependencies[i],
/******/ 									error: err
/******/ 								});
/******/ 							}
/******/ 							if (!options.ignoreErrored) {
/******/ 								if (!error) error = err;
/******/ 							}
/******/ 						}
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// Load self accepted modules
/******/ 		for (i = 0; i < outdatedSelfAcceptedModules.length; i++) {
/******/ 			var item = outdatedSelfAcceptedModules[i];
/******/ 			moduleId = item.module;
/******/ 			hotCurrentParents = item.parents;
/******/ 			hotCurrentChildModule = moduleId;
/******/ 			try {
/******/ 				__webpack_require__(moduleId);
/******/ 			} catch (err) {
/******/ 				if (typeof item.errorHandler === "function") {
/******/ 					try {
/******/ 						item.errorHandler(err);
/******/ 					} catch (err2) {
/******/ 						if (options.onErrored) {
/******/ 							options.onErrored({
/******/ 								type: "self-accept-error-handler-errored",
/******/ 								moduleId: moduleId,
/******/ 								error: err2,
/******/ 								originalError: err
/******/ 							});
/******/ 						}
/******/ 						if (!options.ignoreErrored) {
/******/ 							if (!error) error = err2;
/******/ 						}
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				} else {
/******/ 					if (options.onErrored) {
/******/ 						options.onErrored({
/******/ 							type: "self-accept-errored",
/******/ 							moduleId: moduleId,
/******/ 							error: err
/******/ 						});
/******/ 					}
/******/ 					if (!options.ignoreErrored) {
/******/ 						if (!error) error = err;
/******/ 					}
/******/ 				}
/******/ 			}
/******/ 		}
/******/
/******/ 		// handle errors in accept handlers and self accepted module load
/******/ 		if (error) {
/******/ 			hotSetStatus("fail");
/******/ 			return Promise.reject(error);
/******/ 		}
/******/
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			return hotApplyInternal(options).then(function(list) {
/******/ 				outdatedModules.forEach(function(moduleId) {
/******/ 					if (list.indexOf(moduleId) < 0) list.push(moduleId);
/******/ 				});
/******/ 				return list;
/******/ 			});
/******/ 		}
/******/
/******/ 		hotSetStatus("idle");
/******/ 		return new Promise(function(resolve) {
/******/ 			resolve(outdatedModules);
/******/ 		});
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModules() {
/******/ 		if (hotQueuedInvalidatedModules) {
/******/ 			if (!hotUpdate) hotUpdate = {};
/******/ 			hotQueuedInvalidatedModules.forEach(hotApplyInvalidatedModule);
/******/ 			hotQueuedInvalidatedModules = undefined;
/******/ 			return true;
/******/ 		}
/******/ 	}
/******/
/******/ 	function hotApplyInvalidatedModule(moduleId) {
/******/ 		if (!Object.prototype.hasOwnProperty.call(hotUpdate, moduleId))
/******/ 			hotUpdate[moduleId] = modules[moduleId];
/******/ 	}
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {},
/******/ 			hot: hotCreateModule(moduleId),
/******/ 			parents: (hotCurrentParentsTemp = hotCurrentParents, hotCurrentParents = [], hotCurrentParentsTemp),
/******/ 			children: []
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, hotCreateRequire(moduleId));
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// __webpack_hash__
/******/ 	__webpack_require__.h = function() { return hotCurrentHash; };
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return hotCreateRequire("./src/app/main.ts")(__webpack_require__.s = "./src/app/main.ts");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/@turf/bbox/index.js":
/*!******************************************!*\
  !*** ./node_modules/@turf/bbox/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {GeoJSON} geojson any GeoJSON object
 * @returns {BBox} bbox extent in [minX, minY, maxX, maxY] order
 * @example
 * var line = turf.lineString([[-74, 40], [-78, 42], [-82, 35]]);
 * var bbox = turf.bbox(line);
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * //addToMap
 * var addToMap = [line, bboxPolygon]
 */
function bbox(geojson) {
    var result = [Infinity, Infinity, -Infinity, -Infinity];
    meta_1.coordEach(geojson, function (coord) {
        if (result[0] > coord[0]) {
            result[0] = coord[0];
        }
        if (result[1] > coord[1]) {
            result[1] = coord[1];
        }
        if (result[2] < coord[0]) {
            result[2] = coord[0];
        }
        if (result[3] < coord[1]) {
            result[3] = coord[1];
        }
    });
    return result;
}
exports.default = bbox;


/***/ }),

/***/ "./node_modules/@turf/bearing/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@turf/bearing/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Takes two {@link Point|points} and finds the geographic bearing between them,
 * i.e. the angle measured in degrees from the north line (0 degrees)
 *
 * @name bearing
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.final=false] calculates the final bearing if true
 * @returns {number} bearing in decimal degrees, between -180 and 180 degrees (positive clockwise)
 * @example
 * var point1 = turf.point([-75.343, 39.984]);
 * var point2 = turf.point([-75.534, 39.123]);
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //addToMap
 * var addToMap = [point1, point2]
 * point1.properties['marker-color'] = '#f00'
 * point2.properties['marker-color'] = '#0f0'
 * point1.properties.bearing = bearing
 */
function bearing(start, end, options) {
    if (options === void 0) { options = {}; }
    // Reverse calculation
    if (options.final === true) {
        return calculateFinalBearing(start, end);
    }
    var coordinates1 = invariant_1.getCoord(start);
    var coordinates2 = invariant_1.getCoord(end);
    var lon1 = helpers_1.degreesToRadians(coordinates1[0]);
    var lon2 = helpers_1.degreesToRadians(coordinates2[0]);
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);
    return helpers_1.radiansToDegrees(Math.atan2(a, b));
}
/**
 * Calculates Final Bearing
 *
 * @private
 * @param {Coord} start starting Point
 * @param {Coord} end ending Point
 * @returns {number} bearing
 */
function calculateFinalBearing(start, end) {
    // Swap start & end
    var bear = bearing(end, start);
    bear = (bear + 180) % 360;
    return bear;
}
exports.default = bearing;


/***/ }),

/***/ "./node_modules/@turf/boolean-contains/index.js":
/*!******************************************************!*\
  !*** ./node_modules/@turf/boolean-contains/index.js ***!
  \******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
var bbox_1 = __importDefault(__webpack_require__(/*! @turf/bbox */ "./node_modules/@turf/bbox/index.js"));
var boolean_point_in_polygon_1 = __importDefault(__webpack_require__(/*! @turf/boolean-point-in-polygon */ "./node_modules/@turf/boolean-point-in-polygon/index.js"));
var boolean_point_on_line_1 = __importDefault(__webpack_require__(/*! @turf/boolean-point-on-line */ "./node_modules/@turf/boolean-point-on-line/index.js"));
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Boolean-contains returns True if the second geometry is completely contained by the first geometry.
 * The interiors of both geometries must intersect and, the interior and boundary of the secondary (geometry b)
 * must not intersect the exterior of the primary (geometry a).
 * Boolean-contains returns the exact opposite result of the `@turf/boolean-within`.
 *
 * @name booleanContains
 * @param {Geometry|Feature<any>} feature1 GeoJSON Feature or Geometry
 * @param {Geometry|Feature<any>} feature2 GeoJSON Feature or Geometry
 * @returns {boolean} true/false
 * @example
 * var line = turf.lineString([[1, 1], [1, 2], [1, 3], [1, 4]]);
 * var point = turf.point([1, 2]);
 *
 * turf.booleanContains(line, point);
 * //=true
 */
function booleanContains(feature1, feature2) {
    var geom1 = invariant_1.getGeom(feature1);
    var geom2 = invariant_1.getGeom(feature2);
    var type1 = invariant_1.getType(feature1);
    var type2 = invariant_1.getType(feature2);
    var coords1 = invariant_1.getCoords(feature1);
    var coords2 = invariant_1.getCoords(feature2);
    switch (type1) {
        case "Point":
            switch (type2) {
                case "Point":
                    return compareCoords(coords1, coords2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "MultiPoint":
            switch (type2) {
                case "Point":
                    return isPointInMultiPoint(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInMultiPoint(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "LineString":
            switch (type2) {
                case "Point":
                    return boolean_point_on_line_1.default(geom2, geom1, { ignoreEndVertices: true });
                case "LineString":
                    return isLineOnLine(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointOnLine(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        case "Polygon":
            switch (type2) {
                case "Point":
                    return boolean_point_in_polygon_1.default(geom2, geom1, { ignoreBoundary: true });
                case "LineString":
                    return isLineInPoly(geom1, geom2);
                case "Polygon":
                    return isPolyInPoly(geom1, geom2);
                case "MultiPoint":
                    return isMultiPointInPoly(geom1, geom2);
                default:
                    throw new Error("feature2 " + type2 + " geometry not supported");
            }
        default:
            throw new Error("feature1 " + type1 + " geometry not supported");
    }
}
exports.default = booleanContains;
function isPointInMultiPoint(multiPoint, pt) {
    var i;
    var output = false;
    for (i = 0; i < multiPoint.coordinates.length; i++) {
        if (compareCoords(multiPoint.coordinates[i], pt.coordinates)) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isPointInMultiPoint = isPointInMultiPoint;
function isMultiPointInMultiPoint(multiPoint1, multiPoint2) {
    for (var _i = 0, _a = multiPoint2.coordinates; _i < _a.length; _i++) {
        var coord2 = _a[_i];
        var matchFound = false;
        for (var _b = 0, _c = multiPoint1.coordinates; _b < _c.length; _b++) {
            var coord1 = _c[_b];
            if (compareCoords(coord2, coord1)) {
                matchFound = true;
                break;
            }
        }
        if (!matchFound) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInMultiPoint = isMultiPointInMultiPoint;
function isMultiPointOnLine(lineString, multiPoint) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (boolean_point_on_line_1.default(coord, lineString, { ignoreEndVertices: true })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default(coord, lineString)) {
            return false;
        }
    }
    if (haveFoundInteriorPoint) {
        return true;
    }
    return false;
}
exports.isMultiPointOnLine = isMultiPointOnLine;
function isMultiPointInPoly(polygon, multiPoint) {
    for (var _i = 0, _a = multiPoint.coordinates; _i < _a.length; _i++) {
        var coord = _a[_i];
        if (!boolean_point_in_polygon_1.default(coord, polygon, { ignoreBoundary: true })) {
            return false;
        }
    }
    return true;
}
exports.isMultiPointInPoly = isMultiPointInPoly;
function isLineOnLine(lineString1, lineString2) {
    var haveFoundInteriorPoint = false;
    for (var _i = 0, _a = lineString2.coordinates; _i < _a.length; _i++) {
        var coords = _a[_i];
        if (boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, { ignoreEndVertices: true })) {
            haveFoundInteriorPoint = true;
        }
        if (!boolean_point_on_line_1.default({ type: "Point", coordinates: coords }, lineString1, { ignoreEndVertices: false })) {
            return false;
        }
    }
    return haveFoundInteriorPoint;
}
exports.isLineOnLine = isLineOnLine;
function isLineInPoly(polygon, linestring) {
    var output = false;
    var i = 0;
    var polyBbox = bbox_1.default(polygon);
    var lineBbox = bbox_1.default(linestring);
    if (!doBBoxOverlap(polyBbox, lineBbox)) {
        return false;
    }
    for (i; i < linestring.coordinates.length - 1; i++) {
        var midPoint = getMidpoint(linestring.coordinates[i], linestring.coordinates[i + 1]);
        if (boolean_point_in_polygon_1.default({ type: "Point", coordinates: midPoint }, polygon, { ignoreBoundary: true })) {
            output = true;
            break;
        }
    }
    return output;
}
exports.isLineInPoly = isLineInPoly;
/**
 * Is Polygon2 in Polygon1
 * Only takes into account outer rings
 *
 * @private
 * @param {Geometry|Feature<Polygon>} feature1 Polygon1
 * @param {Geometry|Feature<Polygon>} feature2 Polygon2
 * @returns {boolean} true/false
 */
function isPolyInPoly(feature1, feature2) {
    // Handle Nulls
    if (feature1.type === "Feature" && feature1.geometry === null) {
        return false;
    }
    if (feature2.type === "Feature" && feature2.geometry === null) {
        return false;
    }
    var poly1Bbox = bbox_1.default(feature1);
    var poly2Bbox = bbox_1.default(feature2);
    if (!doBBoxOverlap(poly1Bbox, poly2Bbox)) {
        return false;
    }
    var coords = invariant_1.getGeom(feature2).coordinates;
    for (var _i = 0, coords_1 = coords; _i < coords_1.length; _i++) {
        var ring = coords_1[_i];
        for (var _a = 0, ring_1 = ring; _a < ring_1.length; _a++) {
            var coord = ring_1[_a];
            if (!boolean_point_in_polygon_1.default(coord, feature1)) {
                return false;
            }
        }
    }
    return true;
}
exports.isPolyInPoly = isPolyInPoly;
function doBBoxOverlap(bbox1, bbox2) {
    if (bbox1[0] > bbox2[0]) {
        return false;
    }
    if (bbox1[2] < bbox2[2]) {
        return false;
    }
    if (bbox1[1] > bbox2[1]) {
        return false;
    }
    if (bbox1[3] < bbox2[3]) {
        return false;
    }
    return true;
}
exports.doBBoxOverlap = doBBoxOverlap;
/**
 * compareCoords
 *
 * @private
 * @param {Position} pair1 point [x,y]
 * @param {Position} pair2 point [x,y]
 * @returns {boolean} true/false if coord pairs match
 */
function compareCoords(pair1, pair2) {
    return pair1[0] === pair2[0] && pair1[1] === pair2[1];
}
exports.compareCoords = compareCoords;
function getMidpoint(pair1, pair2) {
    return [(pair1[0] + pair2[0]) / 2, (pair1[1] + pair2[1]) / 2];
}
exports.getMidpoint = getMidpoint;


/***/ }),

/***/ "./node_modules/@turf/boolean-overlap/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@turf/boolean-overlap/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var line_overlap_1 = __webpack_require__(/*! @turf/line-overlap */ "./node_modules/@turf/line-overlap/index.js");
var line_intersect_1 = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js");
var GeojsonEquality = __webpack_require__(/*! geojson-equality */ "./node_modules/geojson-equality/index.js");
/**
 * Compares two geometries of the same dimension and returns true if their intersection set results in a geometry
 * different from both but of the same dimension. It applies to Polygon/Polygon, LineString/LineString,
 * Multipoint/Multipoint, MultiLineString/MultiLineString and MultiPolygon/MultiPolygon.
 *
 * @name booleanOverlap
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature1 input
 * @param  {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} feature2 input
 * @returns {boolean} true/false
 * @example
 * var poly1 = turf.polygon([[[0,0],[0,5],[5,5],[5,0],[0,0]]]);
 * var poly2 = turf.polygon([[[1,1],[1,6],[6,6],[6,1],[1,1]]]);
 * var poly3 = turf.polygon([[[10,10],[10,15],[15,15],[15,10],[10,10]]]);
 *
 * turf.booleanOverlap(poly1, poly2)
 * //=true
 * turf.booleanOverlap(poly2, poly3)
 * //=false
 */
function booleanOverlap(feature1, feature2) {
    // validation
    if (!feature1)
        throw new Error('feature1 is required');
    if (!feature2)
        throw new Error('feature2 is required');
    var type1 = invariant_1.getType(feature1);
    var type2 = invariant_1.getType(feature2);
    if (type1 !== type2)
        throw new Error('features must be of the same type');
    if (type1 === 'Point')
        throw new Error('Point geometry not supported');
    // features must be not equal
    var equality = new GeojsonEquality({ precision: 6 });
    if (equality.compare(feature1, feature2))
        return false;
    var overlap = 0;
    switch (type1) {
        case 'MultiPoint':
            var coords1 = meta_1.coordAll(feature1);
            var coords2 = meta_1.coordAll(feature2);
            coords1.forEach(function (coord1) {
                coords2.forEach(function (coord2) {
                    if (coord1[0] === coord2[0] && coord1[1] === coord2[1])
                        overlap++;
                });
            });
            break;
        case 'LineString':
        case 'MultiLineString':
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_overlap_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
        case 'Polygon':
        case 'MultiPolygon':
            meta_1.segmentEach(feature1, function (segment1) {
                meta_1.segmentEach(feature2, function (segment2) {
                    if (line_intersect_1.default(segment1, segment2).features.length)
                        overlap++;
                });
            });
            break;
    }
    return overlap > 0;
}
exports.default = booleanOverlap;


/***/ }),

/***/ "./node_modules/@turf/boolean-point-in-polygon/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/@turf/boolean-point-in-polygon/index.js ***!
  \**************************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html
/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point
 * resides inside the polygon. The polygon can be convex or concave. The function accounts for holes.
 *
 * @name booleanPointInPolygon
 * @param {Coord} point input point
 * @param {Feature<Polygon|MultiPolygon>} polygon input polygon or multipolygon
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreBoundary=false] True if polygon boundary should be ignored when determining if
 * the point is inside the polygon otherwise false.
 * @returns {boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt = turf.point([-77, 44]);
 * var poly = turf.polygon([[
 *   [-81, 41],
 *   [-81, 47],
 *   [-72, 47],
 *   [-72, 41],
 *   [-81, 41]
 * ]]);
 *
 * turf.booleanPointInPolygon(pt, poly);
 * //= true
 */
function booleanPointInPolygon(point, polygon, options) {
    if (options === void 0) { options = {}; }
    // validation
    if (!point) {
        throw new Error("point is required");
    }
    if (!polygon) {
        throw new Error("polygon is required");
    }
    var pt = invariant_1.getCoord(point);
    var geom = invariant_1.getGeom(polygon);
    var type = geom.type;
    var bbox = polygon.bbox;
    var polys = geom.coordinates;
    // Quick elimination if point is not inside bbox
    if (bbox && inBBox(pt, bbox) === false) {
        return false;
    }
    // normalize to multipolygon
    if (type === "Polygon") {
        polys = [polys];
    }
    var insidePoly = false;
    for (var i = 0; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0], options.ignoreBoundary)) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k], !options.ignoreBoundary)) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) {
                insidePoly = true;
            }
        }
    }
    return insidePoly;
}
exports.default = booleanPointInPolygon;
/**
 * inRing
 *
 * @private
 * @param {Array<number>} pt [x,y]
 * @param {Array<Array<number>>} ring [[x,y], [x,y],..]
 * @param {boolean} ignoreBoundary ignoreBoundary
 * @returns {boolean} inRing
 */
function inRing(pt, ring, ignoreBoundary) {
    var isInside = false;
    if (ring[0][0] === ring[ring.length - 1][0] && ring[0][1] === ring[ring.length - 1][1]) {
        ring = ring.slice(0, ring.length - 1);
    }
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0];
        var yi = ring[i][1];
        var xj = ring[j][0];
        var yj = ring[j][1];
        var onBoundary = (pt[1] * (xi - xj) + yi * (xj - pt[0]) + yj * (pt[0] - xi) === 0) &&
            ((xi - pt[0]) * (xj - pt[0]) <= 0) && ((yi - pt[1]) * (yj - pt[1]) <= 0);
        if (onBoundary) {
            return !ignoreBoundary;
        }
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
            (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
        if (intersect) {
            isInside = !isInside;
        }
    }
    return isInside;
}
/**
 * inBBox
 *
 * @private
 * @param {Position} pt point [x,y]
 * @param {BBox} bbox BBox [west, south, east, north]
 * @returns {boolean} true/false if point is inside BBox
 */
function inBBox(pt, bbox) {
    return bbox[0] <= pt[0] &&
        bbox[1] <= pt[1] &&
        bbox[2] >= pt[0] &&
        bbox[3] >= pt[1];
}


/***/ }),

/***/ "./node_modules/@turf/boolean-point-on-line/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@turf/boolean-point-on-line/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Returns true if a point is on a line. Accepts a optional parameter to ignore the
 * start and end vertices of the linestring.
 *
 * @name booleanPointOnLine
 * @param {Coord} pt GeoJSON Point
 * @param {Feature<LineString>} line GeoJSON LineString
 * @param {Object} [options={}] Optional parameters
 * @param {boolean} [options.ignoreEndVertices=false] whether to ignore the start and end vertices.
 * @returns {boolean} true/false
 * @example
 * var pt = turf.point([0, 0]);
 * var line = turf.lineString([[-1, -1],[1, 1],[1.5, 2.2]]);
 * var isPointOnLine = turf.booleanPointOnLine(pt, line);
 * //=true
 */
function booleanPointOnLine(pt, line, options) {
    if (options === void 0) { options = {}; }
    // Normalize inputs
    var ptCoords = invariant_1.getCoord(pt);
    var lineCoords = invariant_1.getCoords(line);
    // Main
    for (var i = 0; i < lineCoords.length - 1; i++) {
        var ignoreBoundary = false;
        if (options.ignoreEndVertices) {
            if (i === 0) {
                ignoreBoundary = "start";
            }
            if (i === lineCoords.length - 2) {
                ignoreBoundary = "end";
            }
            if (i === 0 && i + 1 === lineCoords.length - 1) {
                ignoreBoundary = "both";
            }
        }
        if (isPointOnLineSegment(lineCoords[i], lineCoords[i + 1], ptCoords, ignoreBoundary)) {
            return true;
        }
    }
    return false;
}
// See http://stackoverflow.com/a/4833823/1979085
/**
 * @private
 * @param {Position} lineSegmentStart coord pair of start of line
 * @param {Position} lineSegmentEnd coord pair of end of line
 * @param {Position} pt coord pair of point to check
 * @param {boolean|string} excludeBoundary whether the point is allowed to fall on the line ends.
 * If true which end to ignore.
 * @returns {boolean} true/false
 */
function isPointOnLineSegment(lineSegmentStart, lineSegmentEnd, pt, excludeBoundary) {
    var x = pt[0];
    var y = pt[1];
    var x1 = lineSegmentStart[0];
    var y1 = lineSegmentStart[1];
    var x2 = lineSegmentEnd[0];
    var y2 = lineSegmentEnd[1];
    var dxc = pt[0] - x1;
    var dyc = pt[1] - y1;
    var dxl = x2 - x1;
    var dyl = y2 - y1;
    var cross = dxc * dyl - dyc * dxl;
    if (cross !== 0) {
        return false;
    }
    if (!excludeBoundary) {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x <= x2 : x2 <= x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y <= y2 : y2 <= y && y <= y1;
    }
    else if (excludeBoundary === "start") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x <= x2 : x2 <= x && x < x1;
        }
        return dyl > 0 ? y1 < y && y <= y2 : y2 <= y && y < y1;
    }
    else if (excludeBoundary === "end") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 <= x && x < x2 : x2 < x && x <= x1;
        }
        return dyl > 0 ? y1 <= y && y < y2 : y2 < y && y <= y1;
    }
    else if (excludeBoundary === "both") {
        if (Math.abs(dxl) >= Math.abs(dyl)) {
            return dxl > 0 ? x1 < x && x < x2 : x2 < x && x < x1;
        }
        return dyl > 0 ? y1 < y && y < y2 : y2 < y && y < y1;
    }
    return false;
}
exports.default = booleanPointOnLine;


/***/ }),

/***/ "./node_modules/@turf/destination/index.js":
/*!*************************************************!*\
  !*** ./node_modules/@turf/destination/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// http://en.wikipedia.org/wiki/Haversine_formula
// http://www.movable-type.co.uk/scripts/latlong.html
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in
 * degrees, radians, miles, or kilometers; and bearing in degrees.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Coord} origin starting point
 * @param {number} distance distance from the origin point
 * @param {number} bearing ranging from -180 to 180
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] miles, kilometers, degrees, or radians
 * @param {Object} [options.properties={}] Translate properties to Point
 * @returns {Feature<Point>} destination point
 * @example
 * var point = turf.point([-75.343, 39.984]);
 * var distance = 50;
 * var bearing = 90;
 * var options = {units: 'miles'};
 *
 * var destination = turf.destination(point, distance, bearing, options);
 *
 * //addToMap
 * var addToMap = [point, destination]
 * destination.properties['marker-color'] = '#f00';
 * point.properties['marker-color'] = '#0f0';
 */
function destination(origin, distance, bearing, options) {
    if (options === void 0) { options = {}; }
    // Handle input
    var coordinates1 = invariant_1.getCoord(origin);
    var longitude1 = helpers_1.degreesToRadians(coordinates1[0]);
    var latitude1 = helpers_1.degreesToRadians(coordinates1[1]);
    var bearingRad = helpers_1.degreesToRadians(bearing);
    var radians = helpers_1.lengthToRadians(distance, options.units);
    // Main
    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearingRad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearingRad) * Math.sin(radians) * Math.cos(latitude1), Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));
    var lng = helpers_1.radiansToDegrees(longitude2);
    var lat = helpers_1.radiansToDegrees(latitude2);
    return helpers_1.point([lng, lat], options.properties);
}
exports.default = destination;


/***/ }),

/***/ "./node_modules/@turf/distance/index.js":
/*!**********************************************!*\
  !*** ./node_modules/@turf/distance/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
/**
 * Calculates the distance between two {@link Point|points} in degrees, radians, miles, or kilometers.
 * This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name distance
 * @param {Coord} from origin point
 * @param {Coord} to destination point
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {number} distance between the two points
 * @example
 * var from = turf.point([-75.343, 39.984]);
 * var to = turf.point([-75.534, 39.123]);
 * var options = {units: 'miles'};
 *
 * var distance = turf.distance(from, to, options);
 *
 * //addToMap
 * var addToMap = [from, to];
 * from.properties.distance = distance;
 * to.properties.distance = distance;
 */
function distance(from, to, options) {
    if (options === void 0) { options = {}; }
    var coordinates1 = invariant_1.getCoord(from);
    var coordinates2 = invariant_1.getCoord(to);
    var dLat = helpers_1.degreesToRadians((coordinates2[1] - coordinates1[1]));
    var dLon = helpers_1.degreesToRadians((coordinates2[0] - coordinates1[0]));
    var lat1 = helpers_1.degreesToRadians(coordinates1[1]);
    var lat2 = helpers_1.degreesToRadians(coordinates2[1]);
    var a = Math.pow(Math.sin(dLat / 2), 2) +
        Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);
    return helpers_1.radiansToLength(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), options.units);
}
exports.default = distance;


/***/ }),

/***/ "./node_modules/@turf/helpers/index.js":
/*!*********************************************!*\
  !*** ./node_modules/@turf/helpers/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * @module helpers
 */
/**
 * Earth Radius used with the Harvesine formula and approximates using a spherical (non-ellipsoid) Earth.
 *
 * @memberof helpers
 * @type {number}
 */
exports.earthRadius = 6371008.8;
/**
 * Unit of measurement factors using a spherical (non-ellipsoid) earth radius.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.factors = {
    centimeters: exports.earthRadius * 100,
    centimetres: exports.earthRadius * 100,
    degrees: exports.earthRadius / 111325,
    feet: exports.earthRadius * 3.28084,
    inches: exports.earthRadius * 39.370,
    kilometers: exports.earthRadius / 1000,
    kilometres: exports.earthRadius / 1000,
    meters: exports.earthRadius,
    metres: exports.earthRadius,
    miles: exports.earthRadius / 1609.344,
    millimeters: exports.earthRadius * 1000,
    millimetres: exports.earthRadius * 1000,
    nauticalmiles: exports.earthRadius / 1852,
    radians: 1,
    yards: exports.earthRadius / 1.0936,
};
/**
 * Units of measurement factors based on 1 meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.unitsFactors = {
    centimeters: 100,
    centimetres: 100,
    degrees: 1 / 111325,
    feet: 3.28084,
    inches: 39.370,
    kilometers: 1 / 1000,
    kilometres: 1 / 1000,
    meters: 1,
    metres: 1,
    miles: 1 / 1609.344,
    millimeters: 1000,
    millimetres: 1000,
    nauticalmiles: 1 / 1852,
    radians: 1 / exports.earthRadius,
    yards: 1 / 1.0936,
};
/**
 * Area of measurement factors based on 1 square meter.
 *
 * @memberof helpers
 * @type {Object}
 */
exports.areaFactors = {
    acres: 0.000247105,
    centimeters: 10000,
    centimetres: 10000,
    feet: 10.763910417,
    inches: 1550.003100006,
    kilometers: 0.000001,
    kilometres: 0.000001,
    meters: 1,
    metres: 1,
    miles: 3.86e-7,
    millimeters: 1000000,
    millimetres: 1000000,
    yards: 1.195990046,
};
/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature} a GeoJSON Feature
 * @example
 * var geometry = {
 *   "type": "Point",
 *   "coordinates": [110, 50]
 * };
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geom, properties, options) {
    if (options === void 0) { options = {}; }
    var feat = { type: "Feature" };
    if (options.id === 0 || options.id) {
        feat.id = options.id;
    }
    if (options.bbox) {
        feat.bbox = options.bbox;
    }
    feat.properties = properties || {};
    feat.geometry = geom;
    return feat;
}
exports.feature = feature;
/**
 * Creates a GeoJSON {@link Geometry} from a Geometry string type & coordinates.
 * For GeometryCollection type use `helpers.geometryCollection`
 *
 * @name geometry
 * @param {string} type Geometry Type
 * @param {Array<any>} coordinates Coordinates
 * @param {Object} [options={}] Optional Parameters
 * @returns {Geometry} a GeoJSON Geometry
 * @example
 * var type = "Point";
 * var coordinates = [110, 50];
 * var geometry = turf.geometry(type, coordinates);
 * // => geometry
 */
function geometry(type, coordinates, options) {
    if (options === void 0) { options = {}; }
    switch (type) {
        case "Point": return point(coordinates).geometry;
        case "LineString": return lineString(coordinates).geometry;
        case "Polygon": return polygon(coordinates).geometry;
        case "MultiPoint": return multiPoint(coordinates).geometry;
        case "MultiLineString": return multiLineString(coordinates).geometry;
        case "MultiPolygon": return multiPolygon(coordinates).geometry;
        default: throw new Error(type + " is invalid");
    }
}
exports.geometry = geometry;
/**
 * Creates a {@link Point} {@link Feature} from a Position.
 *
 * @name point
 * @param {Array<number>} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Point>} a Point feature
 * @example
 * var point = turf.point([-75.343, 39.984]);
 *
 * //=point
 */
function point(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "Point",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.point = point;
/**
 * Creates a {@link Point} {@link FeatureCollection} from an Array of Point coordinates.
 *
 * @name points
 * @param {Array<Array<number>>} coordinates an array of Points
 * @param {Object} [properties={}] Translate these properties to each Feature
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Point>} Point Feature
 * @example
 * var points = turf.points([
 *   [-75, 39],
 *   [-80, 45],
 *   [-78, 50]
 * ]);
 *
 * //=points
 */
function points(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return point(coords, properties);
    }), options);
}
exports.points = points;
/**
 * Creates a {@link Polygon} {@link Feature} from an Array of LinearRings.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<Polygon>} Polygon Feature
 * @example
 * var polygon = turf.polygon([[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]], { name: 'poly1' });
 *
 * //=polygon
 */
function polygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    for (var _i = 0, coordinates_1 = coordinates; _i < coordinates_1.length; _i++) {
        var ring = coordinates_1[_i];
        if (ring.length < 4) {
            throw new Error("Each LinearRing of a Polygon must have 4 or more Positions.");
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            // Check if first point of Polygon contains two numbers
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error("First and last Position are not equivalent.");
            }
        }
    }
    var geom = {
        type: "Polygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.polygon = polygon;
/**
 * Creates a {@link Polygon} {@link FeatureCollection} from an Array of Polygon coordinates.
 *
 * @name polygons
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygon coordinates
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<Polygon>} Polygon FeatureCollection
 * @example
 * var polygons = turf.polygons([
 *   [[[-5, 52], [-4, 56], [-2, 51], [-7, 54], [-5, 52]]],
 *   [[[-15, 42], [-14, 46], [-12, 41], [-17, 44], [-15, 42]]],
 * ]);
 *
 * //=polygons
 */
function polygons(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return polygon(coords, properties);
    }), options);
}
exports.polygons = polygons;
/**
 * Creates a {@link LineString} {@link Feature} from an Array of Positions.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<LineString>} LineString Feature
 * @example
 * var linestring1 = turf.lineString([[-24, 63], [-23, 60], [-25, 65], [-20, 69]], {name: 'line 1'});
 * var linestring2 = turf.lineString([[-14, 43], [-13, 40], [-15, 45], [-10, 49]], {name: 'line 2'});
 *
 * //=linestring1
 * //=linestring2
 */
function lineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    if (coordinates.length < 2) {
        throw new Error("coordinates must be an array of two or more positions");
    }
    var geom = {
        type: "LineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.lineString = lineString;
/**
 * Creates a {@link LineString} {@link FeatureCollection} from an Array of LineString coordinates.
 *
 * @name lineStrings
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north]
 * associated with the FeatureCollection
 * @param {string|number} [options.id] Identifier associated with the FeatureCollection
 * @returns {FeatureCollection<LineString>} LineString FeatureCollection
 * @example
 * var linestrings = turf.lineStrings([
 *   [[-24, 63], [-23, 60], [-25, 65], [-20, 69]],
 *   [[-14, 43], [-13, 40], [-15, 45], [-10, 49]]
 * ]);
 *
 * //=linestrings
 */
function lineStrings(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    return featureCollection(coordinates.map(function (coords) {
        return lineString(coords, properties);
    }), options);
}
exports.lineStrings = lineStrings;
/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {FeatureCollection} FeatureCollection of Features
 * @example
 * var locationA = turf.point([-75.343, 39.984], {name: 'Location A'});
 * var locationB = turf.point([-75.833, 39.284], {name: 'Location B'});
 * var locationC = turf.point([-75.534, 39.123], {name: 'Location C'});
 *
 * var collection = turf.featureCollection([
 *   locationA,
 *   locationB,
 *   locationC
 * ]);
 *
 * //=collection
 */
function featureCollection(features, options) {
    if (options === void 0) { options = {}; }
    var fc = { type: "FeatureCollection" };
    if (options.id) {
        fc.id = options.id;
    }
    if (options.bbox) {
        fc.bbox = options.bbox;
    }
    fc.features = features;
    return fc;
}
exports.featureCollection = featureCollection;
/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 */
function multiLineString(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiLineString",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiLineString = multiLineString;
/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 */
function multiPoint(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPoint",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPoint = multiPoint;
/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]]);
 *
 * //=multiPoly
 *
 */
function multiPolygon(coordinates, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "MultiPolygon",
        coordinates: coordinates,
    };
    return feature(geom, properties, options);
}
exports.multiPolygon = multiPolygon;
/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<Geometry>} geometries an array of GeoJSON Geometries
 * @param {Object} [properties={}] an Object of key-value pairs to add as properties
 * @param {Object} [options={}] Optional Parameters
 * @param {Array<number>} [options.bbox] Bounding Box Array [west, south, east, north] associated with the Feature
 * @param {string|number} [options.id] Identifier associated with the Feature
 * @returns {Feature<GeometryCollection>} a GeoJSON GeometryCollection Feature
 * @example
 * var pt = turf.geometry("Point", [100, 0]);
 * var line = turf.geometry("LineString", [[101, 0], [102, 1]]);
 * var collection = turf.geometryCollection([pt, line]);
 *
 * // => collection
 */
function geometryCollection(geometries, properties, options) {
    if (options === void 0) { options = {}; }
    var geom = {
        type: "GeometryCollection",
        geometries: geometries,
    };
    return feature(geom, properties, options);
}
exports.geometryCollection = geometryCollection;
/**
 * Round number to precision
 *
 * @param {number} num Number
 * @param {number} [precision=0] Precision
 * @returns {number} rounded number
 * @example
 * turf.round(120.4321)
 * //=120
 *
 * turf.round(120.4321, 2)
 * //=120.43
 */
function round(num, precision) {
    if (precision === void 0) { precision = 0; }
    if (precision && !(precision >= 0)) {
        throw new Error("precision must be a positive number");
    }
    var multiplier = Math.pow(10, precision || 0);
    return Math.round(num * multiplier) / multiplier;
}
exports.round = round;
/**
 * Convert a distance measurement (assuming a spherical Earth) from radians to a more friendly unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name radiansToLength
 * @param {number} radians in radians across the sphere
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} distance
 */
function radiansToLength(radians, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return radians * factor;
}
exports.radiansToLength = radiansToLength;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into radians
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @name lengthToRadians
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} radians
 */
function lengthToRadians(distance, units) {
    if (units === void 0) { units = "kilometers"; }
    var factor = exports.factors[units];
    if (!factor) {
        throw new Error(units + " units is invalid");
    }
    return distance / factor;
}
exports.lengthToRadians = lengthToRadians;
/**
 * Convert a distance measurement (assuming a spherical Earth) from a real-world unit into degrees
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, centimeters, kilometres, feet
 *
 * @name lengthToDegrees
 * @param {number} distance in real units
 * @param {string} [units="kilometers"] can be degrees, radians, miles, or kilometers inches, yards, metres,
 * meters, kilometres, kilometers.
 * @returns {number} degrees
 */
function lengthToDegrees(distance, units) {
    return radiansToDegrees(lengthToRadians(distance, units));
}
exports.lengthToDegrees = lengthToDegrees;
/**
 * Converts any bearing angle from the north line direction (positive clockwise)
 * and returns an angle between 0-360 degrees (positive clockwise), 0 being the north line
 *
 * @name bearingToAzimuth
 * @param {number} bearing angle, between -180 and +180 degrees
 * @returns {number} angle between 0 and 360 degrees
 */
function bearingToAzimuth(bearing) {
    var angle = bearing % 360;
    if (angle < 0) {
        angle += 360;
    }
    return angle;
}
exports.bearingToAzimuth = bearingToAzimuth;
/**
 * Converts an angle in radians to degrees
 *
 * @name radiansToDegrees
 * @param {number} radians angle in radians
 * @returns {number} degrees between 0 and 360 degrees
 */
function radiansToDegrees(radians) {
    var degrees = radians % (2 * Math.PI);
    return degrees * 180 / Math.PI;
}
exports.radiansToDegrees = radiansToDegrees;
/**
 * Converts an angle in degrees to radians
 *
 * @name degreesToRadians
 * @param {number} degrees angle between 0 and 360 degrees
 * @returns {number} angle in radians
 */
function degreesToRadians(degrees) {
    var radians = degrees % 360;
    return radians * Math.PI / 180;
}
exports.degreesToRadians = degreesToRadians;
/**
 * Converts a length to the requested unit.
 * Valid units: miles, nauticalmiles, inches, yards, meters, metres, kilometers, centimeters, feet
 *
 * @param {number} length to be converted
 * @param {Units} [originalUnit="kilometers"] of the length
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted length
 */
function convertLength(length, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "kilometers"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(length >= 0)) {
        throw new Error("length must be a positive number");
    }
    return radiansToLength(lengthToRadians(length, originalUnit), finalUnit);
}
exports.convertLength = convertLength;
/**
 * Converts a area to the requested unit.
 * Valid units: kilometers, kilometres, meters, metres, centimetres, millimeters, acres, miles, yards, feet, inches
 * @param {number} area to be converted
 * @param {Units} [originalUnit="meters"] of the distance
 * @param {Units} [finalUnit="kilometers"] returned unit
 * @returns {number} the converted distance
 */
function convertArea(area, originalUnit, finalUnit) {
    if (originalUnit === void 0) { originalUnit = "meters"; }
    if (finalUnit === void 0) { finalUnit = "kilometers"; }
    if (!(area >= 0)) {
        throw new Error("area must be a positive number");
    }
    var startFactor = exports.areaFactors[originalUnit];
    if (!startFactor) {
        throw new Error("invalid original units");
    }
    var finalFactor = exports.areaFactors[finalUnit];
    if (!finalFactor) {
        throw new Error("invalid final units");
    }
    return (area / startFactor) * finalFactor;
}
exports.convertArea = convertArea;
/**
 * isNumber
 *
 * @param {*} num Number to validate
 * @returns {boolean} true/false
 * @example
 * turf.isNumber(123)
 * //=true
 * turf.isNumber('foo')
 * //=false
 */
function isNumber(num) {
    return !isNaN(num) && num !== null && !Array.isArray(num) && !/^\s*$/.test(num);
}
exports.isNumber = isNumber;
/**
 * isObject
 *
 * @param {*} input variable to validate
 * @returns {boolean} true/false
 * @example
 * turf.isObject({elevation: 10})
 * //=true
 * turf.isObject('foo')
 * //=false
 */
function isObject(input) {
    return (!!input) && (input.constructor === Object);
}
exports.isObject = isObject;
/**
 * Validate BBox
 *
 * @private
 * @param {Array<number>} bbox BBox to validate
 * @returns {void}
 * @throws Error if BBox is not valid
 * @example
 * validateBBox([-180, -40, 110, 50])
 * //=OK
 * validateBBox([-180, -40])
 * //=Error
 * validateBBox('Foo')
 * //=Error
 * validateBBox(5)
 * //=Error
 * validateBBox(null)
 * //=Error
 * validateBBox(undefined)
 * //=Error
 */
function validateBBox(bbox) {
    if (!bbox) {
        throw new Error("bbox is required");
    }
    if (!Array.isArray(bbox)) {
        throw new Error("bbox must be an Array");
    }
    if (bbox.length !== 4 && bbox.length !== 6) {
        throw new Error("bbox must be an Array of 4 or 6 numbers");
    }
    bbox.forEach(function (num) {
        if (!isNumber(num)) {
            throw new Error("bbox must only contain numbers");
        }
    });
}
exports.validateBBox = validateBBox;
/**
 * Validate Id
 *
 * @private
 * @param {string|number} id Id to validate
 * @returns {void}
 * @throws Error if Id is not valid
 * @example
 * validateId([-180, -40, 110, 50])
 * //=Error
 * validateId([-180, -40])
 * //=Error
 * validateId('Foo')
 * //=OK
 * validateId(5)
 * //=OK
 * validateId(null)
 * //=Error
 * validateId(undefined)
 * //=Error
 */
function validateId(id) {
    if (!id) {
        throw new Error("id is required");
    }
    if (["string", "number"].indexOf(typeof id) === -1) {
        throw new Error("id must be a number or a string");
    }
}
exports.validateId = validateId;
// Deprecated methods
function radians2degrees() {
    throw new Error("method has been renamed to `radiansToDegrees`");
}
exports.radians2degrees = radians2degrees;
function degrees2radians() {
    throw new Error("method has been renamed to `degreesToRadians`");
}
exports.degrees2radians = degrees2radians;
function distanceToDegrees() {
    throw new Error("method has been renamed to `lengthToDegrees`");
}
exports.distanceToDegrees = distanceToDegrees;
function distanceToRadians() {
    throw new Error("method has been renamed to `lengthToRadians`");
}
exports.distanceToRadians = distanceToRadians;
function radiansToDistance() {
    throw new Error("method has been renamed to `radiansToLength`");
}
exports.radiansToDistance = radiansToDistance;
function bearingToAngle() {
    throw new Error("method has been renamed to `bearingToAzimuth`");
}
exports.bearingToAngle = bearingToAngle;
function convertDistance() {
    throw new Error("method has been renamed to `convertLength`");
}
exports.convertDistance = convertDistance;


/***/ }),

/***/ "./node_modules/@turf/invariant/index.js":
/*!***********************************************!*\
  !*** ./node_modules/@turf/invariant/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
/**
 * Unwrap a coordinate from a Point Feature, Geometry or a single coordinate.
 *
 * @name getCoord
 * @param {Array<number>|Geometry<Point>|Feature<Point>} coord GeoJSON Point or an Array of numbers
 * @returns {Array<number>} coordinates
 * @example
 * var pt = turf.point([10, 10]);
 *
 * var coord = turf.getCoord(pt);
 * //= [10, 10]
 */
function getCoord(coord) {
    if (!coord) {
        throw new Error("coord is required");
    }
    if (!Array.isArray(coord)) {
        if (coord.type === "Feature" && coord.geometry !== null && coord.geometry.type === "Point") {
            return coord.geometry.coordinates;
        }
        if (coord.type === "Point") {
            return coord.coordinates;
        }
    }
    if (Array.isArray(coord) && coord.length >= 2 && !Array.isArray(coord[0]) && !Array.isArray(coord[1])) {
        return coord;
    }
    throw new Error("coord must be GeoJSON Point or an Array of numbers");
}
exports.getCoord = getCoord;
/**
 * Unwrap coordinates from a Feature, Geometry Object or an Array
 *
 * @name getCoords
 * @param {Array<any>|Geometry|Feature} coords Feature, Geometry Object or an Array
 * @returns {Array<any>} coordinates
 * @example
 * var poly = turf.polygon([[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]);
 *
 * var coords = turf.getCoords(poly);
 * //= [[[119.32, -8.7], [119.55, -8.69], [119.51, -8.54], [119.32, -8.7]]]
 */
function getCoords(coords) {
    if (Array.isArray(coords)) {
        return coords;
    }
    // Feature
    if (coords.type === "Feature") {
        if (coords.geometry !== null) {
            return coords.geometry.coordinates;
        }
    }
    else {
        // Geometry
        if (coords.coordinates) {
            return coords.coordinates;
        }
    }
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array");
}
exports.getCoords = getCoords;
/**
 * Checks if coordinates contains a number
 *
 * @name containsNumber
 * @param {Array<any>} coordinates GeoJSON Coordinates
 * @returns {boolean} true if Array contains a number
 */
function containsNumber(coordinates) {
    if (coordinates.length > 1 && helpers_1.isNumber(coordinates[0]) && helpers_1.isNumber(coordinates[1])) {
        return true;
    }
    if (Array.isArray(coordinates[0]) && coordinates[0].length) {
        return containsNumber(coordinates[0]);
    }
    throw new Error("coordinates must only contain numbers");
}
exports.containsNumber = containsNumber;
/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @name geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) {
        throw new Error("type and name required");
    }
    if (!value || value.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + value.type);
    }
}
exports.geojsonType = geojsonType;
/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!feature) {
        throw new Error("No feature passed");
    }
    if (!name) {
        throw new Error(".featureOf() requires a name");
    }
    if (!feature || feature.type !== "Feature" || !feature.geometry) {
        throw new Error("Invalid input to " + name + ", Feature with geometry required");
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
    }
}
exports.featureOf = featureOf;
/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @name collectionOf
 * @param {FeatureCollection} featureCollection a FeatureCollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featureCollection, type, name) {
    if (!featureCollection) {
        throw new Error("No featureCollection passed");
    }
    if (!name) {
        throw new Error(".collectionOf() requires a name");
    }
    if (!featureCollection || featureCollection.type !== "FeatureCollection") {
        throw new Error("Invalid input to " + name + ", FeatureCollection required");
    }
    for (var _i = 0, _a = featureCollection.features; _i < _a.length; _i++) {
        var feature = _a[_i];
        if (!feature || feature.type !== "Feature" || !feature.geometry) {
            throw new Error("Invalid input to " + name + ", Feature with geometry required");
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error("Invalid input to " + name + ": must be a " + type + ", given " + feature.geometry.type);
        }
    }
}
exports.collectionOf = collectionOf;
/**
 * Get Geometry from Feature or Geometry Object
 *
 * @param {Feature|Geometry} geojson GeoJSON Feature or Geometry Object
 * @returns {Geometry|null} GeoJSON Geometry Object
 * @throws {Error} if geojson is not a Feature or Geometry Object
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getGeom(point)
 * //={"type": "Point", "coordinates": [110, 40]}
 */
function getGeom(geojson) {
    if (geojson.type === "Feature") {
        return geojson.geometry;
    }
    return geojson;
}
exports.getGeom = getGeom;
/**
 * Get GeoJSON object's type, Geometry type is prioritize.
 *
 * @param {GeoJSON} geojson GeoJSON object
 * @param {string} [name="geojson"] name of the variable to display in error message
 * @returns {string} GeoJSON type
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [110, 40]
 *   }
 * }
 * var geom = turf.getType(point)
 * //="Point"
 */
function getType(geojson, name) {
    if (geojson.type === "FeatureCollection") {
        return "FeatureCollection";
    }
    if (geojson.type === "GeometryCollection") {
        return "GeometryCollection";
    }
    if (geojson.type === "Feature" && geojson.geometry !== null) {
        return geojson.geometry.type;
    }
    return geojson.type;
}
exports.getType = getType;


/***/ }),

/***/ "./node_modules/@turf/line-intersect/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@turf/line-intersect/index.js ***!
  \****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
}
Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var line_segment_1 = __importDefault(__webpack_require__(/*! @turf/line-segment */ "./node_modules/@turf/line-segment/index.js"));
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var geojson_rbush_1 = __importDefault(__webpack_require__(/*! geojson-rbush */ "./node_modules/geojson-rbush/index.js"));
/**
 * Takes any LineString or Polygon GeoJSON and returns the intersecting point(s).
 *
 * @name lineIntersect
 * @param {GeoJSON} line1 any LineString or Polygon
 * @param {GeoJSON} line2 any LineString or Polygon
 * @returns {FeatureCollection<Point>} point(s) that intersect both
 * @example
 * var line1 = turf.lineString([[126, -11], [129, -21]]);
 * var line2 = turf.lineString([[123, -18], [131, -14]]);
 * var intersects = turf.lineIntersect(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, intersects]
 */
function lineIntersect(line1, line2) {
    var unique = {};
    var results = [];
    // First, normalize geometries to features
    // Then, handle simple 2-vertex segments
    if (line1.type === "LineString") {
        line1 = helpers_1.feature(line1);
    }
    if (line2.type === "LineString") {
        line2 = helpers_1.feature(line2);
    }
    if (line1.type === "Feature" &&
        line2.type === "Feature" &&
        line1.geometry !== null &&
        line2.geometry !== null &&
        line1.geometry.type === "LineString" &&
        line2.geometry.type === "LineString" &&
        line1.geometry.coordinates.length === 2 &&
        line2.geometry.coordinates.length === 2) {
        var intersect = intersects(line1, line2);
        if (intersect) {
            results.push(intersect);
        }
        return helpers_1.featureCollection(results);
    }
    // Handles complex GeoJSON Geometries
    var tree = geojson_rbush_1.default();
    tree.load(line_segment_1.default(line2));
    meta_1.featureEach(line_segment_1.default(line1), function (segment) {
        meta_1.featureEach(tree.search(segment), function (match) {
            var intersect = intersects(segment, match);
            if (intersect) {
                // prevent duplicate points https://github.com/Turfjs/turf/issues/688
                var key = invariant_1.getCoords(intersect).join(",");
                if (!unique[key]) {
                    unique[key] = true;
                    results.push(intersect);
                }
            }
        });
    });
    return helpers_1.featureCollection(results);
}
/**
 * Find a point that intersects LineStrings with two coordinates each
 *
 * @private
 * @param {Feature<LineString>} line1 GeoJSON LineString (Must only contain 2 coordinates)
 * @param {Feature<LineString>} line2 GeoJSON LineString (Must only contain 2 coordinates)
 * @returns {Feature<Point>} intersecting GeoJSON Point
 */
function intersects(line1, line2) {
    var coords1 = invariant_1.getCoords(line1);
    var coords2 = invariant_1.getCoords(line2);
    if (coords1.length !== 2) {
        throw new Error("<intersects> line1 must only contain 2 coordinates");
    }
    if (coords2.length !== 2) {
        throw new Error("<intersects> line2 must only contain 2 coordinates");
    }
    var x1 = coords1[0][0];
    var y1 = coords1[0][1];
    var x2 = coords1[1][0];
    var y2 = coords1[1][1];
    var x3 = coords2[0][0];
    var y3 = coords2[0][1];
    var x4 = coords2[1][0];
    var y4 = coords2[1][1];
    var denom = ((y4 - y3) * (x2 - x1)) - ((x4 - x3) * (y2 - y1));
    var numeA = ((x4 - x3) * (y1 - y3)) - ((y4 - y3) * (x1 - x3));
    var numeB = ((x2 - x1) * (y1 - y3)) - ((y2 - y1) * (x1 - x3));
    if (denom === 0) {
        if (numeA === 0 && numeB === 0) {
            return null;
        }
        return null;
    }
    var uA = numeA / denom;
    var uB = numeB / denom;
    if (uA >= 0 && uA <= 1 && uB >= 0 && uB <= 1) {
        var x = x1 + (uA * (x2 - x1));
        var y = y1 + (uA * (y2 - y1));
        return helpers_1.point([x, y]);
    }
    return null;
}
exports.default = lineIntersect;


/***/ }),

/***/ "./node_modules/@turf/line-overlap/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/line-overlap/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var geojson_rbush_1 = __webpack_require__(/*! geojson-rbush */ "./node_modules/geojson-rbush/index.js");
var line_segment_1 = __webpack_require__(/*! @turf/line-segment */ "./node_modules/@turf/line-segment/index.js");
var nearest_point_on_line_1 = __webpack_require__(/*! @turf/nearest-point-on-line */ "./node_modules/@turf/nearest-point-on-line/index.js");
var boolean_point_on_line_1 = __webpack_require__(/*! @turf/boolean-point-on-line */ "./node_modules/@turf/boolean-point-on-line/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var equal = __webpack_require__(/*! deep-equal */ "./node_modules/deep-equal/index.js");
/**
 * Takes any LineString or Polygon and returns the overlapping lines between both features.
 *
 * @name lineOverlap
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line1 any LineString or Polygon
 * @param {Geometry|Feature<LineString|MultiLineString|Polygon|MultiPolygon>} line2 any LineString or Polygon
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.tolerance=0] Tolerance distance to match overlapping line segments (in kilometers)
 * @returns {FeatureCollection<LineString>} lines(s) that are overlapping between both features
 * @example
 * var line1 = turf.lineString([[115, -35], [125, -30], [135, -30], [145, -35]]);
 * var line2 = turf.lineString([[115, -25], [125, -30], [135, -30], [145, -25]]);
 *
 * var overlapping = turf.lineOverlap(line1, line2);
 *
 * //addToMap
 * var addToMap = [line1, line2, overlapping]
 */
function lineOverlap(line1, line2, options) {
    if (options === void 0) { options = {}; }
    // Optional parameters
    options = options || {};
    if (!helpers_1.isObject(options))
        throw new Error('options is invalid');
    var tolerance = options.tolerance || 0;
    // Containers
    var features = [];
    // Create Spatial Index
    var tree = geojson_rbush_1.default();
    // To-Do -- HACK way to support typescript
    var line = line_segment_1.default(line1);
    tree.load(line);
    var overlapSegment;
    // Line Intersection
    // Iterate over line segments
    meta_1.segmentEach(line2, function (segment) {
        var doesOverlaps = false;
        // Iterate over each segments which falls within the same bounds
        meta_1.featureEach(tree.search(segment), function (match) {
            if (doesOverlaps === false) {
                var coordsSegment = invariant_1.getCoords(segment).sort();
                var coordsMatch = invariant_1.getCoords(match).sort();
                // Segment overlaps feature
                if (equal(coordsSegment, coordsMatch)) {
                    doesOverlaps = true;
                    // Overlaps already exists - only append last coordinate of segment
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                    // Match segments which don't share nodes (Issue #901)
                }
                else if ((tolerance === 0) ?
                    boolean_point_on_line_1.default(coordsSegment[0], match) && boolean_point_on_line_1.default(coordsSegment[1], match) :
                    nearest_point_on_line_1.default(match, coordsSegment[0]).properties.dist <= tolerance &&
                        nearest_point_on_line_1.default(match, coordsSegment[1]).properties.dist <= tolerance) {
                    doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, segment);
                    else
                        overlapSegment = segment;
                }
                else if ((tolerance === 0) ?
                    boolean_point_on_line_1.default(coordsMatch[0], segment) && boolean_point_on_line_1.default(coordsMatch[1], segment) :
                    nearest_point_on_line_1.default(segment, coordsMatch[0]).properties.dist <= tolerance &&
                        nearest_point_on_line_1.default(segment, coordsMatch[1]).properties.dist <= tolerance) {
                    // Do not define (doesOverlap = true) since more matches can occur within the same segment
                    // doesOverlaps = true;
                    if (overlapSegment)
                        overlapSegment = concatSegment(overlapSegment, match);
                    else
                        overlapSegment = match;
                }
            }
        });
        // Segment doesn't overlap - add overlaps to results & reset
        if (doesOverlaps === false && overlapSegment) {
            features.push(overlapSegment);
            overlapSegment = undefined;
        }
    });
    // Add last segment if exists
    if (overlapSegment)
        features.push(overlapSegment);
    return helpers_1.featureCollection(features);
}
/**
 * Concat Segment
 *
 * @private
 * @param {Feature<LineString>} line LineString
 * @param {Feature<LineString>} segment 2-vertex LineString
 * @returns {Feature<LineString>} concat linestring
 */
function concatSegment(line, segment) {
    var coords = invariant_1.getCoords(segment);
    var lineCoords = invariant_1.getCoords(line);
    var start = lineCoords[0];
    var end = lineCoords[lineCoords.length - 1];
    var geom = line.geometry.coordinates;
    if (equal(coords[0], start))
        geom.unshift(coords[1]);
    else if (equal(coords[0], end))
        geom.push(coords[1]);
    else if (equal(coords[1], start))
        geom.unshift(coords[0]);
    else if (equal(coords[1], end))
        geom.push(coords[0]);
    return line;
}
exports.default = lineOverlap;


/***/ }),

/***/ "./node_modules/@turf/line-segment/index.js":
/*!**************************************************!*\
  !*** ./node_modules/@turf/line-segment/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
/**
 * Creates a {@link FeatureCollection} of 2-vertex {@link LineString} segments from a
 * {@link LineString|(Multi)LineString} or {@link Polygon|(Multi)Polygon}.
 *
 * @name lineSegment
 * @param {GeoJSON} geojson GeoJSON Polygon or LineString
 * @returns {FeatureCollection<LineString>} 2-vertex line segments
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 * var segments = turf.lineSegment(polygon);
 *
 * //addToMap
 * var addToMap = [polygon, segments]
 */
function lineSegment(geojson) {
    if (!geojson) {
        throw new Error("geojson is required");
    }
    var results = [];
    meta_1.flattenEach(geojson, function (feature) {
        lineSegmentFeature(feature, results);
    });
    return helpers_1.featureCollection(results);
}
/**
 * Line Segment
 *
 * @private
 * @param {Feature<LineString|Polygon>} geojson Line or polygon feature
 * @param {Array} results push to results
 * @returns {void}
 */
function lineSegmentFeature(geojson, results) {
    var coords = [];
    var geometry = geojson.geometry;
    if (geometry !== null) {
        switch (geometry.type) {
            case "Polygon":
                coords = invariant_1.getCoords(geometry);
                break;
            case "LineString":
                coords = [invariant_1.getCoords(geometry)];
        }
        coords.forEach(function (coord) {
            var segments = createSegments(coord, geojson.properties);
            segments.forEach(function (segment) {
                segment.id = results.length;
                results.push(segment);
            });
        });
    }
}
/**
 * Create Segments from LineString coordinates
 *
 * @private
 * @param {Array<Array<number>>} coords LineString coordinates
 * @param {*} properties GeoJSON properties
 * @returns {Array<Feature<LineString>>} line segments
 */
function createSegments(coords, properties) {
    var segments = [];
    coords.reduce(function (previousCoords, currentCoords) {
        var segment = helpers_1.lineString([previousCoords, currentCoords], properties);
        segment.bbox = bbox(previousCoords, currentCoords);
        segments.push(segment);
        return currentCoords;
    });
    return segments;
}
/**
 * Create BBox between two coordinates (faster than @turf/bbox)
 *
 * @private
 * @param {Array<number>} coords1 Point coordinate
 * @param {Array<number>} coords2 Point coordinate
 * @returns {BBox} [west, south, east, north]
 */
function bbox(coords1, coords2) {
    var x1 = coords1[0];
    var y1 = coords1[1];
    var x2 = coords2[0];
    var y2 = coords2[1];
    var west = (x1 < x2) ? x1 : x2;
    var south = (y1 < y2) ? y1 : y2;
    var east = (x1 > x2) ? x1 : x2;
    var north = (y1 > y2) ? y1 : y2;
    return [west, south, east, north];
}
exports.default = lineSegment;


/***/ }),

/***/ "./node_modules/@turf/meta/index.js":
/*!******************************************!*\
  !*** ./node_modules/@turf/meta/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, '__esModule', { value: true });

var helpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");

/**
 * Callback for coordEach
 *
 * @callback coordEachCallback
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Iterate over coordinates in any GeoJSON object, similar to Array.forEach()
 *
 * @name coordEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentCoord, coordIndex, featureIndex, multiFeatureIndex)
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordEach(features, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function coordEach(geojson, callback, excludeWrapCoord) {
    // Handles null Geometry -- Skips this GeoJSON
    if (geojson === null) return;
    var j, k, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        coordIndex = 0,
        isGeometryCollection,
        type = geojson.type,
        isFeatureCollection = type === 'FeatureCollection',
        isFeature = type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (var featureIndex = 0; featureIndex < stop; featureIndex++) {
        geometryMaybeCollection = (isFeatureCollection ? geojson.features[featureIndex].geometry :
            (isFeature ? geojson.geometry : geojson));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (var geomIndex = 0; geomIndex < stopG; geomIndex++) {
            var multiFeatureIndex = 0;
            var geometryIndex = 0;
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[geomIndex] : geometryMaybeCollection;

            // Handles null Geometry -- Skips this geometry
            if (geometry === null) continue;
            coords = geometry.coordinates;
            var geomType = geometry.type;

            wrapShrink = (excludeWrapCoord && (geomType === 'Polygon' || geomType === 'MultiPolygon')) ? 1 : 0;

            switch (geomType) {
            case null:
                break;
            case 'Point':
                if (callback(coords, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                coordIndex++;
                multiFeatureIndex++;
                break;
            case 'LineString':
            case 'MultiPoint':
                for (j = 0; j < coords.length; j++) {
                    if (callback(coords[j], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                    coordIndex++;
                    if (geomType === 'MultiPoint') multiFeatureIndex++;
                }
                if (geomType === 'LineString') multiFeatureIndex++;
                break;
            case 'Polygon':
            case 'MultiLineString':
                for (j = 0; j < coords.length; j++) {
                    for (k = 0; k < coords[j].length - wrapShrink; k++) {
                        if (callback(coords[j][k], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                        coordIndex++;
                    }
                    if (geomType === 'MultiLineString') multiFeatureIndex++;
                    if (geomType === 'Polygon') geometryIndex++;
                }
                if (geomType === 'Polygon') multiFeatureIndex++;
                break;
            case 'MultiPolygon':
                for (j = 0; j < coords.length; j++) {
                    geometryIndex = 0;
                    for (k = 0; k < coords[j].length; k++) {
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++) {
                            if (callback(coords[j][k][l], coordIndex, featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
                            coordIndex++;
                        }
                        geometryIndex++;
                    }
                    multiFeatureIndex++;
                }
                break;
            case 'GeometryCollection':
                for (j = 0; j < geometry.geometries.length; j++)
                    if (coordEach(geometry.geometries[j], callback, excludeWrapCoord) === false) return false;
                break;
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}

/**
 * Callback for coordReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback coordReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Array<number>} currentCoord The current coordinate being processed.
 * @param {number} coordIndex The current index of the coordinate being processed.
 * Starts at index 0, if an initialValue is provided, and at index 1 otherwise.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 */

/**
 * Reduce coordinates in any GeoJSON object, similar to Array.reduce()
 *
 * @name coordReduce
 * @param {FeatureCollection|Geometry|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentCoord, coordIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @param {boolean} [excludeWrapCoord=false] whether or not to include the final coordinate of LinearRings that wraps the ring in its iteration.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.coordReduce(features, function (previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentCoord
 *   //=coordIndex
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentCoord;
 * });
 */
function coordReduce(geojson, callback, initialValue, excludeWrapCoord) {
    var previousValue = initialValue;
    coordEach(geojson, function (currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex) {
        if (coordIndex === 0 && initialValue === undefined) previousValue = currentCoord;
        else previousValue = callback(previousValue, currentCoord, coordIndex, featureIndex, multiFeatureIndex, geometryIndex);
    }, excludeWrapCoord);
    return previousValue;
}

/**
 * Callback for propEach
 *
 * @callback propEachCallback
 * @param {Object} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over properties in any GeoJSON object, similar to Array.forEach()
 *
 * @name propEach
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentProperties, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propEach(features, function (currentProperties, featureIndex) {
 *   //=currentProperties
 *   //=featureIndex
 * });
 */
function propEach(geojson, callback) {
    var i;
    switch (geojson.type) {
    case 'FeatureCollection':
        for (i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i].properties, i) === false) break;
        }
        break;
    case 'Feature':
        callback(geojson.properties, 0);
        break;
    }
}


/**
 * Callback for propReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback propReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {*} currentProperties The current Properties being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @name propReduce
 * @param {FeatureCollection|Feature} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentProperties, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.propReduce(features, function (previousValue, currentProperties, featureIndex) {
 *   //=previousValue
 *   //=currentProperties
 *   //=featureIndex
 *   return currentProperties
 * });
 */
function propReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    propEach(geojson, function (currentProperties, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentProperties;
        else previousValue = callback(previousValue, currentProperties, featureIndex);
    });
    return previousValue;
}

/**
 * Callback for featureEach
 *
 * @callback featureEachCallback
 * @param {Feature<any>} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name featureEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.featureEach(features, function (currentFeature, featureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 * });
 */
function featureEach(geojson, callback) {
    if (geojson.type === 'Feature') {
        callback(geojson, 0);
    } else if (geojson.type === 'FeatureCollection') {
        for (var i = 0; i < geojson.features.length; i++) {
            if (callback(geojson.features[i], i) === false) break;
        }
    }
}

/**
 * Callback for featureReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback featureReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name featureReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {"foo": "bar"}),
 *   turf.point([36, 53], {"hello": "world"})
 * ]);
 *
 * turf.featureReduce(features, function (previousValue, currentFeature, featureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   return currentFeature
 * });
 */
function featureReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    featureEach(geojson, function (currentFeature, featureIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex);
    });
    return previousValue;
}

/**
 * Get all coordinates from any GeoJSON object.
 *
 * @name coordAll
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @returns {Array<Array<number>>} coordinate position array
 * @example
 * var features = turf.featureCollection([
 *   turf.point([26, 37], {foo: 'bar'}),
 *   turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * var coords = turf.coordAll(features);
 * //= [[26, 37], [36, 53]]
 */
function coordAll(geojson) {
    var coords = [];
    coordEach(geojson, function (coord) {
        coords.push(coord);
    });
    return coords;
}

/**
 * Callback for geomEach
 *
 * @callback geomEachCallback
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Iterate over each geometry in any GeoJSON object, similar to Array.forEach()
 *
 * @name geomEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @returns {void}
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomEach(features, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 * });
 */
function geomEach(geojson, callback) {
    var i, j, g, geometry, stopG,
        geometryMaybeCollection,
        isGeometryCollection,
        featureProperties,
        featureBBox,
        featureId,
        featureIndex = 0,
        isFeatureCollection = geojson.type === 'FeatureCollection',
        isFeature = geojson.type === 'Feature',
        stop = isFeatureCollection ? geojson.features.length : 1;

    // This logic may look a little weird. The reason why it is that way
    // is because it's trying to be fast. GeoJSON supports multiple kinds
    // of objects at its root: FeatureCollection, Features, Geometries.
    // This function has the responsibility of handling all of them, and that
    // means that some of the `for` loops you see below actually just don't apply
    // to certain inputs. For instance, if you give this just a
    // Point geometry, then both loops are short-circuited and all we do
    // is gradually rename the input until it's called 'geometry'.
    //
    // This also aims to allocate as few resources as possible: just a
    // few numbers and booleans, rather than any temporary arrays as would
    // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? geojson.features[i].geometry :
            (isFeature ? geojson.geometry : geojson));
        featureProperties = (isFeatureCollection ? geojson.features[i].properties :
            (isFeature ? geojson.properties : {}));
        featureBBox = (isFeatureCollection ? geojson.features[i].bbox :
            (isFeature ? geojson.bbox : undefined));
        featureId = (isFeatureCollection ? geojson.features[i].id :
            (isFeature ? geojson.id : undefined));
        isGeometryCollection = (geometryMaybeCollection) ? geometryMaybeCollection.type === 'GeometryCollection' : false;
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
                geometryMaybeCollection.geometries[g] : geometryMaybeCollection;

            // Handle null Geometry
            if (geometry === null) {
                if (callback(null, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                continue;
            }
            switch (geometry.type) {
            case 'Point':
            case 'LineString':
            case 'MultiPoint':
            case 'Polygon':
            case 'MultiLineString':
            case 'MultiPolygon': {
                if (callback(geometry, featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                break;
            }
            case 'GeometryCollection': {
                for (j = 0; j < geometry.geometries.length; j++) {
                    if (callback(geometry.geometries[j], featureIndex, featureProperties, featureBBox, featureId) === false) return false;
                }
                break;
            }
            default:
                throw new Error('Unknown Geometry Type');
            }
        }
        // Only increase `featureIndex` per each feature
        featureIndex++;
    }
}

/**
 * Callback for geomReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback geomReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Geometry} currentGeometry The current Geometry being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {Object} featureProperties The current Feature Properties being processed.
 * @param {Array<number>} featureBBox The current Feature BBox being processed.
 * @param {number|string} featureId The current Feature Id being processed.
 */

/**
 * Reduce geometry in any GeoJSON object, similar to Array.reduce().
 *
 * @name geomReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.point([36, 53], {hello: 'world'})
 * ]);
 *
 * turf.geomReduce(features, function (previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
 *   //=previousValue
 *   //=currentGeometry
 *   //=featureIndex
 *   //=featureProperties
 *   //=featureBBox
 *   //=featureId
 *   return currentGeometry
 * });
 */
function geomReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    geomEach(geojson, function (currentGeometry, featureIndex, featureProperties, featureBBox, featureId) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentGeometry;
        else previousValue = callback(previousValue, currentGeometry, featureIndex, featureProperties, featureBBox, featureId);
    });
    return previousValue;
}

/**
 * Callback for flattenEach
 *
 * @callback flattenEachCallback
 * @param {Feature} currentFeature The current flattened feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Iterate over flattened features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @name flattenEach
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (currentFeature, featureIndex, multiFeatureIndex)
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenEach(features, function (currentFeature, featureIndex, multiFeatureIndex) {
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 * });
 */
function flattenEach(geojson, callback) {
    geomEach(geojson, function (geometry, featureIndex, properties, bbox, id) {
        // Callback for single geometry
        var type = (geometry === null) ? null : geometry.type;
        switch (type) {
        case null:
        case 'Point':
        case 'LineString':
        case 'Polygon':
            if (callback(helpers.feature(geometry, properties, {bbox: bbox, id: id}), featureIndex, 0) === false) return false;
            return;
        }

        var geomType;

        // Callback for multi-geometry
        switch (type) {
        case 'MultiPoint':
            geomType = 'Point';
            break;
        case 'MultiLineString':
            geomType = 'LineString';
            break;
        case 'MultiPolygon':
            geomType = 'Polygon';
            break;
        }

        for (var multiFeatureIndex = 0; multiFeatureIndex < geometry.coordinates.length; multiFeatureIndex++) {
            var coordinate = geometry.coordinates[multiFeatureIndex];
            var geom = {
                type: geomType,
                coordinates: coordinate
            };
            if (callback(helpers.feature(geom, properties), featureIndex, multiFeatureIndex) === false) return false;
        }
    });
}

/**
 * Callback for flattenReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback flattenReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature} currentFeature The current Feature being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 */

/**
 * Reduce flattened features in any GeoJSON object, similar to Array.reduce().
 *
 * @name flattenReduce
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON object
 * @param {Function} callback a method that takes (previousValue, currentFeature, featureIndex, multiFeatureIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var features = turf.featureCollection([
 *     turf.point([26, 37], {foo: 'bar'}),
 *     turf.multiPoint([[40, 30], [36, 53]], {hello: 'world'})
 * ]);
 *
 * turf.flattenReduce(features, function (previousValue, currentFeature, featureIndex, multiFeatureIndex) {
 *   //=previousValue
 *   //=currentFeature
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   return currentFeature
 * });
 */
function flattenReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    flattenEach(geojson, function (currentFeature, featureIndex, multiFeatureIndex) {
        if (featureIndex === 0 && multiFeatureIndex === 0 && initialValue === undefined) previousValue = currentFeature;
        else previousValue = callback(previousValue, currentFeature, featureIndex, multiFeatureIndex);
    });
    return previousValue;
}

/**
 * Callback for segmentEach
 *
 * @callback segmentEachCallback
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 * @returns {void}
 */

/**
 * Iterate over 2-vertex line segment in any GeoJSON object, similar to Array.forEach()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex)
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentEach(polygon, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //=currentSegment
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   //=segmentIndex
 * });
 *
 * // Calculate the total number of segments
 * var total = 0;
 * turf.segmentEach(polygon, function () {
 *     total++;
 * });
 */
function segmentEach(geojson, callback) {
    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        var segmentIndex = 0;

        // Exclude null Geometries
        if (!feature.geometry) return;
        // (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
        var type = feature.geometry.type;
        if (type === 'Point' || type === 'MultiPoint') return;

        // Generate 2-vertex line segments
        var previousCoords;
        var previousFeatureIndex = 0;
        var previousMultiIndex = 0;
        var prevGeomIndex = 0;
        if (coordEach(feature, function (currentCoord, coordIndex, featureIndexCoord, multiPartIndexCoord, geometryIndex) {
            // Simulating a meta.coordReduce() since `reduce` operations cannot be stopped by returning `false`
            if (previousCoords === undefined || featureIndex > previousFeatureIndex || multiPartIndexCoord > previousMultiIndex || geometryIndex > prevGeomIndex) {
                previousCoords = currentCoord;
                previousFeatureIndex = featureIndex;
                previousMultiIndex = multiPartIndexCoord;
                prevGeomIndex = geometryIndex;
                segmentIndex = 0;
                return;
            }
            var currentSegment = helpers.lineString([previousCoords, currentCoord], feature.properties);
            if (callback(currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) === false) return false;
            segmentIndex++;
            previousCoords = currentCoord;
        }) === false) return false;
    });
}

/**
 * Callback for segmentReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback segmentReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentSegment The current Segment being processed.
 * @param {number} featureIndex The current index of the Feature being processed.
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed.
 * @param {number} geometryIndex The current index of the Geometry being processed.
 * @param {number} segmentIndex The current index of the Segment being processed.
 */

/**
 * Reduce 2-vertex line segment in any GeoJSON object, similar to Array.reduce()
 * (Multi)Point geometries do not contain segments therefore they are ignored during this operation.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson any GeoJSON
 * @param {Function} callback a method that takes (previousValue, currentSegment, currentIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {void}
 * @example
 * var polygon = turf.polygon([[[-50, 5], [-40, -10], [-50, -10], [-40, 5], [-50, 5]]]);
 *
 * // Iterate over GeoJSON by 2-vertex segments
 * turf.segmentReduce(polygon, function (previousSegment, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
 *   //= previousSegment
 *   //= currentSegment
 *   //= featureIndex
 *   //= multiFeatureIndex
 *   //= geometryIndex
 *   //= segmentInex
 *   return currentSegment
 * });
 *
 * // Calculate the total number of segments
 * var initialValue = 0
 * var total = turf.segmentReduce(polygon, function (previousValue) {
 *     previousValue++;
 *     return previousValue;
 * }, initialValue);
 */
function segmentReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    var started = false;
    segmentEach(geojson, function (currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex) {
        if (started === false && initialValue === undefined) previousValue = currentSegment;
        else previousValue = callback(previousValue, currentSegment, featureIndex, multiFeatureIndex, geometryIndex, segmentIndex);
        started = true;
    });
    return previousValue;
}

/**
 * Callback for lineEach
 *
 * @callback lineEachCallback
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Iterate over line or ring coordinates in LineString, Polygon, MultiLineString, MultiPolygon Features or Geometries,
 * similar to Array.forEach.
 *
 * @name lineEach
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @example
 * var multiLine = turf.multiLineString([
 *   [[26, 37], [35, 45]],
 *   [[36, 53], [38, 50], [41, 55]]
 * ]);
 *
 * turf.lineEach(multiLine, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 * });
 */
function lineEach(geojson, callback) {
    // validation
    if (!geojson) throw new Error('geojson is required');

    flattenEach(geojson, function (feature, featureIndex, multiFeatureIndex) {
        if (feature.geometry === null) return;
        var type = feature.geometry.type;
        var coords = feature.geometry.coordinates;
        switch (type) {
        case 'LineString':
            if (callback(feature, featureIndex, multiFeatureIndex, 0, 0) === false) return false;
            break;
        case 'Polygon':
            for (var geometryIndex = 0; geometryIndex < coords.length; geometryIndex++) {
                if (callback(helpers.lineString(coords[geometryIndex], feature.properties), featureIndex, multiFeatureIndex, geometryIndex) === false) return false;
            }
            break;
        }
    });
}

/**
 * Callback for lineReduce
 *
 * The first time the callback function is called, the values provided as arguments depend
 * on whether the reduce method has an initialValue argument.
 *
 * If an initialValue is provided to the reduce method:
 *  - The previousValue argument is initialValue.
 *  - The currentValue argument is the value of the first element present in the array.
 *
 * If an initialValue is not provided:
 *  - The previousValue argument is the value of the first element present in the array.
 *  - The currentValue argument is the value of the second element present in the array.
 *
 * @callback lineReduceCallback
 * @param {*} previousValue The accumulated value previously returned in the last invocation
 * of the callback, or initialValue, if supplied.
 * @param {Feature<LineString>} currentLine The current LineString|LinearRing being processed.
 * @param {number} featureIndex The current index of the Feature being processed
 * @param {number} multiFeatureIndex The current index of the Multi-Feature being processed
 * @param {number} geometryIndex The current index of the Geometry being processed
 */

/**
 * Reduce features in any GeoJSON object, similar to Array.reduce().
 *
 * @name lineReduce
 * @param {Geometry|Feature<LineString|Polygon|MultiLineString|MultiPolygon>} geojson object
 * @param {Function} callback a method that takes (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex)
 * @param {*} [initialValue] Value to use as the first argument to the first call of the callback.
 * @returns {*} The value that results from the reduction.
 * @example
 * var multiPoly = turf.multiPolygon([
 *   turf.polygon([[[12,48],[2,41],[24,38],[12,48]], [[9,44],[13,41],[13,45],[9,44]]]),
 *   turf.polygon([[[5, 5], [0, 0], [2, 2], [4, 4], [5, 5]]])
 * ]);
 *
 * turf.lineReduce(multiPoly, function (previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
 *   //=previousValue
 *   //=currentLine
 *   //=featureIndex
 *   //=multiFeatureIndex
 *   //=geometryIndex
 *   return currentLine
 * });
 */
function lineReduce(geojson, callback, initialValue) {
    var previousValue = initialValue;
    lineEach(geojson, function (currentLine, featureIndex, multiFeatureIndex, geometryIndex) {
        if (featureIndex === 0 && initialValue === undefined) previousValue = currentLine;
        else previousValue = callback(previousValue, currentLine, featureIndex, multiFeatureIndex, geometryIndex);
    });
    return previousValue;
}

/**
 * Finds a particular 2-vertex LineString Segment from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 * Point & MultiPoint will always return null.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.segmentIndex=0] Segment Index
 * @param {Object} [options.properties={}] Translate Properties to output LineString
 * @param {BBox} [options.bbox={}] Translate BBox to output LineString
 * @param {number|string} [options.id={}] Translate Id to output LineString
 * @returns {Feature<LineString>} 2-vertex GeoJSON Feature LineString
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findSegment(multiLine);
 * // => Feature<LineString<[[10, 10], [50, 30]]>>
 *
 * // First Segment of 2nd Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: 1});
 * // => Feature<LineString<[[-10, -10], [-50, -30]]>>
 *
 * // Last Segment of Last Multi Feature
 * turf.findSegment(multiLine, {multiFeatureIndex: -1, segmentIndex: -1});
 * // => Feature<LineString<[[-50, -30], [-30, -40]]>>
 */
function findSegment(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var segmentIndex = options.segmentIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find SegmentIndex
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
        if (segmentIndex < 0) segmentIndex = coords.length + segmentIndex - 1;
        return helpers.lineString([coords[segmentIndex], coords[segmentIndex + 1]], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[geometryIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[geometryIndex][segmentIndex], coords[geometryIndex][segmentIndex + 1]], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex].length + segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][segmentIndex], coords[multiFeatureIndex][segmentIndex + 1]], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (segmentIndex < 0) segmentIndex = coords[multiFeatureIndex][geometryIndex].length - segmentIndex - 1;
        return helpers.lineString([coords[multiFeatureIndex][geometryIndex][segmentIndex], coords[multiFeatureIndex][geometryIndex][segmentIndex + 1]], properties, options);
    }
    throw new Error('geojson is invalid');
}

/**
 * Finds a particular Point from a GeoJSON using `@turf/meta` indexes.
 *
 * Negative indexes are permitted.
 *
 * @param {FeatureCollection|Feature|Geometry} geojson Any GeoJSON Feature or Geometry
 * @param {Object} [options={}] Optional parameters
 * @param {number} [options.featureIndex=0] Feature Index
 * @param {number} [options.multiFeatureIndex=0] Multi-Feature Index
 * @param {number} [options.geometryIndex=0] Geometry Index
 * @param {number} [options.coordIndex=0] Coord Index
 * @param {Object} [options.properties={}] Translate Properties to output Point
 * @param {BBox} [options.bbox={}] Translate BBox to output Point
 * @param {number|string} [options.id={}] Translate Id to output Point
 * @returns {Feature<Point>} 2-vertex GeoJSON Feature Point
 * @example
 * var multiLine = turf.multiLineString([
 *     [[10, 10], [50, 30], [30, 40]],
 *     [[-10, -10], [-50, -30], [-30, -40]]
 * ]);
 *
 * // First Segment (defaults are 0)
 * turf.findPoint(multiLine);
 * // => Feature<Point<[10, 10]>>
 *
 * // First Segment of the 2nd Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: 1});
 * // => Feature<Point<[-10, -10]>>
 *
 * // Last Segment of last Multi-Feature
 * turf.findPoint(multiLine, {multiFeatureIndex: -1, coordIndex: -1});
 * // => Feature<Point<[-30, -40]>>
 */
function findPoint(geojson, options) {
    // Optional Parameters
    options = options || {};
    if (!helpers.isObject(options)) throw new Error('options is invalid');
    var featureIndex = options.featureIndex || 0;
    var multiFeatureIndex = options.multiFeatureIndex || 0;
    var geometryIndex = options.geometryIndex || 0;
    var coordIndex = options.coordIndex || 0;

    // Find FeatureIndex
    var properties = options.properties;
    var geometry;

    switch (geojson.type) {
    case 'FeatureCollection':
        if (featureIndex < 0) featureIndex = geojson.features.length + featureIndex;
        properties = properties || geojson.features[featureIndex].properties;
        geometry = geojson.features[featureIndex].geometry;
        break;
    case 'Feature':
        properties = properties || geojson.properties;
        geometry = geojson.geometry;
        break;
    case 'Point':
    case 'MultiPoint':
        return null;
    case 'LineString':
    case 'Polygon':
    case 'MultiLineString':
    case 'MultiPolygon':
        geometry = geojson;
        break;
    default:
        throw new Error('geojson is invalid');
    }

    // Find Coord Index
    if (geometry === null) return null;
    var coords = geometry.coordinates;
    switch (geometry.type) {
    case 'Point':
        return helpers.point(coords, properties, options);
    case 'MultiPoint':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        return helpers.point(coords[multiFeatureIndex], properties, options);
    case 'LineString':
        if (coordIndex < 0) coordIndex = coords.length + coordIndex;
        return helpers.point(coords[coordIndex], properties, options);
    case 'Polygon':
        if (geometryIndex < 0) geometryIndex = coords.length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[geometryIndex].length + coordIndex;
        return helpers.point(coords[geometryIndex][coordIndex], properties, options);
    case 'MultiLineString':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex].length + coordIndex;
        return helpers.point(coords[multiFeatureIndex][coordIndex], properties, options);
    case 'MultiPolygon':
        if (multiFeatureIndex < 0) multiFeatureIndex = coords.length + multiFeatureIndex;
        if (geometryIndex < 0) geometryIndex = coords[multiFeatureIndex].length + geometryIndex;
        if (coordIndex < 0) coordIndex = coords[multiFeatureIndex][geometryIndex].length - coordIndex;
        return helpers.point(coords[multiFeatureIndex][geometryIndex][coordIndex], properties, options);
    }
    throw new Error('geojson is invalid');
}

exports.coordEach = coordEach;
exports.coordReduce = coordReduce;
exports.propEach = propEach;
exports.propReduce = propReduce;
exports.featureEach = featureEach;
exports.featureReduce = featureReduce;
exports.coordAll = coordAll;
exports.geomEach = geomEach;
exports.geomReduce = geomReduce;
exports.flattenEach = flattenEach;
exports.flattenReduce = flattenReduce;
exports.segmentEach = segmentEach;
exports.segmentReduce = segmentReduce;
exports.lineEach = lineEach;
exports.lineReduce = lineReduce;
exports.findSegment = findSegment;
exports.findPoint = findPoint;


/***/ }),

/***/ "./node_modules/@turf/nearest-point-on-line/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/@turf/nearest-point-on-line/index.js ***!
  \***********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var bearing_1 = __webpack_require__(/*! @turf/bearing */ "./node_modules/@turf/bearing/index.js");
var distance_1 = __webpack_require__(/*! @turf/distance */ "./node_modules/@turf/distance/index.js");
var destination_1 = __webpack_require__(/*! @turf/destination */ "./node_modules/@turf/destination/index.js");
var line_intersect_1 = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js");
var meta_1 = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var helpers_1 = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var invariant_1 = __webpack_require__(/*! @turf/invariant */ "./node_modules/@turf/invariant/index.js");
/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the (Multi)LineString.
 *
 * @name nearestPointOnLine
 * @param {Geometry|Feature<LineString|MultiLineString>} lines lines to snap to
 * @param {Geometry|Feature<Point>|number[]} pt point to snap from
 * @param {Object} [options={}] Optional parameters
 * @param {string} [options.units='kilometers'] can be degrees, radians, miles, or kilometers
 * @returns {Feature<Point>} closest point on the `line` to `point`. The properties object will contain three values: `index`: closest point was found on nth line part, `dist`: distance between pt and the closest point, `location`: distance along the line between start and the closest point.
 * @example
 * var line = turf.lineString([
 *     [-77.031669, 38.878605],
 *     [-77.029609, 38.881946],
 *     [-77.020339, 38.884084],
 *     [-77.025661, 38.885821],
 *     [-77.021884, 38.889563],
 *     [-77.019824, 38.892368]
 * ]);
 * var pt = turf.point([-77.037076, 38.884017]);
 *
 * var snapped = turf.nearestPointOnLine(line, pt, {units: 'miles'});
 *
 * //addToMap
 * var addToMap = [line, pt, snapped];
 * snapped.properties['marker-color'] = '#00f';
 */
function nearestPointOnLine(lines, pt, options) {
    if (options === void 0) { options = {}; }
    var closestPt = helpers_1.point([Infinity, Infinity], {
        dist: Infinity
    });
    var length = 0.0;
    meta_1.flattenEach(lines, function (line) {
        var coords = invariant_1.getCoords(line);
        for (var i = 0; i < coords.length - 1; i++) {
            //start
            var start = helpers_1.point(coords[i]);
            start.properties.dist = distance_1.default(pt, start, options);
            //stop
            var stop_1 = helpers_1.point(coords[i + 1]);
            stop_1.properties.dist = distance_1.default(pt, stop_1, options);
            // sectionLength
            var sectionLength = distance_1.default(start, stop_1, options);
            //perpendicular
            var heightDistance = Math.max(start.properties.dist, stop_1.properties.dist);
            var direction = bearing_1.default(start, stop_1);
            var perpendicularPt1 = destination_1.default(pt, heightDistance, direction + 90, options);
            var perpendicularPt2 = destination_1.default(pt, heightDistance, direction - 90, options);
            var intersect = line_intersect_1.default(helpers_1.lineString([perpendicularPt1.geometry.coordinates, perpendicularPt2.geometry.coordinates]), helpers_1.lineString([start.geometry.coordinates, stop_1.geometry.coordinates]));
            var intersectPt = null;
            if (intersect.features.length > 0) {
                intersectPt = intersect.features[0];
                intersectPt.properties.dist = distance_1.default(pt, intersectPt, options);
                intersectPt.properties.location = length + distance_1.default(start, intersectPt, options);
            }
            if (start.properties.dist < closestPt.properties.dist) {
                closestPt = start;
                closestPt.properties.index = i;
                closestPt.properties.location = length;
            }
            if (stop_1.properties.dist < closestPt.properties.dist) {
                closestPt = stop_1;
                closestPt.properties.index = i + 1;
                closestPt.properties.location = length + sectionLength;
            }
            if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
                closestPt = intersectPt;
                closestPt.properties.index = i;
            }
            // update length
            length += sectionLength;
        }
    });
    return closestPt;
}
exports.default = nearestPointOnLine;


/***/ }),

/***/ "./node_modules/affine-hull/aff.js":
/*!*****************************************!*\
  !*** ./node_modules/affine-hull/aff.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = affineHull

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")

function linearlyIndependent(points, d) {
  var nhull = new Array(d+1)
  for(var i=0; i<points.length; ++i) {
    nhull[i] = points[i]
  }
  for(var i=0; i<=points.length; ++i) {
    for(var j=points.length; j<=d; ++j) {
      var x = new Array(d)
      for(var k=0; k<d; ++k) {
        x[k] = Math.pow(j+1-i, k)
      }
      nhull[j] = x
    }
    var o = orient.apply(void 0, nhull)
    if(o) {
      return true
    }
  }
  return false
}

function affineHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  }
  if(n === 1) {
    return [0]
  }
  var d = points[0].length
  var frame = [ points[0] ]
  var index = [ 0 ]
  for(var i=1; i<n; ++i) {
    frame.push(points[i])
    if(!linearlyIndependent(frame, d)) {
      frame.pop()
      continue
    }
    index.push(i)
    if(index.length === d+1) {
      return index
    }
  }
  return index
}

/***/ }),

/***/ "./node_modules/bit-twiddle/twiddle.js":
/*!*********************************************!*\
  !*** ./node_modules/bit-twiddle/twiddle.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * Bit twiddling hacks for JavaScript.
 *
 * Author: Mikola Lysenko
 *
 * Ported from Stanford bit twiddling hack library:
 *    http://graphics.stanford.edu/~seander/bithacks.html
 */

 "use restrict";

//Number of bits in an integer
var INT_BITS = 32;

//Constants
exports.INT_BITS  = INT_BITS;
exports.INT_MAX   =  0x7fffffff;
exports.INT_MIN   = -1<<(INT_BITS-1);

//Returns -1, 0, +1 depending on sign of x
exports.sign = function(v) {
  return (v > 0) - (v < 0);
}

//Computes absolute value of integer
exports.abs = function(v) {
  var mask = v >> (INT_BITS-1);
  return (v ^ mask) - mask;
}

//Computes minimum of integers x and y
exports.min = function(x, y) {
  return y ^ ((x ^ y) & -(x < y));
}

//Computes maximum of integers x and y
exports.max = function(x, y) {
  return x ^ ((x ^ y) & -(x < y));
}

//Checks if a number is a power of two
exports.isPow2 = function(v) {
  return !(v & (v-1)) && (!!v);
}

//Computes log base 2 of v
exports.log2 = function(v) {
  var r, shift;
  r =     (v > 0xFFFF) << 4; v >>>= r;
  shift = (v > 0xFF  ) << 3; v >>>= shift; r |= shift;
  shift = (v > 0xF   ) << 2; v >>>= shift; r |= shift;
  shift = (v > 0x3   ) << 1; v >>>= shift; r |= shift;
  return r | (v >> 1);
}

//Computes log base 10 of v
exports.log10 = function(v) {
  return  (v >= 1000000000) ? 9 : (v >= 100000000) ? 8 : (v >= 10000000) ? 7 :
          (v >= 1000000) ? 6 : (v >= 100000) ? 5 : (v >= 10000) ? 4 :
          (v >= 1000) ? 3 : (v >= 100) ? 2 : (v >= 10) ? 1 : 0;
}

//Counts number of bits
exports.popCount = function(v) {
  v = v - ((v >>> 1) & 0x55555555);
  v = (v & 0x33333333) + ((v >>> 2) & 0x33333333);
  return ((v + (v >>> 4) & 0xF0F0F0F) * 0x1010101) >>> 24;
}

//Counts number of trailing zeros
function countTrailingZeros(v) {
  var c = 32;
  v &= -v;
  if (v) c--;
  if (v & 0x0000FFFF) c -= 16;
  if (v & 0x00FF00FF) c -= 8;
  if (v & 0x0F0F0F0F) c -= 4;
  if (v & 0x33333333) c -= 2;
  if (v & 0x55555555) c -= 1;
  return c;
}
exports.countTrailingZeros = countTrailingZeros;

//Rounds to next power of 2
exports.nextPow2 = function(v) {
  v += v === 0;
  --v;
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v + 1;
}

//Rounds down to previous power of 2
exports.prevPow2 = function(v) {
  v |= v >>> 1;
  v |= v >>> 2;
  v |= v >>> 4;
  v |= v >>> 8;
  v |= v >>> 16;
  return v - (v>>>1);
}

//Computes parity of word
exports.parity = function(v) {
  v ^= v >>> 16;
  v ^= v >>> 8;
  v ^= v >>> 4;
  v &= 0xf;
  return (0x6996 >>> v) & 1;
}

var REVERSE_TABLE = new Array(256);

(function(tab) {
  for(var i=0; i<256; ++i) {
    var v = i, r = i, s = 7;
    for (v >>>= 1; v; v >>>= 1) {
      r <<= 1;
      r |= v & 1;
      --s;
    }
    tab[i] = (r << s) & 0xff;
  }
})(REVERSE_TABLE);

//Reverse bits in a 32 bit word
exports.reverse = function(v) {
  return  (REVERSE_TABLE[ v         & 0xff] << 24) |
          (REVERSE_TABLE[(v >>> 8)  & 0xff] << 16) |
          (REVERSE_TABLE[(v >>> 16) & 0xff] << 8)  |
           REVERSE_TABLE[(v >>> 24) & 0xff];
}

//Interleave bits of 2 coordinates with 16 bits.  Useful for fast quadtree codes
exports.interleave2 = function(x, y) {
  x &= 0xFFFF;
  x = (x | (x << 8)) & 0x00FF00FF;
  x = (x | (x << 4)) & 0x0F0F0F0F;
  x = (x | (x << 2)) & 0x33333333;
  x = (x | (x << 1)) & 0x55555555;

  y &= 0xFFFF;
  y = (y | (y << 8)) & 0x00FF00FF;
  y = (y | (y << 4)) & 0x0F0F0F0F;
  y = (y | (y << 2)) & 0x33333333;
  y = (y | (y << 1)) & 0x55555555;

  return x | (y << 1);
}

//Extracts the nth interleaved component
exports.deinterleave2 = function(v, n) {
  v = (v >>> n) & 0x55555555;
  v = (v | (v >>> 1))  & 0x33333333;
  v = (v | (v >>> 2))  & 0x0F0F0F0F;
  v = (v | (v >>> 4))  & 0x00FF00FF;
  v = (v | (v >>> 16)) & 0x000FFFF;
  return (v << 16) >> 16;
}


//Interleave bits of 3 coordinates, each with 10 bits.  Useful for fast octree codes
exports.interleave3 = function(x, y, z) {
  x &= 0x3FF;
  x  = (x | (x<<16)) & 4278190335;
  x  = (x | (x<<8))  & 251719695;
  x  = (x | (x<<4))  & 3272356035;
  x  = (x | (x<<2))  & 1227133513;

  y &= 0x3FF;
  y  = (y | (y<<16)) & 4278190335;
  y  = (y | (y<<8))  & 251719695;
  y  = (y | (y<<4))  & 3272356035;
  y  = (y | (y<<2))  & 1227133513;
  x |= (y << 1);
  
  z &= 0x3FF;
  z  = (z | (z<<16)) & 4278190335;
  z  = (z | (z<<8))  & 251719695;
  z  = (z | (z<<4))  & 3272356035;
  z  = (z | (z<<2))  & 1227133513;
  
  return x | (z << 2);
}

//Extracts nth interleaved component of a 3-tuple
exports.deinterleave3 = function(v, n) {
  v = (v >>> n)       & 1227133513;
  v = (v | (v>>>2))   & 3272356035;
  v = (v | (v>>>4))   & 251719695;
  v = (v | (v>>>8))   & 4278190335;
  v = (v | (v>>>16))  & 0x3FF;
  return (v<<22)>>22;
}

//Computes next combination in colexicographic order (this is mistakenly called nextPermutation on the bit twiddling hacks page)
exports.nextCombination = function(v) {
  var t = v | (v - 1);
  return (t + 1) | (((~t & -~t) - 1) >>> (countTrailingZeros(v) + 1));
}



/***/ }),

/***/ "./node_modules/convex-hull/ch.js":
/*!****************************************!*\
  !*** ./node_modules/convex-hull/ch.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var convexHull1d = __webpack_require__(/*! ./lib/ch1d */ "./node_modules/convex-hull/lib/ch1d.js")
var convexHull2d = __webpack_require__(/*! ./lib/ch2d */ "./node_modules/convex-hull/lib/ch2d.js")
var convexHullnd = __webpack_require__(/*! ./lib/chnd */ "./node_modules/convex-hull/lib/chnd.js")

module.exports = convexHull

function convexHull(points) {
  var n = points.length
  if(n === 0) {
    return []
  } else if(n === 1) {
    return [[0]]
  }
  var d = points[0].length
  if(d === 0) {
    return []
  } else if(d === 1) {
    return convexHull1d(points)
  } else if(d === 2) {
    return convexHull2d(points)
  }
  return convexHullnd(points, d)
}

/***/ }),

/***/ "./node_modules/convex-hull/lib/ch1d.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/ch1d.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHull1d

function convexHull1d(points) {
  var lo = 0
  var hi = 0
  for(var i=1; i<points.length; ++i) {
    if(points[i][0] < points[lo][0]) {
      lo = i
    }
    if(points[i][0] > points[hi][0]) {
      hi = i
    }
  }
  if(lo < hi) {
    return [[lo], [hi]]
  } else if(lo > hi) {
    return [[hi], [lo]]
  } else {
    return [[lo]]
  }
}

/***/ }),

/***/ "./node_modules/convex-hull/lib/ch2d.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/ch2d.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHull2D

var monotoneHull = __webpack_require__(/*! monotone-convex-hull-2d */ "./node_modules/monotone-convex-hull-2d/index.js")

function convexHull2D(points) {
  var hull = monotoneHull(points)
  var h = hull.length
  if(h <= 2) {
    return []
  }
  var edges = new Array(h)
  var a = hull[h-1]
  for(var i=0; i<h; ++i) {
    var b = hull[i]
    edges[i] = [a,b]
    a = b
  }
  return edges
}


/***/ }),

/***/ "./node_modules/convex-hull/lib/chnd.js":
/*!**********************************************!*\
  !*** ./node_modules/convex-hull/lib/chnd.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = convexHullnD

var ich = __webpack_require__(/*! incremental-convex-hull */ "./node_modules/incremental-convex-hull/ich.js")
var aff = __webpack_require__(/*! affine-hull */ "./node_modules/affine-hull/aff.js")

function permute(points, front) {
  var n = points.length
  var npoints = new Array(n)
  for(var i=0; i<front.length; ++i) {
    npoints[i] = points[front[i]]
  }
  var ptr = front.length
  for(var i=0; i<n; ++i) {
    if(front.indexOf(i) < 0) {
      npoints[ptr++] = points[i]
    }
  }
  return npoints
}

function invPermute(cells, front) {
  var nc = cells.length
  var nf = front.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var x = c[j]
      if(x < nf) {
        c[j] = front[x]
      } else {
        x = x - nf
        for(var k=0; k<nf; ++k) {
          if(x >= front[k]) {
            x += 1
          }
        }
        c[j] = x
      }
    }
  }
  return cells
}

function convexHullnD(points, d) {
  try {
    return ich(points, true)
  } catch(e) {
    //If point set is degenerate, try to find a basis and rerun it
    var ah = aff(points)
    if(ah.length <= d) {
      //No basis, no try
      return []
    }
    var npoints = permute(points, ah)
    var nhull   = ich(npoints, true)
    return invPermute(nhull, ah)
  }
}

/***/ }),

/***/ "./node_modules/deep-equal/index.js":
/*!******************************************!*\
  !*** ./node_modules/deep-equal/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var pSlice = Array.prototype.slice;
var objectKeys = __webpack_require__(/*! ./lib/keys.js */ "./node_modules/deep-equal/lib/keys.js");
var isArguments = __webpack_require__(/*! ./lib/is_arguments.js */ "./node_modules/deep-equal/lib/is_arguments.js");

var deepEqual = module.exports = function (actual, expected, opts) {
  if (!opts) opts = {};
  // 7.1. All identical values are equivalent, as determined by ===.
  if (actual === expected) {
    return true;

  } else if (actual instanceof Date && expected instanceof Date) {
    return actual.getTime() === expected.getTime();

  // 7.3. Other pairs that do not both pass typeof value == 'object',
  // equivalence is determined by ==.
  } else if (!actual || !expected || typeof actual != 'object' && typeof expected != 'object') {
    return opts.strict ? actual === expected : actual == expected;

  // 7.4. For all other Object pairs, including Array objects, equivalence is
  // determined by having the same number of owned properties (as verified
  // with Object.prototype.hasOwnProperty.call), the same set of keys
  // (although not necessarily the same order), equivalent values for every
  // corresponding key, and an identical 'prototype' property. Note: this
  // accounts for both named and indexed properties on Arrays.
  } else {
    return objEquiv(actual, expected, opts);
  }
}

function isUndefinedOrNull(value) {
  return value === null || value === undefined;
}

function isBuffer (x) {
  if (!x || typeof x !== 'object' || typeof x.length !== 'number') return false;
  if (typeof x.copy !== 'function' || typeof x.slice !== 'function') {
    return false;
  }
  if (x.length > 0 && typeof x[0] !== 'number') return false;
  return true;
}

function objEquiv(a, b, opts) {
  var i, key;
  if (isUndefinedOrNull(a) || isUndefinedOrNull(b))
    return false;
  // an identical 'prototype' property.
  if (a.prototype !== b.prototype) return false;
  //~~~I've managed to break Object.keys through screwy arguments passing.
  //   Converting to array solves the problem.
  if (isArguments(a)) {
    if (!isArguments(b)) {
      return false;
    }
    a = pSlice.call(a);
    b = pSlice.call(b);
    return deepEqual(a, b, opts);
  }
  if (isBuffer(a)) {
    if (!isBuffer(b)) {
      return false;
    }
    if (a.length !== b.length) return false;
    for (i = 0; i < a.length; i++) {
      if (a[i] !== b[i]) return false;
    }
    return true;
  }
  try {
    var ka = objectKeys(a),
        kb = objectKeys(b);
  } catch (e) {//happens when one is a string literal and the other isn't
    return false;
  }
  // having the same number of owned properties (keys incorporates
  // hasOwnProperty)
  if (ka.length != kb.length)
    return false;
  //the same set of keys (although not necessarily the same order),
  ka.sort();
  kb.sort();
  //~~~cheap key test
  for (i = ka.length - 1; i >= 0; i--) {
    if (ka[i] != kb[i])
      return false;
  }
  //equivalent values for every corresponding key, and
  //~~~possibly expensive deep test
  for (i = ka.length - 1; i >= 0; i--) {
    key = ka[i];
    if (!deepEqual(a[key], b[key], opts)) return false;
  }
  return typeof a === typeof b;
}


/***/ }),

/***/ "./node_modules/deep-equal/lib/is_arguments.js":
/*!*****************************************************!*\
  !*** ./node_modules/deep-equal/lib/is_arguments.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

var supportsArgumentsClass = (function(){
  return Object.prototype.toString.call(arguments)
})() == '[object Arguments]';

exports = module.exports = supportsArgumentsClass ? supported : unsupported;

exports.supported = supported;
function supported(object) {
  return Object.prototype.toString.call(object) == '[object Arguments]';
};

exports.unsupported = unsupported;
function unsupported(object){
  return object &&
    typeof object == 'object' &&
    typeof object.length == 'number' &&
    Object.prototype.hasOwnProperty.call(object, 'callee') &&
    !Object.prototype.propertyIsEnumerable.call(object, 'callee') ||
    false;
};


/***/ }),

/***/ "./node_modules/deep-equal/lib/keys.js":
/*!*********************************************!*\
  !*** ./node_modules/deep-equal/lib/keys.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

exports = module.exports = typeof Object.keys === 'function'
  ? Object.keys : shim;

exports.shim = shim;
function shim (obj) {
  var keys = [];
  for (var key in obj) keys.push(key);
  return keys;
}


/***/ }),

/***/ "./node_modules/earcut/src/earcut.js":
/*!*******************************************!*\
  !*** ./node_modules/earcut/src/earcut.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = earcut;
module.exports.default = earcut;

function earcut(data, holeIndices, dim) {

    dim = dim || 2;

    var hasHoles = holeIndices && holeIndices.length,
        outerLen = hasHoles ? holeIndices[0] * dim : data.length,
        outerNode = linkedList(data, 0, outerLen, dim, true),
        triangles = [];

    if (!outerNode || outerNode.next === outerNode.prev) return triangles;

    var minX, minY, maxX, maxY, x, y, invSize;

    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);

    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
    if (data.length > 80 * dim) {
        minX = maxX = data[0];
        minY = maxY = data[1];

        for (var i = dim; i < outerLen; i += dim) {
            x = data[i];
            y = data[i + 1];
            if (x < minX) minX = x;
            if (y < minY) minY = y;
            if (x > maxX) maxX = x;
            if (y > maxY) maxY = y;
        }

        // minX, minY and invSize are later used to transform coords into integers for z-order calculation
        invSize = Math.max(maxX - minX, maxY - minY);
        invSize = invSize !== 0 ? 1 / invSize : 0;
    }

    earcutLinked(outerNode, triangles, dim, minX, minY, invSize);

    return triangles;
}

// create a circular doubly linked list from polygon points in the specified winding order
function linkedList(data, start, end, dim, clockwise) {
    var i, last;

    if (clockwise === (signedArea(data, start, end, dim) > 0)) {
        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);
    } else {
        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);
    }

    if (last && equals(last, last.next)) {
        removeNode(last);
        last = last.next;
    }

    return last;
}

// eliminate colinear or duplicate points
function filterPoints(start, end) {
    if (!start) return start;
    if (!end) end = start;

    var p = start,
        again;
    do {
        again = false;

        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {
            removeNode(p);
            p = end = p.prev;
            if (p === p.next) break;
            again = true;

        } else {
            p = p.next;
        }
    } while (again || p !== end);

    return end;
}

// main ear slicing loop which triangulates a polygon (given as a linked list)
function earcutLinked(ear, triangles, dim, minX, minY, invSize, pass) {
    if (!ear) return;

    // interlink polygon nodes in z-order
    if (!pass && invSize) indexCurve(ear, minX, minY, invSize);

    var stop = ear,
        prev, next;

    // iterate through ears, slicing them one by one
    while (ear.prev !== ear.next) {
        prev = ear.prev;
        next = ear.next;

        if (invSize ? isEarHashed(ear, minX, minY, invSize) : isEar(ear)) {
            // cut off the triangle
            triangles.push(prev.i / dim);
            triangles.push(ear.i / dim);
            triangles.push(next.i / dim);

            removeNode(ear);

            // skipping the next vertex leads to less sliver triangles
            ear = next.next;
            stop = next.next;

            continue;
        }

        ear = next;

        // if we looped through the whole remaining polygon and can't find any more ears
        if (ear === stop) {
            // try filtering points and slicing again
            if (!pass) {
                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, invSize, 1);

            // if this didn't work, try curing all small self-intersections locally
            } else if (pass === 1) {
                ear = cureLocalIntersections(ear, triangles, dim);
                earcutLinked(ear, triangles, dim, minX, minY, invSize, 2);

            // as a last resort, try splitting the remaining polygon into two
            } else if (pass === 2) {
                splitEarcut(ear, triangles, dim, minX, minY, invSize);
            }

            break;
        }
    }
}

// check whether a polygon node forms a valid ear with adjacent nodes
function isEar(ear) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // now make sure we don't have other points inside the potential ear
    var p = ear.next.next;

    while (p !== ear.prev) {
        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.next;
    }

    return true;
}

function isEarHashed(ear, minX, minY, invSize) {
    var a = ear.prev,
        b = ear,
        c = ear.next;

    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear

    // triangle bbox; min & max are calculated like this for speed
    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),
        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),
        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),
        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);

    // z-order range for the current triangle bbox;
    var minZ = zOrder(minTX, minTY, minX, minY, invSize),
        maxZ = zOrder(maxTX, maxTY, minX, minY, invSize);

    var p = ear.prevZ,
        n = ear.nextZ;

    // look for points inside the triangle in both directions
    while (p && p.z >= minZ && n && n.z <= maxZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;

        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    // look for remaining points in decreasing z-order
    while (p && p.z >= minZ) {
        if (p !== ear.prev && p !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&
            area(p.prev, p, p.next) >= 0) return false;
        p = p.prevZ;
    }

    // look for remaining points in increasing z-order
    while (n && n.z <= maxZ) {
        if (n !== ear.prev && n !== ear.next &&
            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, n.x, n.y) &&
            area(n.prev, n, n.next) >= 0) return false;
        n = n.nextZ;
    }

    return true;
}

// go through all polygon nodes and cure small local self-intersections
function cureLocalIntersections(start, triangles, dim) {
    var p = start;
    do {
        var a = p.prev,
            b = p.next.next;

        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {

            triangles.push(a.i / dim);
            triangles.push(p.i / dim);
            triangles.push(b.i / dim);

            // remove two nodes involved
            removeNode(p);
            removeNode(p.next);

            p = start = b;
        }
        p = p.next;
    } while (p !== start);

    return p;
}

// try splitting polygon into two and triangulate them independently
function splitEarcut(start, triangles, dim, minX, minY, invSize) {
    // look for a valid diagonal that divides the polygon into two
    var a = start;
    do {
        var b = a.next.next;
        while (b !== a.prev) {
            if (a.i !== b.i && isValidDiagonal(a, b)) {
                // split the polygon in two by the diagonal
                var c = splitPolygon(a, b);

                // filter colinear points around the cuts
                a = filterPoints(a, a.next);
                c = filterPoints(c, c.next);

                // run earcut on each half
                earcutLinked(a, triangles, dim, minX, minY, invSize);
                earcutLinked(c, triangles, dim, minX, minY, invSize);
                return;
            }
            b = b.next;
        }
        a = a.next;
    } while (a !== start);
}

// link every hole into the outer loop, producing a single-ring polygon without holes
function eliminateHoles(data, holeIndices, outerNode, dim) {
    var queue = [],
        i, len, start, end, list;

    for (i = 0, len = holeIndices.length; i < len; i++) {
        start = holeIndices[i] * dim;
        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
        list = linkedList(data, start, end, dim, false);
        if (list === list.next) list.steiner = true;
        queue.push(getLeftmost(list));
    }

    queue.sort(compareX);

    // process holes from left to right
    for (i = 0; i < queue.length; i++) {
        eliminateHole(queue[i], outerNode);
        outerNode = filterPoints(outerNode, outerNode.next);
    }

    return outerNode;
}

function compareX(a, b) {
    return a.x - b.x;
}

// find a bridge between vertices that connects hole with an outer ring and and link it
function eliminateHole(hole, outerNode) {
    outerNode = findHoleBridge(hole, outerNode);
    if (outerNode) {
        var b = splitPolygon(outerNode, hole);
        filterPoints(b, b.next);
    }
}

// David Eberly's algorithm for finding a bridge between hole and outer polygon
function findHoleBridge(hole, outerNode) {
    var p = outerNode,
        hx = hole.x,
        hy = hole.y,
        qx = -Infinity,
        m;

    // find a segment intersected by a ray from the hole's leftmost point to the left;
    // segment's endpoint with lesser x will be potential connection point
    do {
        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {
            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
            if (x <= hx && x > qx) {
                qx = x;
                if (x === hx) {
                    if (hy === p.y) return p;
                    if (hy === p.next.y) return p.next;
                }
                m = p.x < p.next.x ? p : p.next;
            }
        }
        p = p.next;
    } while (p !== outerNode);

    if (!m) return null;

    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint

    // look for points inside the triangle of hole point, segment intersection and endpoint;
    // if there are no points found, we have a valid connection;
    // otherwise choose the point of the minimum angle with the ray as connection point

    var stop = m,
        mx = m.x,
        my = m.y,
        tanMin = Infinity,
        tan;

    p = m.next;

    while (p !== stop) {
        if (hx >= p.x && p.x >= mx && hx !== p.x &&
                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {

            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential

            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {
                m = p;
                tanMin = tan;
            }
        }

        p = p.next;
    }

    return m;
}

// interlink polygon nodes in z-order
function indexCurve(start, minX, minY, invSize) {
    var p = start;
    do {
        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, invSize);
        p.prevZ = p.prev;
        p.nextZ = p.next;
        p = p.next;
    } while (p !== start);

    p.prevZ.nextZ = null;
    p.prevZ = null;

    sortLinked(p);
}

// Simon Tatham's linked list merge sort algorithm
// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
function sortLinked(list) {
    var i, p, q, e, tail, numMerges, pSize, qSize,
        inSize = 1;

    do {
        p = list;
        list = null;
        tail = null;
        numMerges = 0;

        while (p) {
            numMerges++;
            q = p;
            pSize = 0;
            for (i = 0; i < inSize; i++) {
                pSize++;
                q = q.nextZ;
                if (!q) break;
            }
            qSize = inSize;

            while (pSize > 0 || (qSize > 0 && q)) {

                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {
                    e = p;
                    p = p.nextZ;
                    pSize--;
                } else {
                    e = q;
                    q = q.nextZ;
                    qSize--;
                }

                if (tail) tail.nextZ = e;
                else list = e;

                e.prevZ = tail;
                tail = e;
            }

            p = q;
        }

        tail.nextZ = null;
        inSize *= 2;

    } while (numMerges > 1);

    return list;
}

// z-order of a point given coords and inverse of the longer side of data bbox
function zOrder(x, y, minX, minY, invSize) {
    // coords are transformed into non-negative 15-bit integer range
    x = 32767 * (x - minX) * invSize;
    y = 32767 * (y - minY) * invSize;

    x = (x | (x << 8)) & 0x00FF00FF;
    x = (x | (x << 4)) & 0x0F0F0F0F;
    x = (x | (x << 2)) & 0x33333333;
    x = (x | (x << 1)) & 0x55555555;

    y = (y | (y << 8)) & 0x00FF00FF;
    y = (y | (y << 4)) & 0x0F0F0F0F;
    y = (y | (y << 2)) & 0x33333333;
    y = (y | (y << 1)) & 0x55555555;

    return x | (y << 1);
}

// find the leftmost node of a polygon ring
function getLeftmost(start) {
    var p = start,
        leftmost = start;
    do {
        if (p.x < leftmost.x || (p.x === leftmost.x && p.y < leftmost.y)) leftmost = p;
        p = p.next;
    } while (p !== start);

    return leftmost;
}

// check if a point lies within a convex triangle
function pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {
    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&
           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&
           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;
}

// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
function isValidDiagonal(a, b) {
    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&
           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);
}

// signed area of a triangle
function area(p, q, r) {
    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
}

// check if two points are equal
function equals(p1, p2) {
    return p1.x === p2.x && p1.y === p2.y;
}

// check if two segments intersect
function intersects(p1, q1, p2, q2) {
    if ((equals(p1, q1) && equals(p2, q2)) ||
        (equals(p1, q2) && equals(p2, q1))) return true;
    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&
           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;
}

// check if a polygon diagonal intersects any polygon segments
function intersectsPolygon(a, b) {
    var p = a;
    do {
        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
                intersects(p, p.next, a, b)) return true;
        p = p.next;
    } while (p !== a);

    return false;
}

// check if a polygon diagonal is locally inside the polygon
function locallyInside(a, b) {
    return area(a.prev, a, a.next) < 0 ?
        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :
        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;
}

// check if the middle point of a polygon diagonal is inside the polygon
function middleInside(a, b) {
    var p = a,
        inside = false,
        px = (a.x + b.x) / 2,
        py = (a.y + b.y) / 2;
    do {
        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&
                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))
            inside = !inside;
        p = p.next;
    } while (p !== a);

    return inside;
}

// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
// if one belongs to the outer ring and another to a hole, it merges it into a single ring
function splitPolygon(a, b) {
    var a2 = new Node(a.i, a.x, a.y),
        b2 = new Node(b.i, b.x, b.y),
        an = a.next,
        bp = b.prev;

    a.next = b;
    b.prev = a;

    a2.next = an;
    an.prev = a2;

    b2.next = a2;
    a2.prev = b2;

    bp.next = b2;
    b2.prev = bp;

    return b2;
}

// create a node and optionally link it with previous one (in a circular doubly linked list)
function insertNode(i, x, y, last) {
    var p = new Node(i, x, y);

    if (!last) {
        p.prev = p;
        p.next = p;

    } else {
        p.next = last.next;
        p.prev = last;
        last.next.prev = p;
        last.next = p;
    }
    return p;
}

function removeNode(p) {
    p.next.prev = p.prev;
    p.prev.next = p.next;

    if (p.prevZ) p.prevZ.nextZ = p.nextZ;
    if (p.nextZ) p.nextZ.prevZ = p.prevZ;
}

function Node(i, x, y) {
    // vertex index in coordinates array
    this.i = i;

    // vertex coordinates
    this.x = x;
    this.y = y;

    // previous and next vertex nodes in a polygon ring
    this.prev = null;
    this.next = null;

    // z-order curve value
    this.z = null;

    // previous and next nodes in z-order
    this.prevZ = null;
    this.nextZ = null;

    // indicates whether this is a steiner point
    this.steiner = false;
}

// return a percentage difference between the polygon area and its triangulation area;
// used to verify correctness of triangulation
earcut.deviation = function (data, holeIndices, dim, triangles) {
    var hasHoles = holeIndices && holeIndices.length;
    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;

    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));
    if (hasHoles) {
        for (var i = 0, len = holeIndices.length; i < len; i++) {
            var start = holeIndices[i] * dim;
            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;
            polygonArea -= Math.abs(signedArea(data, start, end, dim));
        }
    }

    var trianglesArea = 0;
    for (i = 0; i < triangles.length; i += 3) {
        var a = triangles[i] * dim;
        var b = triangles[i + 1] * dim;
        var c = triangles[i + 2] * dim;
        trianglesArea += Math.abs(
            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -
            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));
    }

    return polygonArea === 0 && trianglesArea === 0 ? 0 :
        Math.abs((trianglesArea - polygonArea) / polygonArea);
};

function signedArea(data, start, end, dim) {
    var sum = 0;
    for (var i = start, j = end - dim; i < end; i += dim) {
        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);
        j = i;
    }
    return sum;
}

// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts
earcut.flatten = function (data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }
    return result;
};


/***/ }),

/***/ "./node_modules/geojson-area/index.js":
/*!********************************************!*\
  !*** ./node_modules/geojson-area/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var wgs84 = __webpack_require__(/*! wgs84 */ "./node_modules/wgs84/index.js");

module.exports.geometry = geometry;
module.exports.ring = ringArea;

function geometry(_) {
    var area = 0, i;
    switch (_.type) {
        case 'Polygon':
            return polygonArea(_.coordinates);
        case 'MultiPolygon':
            for (i = 0; i < _.coordinates.length; i++) {
                area += polygonArea(_.coordinates[i]);
            }
            return area;
        case 'Point':
        case 'MultiPoint':
        case 'LineString':
        case 'MultiLineString':
            return 0;
        case 'GeometryCollection':
            for (i = 0; i < _.geometries.length; i++) {
                area += geometry(_.geometries[i]);
            }
            return area;
    }
}

function polygonArea(coords) {
    var area = 0;
    if (coords && coords.length > 0) {
        area += Math.abs(ringArea(coords[0]));
        for (var i = 1; i < coords.length; i++) {
            area -= Math.abs(ringArea(coords[i]));
        }
    }
    return area;
}

/**
 * Calculate the approximate area of the polygon were it projected onto
 *     the earth.  Note that this area will be positive if ring is oriented
 *     clockwise, otherwise it will be negative.
 *
 * Reference:
 * Robert. G. Chamberlain and William H. Duquette, "Some Algorithms for
 *     Polygons on a Sphere", JPL Publication 07-03, Jet Propulsion
 *     Laboratory, Pasadena, CA, June 2007 http://trs-new.jpl.nasa.gov/dspace/handle/2014/40409
 *
 * Returns:
 * {float} The approximate signed geodesic area of the polygon in square
 *     meters.
 */

function ringArea(coords) {
    var p1, p2, p3, lowerIndex, middleIndex, upperIndex,
    area = 0,
    coordsLength = coords.length;

    if (coordsLength > 2) {
        for (i = 0; i < coordsLength; i++) {
            if (i === coordsLength - 2) {// i = N-2
                lowerIndex = coordsLength - 2;
                middleIndex = coordsLength -1;
                upperIndex = 0;
            } else if (i === coordsLength - 1) {// i = N-1
                lowerIndex = coordsLength - 1;
                middleIndex = 0;
                upperIndex = 1;
            } else { // i = 0 to N-3
                lowerIndex = i;
                middleIndex = i+1;
                upperIndex = i+2;
            }
            p1 = coords[lowerIndex];
            p2 = coords[middleIndex];
            p3 = coords[upperIndex];
            area += ( rad(p3[0]) - rad(p1[0]) ) * Math.sin( rad(p2[1]));
        }

        area = area * wgs84.RADIUS * wgs84.RADIUS / 2;
    }

    return area;
}

function rad(_) {
    return _ * Math.PI / 180;
}

/***/ }),

/***/ "./node_modules/geojson-equality/index.js":
/*!************************************************!*\
  !*** ./node_modules/geojson-equality/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//index.js
var deepEqual = __webpack_require__(/*! deep-equal */ "./node_modules/deep-equal/index.js");

var Equality = function(opt) {
  this.precision = opt && opt.precision ? opt.precision : 17;
  this.direction = opt && opt.direction ? opt.direction : false;
  this.pseudoNode = opt && opt.pseudoNode ? opt.pseudoNode : false;
  this.objectComparator = opt && opt.objectComparator ? opt.objectComparator : objectComparator;
};

Equality.prototype.compare = function(g1,g2) {
  if (g1.type !== g2.type || !sameLength(g1,g2)) return false;

  switch(g1.type) {
  case 'Point':
    return this.compareCoord(g1.coordinates, g2.coordinates);
    break;
  case 'LineString':
    return this.compareLine(g1.coordinates, g2.coordinates,0,false);
    break;
  case 'Polygon':
    return this.comparePolygon(g1,g2);
    break;
  case 'Feature':
    return this.compareFeature(g1, g2);
  default:
    if (g1.type.indexOf('Multi') === 0) {
      var context = this;
      var g1s = explode(g1);
      var g2s = explode(g2);
      return g1s.every(function(g1part) {
        return this.some(function(g2part) {
          return context.compare(g1part,g2part);
        });
      },g2s);
    }
  }
  return false;
};

function explode(g) {
  return g.coordinates.map(function(part) {
    return {
      type: g.type.replace('Multi', ''),
      coordinates: part}
  });
}
//compare length of coordinates/array
function sameLength(g1,g2) {
   return g1.hasOwnProperty('coordinates') ?
    g1.coordinates.length === g2.coordinates.length
    : g1.length === g2.length;
}

// compare the two coordinates [x,y]
Equality.prototype.compareCoord = function(c1,c2) {
  if (c1.length !== c2.length) {
    return false;
  }

  for (var i=0; i < c1.length; i++) {
    if (c1[i].toFixed(this.precision) !== c2[i].toFixed(this.precision)) {
      return false;
    }
  }
  return true;
};

Equality.prototype.compareLine = function(path1,path2,ind,isPoly) {
  if (!sameLength(path1,path2)) return false;
  var p1 = this.pseudoNode ? path1 : this.removePseudo(path1);
  var p2 = this.pseudoNode ? path2 : this.removePseudo(path2);
  if (isPoly && !this.compareCoord(p1[0],p2[0])) {
    // fix start index of both to same point
    p2 = this.fixStartIndex(p2,p1);
    if(!p2) return;
  }
  // for linestring ind =0 and for polygon ind =1
  var sameDirection = this.compareCoord(p1[ind],p2[ind]);
  if (this.direction || sameDirection
  ) {
    return this.comparePath(p1, p2);
  } else {
    if (this.compareCoord(p1[ind],p2[p2.length - (1+ind)])
    ) {
      return this.comparePath(p1.slice().reverse(), p2);
    }
    return false;
  }
};
Equality.prototype.fixStartIndex = function(sourcePath,targetPath) {
  //make sourcePath first point same as of targetPath
  var correctPath,ind = -1;
  for (var i=0; i< sourcePath.length; i++) {
    if(this.compareCoord(sourcePath[i],targetPath[0])) {
      ind = i;
      break;
    }
  }
  if (ind >= 0) {
    correctPath = [].concat(
      sourcePath.slice(ind,sourcePath.length),
      sourcePath.slice(1,ind+1));
  }
  return correctPath;
};
Equality.prototype.comparePath = function (p1,p2) {
  var cont = this;
  return p1.every(function(c,i) {
    return cont.compareCoord(c,this[i]);
  },p2);
};

Equality.prototype.comparePolygon = function(g1,g2) {
  if (this.compareLine(g1.coordinates[0],g2.coordinates[0],1,true)) {
    var holes1 = g1.coordinates.slice(1,g1.coordinates.length);
    var holes2 = g2.coordinates.slice(1,g2.coordinates.length);
    var cont = this;
    return holes1.every(function(h1) {
      return this.some(function(h2) {
        return cont.compareLine(h1,h2,1,true);
      });
    },holes2);
  } else {
    return false;
  }
};

Equality.prototype.compareFeature = function(g1,g2) {
  if (
    g1.id !== g2.id ||
    !this.objectComparator(g1.properties, g2.properties) ||
    !this.compareBBox(g1,g2)
  ) {
    return false;
  }
  return this.compare(g1.geometry, g2.geometry);
};

Equality.prototype.compareBBox = function(g1,g2) {
  if (
    (!g1.bbox && !g2.bbox) || 
    (
      g1.bbox && g2.bbox &&
      this.compareCoord(g1.bbox, g2.bbox)
    )
  )  {
    return true;
  }
  return false;
};
Equality.prototype.removePseudo = function(path) {
  //TODO to be implement
  return path;
};

function objectComparator(obj1, obj2) {
  return deepEqual(obj1, obj2, {strict: true});
}

module.exports = Equality;


/***/ }),

/***/ "./node_modules/geojson-normalize/index.js":
/*!*************************************************!*\
  !*** ./node_modules/geojson-normalize/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = normalize;

var types = {
    Point: 'geometry',
    MultiPoint: 'geometry',
    LineString: 'geometry',
    MultiLineString: 'geometry',
    Polygon: 'geometry',
    MultiPolygon: 'geometry',
    GeometryCollection: 'geometry',
    Feature: 'feature',
    FeatureCollection: 'featurecollection'
};

/**
 * Normalize a GeoJSON feature into a FeatureCollection.
 *
 * @param {object} gj geojson data
 * @returns {object} normalized geojson data
 */
function normalize(gj) {
    if (!gj || !gj.type) return null;
    var type = types[gj.type];
    if (!type) return null;

    if (type === 'geometry') {
        return {
            type: 'FeatureCollection',
            features: [{
                type: 'Feature',
                properties: {},
                geometry: gj
            }]
        };
    } else if (type === 'feature') {
        return {
            type: 'FeatureCollection',
            features: [gj]
        };
    } else if (type === 'featurecollection') {
        return gj;
    }
}


/***/ }),

/***/ "./node_modules/geojson-random/index.js":
/*!**********************************************!*\
  !*** ./node_modules/geojson-random/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports = function() {
    throw new Error('call .point() or .polygon() instead');
};

function position(bbox) {
    if (bbox) return coordInBBBOX(bbox);
    else return [lon(), lat()];
}

module.exports.position = position;

module.exports.point = function(count, bbox) {
    var features = [];
    for (i = 0; i < count; i++) {
        features.push(feature(bbox ? point(position(bbox)) : point()));
    }
    return collection(features);
};

module.exports.polygon = function(count, num_vertices, max_radial_length, bbox) {
    if (typeof num_vertices !== 'number') num_vertices = 10;
    if (typeof max_radial_length !== 'number') max_radial_length = 10;
    var features = [];
    for (i = 0; i < count; i++) {
        var vertices = [],
            circle_offsets = Array.apply(null,
                new Array(num_vertices + 1)).map(Math.random);

        circle_offsets.forEach(sumOffsets);
        circle_offsets.forEach(scaleOffsets);
        vertices[vertices.length - 1] = vertices[0]; // close the ring

        // center the polygon around something
        vertices = vertices.map(vertexToCoordinate(position(bbox)));
        features.push(feature(polygon([vertices])));
    }

    function sumOffsets(cur, index, arr) {
        arr[index] = (index > 0) ? cur + arr[index - 1] : cur;
    }

    function scaleOffsets(cur, index) {
        cur = cur * 2 * Math.PI / circle_offsets[circle_offsets.length - 1];
        var radial_scaler = Math.random();
        vertices.push([
            radial_scaler * max_radial_length * Math.sin(cur),
            radial_scaler * max_radial_length * Math.cos(cur)
        ]);
    }

    return collection(features);
};


function vertexToCoordinate(hub) {
    return function(cur, index) { return [cur[0] + hub[0], cur[1] + hub[1]]; };
}

function rnd() { return Math.random() - 0.5; }
function lon() { return rnd() * 360; }
function lat() { return rnd() * 180; }

function point(coordinates) {
    return {
        type: 'Point',
        coordinates: coordinates || [lon(), lat()]
    };
}

function coordInBBBOX(bbox) {
    return [
        (Math.random() * (bbox[2] - bbox[0])) + bbox[0],
        (Math.random() * (bbox[3] - bbox[1])) + bbox[1]];
}

function pointInBBBOX() {
    return {
        type: 'Point',
        coordinates: [lon(), lat()]
    };
}

function polygon(coordinates) {
    return {
        type: 'Polygon',
        coordinates: coordinates
    };
}

function feature(geom) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: {}
    };
}

function collection(f) {
    return {
        type: 'FeatureCollection',
        features: f
    };
}


/***/ }),

/***/ "./node_modules/geojson-rbush/index.js":
/*!*********************************************!*\
  !*** ./node_modules/geojson-rbush/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rbush = __webpack_require__(/*! rbush */ "./node_modules/rbush/index.js");
var helpers = __webpack_require__(/*! @turf/helpers */ "./node_modules/@turf/helpers/index.js");
var meta = __webpack_require__(/*! @turf/meta */ "./node_modules/@turf/meta/index.js");
var turfBBox = __webpack_require__(/*! @turf/bbox */ "./node_modules/@turf/bbox/index.js").default;
var featureEach = meta.featureEach;
var coordEach = meta.coordEach;
var polygon = helpers.polygon;
var featureCollection = helpers.featureCollection;

/**
 * GeoJSON implementation of [RBush](https://github.com/mourner/rbush#rbush) spatial index.
 *
 * @name rbush
 * @param {number} [maxEntries=9] defines the maximum number of entries in a tree node. 9 (used by default) is a
 * reasonable choice for most applications. Higher value means faster insertion and slower search, and vice versa.
 * @returns {RBush} GeoJSON RBush
 * @example
 * var geojsonRbush = require('geojson-rbush').default;
 * var tree = geojsonRbush();
 */
function geojsonRbush(maxEntries) {
    var tree = rbush(maxEntries);
    /**
     * [insert](https://github.com/mourner/rbush#data-format)
     *
     * @param {Feature} feature insert single GeoJSON Feature
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     * tree.insert(poly)
     */
    tree.insert = function (feature) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.insert.call(this, feature);
    };

    /**
     * [load](https://github.com/mourner/rbush#bulk-inserting-data)
     *
     * @param {FeatureCollection|Array<Feature>} features load entire GeoJSON FeatureCollection
     * @returns {RBush} GeoJSON RBush
     * @example
     * var polys = turf.polygons([
     *     [[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]],
     *     [[[-93, 32], [-83, 32], [-83, 39], [-93, 39], [-93, 32]]]
     * ]);
     * tree.load(polys);
     */
    tree.load = function (features) {
        var load = [];
        // Load an Array of Features
        if (Array.isArray(features)) {
            features.forEach(function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        } else {
            // Load a FeatureCollection
            featureEach(features, function (feature) {
                if (feature.type !== 'Feature') throw new Error('invalid features');
                feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
                load.push(feature);
            });
        }
        return rbush.prototype.load.call(this, load);
    };

    /**
     * [remove](https://github.com/mourner/rbush#removing-data)
     *
     * @param {Feature} feature remove single GeoJSON Feature
     * @param {Function} equals Pass a custom equals function to compare by value for removal.
     * @returns {RBush} GeoJSON RBush
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.remove(poly);
     */
    tree.remove = function (feature, equals) {
        if (feature.type !== 'Feature') throw new Error('invalid feature');
        feature.bbox = feature.bbox ? feature.bbox : turfBBox(feature);
        return rbush.prototype.remove.call(this, feature, equals);
    };

    /**
     * [clear](https://github.com/mourner/rbush#removing-data)
     *
     * @returns {RBush} GeoJSON Rbush
     * @example
     * tree.clear()
     */
    tree.clear = function () {
        return rbush.prototype.clear.call(this);
    };

    /**
     * [search](https://github.com/mourner/rbush#search)
     *
     * @param {BBox|FeatureCollection|Feature} geojson search with GeoJSON
     * @returns {FeatureCollection} all features that intersects with the given GeoJSON.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.search(poly);
     */
    tree.search = function (geojson) {
        var features = rbush.prototype.search.call(this, this.toBBox(geojson));
        return featureCollection(features);
    };

    /**
     * [collides](https://github.com/mourner/rbush#collisions)
     *
     * @param {BBox|FeatureCollection|Feature} geojson collides with GeoJSON
     * @returns {boolean} true if there are any items intersecting the given GeoJSON, otherwise false.
     * @example
     * var poly = turf.polygon([[[-78, 41], [-67, 41], [-67, 48], [-78, 48], [-78, 41]]]);
     *
     * tree.collides(poly);
     */
    tree.collides = function (geojson) {
        return rbush.prototype.collides.call(this, this.toBBox(geojson));
    };

    /**
     * [all](https://github.com/mourner/rbush#search)
     *
     * @returns {FeatureCollection} all the features in RBush
     * @example
     * tree.all()
     */
    tree.all = function () {
        var features = rbush.prototype.all.call(this);
        return featureCollection(features);
    };

    /**
     * [toJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @returns {any} export data as JSON object
     * @example
     * var exported = tree.toJSON()
     */
    tree.toJSON = function () {
        return rbush.prototype.toJSON.call(this);
    };

    /**
     * [fromJSON](https://github.com/mourner/rbush#export-and-import)
     *
     * @param {any} json import previously exported data
     * @returns {RBush} GeoJSON RBush
     * @example
     * var exported = {
     *   "children": [
     *     {
     *       "type": "Feature",
     *       "geometry": {
     *         "type": "Point",
     *         "coordinates": [110, 50]
     *       },
     *       "properties": {},
     *       "bbox": [110, 50, 110, 50]
     *     }
     *   ],
     *   "height": 1,
     *   "leaf": true,
     *   "minX": 110,
     *   "minY": 50,
     *   "maxX": 110,
     *   "maxY": 50
     * }
     * tree.fromJSON(exported)
     */
    tree.fromJSON = function (json) {
        return rbush.prototype.fromJSON.call(this, json);
    };

    /**
     * Converts GeoJSON to {minX, minY, maxX, maxY} schema
     *
     * @private
     * @param {BBox|FeatureCollection|Feature} geojson feature(s) to retrieve BBox from
     * @returns {Object} converted to {minX, minY, maxX, maxY}
     */
    tree.toBBox = function (geojson) {
        var bbox;
        if (geojson.bbox) bbox = geojson.bbox;
        else if (Array.isArray(geojson) && geojson.length === 4) bbox = geojson;
        else if (Array.isArray(geojson) && geojson.length === 6) bbox = [geojson[0], geojson[1], geojson[3], geojson[4]];
        else if (geojson.type === 'Feature') bbox = turfBBox(geojson);
        else if (geojson.type === 'FeatureCollection') bbox = turfBBox(geojson);
        else throw new Error('invalid geojson')

        return {
            minX: bbox[0],
            minY: bbox[1],
            maxX: bbox[2],
            maxY: bbox[3]
        };
    };
    return tree;
}

module.exports = geojsonRbush;
module.exports.default = geojsonRbush;


/***/ }),

/***/ "./node_modules/incremental-convex-hull/ich.js":
/*!*****************************************************!*\
  !*** ./node_modules/incremental-convex-hull/ich.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


//High level idea:
// 1. Use Clarkson's incremental construction to find convex hull
// 2. Point location in triangulation by jump and walk

module.exports = incrementalConvexHull

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")
var compareCell = __webpack_require__(/*! simplicial-complex */ "./node_modules/simplicial-complex/topology.js").compareCells

function compareInt(a, b) {
  return a - b
}

function Simplex(vertices, adjacent, boundary) {
  this.vertices = vertices
  this.adjacent = adjacent
  this.boundary = boundary
  this.lastVisited = -1
}

Simplex.prototype.flip = function() {
  var t = this.vertices[0]
  this.vertices[0] = this.vertices[1]
  this.vertices[1] = t
  var u = this.adjacent[0]
  this.adjacent[0] = this.adjacent[1]
  this.adjacent[1] = u
}

function GlueFacet(vertices, cell, index) {
  this.vertices = vertices
  this.cell = cell
  this.index = index
}

function compareGlue(a, b) {
  return compareCell(a.vertices, b.vertices)
}

function bakeOrient(d) {
  var code = ["function orient(){var tuple=this.tuple;return test("]
  for(var i=0; i<=d; ++i) {
    if(i > 0) {
      code.push(",")
    }
    code.push("tuple[", i, "]")
  }
  code.push(")}return orient")
  var proc = new Function("test", code.join(""))
  var test = orient[d+1]
  if(!test) {
    test = orient
  }
  return proc(test)
}

var BAKED = []

function Triangulation(dimension, vertices, simplices) {
  this.dimension = dimension
  this.vertices = vertices
  this.simplices = simplices
  this.interior = simplices.filter(function(c) {
    return !c.boundary
  })

  this.tuple = new Array(dimension+1)
  for(var i=0; i<=dimension; ++i) {
    this.tuple[i] = this.vertices[i]
  }

  var o = BAKED[dimension]
  if(!o) {
    o = BAKED[dimension] = bakeOrient(dimension)
  }
  this.orient = o
}

var proto = Triangulation.prototype

//Degenerate situation where we are on boundary, but coplanar to face
proto.handleBoundaryDegeneracy = function(cell, point) {
  var d = this.dimension
  var n = this.vertices.length - 1
  var tuple = this.tuple
  var verts = this.vertices

  //Dumb solution: Just do dfs from boundary cell until we find any peak, or terminate
  var toVisit = [ cell ]
  cell.lastVisited = -n
  while(toVisit.length > 0) {
    cell = toVisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited <= -n) {
        continue
      }
      var nv = neighbor.vertices
      for(var j=0; j<=d; ++j) {
        var vv = nv[j]
        if(vv < 0) {
          tuple[j] = point
        } else {
          tuple[j] = verts[vv]
        }
      }
      var o = this.orient()
      if(o > 0) {
        return neighbor
      }
      neighbor.lastVisited = -n
      if(o === 0) {
        toVisit.push(neighbor)
      }
    }
  }
  return null
}

proto.walk = function(point, random) {
  //Alias local properties
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple

  //Compute initial jump cell
  var initIndex = random ? (this.interior.length * Math.random())|0 : (this.interior.length-1)
  var cell = this.interior[ initIndex ]

  //Start walking
outerLoop:
  while(!cell.boundary) {
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent

    for(var i=0; i<=d; ++i) {
      tuple[i] = verts[cellVerts[i]]
    }
    cell.lastVisited = n

    //Find farthest adjacent cell
    for(var i=0; i<=d; ++i) {
      var neighbor = cellAdj[i]
      if(neighbor.lastVisited >= n) {
        continue
      }
      var prev = tuple[i]
      tuple[i] = point
      var o = this.orient()
      tuple[i] = prev
      if(o < 0) {
        cell = neighbor
        continue outerLoop
      } else {
        if(!neighbor.boundary) {
          neighbor.lastVisited = n
        } else {
          neighbor.lastVisited = -n
        }
      }
    }
    return
  }

  return cell
}

proto.addPeaks = function(point, cell) {
  var n = this.vertices.length - 1
  var d = this.dimension
  var verts = this.vertices
  var tuple = this.tuple
  var interior = this.interior
  var simplices = this.simplices

  //Walking finished at boundary, time to add peaks
  var tovisit = [ cell ]

  //Stretch initial boundary cell into a peak
  cell.lastVisited = n
  cell.vertices[cell.vertices.indexOf(-1)] = n
  cell.boundary = false
  interior.push(cell)

  //Record a list of all new boundaries created by added peaks so we can glue them together when we are all done
  var glueFacets = []

  //Do a traversal of the boundary walking outward from starting peak
  while(tovisit.length > 0) {
    //Pop off peak and walk over adjacent cells
    var cell = tovisit.pop()
    var cellVerts = cell.vertices
    var cellAdj = cell.adjacent
    var indexOfN = cellVerts.indexOf(n)
    if(indexOfN < 0) {
      continue
    }

    for(var i=0; i<=d; ++i) {
      if(i === indexOfN) {
        continue
      }

      //For each boundary neighbor of the cell
      var neighbor = cellAdj[i]
      if(!neighbor.boundary || neighbor.lastVisited >= n) {
        continue
      }

      var nv = neighbor.vertices

      //Test if neighbor is a peak
      if(neighbor.lastVisited !== -n) {      
        //Compute orientation of p relative to each boundary peak
        var indexOfNeg1 = 0
        for(var j=0; j<=d; ++j) {
          if(nv[j] < 0) {
            indexOfNeg1 = j
            tuple[j] = point
          } else {
            tuple[j] = verts[nv[j]]
          }
        }
        var o = this.orient()

        //Test if neighbor cell is also a peak
        if(o > 0) {
          nv[indexOfNeg1] = n
          neighbor.boundary = false
          interior.push(neighbor)
          tovisit.push(neighbor)
          neighbor.lastVisited = n
          continue
        } else {
          neighbor.lastVisited = -n
        }
      }

      var na = neighbor.adjacent

      //Otherwise, replace neighbor with new face
      var vverts = cellVerts.slice()
      var vadj = cellAdj.slice()
      var ncell = new Simplex(vverts, vadj, true)
      simplices.push(ncell)

      //Connect to neighbor
      var opposite = na.indexOf(cell)
      if(opposite < 0) {
        continue
      }
      na[opposite] = ncell
      vadj[indexOfN] = neighbor

      //Connect to cell
      vverts[i] = -1
      vadj[i] = cell
      cellAdj[i] = ncell

      //Flip facet
      ncell.flip()

      //Add to glue list
      for(var j=0; j<=d; ++j) {
        var uu = vverts[j]
        if(uu < 0 || uu === n) {
          continue
        }
        var nface = new Array(d-1)
        var nptr = 0
        for(var k=0; k<=d; ++k) {
          var vv = vverts[k]
          if(vv < 0 || k === j) {
            continue
          }
          nface[nptr++] = vv
        }
        glueFacets.push(new GlueFacet(nface, ncell, j))
      }
    }
  }

  //Glue boundary facets together
  glueFacets.sort(compareGlue)

  for(var i=0; i+1<glueFacets.length; i+=2) {
    var a = glueFacets[i]
    var b = glueFacets[i+1]
    var ai = a.index
    var bi = b.index
    if(ai < 0 || bi < 0) {
      continue
    }
    a.cell.adjacent[a.index] = b.cell
    b.cell.adjacent[b.index] = a.cell
  }
}

proto.insert = function(point, random) {
  //Add point
  var verts = this.vertices
  verts.push(point)

  var cell = this.walk(point, random)
  if(!cell) {
    return
  }

  //Alias local properties
  var d = this.dimension
  var tuple = this.tuple

  //Degenerate case: If point is coplanar to cell, then walk until we find a non-degenerate boundary
  for(var i=0; i<=d; ++i) {
    var vv = cell.vertices[i]
    if(vv < 0) {
      tuple[i] = point
    } else {
      tuple[i] = verts[vv]
    }
  }
  var o = this.orient(tuple)
  if(o < 0) {
    return
  } else if(o === 0) {
    cell = this.handleBoundaryDegeneracy(cell, point)
    if(!cell) {
      return
    }
  }

  //Add peaks
  this.addPeaks(point, cell)
}

//Extract all boundary cells
proto.boundary = function() {
  var d = this.dimension
  var boundary = []
  var cells = this.simplices
  var nc = cells.length
  for(var i=0; i<nc; ++i) {
    var c = cells[i]
    if(c.boundary) {
      var bcell = new Array(d)
      var cv = c.vertices
      var ptr = 0
      var parity = 0
      for(var j=0; j<=d; ++j) {
        if(cv[j] >= 0) {
          bcell[ptr++] = cv[j]
        } else {
          parity = j&1
        }
      }
      if(parity === (d&1)) {
        var t = bcell[0]
        bcell[0] = bcell[1]
        bcell[1] = t
      }
      boundary.push(bcell)
    }
  }
  return boundary
}

function incrementalConvexHull(points, randomSearch) {
  var n = points.length
  if(n === 0) {
    throw new Error("Must have at least d+1 points")
  }
  var d = points[0].length
  if(n <= d) {
    throw new Error("Must input at least d+1 points")
  }

  //FIXME: This could be degenerate, but need to select d+1 non-coplanar points to bootstrap process
  var initialSimplex = points.slice(0, d+1)

  //Make sure initial simplex is positively oriented
  var o = orient.apply(void 0, initialSimplex)
  if(o === 0) {
    throw new Error("Input not in general position")
  }
  var initialCoords = new Array(d+1)
  for(var i=0; i<=d; ++i) {
    initialCoords[i] = i
  }
  if(o < 0) {
    initialCoords[0] = 1
    initialCoords[1] = 0
  }

  //Create initial topological index, glue pointers together (kind of messy)
  var initialCell = new Simplex(initialCoords, new Array(d+1), false)
  var boundary = initialCell.adjacent
  var list = new Array(d+2)
  for(var i=0; i<=d; ++i) {
    var verts = initialCoords.slice()
    for(var j=0; j<=d; ++j) {
      if(j === i) {
        verts[j] = -1
      }
    }
    var t = verts[0]
    verts[0] = verts[1]
    verts[1] = t
    var cell = new Simplex(verts, new Array(d+1), true)
    boundary[i] = cell
    list[i] = cell
  }
  list[d+1] = initialCell
  for(var i=0; i<=d; ++i) {
    var verts = boundary[i].vertices
    var adj = boundary[i].adjacent
    for(var j=0; j<=d; ++j) {
      var v = verts[j]
      if(v < 0) {
        adj[j] = initialCell
        continue
      }
      for(var k=0; k<=d; ++k) {
        if(boundary[k].vertices.indexOf(v) < 0) {
          adj[j] = boundary[k]
        }
      }
    }
  }

  //Initialize triangles
  var triangles = new Triangulation(d, initialSimplex, list)

  //Insert remaining points
  var useRandom = !!randomSearch
  for(var i=d+1; i<n; ++i) {
    triangles.insert(points[i], useRandom)
  }
  
  //Extract boundary cells
  return triangles.boundary()
}

/***/ }),

/***/ "./node_modules/jquery/dist/jquery.js":
/*!********************************************!*\
  !*** ./node_modules/jquery/dist/jquery.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
 * jQuery JavaScript Library v3.5.1
 * https://jquery.com/
 *
 * Includes Sizzle.js
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://jquery.org/license
 *
 * Date: 2020-05-04T22:49Z
 */
( function( global, factory ) {

	"use strict";

	if (  true && typeof module.exports === "object" ) {

		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
} )( typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Edge <= 12 - 13+, Firefox <=18 - 45+, IE 10 - 11, Safari 5.1 - 9+, iOS 6 - 9.1
// throw exceptions when non-strict code (e.g., ASP.NET 4.5) accesses strict mode
// arguments.callee.caller (trac-13335). But as of jQuery 3.0 (2016), strict mode should be common
// enough that all such attempts are guarded in a try block.
"use strict";

var arr = [];

var getProto = Object.getPrototypeOf;

var slice = arr.slice;

var flat = arr.flat ? function( array ) {
	return arr.flat.call( array );
} : function( array ) {
	return arr.concat.apply( [], array );
};


var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var fnToString = hasOwn.toString;

var ObjectFunctionString = fnToString.call( Object );

var support = {};

var isFunction = function isFunction( obj ) {

      // Support: Chrome <=57, Firefox <=52
      // In some browsers, typeof returns "function" for HTML <object> elements
      // (i.e., `typeof document.createElement( "object" ) === "function"`).
      // We don't want to classify *any* DOM node as a function.
      return typeof obj === "function" && typeof obj.nodeType !== "number";
  };


var isWindow = function isWindow( obj ) {
		return obj != null && obj === obj.window;
	};


var document = window.document;



	var preservedScriptAttributes = {
		type: true,
		src: true,
		nonce: true,
		noModule: true
	};

	function DOMEval( code, node, doc ) {
		doc = doc || document;

		var i, val,
			script = doc.createElement( "script" );

		script.text = code;
		if ( node ) {
			for ( i in preservedScriptAttributes ) {

				// Support: Firefox 64+, Edge 18+
				// Some browsers don't support the "nonce" property on scripts.
				// On the other hand, just using `getAttribute` is not enough as
				// the `nonce` attribute is reset to an empty string whenever it
				// becomes browsing-context connected.
				// See https://github.com/whatwg/html/issues/2369
				// See https://html.spec.whatwg.org/#nonce-attributes
				// The `node.getAttribute` check was added for the sake of
				// `jQuery.globalEval` so that it can fake a nonce-containing node
				// via an object.
				val = node[ i ] || node.getAttribute && node.getAttribute( i );
				if ( val ) {
					script.setAttribute( i, val );
				}
			}
		}
		doc.head.appendChild( script ).parentNode.removeChild( script );
	}


function toType( obj ) {
	if ( obj == null ) {
		return obj + "";
	}

	// Support: Android <=2.3 only (functionish RegExp)
	return typeof obj === "object" || typeof obj === "function" ?
		class2type[ toString.call( obj ) ] || "object" :
		typeof obj;
}
/* global Symbol */
// Defining this global in .eslintrc.json would create a danger of using the global
// unguarded in another place, it seems safer to define global only for this module



var
	version = "3.5.1",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {

		// Return all the elements in a clean array
		if ( num == null ) {
			return slice.call( this );
		}

		// Return just the one element from the set
		return num < 0 ? this[ num + this.length ] : this[ num ];
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	even: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return ( i + 1 ) % 2;
		} ) );
	},

	odd: function() {
		return this.pushStack( jQuery.grep( this, function( _elem, i ) {
			return i % 2;
		} ) );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				copy = options[ name ];

				// Prevent Object.prototype pollution
				// Prevent never-ending loop
				if ( name === "__proto__" || target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = Array.isArray( copy ) ) ) ) {
					src = target[ name ];

					// Ensure proper type for the source value
					if ( copyIsArray && !Array.isArray( src ) ) {
						clone = [];
					} else if ( !copyIsArray && !jQuery.isPlainObject( src ) ) {
						clone = {};
					} else {
						clone = src;
					}
					copyIsArray = false;

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isPlainObject: function( obj ) {
		var proto, Ctor;

		// Detect obvious negatives
		// Use toString instead of jQuery.type to catch host objects
		if ( !obj || toString.call( obj ) !== "[object Object]" ) {
			return false;
		}

		proto = getProto( obj );

		// Objects with no prototype (e.g., `Object.create( null )`) are plain
		if ( !proto ) {
			return true;
		}

		// Objects with prototype are plain iff they were constructed by a global Object function
		Ctor = hasOwn.call( proto, "constructor" ) && proto.constructor;
		return typeof Ctor === "function" && fnToString.call( Ctor ) === ObjectFunctionString;
	},

	isEmptyObject: function( obj ) {
		var name;

		for ( name in obj ) {
			return false;
		}
		return true;
	},

	// Evaluates a script in a provided context; falls back to the global one
	// if not specified.
	globalEval: function( code, options, doc ) {
		DOMEval( code, { nonce: options && options.nonce }, doc );
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	// Support: Android <=4.0 only, PhantomJS 1 only
	// push.apply(_, arraylike) throws on ancient WebKit
	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return flat( ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( _i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: real iOS 8.2 only (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = toType( obj );

	if ( isFunction( obj ) || isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.3.5
 * https://sizzlejs.com/
 *
 * Copyright JS Foundation and other contributors
 * Released under the MIT license
 * https://js.foundation/
 *
 * Date: 2020-03-14
 */
( function( window ) {
var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	nonnativeSelectorCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// Instance methods
	hasOwn = ( {} ).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	pushNative = arr.push,
	push = arr.push,
	slice = arr.slice,

	// Use a stripped-down indexOf as it's faster than native
	// https://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[ i ] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|" +
		"ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// https://www.w3.org/TR/css-syntax-3/#ident-token-diagram
	identifier = "(?:\\\\[\\da-fA-F]{1,6}" + whitespace +
		"?|\\\\[^\\r\\n\\f]|[\\w-]|[^\0-\\x7f])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +

		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +

		// "Attribute values must be CSS identifiers [capture 5]
		// or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" +
		whitespace + "*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +

		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +

		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +

		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" +
		whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace +
		"*" ),
	rdescend = new RegExp( whitespace + "|>" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" +
			whitespace + "*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" +
			whitespace + "*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),

		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace +
			"*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" + whitespace +
			"*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rhtml = /HTML$/i,
	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,

	// CSS escapes
	// http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\[\\da-fA-F]{1,6}" + whitespace + "?|\\\\([^\\r\\n\\f])", "g" ),
	funescape = function( escape, nonHex ) {
		var high = "0x" + escape.slice( 1 ) - 0x10000;

		return nonHex ?

			// Strip the backslash prefix from a non-hex escape sequence
			nonHex :

			// Replace a hexadecimal escape sequence with the encoded Unicode code point
			// Support: IE <=11+
			// For values outside the Basic Multilingual Plane (BMP), manually construct a
			// surrogate pair
			high < 0 ?
				String.fromCharCode( high + 0x10000 ) :
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// CSS string/identifier serialization
	// https://drafts.csswg.org/cssom/#common-serializing-idioms
	rcssescape = /([\0-\x1f\x7f]|^-?\d)|^-$|[^\0-\x1f\x7f-\uFFFF\w-]/g,
	fcssescape = function( ch, asCodePoint ) {
		if ( asCodePoint ) {

			// U+0000 NULL becomes U+FFFD REPLACEMENT CHARACTER
			if ( ch === "\0" ) {
				return "\uFFFD";
			}

			// Control characters and (dependent upon position) numbers get escaped as code points
			return ch.slice( 0, -1 ) + "\\" +
				ch.charCodeAt( ch.length - 1 ).toString( 16 ) + " ";
		}

		// Other potentially-special ASCII characters get backslash-escaped
		return "\\" + ch;
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	},

	inDisabledFieldset = addCombinator(
		function( elem ) {
			return elem.disabled === true && elem.nodeName.toLowerCase() === "fieldset";
		},
		{ dir: "parentNode", next: "legend" }
	);

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		( arr = slice.call( preferredDoc.childNodes ) ),
		preferredDoc.childNodes
	);

	// Support: Android<4.0
	// Detect silently failing push.apply
	// eslint-disable-next-line no-unused-expressions
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			pushNative.apply( target, slice.call( els ) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;

			// Can't trust NodeList.length
			while ( ( target[ j++ ] = els[ i++ ] ) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {
		setDocument( context );
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && ( match = rquickExpr.exec( selector ) ) ) {

				// ID selector
				if ( ( m = match[ 1 ] ) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( ( elem = context.getElementById( m ) ) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && ( elem = newContext.getElementById( m ) ) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[ 2 ] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( ( m = match[ 3 ] ) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!nonnativeSelectorCache[ selector + " " ] &&
				( !rbuggyQSA || !rbuggyQSA.test( selector ) ) &&

				// Support: IE 8 only
				// Exclude object elements
				( nodeType !== 1 || context.nodeName.toLowerCase() !== "object" ) ) {

				newSelector = selector;
				newContext = context;

				// qSA considers elements outside a scoping root when evaluating child or
				// descendant combinators, which is not what we want.
				// In such cases, we work around the behavior by prefixing every selector in the
				// list with an ID selector referencing the scope context.
				// The technique has to be used as well when a leading combinator is used
				// as such selectors are not recognized by querySelectorAll.
				// Thanks to Andrew Dupont for this technique.
				if ( nodeType === 1 &&
					( rdescend.test( selector ) || rcombinators.test( selector ) ) ) {

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;

					// We can use :scope instead of the ID hack if the browser
					// supports it & if we're not changing the context.
					if ( newContext !== context || !support.scope ) {

						// Capture the context ID, setting it first if necessary
						if ( ( nid = context.getAttribute( "id" ) ) ) {
							nid = nid.replace( rcssescape, fcssescape );
						} else {
							context.setAttribute( "id", ( nid = expando ) );
						}
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					while ( i-- ) {
						groups[ i ] = ( nid ? "#" + nid : ":scope" ) + " " +
							toSelector( groups[ i ] );
					}
					newSelector = groups.join( "," );
				}

				try {
					push.apply( results,
						newContext.querySelectorAll( newSelector )
					);
					return results;
				} catch ( qsaError ) {
					nonnativeSelectorCache( selector, true );
				} finally {
					if ( nid === expando ) {
						context.removeAttribute( "id" );
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {

		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {

			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return ( cache[ key + " " ] = value );
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created element and returns a boolean result
 */
function assert( fn ) {
	var el = document.createElement( "fieldset" );

	try {
		return !!fn( el );
	} catch ( e ) {
		return false;
	} finally {

		// Remove from its parent by default
		if ( el.parentNode ) {
			el.parentNode.removeChild( el );
		}

		// release memory in IE
		el = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split( "|" ),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[ i ] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			a.sourceIndex - b.sourceIndex;

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( ( cur = cur.nextSibling ) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return ( name === "input" || name === "button" ) && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for :enabled/:disabled
 * @param {Boolean} disabled true for :disabled; false for :enabled
 */
function createDisabledPseudo( disabled ) {

	// Known :disabled false positives: fieldset[disabled] > legend:nth-of-type(n+2) :can-disable
	return function( elem ) {

		// Only certain elements can match :enabled or :disabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-enabled
		// https://html.spec.whatwg.org/multipage/scripting.html#selector-disabled
		if ( "form" in elem ) {

			// Check for inherited disabledness on relevant non-disabled elements:
			// * listed form-associated elements in a disabled fieldset
			//   https://html.spec.whatwg.org/multipage/forms.html#category-listed
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-fe-disabled
			// * option elements in a disabled optgroup
			//   https://html.spec.whatwg.org/multipage/forms.html#concept-option-disabled
			// All such elements have a "form" property.
			if ( elem.parentNode && elem.disabled === false ) {

				// Option elements defer to a parent optgroup if present
				if ( "label" in elem ) {
					if ( "label" in elem.parentNode ) {
						return elem.parentNode.disabled === disabled;
					} else {
						return elem.disabled === disabled;
					}
				}

				// Support: IE 6 - 11
				// Use the isDisabled shortcut property to check for disabled fieldset ancestors
				return elem.isDisabled === disabled ||

					// Where there is no isDisabled, check manually
					/* jshint -W018 */
					elem.isDisabled !== !disabled &&
					inDisabledFieldset( elem ) === disabled;
			}

			return elem.disabled === disabled;

		// Try to winnow out elements that can't be disabled before trusting the disabled property.
		// Some victims get caught in our net (label, legend, menu, track), but it shouldn't
		// even exist on them, let alone have a boolean value.
		} else if ( "label" in elem ) {
			return elem.disabled === disabled;
		}

		// Remaining elements are neither :enabled nor :disabled
		return false;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction( function( argument ) {
		argument = +argument;
		return markFunction( function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ ( j = matchIndexes[ i ] ) ] ) {
					seed[ j ] = !( matches[ j ] = seed[ j ] );
				}
			}
		} );
	} );
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	var namespace = elem.namespaceURI,
		docElem = ( elem.ownerDocument || elem ).documentElement;

	// Support: IE <=8
	// Assume HTML when documentElement doesn't yet exist, such as inside loading iframes
	// https://bugs.jquery.com/ticket/4833
	return !rhtml.test( namespace || docElem && docElem.nodeName || "HTML" );
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, subWindow,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( doc == document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9 - 11+, Edge 12 - 18+
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( preferredDoc != document &&
		( subWindow = document.defaultView ) && subWindow.top !== subWindow ) {

		// Support: IE 11, Edge
		if ( subWindow.addEventListener ) {
			subWindow.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( subWindow.attachEvent ) {
			subWindow.attachEvent( "onunload", unloadHandler );
		}
	}

	// Support: IE 8 - 11+, Edge 12 - 18+, Chrome <=16 - 25 only, Firefox <=3.6 - 31 only,
	// Safari 4 - 5 only, Opera <=11.6 - 12.x only
	// IE/Edge & older browsers don't support the :scope pseudo-class.
	// Support: Safari 6.0 only
	// Safari 6.0 supports :scope but it's an alias of :root there.
	support.scope = assert( function( el ) {
		docElem.appendChild( el ).appendChild( document.createElement( "div" ) );
		return typeof el.querySelectorAll !== "undefined" &&
			!el.querySelectorAll( ":scope fieldset div" ).length;
	} );

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert( function( el ) {
		el.className = "i";
		return !el.getAttribute( "className" );
	} );

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert( function( el ) {
		el.appendChild( document.createComment( "" ) );
		return !el.getElementsByTagName( "*" ).length;
	} );

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programmatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert( function( el ) {
		docElem.appendChild( el ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	} );

	// ID filter and find
	if ( support.getById ) {
		Expr.filter[ "ID" ] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute( "id" ) === attrId;
			};
		};
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var elem = context.getElementById( id );
				return elem ? [ elem ] : [];
			}
		};
	} else {
		Expr.filter[ "ID" ] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode( "id" );
				return node && node.value === attrId;
			};
		};

		// Support: IE 6 - 7 only
		// getElementById is not reliable as a find shortcut
		Expr.find[ "ID" ] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var node, i, elems,
					elem = context.getElementById( id );

				if ( elem ) {

					// Verify the id attribute
					node = elem.getAttributeNode( "id" );
					if ( node && node.value === id ) {
						return [ elem ];
					}

					// Fall back on getElementsByName
					elems = context.getElementsByName( id );
					i = 0;
					while ( ( elem = elems[ i++ ] ) ) {
						node = elem.getAttributeNode( "id" );
						if ( node && node.value === id ) {
							return [ elem ];
						}
					}
				}

				return [];
			}
		};
	}

	// Tag
	Expr.find[ "TAG" ] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,

				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( ( elem = results[ i++ ] ) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find[ "CLASS" ] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See https://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( ( support.qsa = rnative.test( document.querySelectorAll ) ) ) {

		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert( function( el ) {

			var input;

			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// https://bugs.jquery.com/ticket/12359
			docElem.appendChild( el ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// https://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( el.querySelectorAll( "[msallowcapture^='']" ).length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !el.querySelectorAll( "[selected]" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !el.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push( "~=" );
			}

			// Support: IE 11+, Edge 15 - 18+
			// IE 11/Edge don't find elements on a `[name='']` query in some cases.
			// Adding a temporary attribute to the document before the selection works
			// around the issue.
			// Interestingly, IE 10 & older don't seem to have the issue.
			input = document.createElement( "input" );
			input.setAttribute( "name", "" );
			el.appendChild( input );
			if ( !el.querySelectorAll( "[name='']" ).length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*name" + whitespace + "*=" +
					whitespace + "*(?:''|\"\")" );
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !el.querySelectorAll( ":checked" ).length ) {
				rbuggyQSA.push( ":checked" );
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibling-combinator selector` fails
			if ( !el.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push( ".#.+[+~]" );
			}

			// Support: Firefox <=3.6 - 5 only
			// Old Firefox doesn't throw on a badly-escaped identifier.
			el.querySelectorAll( "\\\f" );
			rbuggyQSA.push( "[\\r\\n\\f]" );
		} );

		assert( function( el ) {
			el.innerHTML = "<a href='' disabled='disabled'></a>" +
				"<select disabled='disabled'><option/></select>";

			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement( "input" );
			input.setAttribute( "type", "hidden" );
			el.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( el.querySelectorAll( "[name=d]" ).length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( el.querySelectorAll( ":enabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: IE9-11+
			// IE's :disabled selector does not pick up the children of disabled fieldsets
			docElem.appendChild( el ).disabled = true;
			if ( el.querySelectorAll( ":disabled" ).length !== 2 ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Support: Opera 10 - 11 only
			// Opera 10-11 does not throw on post-comma invalid pseudos
			el.querySelectorAll( "*,:x" );
			rbuggyQSA.push( ",.*:" );
		} );
	}

	if ( ( support.matchesSelector = rnative.test( ( matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector ) ) ) ) {

		assert( function( el ) {

			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( el, "*" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( el, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		} );
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join( "|" ) );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join( "|" ) );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			) );
		} :
		function( a, b ) {
			if ( b ) {
				while ( ( b = b.parentNode ) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		// Support: IE 11+, Edge 17 - 18+
		// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
		// two documents; shallow comparisons work.
		// eslint-disable-next-line eqeqeq
		compare = ( a.ownerDocument || a ) == ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			( !support.sortDetached && b.compareDocumentPosition( a ) === compare ) ) {

			// Choose the first element that is related to our preferred document
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( a == document || a.ownerDocument == preferredDoc &&
				contains( preferredDoc, a ) ) {
				return -1;
			}

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			// eslint-disable-next-line eqeqeq
			if ( b == document || b.ownerDocument == preferredDoc &&
				contains( preferredDoc, b ) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {

		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {

			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			return a == document ? -1 :
				b == document ? 1 :
				/* eslint-enable eqeqeq */
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( ( cur = cur.parentNode ) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( ( cur = cur.parentNode ) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[ i ] === bp[ i ] ) {
			i++;
		}

		return i ?

			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[ i ], bp[ i ] ) :

			// Otherwise nodes in our document sort first
			// Support: IE 11+, Edge 17 - 18+
			// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
			// two documents; shallow comparisons work.
			/* eslint-disable eqeqeq */
			ap[ i ] == preferredDoc ? -1 :
			bp[ i ] == preferredDoc ? 1 :
			/* eslint-enable eqeqeq */
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	setDocument( elem );

	if ( support.matchesSelector && documentIsHTML &&
		!nonnativeSelectorCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||

				// As well, disconnected nodes are said to be in a document
				// fragment in IE 9
				elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch ( e ) {
			nonnativeSelectorCache( expr, true );
		}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( context.ownerDocument || context ) != document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {

	// Set document vars if needed
	// Support: IE 11+, Edge 17 - 18+
	// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
	// two documents; shallow comparisons work.
	// eslint-disable-next-line eqeqeq
	if ( ( elem.ownerDocument || elem ) != document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],

		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			( val = elem.getAttributeNode( name ) ) && val.specified ?
				val.value :
				null;
};

Sizzle.escape = function( sel ) {
	return ( sel + "" ).replace( rcssescape, fcssescape );
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( ( elem = results[ i++ ] ) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {

		// If no nodeType, this is expected to be an array
		while ( ( node = elem[ i++ ] ) ) {

			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {

		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {

			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}

	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[ 1 ] = match[ 1 ].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[ 3 ] = ( match[ 3 ] || match[ 4 ] ||
				match[ 5 ] || "" ).replace( runescape, funescape );

			if ( match[ 2 ] === "~=" ) {
				match[ 3 ] = " " + match[ 3 ] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {

			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[ 1 ] = match[ 1 ].toLowerCase();

			if ( match[ 1 ].slice( 0, 3 ) === "nth" ) {

				// nth-* requires argument
				if ( !match[ 3 ] ) {
					Sizzle.error( match[ 0 ] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[ 4 ] = +( match[ 4 ] ?
					match[ 5 ] + ( match[ 6 ] || 1 ) :
					2 * ( match[ 3 ] === "even" || match[ 3 ] === "odd" ) );
				match[ 5 ] = +( ( match[ 7 ] + match[ 8 ] ) || match[ 3 ] === "odd" );

				// other types prohibit arguments
			} else if ( match[ 3 ] ) {
				Sizzle.error( match[ 0 ] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[ 6 ] && match[ 2 ];

			if ( matchExpr[ "CHILD" ].test( match[ 0 ] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[ 3 ] ) {
				match[ 2 ] = match[ 4 ] || match[ 5 ] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&

				// Get excess from tokenize (recursively)
				( excess = tokenize( unquoted, true ) ) &&

				// advance to the next closing parenthesis
				( excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length ) ) {

				// excess is a negative index
				match[ 0 ] = match[ 0 ].slice( 0, excess );
				match[ 2 ] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() {
					return true;
				} :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				( pattern = new RegExp( "(^|" + whitespace +
					")" + className + "(" + whitespace + "|$)" ) ) && classCache(
						className, function( elem ) {
							return pattern.test(
								typeof elem.className === "string" && elem.className ||
								typeof elem.getAttribute !== "undefined" &&
									elem.getAttribute( "class" ) ||
								""
							);
				} );
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				/* eslint-disable max-len */

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
				/* eslint-enable max-len */

			};
		},

		"CHILD": function( type, what, _argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, _context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( ( node = node[ dir ] ) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}

								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || ( node[ expando ] = {} );

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								( outerCache[ node.uniqueID ] = {} );

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( ( node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								( diff = nodeIndex = 0 ) || start.pop() ) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {

							// Use previously-cached element index if available
							if ( useCache ) {

								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || ( node[ expando ] = {} );

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									( outerCache[ node.uniqueID ] = {} );

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {

								// Use the same loop as above to seek `elem` from the start
								while ( ( node = ++nodeIndex && node && node[ dir ] ||
									( diff = nodeIndex = 0 ) || start.pop() ) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] ||
												( node[ expando ] = {} );

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												( outerCache[ node.uniqueID ] = {} );

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {

			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction( function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[ i ] );
							seed[ idx ] = !( matches[ idx ] = matched[ i ] );
						}
					} ) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {

		// Potentially complex pseudos
		"not": markFunction( function( selector ) {

			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction( function( seed, matches, _context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( ( elem = unmatched[ i ] ) ) {
							seed[ i ] = !( matches[ i ] = elem );
						}
					}
				} ) :
				function( elem, _context, xml ) {
					input[ 0 ] = elem;
					matcher( input, null, xml, results );

					// Don't keep the element (issue #299)
					input[ 0 ] = null;
					return !results.pop();
				};
		} ),

		"has": markFunction( function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		} ),

		"contains": markFunction( function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || getText( elem ) ).indexOf( text ) > -1;
			};
		} ),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {

			// lang value must be a valid identifier
			if ( !ridentifier.test( lang || "" ) ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( ( elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute( "xml:lang" ) || elem.getAttribute( "lang" ) ) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( ( elem = elem.parentNode ) && elem.nodeType === 1 );
				return false;
			};
		} ),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement &&
				( !document.hasFocus || document.hasFocus() ) &&
				!!( elem.type || elem.href || ~elem.tabIndex );
		},

		// Boolean properties
		"enabled": createDisabledPseudo( false ),
		"disabled": createDisabledPseudo( true ),

		"checked": function( elem ) {

			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return ( nodeName === "input" && !!elem.checked ) ||
				( nodeName === "option" && !!elem.selected );
		},

		"selected": function( elem ) {

			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				// eslint-disable-next-line no-unused-expressions
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {

			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos[ "empty" ]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( ( attr = elem.getAttribute( "type" ) ) == null ||
					attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo( function() {
			return [ 0 ];
		} ),

		"last": createPositionalPseudo( function( _matchIndexes, length ) {
			return [ length - 1 ];
		} ),

		"eq": createPositionalPseudo( function( _matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		} ),

		"even": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"odd": createPositionalPseudo( function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"lt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ?
				argument + length :
				argument > length ?
					length :
					argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} ),

		"gt": createPositionalPseudo( function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		} )
	}
};

Expr.pseudos[ "nth" ] = Expr.pseudos[ "eq" ];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || ( match = rcomma.exec( soFar ) ) ) {
			if ( match ) {

				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[ 0 ].length ) || soFar;
			}
			groups.push( ( tokens = [] ) );
		}

		matched = false;

		// Combinators
		if ( ( match = rcombinators.exec( soFar ) ) ) {
			matched = match.shift();
			tokens.push( {
				value: matched,

				// Cast descendant combinators to space
				type: match[ 0 ].replace( rtrim, " " )
			} );
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( ( match = matchExpr[ type ].exec( soFar ) ) && ( !preFilters[ type ] ||
				( match = preFilters[ type ]( match ) ) ) ) {
				matched = match.shift();
				tokens.push( {
					value: matched,
					type: type,
					matches: match
				} );
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :

			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[ i ].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		skip = combinator.next,
		key = skip || dir,
		checkNonElements = base && key === "parentNode",
		doneName = done++;

	return combinator.first ?

		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( ( elem = elem[ dir ] ) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
			return false;
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( ( elem = elem[ dir ] ) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || ( elem[ expando ] = {} );

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] ||
							( outerCache[ elem.uniqueID ] = {} );

						if ( skip && skip === elem.nodeName.toLowerCase() ) {
							elem = elem[ dir ] || elem;
						} else if ( ( oldCache = uniqueCache[ key ] ) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return ( newCache[ 2 ] = oldCache[ 2 ] );
						} else {

							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ key ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( ( newCache[ 2 ] = matcher( elem, context, xml ) ) ) {
								return true;
							}
						}
					}
				}
			}
			return false;
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[ i ]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[ 0 ];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[ i ], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( ( elem = unmatched[ i ] ) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction( function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts(
				selector || "*",
				context.nodeType ? [ context ] : context,
				[]
			),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?

				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( ( elem = temp[ i ] ) ) {
					matcherOut[ postMap[ i ] ] = !( matcherIn[ postMap[ i ] ] = elem );
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {

					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( ( elem = matcherOut[ i ] ) ) {

							// Restore matcherIn since elem is not yet a final match
							temp.push( ( matcherIn[ i ] = elem ) );
						}
					}
					postFinder( null, ( matcherOut = [] ), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( ( elem = matcherOut[ i ] ) &&
						( temp = postFinder ? indexOf( seed, elem ) : preMap[ i ] ) > -1 ) {

						seed[ temp ] = !( results[ temp ] = elem );
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	} );
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[ 0 ].type ],
		implicitRelative = leadingRelative || Expr.relative[ " " ],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				( checkContext = context ).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );

			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( ( matcher = Expr.relative[ tokens[ i ].type ] ) ) {
			matchers = [ addCombinator( elementMatcher( matchers ), matcher ) ];
		} else {
			matcher = Expr.filter[ tokens[ i ].type ].apply( null, tokens[ i ].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {

				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[ j ].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(

					// If the preceding token was a descendant combinator, insert an implicit any-element `*`
					tokens
						.slice( 0, i - 1 )
						.concat( { value: tokens[ i - 2 ].type === " " ? "*" : "" } )
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( ( tokens = tokens.slice( j ) ) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,

				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find[ "TAG" ]( "*", outermost ),

				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = ( dirruns += contextBackup == null ? 1 : Math.random() || 0.1 ),
				len = elems.length;

			if ( outermost ) {

				// Support: IE 11+, Edge 17 - 18+
				// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
				// two documents; shallow comparisons work.
				// eslint-disable-next-line eqeqeq
				outermostContext = context == document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && ( elem = elems[ i ] ) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;

					// Support: IE 11+, Edge 17 - 18+
					// IE/Edge sometimes throw a "Permission denied" error when strict-comparing
					// two documents; shallow comparisons work.
					// eslint-disable-next-line eqeqeq
					if ( !context && elem.ownerDocument != document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( ( matcher = elementMatchers[ j++ ] ) ) {
						if ( matcher( elem, context || document, xml ) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {

					// They will have gone through all possible matchers
					if ( ( elem = !matcher && elem ) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( ( matcher = setMatchers[ j++ ] ) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {

					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !( unmatched[ i ] || setMatched[ i ] ) ) {
								setMatched[ i ] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {

		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[ i ] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache(
			selector,
			matcherFromGroupMatchers( elementMatchers, setMatchers )
		);

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( ( selector = compiled.selector || selector ) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[ 0 ] = match[ 0 ].slice( 0 );
		if ( tokens.length > 2 && ( token = tokens[ 0 ] ).type === "ID" &&
			context.nodeType === 9 && documentIsHTML && Expr.relative[ tokens[ 1 ].type ] ) {

			context = ( Expr.find[ "ID" ]( token.matches[ 0 ]
				.replace( runescape, funescape ), context ) || [] )[ 0 ];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr[ "needsContext" ].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[ i ];

			// Abort if we hit a combinator
			if ( Expr.relative[ ( type = token.type ) ] ) {
				break;
			}
			if ( ( find = Expr.find[ type ] ) ) {

				// Search, expanding context for leading sibling combinators
				if ( ( seed = find(
					token.matches[ 0 ].replace( runescape, funescape ),
					rsibling.test( tokens[ 0 ].type ) && testContext( context.parentNode ) ||
						context
				) ) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split( "" ).sort( sortOrder ).join( "" ) === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert( function( el ) {

	// Should return 1, but returns 4 (following)
	return el.compareDocumentPosition( document.createElement( "fieldset" ) ) & 1;
} );

// Support: IE<8
// Prevent attribute/property "interpolation"
// https://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert( function( el ) {
	el.innerHTML = "<a href='#'></a>";
	return el.firstChild.getAttribute( "href" ) === "#";
} ) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	} );
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert( function( el ) {
	el.innerHTML = "<input/>";
	el.firstChild.setAttribute( "value", "" );
	return el.firstChild.getAttribute( "value" ) === "";
} ) ) {
	addHandle( "value", function( elem, _name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	} );
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert( function( el ) {
	return el.getAttribute( "disabled" ) == null;
} ) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
				( val = elem.getAttributeNode( name ) ) && val.specified ?
					val.value :
					null;
		}
	} );
}

return Sizzle;

} )( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;

// Deprecated
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;
jQuery.escapeSelector = Sizzle.escape;




var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;



function nodeName( elem, name ) {

  return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();

};
var rsingleTag = ( /^<([a-z][^\/\0>:\x20\t\r\n\f]*)[\x20\t\r\n\f]*\/?>(?:<\/\1>|)$/i );



// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			return !!qualifier.call( elem, i, elem ) !== not;
		} );
	}

	// Single element
	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );
	}

	// Arraylike of elements (jQuery, arguments, Array)
	if ( typeof qualifier !== "string" ) {
		return jQuery.grep( elements, function( elem ) {
			return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
		} );
	}

	// Filtered directly for both simple and complex selectors
	return jQuery.filter( qualifier, elements, not );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	if ( elems.length === 1 && elem.nodeType === 1 ) {
		return jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [];
	}

	return jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
		return elem.nodeType === 1;
	} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i, ret,
			len = this.length,
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		ret = this.pushStack( [] );

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		return len > 1 ? jQuery.uniqueSort( ret ) : ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	// Shortcut simple #id case for speed
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]+))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					if ( elem ) {

						// Inject the element directly into the jQuery object
						this[ 0 ] = elem;
						this.length = 1;
					}
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			targets = typeof selectors !== "string" && jQuery( selectors );

		// Positional selectors never match, since there's no _selection_ context
		if ( !rneedsContext.test( selectors ) ) {
			for ( ; i < l; i++ ) {
				for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

					// Always skip document fragments
					if ( cur.nodeType < 11 && ( targets ?
						targets.index( cur ) > -1 :

						// Don't pass non-elements to Sizzle
						cur.nodeType === 1 &&
							jQuery.find.matchesSelector( cur, selectors ) ) ) {

						matched.push( cur );
						break;
					}
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, _i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, _i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, _i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		if ( elem.contentDocument != null &&

			// Support: IE 11+
			// <object> elements with no `data` attribute has an object
			// `contentDocument` with a `null` prototype.
			getProto( elem.contentDocument ) ) {

			return elem.contentDocument;
		}

		// Support: IE 9 - 11 only, iOS 7 only, Android Browser <=4.3 only
		// Treat the template element as a regular one in browsers that
		// don't support it.
		if ( nodeName( elem, "template" ) ) {
			elem = elem.content || elem;
		}

		return jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnothtmlwhite = ( /[^\x20\t\r\n\f]+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnothtmlwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = locked || options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && toType( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory && !firing ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


function Identity( v ) {
	return v;
}
function Thrower( ex ) {
	throw ex;
}

function adoptValue( value, resolve, reject, noValue ) {
	var method;

	try {

		// Check for promise aspect first to privilege synchronous behavior
		if ( value && isFunction( ( method = value.promise ) ) ) {
			method.call( value ).done( resolve ).fail( reject );

		// Other thenables
		} else if ( value && isFunction( ( method = value.then ) ) ) {
			method.call( value, resolve, reject );

		// Other non-thenables
		} else {

			// Control `resolve` arguments by letting Array#slice cast boolean `noValue` to integer:
			// * false: [ value ].slice( 0 ) => resolve( value )
			// * true: [ value ].slice( 1 ) => resolve()
			resolve.apply( undefined, [ value ].slice( noValue ) );
		}

	// For Promises/A+, convert exceptions into rejections
	// Since jQuery.when doesn't unwrap thenables, we can skip the extra checks appearing in
	// Deferred#then to conditionally suppress rejection.
	} catch ( value ) {

		// Support: Android 4.0 only
		// Strict mode functions invoked without .call/.apply get global-object context
		reject.apply( undefined, [ value ] );
	}
}

jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, callbacks,
				// ... .then handlers, argument index, [final state]
				[ "notify", "progress", jQuery.Callbacks( "memory" ),
					jQuery.Callbacks( "memory" ), 2 ],
				[ "resolve", "done", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 0, "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ),
					jQuery.Callbacks( "once memory" ), 1, "rejected" ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				"catch": function( fn ) {
					return promise.then( null, fn );
				},

				// Keep pipe for back-compat
				pipe: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;

					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( _i, tuple ) {

							// Map tuples (progress, done, fail) to arguments (done, fail, progress)
							var fn = isFunction( fns[ tuple[ 4 ] ] ) && fns[ tuple[ 4 ] ];

							// deferred.progress(function() { bind to newDefer or newDefer.notify })
							// deferred.done(function() { bind to newDefer or newDefer.resolve })
							// deferred.fail(function() { bind to newDefer or newDefer.reject })
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},
				then: function( onFulfilled, onRejected, onProgress ) {
					var maxDepth = 0;
					function resolve( depth, deferred, handler, special ) {
						return function() {
							var that = this,
								args = arguments,
								mightThrow = function() {
									var returned, then;

									// Support: Promises/A+ section 2.3.3.3.3
									// https://promisesaplus.com/#point-59
									// Ignore double-resolution attempts
									if ( depth < maxDepth ) {
										return;
									}

									returned = handler.apply( that, args );

									// Support: Promises/A+ section 2.3.1
									// https://promisesaplus.com/#point-48
									if ( returned === deferred.promise() ) {
										throw new TypeError( "Thenable self-resolution" );
									}

									// Support: Promises/A+ sections 2.3.3.1, 3.5
									// https://promisesaplus.com/#point-54
									// https://promisesaplus.com/#point-75
									// Retrieve `then` only once
									then = returned &&

										// Support: Promises/A+ section 2.3.4
										// https://promisesaplus.com/#point-64
										// Only check objects and functions for thenability
										( typeof returned === "object" ||
											typeof returned === "function" ) &&
										returned.then;

									// Handle a returned thenable
									if ( isFunction( then ) ) {

										// Special processors (notify) just wait for resolution
										if ( special ) {
											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special )
											);

										// Normal processors (resolve) also hook into progress
										} else {

											// ...and disregard older resolution values
											maxDepth++;

											then.call(
												returned,
												resolve( maxDepth, deferred, Identity, special ),
												resolve( maxDepth, deferred, Thrower, special ),
												resolve( maxDepth, deferred, Identity,
													deferred.notifyWith )
											);
										}

									// Handle all other returned values
									} else {

										// Only substitute handlers pass on context
										// and multiple values (non-spec behavior)
										if ( handler !== Identity ) {
											that = undefined;
											args = [ returned ];
										}

										// Process the value(s)
										// Default process is resolve
										( special || deferred.resolveWith )( that, args );
									}
								},

								// Only normal processors (resolve) catch and reject exceptions
								process = special ?
									mightThrow :
									function() {
										try {
											mightThrow();
										} catch ( e ) {

											if ( jQuery.Deferred.exceptionHook ) {
												jQuery.Deferred.exceptionHook( e,
													process.stackTrace );
											}

											// Support: Promises/A+ section 2.3.3.3.4.1
											// https://promisesaplus.com/#point-61
											// Ignore post-resolution exceptions
											if ( depth + 1 >= maxDepth ) {

												// Only substitute handlers pass on context
												// and multiple values (non-spec behavior)
												if ( handler !== Thrower ) {
													that = undefined;
													args = [ e ];
												}

												deferred.rejectWith( that, args );
											}
										}
									};

							// Support: Promises/A+ section 2.3.3.3.1
							// https://promisesaplus.com/#point-57
							// Re-resolve promises immediately to dodge false rejection from
							// subsequent errors
							if ( depth ) {
								process();
							} else {

								// Call an optional hook to record the stack, in case of exception
								// since it's otherwise lost when execution goes async
								if ( jQuery.Deferred.getStackHook ) {
									process.stackTrace = jQuery.Deferred.getStackHook();
								}
								window.setTimeout( process );
							}
						};
					}

					return jQuery.Deferred( function( newDefer ) {

						// progress_handlers.add( ... )
						tuples[ 0 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onProgress ) ?
									onProgress :
									Identity,
								newDefer.notifyWith
							)
						);

						// fulfilled_handlers.add( ... )
						tuples[ 1 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onFulfilled ) ?
									onFulfilled :
									Identity
							)
						);

						// rejected_handlers.add( ... )
						tuples[ 2 ][ 3 ].add(
							resolve(
								0,
								newDefer,
								isFunction( onRejected ) ?
									onRejected :
									Thrower
							)
						);
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 5 ];

			// promise.progress = list.add
			// promise.done = list.add
			// promise.fail = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add(
					function() {

						// state = "resolved" (i.e., fulfilled)
						// state = "rejected"
						state = stateString;
					},

					// rejected_callbacks.disable
					// fulfilled_callbacks.disable
					tuples[ 3 - i ][ 2 ].disable,

					// rejected_handlers.disable
					// fulfilled_handlers.disable
					tuples[ 3 - i ][ 3 ].disable,

					// progress_callbacks.lock
					tuples[ 0 ][ 2 ].lock,

					// progress_handlers.lock
					tuples[ 0 ][ 3 ].lock
				);
			}

			// progress_handlers.fire
			// fulfilled_handlers.fire
			// rejected_handlers.fire
			list.add( tuple[ 3 ].fire );

			// deferred.notify = function() { deferred.notifyWith(...) }
			// deferred.resolve = function() { deferred.resolveWith(...) }
			// deferred.reject = function() { deferred.rejectWith(...) }
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? undefined : this, arguments );
				return this;
			};

			// deferred.notifyWith = list.fireWith
			// deferred.resolveWith = list.fireWith
			// deferred.rejectWith = list.fireWith
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( singleValue ) {
		var

			// count of uncompleted subordinates
			remaining = arguments.length,

			// count of unprocessed arguments
			i = remaining,

			// subordinate fulfillment data
			resolveContexts = Array( i ),
			resolveValues = slice.call( arguments ),

			// the master Deferred
			master = jQuery.Deferred(),

			// subordinate callback factory
			updateFunc = function( i ) {
				return function( value ) {
					resolveContexts[ i ] = this;
					resolveValues[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( !( --remaining ) ) {
						master.resolveWith( resolveContexts, resolveValues );
					}
				};
			};

		// Single- and empty arguments are adopted like Promise.resolve
		if ( remaining <= 1 ) {
			adoptValue( singleValue, master.done( updateFunc( i ) ).resolve, master.reject,
				!remaining );

			// Use .then() to unwrap secondary thenables (cf. gh-3000)
			if ( master.state() === "pending" ||
				isFunction( resolveValues[ i ] && resolveValues[ i ].then ) ) {

				return master.then();
			}
		}

		// Multiple arguments are aggregated like Promise.all array elements
		while ( i-- ) {
			adoptValue( resolveValues[ i ], updateFunc( i ), master.reject );
		}

		return master.promise();
	}
} );


// These usually indicate a programmer mistake during development,
// warn about them ASAP rather than swallowing them by default.
var rerrorNames = /^(Eval|Internal|Range|Reference|Syntax|Type|URI)Error$/;

jQuery.Deferred.exceptionHook = function( error, stack ) {

	// Support: IE 8 - 9 only
	// Console exists when dev tools are open, which can happen at any time
	if ( window.console && window.console.warn && error && rerrorNames.test( error.name ) ) {
		window.console.warn( "jQuery.Deferred exception: " + error.message, error.stack, stack );
	}
};




jQuery.readyException = function( error ) {
	window.setTimeout( function() {
		throw error;
	} );
};




// The deferred used on DOM ready
var readyList = jQuery.Deferred();

jQuery.fn.ready = function( fn ) {

	readyList
		.then( fn )

		// Wrap jQuery.readyException in a function so that the lookup
		// happens at the time of error handling instead of callback
		// registration.
		.catch( function( error ) {
			jQuery.readyException( error );
		} );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );
	}
} );

jQuery.ready.then = readyList.then;

// The ready event handler and self cleanup method
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

// Catch cases where $(document).ready() is called
// after the browser event has already occurred.
// Support: IE <=9 - 10 only
// Older IE sometimes signals "interactive" too soon
if ( document.readyState === "complete" ||
	( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

	// Handle it asynchronously to allow scripts the opportunity to delay ready
	window.setTimeout( jQuery.ready );

} else {

	// Use the handy event callback
	document.addEventListener( "DOMContentLoaded", completed );

	// A fallback to window.onload, that will always work
	window.addEventListener( "load", completed );
}




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( toType( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, _key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	if ( chainable ) {
		return elems;
	}

	// Gets
	if ( bulk ) {
		return fn.call( elems );
	}

	return len ? fn( elems[ 0 ], key ) : emptyGet;
};


// Matches dashed string for camelizing
var rmsPrefix = /^-ms-/,
	rdashAlpha = /-([a-z])/g;

// Used by camelCase as callback to replace()
function fcamelCase( _all, letter ) {
	return letter.toUpperCase();
}

// Convert dashed to camelCase; used by the css and data modules
// Support: IE <=9 - 11, Edge 12 - 15
// Microsoft forgot to hump their vendor prefix (#9572)
function camelCase( string ) {
	return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
}
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	cache: function( owner ) {

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		// Always use camelCase key (gh-2257)
		if ( typeof data === "string" ) {
			cache[ camelCase( data ) ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ camelCase( prop ) ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :

			// Always use camelCase key (gh-2257)
			owner[ this.expando ] && owner[ this.expando ][ camelCase( key ) ];
	},
	access: function( owner, key, value ) {

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			return this.get( owner, key );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key !== undefined ) {

			// Support array or space separated string of keys
			if ( Array.isArray( key ) ) {

				// If key is an array of keys...
				// We always set camelCase keys, so remove that.
				key = key.map( camelCase );
			} else {
				key = camelCase( key );

				// If a key with the spaces exists, use it.
				// Otherwise, create an array by matching non-whitespace
				key = key in cache ?
					[ key ] :
					( key.match( rnothtmlwhite ) || [] );
			}

			i = key.length;

			while ( i-- ) {
				delete cache[ key[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <=35 - 45
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://bugs.chromium.org/p/chromium/issues/detail?id=378607 (bug restricted)
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function getData( data ) {
	if ( data === "true" ) {
		return true;
	}

	if ( data === "false" ) {
		return false;
	}

	if ( data === "null" ) {
		return null;
	}

	// Only convert to a number if it doesn't change the string
	if ( data === +data + "" ) {
		return +data;
	}

	if ( rbrace.test( data ) ) {
		return JSON.parse( data );
	}

	return data;
}

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = getData( data );
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE 11 only
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// The key will always be camelCased in Data
				data = dataUser.get( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, key );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			this.each( function() {

				// We always store the camelCased key
				dataUser.set( this, key, value );
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || Array.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var documentElement = document.documentElement;



	var isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem );
		},
		composed = { composed: true };

	// Support: IE 9 - 11+, Edge 12 - 18+, iOS 10.0 - 10.2 only
	// Check attachment across shadow DOM boundaries when possible (gh-3504)
	// Support: iOS 10.0-10.2 only
	// Early iOS 10 versions support `attachShadow` but not `getRootNode`,
	// leading to errors. We need to check for `getRootNode`.
	if ( documentElement.getRootNode ) {
		isAttached = function( elem ) {
			return jQuery.contains( elem.ownerDocument, elem ) ||
				elem.getRootNode( composed ) === elem.ownerDocument;
		};
	}
var isHiddenWithinTree = function( elem, el ) {

		// isHiddenWithinTree might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;

		// Inline style trumps all
		return elem.style.display === "none" ||
			elem.style.display === "" &&

			// Otherwise, check computed style
			// Support: Firefox <=43 - 45
			// Disconnected elements can have computed display: none, so first confirm that elem is
			// in the document.
			isAttached( elem ) &&

			jQuery.css( elem, "display" ) === "none";
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted, scale,
		maxIterations = 20,
		currentValue = tween ?
			function() {
				return tween.cur();
			} :
			function() {
				return jQuery.css( elem, prop, "" );
			},
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = elem.nodeType &&
			( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Support: Firefox <=54
		// Halve the iteration target value to prevent interference from CSS upper bounds (gh-2144)
		initial = initial / 2;

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		while ( maxIterations-- ) {

			// Evaluate and update our best guess (doubling guesses that zero out).
			// Finish if the scale equals or crosses 1 (making the old*new product non-positive).
			jQuery.style( elem, prop, initialInUnit + unit );
			if ( ( 1 - scale ) * ( 1 - ( scale = currentValue() / initial || 0.5 ) ) <= 0 ) {
				maxIterations = 0;
			}
			initialInUnit = initialInUnit / scale;

		}

		initialInUnit = initialInUnit * 2;
		jQuery.style( elem, prop, initialInUnit + unit );

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}


var defaultDisplayMap = {};

function getDefaultDisplay( elem ) {
	var temp,
		doc = elem.ownerDocument,
		nodeName = elem.nodeName,
		display = defaultDisplayMap[ nodeName ];

	if ( display ) {
		return display;
	}

	temp = doc.body.appendChild( doc.createElement( nodeName ) );
	display = jQuery.css( temp, "display" );

	temp.parentNode.removeChild( temp );

	if ( display === "none" ) {
		display = "block";
	}
	defaultDisplayMap[ nodeName ] = display;

	return display;
}

function showHide( elements, show ) {
	var display, elem,
		values = [],
		index = 0,
		length = elements.length;

	// Determine new display value for elements that need to change
	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		display = elem.style.display;
		if ( show ) {

			// Since we force visibility upon cascade-hidden elements, an immediate (and slow)
			// check is required in this first loop unless we have a nonempty display value (either
			// inline or about-to-be-restored)
			if ( display === "none" ) {
				values[ index ] = dataPriv.get( elem, "display" ) || null;
				if ( !values[ index ] ) {
					elem.style.display = "";
				}
			}
			if ( elem.style.display === "" && isHiddenWithinTree( elem ) ) {
				values[ index ] = getDefaultDisplay( elem );
			}
		} else {
			if ( display !== "none" ) {
				values[ index ] = "none";

				// Remember what we're overwriting
				dataPriv.set( elem, "display", display );
			}
		}
	}

	// Set the display of the elements in a second loop to avoid constant reflow
	for ( index = 0; index < length; index++ ) {
		if ( values[ index ] != null ) {
			elements[ index ].style.display = values[ index ];
		}
	}

	return elements;
}

jQuery.fn.extend( {
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHiddenWithinTree( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([a-z][^\/\0>\x20\t\r\n\f]*)/i );

var rscriptType = ( /^$|^module$|\/(?:java|ecma)script/i );



( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0 - 4.3 only
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Android <=4.1 only
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE <=11 only
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;

	// Support: IE <=9 only
	// IE <=9 replaces <option> tags with their contents when inserted outside of
	// the select element.
	div.innerHTML = "<option></option>";
	support.option = !!div.lastChild;
} )();


// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;

// Support: IE <=9 only
if ( !support.option ) {
	wrapMap.optgroup = wrapMap.option = [ 1, "<select multiple='multiple'>", "</select>" ];
}


function getAll( context, tag ) {

	// Support: IE <=9 - 11 only
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret;

	if ( typeof context.getElementsByTagName !== "undefined" ) {
		ret = context.getElementsByTagName( tag || "*" );

	} else if ( typeof context.querySelectorAll !== "undefined" ) {
		ret = context.querySelectorAll( tag || "*" );

	} else {
		ret = [];
	}

	if ( tag === undefined || tag && nodeName( context, tag ) ) {
		return jQuery.merge( [ context ], ret );
	}

	return ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, attached, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( toType( elem ) === "object" ) {

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android <=4.0 only, PhantomJS 1 only
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		attached = isAttached( elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( attached ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE <=9 - 11+
// focus() and blur() are asynchronous, except when they are no-op.
// So expect focus to be synchronous when the element is already active,
// and blur to be synchronous when the element is not already active.
// (focus and blur are always synchronous in other supported browsers,
// this just defines when we can count on it).
function expectSync( elem, type ) {
	return ( elem === safeActiveElement() ) === ( type === "focus" );
}

// Support: IE <=9 only
// Accessing document.activeElement can throw unexpectedly
// https://bugs.jquery.com/ticket/13393
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return elem;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Only attach events to objects that accept data
		if ( !acceptData( elem ) ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Ensure that invalid selectors throw exceptions at attach time
		// Evaluate against documentElement in case elem is a non-element node (e.g., document)
		if ( selector ) {
			jQuery.find.matchesSelector( documentElement, selector );
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = Object.create( null );
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnothtmlwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( nativeEvent ) {

		var i, j, ret, matched, handleObj, handlerQueue,
			args = new Array( arguments.length ),

			// Make a writable jQuery.Event from the native event object
			event = jQuery.event.fix( nativeEvent ),

			handlers = (
					dataPriv.get( this, "events" ) || Object.create( null )
				)[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;

		for ( i = 1; i < arguments.length; i++ ) {
			args[ i ] = arguments[ i ];
		}

		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// If the event is namespaced, then each handler is only invoked if it is
				// specially universal or its namespaces are a superset of the event's.
				if ( !event.rnamespace || handleObj.namespace === false ||
					event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, handleObj, sel, matchedHandlers, matchedSelectors,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Find delegate handlers
		if ( delegateCount &&

			// Support: IE <=9
			// Black-hole SVG <use> instance trees (trac-13180)
			cur.nodeType &&

			// Support: Firefox <=42
			// Suppress spec-violating clicks indicating a non-primary pointer button (trac-3861)
			// https://www.w3.org/TR/DOM-Level-3-Events/#event-type-click
			// Support: IE 11 only
			// ...but not arrow key "clicks" of radio inputs, which can have `button` -1 (gh-2343)
			!( event.type === "click" && event.button >= 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && !( event.type === "click" && cur.disabled === true ) ) {
					matchedHandlers = [];
					matchedSelectors = {};
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matchedSelectors[ sel ] === undefined ) {
							matchedSelectors[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matchedSelectors[ sel ] ) {
							matchedHandlers.push( handleObj );
						}
					}
					if ( matchedHandlers.length ) {
						handlerQueue.push( { elem: cur, handlers: matchedHandlers } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		cur = this;
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: cur, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	addProp: function( name, hook ) {
		Object.defineProperty( jQuery.Event.prototype, name, {
			enumerable: true,
			configurable: true,

			get: isFunction( hook ) ?
				function() {
					if ( this.originalEvent ) {
							return hook( this.originalEvent );
					}
				} :
				function() {
					if ( this.originalEvent ) {
							return this.originalEvent[ name ];
					}
				},

			set: function( value ) {
				Object.defineProperty( this, name, {
					enumerable: true,
					configurable: true,
					writable: true,
					value: value
				} );
			}
		} );
	},

	fix: function( originalEvent ) {
		return originalEvent[ jQuery.expando ] ?
			originalEvent :
			new jQuery.Event( originalEvent );
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		click: {

			// Utilize native event to ensure correct state for checkable inputs
			setup: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Claim the first handler
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					// dataPriv.set( el, "click", ... )
					leverageNative( el, "click", returnTrue );
				}

				// Return false to allow normal processing in the caller
				return false;
			},
			trigger: function( data ) {

				// For mutual compressibility with _default, replace `this` access with a local var.
				// `|| data` is dead code meant only to preserve the variable through minification.
				var el = this || data;

				// Force setup before triggering a click
				if ( rcheckableType.test( el.type ) &&
					el.click && nodeName( el, "input" ) ) {

					leverageNative( el, "click" );
				}

				// Return non-false to allow normal event-path propagation
				return true;
			},

			// For cross-browser consistency, suppress native .click() on links
			// Also prevent it if we're currently inside a leveraged native-event stack
			_default: function( event ) {
				var target = event.target;
				return rcheckableType.test( target.type ) &&
					target.click && nodeName( target, "input" ) &&
					dataPriv.get( target, "click" ) ||
					nodeName( target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

// Ensure the presence of an event listener that handles manually-triggered
// synthetic events by interrupting progress until reinvoked in response to
// *native* events that it fires directly, ensuring that state changes have
// already occurred before other listeners are invoked.
function leverageNative( el, type, expectSync ) {

	// Missing expectSync indicates a trigger call, which must force setup through jQuery.event.add
	if ( !expectSync ) {
		if ( dataPriv.get( el, type ) === undefined ) {
			jQuery.event.add( el, type, returnTrue );
		}
		return;
	}

	// Register the controller as a special universal handler for all event namespaces
	dataPriv.set( el, type, false );
	jQuery.event.add( el, type, {
		namespace: false,
		handler: function( event ) {
			var notAsync, result,
				saved = dataPriv.get( this, type );

			if ( ( event.isTrigger & 1 ) && this[ type ] ) {

				// Interrupt processing of the outer synthetic .trigger()ed event
				// Saved data should be false in such cases, but might be a leftover capture object
				// from an async native handler (gh-4350)
				if ( !saved.length ) {

					// Store arguments for use when handling the inner native event
					// There will always be at least one argument (an event object), so this array
					// will not be confused with a leftover capture object.
					saved = slice.call( arguments );
					dataPriv.set( this, type, saved );

					// Trigger the native event and capture its result
					// Support: IE <=9 - 11+
					// focus() and blur() are asynchronous
					notAsync = expectSync( this, type );
					this[ type ]();
					result = dataPriv.get( this, type );
					if ( saved !== result || notAsync ) {
						dataPriv.set( this, type, false );
					} else {
						result = {};
					}
					if ( saved !== result ) {

						// Cancel the outer synthetic event
						event.stopImmediatePropagation();
						event.preventDefault();
						return result.value;
					}

				// If this is an inner synthetic event for an event with a bubbling surrogate
				// (focus or blur), assume that the surrogate already propagated from triggering the
				// native event and prevent that from happening again here.
				// This technically gets the ordering wrong w.r.t. to `.trigger()` (in which the
				// bubbling surrogate propagates *after* the non-bubbling base), but that seems
				// less bad than duplication.
				} else if ( ( jQuery.event.special[ type ] || {} ).delegateType ) {
					event.stopPropagation();
				}

			// If this is a native event triggered above, everything is now in order
			// Fire an inner synthetic event with the original arguments
			} else if ( saved.length ) {

				// ...and capture the result
				dataPriv.set( this, type, {
					value: jQuery.event.trigger(

						// Support: IE <=9 - 11+
						// Extend with the prototype to reset the above stopImmediatePropagation()
						jQuery.extend( saved[ 0 ], jQuery.Event.prototype ),
						saved.slice( 1 ),
						this
					)
				} );

				// Abort handling of the native event
				event.stopImmediatePropagation();
			}
		}
	} );
}

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android <=2.3 only
				src.returnValue === false ?
			returnTrue :
			returnFalse;

		// Create target properties
		// Support: Safari <=6 - 7 only
		// Target should not be a text node (#504, #13143)
		this.target = ( src.target && src.target.nodeType === 3 ) ?
			src.target.parentNode :
			src.target;

		this.currentTarget = src.currentTarget;
		this.relatedTarget = src.relatedTarget;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || Date.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// https://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,
	isSimulated: false,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e && !this.isSimulated ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e && !this.isSimulated ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Includes all common event props including KeyEvent and MouseEvent specific props
jQuery.each( {
	altKey: true,
	bubbles: true,
	cancelable: true,
	changedTouches: true,
	ctrlKey: true,
	detail: true,
	eventPhase: true,
	metaKey: true,
	pageX: true,
	pageY: true,
	shiftKey: true,
	view: true,
	"char": true,
	code: true,
	charCode: true,
	key: true,
	keyCode: true,
	button: true,
	buttons: true,
	clientX: true,
	clientY: true,
	offsetX: true,
	offsetY: true,
	pointerId: true,
	pointerType: true,
	screenX: true,
	screenY: true,
	targetTouches: true,
	toElement: true,
	touches: true,

	which: function( event ) {
		var button = event.button;

		// Add which for key events
		if ( event.which == null && rkeyEvent.test( event.type ) ) {
			return event.charCode != null ? event.charCode : event.keyCode;
		}

		// Add which for click: 1 === left; 2 === middle; 3 === right
		if ( !event.which && button !== undefined && rmouseEvent.test( event.type ) ) {
			if ( button & 1 ) {
				return 1;
			}

			if ( button & 2 ) {
				return 3;
			}

			if ( button & 4 ) {
				return 2;
			}

			return 0;
		}

		return event.which;
	}
}, jQuery.event.addProp );

jQuery.each( { focus: "focusin", blur: "focusout" }, function( type, delegateType ) {
	jQuery.event.special[ type ] = {

		// Utilize native event if possible so blur/focus sequence is correct
		setup: function() {

			// Claim the first handler
			// dataPriv.set( this, "focus", ... )
			// dataPriv.set( this, "blur", ... )
			leverageNative( this, type, expectSync );

			// Return false to allow normal processing in the caller
			return false;
		},
		trigger: function() {

			// Force setup before trigger
			leverageNative( this, type );

			// Return non-false to allow normal event-path propagation
			return true;
		},

		delegateType: delegateType
	};
} );

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://bugs.chromium.org/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {

	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var

	// Support: IE <=10 - 11, Edge 12 - 13 only
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

// Prefer a tbody over its parent table for containing new rows
function manipulationTarget( elem, content ) {
	if ( nodeName( elem, "table" ) &&
		nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return jQuery( elem ).children( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	if ( ( elem.type || "" ).slice( 0, 5 ) === "true/" ) {
		elem.type = elem.type.slice( 5 );
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.get( src );
		events = pdataOld.events;

		if ( events ) {
			dataPriv.remove( dest, "handle events" );

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = flat( args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		valueIsFunction = isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( valueIsFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( valueIsFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android <=4.0 only, PhantomJS 1 only
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src && ( node.type || "" ).toLowerCase()  !== "module" ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl && !node.noModule ) {
								jQuery._evalUrl( node.src, {
									nonce: node.nonce || node.getAttribute( "nonce" )
								}, doc );
							}
						} else {
							DOMEval( node.textContent.replace( rcleanScript, "" ), node, doc );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && isAttached( node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html;
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = isAttached( elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: https://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <=35 - 45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {
	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: Android <=4.0 only, PhantomJS 1 only
			// .get() because push.apply(_, arraylike) throws on ancient WebKit
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );
var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE <=11 only, Firefox <=30 (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view || !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.call( elem );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var rboxStyle = new RegExp( cssExpand.join( "|" ), "i" );



( function() {

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {

		// This is a singleton, we need to execute it only once
		if ( !div ) {
			return;
		}

		container.style.cssText = "position:absolute;left:-11111px;width:60px;" +
			"margin-top:1px;padding:0;border:0";
		div.style.cssText =
			"position:relative;display:block;box-sizing:border-box;overflow:scroll;" +
			"margin:auto;border:1px;padding:1px;" +
			"width:60%;top:1%";
		documentElement.appendChild( container ).appendChild( div );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";

		// Support: Android 4.0 - 4.3 only, Firefox <=3 - 44
		reliableMarginLeftVal = roundPixelMeasures( divStyle.marginLeft ) === 12;

		// Support: Android 4.0 - 4.3 only, Safari <=9.1 - 10.1, iOS <=7.0 - 9.3
		// Some styles come back with percentage values, even though they shouldn't
		div.style.right = "60%";
		pixelBoxStylesVal = roundPixelMeasures( divStyle.right ) === 36;

		// Support: IE 9 - 11 only
		// Detect misreporting of content dimensions for box-sizing:border-box elements
		boxSizingReliableVal = roundPixelMeasures( divStyle.width ) === 36;

		// Support: IE 9 only
		// Detect overflow:scroll screwiness (gh-3699)
		// Support: Chrome <=64
		// Don't get tricked when zoom affects offsetWidth (gh-4029)
		div.style.position = "absolute";
		scrollboxSizeVal = roundPixelMeasures( div.offsetWidth / 3 ) === 12;

		documentElement.removeChild( container );

		// Nullify the div so it wouldn't be stored in the memory and
		// it will also be a sign that checks already performed
		div = null;
	}

	function roundPixelMeasures( measure ) {
		return Math.round( parseFloat( measure ) );
	}

	var pixelPositionVal, boxSizingReliableVal, scrollboxSizeVal, pixelBoxStylesVal,
		reliableTrDimensionsVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE <=9 - 11 only
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	jQuery.extend( support, {
		boxSizingReliable: function() {
			computeStyleTests();
			return boxSizingReliableVal;
		},
		pixelBoxStyles: function() {
			computeStyleTests();
			return pixelBoxStylesVal;
		},
		pixelPosition: function() {
			computeStyleTests();
			return pixelPositionVal;
		},
		reliableMarginLeft: function() {
			computeStyleTests();
			return reliableMarginLeftVal;
		},
		scrollboxSize: function() {
			computeStyleTests();
			return scrollboxSizeVal;
		},

		// Support: IE 9 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Behavior in IE 9 is more subtle than in newer versions & it passes
		// some versions of this test; make sure not to make it pass there!
		reliableTrDimensions: function() {
			var table, tr, trChild, trStyle;
			if ( reliableTrDimensionsVal == null ) {
				table = document.createElement( "table" );
				tr = document.createElement( "tr" );
				trChild = document.createElement( "div" );

				table.style.cssText = "position:absolute;left:-11111px";
				tr.style.height = "1px";
				trChild.style.height = "9px";

				documentElement
					.appendChild( table )
					.appendChild( tr )
					.appendChild( trChild );

				trStyle = window.getComputedStyle( tr );
				reliableTrDimensionsVal = parseInt( trStyle.height ) > 3;

				documentElement.removeChild( table );
			}
			return reliableTrDimensionsVal;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,

		// Support: Firefox 51+
		// Retrieving style before computed somehow
		// fixes an issue with getting wrong values
		// on detached elements
		style = elem.style;

	computed = computed || getStyles( elem );

	// getPropertyValue is needed for:
	//   .css('filter') (IE 9 only, #12537)
	//   .css('--customProperty) (#3144)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !isAttached( elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// https://drafts.csswg.org/cssom/#resolved-values
		if ( !support.pixelBoxStyles() && rnumnonpx.test( ret ) && rboxStyle.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE <=9 - 11 only
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var cssPrefixes = [ "Webkit", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style,
	vendorProps = {};

// Return a vendor-prefixed property or undefined
function vendorPropName( name ) {

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

// Return a potentially-mapped jQuery.cssProps or vendor prefixed property
function finalPropName( name ) {
	var final = jQuery.cssProps[ name ] || vendorProps[ name ];

	if ( final ) {
		return final;
	}
	if ( name in emptyStyle ) {
		return name;
	}
	return vendorProps[ name ] = vendorPropName( name ) || name;
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,
	rcustomProp = /^--/,
	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	};

function setPositiveNumber( _elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function boxModelAdjustment( elem, dimension, box, isBorderBox, styles, computedVal ) {
	var i = dimension === "width" ? 1 : 0,
		extra = 0,
		delta = 0;

	// Adjustment may not be necessary
	if ( box === ( isBorderBox ? "border" : "content" ) ) {
		return 0;
	}

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin
		if ( box === "margin" ) {
			delta += jQuery.css( elem, box + cssExpand[ i ], true, styles );
		}

		// If we get here with a content-box, we're seeking "padding" or "border" or "margin"
		if ( !isBorderBox ) {

			// Add padding
			delta += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// For "border" or "margin", add border
			if ( box !== "padding" ) {
				delta += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );

			// But still keep track of it otherwise
			} else {
				extra += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}

		// If we get here with a border-box (content + padding + border), we're seeking "content" or
		// "padding" or "margin"
		} else {

			// For "content", subtract padding
			if ( box === "content" ) {
				delta -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// For "content" or "padding", subtract border
			if ( box !== "margin" ) {
				delta -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	// Account for positive content-box scroll gutter when requested by providing computedVal
	if ( !isBorderBox && computedVal >= 0 ) {

		// offsetWidth/offsetHeight is a rounded sum of content, padding, scroll gutter, and border
		// Assuming integer scroll gutter, subtract the rest and round down
		delta += Math.max( 0, Math.ceil(
			elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
			computedVal -
			delta -
			extra -
			0.5

		// If offsetWidth/offsetHeight is unknown, then we can't determine content-box scroll gutter
		// Use an explicit zero to avoid NaN (gh-3964)
		) ) || 0;
	}

	return delta;
}

function getWidthOrHeight( elem, dimension, extra ) {

	// Start with computed style
	var styles = getStyles( elem ),

		// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-4322).
		// Fake content-box until we know it's needed to know the true value.
		boxSizingNeeded = !support.boxSizingReliable() || extra,
		isBorderBox = boxSizingNeeded &&
			jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
		valueIsBorderBox = isBorderBox,

		val = curCSS( elem, dimension, styles ),
		offsetProp = "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 );

	// Support: Firefox <=54
	// Return a confounding non-pixel value or feign ignorance, as appropriate.
	if ( rnumnonpx.test( val ) ) {
		if ( !extra ) {
			return val;
		}
		val = "auto";
	}


	// Support: IE 9 - 11 only
	// Use offsetWidth/offsetHeight for when box sizing is unreliable.
	// In those cases, the computed value can be trusted to be border-box.
	if ( ( !support.boxSizingReliable() && isBorderBox ||

		// Support: IE 10 - 11+, Edge 15 - 18+
		// IE/Edge misreport `getComputedStyle` of table rows with width/height
		// set in CSS while `offset*` properties report correct values.
		// Interestingly, in some cases IE 9 doesn't suffer from this issue.
		!support.reliableTrDimensions() && nodeName( elem, "tr" ) ||

		// Fall back to offsetWidth/offsetHeight when value is "auto"
		// This happens for inline elements with no explicit setting (gh-3571)
		val === "auto" ||

		// Support: Android <=4.1 - 4.3 only
		// Also use offsetWidth/offsetHeight for misreported inline dimensions (gh-3602)
		!parseFloat( val ) && jQuery.css( elem, "display", false, styles ) === "inline" ) &&

		// Make sure the element is visible & connected
		elem.getClientRects().length ) {

		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

		// Where available, offsetWidth/offsetHeight approximate border box dimensions.
		// Where not available (e.g., SVG), assume unreliable box-sizing and interpret the
		// retrieved value as a content box dimension.
		valueIsBorderBox = offsetProp in elem;
		if ( valueIsBorderBox ) {
			val = elem[ offsetProp ];
		}
	}

	// Normalize "" and auto
	val = parseFloat( val ) || 0;

	// Adjust for the element's box model
	return ( val +
		boxModelAdjustment(
			elem,
			dimension,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles,

			// Provide the current computed size to request scroll gutter calculation (gh-3589)
			val
		)
	) + "px";
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"gridArea": true,
		"gridColumn": true,
		"gridColumnEnd": true,
		"gridColumnStart": true,
		"gridRow": true,
		"gridRowEnd": true,
		"gridRowStart": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name ),
			style = elem.style;

		// Make sure that we're working with the right name. We don't
		// want to query the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			// The isCustomProp check can be removed in jQuery 4.0 when we only auto-append
			// "px" to a few hardcoded values.
			if ( type === "number" && !isCustomProp ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				if ( isCustomProp ) {
					style.setProperty( name, value );
				} else {
					style[ name ] = value;
				}
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = camelCase( name ),
			isCustomProp = rcustomProp.test( name );

		// Make sure that we're working with the right name. We don't
		// want to modify the value if it is a CSS custom property
		// since they are user-defined.
		if ( !isCustomProp ) {
			name = finalPropName( origName );
		}

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}

		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( _i, dimension ) {
	jQuery.cssHooks[ dimension ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&

					// Support: Safari 8+
					// Table columns in Safari have non-zero offsetWidth & zero
					// getBoundingClientRect().width unless display is changed.
					// Support: IE <=11 only
					// Running getBoundingClientRect on a disconnected node
					// in IE throws an error.
					( !elem.getClientRects().length || !elem.getBoundingClientRect().width ) ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, dimension, extra );
						} ) :
						getWidthOrHeight( elem, dimension, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = getStyles( elem ),

				// Only read styles.position if the test has a chance to fail
				// to avoid forcing a reflow.
				scrollboxSizeBuggy = !support.scrollboxSize() &&
					styles.position === "absolute",

				// To avoid forcing a reflow, only fetch boxSizing if we need it (gh-3991)
				boxSizingNeeded = scrollboxSizeBuggy || extra,
				isBorderBox = boxSizingNeeded &&
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
				subtract = extra ?
					boxModelAdjustment(
						elem,
						dimension,
						extra,
						isBorderBox,
						styles
					) :
					0;

			// Account for unreliable border-box dimensions by comparing offset* to computed and
			// faking a content-box to get border and padding (gh-3699)
			if ( isBorderBox && scrollboxSizeBuggy ) {
				subtract -= Math.ceil(
					elem[ "offset" + dimension[ 0 ].toUpperCase() + dimension.slice( 1 ) ] -
					parseFloat( styles[ dimension ] ) -
					boxModelAdjustment( elem, dimension, "border", false, styles ) -
					0.5
				);
			}

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ dimension ] = value;
				value = jQuery.css( elem, dimension );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( prefix !== "margin" ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( Array.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 && (
					jQuery.cssHooks[ tween.prop ] ||
					tween.elem.style[ finalPropName( tween.prop ) ] != null ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE <=9 only
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, inProgress,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

function schedule() {
	if ( inProgress ) {
		if ( document.hidden === false && window.requestAnimationFrame ) {
			window.requestAnimationFrame( schedule );
		} else {
			window.setTimeout( schedule, jQuery.fx.interval );
		}

		jQuery.fx.tick();
	}
}

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = Date.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	var prop, value, toggle, hooks, oldfire, propTween, restoreDisplay, display,
		isBox = "width" in props || "height" in props,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHiddenWithinTree( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Queue-skipping animations hijack the fx hooks
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Detect show/hide animations
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.test( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// Pretend to be hidden if this is a "show" and
				// there is still data from a stopped show/hide
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;

				// Ignore all other no-op show/hide data
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );
		}
	}

	// Bail out if this is a no-op like .hide().hide()
	propTween = !jQuery.isEmptyObject( props );
	if ( !propTween && jQuery.isEmptyObject( orig ) ) {
		return;
	}

	// Restrict "overflow" and "display" styles during box animations
	if ( isBox && elem.nodeType === 1 ) {

		// Support: IE <=9 - 11, Edge 12 - 15
		// Record all 3 overflow attributes because IE does not infer the shorthand
		// from identically-valued overflowX and overflowY and Edge just mirrors
		// the overflowX value there.
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Identify a display type, preferring old show/hide data over the CSS cascade
		restoreDisplay = dataShow && dataShow.display;
		if ( restoreDisplay == null ) {
			restoreDisplay = dataPriv.get( elem, "display" );
		}
		display = jQuery.css( elem, "display" );
		if ( display === "none" ) {
			if ( restoreDisplay ) {
				display = restoreDisplay;
			} else {

				// Get nonempty value(s) by temporarily forcing visibility
				showHide( [ elem ], true );
				restoreDisplay = elem.style.display || restoreDisplay;
				display = jQuery.css( elem, "display" );
				showHide( [ elem ] );
			}
		}

		// Animate inline elements as inline-block
		if ( display === "inline" || display === "inline-block" && restoreDisplay != null ) {
			if ( jQuery.css( elem, "float" ) === "none" ) {

				// Restore the original display value at the end of pure show/hide animations
				if ( !propTween ) {
					anim.done( function() {
						style.display = restoreDisplay;
					} );
					if ( restoreDisplay == null ) {
						display = style.display;
						restoreDisplay = display === "none" ? "" : display;
					}
				}
				style.display = "inline-block";
			}
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// Implement show/hide animations
	propTween = false;
	for ( prop in orig ) {

		// General show/hide setup for this element animation
		if ( !propTween ) {
			if ( dataShow ) {
				if ( "hidden" in dataShow ) {
					hidden = dataShow.hidden;
				}
			} else {
				dataShow = dataPriv.access( elem, "fxshow", { display: restoreDisplay } );
			}

			// Store hidden/visible for toggle so `.stop().toggle()` "reverses"
			if ( toggle ) {
				dataShow.hidden = !hidden;
			}

			// Show elements before animating them
			if ( hidden ) {
				showHide( [ elem ], true );
			}

			/* eslint-disable no-loop-func */

			anim.done( function() {

			/* eslint-enable no-loop-func */

				// The final step of a "hide" animation is actually hiding the element
				if ( !hidden ) {
					showHide( [ elem ] );
				}
				dataPriv.remove( elem, "fxshow" );
				for ( prop in orig ) {
					jQuery.style( elem, prop, orig[ prop ] );
				}
			} );
		}

		// Per-property setup
		propTween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );
		if ( !( prop in dataShow ) ) {
			dataShow[ prop ] = propTween.start;
			if ( hidden ) {
				propTween.end = propTween.start;
				propTween.start = 0;
			}
		}
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( Array.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3 only
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			// If there's more to do, yield
			if ( percent < 1 && length ) {
				return remaining;
			}

			// If this was an empty animation, synthesize a final progress notification
			if ( !length ) {
				deferred.notifyWith( elem, [ animation, 1, 0 ] );
			}

			// Resolve the animation and report its conclusion
			deferred.resolveWith( elem, [ animation ] );
			return false;
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					result.stop.bind( result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	// Attach callbacks from options
	animation
		.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	return animation;
}

jQuery.Animation = jQuery.extend( Animation, {

	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnothtmlwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !isFunction( easing ) && easing
	};

	// Go to the end state if fx are off
	if ( jQuery.fx.off ) {
		opt.duration = 0;

	} else {
		if ( typeof opt.duration !== "number" ) {
			if ( opt.duration in jQuery.fx.speeds ) {
				opt.duration = jQuery.fx.speeds[ opt.duration ];

			} else {
				opt.duration = jQuery.fx.speeds._default;
			}
		}
	}

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHiddenWithinTree ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( _i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = Date.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Run the timer and safely remove it when done (allowing for external removal)
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	jQuery.fx.start();
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( inProgress ) {
		return;
	}

	inProgress = true;
	schedule();
};

jQuery.fx.stop = function() {
	inProgress = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// https://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: Android <=4.3 only
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE <=11 only
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: IE <=11 only
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// Attribute hooks are determined by the lowercase version
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			hooks = jQuery.attrHooks[ name.toLowerCase() ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name,
			i = 0,

			// Attribute names can contain non-HTML whitespace characters
			// https://html.spec.whatwg.org/multipage/syntax.html#attributes-2
			attrNames = value && value.match( rnothtmlwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};

jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( _i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle,
			lowercaseName = name.toLowerCase();

		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ lowercaseName ];
			attrHandle[ lowercaseName ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				lowercaseName :
				null;
			attrHandle[ lowercaseName ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// Support: IE <=9 - 11 only
				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// https://web.archive.org/web/20141116233347/http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				if ( tabindex ) {
					return parseInt( tabindex, 10 );
				}

				if (
					rfocusable.test( elem.nodeName ) ||
					rclickable.test( elem.nodeName ) &&
					elem.href
				) {
					return 0;
				}

				return -1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

// Support: IE <=11 only
// Accessing the selectedIndex property
// forces the browser to respect setting selected
// on the option
// The getter ensures a default option is selected
// when in an optgroup
// eslint rule "no-unused-expressions" is disabled for this code
// since it considers such accessions noop
if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		},
		set: function( elem ) {

			/* eslint no-unused-expressions: "off" */

			var parent = elem.parentNode;
			if ( parent ) {
				parent.selectedIndex;

				if ( parent.parentNode ) {
					parent.parentNode.selectedIndex;
				}
			}
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




	// Strip and collapse whitespace according to HTML spec
	// https://infra.spec.whatwg.org/#strip-and-collapse-ascii-whitespace
	function stripAndCollapse( value ) {
		var tokens = value.match( rnothtmlwhite ) || [];
		return tokens.join( " " );
	}


function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

function classesToArray( value ) {
	if ( Array.isArray( value ) ) {
		return value;
	}
	if ( typeof value === "string" ) {
		return value.match( rnothtmlwhite ) || [];
	}
	return [];
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		classes = classesToArray( value );

		if ( classes.length ) {
			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 && ( " " + stripAndCollapse( curValue ) + " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = stripAndCollapse( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value,
			isValidValue = type === "string" || Array.isArray( value );

		if ( typeof stateVal === "boolean" && isValidValue ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( isValidValue ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = classesToArray( value );

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + stripAndCollapse( getClass( elem ) ) + " " ).indexOf( className ) > -1 ) {
					return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, valueIsFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				// Handle most common string cases
				if ( typeof ret === "string" ) {
					return ret.replace( rreturn, "" );
				}

				// Handle cases where value is null/undef or number
				return ret == null ? "" : ret;
			}

			return;
		}

		valueIsFunction = isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( valueIsFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( Array.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				var val = jQuery.find.attr( elem, "value" );
				return val != null ?
					val :

					// Support: IE <=10 - 11 only
					// option.text throws exceptions (#14686, #14858)
					// Strip and collapse whitespace
					// https://html.spec.whatwg.org/#strip-and-collapse-whitespace
					stripAndCollapse( jQuery.text( elem ) );
			}
		},
		select: {
			get: function( elem ) {
				var value, option, i,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one",
					values = one ? null : [],
					max = one ? index + 1 : options.length;

				if ( index < 0 ) {
					i = max;

				} else {
					i = one ? index : 0;
				}

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// Support: IE <=9 only
					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							!option.disabled &&
							( !option.parentNode.disabled ||
								!nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];

					/* eslint-disable no-cond-assign */

					if ( option.selected =
						jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}

					/* eslint-enable no-cond-assign */
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( Array.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


support.focusin = "onfocusin" in window;


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/,
	stopPropagationCallback = function( e ) {
		e.stopPropagation();
	};

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special, lastElement,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = lastElement = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {
			lastElement = cur;
			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = (
					dataPriv.get( cur, "events" ) || Object.create( null )
				)[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && isFunction( elem[ type ] ) && !isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;

					if ( event.isPropagationStopped() ) {
						lastElement.addEventListener( type, stopPropagationCallback );
					}

					elem[ type ]();

					if ( event.isPropagationStopped() ) {
						lastElement.removeEventListener( type, stopPropagationCallback );
					}

					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	// Used only for `focus(in | out)` events
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true
			}
		);

		jQuery.event.trigger( e, null, elem );
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


// Support: Firefox <=44
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome <=48 - 49, Safari <=9.0 - 9.1
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://bugs.chromium.org/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {

				// Handle: regular nodes (via `this.ownerDocument`), window
				// (via `this.document`) & document (via `this`).
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this.document || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = { guid: Date.now() };

var rquery = ( /\?/ );



// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE 9 - 11 only
	// IE throws on parseFromString with invalid input.
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( Array.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && toType( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, valueOrFunction ) {

			// If value is a function, invoke it and use its return value
			var value = isFunction( valueOrFunction ) ?
				valueOrFunction() :
				valueOrFunction;

			s[ s.length ] = encodeURIComponent( key ) + "=" +
				encodeURIComponent( value == null ? "" : value );
		};

	if ( a == null ) {
		return "";
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( Array.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( _i, elem ) {
			var val = jQuery( this ).val();

			if ( val == null ) {
				return null;
			}

			if ( Array.isArray( val ) ) {
				return jQuery.map( val, function( val ) {
					return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
				} );
			}

			return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


var
	r20 = /%20/g,
	rhash = /#.*$/,
	rantiCache = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnothtmlwhite ) || [];

		if ( isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

			// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",

		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": JSON.parse,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// Request state (becomes false upon send and true upon completion)
			completed,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// uncached part of the url
			uncached,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( completed ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() + " " ] =
									( responseHeaders[ match[ 1 ].toLowerCase() + " " ] || [] )
										.concat( match[ 2 ] );
							}
						}
						match = responseHeaders[ key.toLowerCase() + " " ];
					}
					return match == null ? null : match.join( ", " );
				},

				// Raw string
				getAllResponseHeaders: function() {
					return completed ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					if ( completed == null ) {
						name = requestHeadersNames[ name.toLowerCase() ] =
							requestHeadersNames[ name.toLowerCase() ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( completed == null ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( completed ) {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						} else {

							// Lazy-add the new callbacks in a way that preserves old ones
							for ( code in map ) {
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR );

		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = ( s.dataType || "*" ).toLowerCase().match( rnothtmlwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE <=8 - 11, Edge 12 - 15
			// IE throws exception on accessing the href property if url is malformed,
			// e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE <=8 - 11 only
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( completed ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		// Remove hash to simplify url manipulation
		cacheURL = s.url.replace( rhash, "" );

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// Remember the hash so we can put it back
			uncached = s.url.slice( cacheURL.length );

			// If data is available and should be processed, append data to url
			if ( s.data && ( s.processData || typeof s.data === "string" ) ) {
				cacheURL += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data;

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add or update anti-cache param if needed
			if ( s.cache === false ) {
				cacheURL = cacheURL.replace( rantiCache, "$1" );
				uncached = ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + ( nonce.guid++ ) +
					uncached;
			}

			// Put hash and anti-cache on the URL that will be requested (gh-1732)
			s.url = cacheURL + uncached;

		// Change '%20' to '+' if this is encoded form body content (gh-2658)
		} else if ( s.data && s.processData &&
			( s.contentType || "" ).indexOf( "application/x-www-form-urlencoded" ) === 0 ) {
			s.data = s.data.replace( r20, "+" );
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || completed ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		completeDeferred.add( s.complete );
		jqXHR.done( s.success );
		jqXHR.fail( s.error );

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( completed ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				completed = false;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Rethrow post-completion exceptions
				if ( completed ) {
					throw e;
				}

				// Propagate others as results
				done( -1, e );
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Ignore repeat invocations
			if ( completed ) {
				return;
			}

			completed = true;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Use a noop converter for missing script
			if ( !isSuccess && jQuery.inArray( "script", s.dataTypes ) > -1 ) {
				s.converters[ "text script" ] = function() {};
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( _i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );

jQuery.ajaxPrefilter( function( s ) {
	var i;
	for ( i in s.headers ) {
		if ( i.toLowerCase() === "content-type" ) {
			s.contentType = s.headers[ i ] || "";
		}
	}
} );


jQuery._evalUrl = function( url, options, doc ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		cache: true,
		async: false,
		global: false,

		// Only evaluate the response if it is successful (gh-4126)
		// dataFilter is not invoked for failure responses, so using it instead
		// of the default converter is kludgy but it works.
		converters: {
			"text script": function() {}
		},
		dataFilter: function( response ) {
			jQuery.globalEval( response, options, doc );
		}
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( this[ 0 ] ) {
			if ( isFunction( html ) ) {
				html = html.call( this[ 0 ] );
			}

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var htmlIsFunction = isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( htmlIsFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function( selector ) {
		this.parent( selector ).not( "body" ).each( function() {
			jQuery( this ).replaceWith( this.childNodes );
		} );
		return this;
	}
} );


jQuery.expr.pseudos.hidden = function( elem ) {
	return !jQuery.expr.pseudos.visible( elem );
};
jQuery.expr.pseudos.visible = function( elem ) {
	return !!( elem.offsetWidth || elem.offsetHeight || elem.getClientRects().length );
};




jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE <=9 only
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.ontimeout =
									xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE <=9 only
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE <=9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = xhr.ontimeout = callback( "error" );

				// Support: IE 9 only
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Prevent auto-execution of scripts when no explicit dataType was provided (See gh-2432)
jQuery.ajaxPrefilter( function( s ) {
	if ( s.crossDomain ) {
		s.contents.script = false;
	}
} );

// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain or forced-by-attrs requests
	if ( s.crossDomain || s.scriptAttrs ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" )
					.attr( s.scriptAttrs || {} )
					.prop( { charset: s.scriptCharset, src: s.url } )
					.on( "load error", callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					} );

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce.guid++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8 only
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( typeof data !== "string" ) {
		return [];
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	var base, parsed, scripts;

	if ( !context ) {

		// Stop scripts or inline event handlers from being executed immediately
		// by using document.implementation
		if ( support.createHTMLDocument ) {
			context = document.implementation.createHTMLDocument( "" );

			// Set the base href for the created document
			// so any parsed elements with URLs
			// are based on the document's URL (gh-2965)
			base = context.createElement( "base" );
			base.href = document.location.href;
			context.head.appendChild( base );
		} else {
			context = document;
		}
	}

	parsed = rsingleTag.exec( data );
	scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = stripAndCollapse( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( this, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




jQuery.expr.pseudos.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			if ( typeof props.top === "number" ) {
				props.top += "px";
			}
			if ( typeof props.left === "number" ) {
				props.left += "px";
			}
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {

	// offset() relates an element's border box to the document origin
	offset: function( options ) {

		// Preserve chaining for setter
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var rect, win,
			elem = this[ 0 ];

		if ( !elem ) {
			return;
		}

		// Return zeros for disconnected and hidden (display: none) elements (gh-2310)
		// Support: IE <=11 only
		// Running getBoundingClientRect on a
		// disconnected node in IE throws an error
		if ( !elem.getClientRects().length ) {
			return { top: 0, left: 0 };
		}

		// Get document-relative position by adding viewport scroll to viewport-relative gBCR
		rect = elem.getBoundingClientRect();
		win = elem.ownerDocument.defaultView;
		return {
			top: rect.top + win.pageYOffset,
			left: rect.left + win.pageXOffset
		};
	},

	// position() relates an element's margin box to its offset parent's padding box
	// This corresponds to the behavior of CSS absolute positioning
	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset, doc,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// position:fixed elements are offset from the viewport, which itself always has zero offset
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume position:fixed implies availability of getBoundingClientRect
			offset = elem.getBoundingClientRect();

		} else {
			offset = this.offset();

			// Account for the *real* offset parent, which can be the document or its root element
			// when a statically positioned element is identified
			doc = elem.ownerDocument;
			offsetParent = elem.offsetParent || doc.documentElement;
			while ( offsetParent &&
				( offsetParent === doc.body || offsetParent === doc.documentElement ) &&
				jQuery.css( offsetParent, "position" ) === "static" ) {

				offsetParent = offsetParent.parentNode;
			}
			if ( offsetParent && offsetParent !== elem && offsetParent.nodeType === 1 ) {

				// Incorporate borders into its offset, since they are outside its content origin
				parentOffset = jQuery( offsetParent ).offset();
				parentOffset.top += jQuery.css( offsetParent, "borderTopWidth", true );
				parentOffset.left += jQuery.css( offsetParent, "borderLeftWidth", true );
			}
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {

			// Coalesce documents and windows
			var win;
			if ( isWindow( elem ) ) {
				win = elem;
			} else if ( elem.nodeType === 9 ) {
				win = elem.defaultView;
			}

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari <=7 - 9.1, Chrome <=37 - 49
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://bugs.chromium.org/p/chromium/issues/detail?id=589347
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( _i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( isWindow( elem ) ) {

					// $( window ).outerWidth/Height return w/h including scrollbars (gh-1729)
					return funcName.indexOf( "outer" ) === 0 ?
						elem[ "inner" + name ] :
						elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable );
		};
	} );
} );


jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( _i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},

	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );

jQuery.each( ( "blur focus focusin focusout resize scroll click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup contextmenu" ).split( " " ),
	function( _i, name ) {

		// Handle event binding
		jQuery.fn[ name ] = function( data, fn ) {
			return arguments.length > 0 ?
				this.on( name, null, data, fn ) :
				this.trigger( name );
		};
	} );




// Support: Android <=4.0 only
// Make sure we trim BOM and NBSP
var rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g;

// Bind a function to a context, optionally partially applying any
// arguments.
// jQuery.proxy is deprecated to promote standards (specifically Function#bind)
// However, it is not slated for removal any time soon
jQuery.proxy = function( fn, context ) {
	var tmp, args, proxy;

	if ( typeof context === "string" ) {
		tmp = fn[ context ];
		context = fn;
		fn = tmp;
	}

	// Quick check to determine if target is callable, in the spec
	// this throws a TypeError, but we will just return undefined.
	if ( !isFunction( fn ) ) {
		return undefined;
	}

	// Simulated bind
	args = slice.call( arguments, 2 );
	proxy = function() {
		return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
	};

	// Set the guid of unique handler to the same of original handler, so it can be removed
	proxy.guid = fn.guid = fn.guid || jQuery.guid++;

	return proxy;
};

jQuery.holdReady = function( hold ) {
	if ( hold ) {
		jQuery.readyWait++;
	} else {
		jQuery.ready( true );
	}
};
jQuery.isArray = Array.isArray;
jQuery.parseJSON = JSON.parse;
jQuery.nodeName = nodeName;
jQuery.isFunction = isFunction;
jQuery.isWindow = isWindow;
jQuery.camelCase = camelCase;
jQuery.type = toType;

jQuery.now = Date.now;

jQuery.isNumeric = function( obj ) {

	// As of jQuery 3.0, isNumeric is limited to
	// strings and numbers (primitives or objects)
	// that can be coerced to finite numbers (gh-2662)
	var type = jQuery.type( obj );
	return ( type === "number" || type === "string" ) &&

		// parseFloat NaNs numeric-cast false positives ("")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		!isNaN( obj - parseFloat( obj ) );
};

jQuery.trim = function( text ) {
	return text == null ?
		"" :
		( text + "" ).replace( rtrim, "" );
};



// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( true ) {
	!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function() {
		return jQuery;
	}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}




var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( typeof noGlobal === "undefined" ) {
	window.jQuery = window.$ = jQuery;
}




return jQuery;
} );


/***/ }),

/***/ "./node_modules/jsts/dist/jsts.min.js":
/*!********************************************!*\
  !*** ./node_modules/jsts/dist/jsts.min.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// JSTS. See https://github.com/bjornharrtell/jsts
// Licenses:
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EDLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_EPLv1.txt
// https://github.com/bjornharrtell/jsts/blob/master/LICENSE_LICENSE_ES6_COLLECTIONS.txt
!function(t,e){ true?e(exports):undefined}(this,function(t){"use strict";function e(t,e){for(var n in e)e.hasOwnProperty(n)&&(t[n]=e[n])}function n(){}function i(){}function r(){}function s(){}function o(){}function a(){}function u(){}function l(t){this.message=t}function h(t,e){t.prototype=Object.create(e.prototype),t.prototype.constructor=t}function c(){if(0===arguments.length)l.call(this);else if(1===arguments.length){var t=arguments[0];l.call(this,t)}}function f(){}function g(){if(this.x=null,this.y=null,this.z=null,0===arguments.length)g.call(this,0,0);else if(1===arguments.length){var t=arguments[0];g.call(this,t.x,t.y,t.z)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];g.call(this,e,n,g.NULL_ORDINATE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.x=i,this.y=r,this.z=s}}function d(){if(this.dimensionsToTest=2,0===arguments.length)d.call(this,2);else if(1===arguments.length){var t=arguments[0];if(2!==t&&3!==t)throw new i("only 2 or 3 dimensions may be specified");this.dimensionsToTest=t}}function p(){}function v(){}function m(t){this.message=t||""}function y(){}function x(t){this.message=t||""}function E(t){this.message=t||""}function I(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function N(){if(I.apply(this),0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.ensureCapacity(t.length),this.add(t,!0)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.ensureCapacity(e.length),this.add(e,n)}}function C(){if(this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,0===arguments.length)this.init();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.init(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];this.init(r,s,o,a)}}function S(){}function w(){S.call(this,"Projective point not representable on the Cartesian plane.")}function L(){}function R(t,e){return t.interfaces_&&t.interfaces_().indexOf(e)>-1}function T(){}function P(t){this.str=t}function b(t){this.value=t}function O(){}function _(){if(this.hi=0,this.lo=0,0===arguments.length)this.init(0);else if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.init(t)}else if(arguments[0]instanceof _){var e=arguments[0];this.init(e)}else if("string"==typeof arguments[0]){var n=arguments[0];_.call(this,_.parse(n))}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.init(i,r)}}function M(){}function D(){}function A(){}function F(){if(this.x=null,this.y=null,this.w=null,0===arguments.length)this.x=0,this.y=0,this.w=1;else if(1===arguments.length){var t=arguments[0];this.x=t.x,this.y=t.y,this.w=1}else if(2===arguments.length){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var e=arguments[0],n=arguments[1];this.x=e,this.y=n,this.w=1}else if(arguments[0]instanceof F&&arguments[1]instanceof F){var i=arguments[0],r=arguments[1];this.x=i.y*r.w-r.y*i.w,this.y=r.x*i.w-i.x*r.w,this.w=i.x*r.y-r.x*i.y}else if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1];this.x=s.y-o.y,this.y=o.x-s.x,this.w=s.x*o.y-o.x*s.y}}else if(3===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2];this.x=a,this.y=u,this.w=l}else if(4===arguments.length){var h=arguments[0],c=arguments[1],f=arguments[2],d=arguments[3],p=h.y-c.y,v=c.x-h.x,m=h.x*c.y-c.x*h.y,y=f.y-d.y,x=d.x-f.x,E=f.x*d.y-d.x*f.y;this.x=v*E-x*m,this.y=y*m-p*E,this.w=p*x-y*v}}function G(){}function q(){}function B(){this.envelope=null,this.factory=null,this.SRID=null,this.userData=null;var t=arguments[0];this.factory=t,this.SRID=t.getSRID()}function z(){}function V(){}function k(){}function Y(){}function U(){}function X(){}function H(){}function W(){}function j(){}function K(){}function Z(){}function Q(){}function J(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function $(t){return null==t?$s:t.color}function tt(t){return null==t?null:t.parent}function et(t,e){null!==t&&(t.color=e)}function nt(t){return null==t?null:t.left}function it(t){return null==t?null:t.right}function rt(){this.root_=null,this.size_=0}function st(){}function ot(){}function at(){this.array_=[],arguments[0]instanceof v&&this.addAll(arguments[0])}function ut(){}function lt(){}function ht(){}function ct(){}function ft(){this.geometries=null;var t=arguments[0],e=arguments[1];if(B.call(this,e),null===t&&(t=[]),B.hasNullElements(t))throw new i("geometries must not contain null elements");this.geometries=t}function gt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function dt(){if(this.geom=null,this.geomFact=null,this.bnRule=null,this.endpointMap=null,1===arguments.length){var t=arguments[0];dt.call(this,t,V.MOD2_BOUNDARY_RULE)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.geom=e,this.geomFact=e.getFactory(),this.bnRule=n}}function pt(){this.count=null}function vt(){}function mt(){}function yt(){}function xt(){}function Et(){}function It(){}function Nt(){}function Ct(){}function St(){this.points=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function wt(){}function Lt(){this.coordinates=null;var t=arguments[0],e=arguments[1];B.call(this,e),this.init(t)}function Rt(){}function Tt(){this.shell=null,this.holes=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(B.call(this,n),null===t&&(t=this.getFactory().createLinearRing()),null===e&&(e=[]),B.hasNullElements(e))throw new i("holes must not contain null elements");if(t.isEmpty()&&B.hasNonEmptyElements(e))throw new i("shell is empty but holes are not");this.shell=t,this.holes=e}function Pt(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function bt(){if(arguments[0]instanceof g&&arguments[1]instanceof ie){var t=arguments[0],e=arguments[1];bt.call(this,e.getCoordinateSequenceFactory().create(t),e)}else if(R(arguments[0],D)&&arguments[1]instanceof ie){var n=arguments[0],i=arguments[1];St.call(this,n,i),this.validateConstruction()}}function Ot(){var t=arguments[0],e=arguments[1];ft.call(this,t,e)}function _t(){if(this.factory=null,this.isUserDataCopied=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.factory=t}}function Mt(){}function Dt(){}function At(){}function Ft(){}function Gt(){if(this.dimension=3,this.coordinates=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];Gt.call(this,t,3)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.coordinates=new Array(e).fill(null);for(var n=0;e>n;n++)this.coordinates[n]=new g}else if(R(arguments[0],D)){var i=arguments[0];if(null===i)return this.coordinates=new Array(0).fill(null),null;this.dimension=i.getDimension(),this.coordinates=new Array(i.size()).fill(null);for(var n=0;n<this.coordinates.length;n++)this.coordinates[n]=i.getCoordinateCopy(n)}}else if(2===arguments.length)if(arguments[0]instanceof Array&&Number.isInteger(arguments[1])){var r=arguments[0],s=arguments[1];this.coordinates=r,this.dimension=s,null===r&&(this.coordinates=new Array(0).fill(null))}else if(Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var o=arguments[0],a=arguments[1];this.coordinates=new Array(o).fill(null),this.dimension=a;for(var n=0;o>n;n++)this.coordinates[n]=new g}}function qt(){}function Bt(t,e){return t===e||t!==t&&e!==e}function zt(t,e){function n(t){return this&&this.constructor===n?(this._keys=[],this._values=[],this._itp=[],this.objectOnly=e,void(t&&Vt.call(this,t))):new n(t)}return e||io(t,"size",{get:Jt}),t.constructor=n,n.prototype=t,n}function Vt(t){this.add?t.forEach(this.add,this):t.forEach(function(t){this.set(t[0],t[1])},this)}function kt(t){return this.has(t)&&(this._keys.splice(no,1),this._values.splice(no,1),this._itp.forEach(function(t){no<t[0]&&t[0]--})),no>-1}function Yt(t){return this.has(t)?this._values[no]:void 0}function Ut(t,e){if(this.objectOnly&&e!==Object(e))throw new TypeError("Invalid value used as weak collection key");if(e!==e||0===e)for(no=t.length;no--&&!Bt(t[no],e););else no=t.indexOf(e);return no>-1}function Xt(t){return Ut.call(this,this._keys,t)}function Ht(t,e){return this.has(t)?this._values[no]=e:this._values[this._keys.push(t)-1]=e,this}function Wt(){(this._keys||0).length=this._values.length=0}function jt(){return Qt(this._itp,this._keys)}function Kt(){return Qt(this._itp,this._values)}function Zt(){return Qt(this._itp,this._keys,this._values)}function Qt(t,e,n){var i=[0],r=!1;return t.push(i),{next:function(){var s,o=i[0];return!r&&o<e.length?(s=n?[e[o],n[o]]:e[o],i[0]++):(r=!0,t.splice(t.indexOf(i),1)),{done:r,value:s}}}}function Jt(){return this._values.length}function $t(t,e){for(var n=this.entries();;){var i=n.next();if(i.done)break;t.call(e,i.value[1],i.value[0],this)}}function te(){this.map_=new so}function ee(){if(this.modelType=null,this.scale=null,0===arguments.length)this.modelType=ee.FLOATING;else if(1===arguments.length)if(arguments[0]instanceof ne){var t=arguments[0];this.modelType=t,t===ee.FIXED&&this.setScale(1)}else if("number"==typeof arguments[0]){var e=arguments[0];this.modelType=ee.FIXED,this.setScale(e)}else if(arguments[0]instanceof ee){var n=arguments[0];this.modelType=n.modelType,this.scale=n.scale}}function ne(){this.name=null;var t=arguments[0];this.name=t,ne.nameToTypeMap.put(t,this)}function ie(){if(this.precisionModel=null,this.coordinateSequenceFactory=null,this.SRID=null,0===arguments.length)ie.call(this,new ee,0);else if(1===arguments.length){if(R(arguments[0],G)){var t=arguments[0];ie.call(this,new ee,0,t)}else if(arguments[0]instanceof ee){var e=arguments[0];ie.call(this,e,0,ie.getDefaultCoordinateSequenceFactory())}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];ie.call(this,n,i,ie.getDefaultCoordinateSequenceFactory())}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.precisionModel=r,this.coordinateSequenceFactory=o,this.SRID=s}}function re(t){this.geometryFactory=t||new ie}function se(t){this.parser=new re(t)}function oe(){this.result=null,this.inputLines=Array(2).fill().map(function(){return Array(2)}),this.intPt=new Array(2).fill(null),this.intLineIndex=null,this._isProper=null,this.pa=null,this.pb=null,this.precisionModel=null,this.intPt[0]=new g,this.intPt[1]=new g,this.pa=this.intPt[0],this.pb=this.intPt[1],this.result=0}function ae(){oe.apply(this)}function ue(){}function le(){this.p=null,this.crossingCount=0,this.isPointOnSegment=!1;var t=arguments[0];this.p=t}function he(){}function ce(){if(this.p0=null,this.p1=null,0===arguments.length)ce.call(this,new g,new g);else if(1===arguments.length){var t=arguments[0];ce.call(this,t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0=e,this.p1=n}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];ce.call(this,new g(i,r),new g(s,o))}}function fe(){if(this.matrix=null,0===arguments.length)this.matrix=Array(3).fill().map(function(){return Array(3)}),this.setAll(lt.FALSE);else if(1===arguments.length)if("string"==typeof arguments[0]){var t=arguments[0];fe.call(this),this.set(t)}else if(arguments[0]instanceof fe){var e=arguments[0];fe.call(this),this.matrix[L.INTERIOR][L.INTERIOR]=e.matrix[L.INTERIOR][L.INTERIOR],this.matrix[L.INTERIOR][L.BOUNDARY]=e.matrix[L.INTERIOR][L.BOUNDARY],this.matrix[L.INTERIOR][L.EXTERIOR]=e.matrix[L.INTERIOR][L.EXTERIOR],this.matrix[L.BOUNDARY][L.INTERIOR]=e.matrix[L.BOUNDARY][L.INTERIOR],this.matrix[L.BOUNDARY][L.BOUNDARY]=e.matrix[L.BOUNDARY][L.BOUNDARY],this.matrix[L.BOUNDARY][L.EXTERIOR]=e.matrix[L.BOUNDARY][L.EXTERIOR],this.matrix[L.EXTERIOR][L.INTERIOR]=e.matrix[L.EXTERIOR][L.INTERIOR],this.matrix[L.EXTERIOR][L.BOUNDARY]=e.matrix[L.EXTERIOR][L.BOUNDARY],this.matrix[L.EXTERIOR][L.EXTERIOR]=e.matrix[L.EXTERIOR][L.EXTERIOR]}}function ge(){this.areaBasePt=null,this.triangleCent3=new g,this.areasum2=0,this.cg3=new g,this.lineCentSum=new g,this.totalLength=0,this.ptCount=0,this.ptCentSum=new g;var t=arguments[0];this.areaBasePt=null,this.add(t)}function de(t){this.message=t||""}function pe(){this.array_=[]}function ve(){this.treeSet=new at,this.list=new I}function me(){if(this.geomFactory=null,this.inputPts=null,1===arguments.length){var t=arguments[0];me.call(this,me.extractCoordinates(t),t.getFactory())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputPts=ve.filterCoordinates(e),this.geomFactory=n}}function ye(){this.origin=null;var t=arguments[0];this.origin=t}function xe(){this.inputGeom=null,this.factory=null,this.pruneEmptyGeometry=!0,this.preserveGeometryCollectionType=!0,this.preserveCollections=!1,this.preserveType=!1}function Ee(){if(this.snapTolerance=0,this.srcPts=null,this.seg=new ce,this.allowSnappingToSourceVertices=!1,this._isClosed=!1,arguments[0]instanceof St&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];Ee.call(this,t.getCoordinates(),e)}else if(arguments[0]instanceof Array&&"number"==typeof arguments[1]){var n=arguments[0],i=arguments[1];this.srcPts=n,this._isClosed=Ee.isClosed(n),this.snapTolerance=i}}function Ie(){this.srcGeom=null;var t=arguments[0];this.srcGeom=t}function Ne(){if(xe.apply(this),this.snapTolerance=null,this.snapPts=null,this.isSelfSnap=!1,2===arguments.length){var t=arguments[0],e=arguments[1];this.snapTolerance=t,this.snapPts=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.snapTolerance=n,this.snapPts=i,this.isSelfSnap=r}}function Ce(){this.isFirst=!0,this.commonMantissaBitsCount=53,this.commonBits=0,this.commonSignExp=null}function Se(){this.commonCoord=null,this.ccFilter=new we}function we(){this.commonBitsX=new Ce,this.commonBitsY=new Ce}function Le(){this.trans=null;var t=arguments[0];this.trans=t}function Re(){this.parent=null,this.atStart=null,this.max=null,this.index=null,this.subcollectionIterator=null;var t=arguments[0];this.parent=t,this.atStart=!0,this.index=0,this.max=t.getNumGeometries()}function Te(){if(this.boundaryRule=V.OGC_SFS_BOUNDARY_RULE,this.isIn=null,this.numBoundaries=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];if(null===t)throw new i("Rule must be non-null");this.boundaryRule=t}}function Pe(){}function be(){}function Oe(){this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function _e(){}function Me(){this.bounds=null,this.item=null;var t=arguments[0],e=arguments[1];this.bounds=t,this.item=e}function De(){this._size=null,this.items=null,this._size=0,this.items=new I,this.items.add(null)}function Ae(){}function Fe(){}function Ge(){if(this.childBoundables=new I,this.bounds=null,this.level=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.level=t}}function qe(){this.boundable1=null,this.boundable2=null,this._distance=null,this.itemDistance=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.boundable1=t,this.boundable2=e,this.itemDistance=n,this._distance=this.distance()}function Be(){if(this.root=null,this.built=!1,this.itemBoundables=new I,this.nodeCapacity=null,0===arguments.length)Be.call(this,Be.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];f.isTrue(t>1,"Node capacity must be greater than 1"),this.nodeCapacity=t}}function ze(){}function Ve(){}function ke(){if(0===arguments.length)ke.call(this,ke.DEFAULT_NODE_CAPACITY);else if(1===arguments.length){var t=arguments[0];Be.call(this,t)}}function Ye(){var t=arguments[0];Ge.call(this,t)}function Ue(){}function Xe(){this.segString=null,this.coord=null,this.segmentIndex=null,this.segmentOctant=null,this._isInterior=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.segString=t,this.coord=new g(e),this.segmentIndex=n,this.segmentOctant=i,this._isInterior=!e.equals2D(t.getCoordinate(n))}function He(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function We(){this.nodeList=null,this.edge=null,this.nodeIt=null,this.currNode=null,this.nextNode=null,this.currSegIndex=0;var t=arguments[0];this.nodeList=t,this.edge=t.getEdge(),this.nodeIt=t.iterator(),this.readNextNode()}function je(){}function Ke(){this.nodeList=new He(this),this.pts=null,this.data=null;var t=arguments[0],e=arguments[1];this.pts=t,this.data=e}function Ze(){this.tempEnv1=new C,this.tempEnv2=new C,this.overlapSeg1=new ce,this.overlapSeg2=new ce}function Qe(){this.pts=null,this.start=null,this.end=null,this.env=null,this.context=null,this.id=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.pts=t,this.start=e,this.end=n,this.context=i}function Je(){}function $e(){}function tn(){}function en(){if(this.segInt=null,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setSegmentIntersector(t)}}function nn(){if(this.monoChains=new I,this.index=new ke,this.idCounter=0,this.nodedSegStrings=null,this.nOverlaps=0,0===arguments.length);else if(1===arguments.length){var t=arguments[0];en.call(this,t)}}function rn(){Ze.apply(this),this.si=null;var t=arguments[0];this.si=t}function sn(){if(this.pt=null,1===arguments.length){var t=arguments[0];l.call(this,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];l.call(this,sn.msgWithCoord(e,n)),this.pt=new g(n)}}function on(){}function an(){this.findAllIntersections=!1,this.isCheckEndSegmentsOnly=!1,this.li=null,this.interiorIntersection=null,this.intSegments=null,this.intersections=new I,this.intersectionCount=0,this.keepIntersections=!0;var t=arguments[0];this.li=t,this.interiorIntersection=null}function un(){this.li=new ae,this.segStrings=null,this.findAllIntersections=!1,this.segInt=null,this._isValid=!0;var t=arguments[0];this.segStrings=t}function ln(){this.nv=null;var t=arguments[0];this.nv=new un(ln.toSegmentStrings(t))}function hn(){this.mapOp=null;var t=arguments[0];this.mapOp=t}function cn(){}function fn(){if(this.location=null,1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];this.init(t.length)}else if(Number.isInteger(arguments[0])){var e=arguments[0];this.init(1),this.location[cn.ON]=e}else if(arguments[0]instanceof fn){var n=arguments[0];if(this.init(n.location.length),null!==n)for(var i=0;i<this.location.length;i++)this.location[i]=n.location[i]}}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.init(3),this.location[cn.ON]=r,this.location[cn.LEFT]=s,this.location[cn.RIGHT]=o}}function gn(){if(this.elt=new Array(2).fill(null),1===arguments.length){if(Number.isInteger(arguments[0])){var t=arguments[0];this.elt[0]=new fn(t),this.elt[1]=new fn(t)}else if(arguments[0]instanceof gn){var e=arguments[0];this.elt[0]=new fn(e.elt[0]),this.elt[1]=new fn(e.elt[1])}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.elt[0]=new fn(L.NONE),this.elt[1]=new fn(L.NONE),this.elt[n].setLocation(i)}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.elt[0]=new fn(r,s,o),this.elt[1]=new fn(r,s,o)}else if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3];this.elt[0]=new fn(L.NONE,L.NONE,L.NONE),this.elt[1]=new fn(L.NONE,L.NONE,L.NONE),this.elt[a].setLocations(u,l,h)}}function dn(){this.startDe=null,this.maxNodeDegree=-1,this.edges=new I,this.pts=new I,this.label=new gn(L.NONE),this.ring=null,this._isHole=null,this.shell=null,this.holes=new I,this.geometryFactory=null;var t=arguments[0],e=arguments[1];this.geometryFactory=e,this.computePoints(t),this.computeRing()}function pn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function vn(){var t=arguments[0],e=arguments[1];dn.call(this,t,e)}function mn(){if(this.label=null,this._isInResult=!1,this._isCovered=!1,this._isCoveredSet=!1,this._isVisited=!1,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.label=t}}function yn(){mn.apply(this),this.coord=null,this.edges=null;var t=arguments[0],e=arguments[1];this.coord=t,this.edges=e,this.label=new gn(0,L.NONE)}function xn(){this.nodeMap=new rt,this.nodeFact=null;var t=arguments[0];this.nodeFact=t}function En(){if(this.edge=null,this.label=null,this.node=null,this.p0=null,this.p1=null,this.dx=null,this.dy=null,this.quadrant=null,1===arguments.length){var t=arguments[0];this.edge=t}else if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];En.call(this,e,n,i,null)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];En.call(this,r),this.init(s,o),this.label=a}}function In(){this._isForward=null,this._isInResult=!1,this._isVisited=!1,this.sym=null,this.next=null,this.nextMin=null,this.edgeRing=null,this.minEdgeRing=null,this.depth=[0,-999,-999];var t=arguments[0],e=arguments[1];if(En.call(this,t),this._isForward=e,e)this.init(t.getCoordinate(0),t.getCoordinate(1));else{var n=t.getNumPoints()-1;this.init(t.getCoordinate(n),t.getCoordinate(n-1))}this.computeDirectedLabel()}function Nn(){}function Cn(){if(this.edges=new I,this.nodes=null,this.edgeEndList=new I,0===arguments.length)this.nodes=new xn(new Nn);else if(1===arguments.length){var t=arguments[0];this.nodes=new xn(t)}}function Sn(){this.geometryFactory=null,this.shellList=new I;var t=arguments[0];this.geometryFactory=t}function wn(){this.op=null,this.geometryFactory=null,this.ptLocator=null,this.lineEdgesList=new I,this.resultLineList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.op=t,this.geometryFactory=e,this.ptLocator=n}function Ln(){this.op=null,this.geometryFactory=null,this.resultPointList=new I;var t=arguments[0],e=arguments[1];arguments[2];this.op=t,this.geometryFactory=e}function Rn(){}function Tn(){this.geom=null;var t=arguments[0];this.geom=t}function Pn(){this.edgeMap=new rt,this.edgeList=null,this.ptInAreaLocation=[L.NONE,L.NONE]}function bn(){Pn.apply(this),this.resultAreaEdgeList=null,this.label=null,this.SCANNING_FOR_INCOMING=1,this.LINKING_TO_OUTGOING=2}function On(){Nn.apply(this)}function _n(){this.mce=null,this.chainIndex=null;var t=arguments[0],e=arguments[1];this.mce=t,this.chainIndex=e}function Mn(){if(this.label=null,this.xValue=null,this.eventType=null,this.insertEvent=null,this.deleteEventIndex=null,this.obj=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.eventType=Mn.DELETE,this.xValue=t,this.insertEvent=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.eventType=Mn.INSERT,this.label=n,this.xValue=i,this.obj=r}}function Dn(){}function An(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.properIntersectionPoint=null,this.li=null,this.includeProper=null,this.recordIsolated=null,this.isSelfIntersection=null,this.numIntersections=0,this.numTests=0,this.bdyNodes=null,this._isDone=!1,this.isDoneWhenProperInt=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.li=t,this.includeProper=e,this.recordIsolated=n}function Fn(){Dn.apply(this),this.events=new I,this.nOverlaps=null}function Gn(){this.min=r.POSITIVE_INFINITY,this.max=r.NEGATIVE_INFINITY}function qn(){}function Bn(){Gn.apply(this),this.item=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.min=t,this.max=e,this.item=n}function zn(){Gn.apply(this),this.node1=null,this.node2=null;var t=arguments[0],e=arguments[1];this.node1=t,this.node2=e,this.buildExtent(this.node1,this.node2)}function Vn(){this.leaves=new I,this.root=null,this.level=0}function kn(){if(this.lines=null,this.isForcedToLineString=!1,1===arguments.length){var t=arguments[0];this.lines=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.lines=e,this.isForcedToLineString=n}}function Yn(){this.items=new I}function Un(){this.index=null;var t=arguments[0];if(!R(t,Rt))throw new i("Argument must be Polygonal");this.index=new Hn(t)}function Xn(){this.counter=null;var t=arguments[0];this.counter=t}function Hn(){this.index=new Vn;var t=arguments[0];this.init(t)}function Wn(){this.coord=null,this.segmentIndex=null,this.dist=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.coord=new g(t),this.segmentIndex=e,this.dist=n}function jn(){this.nodeMap=new rt,this.edge=null;var t=arguments[0];this.edge=t}function Kn(){}function Zn(){this.e=null,this.pts=null,this.startIndex=null,this.env1=new C,this.env2=new C;var t=arguments[0];this.e=t,this.pts=t.getCoordinates();var e=new Kn;this.startIndex=e.getChainStartIndices(this.pts)}function Qn(){this.depth=Array(2).fill().map(function(){return Array(3)});for(var t=0;2>t;t++)for(var e=0;3>e;e++)this.depth[t][e]=Qn.NULL_VALUE}function Jn(){if(mn.apply(this),this.pts=null,this.env=null,this.eiList=new jn(this),this.name=null,this.mce=null,this._isIsolated=!0,this.depth=new Qn,this.depthDelta=0,1===arguments.length){var t=arguments[0];Jn.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pts=e,this.label=n}}function $n(){if(Cn.apply(this),this.parentGeom=null,this.lineEdgeMap=new te,this.boundaryNodeRule=null,this.useBoundaryDeterminationRule=!0,this.argIndex=null,this.boundaryNodes=null,this._hasTooFewPoints=!1,this.invalidPoint=null,this.areaPtLocator=null,this.ptLocator=new Te,2===arguments.length){var t=arguments[0],e=arguments[1];$n.call(this,t,e,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.argIndex=n,this.parentGeom=i,this.boundaryNodeRule=r,null!==i&&this.add(i)}}function ti(){if(this.li=new ae,this.resultPrecisionModel=null,this.arg=null,1===arguments.length){var t=arguments[0];this.setComputationPrecision(t.getPrecisionModel()),this.arg=new Array(1).fill(null),this.arg[0]=new $n(0,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];ti.call(this,e,n,V.OGC_SFS_BOUNDARY_RULE)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];i.getPrecisionModel().compareTo(r.getPrecisionModel())>=0?this.setComputationPrecision(i.getPrecisionModel()):this.setComputationPrecision(r.getPrecisionModel()),this.arg=new Array(2).fill(null),this.arg[0]=new $n(0,i,s),this.arg[1]=new $n(1,r,s)}}function ei(){this.pts=null,this._orientation=null;var t=arguments[0];this.pts=t,this._orientation=ei.orientation(t)}function ni(){this.edges=new I,this.ocaMap=new rt}function ii(){this.ptLocator=new Te,this.geomFact=null,this.resultGeom=null,this.graph=null,this.edgeList=new ni,this.resultPolyList=new I,this.resultLineList=new I,this.resultPointList=new I;var t=arguments[0],e=arguments[1];ti.call(this,t,e),this.graph=new Cn(new On),this.geomFact=t.getFactory()}function ri(){this.geom=new Array(2).fill(null),this.snapTolerance=null,this.cbr=null;var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e,this.computeSnapTolerance()}function si(){this.geom=new Array(2).fill(null);var t=arguments[0],e=arguments[1];this.geom[0]=t,this.geom[1]=e}function oi(){this.factory=null,this.interiorPoint=null,this.maxWidth=0;var t=arguments[0];this.factory=t.getFactory(),this.add(t)}function ai(){this.poly=null,this.centreY=null,this.hiY=r.MAX_VALUE,this.loY=-r.MAX_VALUE;var t=arguments[0];this.poly=t,this.hiY=t.getEnvelopeInternal().getMaxY(),this.loY=t.getEnvelopeInternal().getMinY(),this.centreY=oi.avg(this.loY,this.hiY)}function ui(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.addInterior(t),null===this.interiorPoint&&this.addEndpoints(t)}function li(){this.centroid=null,this.minDistance=r.MAX_VALUE,this.interiorPoint=null;var t=arguments[0];this.centroid=t.getCentroid().getCoordinate(),this.add(t)}function hi(){}function ci(){this.p0=null,this.p1=null,this.p2=null;var t=arguments[0],e=arguments[1],n=arguments[2];this.p0=t,this.p1=e,this.p2=n}function fi(){this.input=null,this.extremalPts=null,this.centre=null,this.radius=0;var t=arguments[0];this.input=t}function gi(){if(this.inputGeom=null,this.isConvex=null,this.convexHullPts=null,this.minBaseSeg=new ce,this.minWidthPt=null,this.minPtIndex=null,this.minWidth=0,1===arguments.length){var t=arguments[0];gi.call(this,t,!1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isConvex=n}}function di(){this.inputGeom=null,this.distanceTolerance=null;var t=arguments[0];this.inputGeom=t}function pi(){xe.apply(this),this.distanceTolerance=null;var t=arguments[0];this.distanceTolerance=t}function vi(){this._orig=null,this._sym=null,this._next=null;var t=arguments[0];this._orig=t}function mi(){this._isMarked=!1;var t=arguments[0];vi.call(this,t)}function yi(){this.vertexMap=new te}function xi(){this._isStart=!1;var t=arguments[0];mi.call(this,t)}function Ei(){yi.apply(this)}function Ii(){this.result=null,this.factory=null,this.graph=null,this.lines=new I,this.nodeEdgeStack=new pe,this.ringStartEdge=null,this.graph=new Ei}function Ni(){this.items=new I,this.subnode=new Array(4).fill(null)}function Ci(){}function Si(t,e){var n,i,r,s,o={32:{d:127,c:128,b:0,a:0},64:{d:32752,c:0,b:0,a:0}},a={32:8,64:11}[t];if(s||(n=0>e||0>1/e,isFinite(e)||(s=o[t],n&&(s.d+=1<<t/4-1),i=Math.pow(2,a)-1,r=0)),!s){for(i={32:127,64:1023}[t],r=Math.abs(e);r>=2;)i++,r/=2;for(;1>r&&i>0;)i--,r*=2;0>=i&&(r/=2),32===t&&i>254&&(s={d:n?255:127,c:128,b:0,a:0},i=Math.pow(2,a)-1,r=0)}return i}function wi(){this.pt=new g,this.level=0,this.env=null;var t=arguments[0];this.computeKey(t)}function Li(){Ni.apply(this),this.env=null,this.centrex=null,this.centrey=null,this.level=null;var t=arguments[0],e=arguments[1];this.env=t,this.level=e,this.centrex=(t.getMinX()+t.getMaxX())/2,this.centrey=(t.getMinY()+t.getMaxY())/2}function Ri(){}function Ti(){Ni.apply(this)}function Pi(){this.root=null,this.minExtent=1,this.root=new Ti}function bi(t){this.geometryFactory=t||new ie}function Oi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new bi(this.geometryFactory)}function _i(){this.parser=new bi(this.geometryFactory)}function Mi(t){this.geometryFactory=t||new ie,this.precisionModel=this.geometryFactory.getPrecisionModel(),this.parser=new re(this.geometryFactory)}function Di(t){return[t.x,t.y]}function Ai(t){this.geometryFactory=t||new ie}function Fi(){if(this.noder=null,this.scaleFactor=null,this.offsetX=null,this.offsetY=null,this.isScaled=!1,2===arguments.length){var t=arguments[0],e=arguments[1];Fi.call(this,t,e,0,0)}else if(4===arguments.length){var n=arguments[0],i=arguments[1];arguments[2],arguments[3];this.noder=n,this.scaleFactor=i,this.isScaled=!this.isIntegerPrecision()}}function Gi(){if(this.inputGeom=null,this.isClosedEndpointsInInterior=!0,this.nonSimpleLocation=null,1===arguments.length){var t=arguments[0];this.inputGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.inputGeom=e,this.isClosedEndpointsInInterior=!n.isInBoundary(2)}}function qi(){this.pt=null,this.isClosed=null,this.degree=null;var t=arguments[0];this.pt=t,this.isClosed=!1,this.degree=0}function Bi(){if(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS,this.endCapStyle=Bi.CAP_ROUND,this.joinStyle=Bi.JOIN_ROUND,this.mitreLimit=Bi.DEFAULT_MITRE_LIMIT,this._isSingleSided=!1,this.simplifyFactor=Bi.DEFAULT_SIMPLIFY_FACTOR,0===arguments.length);else if(1===arguments.length){var t=arguments[0];this.setQuadrantSegments(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.setQuadrantSegments(e),this.setEndCapStyle(n)}else if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3];this.setQuadrantSegments(i),this.setEndCapStyle(r),this.setJoinStyle(s),this.setMitreLimit(o)}}function zi(){this.minIndex=-1,this.minCoord=null,this.minDe=null,this.orientedDe=null}function Vi(){this.array_=[]}function ki(){this.finder=null,this.dirEdgeList=new I,this.nodes=new I,this.rightMostCoord=null,this.env=null,this.finder=new zi}function Yi(){this.inputLine=null,
this.distanceTol=null,this.isDeleted=null,this.angleOrientation=he.COUNTERCLOCKWISE;var t=arguments[0];this.inputLine=t}function Ui(){this.ptList=null,this.precisionModel=null,this.minimimVertexDistance=0,this.ptList=new I}function Xi(){this.maxCurveSegmentError=0,this.filletAngleQuantum=null,this.closingSegLengthFactor=1,this.segList=null,this.distance=0,this.precisionModel=null,this.bufParams=null,this.li=null,this.s0=null,this.s1=null,this.s2=null,this.seg0=new ce,this.seg1=new ce,this.offset0=new ce,this.offset1=new ce,this.side=0,this._hasNarrowConcaveAngle=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.precisionModel=t,this.bufParams=e,this.li=new ae,this.filletAngleQuantum=Math.PI/2/e.getQuadrantSegments(),e.getQuadrantSegments()>=8&&e.getJoinStyle()===Bi.JOIN_ROUND&&(this.closingSegLengthFactor=Xi.MAX_CLOSING_SEG_LEN_FACTOR),this.init(n)}function Hi(){this.distance=0,this.precisionModel=null,this.bufParams=null;var t=arguments[0],e=arguments[1];this.precisionModel=t,this.bufParams=e}function Wi(){this.subgraphs=null,this.seg=new ce,this.cga=new he;var t=arguments[0];this.subgraphs=t}function ji(){this.upwardSeg=null,this.leftDepth=null;var t=arguments[0],e=arguments[1];this.upwardSeg=new ce(t),this.leftDepth=e}function Ki(){this.inputGeom=null,this.distance=null,this.curveBuilder=null,this.curveList=new I;var t=arguments[0],e=arguments[1],n=arguments[2];this.inputGeom=t,this.distance=e,this.curveBuilder=n}function Zi(){this._hasIntersection=!1,this.hasProper=!1,this.hasProperInterior=!1,this.hasInterior=!1,this.properIntersectionPoint=null,this.li=null,this.isSelfIntersection=null,this.numIntersections=0,this.numInteriorIntersections=0,this.numProperIntersections=0,this.numTests=0;var t=arguments[0];this.li=t}function Qi(){this.bufParams=null,this.workingPrecisionModel=null,this.workingNoder=null,this.geomFact=null,this.graph=null,this.edgeList=new ni;var t=arguments[0];this.bufParams=t}function Ji(){this.li=new ae,this.segStrings=null;var t=arguments[0];this.segStrings=t}function $i(){this.li=null,this.pt=null,this.originalPt=null,this.ptScaled=null,this.p0Scaled=null,this.p1Scaled=null,this.scaleFactor=null,this.minx=null,this.maxx=null,this.miny=null,this.maxy=null,this.corner=new Array(4).fill(null),this.safeEnv=null;var t=arguments[0],e=arguments[1],n=arguments[2];if(this.originalPt=t,this.pt=t,this.scaleFactor=e,this.li=n,0>=e)throw new i("Scale factor must be non-zero");1!==e&&(this.pt=new g(this.scale(t.x),this.scale(t.y)),this.p0Scaled=new g,this.p1Scaled=new g),this.initCorners(this.pt)}function tr(){this.tempEnv1=new C,this.selectedSegment=new ce}function er(){this.index=null;var t=arguments[0];this.index=t}function nr(){tr.apply(this),this.hotPixel=null,this.parentEdge=null,this.hotPixelVertexIndex=null,this._isNodeAdded=!1;var t=arguments[0],e=arguments[1],n=arguments[2];this.hotPixel=t,this.parentEdge=e,this.hotPixelVertexIndex=n}function ir(){this.li=null,this.interiorIntersections=null;var t=arguments[0];this.li=t,this.interiorIntersections=new I}function rr(){this.pm=null,this.li=null,this.scaleFactor=null,this.noder=null,this.pointSnapper=null,this.nodedSegStrings=null;var t=arguments[0];this.pm=t,this.li=new ae,this.li.setPrecisionModel(t),this.scaleFactor=t.getScale()}function sr(){if(this.argGeom=null,this.distance=null,this.bufParams=new Bi,this.resultGeometry=null,this.saveException=null,1===arguments.length){var t=arguments[0];this.argGeom=t}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.argGeom=e,this.bufParams=n}}function or(){this.comps=null;var t=arguments[0];this.comps=t}function ar(){if(this.component=null,this.segIndex=null,this.pt=null,2===arguments.length){var t=arguments[0],e=arguments[1];ar.call(this,t,ar.INSIDE_AREA,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.component=n,this.segIndex=i,this.pt=r}}function ur(){this.pts=null;var t=arguments[0];this.pts=t}function lr(){this.locations=null;var t=arguments[0];this.locations=t}function hr(){if(this.geom=null,this.terminateDistance=0,this.ptLocator=new Te,this.minDistanceLocation=null,this.minDistance=r.MAX_VALUE,2===arguments.length){var t=arguments[0],e=arguments[1];hr.call(this,t,e,0)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],s=arguments[2];this.geom=new Array(2).fill(null),this.geom[0]=n,this.geom[1]=i,this.terminateDistance=s}}function cr(){this.factory=null,this.directedEdges=new I,this.coordinates=null;var t=arguments[0];this.factory=t}function fr(){this._isMarked=!1,this._isVisited=!1,this.data=null}function gr(){fr.apply(this),this.parentEdge=null,this.from=null,this.to=null,this.p0=null,this.p1=null,this.sym=null,this.edgeDirection=null,this.quadrant=null,this.angle=null;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.from=t,this.to=e,this.edgeDirection=i,this.p0=t.getCoordinate(),this.p1=n;var r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y;this.quadrant=Je.quadrant(r,s),this.angle=Math.atan2(s,r)}function dr(){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function pr(){if(fr.apply(this),this.dirEdge=null,0===arguments.length);else if(2===arguments.length){var t=arguments[0],e=arguments[1];this.setDirectedEdges(t,e)}}function vr(){this.outEdges=new I,this.sorted=!1}function mr(){if(fr.apply(this),this.pt=null,this.deStar=null,1===arguments.length){var t=arguments[0];mr.call(this,t,new vr)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.pt=e,this.deStar=n}}function yr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function xr(){this.nodeMap=new rt}function Er(){this.edges=new J,this.dirEdges=new J,this.nodeMap=new xr}function Ir(){Er.apply(this)}function Nr(){this.graph=new Ir,this.mergedLineStrings=null,this.factory=null,this.edgeStrings=null}function Cr(){this.edgeRing=null,this.next=null,this.label=-1;var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];gr.call(this,t,e,n,i)}function Sr(){pr.apply(this),this.line=null;var t=arguments[0];this.line=t}function wr(){this.factory=null,this.deList=new I,this.lowestEdge=null,this.ring=null,this.ringPts=null,this.holes=null,this.shell=null,this._isHole=null,this._isProcessed=!1,this._isIncludedSet=!1,this._isIncluded=!1;var t=arguments[0];this.factory=t}function Lr(){}function Rr(){Er.apply(this),this.factory=null;var t=arguments[0];this.factory=t}function Tr(){if(this.lineStringAdder=new Pr(this),this.graph=null,this.dangles=new I,this.cutEdges=new I,this.invalidRingLines=new I,this.holeList=null,this.shellList=null,this.polyList=null,this.isCheckingRingsValid=!0,this.extractOnlyPolygonal=null,this.geomFactory=null,0===arguments.length)Tr.call(this,!1);else if(1===arguments.length){var t=arguments[0];this.extractOnlyPolygonal=t}}function Pr(){this.p=null;var t=arguments[0];this.p=t}function br(){}function Or(){if(this.edgeEnds=new I,1===arguments.length){var t=arguments[0];Or.call(this,null,t)}else if(2===arguments.length){var e=(arguments[0],arguments[1]);En.call(this,e.getEdge(),e.getCoordinate(),e.getDirectedCoordinate(),new gn(e.getLabel())),this.insert(e)}}function _r(){Pn.apply(this)}function Mr(){var t=arguments[0],e=arguments[1];yn.call(this,t,e)}function Dr(){Nn.apply(this)}function Ar(){this.li=new ae,this.ptLocator=new Te,this.arg=null,this.nodes=new xn(new Dr),this.im=null,this.isolatedEdges=new I,this.invalidPoint=null;var t=arguments[0];this.arg=t}function Fr(){this.rectEnv=null;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal()}function Gr(){this.li=new ae,this.rectEnv=null,this.diagUp0=null,this.diagUp1=null,this.diagDown0=null,this.diagDown1=null;var t=arguments[0];this.rectEnv=t,this.diagUp0=new g(t.getMinX(),t.getMinY()),this.diagUp1=new g(t.getMaxX(),t.getMaxY()),this.diagDown0=new g(t.getMinX(),t.getMaxY()),this.diagDown1=new g(t.getMaxX(),t.getMinY())}function qr(){this._isDone=!1}function Br(){this.rectangle=null,this.rectEnv=null;var t=arguments[0];this.rectangle=t,this.rectEnv=t.getEnvelopeInternal()}function zr(){qr.apply(this),this.rectEnv=null,this._intersects=!1;var t=arguments[0];this.rectEnv=t}function Vr(){qr.apply(this),this.rectSeq=null,this.rectEnv=null,this._containsPoint=!1;var t=arguments[0];this.rectSeq=t.getExteriorRing().getCoordinateSequence(),this.rectEnv=t.getEnvelopeInternal()}function kr(){qr.apply(this),this.rectEnv=null,this.rectIntersector=null,this.hasIntersection=!1,this.p0=new g,this.p1=new g;var t=arguments[0];this.rectEnv=t.getEnvelopeInternal(),this.rectIntersector=new Gr(this.rectEnv)}function Yr(){if(this._relate=null,2===arguments.length){var t=arguments[0],e=arguments[1];ti.call(this,t,e),this._relate=new Ar(this.arg)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];ti.call(this,n,i,r),this._relate=new Ar(this.arg)}}function Ur(){this.geomFactory=null,this.skipEmpty=!1,this.inputGeoms=null;var t=arguments[0];this.geomFactory=Ur.extractFactory(t),this.inputGeoms=t}function Xr(){this.pointGeom=null,this.otherGeom=null,this.geomFact=null;var t=arguments[0],e=arguments[1];this.pointGeom=t,this.otherGeom=e,this.geomFact=e.getFactory()}function Hr(){this.sortIndex=-1,this.comps=null;var t=arguments[0],e=arguments[1];this.sortIndex=t,this.comps=e}function Wr(){this.inputPolys=null,this.geomFactory=null;var t=arguments[0];this.inputPolys=t,null===this.inputPolys&&(this.inputPolys=new I)}function jr(){if(this.polygons=new I,this.lines=new I,this.points=new I,this.geomFact=null,1===arguments.length){if(R(arguments[0],v)){var t=arguments[0];this.extract(t)}else if(arguments[0]instanceof B){var e=arguments[0];this.extract(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.geomFact=i,this.extract(n)}}function Kr(){this.geometryFactory=new ie,this.geomGraph=null,this.disconnectedRingcoord=null;var t=arguments[0];this.geomGraph=t}function Zr(){this.items=new I,this.subnode=[null,null]}function Qr(){if(this.min=null,this.max=null,0===arguments.length)this.min=0,this.max=0;else if(1===arguments.length){var t=arguments[0];this.init(t.min,t.max)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.init(e,n)}}function Jr(){this.pt=0,this.level=0,this.interval=null;var t=arguments[0];this.computeKey(t)}function $r(){Zr.apply(this),this.interval=null,this.centre=null,this.level=null;var t=arguments[0],e=arguments[1];this.interval=t,this.level=e,this.centre=(t.getMin()+t.getMax())/2}function ts(){Zr.apply(this)}function es(){this.root=null,this.minExtent=1,this.root=new ts}function ns(){}function is(){this.ring=null,this.tree=null,this.crossings=0,this.interval=new Qr;var t=arguments[0];this.ring=t,this.buildIndex()}function rs(){tr.apply(this),this.mcp=null,this.p=null;var t=arguments[0],e=arguments[1];this.mcp=t,this.p=e}function ss(){this.nodes=new xn(new Dr)}function os(){this.li=new ae,this.geomGraph=null,this.nodeGraph=new ss,this.invalidPoint=null;var t=arguments[0];this.geomGraph=t}function as(){this.graph=null,this.rings=new I,this.totalEnv=new C,this.index=null,this.nestedPt=null;var t=arguments[0];this.graph=t}function us(){if(this.errorType=null,this.pt=null,1===arguments.length){var t=arguments[0];us.call(this,t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.errorType=e,null!==n&&(this.pt=n.copy())}}function ls(){this.parentGeometry=null,this.isSelfTouchingRingFormingHoleValid=!1,this.validErr=null;var t=arguments[0];this.parentGeometry=t}function hs(){_t.CoordinateOperation.apply(this),this.targetPM=null,this.removeCollapsed=!0;var t=arguments[0],e=arguments[1];this.targetPM=t,this.removeCollapsed=e}function cs(){this.targetPM=null,this.removeCollapsed=!0,this.changePrecisionModel=!1,this.isPointwise=!1;var t=arguments[0];this.targetPM=t}function fs(){this.pts=null,this.usePt=null,this.distanceTolerance=null,this.seg=new ce;var t=arguments[0];this.pts=t}function gs(){this.inputGeom=null,this.distanceTolerance=null,this.isEnsureValidTopology=!0;var t=arguments[0];this.inputGeom=t}function ds(){xe.apply(this),this.isEnsureValidTopology=!0,this.distanceTolerance=null;var t=arguments[0],e=arguments[1];this.isEnsureValidTopology=t,this.distanceTolerance=e}function ps(){if(this.parent=null,this.index=null,2===arguments.length){var t=arguments[0],e=arguments[1];ps.call(this,t,e,null,-1)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=arguments[3];ce.call(this,n,i),this.parent=r,this.index=s}}function vs(){if(this.parentLine=null,this.segs=null,this.resultSegs=new I,this.minimumSize=null,1===arguments.length){var t=arguments[0];vs.call(this,t,2)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.parentLine=e,this.minimumSize=n,this.init()}}function ms(){this.index=new Pi}function ys(){this.querySeg=null,this.items=new I;var t=arguments[0];this.querySeg=t}function xs(){this.li=new ae,this.inputIndex=new ms,this.outputIndex=new ms,this.line=null,this.linePts=null,this.distanceTolerance=0;var t=arguments[0],e=arguments[1];this.inputIndex=t,this.outputIndex=e}function Es(){this.inputIndex=new ms,this.outputIndex=new ms,this.distanceTolerance=0}function Is(){this.inputGeom=null,this.lineSimplifier=new Es,this.linestringMap=null;var t=arguments[0];this.inputGeom=t}function Ns(){xe.apply(this),this.linestringMap=null;var t=arguments[0];this.linestringMap=t}function Cs(){this.tps=null;var t=arguments[0];this.tps=t}function Ss(){this.seg=null,this.segLen=null,this.splitPt=null,this.minimumLen=0;var t=arguments[0];this.seg=t,this.segLen=t.getLength()}function ws(){}function Ls(){}function Rs(){}function Ts(){if(this.p=null,1===arguments.length){var t=arguments[0];this.p=new g(t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p=new g(e,n)}else if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.p=new g(i,r,s)}}function Ps(){this._isOnConstraint=null,this.constraint=null;var t=arguments[0];Ts.call(this,t)}function bs(){this._rot=null,this.vertex=null,this.next=null,this.data=null}function Os(){this.subdiv=null,this.isUsingTolerance=!1;var t=arguments[0];this.subdiv=t,this.isUsingTolerance=t.getTolerance()>0}function _s(){}function Ms(){this.subdiv=null,this.lastEdge=null;var t=arguments[0];this.subdiv=t,this.init()}function Ds(){if(this.seg=null,1===arguments.length){if("string"==typeof arguments[0]){var t=arguments[0];l.call(this,t)}else if(arguments[0]instanceof ce){var e=arguments[0];l.call(this,"Locate failed to converge (at edge: "+e+").  Possible causes include invalid Subdivision topology or very close sites"),this.seg=new ce(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];l.call(this,Ds.msgWithSpatial(n,i)),this.seg=new ce(i)}}function As(){}function Fs(){this.visitedKey=0,this.quadEdges=new I,this.startingEdge=null,this.tolerance=null,this.edgeCoincidenceTolerance=null,this.frameVertex=new Array(3).fill(null),this.frameEnv=null,this.locator=null,this.seg=new ce,this.triEdges=new Array(3).fill(null);var t=arguments[0],e=arguments[1];this.tolerance=e,this.edgeCoincidenceTolerance=e/Fs.EDGE_COINCIDENCE_TOL_FACTOR,this.createFrame(t),this.startingEdge=this.initSubdiv(),this.locator=new Ms(this)}function Gs(){}function qs(){this.triList=new I}function Bs(){this.triList=new I}function zs(){this.coordList=new N,this.triCoords=new I}function Vs(){if(this.ls=null,this.data=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.ls=new ce(t,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.ls=new ce(n,i),this.data=r}else if(6===arguments.length){var s=arguments[0],o=arguments[1],a=arguments[2],u=arguments[3],l=arguments[4],h=arguments[5];Vs.call(this,new g(s,o,a),new g(u,l,h))}else if(7===arguments.length){var c=arguments[0],f=arguments[1],d=arguments[2],p=arguments[3],v=arguments[4],m=arguments[5],y=arguments[6];Vs.call(this,new g(c,f,d),new g(p,v,m),y)}}function ks(){}function Ys(){if(this.p=null,this.data=null,this.left=null,this.right=null,this.count=null,2===arguments.length){var t=arguments[0],e=arguments[1];this.p=new g(t),this.left=null,this.right=null,this.count=1,this.data=e}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.p=new g(n,i),this.left=null,this.right=null,this.count=1,this.data=r}}function Us(){if(this.root=null,this.numberOfNodes=null,this.tolerance=null,0===arguments.length)Us.call(this,0);else if(1===arguments.length){var t=arguments[0];this.tolerance=t}}function Xs(){this.tolerance=null,this.matchNode=null,this.matchDist=0,this.p=null;var t=arguments[0],e=arguments[1];this.p=t,this.tolerance=e}function Hs(){this.initialVertices=null,this.segVertices=null,this.segments=new I,this.subdiv=null,this.incDel=null,this.convexHull=null,this.splitFinder=new Ls,this.kdt=null,this.vertexFactory=null,this.computeAreaEnv=null,this.splitPt=null,this.tolerance=null;var t=arguments[0],e=arguments[1];this.initialVertices=new I(t),this.tolerance=e,this.kdt=new Us(e)}function Ws(){this.siteCoords=null,this.tolerance=0,this.subdiv=null}function js(){this.siteCoords=null,this.constraintLines=null,this.tolerance=0,this.subdiv=null,this.constraintVertexMap=new rt}function Ks(){this.siteCoords=null,this.tolerance=0,this.subdiv=null,this.clipEnv=null,this.diagramEnv=null}function Zs(){}Array.prototype.fill||(Array.prototype.fill=function(t){for(var e=Object(this),n=parseInt(e.length,10),i=arguments[1],r=parseInt(i,10)||0,s=0>r?Math.max(n+r,0):Math.min(r,n),o=arguments[2],a=void 0===o?n:parseInt(o,10)||0,u=0>a?Math.max(n+a,0):Math.min(a,n);u>s;s++)e[s]=t;return e}),Number.isFinite=Number.isFinite||function(t){return"number"==typeof t&&isFinite(t)},Number.isInteger=Number.isInteger||function(t){return"number"==typeof t&&isFinite(t)&&Math.floor(t)===t},Number.parseFloat=Number.parseFloat||parseFloat,Number.isNaN=Number.isNaN||function(t){return t!==t},Math.trunc=Math.trunc||function(t){return 0>t?Math.ceil(t):Math.floor(t)},e(n.prototype,{interfaces_:function(){return[]},getClass:function(){return n}}),n.equalsWithTolerance=function(t,e,n){return Math.abs(t-e)<=n},r.isNaN=function(t){return Number.isNaN(t)},r.doubleToLongBits=function(t){return t},r.longBitsToDouble=function(t){return t},r.isInfinite=function(t){return!Number.isFinite(t)},r.MAX_VALUE=Number.MAX_VALUE,h(c,l),e(c.prototype,{interfaces_:function(){return[]},getClass:function(){return c}}),e(f.prototype,{interfaces_:function(){return[]},getClass:function(){return f}}),f.shouldNeverReachHere=function(){if(0===arguments.length)f.shouldNeverReachHere(null);else if(1===arguments.length){var t=arguments[0];throw new c("Should never reach here"+(null!==t?": "+t:""))}},f.isTrue=function(){if(1===arguments.length){var t=arguments[0];f.isTrue(t,null)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(!e)throw null===n?new c:new c(n)}},f.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];f.equals(t,e,null)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(!i.equals(n))throw new c("Expected "+n+" but encountered "+i+(null!==r?": "+r:""))}},e(g.prototype,{setOrdinate:function(t,e){switch(t){case g.X:this.x=e;break;case g.Y:this.y=e;break;case g.Z:this.z=e;break;default:throw new i("Invalid ordinate index: "+t)}},equals2D:function(){if(1===arguments.length){var t=arguments[0];return this.x!==t.x?!1:this.y===t.y}if(2===arguments.length){var e=arguments[0],i=arguments[1];return n.equalsWithTolerance(this.x,e.x,i)?!!n.equalsWithTolerance(this.y,e.y,i):!1}},getOrdinate:function(t){switch(t){case g.X:return this.x;case g.Y:return this.y;case g.Z:return this.z}throw new i("Invalid ordinate index: "+t)},equals3D:function(t){return this.x===t.x&&this.y===t.y&&(this.z===t.z||r.isNaN(this.z)&&r.isNaN(t.z))},equals:function(t){return t instanceof g?this.equals2D(t):!1},equalInZ:function(t,e){return n.equalsWithTolerance(this.z,t.z,e)},compareTo:function(t){var e=t;return this.x<e.x?-1:this.x>e.x?1:this.y<e.y?-1:this.y>e.y?1:0},clone:function(){try{var t=null;return t}catch(t){if(t instanceof CloneNotSupportedException)return f.shouldNeverReachHere("this shouldn't happen because this class is Cloneable"),null;throw t}finally{}},copy:function(){return new g(this)},toString:function(){return"("+this.x+", "+this.y+", "+this.z+")"},distance3D:function(t){var e=this.x-t.x,n=this.y-t.y,i=this.z-t.z;return Math.sqrt(e*e+n*n+i*i)},distance:function(t){var e=this.x-t.x,n=this.y-t.y;return Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.x),t=37*t+g.hashCode(this.y)},setCoordinate:function(t){this.x=t.x,this.y=t.y,this.z=t.z},interfaces_:function(){return[s,o,u]},getClass:function(){return g}}),g.hashCode=function(){if(1===arguments.length){var t=arguments[0],e=r.doubleToLongBits(t);return Math.trunc(e^e>>>32)}},e(d.prototype,{compare:function(t,e){var n=t,i=e,r=d.compare(n.x,i.x);if(0!==r)return r;var s=d.compare(n.y,i.y);if(0!==s)return s;if(this.dimensionsToTest<=2)return 0;var o=d.compare(n.z,i.z);return o},interfaces_:function(){return[a]},getClass:function(){return d}}),d.compare=function(t,e){return e>t?-1:t>e?1:r.isNaN(t)?r.isNaN(e)?0:-1:r.isNaN(e)?1:0},g.DimensionalComparator=d,g.serialVersionUID=0x5cbf2c235c7e5800,g.NULL_ORDINATE=r.NaN,g.X=0,g.Y=1,g.Z=2,p.prototype.hasNext=function(){},p.prototype.next=function(){},p.prototype.remove=function(){},v.prototype.add=function(){},v.prototype.addAll=function(){},v.prototype.isEmpty=function(){},v.prototype.iterator=function(){},v.prototype.size=function(){},v.prototype.toArray=function(){},v.prototype.remove=function(){},m.prototype=new Error,m.prototype.name="IndexOutOfBoundsException",y.prototype=Object.create(v.prototype),y.prototype.constructor=y,y.prototype.get=function(){},y.prototype.set=function(){},y.prototype.isEmpty=function(){},x.prototype=new Error,x.prototype.name="NoSuchElementException",E.prototype=new Error,E.prototype.name="OperationNotSupported",I.prototype=Object.create(y.prototype),I.prototype.constructor=I,I.prototype.ensureCapacity=function(){},I.prototype.interfaces_=function(){return[y,v]},I.prototype.add=function(t){return this.array_.push(t),!0},I.prototype.clear=function(){this.array_=[]},I.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},I.prototype.set=function(t,e){var n=this.array_[t];return this.array_[t]=e,n},I.prototype.iterator=function(){return new Qs(this)},I.prototype.get=function(t){if(0>t||t>=this.size())throw new m;return this.array_[t]},I.prototype.isEmpty=function(){return 0===this.array_.length},I.prototype.size=function(){return this.array_.length},I.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},I.prototype.remove=function(t){for(var e=!1,n=0,i=this.array_.length;i>n;n++)if(this.array_[n]===t){this.array_.splice(n,1),e=!0;break}return e};var Qs=function(t){this.arrayList_=t,this.position_=0};Qs.prototype.next=function(){if(this.position_===this.arrayList_.size())throw new x;return this.arrayList_.get(this.position_++)},Qs.prototype.hasNext=function(){return this.position_<this.arrayList_.size()},Qs.prototype.set=function(t){return this.arrayList_.set(this.position_-1,t)},Qs.prototype.remove=function(){throw new E},h(N,I),e(N.prototype,{getCoordinate:function(t){return this.get(t)},addAll:function(){if(2===arguments.length){for(var t=arguments[0],e=arguments[1],n=!1,i=t.iterator();i.hasNext();)this.add(i.next(),e),n=!0;return n}return I.prototype.addAll.apply(this,arguments)},clone:function t(){for(var t=I.prototype.clone.call(this),e=0;e<this.size();e++)t.add(e,this.get(e).copy());return t},toCoordinateArray:function(){return this.toArray(N.coordArrayType)},add:function(){if(1===arguments.length){var t=arguments[0];I.prototype.add.call(this,t)}else if(2===arguments.length){if(arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var e=arguments[0],n=arguments[1];return this.add(e,n,!0),!0}if(arguments[0]instanceof g&&"boolean"==typeof arguments[1]){var i=arguments[0],r=arguments[1];if(!r&&this.size()>=1){var s=this.get(this.size()-1);if(s.equals2D(i))return null}I.prototype.add.call(this,i)}else if(arguments[0]instanceof Object&&"boolean"==typeof arguments[1]){var o=arguments[0],a=arguments[1];return this.add(o,a),!0}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&arguments[0]instanceof Array&&"boolean"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2];if(h)for(var c=0;c<u.length;c++)this.add(u[c],l);else for(var c=u.length-1;c>=0;c--)this.add(u[c],l);return!0}if("boolean"==typeof arguments[2]&&Number.isInteger(arguments[0])&&arguments[1]instanceof g){var f=arguments[0],d=arguments[1],p=arguments[2];if(!p){var v=this.size();if(v>0){if(f>0){var m=this.get(f-1);if(m.equals2D(d))return null}if(v>f){var y=this.get(f);if(y.equals2D(d))return null}}}I.prototype.add.call(this,f,d)}}else if(4===arguments.length){var x=arguments[0],E=arguments[1],N=arguments[2],C=arguments[3],S=1;N>C&&(S=-1);for(var c=N;c!==C;c+=S)this.add(x[c],E);return!0}},closeRing:function(){this.size()>0&&this.add(new g(this.get(0)),!1)},interfaces_:function(){return[]},getClass:function(){return N}}),N.coordArrayType=new Array(0).fill(null),e(C.prototype,{getArea:function(){return this.getWidth()*this.getHeight()},equals:function(t){if(!(t instanceof C))return!1;var e=t;return this.isNull()?e.isNull():this.maxx===e.getMaxX()&&this.maxy===e.getMaxY()&&this.minx===e.getMinX()&&this.miny===e.getMinY()},intersection:function(t){if(this.isNull()||t.isNull()||!this.intersects(t))return new C;var e=this.minx>t.minx?this.minx:t.minx,n=this.miny>t.miny?this.miny:t.miny,i=this.maxx<t.maxx?this.maxx:t.maxx,r=this.maxy<t.maxy?this.maxy:t.maxy;return new C(e,i,n,r)},isNull:function(){return this.maxx<this.minx},getMaxX:function(){return this.maxx},covers:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.covers(t.x,t.y)}if(arguments[0]instanceof C){var e=arguments[0];return this.isNull()||e.isNull()?!1:e.getMinX()>=this.minx&&e.getMaxX()<=this.maxx&&e.getMinY()>=this.miny&&e.getMaxY()<=this.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:n>=this.minx&&n<=this.maxx&&i>=this.miny&&i<=this.maxy}},intersects:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.isNull()||t.isNull()?!1:!(t.minx>this.maxx||t.maxx<this.minx||t.miny>this.maxy||t.maxy<this.miny)}if(arguments[0]instanceof g){var e=arguments[0];return this.intersects(e.x,e.y)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.isNull()?!1:!(n>this.maxx||n<this.minx||i>this.maxy||i<this.miny)}},getMinY:function(){return this.miny},getMinX:function(){return this.minx},expandToInclude:function(){if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.expandToInclude(t.x,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];if(e.isNull())return null;this.isNull()?(this.minx=e.getMinX(),this.maxx=e.getMaxX(),this.miny=e.getMinY(),this.maxy=e.getMaxY()):(e.minx<this.minx&&(this.minx=e.minx),e.maxx>this.maxx&&(this.maxx=e.maxx),e.miny<this.miny&&(this.miny=e.miny),e.maxy>this.maxy&&(this.maxy=e.maxy))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.isNull()?(this.minx=n,this.maxx=n,this.miny=i,this.maxy=i):(n<this.minx&&(this.minx=n),n>this.maxx&&(this.maxx=n),i<this.miny&&(this.miny=i),i>this.maxy&&(this.maxy=i))}},minExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return e>t?t:e},getWidth:function(){return this.isNull()?0:this.maxx-this.minx},compareTo:function(t){var e=t;return this.isNull()?e.isNull()?0:-1:e.isNull()?1:this.minx<e.minx?-1:this.minx>e.minx?1:this.miny<e.miny?-1:this.miny>e.miny?1:this.maxx<e.maxx?-1:this.maxx>e.maxx?1:this.maxy<e.maxy?-1:this.maxy>e.maxy?1:0},translate:function(t,e){return this.isNull()?null:void this.init(this.getMinX()+t,this.getMaxX()+t,this.getMinY()+e,this.getMaxY()+e)},toString:function(){return"Env["+this.minx+" : "+this.maxx+", "+this.miny+" : "+this.maxy+"]"},setToNull:function(){this.minx=0,this.maxx=-1,this.miny=0,this.maxy=-1},getHeight:function(){return this.isNull()?0:this.maxy-this.miny},maxExtent:function(){if(this.isNull())return 0;var t=this.getWidth(),e=this.getHeight();return t>e?t:e},expandBy:function(){if(1===arguments.length){var t=arguments[0];this.expandBy(t,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(this.isNull())return null;this.minx-=e,this.maxx+=e,this.miny-=n,this.maxy+=n,(this.minx>this.maxx||this.miny>this.maxy)&&this.setToNull()}},contains:function(){if(1===arguments.length){if(arguments[0]instanceof C){var t=arguments[0];return this.covers(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.covers(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return this.covers(n,i)}},centre:function(){return this.isNull()?null:new g((this.getMinX()+this.getMaxX())/2,(this.getMinY()+this.getMaxY())/2)},init:function(){if(0===arguments.length)this.setToNull();else if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];this.init(t.x,t.x,t.y,t.y)}else if(arguments[0]instanceof C){var e=arguments[0];this.minx=e.minx,this.maxx=e.maxx,this.miny=e.miny,this.maxy=e.maxy}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.init(n.x,i.x,n.y,i.y)}else if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3];s>r?(this.minx=r,this.maxx=s):(this.minx=s,this.maxx=r),a>o?(this.miny=o,this.maxy=a):(this.miny=a,this.maxy=o)}},getMaxY:function(){return this.maxy},distance:function(t){if(this.intersects(t))return 0;var e=0;this.maxx<t.minx?e=t.minx-this.maxx:this.minx>t.maxx&&(e=this.minx-t.maxx);var n=0;return this.maxy<t.miny?n=t.miny-this.maxy:this.miny>t.maxy&&(n=this.miny-t.maxy),0===e?n:0===n?e:Math.sqrt(e*e+n*n)},hashCode:function(){var t=17;return t=37*t+g.hashCode(this.minx),t=37*t+g.hashCode(this.maxx),t=37*t+g.hashCode(this.miny),t=37*t+g.hashCode(this.maxy)},interfaces_:function(){return[s,u]},getClass:function(){return C}}),C.intersects=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2];return n.x>=(t.x<e.x?t.x:e.x)&&n.x<=(t.x>e.x?t.x:e.x)&&n.y>=(t.y<e.y?t.y:e.y)&&n.y<=(t.y>e.y?t.y:e.y)}if(4===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=Math.min(s.x,o.x),u=Math.max(s.x,o.x),l=Math.min(i.x,r.x),h=Math.max(i.x,r.x);return l>u?!1:a>h?!1:(a=Math.min(s.y,o.y),u=Math.max(s.y,o.y),l=Math.min(i.y,r.y),h=Math.max(i.y,r.y),l>u?!1:!(a>h))}},C.serialVersionUID=0x51845cd552189800,h(w,S),e(w.prototype,{interfaces_:function(){return[]},getClass:function(){return w}}),e(L.prototype,{interfaces_:function(){return[]},getClass:function(){return L}}),L.toLocationSymbol=function(t){switch(t){case L.EXTERIOR:return"e";case L.BOUNDARY:return"b";case L.INTERIOR:return"i";case L.NONE:return"-"}throw new i("Unknown location value: "+t)},L.INTERIOR=0,L.BOUNDARY=1,L.EXTERIOR=2,L.NONE=-1,e(T.prototype,{interfaces_:function(){return[]},getClass:function(){return T}}),T.log10=function(t){var e=Math.log(t);return r.isInfinite(e)?e:r.isNaN(e)?e:e/T.LOG_10},T.min=function(t,e,n,i){var r=t;return r>e&&(r=e),r>n&&(r=n),r>i&&(r=i),r},T.clamp=function(){if("number"==typeof arguments[2]&&"number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1],n=arguments[2];return e>t?e:t>n?n:t}if(Number.isInteger(arguments[2])&&Number.isInteger(arguments[0])&&Number.isInteger(arguments[1])){var i=arguments[0],r=arguments[1],s=arguments[2];return r>i?r:i>s?s:i}},T.wrap=function(t,e){return 0>t?e- -t%e:t%e},T.max=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=t;return e>i&&(i=e),n>i&&(i=n),i}if(4===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],i=r;return s>i&&(i=s),o>i&&(i=o),a>i&&(i=a),i}},T.average=function(t,e){
return(t+e)/2},T.LOG_10=Math.log(10),P.prototype.append=function(t){this.str+=t},P.prototype.setCharAt=function(t,e){return this.str.substr(0,t)+e+this.str.substr(t+1)},P.prototype.toString=function(t){return this.str},b.prototype.intValue=function(){return this.value},b.prototype.compareTo=function(t){return this.value<t?-1:this.value>t?1:0},b.isNaN=function(t){return Number.isNaN(t)},O.isWhitespace=function(t){return 32>=t&&t>=0||127==t},O.toUpperCase=function(t){return t.toUpperCase()},e(_.prototype,{le:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<=t.lo},extractSignificantDigits:function(t,e){var n=this.abs(),i=_.magnitude(n.hi),r=_.TEN.pow(i);n=n.divide(r),n.gt(_.TEN)?(n=n.divide(_.TEN),i+=1):n.lt(_.ONE)&&(n=n.multiply(_.TEN),i-=1);for(var s=i+1,o=new P,a=_.MAX_PRINT_DIGITS-1,u=0;a>=u;u++){t&&u===s&&o.append(".");var l=Math.trunc(n.hi);if(0>l)break;var h=!1,c=0;l>9?(h=!0,c="9"):c="0"+l,o.append(c),n=n.subtract(_.valueOf(l)).multiply(_.TEN),h&&n.selfAdd(_.TEN);var f=!0,g=_.magnitude(n.hi);if(0>g&&Math.abs(g)>=a-u&&(f=!1),!f)break}return e[0]=i,o.toString()},sqr:function(){return this.multiply(this)},doubleValue:function(){return this.hi+this.lo},subtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.add(t.negate())}if("number"==typeof arguments[0]){var e=arguments[0];return this.add(-e)}},equals:function(){if(1===arguments.length){var t=arguments[0];return this.hi===t.hi&&this.lo===t.lo}},isZero:function(){return 0===this.hi&&0===this.lo},selfSubtract:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.isNaN()?this:this.selfAdd(-t.hi,-t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.isNaN()?this:this.selfAdd(-e,0)}},getSpecialNumberString:function(){return this.isZero()?"0.0":this.isNaN()?"NaN ":null},min:function(t){return this.le(t)?this:t},selfDivide:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfDivide(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfDivide(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null,h=null,c=null;return u=this.hi/n,l=_.SPLIT*u,r=l-u,c=_.SPLIT*n,r=l-r,s=u-r,o=c-n,h=u*n,o=c-o,a=n-o,c=r*o-h+r*a+s*o+s*a,l=(this.hi-h-c+this.lo-u*i)/n,c=u+l,this.hi=c,this.lo=u-c+l,this}},dump:function(){return"DD<"+this.hi+", "+this.lo+">"},divide:function(){if(arguments[0]instanceof _){var t=arguments[0],e=null,n=null,i=null,s=null,o=null,a=null,u=null,l=null;o=this.hi/t.hi,a=_.SPLIT*o,e=a-o,l=_.SPLIT*t.hi,e=a-e,n=o-e,i=l-t.hi,u=o*t.hi,i=l-i,s=t.hi-i,l=e*i-u+e*s+n*i+n*s,a=(this.hi-u-l+this.lo-o*t.lo)/t.hi,l=o+a;var h=l,c=o-l+a;return new _(h,c)}if("number"==typeof arguments[0]){var f=arguments[0];return r.isNaN(f)?_.createNaN():_.copy(this).selfDivide(f,0)}},ge:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>=t.lo},pow:function(t){if(0===t)return _.valueOf(1);var e=new _(this),n=_.valueOf(1),i=Math.abs(t);if(i>1)for(;i>0;)i%2===1&&n.selfMultiply(e),i/=2,i>0&&(e=e.sqr());else n=e;return 0>t?n.reciprocal():n},ceil:function(){if(this.isNaN())return _.NaN;var t=Math.ceil(this.hi),e=0;return t===this.hi&&(e=Math.ceil(this.lo)),new _(t,e)},compareTo:function(t){var e=t;return this.hi<e.hi?-1:this.hi>e.hi?1:this.lo<e.lo?-1:this.lo>e.lo?1:0},rint:function(){if(this.isNaN())return this;var t=this.add(.5);return t.floor()},setValue:function(){if(arguments[0]instanceof _){var t=arguments[0];return this.init(t),this}if("number"==typeof arguments[0]){var e=arguments[0];return this.init(e),this}},max:function(t){return this.ge(t)?this:t},sqrt:function(){if(this.isZero())return _.valueOf(0);if(this.isNegative())return _.NaN;var t=1/Math.sqrt(this.hi),e=this.hi*t,n=_.valueOf(e),i=this.subtract(n.sqr()),r=i.hi*(.5*t);return n.add(r)},selfAdd:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfAdd(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0],n=null,i=null,r=null,s=null,o=null,a=null;return r=this.hi+e,o=r-this.hi,s=r-o,s=e-o+(this.hi-s),a=s+this.lo,n=r+a,i=a+(r-n),this.hi=n+i,this.lo=i+(n-this.hi),this}}else if(2===arguments.length){var u=arguments[0],l=arguments[1],n=null,i=null,h=null,c=null,r=null,s=null,o=null,a=null;r=this.hi+u,h=this.lo+l,o=r-this.hi,a=h-this.lo,s=r-o,c=h-a,s=u-o+(this.hi-s),c=l-a+(this.lo-c),o=s+h,n=r+o,i=o+(r-n),o=c+i;var f=n+o,g=o+(n-f);return this.hi=f,this.lo=g,this}},selfMultiply:function(){if(1===arguments.length){if(arguments[0]instanceof _){var t=arguments[0];return this.selfMultiply(t.hi,t.lo)}if("number"==typeof arguments[0]){var e=arguments[0];return this.selfMultiply(e,0)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=null,s=null,o=null,a=null,u=null,l=null;u=_.SPLIT*this.hi,r=u-this.hi,l=_.SPLIT*n,r=u-r,s=this.hi-r,o=l-n,u=this.hi*n,o=l-o,a=n-o,l=r*o-u+r*a+s*o+s*a+(this.hi*i+this.lo*n);var h=u+l;r=u-h;var c=l+r;return this.hi=h,this.lo=c,this}},selfSqr:function(){return this.selfMultiply(this)},floor:function(){if(this.isNaN())return _.NaN;var t=Math.floor(this.hi),e=0;return t===this.hi&&(e=Math.floor(this.lo)),new _(t,e)},negate:function(){return this.isNaN()?this:new _(-this.hi,-this.lo)},clone:function(){try{return null}catch(t){if(t instanceof CloneNotSupportedException)return null;throw t}finally{}},multiply:function(){if(arguments[0]instanceof _){var t=arguments[0];return t.isNaN()?_.createNaN():_.copy(this).selfMultiply(t)}if("number"==typeof arguments[0]){var e=arguments[0];return r.isNaN(e)?_.createNaN():_.copy(this).selfMultiply(e,0)}},isNaN:function(){return r.isNaN(this.hi)},intValue:function(){return Math.trunc(this.hi)},toString:function(){var t=_.magnitude(this.hi);return t>=-3&&20>=t?this.toStandardNotation():this.toSciNotation()},toStandardNotation:function(){var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!0,e),i=e[0]+1,r=n;if("."===n.charAt(0))r="0"+n;else if(0>i)r="0."+_.stringOfChar("0",-i)+n;else if(-1===n.indexOf(".")){var s=i-n.length,o=_.stringOfChar("0",s);r=n+o+".0"}return this.isNegative()?"-"+r:r},reciprocal:function(){var t=null,e=null,n=null,i=null,r=null,s=null,o=null,a=null;r=1/this.hi,s=_.SPLIT*r,t=s-r,a=_.SPLIT*this.hi,t=s-t,e=r-t,n=a-this.hi,o=r*this.hi,n=a-n,i=this.hi-n,a=t*n-o+t*i+e*n+e*i,s=(1-o-a-r*this.lo)/this.hi;var u=r+s,l=r-u+s;return new _(u,l)},toSciNotation:function(){if(this.isZero())return _.SCI_NOT_ZERO;var t=this.getSpecialNumberString();if(null!==t)return t;var e=new Array(1).fill(null),n=this.extractSignificantDigits(!1,e),i=_.SCI_NOT_EXPONENT_CHAR+e[0];if("0"===n.charAt(0))throw new IllegalStateException("Found leading zero: "+n);var r="";n.length>1&&(r=n.substring(1));var s=n.charAt(0)+"."+r;return this.isNegative()?"-"+s+i:s+i},abs:function(){return this.isNaN()?_.NaN:this.isNegative()?this.negate():new _(this)},isPositive:function(){return this.hi>0||0===this.hi&&this.lo>0},lt:function(t){return this.hi<t.hi||this.hi===t.hi&&this.lo<t.lo},add:function(){if(arguments[0]instanceof _){var t=arguments[0];return _.copy(this).selfAdd(t)}if("number"==typeof arguments[0]){var e=arguments[0];return _.copy(this).selfAdd(e)}},init:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];this.hi=t,this.lo=0}else if(arguments[0]instanceof _){var e=arguments[0];this.hi=e.hi,this.lo=e.lo}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];this.hi=n,this.lo=i}},gt:function(t){return this.hi>t.hi||this.hi===t.hi&&this.lo>t.lo},isNegative:function(){return this.hi<0||0===this.hi&&this.lo<0},trunc:function(){return this.isNaN()?_.NaN:this.isPositive()?this.floor():this.ceil()},signum:function(){return this.hi>0?1:this.hi<0?-1:this.lo>0?1:this.lo<0?-1:0},interfaces_:function(){return[u,s,o]},getClass:function(){return _}}),_.sqr=function(t){return _.valueOf(t).selfMultiply(t)},_.valueOf=function(){if("string"==typeof arguments[0]){var t=arguments[0];return _.parse(t)}if("number"==typeof arguments[0]){var e=arguments[0];return new _(e)}},_.sqrt=function(t){return _.valueOf(t).sqrt()},_.parse=function(t){for(var e=0,n=t.length;O.isWhitespace(t.charAt(e));)e++;var i=!1;if(n>e){var r=t.charAt(e);"-"!==r&&"+"!==r||(e++,"-"===r&&(i=!0))}for(var s=new _,o=0,a=0,u=0;;){if(e>=n)break;var l=t.charAt(e);if(e++,O.isDigit(l)){var h=l-"0";s.selfMultiply(_.TEN),s.selfAdd(h),o++}else{if("."!==l){if("e"===l||"E"===l){var c=t.substring(e);try{u=b.parseInt(c)}catch(e){throw e instanceof NumberFormatException?new NumberFormatException("Invalid exponent "+c+" in string "+t):e}finally{}break}throw new NumberFormatException("Unexpected character '"+l+"' at position "+e+" in string "+t)}a=o}}var f=s,g=o-a-u;if(0===g)f=s;else if(g>0){var d=_.TEN.pow(g);f=s.divide(d)}else if(0>g){var d=_.TEN.pow(-g);f=s.multiply(d)}return i?f.negate():f},_.createNaN=function(){return new _(r.NaN,r.NaN)},_.copy=function(t){return new _(t)},_.magnitude=function(t){var e=Math.abs(t),n=Math.log(e)/Math.log(10),i=Math.trunc(Math.floor(n)),r=Math.pow(10,i);return e>=10*r&&(i+=1),i},_.stringOfChar=function(t,e){for(var n=new P,i=0;e>i;i++)n.append(t);return n.toString()},_.PI=new _(3.141592653589793,1.2246467991473532e-16),_.TWO_PI=new _(6.283185307179586,2.4492935982947064e-16),_.PI_2=new _(1.5707963267948966,6.123233995736766e-17),_.E=new _(2.718281828459045,1.4456468917292502e-16),_.NaN=new _(r.NaN,r.NaN),_.EPS=1.23259516440783e-32,_.SPLIT=134217729,_.MAX_PRINT_DIGITS=32,_.TEN=_.valueOf(10),_.ONE=_.valueOf(1),_.SCI_NOT_EXPONENT_CHAR="E",_.SCI_NOT_ZERO="0.0E0",e(M.prototype,{interfaces_:function(){return[]},getClass:function(){return M}}),M.orientationIndex=function(t,e,n){var i=M.orientationIndexFilter(t,e,n);if(1>=i)return i;var r=_.valueOf(e.x).selfAdd(-t.x),s=_.valueOf(e.y).selfAdd(-t.y),o=_.valueOf(n.x).selfAdd(-e.x),a=_.valueOf(n.y).selfAdd(-e.y);return r.selfMultiply(a).selfSubtract(s.selfMultiply(o)).signum()},M.signOfDet2x2=function(t,e,n,i){var r=t.multiply(i).selfSubtract(e.multiply(n));return r.signum()},M.intersection=function(t,e,n,i){var r=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(e.x).selfSubtract(t.x)),s=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(e.y).selfSubtract(t.y)),o=r.subtract(s),a=_.valueOf(i.x).selfSubtract(n.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),u=_.valueOf(i.y).selfSubtract(n.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),l=a.subtract(u),h=l.selfDivide(o).doubleValue(),c=_.valueOf(t.x).selfAdd(_.valueOf(e.x).selfSubtract(t.x).selfMultiply(h)).doubleValue(),f=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(t.y).selfSubtract(n.y)),d=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(t.x).selfSubtract(n.x)),p=f.subtract(d),v=p.selfDivide(o).doubleValue(),m=_.valueOf(n.y).selfAdd(_.valueOf(i.y).selfSubtract(n.y).selfMultiply(v)).doubleValue();return new g(c,m)},M.orientationIndexFilter=function(t,e,n){var i=null,r=(t.x-n.x)*(e.y-n.y),s=(t.y-n.y)*(e.x-n.x),o=r-s;if(r>0){if(0>=s)return M.signum(o);i=r+s}else{if(!(0>r))return M.signum(o);if(s>=0)return M.signum(o);i=-r-s}var a=M.DP_SAFE_EPSILON*i;return o>=a||-o>=a?M.signum(o):2},M.signum=function(t){return t>0?1:0>t?-1:0},M.DP_SAFE_EPSILON=1e-15,e(D.prototype,{setOrdinate:function(t,e,n){},size:function(){},getOrdinate:function(t,e){},getCoordinate:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},getCoordinateCopy:function(t){},getDimension:function(){},getX:function(t){},clone:function(){},expandEnvelope:function(t){},copy:function(){},getY:function(t){},toCoordinateArray:function(){},interfaces_:function(){return[o]},getClass:function(){return D}}),D.X=0,D.Y=1,D.Z=2,D.M=3,A.arraycopy=function(t,e,n,i,r){for(var s=0,o=e;e+r>o;o++)n[i+s]=t[o],s++},A.getProperty=function(t){return{"line.separator":"\n"}[t]},e(F.prototype,{getY:function(){var t=this.y/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getX:function(){var t=this.x/this.w;if(r.isNaN(t)||r.isInfinite(t))throw new w;return t},getCoordinate:function(){var t=new g;return t.x=this.getX(),t.y=this.getY(),t},interfaces_:function(){return[]},getClass:function(){return F}}),F.intersection=function(t,e,n,i){var s=t.y-e.y,o=e.x-t.x,a=t.x*e.y-e.x*t.y,u=n.y-i.y,l=i.x-n.x,h=n.x*i.y-i.x*n.y,c=o*h-l*a,f=u*a-s*h,d=s*l-u*o,p=c/d,v=f/d;if(r.isNaN(p)||r.isInfinite(p)||r.isNaN(v)||r.isInfinite(v))throw new w;return new g(p,v)},e(G.prototype,{create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){arguments[0]}else if(R(arguments[0],D)){arguments[0]}}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return G}}),e(q.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return q}}),e(B.prototype,{isGeometryCollection:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION},getFactory:function(){return this.factory},getGeometryN:function(t){return this},getArea:function(){return 0},isRectangle:function(){return!1},equals:function(){if(1===arguments.length){if(arguments[0]instanceof B){var t=arguments[0];return null===t?!1:this.equalsTopo(t)}if(arguments[0]instanceof Object){var e=arguments[0];if(!(e instanceof B))return!1;var n=e;return this.equalsExact(n)}}},equalsExact:function(t){return this===t||this.equalsExact(t,0)},geometryChanged:function(){this.apply(B.geometryChangedFilter)},geometryChangedAction:function(){this.envelope=null},equalsNorm:function(t){return null===t?!1:this.norm().equalsExact(t.norm())},getLength:function(){return 0},getNumGeometries:function(){return 1},compareTo:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return this.getSortIndex()!==e.getSortIndex()?this.getSortIndex()-e.getSortIndex():this.isEmpty()&&e.isEmpty()?0:this.isEmpty()?-1:e.isEmpty()?1:this.compareToSameClass(n,i)}},getUserData:function(){return this.userData},getSRID:function(){return this.SRID},getEnvelope:function(){return this.getFactory().toGeometry(this.getEnvelopeInternal())},checkNotGeometryCollection:function(t){if(t.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION)throw new i("This method does not support GeometryCollection arguments")},equal:function(t,e,n){return 0===n?t.equals(e):t.distance(e)<=n},norm:function(){var t=this.copy();return t.normalize(),t},getPrecisionModel:function(){return this.factory.getPrecisionModel()},getEnvelopeInternal:function(){return null===this.envelope&&(this.envelope=this.computeEnvelopeInternal()),new C(this.envelope)},setSRID:function(t){this.SRID=t},setUserData:function(t){this.userData=t},compare:function(t,e){for(var n=t.iterator(),i=e.iterator();n.hasNext()&&i.hasNext();){var r=n.next(),s=i.next(),o=r.compareTo(s);if(0!==o)return o}return n.hasNext()?1:i.hasNext()?-1:0},hashCode:function(){return this.getEnvelopeInternal().hashCode()},isGeometryCollectionOrDerived:function(){return this.getSortIndex()===B.SORTINDEX_GEOMETRYCOLLECTION||this.getSortIndex()===B.SORTINDEX_MULTIPOINT||this.getSortIndex()===B.SORTINDEX_MULTILINESTRING||this.getSortIndex()===B.SORTINDEX_MULTIPOLYGON},interfaces_:function(){return[o,s,u]},getClass:function(){return B}}),B.hasNonEmptyElements=function(t){for(var e=0;e<t.length;e++)if(!t[e].isEmpty())return!0;return!1},B.hasNullElements=function(t){for(var e=0;e<t.length;e++)if(null===t[e])return!0;return!1},B.serialVersionUID=0x799ea46522854c00,B.SORTINDEX_POINT=0,B.SORTINDEX_MULTIPOINT=1,B.SORTINDEX_LINESTRING=2,B.SORTINDEX_LINEARRING=3,B.SORTINDEX_MULTILINESTRING=4,B.SORTINDEX_POLYGON=5,B.SORTINDEX_MULTIPOLYGON=6,B.SORTINDEX_GEOMETRYCOLLECTION=7,B.geometryChangedFilter={interfaces_:function(){return[q]},filter:function(t){t.geometryChangedAction()}},e(z.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return z}}),e(V.prototype,{isInBoundary:function(t){},interfaces_:function(){return[]},getClass:function(){return V}}),e(k.prototype,{isInBoundary:function(t){return t%2===1},interfaces_:function(){return[V]},getClass:function(){return k}}),e(Y.prototype,{isInBoundary:function(t){return t>0},interfaces_:function(){return[V]},getClass:function(){return Y}}),e(U.prototype,{isInBoundary:function(t){return t>1},interfaces_:function(){return[V]},getClass:function(){return U}}),e(X.prototype,{isInBoundary:function(t){return 1===t},interfaces_:function(){return[V]},getClass:function(){return X}}),V.Mod2BoundaryNodeRule=k,V.EndPointBoundaryNodeRule=Y,V.MultiValentEndPointBoundaryNodeRule=U,V.MonoValentEndPointBoundaryNodeRule=X,V.MOD2_BOUNDARY_RULE=new k,V.ENDPOINT_BOUNDARY_RULE=new Y,V.MULTIVALENT_ENDPOINT_BOUNDARY_RULE=new U,V.MONOVALENT_ENDPOINT_BOUNDARY_RULE=new X,V.OGC_SFS_BOUNDARY_RULE=V.MOD2_BOUNDARY_RULE,e(H.prototype,{interfaces_:function(){return[]},getClass:function(){return H}}),H.isRing=function(t){return t.length<4?!1:!!t[0].equals2D(t[t.length-1])},H.ptNotInList=function(t,e){for(var n=0;n<t.length;n++){var i=t[n];if(H.indexOf(i,e)<0)return i}return null},H.scroll=function(t,e){var n=H.indexOf(e,t);if(0>n)return null;var i=new Array(t.length).fill(null);A.arraycopy(t,n,i,0,t.length-n),A.arraycopy(t,0,i,t.length-n,n),A.arraycopy(i,0,t,0,t.length)},H.equals=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(t===e)return!0;if(null===t||null===e)return!1;if(t.length!==e.length)return!1;for(var n=0;n<t.length;n++)if(!t[n].equals(e[n]))return!1;return!0}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];if(i===r)return!0;if(null===i||null===r)return!1;if(i.length!==r.length)return!1;for(var n=0;n<i.length;n++)if(0!==s.compare(i[n],r[n]))return!1;return!0}},H.intersection=function(t,e){for(var n=new N,i=0;i<t.length;i++)e.intersects(t[i])&&n.add(t[i],!0);return n.toCoordinateArray()},H.hasRepeatedPoints=function(t){for(var e=1;e<t.length;e++)if(t[e-1].equals(t[e]))return!0;return!1},H.removeRepeatedPoints=function(t){if(!H.hasRepeatedPoints(t))return t;var e=new N(t,!1);return e.toCoordinateArray()},H.reverse=function(t){for(var e=t.length-1,n=Math.trunc(e/2),i=0;n>=i;i++){var r=t[i];t[i]=t[e-i],t[e-i]=r}},H.removeNull=function(t){for(var e=0,n=0;n<t.length;n++)null!==t[n]&&e++;var i=new Array(e).fill(null);if(0===e)return i;for(var r=0,n=0;n<t.length;n++)null!==t[n]&&(i[r++]=t[n]);return i},H.copyDeep=function(){if(1===arguments.length){for(var t=arguments[0],e=new Array(t.length).fill(null),n=0;n<t.length;n++)e[n]=new g(t[n]);return e}if(5===arguments.length)for(var i=arguments[0],r=arguments[1],s=arguments[2],o=arguments[3],a=arguments[4],n=0;a>n;n++)s[o+n]=new g(i[r+n])},H.isEqualReversed=function(t,e){for(var n=0;n<t.length;n++){var i=t[n],r=e[t.length-n-1];if(0!==i.compareTo(r))return!1}return!0},H.envelope=function(t){for(var e=new C,n=0;n<t.length;n++)e.expandToInclude(t[n]);return e},H.toCoordinateArray=function(t){return t.toArray(H.coordArrayType)},H.atLeastNCoordinatesOrNothing=function(t,e){return e.length>=t?e:[]},H.indexOf=function(t,e){for(var n=0;n<e.length;n++)if(t.equals(e[n]))return n;return-1},H.increasingDirection=function(t){for(var e=0;e<Math.trunc(t.length/2);e++){var n=t.length-1-e,i=t[e].compareTo(t[n]);if(0!==i)return i}return 1},H.compare=function(t,e){for(var n=0;n<t.length&&n<e.length;){var i=t[n].compareTo(e[n]);if(0!==i)return i;n++}return n<e.length?-1:n<t.length?1:0},H.minCoordinate=function(t){for(var e=null,n=0;n<t.length;n++)(null===e||e.compareTo(t[n])>0)&&(e=t[n]);return e},H.extract=function(t,e,n){e=T.clamp(e,0,t.length),n=T.clamp(n,-1,t.length);var i=n-e+1;0>n&&(i=0),e>=t.length&&(i=0),e>n&&(i=0);var r=new Array(i).fill(null);if(0===i)return r;for(var s=0,o=e;n>=o;o++)r[s++]=t[o];return r},e(W.prototype,{compare:function(t,e){var n=t,i=e;return H.compare(n,i)},interfaces_:function(){return[a]},getClass:function(){return W}}),e(j.prototype,{compare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;var r=H.compare(n,i),s=H.isEqualReversed(n,i);return s?0:r},OLDcompare:function(t,e){var n=t,i=e;if(n.length<i.length)return-1;if(n.length>i.length)return 1;if(0===n.length)return 0;for(var r=H.increasingDirection(n),s=H.increasingDirection(i),o=r>0?0:n.length-1,a=s>0?0:n.length-1,u=0;u<n.length;u++){var l=n[o].compareTo(i[a]);if(0!==l)return l;o+=r,a+=s}return 0},interfaces_:function(){return[a]},getClass:function(){return j}}),H.ForwardComparator=W,H.BidirectionalComparator=j,H.coordArrayType=new Array(0).fill(null),K.prototype.get=function(){},K.prototype.put=function(){},K.prototype.size=function(){},K.prototype.values=function(){},K.prototype.entrySet=function(){},Z.prototype=new K,Q.prototype=new v,Q.prototype.contains=function(){},J.prototype=new Q,J.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(i===t)return!0}return!1},J.prototype.add=function(t){return this.contains(t)?!1:(this.array_.push(t),!0)},J.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},J.prototype.remove=function(t){throw new javascript.util.OperationNotSupported},J.prototype.size=function(){return this.array_.length},J.prototype.isEmpty=function(){return 0===this.array_.length},J.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},J.prototype.iterator=function(){return new Js(this)};var Js=function(t){this.hashSet_=t,this.position_=0};Js.prototype.next=function(){if(this.position_===this.hashSet_.size())throw new x;return this.hashSet_.array_[this.position_++]},Js.prototype.hasNext=function(){return this.position_<this.hashSet_.size()},Js.prototype.remove=function(){throw new E};var $s=0,to=1;rt.prototype=new Z,rt.prototype.get=function(t){for(var e=this.root_;null!==e;){var n=t.compareTo(e.key);if(0>n)e=e.left;else{if(!(n>0))return e.value;e=e.right}}return null},rt.prototype.put=function(t,e){if(null===this.root_)return this.root_={key:t,value:e,left:null,right:null,parent:null,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}},this.size_=1,null;var n,i,r=this.root_;do if(n=r,i=t.compareTo(r.key),0>i)r=r.left;else{if(!(i>0)){var s=r.value;return r.value=e,s}r=r.right}while(null!==r);var o={key:t,left:null,right:null,value:e,parent:n,color:$s,getValue:function(){return this.value},getKey:function(){return this.key}};return 0>i?n.left=o:n.right=o,this.fixAfterInsertion(o),this.size_++,null},rt.prototype.fixAfterInsertion=function(t){for(t.color=to;null!=t&&t!=this.root_&&t.parent.color==to;)if(tt(t)==nt(tt(tt(t)))){var e=it(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==it(tt(t))&&(t=tt(t),this.rotateLeft(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateRight(tt(tt(t))))}else{var e=nt(tt(tt(t)));$(e)==to?(et(tt(t),$s),et(e,$s),et(tt(tt(t)),to),t=tt(tt(t))):(t==nt(tt(t))&&(t=tt(t),this.rotateRight(t)),et(tt(t),$s),et(tt(tt(t)),to),this.rotateLeft(tt(tt(t))))}this.root_.color=$s},rt.prototype.values=function(){var t=new I,e=this.getFirstEntry();if(null!==e)for(t.add(e.value);null!==(e=rt.successor(e));)t.add(e.value);return t},rt.prototype.entrySet=function(){var t=new J,e=this.getFirstEntry();if(null!==e)for(t.add(e);null!==(e=rt.successor(e));)t.add(e);return t},rt.prototype.rotateLeft=function(t){if(null!=t){var e=t.right;t.right=e.left,null!=e.left&&(e.left.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.left==t?t.parent.left=e:t.parent.right=e,e.left=t,t.parent=e}},rt.prototype.rotateRight=function(t){if(null!=t){var e=t.left;t.left=e.right,null!=e.right&&(e.right.parent=t),e.parent=t.parent,null==t.parent?this.root_=e:t.parent.right==t?t.parent.right=e:t.parent.left=e,e.right=t,t.parent=e}},rt.prototype.getFirstEntry=function(){var t=this.root_;if(null!=t)for(;null!=t.left;)t=t.left;return t},rt.successor=function(t){if(null===t)return null;if(null!==t.right){for(var e=t.right;null!==e.left;)e=e.left;return e}for(var e=t.parent,n=t;null!==e&&n===e.right;)n=e,e=e.parent;return e},rt.prototype.size=function(){return this.size_},e(st.prototype,{interfaces_:function(){return[]},getClass:function(){return st}}),ot.prototype=new Q,at.prototype=new ot,at.prototype.contains=function(t){for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(0===i.compareTo(t))return!0}return!1},at.prototype.add=function(t){if(this.contains(t))return!1;for(var e=0,n=this.array_.length;n>e;e++){var i=this.array_[e];if(1===i.compareTo(t))return this.array_.splice(e,0,t),!0}return this.array_.push(t),!0},at.prototype.addAll=function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next());return!0},at.prototype.remove=function(t){throw new E},at.prototype.size=function(){return this.array_.length},at.prototype.isEmpty=function(){return 0===this.array_.length},at.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},at.prototype.iterator=function(){return new eo(this)};var eo=function(t){this.treeSet_=t,this.position_=0};eo.prototype.next=function(){if(this.position_===this.treeSet_.size())throw new x;return this.treeSet_.array_[this.position_++]},eo.prototype.hasNext=function(){return this.position_<this.treeSet_.size()},eo.prototype.remove=function(){throw new E},ut.sort=function(){var t,e,n,i,r=arguments[0];if(1===arguments.length)return i=function(t,e){return t.compareTo(e)},void r.sort(i);if(2===arguments.length)n=arguments[1],i=function(t,e){return n.compare(t,e)},r.sort(i);else{if(3===arguments.length){e=r.slice(arguments[1],arguments[2]),e.sort();var s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length));for(r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}if(4===arguments.length){for(e=r.slice(arguments[1],arguments[2]),n=arguments[3],i=function(t,e){return n.compare(t,e)},e.sort(i),s=r.slice(0,arguments[1]).concat(e,r.slice(arguments[2],r.length)),r.splice(0,r.length),t=0;t<s.length;t++)r.push(s[t]);return}}},ut.asList=function(t){for(var e=new I,n=0,i=t.length;i>n;n++)e.add(t[n]);return e},e(lt.prototype,{interfaces_:function(){return[]},getClass:function(){return lt}}),lt.toDimensionSymbol=function(t){switch(t){case lt.FALSE:return lt.SYM_FALSE;case lt.TRUE:return lt.SYM_TRUE;case lt.DONTCARE:return lt.SYM_DONTCARE;case lt.P:return lt.SYM_P;case lt.L:return lt.SYM_L;case lt.A:return lt.SYM_A}throw new i("Unknown dimension value: "+t)},lt.toDimensionValue=function(t){switch(O.toUpperCase(t)){case lt.SYM_FALSE:return lt.FALSE;case lt.SYM_TRUE:return lt.TRUE;case lt.SYM_DONTCARE:return lt.DONTCARE;case lt.SYM_P:return lt.P;case lt.SYM_L:return lt.L;case lt.SYM_A:return lt.A}throw new i("Unknown dimension symbol: "+t)},lt.P=0,lt.L=1,lt.A=2,lt.FALSE=-1,lt.TRUE=-2,lt.DONTCARE=-3,lt.SYM_FALSE="F",lt.SYM_TRUE="T",lt.SYM_DONTCARE="*",lt.SYM_P="0",lt.SYM_L="1",lt.SYM_A="2",e(ht.prototype,{filter:function(t){},interfaces_:function(){return[]},getClass:function(){return ht}}),e(ct.prototype,{filter:function(t,e){},isDone:function(){},isGeometryChanged:function(){},interfaces_:function(){return[]},getClass:function(){return ct}}),h(ft,B),e(ft.prototype,{computeEnvelopeInternal:function(){for(var t=new C,e=0;e<this.geometries.length;e++)t.expandToInclude(this.geometries[e].getEnvelopeInternal());return t},getGeometryN:function(t){return this.geometries[t]},getSortIndex:function(){return B.SORTINDEX_GEOMETRYCOLLECTION},getCoordinates:function(){for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=0;n<this.geometries.length;n++)for(var i=this.geometries[n].getCoordinates(),r=0;r<i.length;r++)e++,t[e]=i[r];return t},getArea:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getArea();return t},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.geometries.length!==n.geometries.length)return!1;for(var i=0;i<this.geometries.length;i++)if(!this.geometries[i].equalsExact(n.geometries[i],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<this.geometries.length;t++)this.geometries[t].normalize();ut.sort(this.geometries)},getCoordinate:function(){return this.isEmpty()?null:this.geometries[0].getCoordinate()},getBoundaryDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getBoundaryDimension());return t},getDimension:function(){for(var t=lt.FALSE,e=0;e<this.geometries.length;e++)t=Math.max(t,this.geometries[e].getDimension());return t},getLength:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getLength();return t},getNumPoints:function(){for(var t=0,e=0;e<this.geometries.length;e++)t+=this.geometries[e].getNumPoints();return t},getNumGeometries:function(){return this.geometries.length},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createGeometryCollection(e)},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=new at(ut.asList(this.geometries)),n=new at(ut.asList(t.geometries));return this.compare(e,n)}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s=i,o=this.getNumGeometries(),a=s.getNumGeometries(),u=0;o>u&&a>u;){var l=this.getGeometryN(u),h=s.getGeometryN(u),c=l.compareToSameClass(h,r);if(0!==c)return c;u++}return o>u?1:a>u?-1:0}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.geometries.length;e++)this.geometries[e].apply(t);else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.geometries.length)return null;for(var e=0;e<this.geometries.length&&(this.geometries[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(i)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this);for(var e=0;e<this.geometries.length;e++)this.geometries[e].apply(r)}},getBoundary:function(){return this.checkNotGeometryCollection(this),f.shouldNeverReachHere(),null},clone:function(){var t=B.prototype.clone.call(this);t.geometries=new Array(this.geometries.length).fill(null);for(var e=0;e<this.geometries.length;e++)t.geometries[e]=this.geometries[e].clone();return t},getGeometryType:function(){return"GeometryCollection"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new ft(t,this.factory)},isEmpty:function(){for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isEmpty())return!1;return!0},interfaces_:function(){return[]},getClass:function(){return ft}}),ft.serialVersionUID=-0x4f07bcb1f857d800,h(gt,ft),e(gt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTILINESTRING},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){if(this.isEmpty())return!1;for(var t=0;t<this.geometries.length;t++)if(!this.geometries[t].isClosed())return!1;return!0},getDimension:function(){return 1},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[t-1-n]=this.geometries[n].reverse();return this.getFactory().createMultiLineString(e)},getBoundary:function(){return new dt(this).getBoundary()},getGeometryType:function(){return"MultiLineString"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new gt(t,this.factory)},interfaces_:function(){
return[st]},getClass:function(){return gt}}),gt.serialVersionUID=0x7155d2ab4afa8000,e(dt.prototype,{boundaryMultiLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();var e=this.computeBoundaryCoordinates(t);return 1===e.length?this.geomFact.createPoint(e[0]):this.geomFact.createMultiPointFromCoords(e)},getBoundary:function(){return this.geom instanceof St?this.boundaryLineString(this.geom):this.geom instanceof gt?this.boundaryMultiLineString(this.geom):this.geom.getBoundary()},boundaryLineString:function(t){if(this.geom.isEmpty())return this.getEmptyMultiPoint();if(t.isClosed()){var e=this.bnRule.isInBoundary(2);return e?t.getStartPoint():this.geomFact.createMultiPoint()}return this.geomFact.createMultiPoint([t.getStartPoint(),t.getEndPoint()])},getEmptyMultiPoint:function(){return this.geomFact.createMultiPoint()},computeBoundaryCoordinates:function(t){var e=new I;this.endpointMap=new rt;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);0!==i.getNumPoints()&&(this.addEndpoint(i.getCoordinateN(0)),this.addEndpoint(i.getCoordinateN(i.getNumPoints()-1)))}for(var r=this.endpointMap.entrySet().iterator();r.hasNext();){var s=r.next(),o=s.getValue(),a=o.count;this.bnRule.isInBoundary(a)&&e.add(s.getKey())}return H.toCoordinateArray(e)},addEndpoint:function(t){var e=this.endpointMap.get(t);null===e&&(e=new pt,this.endpointMap.put(t,e)),e.count++},interfaces_:function(){return[]},getClass:function(){return dt}}),dt.getBoundary=function(){if(1===arguments.length){var t=arguments[0],e=new dt(t);return e.getBoundary()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new dt(n,i);return e.getBoundary()}},e(pt.prototype,{interfaces_:function(){return[]},getClass:function(){return pt}}),e(Nt.prototype,{interfaces_:function(){return[]},getClass:function(){return Nt}}),Nt.chars=function(t,e){for(var n=new Array(e).fill(null),i=0;e>i;i++)n[i]=t;return new String(n)},Nt.getStackTrace=function(){if(1===arguments.length){var t=arguments[0],e=new xt,n=new vt(e);return t.printStackTrace(n),e.toString()}if(2===arguments.length){for(var i=arguments[0],r=arguments[1],s="",o=new mt(Nt.getStackTrace(i)),a=new It(o),u=0;r>u;u++)try{s+=a.readLine()+Nt.NEWLINE}catch(t){if(!(t instanceof Et))throw t;f.shouldNeverReachHere()}finally{}return s}},Nt.split=function(t,e){for(var n=e.length,i=new I,r=""+t,s=r.indexOf(e);s>=0;){var o=r.substring(0,s);i.add(o),r=r.substring(s+n),s=r.indexOf(e)}r.length>0&&i.add(r);for(var a=new Array(i.size()).fill(null),u=0;u<a.length;u++)a[u]=i.get(u);return a},Nt.toString=function(){if(1===arguments.length){var t=arguments[0];return Nt.SIMPLE_ORDINATE_FORMAT.format(t)}},Nt.spaces=function(t){return Nt.chars(" ",t)},Nt.NEWLINE=A.getProperty("line.separator"),Nt.SIMPLE_ORDINATE_FORMAT=new yt("0.#"),e(Ct.prototype,{interfaces_:function(){return[]},getClass:function(){return Ct}}),Ct.copyCoord=function(t,e,n,i){for(var r=Math.min(t.getDimension(),n.getDimension()),s=0;r>s;s++)n.setOrdinate(i,s,t.getOrdinate(e,s))},Ct.isRing=function(t){var e=t.size();return 0===e?!0:3>=e?!1:t.getOrdinate(0,D.X)===t.getOrdinate(e-1,D.X)&&t.getOrdinate(0,D.Y)===t.getOrdinate(e-1,D.Y)},Ct.isEqual=function(t,e){var n=t.size(),i=e.size();if(n!==i)return!1;for(var s=Math.min(t.getDimension(),e.getDimension()),o=0;n>o;o++)for(var a=0;s>a;a++){var u=t.getOrdinate(o,a),l=e.getOrdinate(o,a);if(!(t.getOrdinate(o,a)===e.getOrdinate(o,a)||r.isNaN(u)&&r.isNaN(l)))return!1}return!0},Ct.extend=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();if(Ct.copy(e,0,i,0,r),r>0)for(var s=r;n>s;s++)Ct.copy(e,r-1,i,s,1);return i},Ct.reverse=function(t){for(var e=t.size()-1,n=Math.trunc(e/2),i=0;n>=i;i++)Ct.swap(t,i,e-i)},Ct.swap=function(t,e,n){if(e===n)return null;for(var i=0;i<t.getDimension();i++){var r=t.getOrdinate(e,i);t.setOrdinate(e,i,t.getOrdinate(n,i)),t.setOrdinate(n,i,r)}},Ct.copy=function(t,e,n,i,r){for(var s=0;r>s;s++)Ct.copyCoord(t,e+s,n,i+s)},Ct.toString=function(){if(1===arguments.length){var t=arguments[0],e=t.size();if(0===e)return"()";var n=t.getDimension(),i=new P;i.append("(");for(var r=0;e>r;r++){r>0&&i.append(" ");for(var s=0;n>s;s++)s>0&&i.append(","),i.append(Nt.toString(t.getOrdinate(r,s)))}return i.append(")"),i.toString()}},Ct.ensureValidRing=function(t,e){var n=e.size();if(0===n)return e;if(3>=n)return Ct.createClosedRing(t,e,4);var i=e.getOrdinate(0,D.X)===e.getOrdinate(n-1,D.X)&&e.getOrdinate(0,D.Y)===e.getOrdinate(n-1,D.Y);return i?e:Ct.createClosedRing(t,e,n+1)},Ct.createClosedRing=function(t,e,n){var i=t.create(n,e.getDimension()),r=e.size();Ct.copy(e,0,i,0,r);for(var s=r;n>s;s++)Ct.copy(e,0,i,s,1);return i},h(St,B),e(St.prototype,{computeEnvelopeInternal:function(){return this.isEmpty()?new C:this.points.expandEnvelope(new C)},isRing:function(){return this.isClosed()&&this.isSimple()},getSortIndex:function(){return B.SORTINDEX_LINESTRING},getCoordinates:function(){return this.points.toCoordinateArray()},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t;if(this.points.size()!==n.points.size())return!1;for(var i=0;i<this.points.size();i++)if(!this.equal(this.points.getCoordinate(i),n.points.getCoordinate(i),e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){for(var t=0;t<Math.trunc(this.points.size()/2);t++){var e=this.points.size()-1-t;if(!this.points.getCoordinate(t).equals(this.points.getCoordinate(e)))return this.points.getCoordinate(t).compareTo(this.points.getCoordinate(e))>0&&Ct.reverse(this.points),null}},getCoordinate:function(){return this.isEmpty()?null:this.points.getCoordinate(0)},getBoundaryDimension:function(){return this.isClosed()?lt.FALSE:0},isClosed:function(){return this.isEmpty()?!1:this.getCoordinateN(0).equals2D(this.getCoordinateN(this.getNumPoints()-1))},getEndPoint:function(){return this.isEmpty()?null:this.getPointN(this.getNumPoints()-1)},getDimension:function(){return 1},getLength:function(){return he.computeLength(this.points)},getNumPoints:function(){return this.points.size()},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLineString(t);return e},compareToSameClass:function(){if(1===arguments.length){for(var t=arguments[0],e=t,n=0,i=0;n<this.points.size()&&i<e.points.size();){var r=this.points.getCoordinate(n).compareTo(e.points.getCoordinate(i));if(0!==r)return r;n++,i++}return n<this.points.size()?1:i<e.points.size()?-1:0}if(2===arguments.length){var s=arguments[0],o=arguments[1],e=s;return o.compare(this.points,e.points)}},apply:function(){if(R(arguments[0],z))for(var t=arguments[0],e=0;e<this.points.size();e++)t.filter(this.points.getCoordinate(e));else if(R(arguments[0],ct)){var n=arguments[0];if(0===this.points.size())return null;for(var e=0;e<this.points.size()&&(n.filter(this.points,e),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this)}},getBoundary:function(){return new dt(this).getBoundary()},isEquivalentClass:function(t){return t instanceof St},clone:function(){var t=B.prototype.clone.call(this);return t.points=this.points.clone(),t},getCoordinateN:function(t){return this.points.getCoordinate(t)},getGeometryType:function(){return"LineString"},copy:function(){return new St(this.points.copy(),this.factory)},getCoordinateSequence:function(){return this.points},isEmpty:function(){return 0===this.points.size()},init:function(t){if(null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),1===t.size())throw new i("Invalid number of points in LineString (found "+t.size()+" - must be 0 or >= 2)");this.points=t},isCoordinate:function(t){for(var e=0;e<this.points.size();e++)if(this.points.getCoordinate(e).equals(t))return!0;return!1},getStartPoint:function(){return this.isEmpty()?null:this.getPointN(0)},getPointN:function(t){return this.getFactory().createPoint(this.points.getCoordinate(t))},interfaces_:function(){return[st]},getClass:function(){return St}}),St.serialVersionUID=0x2b2b51ba435c8e00,e(wt.prototype,{interfaces_:function(){return[]},getClass:function(){return wt}}),h(Lt,B),e(Lt.prototype,{computeEnvelopeInternal:function(){if(this.isEmpty())return new C;var t=new C;return t.expandToInclude(this.coordinates.getX(0),this.coordinates.getY(0)),t},getSortIndex:function(){return B.SORTINDEX_POINT},getCoordinates:function(){return this.isEmpty()?[]:[this.getCoordinate()]},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?this.isEmpty()&&t.isEmpty()?!0:this.isEmpty()!==t.isEmpty()?!1:this.equal(t.getCoordinate(),this.getCoordinate(),e):!1}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){},getCoordinate:function(){return 0!==this.coordinates.size()?this.coordinates.getCoordinate(0):null},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getNumPoints:function(){return this.isEmpty()?0:1},reverse:function(){return this.copy()},getX:function(){if(null===this.getCoordinate())throw new IllegalStateException("getX called on empty Point");return this.getCoordinate().x},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=t;return this.getCoordinate().compareTo(e.getCoordinate())}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=n;return i.compare(this.coordinates,e.coordinates)}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];if(this.isEmpty())return null;t.filter(this.getCoordinate())}else if(R(arguments[0],ct)){var e=arguments[0];if(this.isEmpty())return null;e.filter(this.coordinates,0),e.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var n=arguments[0];n.filter(this)}else if(R(arguments[0],q)){var i=arguments[0];i.filter(this)}},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},clone:function(){var t=B.prototype.clone.call(this);return t.coordinates=this.coordinates.clone(),t},getGeometryType:function(){return"Point"},copy:function(){return new Lt(this.coordinates.copy(),this.factory)},getCoordinateSequence:function(){return this.coordinates},getY:function(){if(null===this.getCoordinate())throw new IllegalStateException("getY called on empty Point");return this.getCoordinate().y},isEmpty:function(){return 0===this.coordinates.size()},init:function(t){null===t&&(t=this.getFactory().getCoordinateSequenceFactory().create([])),f.isTrue(t.size()<=1),this.coordinates=t},isSimple:function(){return!0},interfaces_:function(){return[wt]},getClass:function(){return Lt}}),Lt.serialVersionUID=0x44077bad161cbc00,e(Rt.prototype,{interfaces_:function(){return[]},getClass:function(){return Rt}}),h(Tt,B),e(Tt.prototype,{computeEnvelopeInternal:function(){return this.shell.getEnvelopeInternal()},getSortIndex:function(){return B.SORTINDEX_POLYGON},getCoordinates:function(){if(this.isEmpty())return[];for(var t=new Array(this.getNumPoints()).fill(null),e=-1,n=this.shell.getCoordinates(),i=0;i<n.length;i++)e++,t[e]=n[i];for(var r=0;r<this.holes.length;r++)for(var s=this.holes[r].getCoordinates(),o=0;o<s.length;o++)e++,t[e]=s[o];return t},getArea:function(){var t=0;t+=Math.abs(he.signedArea(this.shell.getCoordinateSequence()));for(var e=0;e<this.holes.length;e++)t-=Math.abs(he.signedArea(this.holes[e].getCoordinateSequence()));return t},isRectangle:function(){if(0!==this.getNumInteriorRing())return!1;if(null===this.shell)return!1;if(5!==this.shell.getNumPoints())return!1;for(var t=this.shell.getCoordinateSequence(),e=this.getEnvelopeInternal(),n=0;5>n;n++){var i=t.getX(n);if(i!==e.getMinX()&&i!==e.getMaxX())return!1;var r=t.getY(n);if(r!==e.getMinY()&&r!==e.getMaxY())return!1}for(var s=t.getX(0),o=t.getY(0),n=1;4>=n;n++){var i=t.getX(n),r=t.getY(n),a=i!==s,u=r!==o;if(a===u)return!1;s=i,o=r}return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(!this.isEquivalentClass(t))return!1;var n=t,i=this.shell,r=n.shell;if(!i.equalsExact(r,e))return!1;if(this.holes.length!==n.holes.length)return!1;for(var s=0;s<this.holes.length;s++)if(!this.holes[s].equalsExact(n.holes[s],e))return!1;return!0}return B.prototype.equalsExact.apply(this,arguments)},normalize:function(){if(0===arguments.length){this.normalize(this.shell,!0);for(var t=0;t<this.holes.length;t++)this.normalize(this.holes[t],!1);ut.sort(this.holes)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];if(e.isEmpty())return null;var i=new Array(e.getCoordinates().length-1).fill(null);A.arraycopy(e.getCoordinates(),0,i,0,i.length);var r=H.minCoordinate(e.getCoordinates());H.scroll(i,r),A.arraycopy(i,0,e.getCoordinates(),0,i.length),e.getCoordinates()[i.length]=i[0],he.isCCW(e.getCoordinates())===n&&H.reverse(e.getCoordinates())}},getCoordinate:function(){return this.shell.getCoordinate()},getNumInteriorRing:function(){return this.holes.length},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},getLength:function(){var t=0;t+=this.shell.getLength();for(var e=0;e<this.holes.length;e++)t+=this.holes[e].getLength();return t},getNumPoints:function(){for(var t=this.shell.getNumPoints(),e=0;e<this.holes.length;e++)t+=this.holes[e].getNumPoints();return t},reverse:function(){var t=this.copy();t.shell=this.shell.copy().reverse(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].copy().reverse();return t},convexHull:function(){return this.getExteriorRing().convexHull()},compareToSameClass:function(){if(1===arguments.length){var t=arguments[0],e=this.shell,n=t.shell;return e.compareToSameClass(n)}if(2===arguments.length){var i=arguments[0],r=arguments[1],s=i,e=this.shell,n=s.shell,o=e.compareToSameClass(n,r);if(0!==o)return o;for(var a=this.getNumInteriorRing(),u=s.getNumInteriorRing(),l=0;a>l&&u>l;){var h=this.getInteriorRingN(l),c=s.getInteriorRingN(l),f=h.compareToSameClass(c,r);if(0!==f)return f;l++}return a>l?1:u>l?-1:0}},apply:function(){if(R(arguments[0],z)){var t=arguments[0];this.shell.apply(t);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(t)}else if(R(arguments[0],ct)){var n=arguments[0];if(this.shell.apply(n),!n.isDone())for(var e=0;e<this.holes.length&&(this.holes[e].apply(n),!n.isDone());e++);n.isGeometryChanged()&&this.geometryChanged()}else if(R(arguments[0],ht)){var i=arguments[0];i.filter(this)}else if(R(arguments[0],q)){var r=arguments[0];r.filter(this),this.shell.apply(r);for(var e=0;e<this.holes.length;e++)this.holes[e].apply(r)}},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();var t=new Array(this.holes.length+1).fill(null);t[0]=this.shell;for(var e=0;e<this.holes.length;e++)t[e+1]=this.holes[e];return t.length<=1?this.getFactory().createLinearRing(t[0].getCoordinateSequence()):this.getFactory().createMultiLineString(t)},clone:function(){var t=B.prototype.clone.call(this);t.shell=this.shell.clone(),t.holes=new Array(this.holes.length).fill(null);for(var e=0;e<this.holes.length;e++)t.holes[e]=this.holes[e].clone();return t},getGeometryType:function(){return"Polygon"},copy:function(){for(var t=this.shell.copy(),e=new Array(this.holes.length).fill(null),n=0;n<e.length;n++)e[n]=this.holes[n].copy();return new Tt(t,e,this.factory)},getExteriorRing:function(){return this.shell},isEmpty:function(){return this.shell.isEmpty()},getInteriorRingN:function(t){return this.holes[t]},interfaces_:function(){return[Rt]},getClass:function(){return Tt}}),Tt.serialVersionUID=-0x307ffefd8dc97200,h(Pt,ft),e(Pt.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOINT},isValid:function(){return!0},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.geometries[t].getCoordinate()}return ft.prototype.getCoordinate.apply(this,arguments)},getBoundaryDimension:function(){return lt.FALSE},getDimension:function(){return 0},getBoundary:function(){return this.getFactory().createGeometryCollection(null)},getGeometryType:function(){return"MultiPoint"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Pt(t,this.factory)},interfaces_:function(){return[wt]},getClass:function(){return Pt}}),Pt.serialVersionUID=-0x6fb1ed4162e0fc00,h(bt,St),e(bt.prototype,{getSortIndex:function(){return B.SORTINDEX_LINEARRING},getBoundaryDimension:function(){return lt.FALSE},isClosed:function(){return this.isEmpty()?!0:St.prototype.isClosed.call(this)},reverse:function(){var t=this.points.copy();Ct.reverse(t);var e=this.getFactory().createLinearRing(t);return e},validateConstruction:function(){if(!this.isEmpty()&&!St.prototype.isClosed.call(this))throw new i("Points of LinearRing do not form a closed linestring");if(this.getCoordinateSequence().size()>=1&&this.getCoordinateSequence().size()<bt.MINIMUM_VALID_SIZE)throw new i("Invalid number of points in LinearRing (found "+this.getCoordinateSequence().size()+" - must be 0 or >= 4)")},getGeometryType:function(){return"LinearRing"},copy:function(){return new bt(this.points.copy(),this.factory)},interfaces_:function(){return[]},getClass:function(){return bt}}),bt.MINIMUM_VALID_SIZE=4,bt.serialVersionUID=-0x3b229e262367a600,h(Ot,ft),e(Ot.prototype,{getSortIndex:function(){return B.SORTINDEX_MULTIPOLYGON},equalsExact:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.isEquivalentClass(t)?ft.prototype.equalsExact.call(this,t,e):!1}return ft.prototype.equalsExact.apply(this,arguments)},getBoundaryDimension:function(){return 1},getDimension:function(){return 2},reverse:function(){for(var t=this.geometries.length,e=new Array(t).fill(null),n=0;n<this.geometries.length;n++)e[n]=this.geometries[n].reverse();return this.getFactory().createMultiPolygon(e)},getBoundary:function(){if(this.isEmpty())return this.getFactory().createMultiLineString();for(var t=new I,e=0;e<this.geometries.length;e++)for(var n=this.geometries[e],i=n.getBoundary(),r=0;r<i.getNumGeometries();r++)t.add(i.getGeometryN(r));var s=new Array(t.size()).fill(null);return this.getFactory().createMultiLineString(t.toArray(s))},getGeometryType:function(){return"MultiPolygon"},copy:function(){for(var t=new Array(this.geometries.length).fill(null),e=0;e<t.length;e++)t[e]=this.geometries[e].copy();return new Ot(t,this.factory)},interfaces_:function(){return[Rt]},getClass:function(){return Ot}}),Ot.serialVersionUID=-0x7a5aa1369171980,e(_t.prototype,{setCopyUserData:function(t){this.isUserDataCopied=t},edit:function(t,e){if(null===t)return null;var n=this.editInternal(t,e);return this.isUserDataCopied&&n.setUserData(t.getUserData()),n},editInternal:function(t,e){return null===this.factory&&(this.factory=t.getFactory()),t instanceof ft?this.editGeometryCollection(t,e):t instanceof Tt?this.editPolygon(t,e):t instanceof Lt?e.edit(t,this.factory):t instanceof St?e.edit(t,this.factory):(f.shouldNeverReachHere("Unsupported Geometry class: "+t.getClass().getName()),null)},editGeometryCollection:function(t,e){for(var n=e.edit(t,this.factory),i=new I,r=0;r<n.getNumGeometries();r++){var s=this.edit(n.getGeometryN(r),e);null===s||s.isEmpty()||i.add(s)}return n.getClass()===Pt?this.factory.createMultiPoint(i.toArray([])):n.getClass()===gt?this.factory.createMultiLineString(i.toArray([])):n.getClass()===Ot?this.factory.createMultiPolygon(i.toArray([])):this.factory.createGeometryCollection(i.toArray([]))},editPolygon:function(t,e){var n=e.edit(t,this.factory);if(null===n&&(n=this.factory.createPolygon(null)),n.isEmpty())return n;var i=this.edit(n.getExteriorRing(),e);if(null===i||i.isEmpty())return this.factory.createPolygon();for(var r=new I,s=0;s<n.getNumInteriorRing();s++){var o=this.edit(n.getInteriorRingN(s),e);null===o||o.isEmpty()||r.add(o)}return this.factory.createPolygon(i,r.toArray([]))},interfaces_:function(){return[]},getClass:function(){return _t}}),_t.GeometryEditorOperation=Mt,e(Dt.prototype,{edit:function(t,e){return t},interfaces_:function(){return[Mt]},getClass:function(){return Dt}}),e(At.prototype,{edit:function(t,e){if(t instanceof bt)return e.createLinearRing(this.editCoordinates(t.getCoordinates(),t));if(t instanceof St)return e.createLineString(this.editCoordinates(t.getCoordinates(),t));if(t instanceof Lt){var n=this.editCoordinates(t.getCoordinates(),t);return n.length>0?e.createPoint(n[0]):e.createPoint()}return t},interfaces_:function(){return[Mt]},getClass:function(){return At}}),e(Ft.prototype,{edit:function(t,e){return t instanceof bt?e.createLinearRing(this.edit(t.getCoordinateSequence(),t)):t instanceof St?e.createLineString(this.edit(t.getCoordinateSequence(),t)):t instanceof Lt?e.createPoint(this.edit(t.getCoordinateSequence(),t)):t},interfaces_:function(){return[Mt]},getClass:function(){return Ft}}),_t.NoOpGeometryOperation=Dt,_t.CoordinateOperation=At,_t.CoordinateSequenceOperation=Ft,e(Gt.prototype,{setOrdinate:function(t,e,n){switch(e){case D.X:this.coordinates[t].x=n;break;case D.Y:this.coordinates[t].y=n;break;case D.Z:this.coordinates[t].z=n;break;default:throw new i("invalid ordinateIndex")}},size:function(){return this.coordinates.length},getOrdinate:function(t,e){switch(e){case D.X:return this.coordinates[t].x;case D.Y:return this.coordinates[t].y;case D.Z:return this.coordinates[t].z}return r.NaN},getCoordinate:function(){if(1===arguments.length){var t=arguments[0];return this.coordinates[t]}if(2===arguments.length){var e=arguments[0],n=arguments[1];n.x=this.coordinates[e].x,n.y=this.coordinates[e].y,n.z=this.coordinates[e].z}},getCoordinateCopy:function(t){return new g(this.coordinates[t])},getDimension:function(){return this.dimension},getX:function(t){return this.coordinates[t].x},clone:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].clone();return new Gt(t,this.dimension)},expandEnvelope:function(t){for(var e=0;e<this.coordinates.length;e++)t.expandToInclude(this.coordinates[e]);return t},copy:function(){for(var t=new Array(this.size()).fill(null),e=0;e<this.coordinates.length;e++)t[e]=this.coordinates[e].copy();return new Gt(t,this.dimension)},toString:function(){if(this.coordinates.length>0){var t=new P(17*this.coordinates.length);t.append("("),t.append(this.coordinates[0]);for(var e=1;e<this.coordinates.length;e++)t.append(", "),t.append(this.coordinates[e]);return t.append(")"),t.toString()}return"()"},getY:function(t){return this.coordinates[t].y},toCoordinateArray:function(){return this.coordinates},interfaces_:function(){return[D,u]},getClass:function(){return Gt}}),Gt.serialVersionUID=-0xcb44a778db18e00,e(qt.prototype,{readResolve:function(){return qt.instance()},create:function(){if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Gt(t)}if(R(arguments[0],D)){var e=arguments[0];return new Gt(e)}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return i>3&&(i=3),2>i?new Gt(n):new Gt(n,i)}},interfaces_:function(){return[G,u]},getClass:function(){return qt}}),qt.instance=function(){return qt.instanceObject},qt.serialVersionUID=-0x38e49fa6cf6f2e00,qt.instanceObject=new qt;var no,io=Object.defineProperty,ro=zt({delete:kt,has:Xt,get:Yt,set:Ht,keys:jt,values:Kt,entries:Zt,forEach:$t,clear:Wt}),so="undefined"!=typeof Map&&Map.prototype.values?Map:ro;te.prototype=new K,te.prototype.get=function(t){return this.map_.get(t)||null},te.prototype.put=function(t,e){return this.map_.set(t,e),e},te.prototype.values=function(){for(var t=new I,e=this.map_.values(),n=e.next();!n.done;)t.add(n.value),n=e.next();return t},te.prototype.entrySet=function(){var t=new J;return this.map_.entries().forEach(function(e){return t.add(e)}),t},te.prototype.size=function(){return this.map_.size()},e(ee.prototype,{equals:function(t){if(!(t instanceof ee))return!1;var e=t;return this.modelType===e.modelType&&this.scale===e.scale},compareTo:function(t){var e=t,n=this.getMaximumSignificantDigits(),i=e.getMaximumSignificantDigits();return new b(n).compareTo(new b(i))},getScale:function(){return this.scale},isFloating:function(){return this.modelType===ee.FLOATING||this.modelType===ee.FLOATING_SINGLE},getType:function(){return this.modelType},toString:function(){var t="UNKNOWN";return this.modelType===ee.FLOATING?t="Floating":this.modelType===ee.FLOATING_SINGLE?t="Floating-Single":this.modelType===ee.FIXED&&(t="Fixed (Scale="+this.getScale()+")"),t},makePrecise:function(){if("number"==typeof arguments[0]){var t=arguments[0];if(r.isNaN(t))return t;if(this.modelType===ee.FLOATING_SINGLE){var e=t;return e}return this.modelType===ee.FIXED?Math.round(t*this.scale)/this.scale:t}if(arguments[0]instanceof g){var n=arguments[0];if(this.modelType===ee.FLOATING)return null;n.x=this.makePrecise(n.x),n.y=this.makePrecise(n.y)}},getMaximumSignificantDigits:function(){var t=16;return this.modelType===ee.FLOATING?t=16:this.modelType===ee.FLOATING_SINGLE?t=6:this.modelType===ee.FIXED&&(t=1+Math.trunc(Math.ceil(Math.log(this.getScale())/Math.log(10)))),t},setScale:function(t){this.scale=Math.abs(t)},interfaces_:function(){return[u,s]},getClass:function(){return ee}}),ee.mostPrecise=function(t,e){return t.compareTo(e)>=0?t:e},e(ne.prototype,{readResolve:function(){return ne.nameToTypeMap.get(this.name)},toString:function(){return this.name},interfaces_:function(){return[u]},getClass:function(){return ne}}),ne.serialVersionUID=-552860263173159e4,ne.nameToTypeMap=new te,ee.Type=ne,ee.serialVersionUID=0x6bee6404e9a25c00,ee.FIXED=new ne("FIXED"),ee.FLOATING=new ne("FLOATING"),ee.FLOATING_SINGLE=new ne("FLOATING SINGLE"),ee.maximumPreciseValue=9007199254740992,e(ie.prototype,{toGeometry:function(t){return t.isNull()?this.createPoint(null):t.getMinX()===t.getMaxX()&&t.getMinY()===t.getMaxY()?this.createPoint(new g(t.getMinX(),t.getMinY())):t.getMinX()===t.getMaxX()||t.getMinY()===t.getMaxY()?this.createLineString([new g(t.getMinX(),t.getMinY()),new g(t.getMaxX(),t.getMaxY())]):this.createPolygon(this.createLinearRing([new g(t.getMinX(),t.getMinY()),new g(t.getMinX(),t.getMaxY()),new g(t.getMaxX(),t.getMaxY()),new g(t.getMaxX(),t.getMinY()),new g(t.getMinX(),t.getMinY())]),null)},createLineString:function(){if(0===arguments.length)return this.createLineString(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLineString(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new St(e,this)}}},createMultiLineString:function(){if(0===arguments.length)return new gt(null,this);if(1===arguments.length){var t=arguments[0];return new gt(t,this)}},buildGeometry:function(t){for(var e=null,n=!1,i=!1,r=t.iterator();r.hasNext();){var s=r.next(),o=s.getClass();null===e&&(e=o),o!==e&&(n=!0),s.isGeometryCollectionOrDerived()&&(i=!0)}if(null===e)return this.createGeometryCollection();if(n||i)return this.createGeometryCollection(ie.toGeometryArray(t));var a=t.iterator().next(),u=t.size()>1;if(u){if(a instanceof Tt)return this.createMultiPolygon(ie.toPolygonArray(t));if(a instanceof St)return this.createMultiLineString(ie.toLineStringArray(t));if(a instanceof Lt)return this.createMultiPoint(ie.toPointArray(t));f.shouldNeverReachHere("Unhandled class: "+a.getClass().getName())}return a},createMultiPointFromCoords:function(t){return this.createMultiPoint(null!==t?this.getCoordinateSequenceFactory().create(t):null)},createPoint:function(){if(0===arguments.length)return this.createPoint(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof g){var t=arguments[0];return this.createPoint(null!==t?this.getCoordinateSequenceFactory().create([t]):null)}if(R(arguments[0],D)){var e=arguments[0];return new Lt(e,this)}}},getCoordinateSequenceFactory:function(){return this.coordinateSequenceFactory},createPolygon:function(){if(0===arguments.length)return new Tt(null,null,this);if(1===arguments.length){if(R(arguments[0],D)){var t=arguments[0];return this.createPolygon(this.createLinearRing(t))}if(arguments[0]instanceof Array){var e=arguments[0];return this.createPolygon(this.createLinearRing(e))}if(arguments[0]instanceof bt){var n=arguments[0];return this.createPolygon(n,null)}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];return new Tt(i,r,this)}},getSRID:function(){return this.SRID},createGeometryCollection:function(){if(0===arguments.length)return new ft(null,this);if(1===arguments.length){var t=arguments[0];return new ft(t,this)}},createGeometry:function(t){var e=new _t(this);return e.edit(t,{edit:function(){if(2===arguments.length){var t=arguments[0];arguments[1];return this.coordinateSequenceFactory.create(t)}}})},getPrecisionModel:function(){return this.precisionModel},createLinearRing:function(){if(0===arguments.length)return this.createLinearRing(this.getCoordinateSequenceFactory().create([]));if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return this.createLinearRing(null!==t?this.getCoordinateSequenceFactory().create(t):null)}if(R(arguments[0],D)){var e=arguments[0];return new bt(e,this)}}},createMultiPolygon:function(){if(0===arguments.length)return new Ot(null,this);if(1===arguments.length){var t=arguments[0];return new Ot(t,this)}},createMultiPoint:function(){if(0===arguments.length)return new Pt(null,this);if(1===arguments.length){if(arguments[0]instanceof Array){var t=arguments[0];return new Pt(t,this)}if(arguments[0]instanceof Array){var e=arguments[0];return this.createMultiPoint(null!==e?this.getCoordinateSequenceFactory().create(e):null)}if(R(arguments[0],D)){var n=arguments[0];if(null===n)return this.createMultiPoint(new Array(0).fill(null));for(var i=new Array(n.size()).fill(null),r=0;r<n.size();r++){var s=this.getCoordinateSequenceFactory().create(1,n.getDimension());Ct.copy(n,r,s,0,1),i[r]=this.createPoint(s)}return this.createMultiPoint(i)}}},interfaces_:function(){return[u]},getClass:function(){return ie}}),ie.toMultiPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toGeometryArray=function(t){if(null===t)return null;var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.getDefaultCoordinateSequenceFactory=function(){return qt.instance()},ie.toMultiLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLineStringArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toMultiPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toLinearRingArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPointArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.toPolygonArray=function(t){var e=new Array(t.size()).fill(null);return t.toArray(e)},ie.createPointFromInternalCoord=function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},ie.serialVersionUID=-0x5ea75f2051eeb400;var oo={typeStr:/^\s*(\w+)\s*\(\s*(.*)\s*\)\s*$/,emptyTypeStr:/^\s*(\w+)\s*EMPTY\s*$/,spaces:/\s+/,parenComma:/\)\s*,\s*\(/,doubleParenComma:/\)\s*\)\s*,\s*\(\s*\(/,trimParens:/^\s*\(?(.*?)\)?\s*$/};e(re.prototype,{read:function(t){var e,n,i;t=t.replace(/[\n\r]/g," ");var r=oo.typeStr.exec(t);if(-1!==t.search("EMPTY")&&(r=oo.emptyTypeStr.exec(t),r[2]=void 0),r&&(n=r[1].toLowerCase(),i=r[2],uo[n]&&(e=uo[n].apply(this,[i]))),void 0===e)throw new Error("Could not parse WKT "+t);return e},write:function(t){return this.extractGeometry(t)},extractGeometry:function(t){var e=t.getGeometryType().toLowerCase();if(!ao[e])return null;var n,i=e.toUpperCase();return n=t.isEmpty()?i+" EMPTY":i+"("+ao[e].apply(this,[t])+")"}});var ao={coordinate:function(t){return t.x+" "+t.y},point:function(t){
return ao.coordinate.call(this,t.coordinates.coordinates[0])},multipoint:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.point.apply(this,[t.geometries[n]])+")");return e.join(",")},linestring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},linearring:function(t){for(var e=[],n=0,i=t.points.coordinates.length;i>n;++n)e.push(ao.coordinate.apply(this,[t.points.coordinates[n]]));return e.join(",")},multilinestring:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.geometries[n]])+")");return e.join(",")},polygon:function(t){var e=[];e.push("("+ao.linestring.apply(this,[t.shell])+")");for(var n=0,i=t.holes.length;i>n;++n)e.push("("+ao.linestring.apply(this,[t.holes[n]])+")");return e.join(",")},multipolygon:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push("("+ao.polygon.apply(this,[t.geometries[n]])+")");return e.join(",")},geometrycollection:function(t){for(var e=[],n=0,i=t.geometries.length;i>n;++n)e.push(this.extractGeometry(t.geometries[n]));return e.join(",")}},uo={point:function(t){if(void 0===t)return this.geometryFactory.createPoint();var e=t.trim().split(oo.spaces);return this.geometryFactory.createPoint(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])))},multipoint:function(t){if(void 0===t)return this.geometryFactory.createMultiPoint();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.point.apply(this,[e]));return this.geometryFactory.createMultiPoint(i)},linestring:function(t){if(void 0===t)return this.geometryFactory.createLineString();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLineString(i)},linearring:function(t){if(void 0===t)return this.geometryFactory.createLinearRing();for(var e,n=t.trim().split(","),i=[],r=0,s=n.length;s>r;++r)e=n[r].trim().split(oo.spaces),i.push(new g(Number.parseFloat(e[0]),Number.parseFloat(e[1])));return this.geometryFactory.createLinearRing(i)},multilinestring:function(t){if(void 0===t)return this.geometryFactory.createMultiLineString();for(var e,n=t.trim().split(oo.parenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.linestring.apply(this,[e]));return this.geometryFactory.createMultiLineString(i)},polygon:function(t){if(void 0===t)return this.geometryFactory.createPolygon();for(var e,n,i,r,s=t.trim().split(oo.parenComma),o=[],a=0,u=s.length;u>a;++a)e=s[a].replace(oo.trimParens,"$1"),n=uo.linestring.apply(this,[e]),i=this.geometryFactory.createLinearRing(n.points),0===a?r=i:o.push(i);return this.geometryFactory.createPolygon(r,o)},multipolygon:function(t){if(void 0===t)return this.geometryFactory.createMultiPolygon();for(var e,n=t.trim().split(oo.doubleParenComma),i=[],r=0,s=n.length;s>r;++r)e=n[r].replace(oo.trimParens,"$1"),i.push(uo.polygon.apply(this,[e]));return this.geometryFactory.createMultiPolygon(i)},geometrycollection:function(t){if(void 0===t)return this.geometryFactory.createGeometryCollection();t=t.replace(/,\s*([A-Za-z])/g,"|$1");for(var e=t.trim().split("|"),n=[],i=0,r=e.length;r>i;++i)n.push(this.read(e[i]));return this.geometryFactory.createGeometryCollection(n)}};e(se.prototype,{write:function(t){return this.parser.write(t)}}),e(se,{toLineString:function(t,e){if(2!==arguments.length)throw new Error("Not implemented");return"LINESTRING ( "+t.x+" "+t.y+", "+e.x+" "+e.y+" )"}}),e(oe.prototype,{getIndexAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intLineIndex[t][e]},getTopologySummary:function(){var t=new P;return this.isEndPoint()&&t.append(" endpoint"),this._isProper&&t.append(" proper"),this.isCollinear()&&t.append(" collinear"),t.toString()},computeIntersection:function(t,e,n,i){this.inputLines[0][0]=t,this.inputLines[0][1]=e,this.inputLines[1][0]=n,this.inputLines[1][1]=i,this.result=this.computeIntersect(t,e,n,i)},getIntersectionNum:function(){return this.result},computeIntLineIndex:function(){if(0===arguments.length)null===this.intLineIndex&&(this.intLineIndex=Array(2).fill().map(function(){return Array(2)}),this.computeIntLineIndex(0),this.computeIntLineIndex(1));else if(1===arguments.length){var t=arguments[0],e=this.getEdgeDistance(t,0),n=this.getEdgeDistance(t,1);e>n?(this.intLineIndex[t][0]=0,this.intLineIndex[t][1]=1):(this.intLineIndex[t][0]=1,this.intLineIndex[t][1]=0)}},isProper:function(){return this.hasIntersection()&&this._isProper},setPrecisionModel:function(t){this.precisionModel=t},isInteriorIntersection:function(){if(0===arguments.length)return this.isInteriorIntersection(0)?!0:!!this.isInteriorIntersection(1);if(1===arguments.length){for(var t=arguments[0],e=0;e<this.result;e++)if(!this.intPt[e].equals2D(this.inputLines[t][0])&&!this.intPt[e].equals2D(this.inputLines[t][1]))return!0;return!1}},getIntersection:function(t){return this.intPt[t]},isEndPoint:function(){return this.hasIntersection()&&!this._isProper},hasIntersection:function(){return this.result!==oe.NO_INTERSECTION},getEdgeDistance:function(t,e){var n=oe.computeEdgeDistance(this.intPt[e],this.inputLines[t][0],this.inputLines[t][1]);return n},isCollinear:function(){return this.result===oe.COLLINEAR_INTERSECTION},toString:function(){return se.toLineString(this.inputLines[0][0],this.inputLines[0][1])+" - "+se.toLineString(this.inputLines[1][0],this.inputLines[1][1])+this.getTopologySummary()},getEndpoint:function(t,e){return this.inputLines[t][e]},isIntersection:function(t){for(var e=0;e<this.result;e++)if(this.intPt[e].equals2D(t))return!0;return!1},getIntersectionAlongSegment:function(t,e){return this.computeIntLineIndex(),this.intPt[this.intLineIndex[t][e]]},interfaces_:function(){return[]},getClass:function(){return oe}}),oe.computeEdgeDistance=function(t,e,n){var i=Math.abs(n.x-e.x),r=Math.abs(n.y-e.y),s=-1;if(t.equals(e))s=0;else if(t.equals(n))s=i>r?i:r;else{var o=Math.abs(t.x-e.x),a=Math.abs(t.y-e.y);s=i>r?o:a,0!==s||t.equals(e)||(s=Math.max(o,a))}return f.isTrue(!(0===s&&!t.equals(e)),"Bad distance calculation"),s},oe.nonRobustComputeEdgeDistance=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=Math.sqrt(i*i+r*r);return f.isTrue(!(0===s&&!t.equals(e)),"Invalid distance calculation"),s},oe.DONT_INTERSECT=0,oe.DO_INTERSECT=1,oe.COLLINEAR=2,oe.NO_INTERSECTION=0,oe.POINT_INTERSECTION=1,oe.COLLINEAR_INTERSECTION=2,h(ae,oe),e(ae.prototype,{isInSegmentEnvelopes:function(t){var e=new C(this.inputLines[0][0],this.inputLines[0][1]),n=new C(this.inputLines[1][0],this.inputLines[1][1]);return e.contains(t)&&n.contains(t)},computeIntersection:function(){if(3!==arguments.length)return oe.prototype.computeIntersection.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2];return this._isProper=!1,C.intersects(e,n,t)&&0===he.orientationIndex(e,n,t)&&0===he.orientationIndex(n,e,t)?(this._isProper=!0,(t.equals(e)||t.equals(n))&&(this._isProper=!1),this.result=oe.POINT_INTERSECTION,null):void(this.result=oe.NO_INTERSECTION)},normalizeToMinimum:function(t,e,n,i,r){r.x=this.smallestInAbsValue(t.x,e.x,n.x,i.x),r.y=this.smallestInAbsValue(t.y,e.y,n.y,i.y),t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},safeHCoordinateIntersection:function(t,e,n,i){var r=null;try{r=F.intersection(t,e,n,i)}catch(s){if(!(s instanceof w))throw s;r=ae.nearestEndpoint(t,e,n,i)}finally{}return r},intersection:function(t,e,n,i){var r=this.intersectionWithNormalization(t,e,n,i);return this.isInSegmentEnvelopes(r)||(r=new g(ae.nearestEndpoint(t,e,n,i))),null!==this.precisionModel&&this.precisionModel.makePrecise(r),r},smallestInAbsValue:function(t,e,n,i){var r=t,s=Math.abs(r);return Math.abs(e)<s&&(r=e,s=Math.abs(e)),Math.abs(n)<s&&(r=n,s=Math.abs(n)),Math.abs(i)<s&&(r=i),r},checkDD:function(t,e,n,i,r){var s=M.intersection(t,e,n,i),o=this.isInSegmentEnvelopes(s);A.out.println("DD in env = "+o+"  --------------------- "+s),r.distance(s)>1e-4&&A.out.println("Distance = "+r.distance(s))},intersectionWithNormalization:function(t,e,n,i){var r=new g(t),s=new g(e),o=new g(n),a=new g(i),u=new g;this.normalizeToEnvCentre(r,s,o,a,u);var l=this.safeHCoordinateIntersection(r,s,o,a);return l.x+=u.x,l.y+=u.y,l},computeCollinearIntersection:function(t,e,n,i){var r=C.intersects(t,e,n),s=C.intersects(t,e,i),o=C.intersects(n,i,t),a=C.intersects(n,i,e);return r&&s?(this.intPt[0]=n,this.intPt[1]=i,oe.COLLINEAR_INTERSECTION):o&&a?(this.intPt[0]=t,this.intPt[1]=e,oe.COLLINEAR_INTERSECTION):r&&o?(this.intPt[0]=n,this.intPt[1]=t,!n.equals(t)||s||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):r&&a?(this.intPt[0]=n,this.intPt[1]=e,!n.equals(e)||s||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&o?(this.intPt[0]=i,this.intPt[1]=t,!i.equals(t)||r||a?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):s&&a?(this.intPt[0]=i,this.intPt[1]=e,!i.equals(e)||r||o?oe.COLLINEAR_INTERSECTION:oe.POINT_INTERSECTION):oe.NO_INTERSECTION},normalizeToEnvCentre:function(t,e,n,i,r){var s=t.x<e.x?t.x:e.x,o=t.y<e.y?t.y:e.y,a=t.x>e.x?t.x:e.x,u=t.y>e.y?t.y:e.y,l=n.x<i.x?n.x:i.x,h=n.y<i.y?n.y:i.y,c=n.x>i.x?n.x:i.x,f=n.y>i.y?n.y:i.y,g=s>l?s:l,d=c>a?a:c,p=o>h?o:h,v=f>u?u:f,m=(g+d)/2,y=(p+v)/2;r.x=m,r.y=y,t.x-=r.x,t.y-=r.y,e.x-=r.x,e.y-=r.y,n.x-=r.x,n.y-=r.y,i.x-=r.x,i.y-=r.y},computeIntersect:function(t,e,n,i){if(this._isProper=!1,!C.intersects(t,e,n,i))return oe.NO_INTERSECTION;var r=he.orientationIndex(t,e,n),s=he.orientationIndex(t,e,i);if(r>0&&s>0||0>r&&0>s)return oe.NO_INTERSECTION;var o=he.orientationIndex(n,i,t),a=he.orientationIndex(n,i,e);if(o>0&&a>0||0>o&&0>a)return oe.NO_INTERSECTION;var u=0===r&&0===s&&0===o&&0===a;return u?this.computeCollinearIntersection(t,e,n,i):(0===r||0===s||0===o||0===a?(this._isProper=!1,t.equals2D(n)||t.equals2D(i)?this.intPt[0]=t:e.equals2D(n)||e.equals2D(i)?this.intPt[0]=e:0===r?this.intPt[0]=new g(n):0===s?this.intPt[0]=new g(i):0===o?this.intPt[0]=new g(t):0===a&&(this.intPt[0]=new g(e))):(this._isProper=!0,this.intPt[0]=this.intersection(t,e,n,i)),oe.POINT_INTERSECTION)},interfaces_:function(){return[]},getClass:function(){return ae}}),ae.nearestEndpoint=function(t,e,n,i){var r=t,s=he.distancePointLine(t,n,i),o=he.distancePointLine(e,n,i);return s>o&&(s=o,r=e),o=he.distancePointLine(n,t,e),s>o&&(s=o,r=n),o=he.distancePointLine(i,t,e),s>o&&(s=o,r=i),r},e(ue.prototype,{interfaces_:function(){return[]},getClass:function(){return ue}}),ue.orientationIndex=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-e.x,o=n.y-e.y;return ue.signOfDet2x2(i,r,s,o)},ue.signOfDet2x2=function(t,e,n,i){var r=null,s=null,o=null,a=0;if(r=1,0===t||0===i)return 0===e||0===n?0:e>0?n>0?-r:r:n>0?r:-r;if(0===e||0===n)return i>0?t>0?r:-r:t>0?-r:r;if(e>0?i>0?i>=e||(r=-r,s=t,t=n,n=s,s=e,e=i,i=s):-i>=e?(r=-r,n=-n,i=-i):(s=t,t=-n,n=s,s=e,e=-i,i=s):i>0?i>=-e?(r=-r,t=-t,e=-e):(s=-t,t=n,n=s,s=-e,e=i,i=s):e>=i?(t=-t,e=-e,n=-n,i=-i):(r=-r,s=-t,t=-n,n=s,s=-e,e=-i,i=s),t>0){if(!(n>0))return r;if(!(n>=t))return r}else{if(n>0)return-r;if(!(t>=n))return-r;r=-r,t=-t,n=-n}for(;;){if(a+=1,o=Math.floor(n/t),n-=o*t,i-=o*e,0>i)return-r;if(i>e)return r;if(t>n+n){if(i+i>e)return r}else{if(e>i+i)return-r;n=t-n,i=e-i,r=-r}if(0===i)return 0===n?0:-r;if(0===n)return r;if(o=Math.floor(t/n),t-=o*n,e-=o*i,0>e)return r;if(e>i)return-r;if(n>t+t){if(e+e>i)return-r}else{if(i>e+e)return r;t=n-t,e=i-e,r=-r}if(0===e)return 0===t?0:r;if(0===t)return-r}},e(le.prototype,{countSegment:function(t,e){if(t.x<this.p.x&&e.x<this.p.x)return null;if(this.p.x===e.x&&this.p.y===e.y)return this.isPointOnSegment=!0,null;if(t.y===this.p.y&&e.y===this.p.y){var n=t.x,i=e.x;return n>i&&(n=e.x,i=t.x),this.p.x>=n&&this.p.x<=i&&(this.isPointOnSegment=!0),null}if(t.y>this.p.y&&e.y<=this.p.y||e.y>this.p.y&&t.y<=this.p.y){var r=t.x-this.p.x,s=t.y-this.p.y,o=e.x-this.p.x,a=e.y-this.p.y,u=ue.signOfDet2x2(r,s,o,a);if(0===u)return this.isPointOnSegment=!0,null;s>a&&(u=-u),u>0&&this.crossingCount++}},isPointInPolygon:function(){return this.getLocation()!==L.EXTERIOR},getLocation:function(){return this.isPointOnSegment?L.BOUNDARY:this.crossingCount%2===1?L.INTERIOR:L.EXTERIOR},isOnSegment:function(){return this.isPointOnSegment},interfaces_:function(){return[]},getClass:function(){return le}}),le.locatePointInRing=function(){if(arguments[0]instanceof g&&R(arguments[1],D)){for(var t=arguments[0],e=arguments[1],n=new le(t),i=new g,r=new g,s=1;s<e.size();s++)if(e.getCoordinate(s,i),e.getCoordinate(s-1,r),n.countSegment(i,r),n.isOnSegment())return n.getLocation();return n.getLocation()}if(arguments[0]instanceof g&&arguments[1]instanceof Array){for(var o=arguments[0],a=arguments[1],n=new le(o),s=1;s<a.length;s++){var i=a[s],r=a[s-1];if(n.countSegment(i,r),n.isOnSegment())return n.getLocation()}return n.getLocation()}},e(he.prototype,{interfaces_:function(){return[]},getClass:function(){return he}}),he.orientationIndex=function(t,e,n){return M.orientationIndex(t,e,n)},he.signedArea=function(){if(arguments[0]instanceof Array){var t=arguments[0];if(t.length<3)return 0;for(var e=0,n=t[0].x,i=1;i<t.length-1;i++){var r=t[i].x-n,s=t[i+1].y,o=t[i-1].y;e+=r*(o-s)}return e/2}if(R(arguments[0],D)){var a=arguments[0],u=a.size();if(3>u)return 0;var l=new g,h=new g,c=new g;a.getCoordinate(0,h),a.getCoordinate(1,c);var n=h.x;c.x-=n;for(var e=0,i=1;u-1>i;i++)l.y=h.y,h.x=c.x,h.y=c.y,a.getCoordinate(i+1,c),c.x-=n,e+=h.x*(l.y-c.y);return e/2}},he.distanceLineLine=function(t,e,n,i){if(t.equals(e))return he.distancePointLine(t,n,i);if(n.equals(i))return he.distancePointLine(i,t,e);var r=!1;if(C.intersects(t,e,n,i)){var s=(e.x-t.x)*(i.y-n.y)-(e.y-t.y)*(i.x-n.x);if(0===s)r=!0;else{var o=(t.y-n.y)*(i.x-n.x)-(t.x-n.x)*(i.y-n.y),a=(t.y-n.y)*(e.x-t.x)-(t.x-n.x)*(e.y-t.y),u=a/s,l=o/s;(0>l||l>1||0>u||u>1)&&(r=!0)}}else r=!0;return r?T.min(he.distancePointLine(t,n,i),he.distancePointLine(e,n,i),he.distancePointLine(n,t,e),he.distancePointLine(i,t,e)):0},he.isPointInRing=function(t,e){return he.locatePointInRing(t,e)!==L.EXTERIOR},he.computeLength=function(t){var e=t.size();if(1>=e)return 0;var n=0,i=new g;t.getCoordinate(0,i);for(var r=i.x,s=i.y,o=1;e>o;o++){t.getCoordinate(o,i);var a=i.x,u=i.y,l=a-r,h=u-s;n+=Math.sqrt(l*l+h*h),r=a,s=u}return n},he.isCCW=function(t){var e=t.length-1;if(3>e)throw new i("Ring has fewer than 4 points, so orientation cannot be determined");for(var n=t[0],r=0,s=1;e>=s;s++){var o=t[s];o.y>n.y&&(n=o,r=s)}var a=r;do a-=1,0>a&&(a=e);while(t[a].equals2D(n)&&a!==r);var u=r;do u=(u+1)%e;while(t[u].equals2D(n)&&u!==r);var l=t[a],h=t[u];if(l.equals2D(n)||h.equals2D(n)||l.equals2D(h))return!1;var c=he.computeOrientation(l,n,h),f=!1;return f=0===c?l.x>h.x:c>0},he.locatePointInRing=function(t,e){return le.locatePointInRing(t,e)},he.distancePointLinePerpendicular=function(t,e,n){var i=(n.x-e.x)*(n.x-e.x)+(n.y-e.y)*(n.y-e.y),r=((e.y-t.y)*(n.x-e.x)-(e.x-t.x)*(n.y-e.y))/i;return Math.abs(r)*Math.sqrt(i)},he.computeOrientation=function(t,e,n){return he.orientationIndex(t,e,n)},he.distancePointLine=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];if(0===e.length)throw new i("Line array must contain at least one vertex");for(var n=t.distance(e[0]),r=0;r<e.length-1;r++){var s=he.distancePointLine(t,e[r],e[r+1]);n>s&&(n=s)}return n}if(3===arguments.length){var o=arguments[0],a=arguments[1],u=arguments[2];if(a.x===u.x&&a.y===u.y)return o.distance(a);var l=(u.x-a.x)*(u.x-a.x)+(u.y-a.y)*(u.y-a.y),h=((o.x-a.x)*(u.x-a.x)+(o.y-a.y)*(u.y-a.y))/l;if(0>=h)return o.distance(a);if(h>=1)return o.distance(u);var c=((a.y-o.y)*(u.x-a.x)-(a.x-o.x)*(u.y-a.y))/l;return Math.abs(c)*Math.sqrt(l)}},he.isOnLine=function(t,e){for(var n=new ae,i=1;i<e.length;i++){var r=e[i-1],s=e[i];if(n.computeIntersection(t,r,s),n.hasIntersection())return!0}return!1},he.CLOCKWISE=-1,he.RIGHT=he.CLOCKWISE,he.COUNTERCLOCKWISE=1,he.LEFT=he.COUNTERCLOCKWISE,he.COLLINEAR=0,he.STRAIGHT=he.COLLINEAR,e(ce.prototype,{minX:function(){return Math.min(this.p0.x,this.p1.x)},orientationIndex:function(){if(arguments[0]instanceof ce){var t=arguments[0],e=he.orientationIndex(this.p0,this.p1,t.p0),n=he.orientationIndex(this.p0,this.p1,t.p1);return e>=0&&n>=0?Math.max(e,n):0>=e&&0>=n?Math.max(e,n):0}if(arguments[0]instanceof g){var i=arguments[0];return he.orientationIndex(this.p0,this.p1,i)}},toGeometry:function(t){return t.createLineString([this.p0,this.p1])},isVertical:function(){return this.p0.x===this.p1.x},equals:function(t){if(!(t instanceof ce))return!1;var e=t;return this.p0.equals(e.p0)&&this.p1.equals(e.p1)},intersection:function(t){var e=new ae;return e.computeIntersection(this.p0,this.p1,t.p0,t.p1),e.hasIntersection()?e.getIntersection(0):null},project:function(){if(arguments[0]instanceof g){var t=arguments[0];if(t.equals(this.p0)||t.equals(this.p1))return new g(t);var e=this.projectionFactor(t),n=new g;return n.x=this.p0.x+e*(this.p1.x-this.p0.x),n.y=this.p0.y+e*(this.p1.y-this.p0.y),n}if(arguments[0]instanceof ce){var i=arguments[0],r=this.projectionFactor(i.p0),s=this.projectionFactor(i.p1);if(r>=1&&s>=1)return null;if(0>=r&&0>=s)return null;var o=this.project(i.p0);0>r&&(o=this.p0),r>1&&(o=this.p1);var a=this.project(i.p1);return 0>s&&(a=this.p0),s>1&&(a=this.p1),new ce(o,a)}},normalize:function(){this.p1.compareTo(this.p0)<0&&this.reverse()},angle:function(){return Math.atan2(this.p1.y-this.p0.y,this.p1.x-this.p0.x)},getCoordinate:function(t){return 0===t?this.p0:this.p1},distancePerpendicular:function(t){return he.distancePointLinePerpendicular(t,this.p0,this.p1)},minY:function(){return Math.min(this.p0.y,this.p1.y)},midPoint:function(){return ce.midPoint(this.p0,this.p1)},projectionFactor:function(t){if(t.equals(this.p0))return 0;if(t.equals(this.p1))return 1;var e=this.p1.x-this.p0.x,n=this.p1.y-this.p0.y,i=e*e+n*n;if(0>=i)return r.NaN;var s=((t.x-this.p0.x)*e+(t.y-this.p0.y)*n)/i;return s},closestPoints:function(t){var e=this.intersection(t);if(null!==e)return[e,e];var n=new Array(2).fill(null),i=r.MAX_VALUE,s=null,o=this.closestPoint(t.p0);i=o.distance(t.p0),n[0]=o,n[1]=t.p0;var a=this.closestPoint(t.p1);s=a.distance(t.p1),i>s&&(i=s,n[0]=a,n[1]=t.p1);var u=t.closestPoint(this.p0);s=u.distance(this.p0),i>s&&(i=s,n[0]=this.p0,n[1]=u);var l=t.closestPoint(this.p1);return s=l.distance(this.p1),i>s&&(i=s,n[0]=this.p1,n[1]=l),n},closestPoint:function(t){var e=this.projectionFactor(t);if(e>0&&1>e)return this.project(t);var n=this.p0.distance(t),i=this.p1.distance(t);return i>n?this.p0:this.p1},maxX:function(){return Math.max(this.p0.x,this.p1.x)},getLength:function(){return this.p0.distance(this.p1)},compareTo:function(t){var e=t,n=this.p0.compareTo(e.p0);return 0!==n?n:this.p1.compareTo(e.p1)},reverse:function(){var t=this.p0;this.p0=this.p1,this.p1=t},equalsTopo:function(t){return this.p0.equals(t.p0)&&this.p1.equals(t.p1)||this.p0.equals(t.p1)&&this.p1.equals(t.p0)},lineIntersection:function(t){try{var e=F.intersection(this.p0,this.p1,t.p0,t.p1);return e}catch(t){if(!(t instanceof w))throw t}finally{}return null},maxY:function(){return Math.max(this.p0.y,this.p1.y)},pointAlongOffset:function(t,e){var n=this.p0.x+t*(this.p1.x-this.p0.x),i=this.p0.y+t*(this.p1.y-this.p0.y),r=this.p1.x-this.p0.x,s=this.p1.y-this.p0.y,o=Math.sqrt(r*r+s*s),a=0,u=0;if(0!==e){if(0>=o)throw new IllegalStateException("Cannot compute offset from zero-length line segment");a=e*r/o,u=e*s/o}var l=n-u,h=i+a,c=new g(l,h);return c},setCoordinates:function(){if(1===arguments.length){var t=arguments[0];this.setCoordinates(t.p0,t.p1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.p0.x=e.x,this.p0.y=e.y,this.p1.x=n.x,this.p1.y=n.y}},segmentFraction:function(t){var e=this.projectionFactor(t);return 0>e?e=0:(e>1||r.isNaN(e))&&(e=1),e},toString:function(){return"LINESTRING( "+this.p0.x+" "+this.p0.y+", "+this.p1.x+" "+this.p1.y+")"},isHorizontal:function(){return this.p0.y===this.p1.y},distance:function(){if(arguments[0]instanceof ce){var t=arguments[0];return he.distanceLineLine(this.p0,this.p1,t.p0,t.p1)}if(arguments[0]instanceof g){var e=arguments[0];return he.distancePointLine(e,this.p0,this.p1)}},pointAlong:function(t){var e=new g;return e.x=this.p0.x+t*(this.p1.x-this.p0.x),e.y=this.p0.y+t*(this.p1.y-this.p0.y),e},hashCode:function(){var t=java.lang.Double.doubleToLongBits(this.p0.x);t^=31*java.lang.Double.doubleToLongBits(this.p0.y);var e=Math.trunc(t)^Math.trunc(t>>32),n=java.lang.Double.doubleToLongBits(this.p1.x);n^=31*java.lang.Double.doubleToLongBits(this.p1.y);var i=Math.trunc(n)^Math.trunc(n>>32);return e^i},interfaces_:function(){return[s,u]},getClass:function(){return ce}}),ce.midPoint=function(t,e){return new g((t.x+e.x)/2,(t.y+e.y)/2)},ce.serialVersionUID=0x2d2172135f411c00,e(fe.prototype,{isIntersects:function(){return!this.isDisjoint()},isCovers:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},isCoveredBy:function(){var t=fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])||fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY]);return t&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},set:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.matrix[n][i]=lt.toDimensionValue(t.charAt(e))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]=o}},isContains:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},setAtLeast:function(){if(1===arguments.length)for(var t=arguments[0],e=0;e<t.length;e++){var n=Math.trunc(e/3),i=e%3;this.setAtLeast(n,i,lt.toDimensionValue(t.charAt(e)))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];this.matrix[r][s]<o&&(this.matrix[r][s]=o)}},setAtLeastIfValid:function(t,e,n){t>=0&&e>=0&&this.setAtLeast(t,e,n)},isWithin:function(){return fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE},isTouches:function(t,e){return t>e?this.isTouches(e,t):t===lt.A&&e===lt.A||t===lt.L&&e===lt.L||t===lt.L&&e===lt.A||t===lt.P&&e===lt.A||t===lt.P&&e===lt.L?this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&(fe.isTrue(this.matrix[L.INTERIOR][L.BOUNDARY])||fe.isTrue(this.matrix[L.BOUNDARY][L.INTERIOR])||fe.isTrue(this.matrix[L.BOUNDARY][L.BOUNDARY])):!1},isOverlaps:function(t,e){return t===lt.P&&e===lt.P||t===lt.A&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?1===this.matrix[L.INTERIOR][L.INTERIOR]&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):!1},isEquals:function(t,e){return t!==e?!1:fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&this.matrix[L.INTERIOR][L.EXTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.EXTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.EXTERIOR][L.BOUNDARY]===lt.FALSE},toString:function(){for(var t=new P("123456789"),e=0;3>e;e++)for(var n=0;3>n;n++)t.setCharAt(3*e+n,lt.toDimensionSymbol(this.matrix[e][n]));return t.toString()},setAll:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.matrix[e][n]=t},get:function(t,e){return this.matrix[t][e]},transpose:function(){var t=this.matrix[1][0];return this.matrix[1][0]=this.matrix[0][1],this.matrix[0][1]=t,t=this.matrix[2][0],this.matrix[2][0]=this.matrix[0][2],this.matrix[0][2]=t,t=this.matrix[2][1],this.matrix[2][1]=this.matrix[1][2],this.matrix[1][2]=t,this},matches:function(t){if(9!==t.length)throw new i("Should be length 9: "+t);for(var e=0;3>e;e++)for(var n=0;3>n;n++)if(!fe.matches(this.matrix[e][n],t.charAt(3*e+n)))return!1;return!0},add:function(t){for(var e=0;3>e;e++)for(var n=0;3>n;n++)this.setAtLeast(e,n,t.get(e,n))},isDisjoint:function(){return this.matrix[L.INTERIOR][L.INTERIOR]===lt.FALSE&&this.matrix[L.INTERIOR][L.BOUNDARY]===lt.FALSE&&this.matrix[L.BOUNDARY][L.INTERIOR]===lt.FALSE&&this.matrix[L.BOUNDARY][L.BOUNDARY]===lt.FALSE},isCrosses:function(t,e){return t===lt.P&&e===lt.L||t===lt.P&&e===lt.A||t===lt.L&&e===lt.A?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.INTERIOR][L.EXTERIOR]):t===lt.L&&e===lt.P||t===lt.A&&e===lt.P||t===lt.A&&e===lt.L?fe.isTrue(this.matrix[L.INTERIOR][L.INTERIOR])&&fe.isTrue(this.matrix[L.EXTERIOR][L.INTERIOR]):t===lt.L&&e===lt.L?0===this.matrix[L.INTERIOR][L.INTERIOR]:!1},interfaces_:function(){return[o]},getClass:function(){return fe}}),fe.matches=function(){if(Number.isInteger(arguments[0])&&"string"==typeof arguments[1]){var t=arguments[0],e=arguments[1];return e===lt.SYM_DONTCARE?!0:e===lt.SYM_TRUE&&(t>=0||t===lt.TRUE)?!0:e===lt.SYM_FALSE&&t===lt.FALSE?!0:e===lt.SYM_P&&t===lt.P?!0:e===lt.SYM_L&&t===lt.L?!0:e===lt.SYM_A&&t===lt.A}if("string"==typeof arguments[0]&&"string"==typeof arguments[1]){var n=arguments[0],i=arguments[1],r=new fe(n);return r.matches(i)}},fe.isTrue=function(t){return t>=0||t===lt.TRUE};var lo=Object.freeze({Coordinate:g,CoordinateList:N,Envelope:C,LineSegment:ce,GeometryFactory:ie,Geometry:B,Point:Lt,LineString:St,LinearRing:bt,Polygon:Tt,GeometryCollection:ft,MultiPoint:Pt,MultiLineString:gt,MultiPolygon:Ot,Dimension:lt,IntersectionMatrix:fe});e(ge.prototype,{addPoint:function(t){this.ptCount+=1,this.ptCentSum.x+=t.x,this.ptCentSum.y+=t.y},setBasePoint:function(t){null===this.areaBasePt&&(this.areaBasePt=t)},addLineSegments:function(t){for(var e=0,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);if(0!==i){e+=i;var r=(t[n].x+t[n+1].x)/2;this.lineCentSum.x+=i*r;var s=(t[n].y+t[n+1].y)/2;this.lineCentSum.y+=i*s}}this.totalLength+=e,0===e&&t.length>0&&this.addPoint(t[0])},addHole:function(t){for(var e=he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},getCentroid:function(){var t=new g;if(Math.abs(this.areasum2)>0)t.x=this.cg3.x/3/this.areasum2,t.y=this.cg3.y/3/this.areasum2;else if(this.totalLength>0)t.x=this.lineCentSum.x/this.totalLength,t.y=this.lineCentSum.y/this.totalLength;else{if(!(this.ptCount>0))return null;t.x=this.ptCentSum.x/this.ptCount,t.y=this.ptCentSum.y/this.ptCount}return t},addShell:function(t){t.length>0&&this.setBasePoint(t[0]);for(var e=!he.isCCW(t),n=0;n<t.length-1;n++)this.addTriangle(this.areaBasePt,t[n],t[n+1],e);this.addLineSegments(t)},addTriangle:function(t,e,n,i){var r=i?1:-1;ge.centroid3(t,e,n,this.triangleCent3);var s=ge.area2(t,e,n);this.cg3.x+=r*s*this.triangleCent3.x,this.cg3.y+=r*s*this.triangleCent3.y,this.areasum2+=r*s},add:function(){if(arguments[0]instanceof Tt){var t=arguments[0];this.addShell(t.getExteriorRing().getCoordinates());for(var e=0;e<t.getNumInteriorRing();e++)this.addHole(t.getInteriorRingN(e).getCoordinates())}else if(arguments[0]instanceof B){var n=arguments[0];if(n.isEmpty())return null;if(n instanceof Lt)this.addPoint(n.getCoordinate());else if(n instanceof St)this.addLineSegments(n.getCoordinates());else if(n instanceof Tt){var i=n;this.add(i)}else if(n instanceof ft)for(var r=n,e=0;e<r.getNumGeometries();e++)this.add(r.getGeometryN(e))}},interfaces_:function(){return[]},getClass:function(){return ge}}),ge.area2=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(n.x-t.x)*(e.y-t.y)},ge.centroid3=function(t,e,n,i){return i.x=t.x+e.x+n.x,i.y=t.y+e.y+n.y,null},ge.getCentroid=function(t){var e=new ge(t);return e.getCentroid()},de.prototype=new Error,de.prototype.name="EmptyStackException",pe.prototype=new y,pe.prototype.add=function(t){return this.array_.push(t),!0},pe.prototype.get=function(t){if(0>t||t>=this.size())throw new IndexOutOfBoundsException;return this.array_[t]},pe.prototype.push=function(t){return this.array_.push(t),t},pe.prototype.pop=function(t){if(0===this.array_.length)throw new de;return this.array_.pop()},pe.prototype.peek=function(){if(0===this.array_.length)throw new de;return this.array_[this.array_.length-1]},pe.prototype.empty=function(){return 0===this.array_.length},pe.prototype.isEmpty=function(){return this.empty()},pe.prototype.search=function(t){return this.array_.indexOf(t)},pe.prototype.size=function(){return this.array_.length},pe.prototype.toArray=function(){for(var t=[],e=0,n=this.array_.length;n>e;e++)t.push(this.array_[e]);return t},e(ve.prototype,{filter:function(t){this.treeSet.contains(t)||(this.list.add(t),this.treeSet.add(t))},getCoordinates:function(){var t=new Array(this.list.size()).fill(null);return this.list.toArray(t)},interfaces_:function(){return[z]},getClass:function(){return ve}}),ve.filterCoordinates=function(t){for(var e=new ve,n=0;n<t.length;n++)e.filter(t[n]);return e.getCoordinates()},e(me.prototype,{preSort:function(t){for(var e=null,n=1;n<t.length;n++)(t[n].y<t[0].y||t[n].y===t[0].y&&t[n].x<t[0].x)&&(e=t[0],t[0]=t[n],t[n]=e);return ut.sort(t,1,t.length,new ye(t[0])),t},computeOctRing:function(t){var e=this.computeOctPts(t),n=new N;return n.add(e,!1),n.size()<3?null:(n.closeRing(),n.toCoordinateArray())},lineOrPolygon:function(t){if(t=this.cleanRing(t),3===t.length)return this.geomFactory.createLineString([t[0],t[1]]);var e=this.geomFactory.createLinearRing(t);return this.geomFactory.createPolygon(e,null)},cleanRing:function(t){f.equals(t[0],t[t.length-1]);for(var e=new I,n=null,i=0;i<=t.length-2;i++){var r=t[i],s=t[i+1];r.equals(s)||null!==n&&this.isBetween(n,r,s)||(e.add(r),n=r)}e.add(t[t.length-1]);var o=new Array(e.size()).fill(null);return e.toArray(o)},isBetween:function(t,e,n){if(0!==he.computeOrientation(t,e,n))return!1;if(t.x!==n.x){if(t.x<=e.x&&e.x<=n.x)return!0;if(n.x<=e.x&&e.x<=t.x)return!0}if(t.y!==n.y){if(t.y<=e.y&&e.y<=n.y)return!0;if(n.y<=e.y&&e.y<=t.y)return!0}return!1},reduce:function(t){var e=this.computeOctRing(t);if(null===e)return t;for(var n=new at,i=0;i<e.length;i++)n.add(e[i]);for(var i=0;i<t.length;i++)he.isPointInRing(t[i],e)||n.add(t[i]);var r=H.toCoordinateArray(n);return r.length<3?this.padArray3(r):r},getConvexHull:function(){if(0===this.inputPts.length)return this.geomFactory.createGeometryCollection(null);if(1===this.inputPts.length)return this.geomFactory.createPoint(this.inputPts[0]);if(2===this.inputPts.length)return this.geomFactory.createLineString(this.inputPts);var t=this.inputPts;this.inputPts.length>50&&(t=this.reduce(this.inputPts));var e=this.preSort(t),n=this.grahamScan(e),i=this.toCoordinateArray(n);return this.lineOrPolygon(i)},padArray3:function(t){for(var e=new Array(3).fill(null),n=0;n<e.length;n++)n<t.length?e[n]=t[n]:e[n]=t[0];return e},computeOctPts:function(t){for(var e=new Array(8).fill(null),n=0;n<e.length;n++)e[n]=t[0];for(var i=1;i<t.length;i++)t[i].x<e[0].x&&(e[0]=t[i]),t[i].x-t[i].y<e[1].x-e[1].y&&(e[1]=t[i]),t[i].y>e[2].y&&(e[2]=t[i]),t[i].x+t[i].y>e[3].x+e[3].y&&(e[3]=t[i]),t[i].x>e[4].x&&(e[4]=t[i]),t[i].x-t[i].y>e[5].x-e[5].y&&(e[5]=t[i]),t[i].y<e[6].y&&(e[6]=t[i]),t[i].x+t[i].y<e[7].x+e[7].y&&(e[7]=t[i]);return e},toCoordinateArray:function(t){for(var e=new Array(t.size()).fill(null),n=0;n<t.size();n++){var i=t.get(n);e[n]=i}return e},grahamScan:function(t){var e=null,n=new pe;e=n.push(t[0]),e=n.push(t[1]),e=n.push(t[2]);for(var i=3;i<t.length;i++){for(e=n.pop();!n.empty()&&he.computeOrientation(n.peek(),e,t[i])>0;)e=n.pop();e=n.push(e),e=n.push(t[i])}return e=n.push(t[0]),n},interfaces_:function(){return[]},getClass:function(){return me}}),me.extractCoordinates=function(t){var e=new ve;return t.apply(e),e.getCoordinates()},e(ye.prototype,{compare:function(t,e){var n=t,i=e;return ye.polarCompare(this.origin,n,i)},interfaces_:function(){return[a]},getClass:function(){return ye}}),ye.polarCompare=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=n.x-t.x,o=n.y-t.y,a=he.computeOrientation(t,e,n);
if(a===he.COUNTERCLOCKWISE)return 1;if(a===he.CLOCKWISE)return-1;var u=i*i+r*r,l=s*s+o*o;return l>u?-1:u>l?1:0},me.RadialComparator=ye,e(xe.prototype,{transformPoint:function(t,e){return this.factory.createPoint(this.transformCoordinates(t.getCoordinateSequence(),t))},transformPolygon:function(t,e){var n=!0,i=this.transformLinearRing(t.getExteriorRing(),t);null!==i&&i instanceof bt&&!i.isEmpty()||(n=!1);for(var r=new I,s=0;s<t.getNumInteriorRing();s++){var o=this.transformLinearRing(t.getInteriorRingN(s),t);null===o||o.isEmpty()||(o instanceof bt||(n=!1),r.add(o))}if(n)return this.factory.createPolygon(i,r.toArray([]));var a=new I;return null!==i&&a.add(i),a.addAll(r),this.factory.buildGeometry(a)},createCoordinateSequence:function(t){return this.factory.getCoordinateSequenceFactory().create(t)},getInputGeometry:function(){return this.inputGeom},transformMultiLineString:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformLineString(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformCoordinates:function(t,e){return this.copy(t)},transformLineString:function(t,e){return this.factory.createLineString(this.transformCoordinates(t.getCoordinateSequence(),t))},transformMultiPoint:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPoint(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},transformMultiPolygon:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transformPolygon(t.getGeometryN(i),t);null!==r&&(r.isEmpty()||n.add(r))}return this.factory.buildGeometry(n)},copy:function(t){return t.copy()},transformGeometryCollection:function(t,e){for(var n=new I,i=0;i<t.getNumGeometries();i++){var r=this.transform(t.getGeometryN(i));null!==r&&(this.pruneEmptyGeometry&&r.isEmpty()||n.add(r))}return this.preserveGeometryCollectionType?this.factory.createGeometryCollection(ie.toGeometryArray(n)):this.factory.buildGeometry(n)},transform:function(t){if(this.inputGeom=t,this.factory=t.getFactory(),t instanceof Lt)return this.transformPoint(t,null);if(t instanceof Pt)return this.transformMultiPoint(t,null);if(t instanceof bt)return this.transformLinearRing(t,null);if(t instanceof St)return this.transformLineString(t,null);if(t instanceof gt)return this.transformMultiLineString(t,null);if(t instanceof Tt)return this.transformPolygon(t,null);if(t instanceof Ot)return this.transformMultiPolygon(t,null);if(t instanceof ft)return this.transformGeometryCollection(t,null);throw new i("Unknown Geometry subtype: "+t.getClass().getName())},transformLinearRing:function(t,e){var n=this.transformCoordinates(t.getCoordinateSequence(),t);if(null===n)return this.factory.createLinearRing(null);var i=n.size();return i>0&&4>i&&!this.preserveType?this.factory.createLineString(n):this.factory.createLinearRing(n)},interfaces_:function(){return[]},getClass:function(){return xe}}),e(Ee.prototype,{snapVertices:function(t,e){for(var n=this._isClosed?t.size()-1:t.size(),i=0;n>i;i++){var r=t.get(i),s=this.findSnapForVertex(r,e);null!==s&&(t.set(i,new g(s)),0===i&&this._isClosed&&t.set(t.size()-1,new g(s)))}},findSnapForVertex:function(t,e){for(var n=0;n<e.length;n++){if(t.equals2D(e[n]))return null;if(t.distance(e[n])<this.snapTolerance)return e[n]}return null},snapTo:function(t){var e=new N(this.srcPts);this.snapVertices(e,t),this.snapSegments(e,t);var n=e.toCoordinateArray();return n},snapSegments:function(t,e){if(0===e.length)return null;var n=e.length;e[0].equals2D(e[e.length-1])&&(n=e.length-1);for(var i=0;n>i;i++){var r=e[i],s=this.findSegmentIndexToSnap(r,t);s>=0&&t.add(s+1,new g(r),!1)}},findSegmentIndexToSnap:function(t,e){for(var n=r.MAX_VALUE,i=-1,s=0;s<e.size()-1;s++){if(this.seg.p0=e.get(s),this.seg.p1=e.get(s+1),this.seg.p0.equals2D(t)||this.seg.p1.equals2D(t)){if(this.allowSnappingToSourceVertices)continue;return-1}var o=this.seg.distance(t);o<this.snapTolerance&&n>o&&(n=o,i=s)}return i},setAllowSnappingToSourceVertices:function(t){this.allowSnappingToSourceVertices=t},interfaces_:function(){return[]},getClass:function(){return Ee}}),Ee.isClosed=function(t){return t.length<=1?!1:t[0].equals2D(t[t.length-1])},e(Ie.prototype,{snapTo:function(t,e){var n=this.extractTargetCoordinates(t),i=new Ne(e,n);return i.transform(this.srcGeom)},snapToSelf:function(t,e){var n=this.extractTargetCoordinates(this.srcGeom),i=new Ne(t,n,!0),r=i.transform(this.srcGeom),s=r;return e&&R(s,Rt)&&(s=r.buffer(0)),s},computeSnapTolerance:function(t){var e=this.computeMinimumSegmentLength(t),n=e/10;return n},extractTargetCoordinates:function(t){for(var e=new at,n=t.getCoordinates(),i=0;i<n.length;i++)e.add(n[i]);return e.toArray(new Array(0).fill(null))},computeMinimumSegmentLength:function(t){for(var e=r.MAX_VALUE,n=0;n<t.length-1;n++){var i=t[n].distance(t[n+1]);e>i&&(e=i)}return e},interfaces_:function(){return[]},getClass:function(){return Ie}}),Ie.snap=function(t,e,n){var i=new Array(2).fill(null),r=new Ie(t);i[0]=r.snapTo(e,n);var s=new Ie(e);return i[1]=s.snapTo(i[0],n),i},Ie.computeOverlaySnapTolerance=function(){if(1===arguments.length){var t=arguments[0],e=Ie.computeSizeBasedSnapTolerance(t),n=t.getPrecisionModel();if(n.getType()===ee.FIXED){var i=1/n.getScale()*2/1.415;i>e&&(e=i)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1];return Math.min(Ie.computeOverlaySnapTolerance(r),Ie.computeOverlaySnapTolerance(s))}},Ie.computeSizeBasedSnapTolerance=function(t){var e=t.getEnvelopeInternal(),n=Math.min(e.getHeight(),e.getWidth()),i=n*Ie.SNAP_PRECISION_FACTOR;return i},Ie.snapToSelf=function(t,e,n){var i=new Ie(t);return i.snapToSelf(e,n)},Ie.SNAP_PRECISION_FACTOR=1e-9,h(Ne,xe),e(Ne.prototype,{snapLine:function(t,e){var n=new Ee(t,this.snapTolerance);return n.setAllowSnappingToSourceVertices(this.isSelfSnap),n.snapTo(e)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=this.snapLine(n,this.snapPts);return this.factory.getCoordinateSequenceFactory().create(i)},interfaces_:function(){return[]},getClass:function(){return Ne}}),e(Ce.prototype,{getCommon:function(){return r.longBitsToDouble(this.commonBits)},add:function(t){var e=r.doubleToLongBits(t);if(this.isFirst)return this.commonBits=e,this.commonSignExp=Ce.signExpBits(this.commonBits),this.isFirst=!1,null;var n=Ce.signExpBits(e);return n!==this.commonSignExp?(this.commonBits=0,null):(this.commonMantissaBitsCount=Ce.numCommonMostSigMantissaBits(this.commonBits,e),void(this.commonBits=Ce.zeroLowerBits(this.commonBits,64-(12+this.commonMantissaBitsCount))))},toString:function(){if(1===arguments.length){var t=arguments[0],e=r.longBitsToDouble(t),n=Long.toBinaryString(t),i="0000000000000000000000000000000000000000000000000000000000000000"+n,s=i.substring(i.length-64),o=s.substring(0,1)+"  "+s.substring(1,12)+"(exp) "+s.substring(12)+" [ "+e+" ]";return o}},interfaces_:function(){return[]},getClass:function(){return Ce}}),Ce.getBit=function(t,e){var n=1<<e;return 0!==(t&n)?1:0},Ce.signExpBits=function(t){return t>>52},Ce.zeroLowerBits=function(t,e){var n=(1<<e)-1,i=~n,r=t&i;return r},Ce.numCommonMostSigMantissaBits=function(t,e){for(var n=0,i=52;i>=0;i--){if(Ce.getBit(t,i)!==Ce.getBit(e,i))return n;n++}return 52},e(Se.prototype,{addCommonBits:function(t){var e=new Le(this.commonCoord);t.apply(e),t.geometryChanged()},removeCommonBits:function(t){if(0===this.commonCoord.x&&0===this.commonCoord.y)return t;var e=new g(this.commonCoord);e.x=-e.x,e.y=-e.y;var n=new Le(e);return t.apply(n),t.geometryChanged(),t},getCommonCoordinate:function(){return this.commonCoord},add:function(t){t.apply(this.ccFilter),this.commonCoord=this.ccFilter.getCommonCoordinate()},interfaces_:function(){return[]},getClass:function(){return Se}}),e(we.prototype,{filter:function(t){this.commonBitsX.add(t.x),this.commonBitsY.add(t.y)},getCommonCoordinate:function(){return new g(this.commonBitsX.getCommon(),this.commonBitsY.getCommon())},interfaces_:function(){return[z]},getClass:function(){return we}}),e(Le.prototype,{filter:function(t,e){var n=t.getOrdinate(e,0)+this.trans.x,i=t.getOrdinate(e,1)+this.trans.y;t.setOrdinate(e,0,n),t.setOrdinate(e,1,i)},isDone:function(){return!1},isGeometryChanged:function(){return!0},interfaces_:function(){return[ct]},getClass:function(){return Le}}),Se.CommonCoordinateFilter=we,Se.Translater=Le,e(Re.prototype,{next:function(){if(this.atStart)return this.atStart=!1,Re.isAtomic(this.parent)&&this.index++,this.parent;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return this.subcollectionIterator.next();this.subcollectionIterator=null}if(this.index>=this.max)throw new x;var t=this.parent.getGeometryN(this.index++);return t instanceof ft?(this.subcollectionIterator=new Re(t),this.subcollectionIterator.next()):t},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){if(this.atStart)return!0;if(null!==this.subcollectionIterator){if(this.subcollectionIterator.hasNext())return!0;this.subcollectionIterator=null}return!(this.index>=this.max)},interfaces_:function(){return[p]},getClass:function(){return Re}}),Re.isAtomic=function(t){return!(t instanceof ft)},e(Te.prototype,{locateInternal:function(){if(arguments[0]instanceof g&&arguments[1]instanceof Tt){var t=arguments[0],e=arguments[1];if(e.isEmpty())return L.EXTERIOR;var n=e.getExteriorRing(),i=this.locateInPolygonRing(t,n);if(i===L.EXTERIOR)return L.EXTERIOR;if(i===L.BOUNDARY)return L.BOUNDARY;for(var r=0;r<e.getNumInteriorRing();r++){var s=e.getInteriorRingN(r),o=this.locateInPolygonRing(t,s);if(o===L.INTERIOR)return L.EXTERIOR;if(o===L.BOUNDARY)return L.BOUNDARY}return L.INTERIOR}if(arguments[0]instanceof g&&arguments[1]instanceof St){var a=arguments[0],u=arguments[1];if(!u.getEnvelopeInternal().intersects(a))return L.EXTERIOR;var l=u.getCoordinates();return u.isClosed()||!a.equals(l[0])&&!a.equals(l[l.length-1])?he.isOnLine(a,l)?L.INTERIOR:L.EXTERIOR:L.BOUNDARY}if(arguments[0]instanceof g&&arguments[1]instanceof Lt){var h=arguments[0],c=arguments[1],f=c.getCoordinate();return f.equals2D(h)?L.INTERIOR:L.EXTERIOR}},locateInPolygonRing:function(t,e){return e.getEnvelopeInternal().intersects(t)?he.locatePointInRing(t,e.getCoordinates()):L.EXTERIOR},intersects:function(t,e){return this.locate(t,e)!==L.EXTERIOR},updateLocationInfo:function(t){t===L.INTERIOR&&(this.isIn=!0),t===L.BOUNDARY&&this.numBoundaries++},computeLocation:function(t,e){if(e instanceof Lt&&this.updateLocationInfo(this.locateInternal(t,e)),e instanceof St)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof Tt)this.updateLocationInfo(this.locateInternal(t,e));else if(e instanceof gt)for(var n=e,i=0;i<n.getNumGeometries();i++){var r=n.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,r))}else if(e instanceof Ot)for(var s=e,i=0;i<s.getNumGeometries();i++){var o=s.getGeometryN(i);this.updateLocationInfo(this.locateInternal(t,o))}else if(e instanceof ft)for(var a=new Re(e);a.hasNext();){var u=a.next();u!==e&&this.computeLocation(t,u)}},locate:function(t,e){return e.isEmpty()?L.EXTERIOR:e instanceof St?this.locateInternal(t,e):e instanceof Tt?this.locateInternal(t,e):(this.isIn=!1,this.numBoundaries=0,this.computeLocation(t,e),this.boundaryRule.isInBoundary(this.numBoundaries)?L.BOUNDARY:this.numBoundaries>0||this.isIn?L.INTERIOR:L.EXTERIOR)},interfaces_:function(){return[]},getClass:function(){return Te}}),e(Pe.prototype,{interfaces_:function(){return[]},getClass:function(){return Pe}}),Pe.octant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the octant for point ( "+t+", "+e+" )");var n=Math.abs(t),r=Math.abs(e);return t>=0?e>=0?n>=r?0:1:n>=r?7:6:e>=0?n>=r?3:2:n>=r?4:5}if(arguments[0]instanceof g&&arguments[1]instanceof g){var s=arguments[0],o=arguments[1],a=o.x-s.x,u=o.y-s.y;if(0===a&&0===u)throw new i("Cannot compute the octant for two identical points "+s);return Pe.octant(a,u)}},e(be.prototype,{getCoordinates:function(){},size:function(){},getCoordinate:function(t){},isClosed:function(){},setData:function(t){},getData:function(){},interfaces_:function(){return[]},getClass:function(){return be}}),e(Oe.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:Pe.octant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},getData:function(){return this.data},toString:function(){return se.toLineString(new Gt(this.pts))},interfaces_:function(){return[be]},getClass:function(){return Oe}}),e(_e.prototype,{getBounds:function(){},interfaces_:function(){return[]},getClass:function(){return _e}}),e(Me.prototype,{getItem:function(){return this.item},getBounds:function(){return this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Me}}),e(De.prototype,{poll:function(){if(this.isEmpty())return null;var t=this.items.get(1);return this.items.set(1,this.items.get(this._size)),this._size-=1,this.reorder(1),t},size:function(){return this._size},reorder:function(t){for(var e=null,n=this.items.get(t);2*t<=this._size&&(e=2*t,e!==this._size&&this.items.get(e+1).compareTo(this.items.get(e))<0&&e++,this.items.get(e).compareTo(n)<0);t=e)this.items.set(t,this.items.get(e));this.items.set(t,n)},clear:function(){this._size=0,this.items.clear()},isEmpty:function(){return 0===this._size},add:function(t){this.items.add(null),this._size+=1;var e=this._size;for(this.items.set(0,t);t.compareTo(this.items.get(Math.trunc(e/2)))<0;e/=2)this.items.set(e,this.items.get(Math.trunc(e/2)));this.items.set(e,t)},interfaces_:function(){return[]},getClass:function(){return De}}),e(Ae.prototype,{visitItem:function(t){},interfaces_:function(){return[]},getClass:function(){return Ae}}),e(Fe.prototype,{insert:function(t,e){},remove:function(t,e){},query:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){arguments[0],arguments[1]}},interfaces_:function(){return[]},getClass:function(){return Fe}}),e(Ge.prototype,{getLevel:function(){return this.level},size:function(){return this.childBoundables.size()},getChildBoundables:function(){return this.childBoundables},addChildBoundable:function(t){f.isTrue(null===this.bounds),this.childBoundables.add(t)},isEmpty:function(){return this.childBoundables.isEmpty()},getBounds:function(){return null===this.bounds&&(this.bounds=this.computeBounds()),this.bounds},interfaces_:function(){return[_e,u]},getClass:function(){return Ge}}),Ge.serialVersionUID=0x5a1e55ec41369800;var ho={reverseOrder:function(){return{compare:function(t,e){return e.compareTo(t)}}},min:function(t){return ho.sort(t),t.get(0)},sort:function(t,e){var n=t.toArray();e?ut.sort(n,e):ut.sort(n);for(var i=t.iterator(),r=0,s=n.length;s>r;r++)i.next(),i.set(n[r])},singletonList:function(t){var e=new I;return e.add(t),e}};e(qe.prototype,{expandToQueue:function(t,e){var n=qe.isComposite(this.boundable1),r=qe.isComposite(this.boundable2);if(n&&r)return qe.area(this.boundable1)>qe.area(this.boundable2)?(this.expand(this.boundable1,this.boundable2,t,e),null):(this.expand(this.boundable2,this.boundable1,t,e),null);if(n)return this.expand(this.boundable1,this.boundable2,t,e),null;if(r)return this.expand(this.boundable2,this.boundable1,t,e),null;throw new i("neither boundable is composite")},isLeaves:function(){return!(qe.isComposite(this.boundable1)||qe.isComposite(this.boundable2))},compareTo:function(t){var e=t;return this._distance<e._distance?-1:this._distance>e._distance?1:0},expand:function(t,e,n,i){for(var r=t.getChildBoundables(),s=r.iterator();s.hasNext();){var o=s.next(),a=new qe(o,e,this.itemDistance);a.getDistance()<i&&n.add(a)}},getBoundable:function(t){return 0===t?this.boundable1:this.boundable2},getDistance:function(){return this._distance},distance:function(){return this.isLeaves()?this.itemDistance.distance(this.boundable1,this.boundable2):this.boundable1.getBounds().distance(this.boundable2.getBounds())},interfaces_:function(){return[s]},getClass:function(){return qe}}),qe.area=function(t){return t.getBounds().getArea()},qe.isComposite=function(t){return t instanceof Ge},e(Be.prototype,{getNodeCapacity:function(){return this.nodeCapacity},lastNode:function(t){return t.get(t.size()-1)},size:function t(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.size(this.root));if(1===arguments.length){for(var e=arguments[0],t=0,n=e.getChildBoundables().iterator();n.hasNext();){var i=n.next();i instanceof Ge?t+=this.size(i):i instanceof Me&&(t+=1)}return t}},removeItem:function(t,e){for(var n=null,i=t.getChildBoundables().iterator();i.hasNext();){var r=i.next();r instanceof Me&&r.getItem()===e&&(n=r)}return null!==n?(t.getChildBoundables().remove(n),!0):!1},itemsTree:function(){if(0===arguments.length){this.build();var t=this.itemsTree(this.root);return null===t?new I:t}if(1===arguments.length){for(var e=arguments[0],n=new I,i=e.getChildBoundables().iterator();i.hasNext();){var r=i.next();if(r instanceof Ge){var s=this.itemsTree(r);null!==s&&n.add(s)}else r instanceof Me?n.add(r.getItem()):f.shouldNeverReachHere()}return n.size()<=0?null:n}},insert:function(t,e){f.isTrue(!this.built,"Cannot insert items into an STR packed R-tree after it has been built."),this.itemBoundables.add(new Me(t,e))},boundablesAtLevel:function(){if(1===arguments.length){var t=arguments[0],e=new I;return this.boundablesAtLevel(t,this.root,e),e}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];if(f.isTrue(n>-2),i.getLevel()===n)return r.add(i),null;for(var s=i.getChildBoundables().iterator();s.hasNext();){var o=s.next();o instanceof Ge?this.boundablesAtLevel(n,o,r):(f.isTrue(o instanceof Me),-1===n&&r.add(o))}return null}},query:function(){if(1===arguments.length){var t=arguments[0];this.build();var e=new I;return this.isEmpty()?e:(this.getIntersectsOp().intersects(this.root.getBounds(),t)&&this.query(t,this.root,e),e)}if(2===arguments.length){var n=arguments[0],i=arguments[1];if(this.build(),this.isEmpty())return null;this.getIntersectsOp().intersects(this.root.getBounds(),n)&&this.query(n,this.root,i)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var r=arguments[0],s=arguments[1],o=arguments[2],a=s.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),r)&&(l instanceof Ge?this.query(r,l,o):l instanceof Me?o.visitItem(l.getItem()):f.shouldNeverReachHere())}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge)for(var h=arguments[0],c=arguments[1],g=arguments[2],a=c.getChildBoundables(),u=0;u<a.size();u++){var l=a.get(u);this.getIntersectsOp().intersects(l.getBounds(),h)&&(l instanceof Ge?this.query(h,l,g):l instanceof Me?g.add(l.getItem()):f.shouldNeverReachHere())}},build:function(){return this.built?null:(this.root=this.itemBoundables.isEmpty()?this.createNode(0):this.createHigherLevels(this.itemBoundables,-1),this.itemBoundables=null,void(this.built=!0))},getRoot:function(){return this.build(),this.root},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.build(),this.getIntersectsOp().intersects(this.root.getBounds(),t)?this.remove(t,this.root,e):!1}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=this.removeItem(i,r);if(s)return!0;for(var o=null,a=i.getChildBoundables().iterator();a.hasNext();){var u=a.next();if(this.getIntersectsOp().intersects(u.getBounds(),n)&&u instanceof Ge&&(s=this.remove(n,u,r))){o=u;break}}return null!==o&&o.getChildBoundables().isEmpty()&&i.getChildBoundables().remove(o),s}},createHigherLevels:function(t,e){f.isTrue(!t.isEmpty());var n=this.createParentBoundables(t,e+1);return 1===n.size()?n.get(0):this.createHigherLevels(n,e+1)},depth:function(){if(0===arguments.length)return this.isEmpty()?0:(this.build(),this.depth(this.root));if(1===arguments.length){for(var t=arguments[0],e=0,n=t.getChildBoundables().iterator();n.hasNext();){var i=n.next();if(i instanceof Ge){var r=this.depth(i);r>e&&(e=r)}}return e+1}},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=new I;n.add(this.createNode(e));var i=new I(t);ho.sort(i,this.getComparator());for(var r=i.iterator();r.hasNext();){var s=r.next();this.lastNode(n).getChildBoundables().size()===this.getNodeCapacity()&&n.add(this.createNode(e)),this.lastNode(n).addChildBoundable(s)}return n},isEmpty:function(){return this.built?this.root.isEmpty():this.itemBoundables.isEmpty()},interfaces_:function(){return[u]},getClass:function(){return Be}}),Be.compareDoubles=function(t,e){return t>e?1:e>t?-1:0},Be.IntersectsOp=ze,Be.serialVersionUID=-0x35ef64c82d4c5400,Be.DEFAULT_NODE_CAPACITY=10,e(Ve.prototype,{distance:function(t,e){},interfaces_:function(){return[]},getClass:function(){return Ve}}),h(ke,Be),e(ke.prototype,{createParentBoundablesFromVerticalSlices:function(t,e){f.isTrue(t.length>0);for(var n=new I,i=0;i<t.length;i++)n.addAll(this.createParentBoundablesFromVerticalSlice(t[i],e));return n},createNode:function(t){return new Ye(t)},size:function(){return 0===arguments.length?Be.prototype.size.call(this):Be.prototype.size.apply(this,arguments)},insert:function(){if(2!==arguments.length)return Be.prototype.insert.apply(this,arguments);var t=arguments[0],e=arguments[1];return t.isNull()?null:void Be.prototype.insert.call(this,t,e)},getIntersectsOp:function(){return ke.intersectsOp},verticalSlices:function(t,e){for(var n=Math.trunc(Math.ceil(t.size()/e)),i=new Array(e).fill(null),r=t.iterator(),s=0;e>s;s++){i[s]=new I;for(var o=0;r.hasNext()&&n>o;){var a=r.next();i[s].add(a),o++}}return i},query:function(){if(1===arguments.length){var t=arguments[0];return Be.prototype.query.call(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];Be.prototype.query.call(this,e,n)}else if(3===arguments.length)if(R(arguments[2],Ae)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var i=arguments[0],r=arguments[1],s=arguments[2];Be.prototype.query.call(this,i,r,s)}else if(R(arguments[2],y)&&arguments[0]instanceof Object&&arguments[1]instanceof Ge){var o=arguments[0],a=arguments[1],u=arguments[2];Be.prototype.query.call(this,o,a,u)}},getComparator:function(){return ke.yComparator},createParentBoundablesFromVerticalSlice:function(t,e){return Be.prototype.createParentBoundables.call(this,t,e)},remove:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Be.prototype.remove.call(this,t,e)}return Be.prototype.remove.apply(this,arguments)},depth:function(){return 0===arguments.length?Be.prototype.depth.call(this):Be.prototype.depth.apply(this,arguments)},createParentBoundables:function(t,e){f.isTrue(!t.isEmpty());var n=Math.trunc(Math.ceil(t.size()/this.getNodeCapacity())),i=new I(t);ho.sort(i,ke.xComparator);var r=this.verticalSlices(i,Math.trunc(Math.ceil(Math.sqrt(n))));return this.createParentBoundablesFromVerticalSlices(r,e)},nearestNeighbour:function(){if(1===arguments.length){if(R(arguments[0],Ve)){var t=arguments[0],e=new qe(this.getRoot(),this.getRoot(),t);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe){var n=arguments[0];return this.nearestNeighbour(n,r.POSITIVE_INFINITY)}}else if(2===arguments.length){if(arguments[0]instanceof ke&&R(arguments[1],Ve)){var i=arguments[0],s=arguments[1],e=new qe(this.getRoot(),i.getRoot(),s);return this.nearestNeighbour(e)}if(arguments[0]instanceof qe&&"number"==typeof arguments[1]){var o=arguments[0],a=arguments[1],u=a,l=null,h=new De;for(h.add(o);!h.isEmpty()&&u>0;){var c=h.poll(),f=c.getDistance();if(f>=u)break;c.isLeaves()?(u=f,l=c):c.expandToQueue(h,u)}return[l.getBoundable(0).getItem(),l.getBoundable(1).getItem()]}}else if(3===arguments.length){var g=arguments[0],d=arguments[1],p=arguments[2],v=new Me(g,d),e=new qe(this.getRoot(),v,p);return this.nearestNeighbour(e)[0]}},interfaces_:function(){return[Fe,u]},getClass:function(){return ke}}),ke.centreX=function(t){return ke.avg(t.getMinX(),t.getMaxX())},ke.avg=function(t,e){return(t+e)/2},ke.centreY=function(t){return ke.avg(t.getMinY(),t.getMaxY())},h(Ye,Ge),e(Ye.prototype,{computeBounds:function(){for(var t=null,e=this.getChildBoundables().iterator();e.hasNext();){var n=e.next();null===t?t=new C(n.getBounds()):t.expandToInclude(n.getBounds())}return t},interfaces_:function(){return[]},getClass:function(){return Ye}}),ke.STRtreeNode=Ye,ke.serialVersionUID=0x39920f7d5f261e0,ke.xComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreX(t.getBounds()),ke.centreX(e.getBounds()))}},ke.yComparator={interfaces_:function(){return[a]},compare:function(t,e){return Be.compareDoubles(ke.centreY(t.getBounds()),ke.centreY(e.getBounds()))}},ke.intersectsOp={interfaces_:function(){return[IntersectsOp]},intersects:function(t,e){return t.intersects(e)}},ke.DEFAULT_NODE_CAPACITY=10,e(Ue.prototype,{interfaces_:function(){return[]},getClass:function(){return Ue}}),Ue.relativeSign=function(t,e){return e>t?-1:t>e?1:0},Ue.compare=function(t,e,n){if(e.equals2D(n))return 0;var i=Ue.relativeSign(e.x,n.x),r=Ue.relativeSign(e.y,n.y);switch(t){case 0:return Ue.compareValue(i,r);case 1:return Ue.compareValue(r,i);case 2:return Ue.compareValue(r,-i);case 3:return Ue.compareValue(-i,r);case 4:return Ue.compareValue(-i,-r);case 5:return Ue.compareValue(-r,-i);case 6:return Ue.compareValue(-r,i);case 7:return Ue.compareValue(i,-r)}return f.shouldNeverReachHere("invalid octant value"),0},Ue.compareValue=function(t,e){return 0>t?-1:t>0?1:0>e?-1:e>0?1:0},e(Xe.prototype,{getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex)},compareTo:function(t){var e=t;return this.segmentIndex<e.segmentIndex?-1:this.segmentIndex>e.segmentIndex?1:this.coord.equals2D(e.coord)?0:Ue.compare(this.segmentOctant,this.coord,e.coord)},isEndPoint:function(t){return 0!==this.segmentIndex||this._isInterior?this.segmentIndex===t:!0},isInterior:function(){return this._isInterior},interfaces_:function(){return[s]},getClass:function(){return Xe}}),e(He.prototype,{getSplitCoordinates:function(){var t=new N;this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next();this.addEdgeCoordinates(n,i,t),n=i}return t.toCoordinateArray()},addCollapsedNodes:function(){var t=new I;this.findCollapsesFromInsertedNodes(t),this.findCollapsesFromExistingVertices(t);for(var e=t.iterator();e.hasNext();){var n=e.next().intValue();this.add(this.edge.getCoordinate(n),n)}},print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},findCollapsesFromExistingVertices:function(t){for(var e=0;e<this.edge.size()-2;e++){var n=this.edge.getCoordinate(e),i=(this.edge.getCoordinate(e+1),this.edge.getCoordinate(e+2));n.equals2D(i)&&t.add(new b(e+1))}},addEdgeCoordinates:function(t,e,n){var i=e.segmentIndex-t.segmentIndex+2,r=this.edge.getCoordinate(e.segmentIndex),s=e.isInterior()||!e.coord.equals2D(r);s||i--;n.add(new g(t.coord),!1);for(var o=t.segmentIndex+1;o<=e.segmentIndex;o++)n.add(this.edge.getCoordinate(o));s&&n.add(new g(e.coord))},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints(),this.addCollapsedNodes();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},findCollapseIndex:function(t,e,n){if(!t.coord.equals2D(e.coord))return!1;var i=e.segmentIndex-t.segmentIndex;return e.isInterior()||i--,1===i?(n[0]=t.segmentIndex+1,!0):!1},findCollapsesFromInsertedNodes:function(t){for(var e=new Array(1).fill(null),n=this.iterator(),i=n.next();n.hasNext();){var r=n.next(),s=this.findCollapseIndex(i,r,e);s&&t.add(new b(e[0])),i=r}},getEdge:function(){return this.edge},addEndpoints:function(){var t=this.edge.size()-1;this.add(this.edge.getCoordinate(0),0),this.add(this.edge.getCoordinate(t),t)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.getCoordinate(e.segmentIndex),r=e.isInterior()||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.getCoordinate(a);return r&&(s[o]=new g(e.coord)),new Ke(s,this.edge.getData())},add:function(t,e){var n=new Xe(this.edge,t,e,this.edge.getSegmentOctant(e)),i=this.nodeMap.get(n);return null!==i?(f.isTrue(i.coord.equals2D(t),"Found equal nodes with different coordinates"),i):(this.nodeMap.put(n,n),n)},checkSplitEdgesCorrectness:function(t){var e=this.edge.getCoordinates(),n=t.get(0),i=n.getCoordinate(0);if(!i.equals2D(e[0]))throw new l("bad split edge start point at "+i);var r=t.get(t.size()-1),s=r.getCoordinates(),o=s[s.length-1];if(!o.equals2D(e[e.length-1]))throw new l("bad split edge end point at "+o)},interfaces_:function(){return[]},getClass:function(){return He}}),e(We.prototype,{next:function(){return null===this.currNode?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):null===this.nextNode?null:this.nextNode.segmentIndex===this.currNode.segmentIndex?(this.currNode=this.nextNode,this.currSegIndex=this.currNode.segmentIndex,this.readNextNode(),this.currNode):(this.nextNode.segmentIndex>this.currNode.segmentIndex,null)},remove:function(){throw new UnsupportedOperationException(this.getClass().getName())},hasNext:function(){return null!==this.nextNode},readNextNode:function(){this.nodeIt.hasNext()?this.nextNode=this.nodeIt.next():this.nextNode=null},interfaces_:function(){return[p]},getClass:function(){return We}}),e(je.prototype,{addIntersection:function(t,e){},interfaces_:function(){return[be]},getClass:function(){return je}}),e(Ke.prototype,{getCoordinates:function(){return this.pts},size:function(){return this.pts.length},getCoordinate:function(t){return this.pts[t]},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getSegmentOctant:function(t){return t===this.pts.length-1?-1:this.safeOctant(this.getCoordinate(t),this.getCoordinate(t+1))},setData:function(t){this.data=t},safeOctant:function(t,e){return t.equals2D(e)?0:Pe.octant(t,e)},getData:function(){return this.data},addIntersection:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.addIntersectionNode(t,e)}else if(4===arguments.length){var n=arguments[0],i=arguments[1],r=(arguments[2],arguments[3]),s=new g(n.getIntersection(r));this.addIntersection(s,i)}},toString:function(){return se.toLineString(new Gt(this.pts))},getNodeList:function(){return this.nodeList},addIntersectionNode:function(t,e){var n=e,i=n+1;if(i<this.pts.length){var r=this.pts[i];t.equals2D(r)&&(n=i)}var s=this.nodeList.add(t,n);return s},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[je]},getClass:function(){return Ke}}),Ke.getNodedSubstrings=function(){if(1===arguments.length){var t=arguments[0],e=new I;return Ke.getNodedSubstrings(t,e),e}if(2===arguments.length)for(var n=arguments[0],i=arguments[1],r=n.iterator();r.hasNext();){var s=r.next();s.getNodeList().addSplitEdges(i)}},e(Ze.prototype,{overlap:function(){if(2===arguments.length){arguments[0],arguments[1]}else if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];t.getLineSegment(e,this.overlapSeg1),n.getLineSegment(i,this.overlapSeg2),this.overlap(this.overlapSeg1,this.overlapSeg2)}},interfaces_:function(){return[]},getClass:function(){return Ze}}),e(Qe.prototype,{getLineSegment:function(t,e){e.p0=this.pts[t],e.p1=this.pts[t+1]},computeSelect:function(t,e,n,i){var r=this.pts[e],s=this.pts[n];if(i.tempEnv1.init(r,s),n-e===1)return i.select(this,e),null;if(!t.intersects(i.tempEnv1))return null;var o=Math.trunc((e+n)/2);
o>e&&this.computeSelect(t,e,o,i),n>o&&this.computeSelect(t,o,n,i)},getCoordinates:function(){for(var t=new Array(this.end-this.start+1).fill(null),e=0,n=this.start;n<=this.end;n++)t[e++]=this.pts[n];return t},computeOverlaps:function(t,e){this.computeOverlapsInternal(this.start,this.end,t,t.start,t.end,e)},setId:function(t){this.id=t},select:function(t,e){this.computeSelect(t,this.start,this.end,e)},getEnvelope:function(){if(null===this.env){var t=this.pts[this.start],e=this.pts[this.end];this.env=new C(t,e)}return this.env},getEndIndex:function(){return this.end},getStartIndex:function(){return this.start},getContext:function(){return this.context},getId:function(){return this.id},computeOverlapsInternal:function(t,e,n,i,r,s){var o=this.pts[t],a=this.pts[e],u=n.pts[i],l=n.pts[r];if(e-t===1&&r-i===1)return s.overlap(this,t,n,i),null;if(s.tempEnv1.init(o,a),s.tempEnv2.init(u,l),!s.tempEnv1.intersects(s.tempEnv2))return null;var h=Math.trunc((t+e)/2),c=Math.trunc((i+r)/2);h>t&&(c>i&&this.computeOverlapsInternal(t,h,n,i,c,s),r>c&&this.computeOverlapsInternal(t,h,n,c,r,s)),e>h&&(c>i&&this.computeOverlapsInternal(h,e,n,i,c,s),r>c&&this.computeOverlapsInternal(h,e,n,c,r,s))},interfaces_:function(){return[]},getClass:function(){return Qe}}),e(Je.prototype,{interfaces_:function(){return[]},getClass:function(){return Je}}),Je.isNorthern=function(t){return t===Je.NE||t===Je.NW},Je.isOpposite=function(t,e){if(t===e)return!1;var n=(t-e+4)%4;return 2===n},Je.commonHalfPlane=function(t,e){if(t===e)return t;var n=(t-e+4)%4;if(2===n)return-1;var i=e>t?t:e,r=t>e?t:e;return 0===i&&3===r?3:i},Je.isInHalfPlane=function(t,e){return e===Je.SE?t===Je.SE||t===Je.SW:t===e||t===e+1},Je.quadrant=function(){if("number"==typeof arguments[0]&&"number"==typeof arguments[1]){var t=arguments[0],e=arguments[1];if(0===t&&0===e)throw new i("Cannot compute the quadrant for point ( "+t+", "+e+" )");return t>=0?e>=0?Je.NE:Je.SE:e>=0?Je.NW:Je.SW}if(arguments[0]instanceof g&&arguments[1]instanceof g){var n=arguments[0],r=arguments[1];if(r.x===n.x&&r.y===n.y)throw new i("Cannot compute the quadrant for two identical points "+n);return r.x>=n.x?r.y>=n.y?Je.NE:Je.SE:r.y>=n.y?Je.NW:Je.SW}},Je.NE=0,Je.NW=1,Je.SW=2,Je.SE=3,e($e.prototype,{interfaces_:function(){return[]},getClass:function(){return $e}}),$e.getChainStartIndices=function(t){var e=0,n=new I;n.add(new b(e));do{var i=$e.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=$e.toIntArray(n);return r},$e.findChainEnd=function(t,e){for(var n=e;n<t.length-1&&t[n].equals2D(t[n+1]);)n++;if(n>=t.length-1)return t.length-1;for(var i=Je.quadrant(t[n],t[n+1]),r=e+1;r<t.length;){if(!t[r-1].equals2D(t[r])){var s=Je.quadrant(t[r-1],t[r]);if(s!==i)break}r++}return r-1},$e.getChains=function(){if(1===arguments.length){var t=arguments[0];return $e.getChains(t,null)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new I,r=$e.getChainStartIndices(e),s=0;s<r.length-1;s++){var o=new Qe(e,r[s],r[s+1],n);i.add(o)}return i}},$e.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(tn.prototype,{computeNodes:function(t){},getNodedSubstrings:function(){},interfaces_:function(){return[]},getClass:function(){return tn}}),e(en.prototype,{setSegmentIntersector:function(t){this.segInt=t},interfaces_:function(){return[tn]},getClass:function(){return en}}),h(nn,en),e(nn.prototype,{getMonotoneChains:function(){return this.monoChains},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},getIndex:function(){return this.index},add:function(t){for(var e=$e.getChains(t.getCoordinates(),t),n=e.iterator();n.hasNext();){var i=n.next();i.setId(this.idCounter++),this.index.insert(i.getEnvelope(),i),this.monoChains.add(i)}},computeNodes:function(t){this.nodedSegStrings=t;for(var e=t.iterator();e.hasNext();)this.add(e.next());this.intersectChains()},intersectChains:function(){for(var t=new rn(this.segInt),e=this.monoChains.iterator();e.hasNext();)for(var n=e.next(),i=this.index.query(n.getEnvelope()),r=i.iterator();r.hasNext();){var s=r.next();if(s.getId()>n.getId()&&(n.computeOverlaps(s,t),this.nOverlaps++),this.segInt.isDone())return null}},interfaces_:function(){return[]},getClass:function(){return nn}}),h(rn,Ze),e(rn.prototype,{overlap:function(){if(4!==arguments.length)return Ze.prototype.overlap.apply(this,arguments);var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3],r=t.getContext(),s=n.getContext();this.si.processIntersections(r,e,s,i)},interfaces_:function(){return[]},getClass:function(){return rn}}),nn.SegmentOverlapAction=rn,h(sn,l),e(sn.prototype,{getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return sn}}),sn.msgWithCoord=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(on.prototype,{processIntersections:function(t,e,n,i){},isDone:function(){},interfaces_:function(){return[]},getClass:function(){return on}}),e(an.prototype,{getInteriorIntersection:function(){return this.interiorIntersection},setCheckEndSegmentsOnly:function(t){this.isCheckEndSegmentsOnly=t},getIntersectionSegments:function(){return this.intSegments},count:function(){return this.intersectionCount},getIntersections:function(){return this.intersections},setFindAllIntersections:function(t){this.findAllIntersections=t},setKeepIntersections:function(t){this.keepIntersections=t},processIntersections:function(t,e,n,i){if(!this.findAllIntersections&&this.hasIntersection())return null;if(t===n&&e===i)return null;if(this.isCheckEndSegmentsOnly){var r=this.isEndSegment(t,e)||this.isEndSegment(n,i);if(!r)return null}var s=t.getCoordinates()[e],o=t.getCoordinates()[e+1],a=n.getCoordinates()[i],u=n.getCoordinates()[i+1];this.li.computeIntersection(s,o,a,u),this.li.hasIntersection()&&this.li.isInteriorIntersection()&&(this.intSegments=new Array(4).fill(null),this.intSegments[0]=s,this.intSegments[1]=o,this.intSegments[2]=a,this.intSegments[3]=u,this.interiorIntersection=this.li.getIntersection(0),this.keepIntersections&&this.intersections.add(this.interiorIntersection),this.intersectionCount++)},isEndSegment:function(t,e){return 0===e?!0:e>=t.size()-2},hasIntersection:function(){return null!==this.interiorIntersection},isDone:function(){return this.findAllIntersections?!1:null!==this.interiorIntersection},interfaces_:function(){return[on]},getClass:function(){return an}}),an.createAllIntersectionsFinder=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e},an.createAnyIntersectionFinder=function(t){return new an(t)},an.createIntersectionCounter=function(t){var e=new an(t);return e.setFindAllIntersections(!0),e.setKeepIntersections(!1),e},e(un.prototype,{execute:function(){return null!==this.segInt?null:void this.checkInteriorIntersections()},getIntersections:function(){return this.segInt.getIntersections()},isValid:function(){return this.execute(),this._isValid},setFindAllIntersections:function(t){this.findAllIntersections=t},checkInteriorIntersections:function(){this._isValid=!0,this.segInt=new an(this.li),this.segInt.setFindAllIntersections(this.findAllIntersections);var t=new nn;return t.setSegmentIntersector(this.segInt),t.computeNodes(this.segStrings),this.segInt.hasIntersection()?(this._isValid=!1,null):void 0},checkValid:function(){if(this.execute(),!this._isValid)throw new sn(this.getErrorMessage(),this.segInt.getInteriorIntersection())},getErrorMessage:function(){if(this._isValid)return"no intersections found";var t=this.segInt.getIntersectionSegments();return"found non-noded intersection between "+se.toLineString(t[0],t[1])+" and "+se.toLineString(t[2],t[3])},interfaces_:function(){return[]},getClass:function(){return un}}),un.computeIntersections=function(t){var e=new un(t);return e.setFindAllIntersections(!0),e.isValid(),e.getIntersections()},e(ln.prototype,{checkValid:function(){this.nv.checkValid()},interfaces_:function(){return[]},getClass:function(){return ln}}),ln.toSegmentStrings=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Oe(i.getCoordinates(),i))}return e},ln.checkValid=function(t){var e=new ln(t);e.checkValid()},e(hn.prototype,{map:function(t){for(var e=new I,n=0;n<t.getNumGeometries();n++){var i=this.mapOp.map(t.getGeometryN(n));i.isEmpty()||e.add(i)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(e))},interfaces_:function(){return[]},getClass:function(){return hn}}),hn.map=function(t,e){var n=new hn(e);return n.map(t)},e(cn.prototype,{interfaces_:function(){return[]},getClass:function(){return cn}}),cn.opposite=function(t){return t===cn.LEFT?cn.RIGHT:t===cn.RIGHT?cn.LEFT:t},cn.ON=0,cn.LEFT=1,cn.RIGHT=2,e(fn.prototype,{setAllLocations:function(t){for(var e=0;e<this.location.length;e++)this.location[e]=t},isNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]!==L.NONE)return!1;return!0},setAllLocationsIfNull:function(t){for(var e=0;e<this.location.length;e++)this.location[e]===L.NONE&&(this.location[e]=t)},isLine:function(){return 1===this.location.length},merge:function(t){if(t.location.length>this.location.length){var e=new Array(3).fill(null);e[cn.ON]=this.location[cn.ON],e[cn.LEFT]=L.NONE,e[cn.RIGHT]=L.NONE,this.location=e}for(var n=0;n<this.location.length;n++)this.location[n]===L.NONE&&n<t.location.length&&(this.location[n]=t.location[n])},getLocations:function(){return this.location},flip:function(){if(this.location.length<=1)return null;var t=this.location[cn.LEFT];this.location[cn.LEFT]=this.location[cn.RIGHT],this.location[cn.RIGHT]=t},toString:function(){var t=new P;return this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.LEFT])),t.append(L.toLocationSymbol(this.location[cn.ON])),this.location.length>1&&t.append(L.toLocationSymbol(this.location[cn.RIGHT])),t.toString()},setLocations:function(t,e,n){this.location[cn.ON]=t,this.location[cn.LEFT]=e,this.location[cn.RIGHT]=n},get:function(t){return t<this.location.length?this.location[t]:L.NONE},isArea:function(){return this.location.length>1},isAnyNull:function(){for(var t=0;t<this.location.length;t++)if(this.location[t]===L.NONE)return!0;return!1},setLocation:function(){if(1===arguments.length){var t=arguments[0];this.setLocation(cn.ON,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.location[e]=n}},init:function(t){this.location=new Array(t).fill(null),this.setAllLocations(L.NONE)},isEqualOnSide:function(t,e){return this.location[e]===t.location[e]},allPositionsEqual:function(t){for(var e=0;e<this.location.length;e++)if(this.location[e]!==t)return!1;return!0},interfaces_:function(){return[]},getClass:function(){return fn}}),e(gn.prototype,{getGeometryCount:function(){var t=0;return this.elt[0].isNull()||t++,this.elt[1].isNull()||t++,t},setAllLocations:function(t,e){this.elt[t].setAllLocations(e)},isNull:function(t){return this.elt[t].isNull()},setAllLocationsIfNull:function(){if(1===arguments.length){var t=arguments[0];this.setAllLocationsIfNull(0,t),this.setAllLocationsIfNull(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1];this.elt[e].setAllLocationsIfNull(n)}},isLine:function(t){return this.elt[t].isLine()},merge:function(t){for(var e=0;2>e;e++)null===this.elt[e]&&null!==t.elt[e]?this.elt[e]=new fn(t.elt[e]):this.elt[e].merge(t.elt[e])},flip:function(){this.elt[0].flip(),this.elt[1].flip()},getLocation:function(){if(1===arguments.length){var t=arguments[0];return this.elt[t].get(cn.ON)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.elt[e].get(n)}},toString:function(){var t=new P;return null!==this.elt[0]&&(t.append("A:"),t.append(this.elt[0].toString())),null!==this.elt[1]&&(t.append(" B:"),t.append(this.elt[1].toString())),t.toString()},isArea:function(){if(0===arguments.length)return this.elt[0].isArea()||this.elt[1].isArea();if(1===arguments.length){var t=arguments[0];return this.elt[t].isArea()}},isAnyNull:function(t){return this.elt[t].isAnyNull()},setLocation:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];this.elt[t].setLocation(cn.ON,e)}else if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];this.elt[n].setLocation(i,r)}},isEqualOnSide:function(t,e){return this.elt[0].isEqualOnSide(t.elt[0],e)&&this.elt[1].isEqualOnSide(t.elt[1],e)},allPositionsEqual:function(t,e){return this.elt[t].allPositionsEqual(e)},toLine:function(t){this.elt[t].isArea()&&(this.elt[t]=new fn(this.elt[t].location[0]))},interfaces_:function(){return[]},getClass:function(){return gn}}),gn.toLineLabel=function(t){for(var e=new gn(L.NONE),n=0;2>n;n++)e.setLocation(n,t.getLocation(n));return e},e(dn.prototype,{computeRing:function(){if(null!==this.ring)return null;for(var t=new Array(this.pts.size()).fill(null),e=0;e<this.pts.size();e++)t[e]=this.pts.get(e);this.ring=this.geometryFactory.createLinearRing(t),this._isHole=he.isCCW(this.ring.getCoordinates())},isIsolated:function(){return 1===this.label.getGeometryCount()},computePoints:function(t){this.startDe=t;var e=t,n=!0;do{if(null===e)throw new sn("Found null DirectedEdge");if(e.getEdgeRing()===this)throw new sn("Directed Edge visited twice during ring-building at "+e.getCoordinate());this.edges.add(e);var i=e.getLabel();f.isTrue(i.isArea()),this.mergeLabel(i),this.addPoints(e.getEdge(),e.isForward(),n),n=!1,this.setEdgeRing(e,this),e=this.getNext(e)}while(e!==this.startDe)},getLinearRing:function(){return this.ring},getCoordinate:function(t){return this.pts.get(t)},computeMaxNodeDegree:function(){this.maxNodeDegree=0;var t=this.startDe;do{var e=t.getNode(),n=e.getEdges().getOutgoingDegree(this);n>this.maxNodeDegree&&(this.maxNodeDegree=n),t=this.getNext(t)}while(t!==this.startDe);this.maxNodeDegree*=2},addPoints:function(t,e,n){var i=t.getCoordinates();if(e){var r=1;n&&(r=0);for(var s=r;s<i.length;s++)this.pts.add(i[s])}else{var r=i.length-2;n&&(r=i.length-1);for(var s=r;s>=0;s--)this.pts.add(i[s])}},isHole:function(){return this._isHole},setInResult:function(){var t=this.startDe;do t.getEdge().setInResult(!0),t=t.getNext();while(t!==this.startDe)},containsPoint:function(t){var e=this.getLinearRing(),n=e.getEnvelopeInternal();if(!n.contains(t))return!1;if(!he.isPointInRing(t,e.getCoordinates()))return!1;for(var i=this.holes.iterator();i.hasNext();){var r=i.next();if(r.containsPoint(t))return!1}return!0},addHole:function(t){this.holes.add(t)},isShell:function(){return null===this.shell},getLabel:function(){return this.label},getEdges:function(){return this.edges},getMaxNodeDegree:function(){return this.maxNodeDegree<0&&this.computeMaxNodeDegree(),this.maxNodeDegree},getShell:function(){return this.shell},mergeLabel:function(){if(1===arguments.length){var t=arguments[0];this.mergeLabel(t,0),this.mergeLabel(t,1)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=e.getLocation(n,cn.RIGHT);if(i===L.NONE)return null;if(this.label.getLocation(n)===L.NONE)return this.label.setLocation(n,i),null}},setShell:function(t){this.shell=t,null!==t&&t.addHole(this)},toPolygon:function(t){for(var e=new Array(this.holes.size()).fill(null),n=0;n<this.holes.size();n++)e[n]=this.holes.get(n).getLinearRing();var i=t.createPolygon(this.getLinearRing(),e);return i},interfaces_:function(){return[]},getClass:function(){return dn}}),h(pn,dn),e(pn.prototype,{setEdgeRing:function(t,e){t.setMinEdgeRing(e)},getNext:function(t){return t.getNextMin()},interfaces_:function(){return[]},getClass:function(){return pn}}),h(vn,dn),e(vn.prototype,{buildMinimalRings:function(){var t=new I,e=this.startDe;do{if(null===e.getMinEdgeRing()){var n=new pn(e,this.geometryFactory);t.add(n)}e=e.getNext()}while(e!==this.startDe);return t},setEdgeRing:function(t,e){t.setEdgeRing(e)},linkDirectedEdgesForMinimalEdgeRings:function(){var t=this.startDe;do{var e=t.getNode();e.getEdges().linkMinimalDirectedEdges(this),t=t.getNext()}while(t!==this.startDe)},getNext:function(t){return t.getNext()},interfaces_:function(){return[]},getClass:function(){return vn}}),e(mn.prototype,{setVisited:function(t){this._isVisited=t},setInResult:function(t){this._isInResult=t},isCovered:function(){return this._isCovered},isCoveredSet:function(){return this._isCoveredSet},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setCovered:function(t){this._isCovered=t,this._isCoveredSet=!0},updateIM:function(t){f.isTrue(this.label.getGeometryCount()>=2,"found partial label"),this.computeIM(t)},isInResult:function(){return this._isInResult},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return mn}}),h(yn,mn),e(yn.prototype,{isIncidentEdgeInResult:function(){for(var t=this.getEdges().getEdges().iterator();t.hasNext();){var e=t.next();if(e.getEdge().isInResult())return!0}return!1},isIsolated:function(){return 1===this.label.getGeometryCount()},getCoordinate:function(){return this.coord},print:function(t){t.println("node "+this.coord+" lbl: "+this.label)},computeIM:function(t){},computeMergedLocation:function(t,e){var n=L.NONE;if(n=this.label.getLocation(e),!t.isNull(e)){var i=t.getLocation(e);n!==L.BOUNDARY&&(n=i)}return n},setLabel:function(){if(2!==arguments.length)return mn.prototype.setLabel.apply(this,arguments);var t=arguments[0],e=arguments[1];null===this.label?this.label=new gn(t,e):this.label.setLocation(t,e)},getEdges:function(){return this.edges},mergeLabel:function(){if(arguments[0]instanceof yn){var t=arguments[0];this.mergeLabel(t.label)}else if(arguments[0]instanceof gn)for(var e=arguments[0],n=0;2>n;n++){var i=this.computeMergedLocation(e,n),r=this.label.getLocation(n);r===L.NONE&&this.label.setLocation(n,i)}},add:function(t){this.edges.insert(t),t.setNode(this)},setLabelBoundary:function(t){if(null===this.label)return null;var e=L.NONE;null!==this.label&&(e=this.label.getLocation(t));var n=null;switch(e){case L.BOUNDARY:n=L.INTERIOR;break;case L.INTERIOR:n=L.BOUNDARY;break;default:n=L.BOUNDARY}this.label.setLocation(t,n)},interfaces_:function(){return[]},getClass:function(){return yn}}),e(xn.prototype,{find:function(t){return this.nodeMap.get(t)},addNode:function(){if(arguments[0]instanceof g){var t=arguments[0],e=this.nodeMap.get(t);return null===e&&(e=this.nodeFact.createNode(t),this.nodeMap.put(t,e)),e}if(arguments[0]instanceof yn){var n=arguments[0],e=this.nodeMap.get(n.getCoordinate());return null===e?(this.nodeMap.put(n.getCoordinate(),n),n):(e.mergeLabel(n),e)}},print:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},values:function(){return this.nodeMap.values()},getBoundaryNodes:function(t){for(var e=new I,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().getLocation(t)===L.BOUNDARY&&e.add(i)}return e},add:function(t){var e=t.getCoordinate(),n=this.addNode(e);n.add(t)},interfaces_:function(){return[]},getClass:function(){return xn}}),e(En.prototype,{compareDirection:function(t){return this.dx===t.dx&&this.dy===t.dy?0:this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getDy:function(){return this.dy},getCoordinate:function(){return this.p0},setNode:function(t){this.node=t},print:function(t){var e=Math.atan2(this.dy,this.dx),n=this.getClass().getName(),i=n.lastIndexOf("."),r=n.substring(i+1);t.print("  "+r+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+e+"   "+this.label)},compareTo:function(t){var e=t;return this.compareDirection(e)},getDirectedCoordinate:function(){return this.p1},getDx:function(){return this.dx},getLabel:function(){return this.label},getEdge:function(){return this.edge},getQuadrant:function(){return this.quadrant},getNode:function(){return this.node},toString:function(){var t=Math.atan2(this.dy,this.dx),e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);return"  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+t+"   "+this.label},computeLabel:function(t){},init:function(t,e){this.p0=t,this.p1=e,this.dx=e.x-t.x,this.dy=e.y-t.y,this.quadrant=Je.quadrant(this.dx,this.dy),f.isTrue(!(0===this.dx&&0===this.dy),"EdgeEnd with identical endpoints found")},interfaces_:function(){return[s]},getClass:function(){return En}}),h(In,En),e(In.prototype,{getNextMin:function(){return this.nextMin},getDepth:function(t){return this.depth[t]},setVisited:function(t){this._isVisited=t},computeDirectedLabel:function(){this.label=new gn(this.edge.getLabel()),this._isForward||this.label.flip()},getNext:function(){return this.next},setDepth:function(t,e){if(-999!==this.depth[t]&&this.depth[t]!==e)throw new sn("assigned depths do not match",this.getCoordinate());this.depth[t]=e},isInteriorAreaEdge:function t(){for(var t=!0,e=0;2>e;e++)this.label.isArea(e)&&this.label.getLocation(e,cn.LEFT)===L.INTERIOR&&this.label.getLocation(e,cn.RIGHT)===L.INTERIOR||(t=!1);return t},setNextMin:function(t){this.nextMin=t},print:function(t){En.prototype.print.call(this,t),t.print(" "+this.depth[cn.LEFT]+"/"+this.depth[cn.RIGHT]),t.print(" ("+this.getDepthDelta()+")"),this._isInResult&&t.print(" inResult")},setMinEdgeRing:function(t){this.minEdgeRing=t},isLineEdge:function(){var t=this.label.isLine(0)||this.label.isLine(1),e=!this.label.isArea(0)||this.label.allPositionsEqual(0,L.EXTERIOR),n=!this.label.isArea(1)||this.label.allPositionsEqual(1,L.EXTERIOR);return t&&e&&n},setEdgeRing:function(t){this.edgeRing=t},getMinEdgeRing:function(){return this.minEdgeRing},getDepthDelta:function(){var t=this.edge.getDepthDelta();return this._isForward||(t=-t),t},setInResult:function(t){this._isInResult=t},getSym:function(){return this.sym},isForward:function(){return this._isForward},getEdge:function(){return this.edge},printEdge:function(t){this.print(t),t.print(" "),this._isForward?this.edge.print(t):this.edge.printReverse(t)},setSym:function(t){this.sym=t},setVisitedEdge:function(t){this.setVisited(t),this.sym.setVisited(t)},setEdgeDepths:function(t,e){var n=this.getEdge().getDepthDelta();this._isForward||(n=-n);var i=1;t===cn.LEFT&&(i=-1);var r=cn.opposite(t),s=n*i,o=e+s;this.setDepth(t,e),this.setDepth(r,o)},getEdgeRing:function(){return this.edgeRing},isInResult:function(){return this._isInResult},setNext:function(t){this.next=t},isVisited:function(){return this._isVisited},interfaces_:function(){return[]},getClass:function(){return In}}),In.depthFactor=function(t,e){return t===L.EXTERIOR&&e===L.INTERIOR?1:t===L.INTERIOR&&e===L.EXTERIOR?-1:0},e(Nn.prototype,{createNode:function(t){return new yn(t,null)},interfaces_:function(){return[]},getClass:function(){return Nn}}),e(Cn.prototype,{printEdges:function(t){t.println("Edges:");for(var e=0;e<this.edges.size();e++){t.println("edge "+e+":");var n=this.edges.get(e);n.print(t),n.eiList.print(t)}},find:function(t){return this.nodes.find(t)},addNode:function(){if(arguments[0]instanceof yn){var t=arguments[0];return this.nodes.addNode(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.nodes.addNode(e)}},getNodeIterator:function(){return this.nodes.iterator()},linkResultDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkResultDirectedEdges()}},debugPrintln:function(t){A.out.println(t)},isBoundaryNode:function(t,e){var n=this.nodes.find(e);if(null===n)return!1;var i=n.getLabel();return null!==i&&i.getLocation(t)===L.BOUNDARY},linkAllDirectedEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().linkAllDirectedEdges()}},matchInSameDirection:function(t,e,n,i){return t.equals(n)?he.computeOrientation(t,e,i)===he.COLLINEAR&&Je.quadrant(t,e)===Je.quadrant(n,i):!1},getEdgeEnds:function(){return this.edgeEndList},debugPrint:function(t){A.out.print(t)},getEdgeIterator:function(){return this.edges.iterator()},findEdgeInSameDirection:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(this.matchInSameDirection(t,e,r[0],r[1]))return i;if(this.matchInSameDirection(t,e,r[r.length-1],r[r.length-2]))return i}return null},insertEdge:function(t){this.edges.add(t)},findEdgeEnd:function(t){for(var e=this.getEdgeEnds().iterator();e.hasNext();){var n=e.next();if(n.getEdge()===t)return n}return null},addEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.edges.add(n);var i=new In(n,!0),r=new In(n,!1);i.setSym(r),r.setSym(i),this.add(i),this.add(r)}},add:function(t){this.nodes.add(t),this.edgeEndList.add(t)},getNodes:function(){return this.nodes.values()},findEdge:function(t,e){for(var n=0;n<this.edges.size();n++){var i=this.edges.get(n),r=i.getCoordinates();if(t.equals(r[0])&&e.equals(r[1]))return i}return null},interfaces_:function(){return[]},getClass:function(){return Cn}}),Cn.linkResultDirectedEdges=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.getEdges().linkResultDirectedEdges()}},e(Sn.prototype,{sortShellsAndHoles:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isHole()?n.add(r):e.add(r)}},computePolygons:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=i.toPolygon(this.geometryFactory);e.add(r)}return e},placeFreeHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();if(null===i.getShell()){var r=this.findEdgeRingContaining(i,t);if(null===r)throw new sn("unable to assign hole to a shell",i.getCoordinate(0));i.setShell(r)}}},buildMinimalEdgeRings:function(t,e,n){for(var i=new I,r=t.iterator();r.hasNext();){var s=r.next();if(s.getMaxNodeDegree()>2){s.linkDirectedEdgesForMinimalEdgeRings();var o=s.buildMinimalRings(),a=this.findShell(o);null!==a?(this.placePolygonHoles(a,o),e.add(a)):n.addAll(o)}else i.add(s)}return i},containsPoint:function(t){for(var e=this.shellList.iterator();e.hasNext();){var n=e.next();if(n.containsPoint(t))return!0}return!1},buildMaximalEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&i.getLabel().isArea()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);e.add(r),r.setInResult()}}return e},placePolygonHoles:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next();i.isHole()&&i.setShell(t)}},getPolygons:function(){var t=this.computePolygons(this.shellList);return t},findEdgeRingContaining:function(t,e){for(var n=t.getLinearRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getLinearRing(),h=l.getEnvelopeInternal();null!==s&&(o=s.getLinearRing().getEnvelopeInternal());var c=!1;h.contains(i)&&he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u)}return s},findShell:function(t){for(var e=0,n=null,i=t.iterator();i.hasNext();){var r=i.next();r.isHole()||(n=r,e++)}return f.isTrue(1>=e,"found two shells in MinimalEdgeRing list"),n},add:function(){if(1===arguments.length){var t=arguments[0];this.add(t.getEdgeEnds(),t.getNodes())}else if(2===arguments.length){var e=arguments[0],n=arguments[1];Cn.linkResultDirectedEdges(n);var i=this.buildMaximalEdgeRings(e),r=new I,s=this.buildMinimalEdgeRings(i,this.shellList,r);this.sortShellsAndHoles(s,this.shellList,r),this.placeFreeHoles(this.shellList,r)}},interfaces_:function(){return[]},getClass:function(){return Sn}}),e(wn.prototype,{collectLines:function(t){for(var e=this.op.getGraph().getEdgeEnds().iterator();e.hasNext();){var n=e.next();this.collectLineEdge(n,t,this.lineEdgesList),this.collectBoundaryTouchEdge(n,t,this.lineEdgesList)}},labelIsolatedLine:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.op.getArgGeometry(e));t.getLabel().setLocation(e,n)},build:function(t){return this.findCoveredLineEdges(),this.collectLines(t),this.buildLines(t),this.resultLineList},collectLineEdge:function(t,e,n){var i=t.getLabel(),r=t.getEdge();t.isLineEdge()&&(t.isVisited()||!ii.isResultOfOp(i,e)||r.isCovered()||(n.add(r),t.setVisitedEdge(!0)))},findCoveredLineEdges:function(){for(var t=this.op.getGraph().getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().findCoveredLineEdges()}for(var n=this.op.getGraph().getEdgeEnds().iterator();n.hasNext();){var i=n.next(),r=i.getEdge();if(i.isLineEdge()&&!r.isCoveredSet()){var s=this.op.isCoveredByA(i.getCoordinate());r.setCovered(s)}}},labelIsolatedLines:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(i.isNull(0)?this.labelIsolatedLine(n,0):this.labelIsolatedLine(n,1))}},buildLines:function(t){for(var e=this.lineEdgesList.iterator();e.hasNext();){var n=e.next(),i=(n.getLabel(),this.geometryFactory.createLineString(n.getCoordinates()));this.resultLineList.add(i),n.setInResult(!0)}},collectBoundaryTouchEdge:function(t,e,n){var i=t.getLabel();return t.isLineEdge()?null:t.isVisited()?null:t.isInteriorAreaEdge()?null:t.getEdge().isInResult()?null:(f.isTrue(!(t.isInResult()||t.getSym().isInResult())||!t.getEdge().isInResult()),void(ii.isResultOfOp(i,e)&&e===ii.INTERSECTION&&(n.add(t.getEdge()),t.setVisitedEdge(!0))))},interfaces_:function(){return[]},getClass:function(){return wn}}),e(Ln.prototype,{filterCoveredNodeToPoint:function(t){var e=t.getCoordinate();if(!this.op.isCoveredByLA(e)){var n=this.geometryFactory.createPoint(e);this.resultPointList.add(n)}},extractNonCoveredResultNodes:function(t){for(var e=this.op.getGraph().getNodes().iterator();e.hasNext();){var n=e.next();if(!(n.isInResult()||n.isIncidentEdgeInResult()||0!==n.getEdges().getDegree()&&t!==ii.INTERSECTION)){var i=n.getLabel();ii.isResultOfOp(i,t)&&this.filterCoveredNodeToPoint(n)}}},build:function(t){return this.extractNonCoveredResultNodes(t),this.resultPointList},interfaces_:function(){return[]},getClass:function(){return Ln}}),e(Rn.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return Rn}}),e(Tn.prototype,{locate:function(t){return Tn.locate(t,this.geom)},interfaces_:function(){return[Rn]},getClass:function(){return Tn}}),Tn.isPointInRing=function(t,e){return e.getEnvelopeInternal().intersects(t)?he.isPointInRing(t,e.getCoordinates()):!1},Tn.containsPointInPolygon=function(t,e){if(e.isEmpty())return!1;var n=e.getExteriorRing();if(!Tn.isPointInRing(t,n))return!1;for(var i=0;i<e.getNumInteriorRing();i++){var r=e.getInteriorRingN(i);if(Tn.isPointInRing(t,r))return!1}return!0},Tn.containsPoint=function(t,e){if(e instanceof Tt)return Tn.containsPointInPolygon(t,e);if(e instanceof ft)for(var n=new Re(e);n.hasNext();){var i=n.next();if(i!==e&&Tn.containsPoint(t,i))return!0}return!1},Tn.locate=function(t,e){return e.isEmpty()?L.EXTERIOR:Tn.containsPoint(t,e)?L.INTERIOR:L.EXTERIOR},e(Pn.prototype,{getNextCW:function(t){this.getEdges();var e=this.edgeList.indexOf(t),n=e-1;return 0===e&&(n=this.edgeList.size()-1),this.edgeList.get(n)},propagateSideLabels:function(t){for(var e=L.NONE,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();r.isArea(t)&&r.getLocation(t,cn.LEFT)!==L.NONE&&(e=r.getLocation(t,cn.LEFT))}if(e===L.NONE)return null;for(var s=e,n=this.iterator();n.hasNext();){var i=n.next(),r=i.getLabel();if(r.getLocation(t,cn.ON)===L.NONE&&r.setLocation(t,cn.ON,s),r.isArea(t)){var o=r.getLocation(t,cn.LEFT),a=r.getLocation(t,cn.RIGHT);if(a!==L.NONE){if(a!==s)throw new sn("side location conflict",i.getCoordinate());o===L.NONE&&f.shouldNeverReachHere("found single null side (at "+i.getCoordinate()+")"),s=o}else f.isTrue(r.getLocation(t,cn.LEFT)===L.NONE,"found single null side"),r.setLocation(t,cn.RIGHT,s),r.setLocation(t,cn.LEFT,s)}}},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},print:function(t){A.out.println("EdgeEndStar:   "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},isAreaLabelsConsistent:function(t){return this.computeEdgeEndLabels(t.getBoundaryNodeRule()),this.checkAreaLabelsConsistent(0)},checkAreaLabelsConsistent:function(t){var e=this.getEdges();if(e.size()<=0)return!0;var n=e.size()-1,i=e.get(n).getLabel(),r=i.getLocation(t,cn.LEFT);f.isTrue(r!==L.NONE,"Found unlabelled area edge");for(var s=r,o=this.iterator();o.hasNext();){var a=o.next(),u=a.getLabel();
f.isTrue(u.isArea(t),"Found non-area edge");var l=u.getLocation(t,cn.LEFT),h=u.getLocation(t,cn.RIGHT);if(l===h)return!1;if(h!==s)return!1;s=l}return!0},findIndex:function(t){this.iterator();for(var e=0;e<this.edgeList.size();e++){var n=this.edgeList.get(e);if(n===t)return e}return-1},iterator:function(){return this.getEdges().iterator()},getEdges:function(){return null===this.edgeList&&(this.edgeList=new I(this.edgeMap.values())),this.edgeList},getLocation:function(t,e,n){return this.ptInAreaLocation[t]===L.NONE&&(this.ptInAreaLocation[t]=Tn.locate(e,n[t].getGeometry())),this.ptInAreaLocation[t]},toString:function(){var t=new P;t.append("EdgeEndStar:   "+this.getCoordinate()),t.append("\n");for(var e=this.iterator();e.hasNext();){var n=e.next();t.append(n),t.append("\n")}return t.toString()},computeEdgeEndLabels:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.computeLabel(t)}},computeLabelling:function(t){this.computeEdgeEndLabels(t[0].getBoundaryNodeRule()),this.propagateSideLabels(0),this.propagateSideLabels(1);for(var e=[!1,!1],n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)r.isLine(s)&&r.getLocation(s)===L.BOUNDARY&&(e[s]=!0);for(var n=this.iterator();n.hasNext();)for(var i=n.next(),r=i.getLabel(),s=0;2>s;s++)if(r.isAnyNull(s)){var o=L.NONE;if(e[s])o=L.EXTERIOR;else{var a=i.getCoordinate();o=this.getLocation(s,a,t)}r.setAllLocationsIfNull(s,o)}},getDegree:function(){return this.edgeMap.size()},insertEdgeEnd:function(t,e){this.edgeMap.put(t,e),this.edgeList=null},interfaces_:function(){return[]},getClass:function(){return Pn}}),h(bn,Pn),e(bn.prototype,{linkResultDirectedEdges:function(){this.getResultAreaEdges();for(var t=null,e=null,n=this.SCANNING_FOR_INCOMING,i=0;i<this.resultAreaEdgeList.size();i++){var r=this.resultAreaEdgeList.get(i),s=r.getSym();if(r.getLabel().isArea())switch(null===t&&r.isInResult()&&(t=r),n){case this.SCANNING_FOR_INCOMING:if(!s.isInResult())continue;e=s,n=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(!r.isInResult())continue;e.setNext(r),n=this.SCANNING_FOR_INCOMING}}if(n===this.LINKING_TO_OUTGOING){if(null===t)throw new sn("no outgoing dirEdge found",this.getCoordinate());f.isTrue(t.isInResult(),"unable to link last incoming dirEdge"),e.setNext(t)}},insert:function(t){var e=t;this.insertEdgeEnd(e,e)},getRightmostEdge:function(){var t=this.getEdges(),e=t.size();if(1>e)return null;var n=t.get(0);if(1===e)return n;var i=t.get(e-1),r=n.getQuadrant(),s=i.getQuadrant();if(Je.isNorthern(r)&&Je.isNorthern(s))return n;if(!Je.isNorthern(r)&&!Je.isNorthern(s))return i;return 0!==n.getDy()?n:0!==i.getDy()?i:(f.shouldNeverReachHere("found two horizontal edges incident on node"),null)},print:function(t){A.out.println("DirectedEdgeStar: "+this.getCoordinate());for(var e=this.iterator();e.hasNext();){var n=e.next();t.print("out "),n.print(t),t.println(),t.print("in "),n.getSym().print(t),t.println()}},getResultAreaEdges:function(){if(null!==this.resultAreaEdgeList)return this.resultAreaEdgeList;this.resultAreaEdgeList=new I;for(var t=this.iterator();t.hasNext();){var e=t.next();(e.isInResult()||e.getSym().isInResult())&&this.resultAreaEdgeList.add(e)}return this.resultAreaEdgeList},updateLabelling:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.setAllLocationsIfNull(0,t.getLocation(0)),i.setAllLocationsIfNull(1,t.getLocation(1))}},linkAllDirectedEdges:function(){this.getEdges();for(var t=null,e=null,n=this.edgeList.size()-1;n>=0;n--){var i=this.edgeList.get(n),r=i.getSym();null===e&&(e=r),null!==t&&r.setNext(t),t=i}e.setNext(t)},computeDepths:function(){if(1===arguments.length){var t=arguments[0],e=this.findIndex(t),n=(t.getLabel(),t.getDepth(cn.LEFT)),i=t.getDepth(cn.RIGHT),r=this.computeDepths(e+1,this.edgeList.size(),n),s=this.computeDepths(0,e,r);if(s!==i)throw new sn("depth mismatch at "+t.getCoordinate())}else if(3===arguments.length){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=u,h=o;a>h;h++){var c=this.edgeList.get(h);c.getLabel();c.setEdgeDepths(cn.RIGHT,l),l=c.getDepth(cn.LEFT)}return l}},mergeSymLabels:function(){for(var t=this.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();n.merge(e.getSym().getLabel())}},linkMinimalDirectedEdges:function(t){for(var e=null,n=null,i=this.SCANNING_FOR_INCOMING,r=this.resultAreaEdgeList.size()-1;r>=0;r--){var s=this.resultAreaEdgeList.get(r),o=s.getSym();switch(null===e&&s.getEdgeRing()===t&&(e=s),i){case this.SCANNING_FOR_INCOMING:if(o.getEdgeRing()!==t)continue;n=o,i=this.LINKING_TO_OUTGOING;break;case this.LINKING_TO_OUTGOING:if(s.getEdgeRing()!==t)continue;n.setNextMin(s),i=this.SCANNING_FOR_INCOMING}}i===this.LINKING_TO_OUTGOING&&(f.isTrue(null!==e,"found null for first outgoing dirEdge"),f.isTrue(e.getEdgeRing()===t,"unable to link last incoming dirEdge"),n.setNextMin(e))},getOutgoingDegree:function(){if(0===arguments.length){for(var t=0,e=this.iterator();e.hasNext();){var n=e.next();n.isInResult()&&t++}return t}if(1===arguments.length){for(var i=arguments[0],t=0,e=this.iterator();e.hasNext();){var n=e.next();n.getEdgeRing()===i&&t++}return t}},getLabel:function(){return this.label},findCoveredLineEdges:function(){for(var t=L.NONE,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();if(!n.isLineEdge()){if(n.isInResult()){t=L.INTERIOR;break}if(i.isInResult()){t=L.EXTERIOR;break}}}if(t===L.NONE)return null;for(var r=t,e=this.iterator();e.hasNext();){var n=e.next(),i=n.getSym();n.isLineEdge()?n.getEdge().setCovered(r===L.INTERIOR):(n.isInResult()&&(r=L.EXTERIOR),i.isInResult()&&(r=L.INTERIOR))}},computeLabelling:function(t){Pn.prototype.computeLabelling.call(this,t),this.label=new gn(L.NONE);for(var e=this.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge(),r=i.getLabel(),s=0;2>s;s++){var o=r.getLocation(s);o!==L.INTERIOR&&o!==L.BOUNDARY||this.label.setLocation(s,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return bn}}),h(On,Nn),e(On.prototype,{createNode:function(t){return new yn(t,new bn)},interfaces_:function(){return[]},getClass:function(){return On}}),e(_n.prototype,{computeIntersections:function(t,e){this.mce.computeIntersectsForChain(this.chainIndex,t.mce,t.chainIndex,e)},interfaces_:function(){return[]},getClass:function(){return _n}}),e(Mn.prototype,{isDelete:function(){return this.eventType===Mn.DELETE},setDeleteEventIndex:function(t){this.deleteEventIndex=t},getObject:function(){return this.obj},compareTo:function(t){var e=t;return this.xValue<e.xValue?-1:this.xValue>e.xValue?1:this.eventType<e.eventType?-1:this.eventType>e.eventType?1:0},getInsertEvent:function(){return this.insertEvent},isInsert:function(){return this.eventType===Mn.INSERT},isSameLabel:function(t){return null===this.label?!1:this.label===t.label},getDeleteEventIndex:function(){return this.deleteEventIndex},interfaces_:function(){return[s]},getClass:function(){return Mn}}),Mn.INSERT=1,Mn.DELETE=2,e(Dn.prototype,{interfaces_:function(){return[]},getClass:function(){return Dn}}),e(An.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(An.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.getNumPoints()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},setIsDoneIfProperInt:function(t){this.isDoneWhenProperInt=t},hasProperInteriorIntersection:function(){return this.hasProperInterior},isBoundaryPointInternal:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinate();if(t.isIntersection(r))return!0}return!1},hasProperIntersection:function(){return this.hasProper},hasIntersection:function(){return this._hasIntersection},isDone:function(){return this._isDone},isBoundaryPoint:function(t,e){return null===e?!1:this.isBoundaryPointInternal(t,e[0])?!0:!!this.isBoundaryPointInternal(t,e[1])},setBoundaryNodes:function(t,e){this.bdyNodes=new Array(2).fill(null),this.bdyNodes[0]=t,this.bdyNodes[1]=e},addIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.recordIsolated&&(t.setIsolated(!1),n.setIsolated(!1)),this.numIntersections++,this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,!this.includeProper&&this.li.isProper()||(t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)),this.li.isProper()&&(this.properIntersectionPoint=this.li.getIntersection(0).copy(),this.hasProper=!0,this.isDoneWhenProperInt&&(this._isDone=!0),this.isBoundaryPoint(this.li,this.bdyNodes)||(this.hasProperInterior=!0))))},interfaces_:function(){return[]},getClass:function(){return An}}),An.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},h(Fn,Dn),e(Fn.prototype,{prepareEvents:function(){ho.sort(this.events);for(var t=0;t<this.events.size();t++){var e=this.events.get(t);e.isDelete()&&e.getInsertEvent().setDeleteEventIndex(t)}},computeIntersections:function(){if(1===arguments.length){var t=arguments[0];this.nOverlaps=0,this.prepareEvents();for(var e=0;e<this.events.size();e++){var n=this.events.get(e);if(n.isInsert()&&this.processOverlaps(e,n.getDeleteEventIndex(),n,t),t.isDone())break}}else if(3===arguments.length)if(arguments[2]instanceof An&&R(arguments[0],y)&&R(arguments[1],y)){var i=arguments[0],r=arguments[1],s=arguments[2];this.addEdges(i,i),this.addEdges(r,r),this.computeIntersections(s)}else if("boolean"==typeof arguments[2]&&R(arguments[0],y)&&arguments[1]instanceof An){var o=arguments[0],a=arguments[1],u=arguments[2];u?this.addEdges(o,null):this.addEdges(o),this.computeIntersections(a)}},addEdge:function(t,e){for(var n=t.getMonotoneChainEdge(),i=n.getStartIndexes(),r=0;r<i.length-1;r++){var s=new _n(n,r),o=new Mn(e,n.getMinX(r),s);this.events.add(o),this.events.add(new Mn(n.getMaxX(r),o))}},processOverlaps:function(t,e,n,i){for(var r=n.getObject(),s=t;e>s;s++){var o=this.events.get(s);if(o.isInsert()){var a=o.getObject();n.isSameLabel(o)||(r.computeIntersections(a,i),this.nOverlaps++)}}},addEdges:function(){if(1===arguments.length)for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.addEdge(n,n)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],e=i.iterator();e.hasNext();){var n=e.next();this.addEdge(n,r)}},interfaces_:function(){return[]},getClass:function(){return Fn}}),e(Gn.prototype,{getMin:function(){return this.min},intersects:function(t,e){return!(this.min>e||this.max<t)},getMax:function(){return this.max},toString:function(){return se.toLineString(new g(this.min,0),new g(this.max,0))},interfaces_:function(){return[]},getClass:function(){return Gn}}),e(qn.prototype,{compare:function(t,e){var n=t,i=e,r=(n.min+n.max)/2,s=(i.min+i.max)/2;return s>r?-1:r>s?1:0},interfaces_:function(){return[a]},getClass:function(){return qn}}),Gn.NodeComparator=qn,h(Bn,Gn),e(Bn.prototype,{query:function(t,e,n){return this.intersects(t,e)?void n.visitItem(this.item):null},interfaces_:function(){return[]},getClass:function(){return Bn}}),h(zn,Gn),e(zn.prototype,{buildExtent:function(t,e){this.min=Math.min(t.min,e.min),this.max=Math.max(t.max,e.max)},query:function(t,e,n){return this.intersects(t,e)?(null!==this.node1&&this.node1.query(t,e,n),void(null!==this.node2&&this.node2.query(t,e,n))):null},interfaces_:function(){return[]},getClass:function(){return zn}}),e(Vn.prototype,{buildTree:function(){ho.sort(this.leaves,new IntervalRTreeNode.NodeComparator);for(var t=this.leaves,e=null,n=new I;;){if(this.buildLevel(t,n),1===n.size())return n.get(0);e=t,t=n,n=e}},insert:function(t,e,n){if(null!==this.root)throw new IllegalStateException("Index cannot be added to once it has been queried");this.leaves.add(new Bn(t,e,n))},query:function(t,e,n){this.init(),this.root.query(t,e,n)},buildRoot:function(){return null!==this.root?null:void(this.root=this.buildTree())},printNode:function(t){A.out.println(se.toLineString(new g(t.min,this.level),new g(t.max,this.level)))},init:function(){return null!==this.root?null:void this.buildRoot()},buildLevel:function(t,e){this.level++,e.clear();for(var n=0;n<t.size();n+=2){var i=t.get(n),r=n+1<t.size()?t.get(n):null;if(null===r)e.add(i);else{var s=new zn(t.get(n),t.get(n+1));e.add(s)}}},interfaces_:function(){return[]},getClass:function(){return Vn}}),e(kn.prototype,{filter:function(t){if(this.isForcedToLineString&&t instanceof bt){var e=t.getFactory().createLineString(t.getCoordinateSequence());return this.lines.add(e),null}t instanceof St&&this.lines.add(t)},setForceToLineString:function(t){this.isForcedToLineString=t},interfaces_:function(){return[q]},getClass:function(){return kn}}),kn.getGeometry=function(){if(1===arguments.length){var t=arguments[0];return t.getFactory().buildGeometry(kn.getLines(t))}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e.getFactory().buildGeometry(kn.getLines(e,n))}},kn.getLines=function(){if(1===arguments.length){var t=arguments[0];return kn.getLines(t,!1)}if(2===arguments.length){if(R(arguments[0],v)&&R(arguments[1],v)){for(var e=arguments[0],n=arguments[1],i=e.iterator();i.hasNext();){var r=i.next();kn.getLines(r,n)}return n}if(arguments[0]instanceof B&&"boolean"==typeof arguments[1]){var s=arguments[0],o=arguments[1],a=new I;return s.apply(new kn(a,o)),a}if(arguments[0]instanceof B&&R(arguments[1],v)){var u=arguments[0],l=arguments[1];return u instanceof St?l.add(u):u.apply(new kn(l)),l}}else if(3===arguments.length){if("boolean"==typeof arguments[2]&&R(arguments[0],v)&&R(arguments[1],v)){for(var h=arguments[0],c=arguments[1],f=arguments[2],i=h.iterator();i.hasNext();){var r=i.next();kn.getLines(r,c,f)}return c}if("boolean"==typeof arguments[2]&&arguments[0]instanceof B&&R(arguments[1],v)){var g=arguments[0],d=arguments[1],p=arguments[2];return g.apply(new kn(d,p)),d}}},e(Yn.prototype,{visitItem:function(t){this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return Yn}}),e(Un.prototype,{locate:function(t){var e=new le(t),n=new Xn(e);return this.index.query(t.y,t.y,n),e.getLocation()},interfaces_:function(){return[Rn]},getClass:function(){return Un}}),e(Xn.prototype,{visitItem:function(t){var e=t;this.counter.countSegment(e.getCoordinate(0),e.getCoordinate(1))},interfaces_:function(){return[Ae]},getClass:function(){return Xn}}),e(Hn.prototype,{init:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next(),r=i.getCoordinates();this.addLine(r)}},addLine:function(t){for(var e=1;e<t.length;e++){var n=new ce(t[e-1],t[e]),i=Math.min(n.p0.y,n.p1.y),r=Math.max(n.p0.y,n.p1.y);this.index.insert(i,r,n)}},query:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yn;return this.index.query(t,e,n),n.getItems()}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];this.index.query(i,r,s)}},interfaces_:function(){return[]},getClass:function(){return Hn}}),Un.SegmentVisitor=Xn,Un.IntervalIndexedGeometry=Hn,e(Wn.prototype,{getSegmentIndex:function(){return this.segmentIndex},getCoordinate:function(){return this.coord},print:function(t){t.print(this.coord),t.print(" seg # = "+this.segmentIndex),t.println(" dist = "+this.dist)},compareTo:function(t){var e=t;return this.compare(e.segmentIndex,e.dist)},isEndPoint:function(t){return 0===this.segmentIndex&&0===this.dist?!0:this.segmentIndex===t},toString:function(){return this.coord+" seg # = "+this.segmentIndex+" dist = "+this.dist},getDistance:function(){return this.dist},compare:function(t,e){return this.segmentIndex<t?-1:this.segmentIndex>t?1:this.dist<e?-1:this.dist>e?1:0},interfaces_:function(){return[s]},getClass:function(){return Wn}}),e(jn.prototype,{print:function(t){t.println("Intersections:");for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t)}},iterator:function(){return this.nodeMap.values().iterator()},addSplitEdges:function(t){this.addEndpoints();for(var e=this.iterator(),n=e.next();e.hasNext();){var i=e.next(),r=this.createSplitEdge(n,i);t.add(r),n=i}},addEndpoints:function(){var t=this.edge.pts.length-1;this.add(this.edge.pts[0],0,0),this.add(this.edge.pts[t],t,0)},createSplitEdge:function(t,e){var n=e.segmentIndex-t.segmentIndex+2,i=this.edge.pts[e.segmentIndex],r=e.dist>0||!e.coord.equals2D(i);r||n--;var s=new Array(n).fill(null),o=0;s[o++]=new g(t.coord);for(var a=t.segmentIndex+1;a<=e.segmentIndex;a++)s[o++]=this.edge.pts[a];return r&&(s[o]=e.coord),new Jn(s,new gn(this.edge.label))},add:function(t,e,n){var i=new Wn(t,e,n),r=this.nodeMap.get(i);return null!==r?r:(this.nodeMap.put(i,i),i)},isIntersection:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();if(n.coord.equals(t))return!0}return!1},interfaces_:function(){return[]},getClass:function(){return jn}}),e(Kn.prototype,{getChainStartIndices:function(t){var e=0,n=new I;n.add(new b(e));do{var i=this.findChainEnd(t,e);n.add(new b(i)),e=i}while(e<t.length-1);var r=Kn.toIntArray(n);return r},findChainEnd:function(t,e){for(var n=Je.quadrant(t[e],t[e+1]),i=e+1;i<t.length;){var r=Je.quadrant(t[i-1],t[i]);if(r!==n)break;i++}return i-1},interfaces_:function(){return[]},getClass:function(){return Kn}}),Kn.toIntArray=function(t){for(var e=new Array(t.size()).fill(null),n=0;n<e.length;n++)e[n]=t.get(n).intValue();return e},e(Zn.prototype,{getCoordinates:function(){return this.pts},getMaxX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return e>n?e:n},getMinX:function(t){var e=this.pts[this.startIndex[t]].x,n=this.pts[this.startIndex[t+1]].x;return n>e?e:n},computeIntersectsForChain:function(){if(4===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=arguments[3];this.computeIntersectsForChain(this.startIndex[t],this.startIndex[t+1],e,e.startIndex[n],e.startIndex[n+1],i)}else if(6===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],a=arguments[3],u=arguments[4],l=arguments[5],h=this.pts[r],c=this.pts[s],f=o.pts[a],g=o.pts[u];if(s-r===1&&u-a===1)return l.addIntersections(this.e,r,o.e,a),null;if(this.env1.init(h,c),this.env2.init(f,g),!this.env1.intersects(this.env2))return null;var d=Math.trunc((r+s)/2),p=Math.trunc((a+u)/2);d>r&&(p>a&&this.computeIntersectsForChain(r,d,o,a,p,l),u>p&&this.computeIntersectsForChain(r,d,o,p,u,l)),s>d&&(p>a&&this.computeIntersectsForChain(d,s,o,a,p,l),u>p&&this.computeIntersectsForChain(d,s,o,p,u,l))}},getStartIndexes:function(){return this.startIndex},computeIntersects:function(t,e){for(var n=0;n<this.startIndex.length-1;n++)for(var i=0;i<t.startIndex.length-1;i++)this.computeIntersectsForChain(n,t,i,e)},interfaces_:function(){return[]},getClass:function(){return Zn}}),e(Qn.prototype,{getDepth:function(t,e){return this.depth[t][e]},setDepth:function(t,e,n){this.depth[t][e]=n},isNull:function(){if(0===arguments.length){for(var t=0;2>t;t++)for(var e=0;3>e;e++)if(this.depth[t][e]!==Qn.NULL_VALUE)return!1;return!0}if(1===arguments.length){var n=arguments[0];return this.depth[n][1]===Qn.NULL_VALUE}if(2===arguments.length){var i=arguments[0],r=arguments[1];return this.depth[i][r]===Qn.NULL_VALUE}},normalize:function(){for(var t=0;2>t;t++)if(!this.isNull(t)){var e=this.depth[t][1];this.depth[t][2]<e&&(e=this.depth[t][2]),0>e&&(e=0);for(var n=1;3>n;n++){var i=0;this.depth[t][n]>e&&(i=1),this.depth[t][n]=i}}},getDelta:function(t){return this.depth[t][cn.RIGHT]-this.depth[t][cn.LEFT]},getLocation:function(t,e){return this.depth[t][e]<=0?L.EXTERIOR:L.INTERIOR},toString:function(){return"A: "+this.depth[0][1]+","+this.depth[0][2]+" B: "+this.depth[1][1]+","+this.depth[1][2]},add:function(){if(1===arguments.length)for(var t=arguments[0],e=0;2>e;e++)for(var n=1;3>n;n++){var i=t.getLocation(e,n);i!==L.EXTERIOR&&i!==L.INTERIOR||(this.isNull(e,n)?this.depth[e][n]=Qn.depthAtLocation(i):this.depth[e][n]+=Qn.depthAtLocation(i))}else if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];o===L.INTERIOR&&this.depth[r][s]++}},interfaces_:function(){return[]},getClass:function(){return Qn}}),Qn.depthAtLocation=function(t){return t===L.EXTERIOR?0:t===L.INTERIOR?1:Qn.NULL_VALUE},Qn.NULL_VALUE=-1,h(Jn,mn),e(Jn.prototype,{getDepth:function(){return this.depth},getCollapsedEdge:function(){var t=new Array(2).fill(null);t[0]=this.pts[0],t[1]=this.pts[1];var e=new Jn(t,gn.toLineLabel(this.label));return e},isIsolated:function(){return this._isIsolated},getCoordinates:function(){return this.pts},setIsolated:function(t){this._isIsolated=t},setName:function(t){this.name=t},equals:function(t){if(!(t instanceof Jn))return!1;var e=t;if(this.pts.length!==e.pts.length)return!1;for(var n=!0,i=!0,r=this.pts.length,s=0;s<this.pts.length;s++)if(this.pts[s].equals2D(e.pts[s])||(n=!1),this.pts[s].equals2D(e.pts[--r])||(i=!1),!n&&!i)return!1;return!0},getCoordinate:function(){if(0===arguments.length)return this.pts.length>0?this.pts[0]:null;if(1===arguments.length){var t=arguments[0];return this.pts[t]}},print:function(t){t.print("edge "+this.name+": "),t.print("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.print(","),t.print(this.pts[e].x+" "+this.pts[e].y);t.print(")  "+this.label+" "+this.depthDelta)},computeIM:function(t){Jn.updateIM(this.label,t)},isCollapsed:function(){return this.label.isArea()?3!==this.pts.length?!1:!!this.pts[0].equals(this.pts[2]):!1},isClosed:function(){return this.pts[0].equals(this.pts[this.pts.length-1])},getMaximumSegmentIndex:function(){return this.pts.length-1},getDepthDelta:function(){return this.depthDelta},getNumPoints:function(){return this.pts.length},printReverse:function(t){t.print("edge "+this.name+": ");for(var e=this.pts.length-1;e>=0;e--)t.print(this.pts[e]+" ");t.println("")},getMonotoneChainEdge:function(){return null===this.mce&&(this.mce=new Zn(this)),this.mce},getEnvelope:function(){if(null===this.env){this.env=new C;for(var t=0;t<this.pts.length;t++)this.env.expandToInclude(this.pts[t])}return this.env},addIntersection:function(t,e,n,i){var r=new g(t.getIntersection(i)),s=e,o=t.getEdgeDistance(n,i),a=s+1;if(a<this.pts.length){var u=this.pts[a];r.equals2D(u)&&(s=a,o=0)}this.eiList.add(r,s,o)},toString:function(){var t=new P;t.append("edge "+this.name+": "),t.append("LINESTRING (");for(var e=0;e<this.pts.length;e++)e>0&&t.append(","),t.append(this.pts[e].x+" "+this.pts[e].y);return t.append(")  "+this.label+" "+this.depthDelta),t.toString()},isPointwiseEqual:function(t){if(this.pts.length!==t.pts.length)return!1;for(var e=0;e<this.pts.length;e++)if(!this.pts[e].equals2D(t.pts[e]))return!1;return!0},setDepthDelta:function(t){this.depthDelta=t},getEdgeIntersectionList:function(){return this.eiList},addIntersections:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++)this.addIntersection(t,e,n,i)},interfaces_:function(){return[]},getClass:function(){return Jn}}),Jn.updateIM=function(){if(2!==arguments.length)return mn.prototype.updateIM.apply(this,arguments);var t=arguments[0],e=arguments[1];e.setAtLeastIfValid(t.getLocation(0,cn.ON),t.getLocation(1,cn.ON),1),t.isArea()&&(e.setAtLeastIfValid(t.getLocation(0,cn.LEFT),t.getLocation(1,cn.LEFT),2),e.setAtLeastIfValid(t.getLocation(0,cn.RIGHT),t.getLocation(1,cn.RIGHT),2))},h($n,Cn),e($n.prototype,{insertBoundaryPoint:function(t,e){var n=this.nodes.addNode(e),i=n.getLabel(),r=1,s=L.NONE;s=i.getLocation(t,cn.ON),s===L.BOUNDARY&&r++;var o=$n.determineBoundary(this.boundaryNodeRule,r);i.setLocation(t,o)},computeSelfNodes:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this.computeSelfNodes(t,e,!1)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2],s=new An(n,!0,!1);s.setIsDoneIfProperInt(r);var o=this.createEdgeSetIntersector(),a=this.parentGeom instanceof bt||this.parentGeom instanceof Tt||this.parentGeom instanceof Ot,u=i||!a;return o.computeIntersections(this.edges,s,u),this.addSelfIntersectionNodes(this.argIndex),s}},computeSplitEdges:function(t){for(var e=this.edges.iterator();e.hasNext();){var n=e.next();n.eiList.addSplitEdges(t)}},computeEdgeIntersections:function(t,e,n){var i=new An(e,n,!0);i.setBoundaryNodes(this.getBoundaryNodes(),t.getBoundaryNodes());var r=this.createEdgeSetIntersector();return r.computeIntersections(this.edges,t.edges,i),i},getGeometry:function(){return this.parentGeom},getBoundaryNodeRule:function(){return this.boundaryNodeRule},hasTooFewPoints:function(){return this._hasTooFewPoints},addPoint:function(){if(arguments[0]instanceof Lt){var t=arguments[0],e=t.getCoordinate();this.insertPoint(this.argIndex,e,L.INTERIOR)}else if(arguments[0]instanceof g){var n=arguments[0];this.insertPoint(this.argIndex,n,L.INTERIOR)}},addPolygon:function(t){this.addPolygonRing(t.getExteriorRing(),L.EXTERIOR,L.INTERIOR);for(var e=0;e<t.getNumInteriorRing();e++){var n=t.getInteriorRingN(e);this.addPolygonRing(n,L.INTERIOR,L.EXTERIOR)}},addEdge:function(t){this.insertEdge(t);var e=t.getCoordinates();this.insertPoint(this.argIndex,e[0],L.BOUNDARY),this.insertPoint(this.argIndex,e[e.length-1],L.BOUNDARY)},addLineString:function(t){var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return this._hasTooFewPoints=!0,this.invalidPoint=e[0],null;var n=new Jn(e,new gn(this.argIndex,L.INTERIOR));this.lineEdgeMap.put(t,n),this.insertEdge(n),f.isTrue(e.length>=2,"found LineString with single point"),this.insertBoundaryPoint(this.argIndex,e[0]),this.insertBoundaryPoint(this.argIndex,e[e.length-1])},getInvalidPoint:function(){return this.invalidPoint},getBoundaryPoints:function(){for(var t=this.getBoundaryNodes(),e=new Array(t.size()).fill(null),n=0,i=t.iterator();i.hasNext();){var r=i.next();e[n++]=r.getCoordinate().copy()}return e},getBoundaryNodes:function(){return null===this.boundaryNodes&&(this.boundaryNodes=this.nodes.getBoundaryNodes(this.argIndex)),this.boundaryNodes},addSelfIntersectionNode:function(t,e,n){return this.isBoundaryNode(t,e)?null:void(n===L.BOUNDARY&&this.useBoundaryDeterminationRule?this.insertBoundaryPoint(t,e):this.insertPoint(t,e,n))},addPolygonRing:function(t,e,n){if(t.isEmpty())return null;var i=H.removeRepeatedPoints(t.getCoordinates());if(i.length<4)return this._hasTooFewPoints=!0,this.invalidPoint=i[0],null;var r=e,s=n;he.isCCW(i)&&(r=n,s=e);var o=new Jn(i,new gn(this.argIndex,L.BOUNDARY,r,s));this.lineEdgeMap.put(t,o),this.insertEdge(o),this.insertPoint(this.argIndex,i[0],L.BOUNDARY)},insertPoint:function(t,e,n){var i=this.nodes.addNode(e),r=i.getLabel();null===r?i.label=new gn(t,n):r.setLocation(t,n)},createEdgeSetIntersector:function(){return new Fn},addSelfIntersectionNodes:function(t){for(var e=this.edges.iterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.eiList.iterator();r.hasNext();){var s=r.next();this.addSelfIntersectionNode(t,s.coord,i)}},add:function(){if(1!==arguments.length)return Cn.prototype.add.apply(this,arguments);var t=arguments[0];if(t.isEmpty())return null;if(t instanceof Ot&&(this.useBoundaryDeterminationRule=!1),t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},locate:function(t){return R(this.parentGeom,Rt)&&this.parentGeom.getNumGeometries()>50?(null===this.areaPtLocator&&(this.areaPtLocator=new Un(this.parentGeom)),this.areaPtLocator.locate(t)):this.ptLocator.locate(t,this.parentGeom)},findEdge:function(){if(1===arguments.length){var t=arguments[0];return this.lineEdgeMap.get(t)}return Cn.prototype.findEdge.apply(this,arguments)},interfaces_:function(){return[]},getClass:function(){return $n}}),$n.determineBoundary=function(t,e){return t.isInBoundary(e)?L.BOUNDARY:L.INTERIOR},e(ti.prototype,{getArgGeometry:function(t){return this.arg[t].getGeometry()},setComputationPrecision:function(t){this.resultPrecisionModel=t,this.li.setPrecisionModel(this.resultPrecisionModel)},interfaces_:function(){return[]},getClass:function(){return ti}}),e(ei.prototype,{compareTo:function(t){var e=t,n=ei.compareOriented(this.pts,this._orientation,e.pts,e._orientation);return n},interfaces_:function(){return[s]},getClass:function(){return ei}}),ei.orientation=function(t){return 1===H.increasingDirection(t)},ei.compareOriented=function(t,e,n,i){for(var r=e?1:-1,s=i?1:-1,o=e?t.length:-1,a=i?n.length:-1,u=e?0:t.length-1,l=i?0:n.length-1;;){var h=t[u].compareTo(n[l]);if(0!==h)return h;u+=r,l+=s;var c=u===o,f=l===a;if(c&&!f)return-1;if(!c&&f)return 1;if(c&&f)return 0}},e(ni.prototype,{print:function(t){t.print("MULTILINESTRING ( ");for(var e=0;e<this.edges.size();e++){var n=this.edges.get(e);e>0&&t.print(","),t.print("(");for(var i=n.getCoordinates(),r=0;r<i.length;r++)r>0&&t.print(","),t.print(i[r].x+" "+i[r].y);t.println(")")}t.print(")  ")},addAll:function(t){for(var e=t.iterator();e.hasNext();)this.add(e.next())},findEdgeIndex:function(t){for(var e=0;e<this.edges.size();e++)if(this.edges.get(e).equals(t))return e;return-1},iterator:function(){return this.edges.iterator()},getEdges:function(){return this.edges},get:function(t){return this.edges.get(t)},findEqualEdge:function(t){var e=new ei(t.getCoordinates()),n=this.ocaMap.get(e);return n},add:function(t){this.edges.add(t);var e=new ei(t.getCoordinates());this.ocaMap.put(e,t)},interfaces_:function(){return[]},getClass:function(){return ni}}),h(ii,ti),e(ii.prototype,{insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip());var r=e.getDepth();r.isNull()&&r.add(n),r.add(i),n.merge(i)}else this.edgeList.add(t)},getGraph:function(){return this.graph},cancelDuplicateResultEdges:function(){for(var t=this.graph.getEdgeEnds().iterator();t.hasNext();){var e=t.next(),n=e.getSym();e.isInResult()&&n.isInResult()&&(e.setInResult(!1),n.setInResult(!1))}},isCoveredByLA:function(t){return this.isCovered(t,this.resultLineList)?!0:!!this.isCovered(t,this.resultPolyList)},computeGeometry:function(t,e,n,i){var r=new I;return r.addAll(t),r.addAll(e),r.addAll(n),r.isEmpty()?ii.createEmptyResult(i,this.arg[0].getGeometry(),this.arg[1].getGeometry(),this.geomFact):this.geomFact.buildGeometry(r)},mergeSymLabels:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().mergeSymLabels()}},isCovered:function(t,e){for(var n=e.iterator();n.hasNext();){var i=n.next(),r=this.ptLocator.locate(t,i);if(r!==L.EXTERIOR)return!0}return!1},replaceCollapsedEdges:function(){for(var t=new I,e=this.edgeList.iterator();e.hasNext();){var n=e.next();n.isCollapsed()&&(e.remove(),t.add(n.getCollapsedEdge()))}this.edgeList.addAll(t)},updateNodeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next(),n=e.getEdges().getLabel();e.getLabel().merge(n)}},getResultGeometry:function(t){return this.computeOverlay(t),this.resultGeom},insertUniqueEdges:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertUniqueEdge(n)}},computeOverlay:function(t){this.copyPoints(0),this.copyPoints(1),this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1),this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!0);var e=new I;this.arg[0].computeSplitEdges(e),this.arg[1].computeSplitEdges(e);this.insertUniqueEdges(e),this.computeLabelsFromDepths(),this.replaceCollapsedEdges(),ln.checkValid(this.edgeList.getEdges()),this.graph.addEdges(this.edgeList.getEdges()),this.computeLabelling(),this.labelIncompleteNodes(),this.findResultAreaEdges(t),this.cancelDuplicateResultEdges();var n=new Sn(this.geomFact);n.add(this.graph),this.resultPolyList=n.getPolygons();var i=new wn(this,this.geomFact,this.ptLocator);this.resultLineList=i.build(t);var r=new Ln(this,this.geomFact,this.ptLocator);this.resultPointList=r.build(t),
this.resultGeom=this.computeGeometry(this.resultPointList,this.resultLineList,this.resultPolyList,t)},labelIncompleteNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setLocation(e,n)},copyPoints:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.graph.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},findResultAreaEdges:function(t){for(var e=this.graph.getEdgeEnds().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();i.isArea()&&!n.isInteriorAreaEdge()&&ii.isResultOfOp(i.getLocation(0,cn.RIGHT),i.getLocation(1,cn.RIGHT),t)&&n.setInResult(!0)}},computeLabelsFromDepths:function(){for(var t=this.edgeList.iterator();t.hasNext();){var e=t.next(),n=e.getLabel(),i=e.getDepth();if(!i.isNull()){i.normalize();for(var r=0;2>r;r++)n.isNull(r)||!n.isArea()||i.isNull(r)||(0===i.getDelta(r)?n.toLine(r):(f.isTrue(!i.isNull(r,cn.LEFT),"depth of LEFT side has not been initialized"),n.setLocation(r,cn.LEFT,i.getLocation(r,cn.LEFT)),f.isTrue(!i.isNull(r,cn.RIGHT),"depth of RIGHT side has not been initialized"),n.setLocation(r,cn.RIGHT,i.getLocation(r,cn.RIGHT))))}}},computeLabelling:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}this.mergeSymLabels(),this.updateNodeLabelling()},labelIncompleteNodes:function(){for(var t=0,e=this.graph.getNodes().iterator();e.hasNext();){var n=e.next(),i=n.getLabel();n.isIsolated()&&(t++,i.isNull(0)?this.labelIncompleteNode(n,0):this.labelIncompleteNode(n,1)),n.getEdges().updateLabelling(i)}},isCoveredByA:function(t){return!!this.isCovered(t,this.resultPolyList)},interfaces_:function(){return[]},getClass:function(){return ii}}),ii.overlayOp=function(t,e,n){var i=new ii(t,e),r=i.getResultGeometry(n);return r},ii.intersection=function(t,e){if(t.isEmpty()||e.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,t,e,t.getFactory());if(t.isGeometryCollection()){var n=e;return hn.map(t,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(n)}})}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.INTERSECTION)},ii.symDifference=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.SYMDIFFERENCE)},ii.resultDimension=function(t,e,n){var i=e.getDimension(),r=n.getDimension(),s=-1;switch(t){case ii.INTERSECTION:s=Math.min(i,r);break;case ii.UNION:s=Math.max(i,r);break;case ii.DIFFERENCE:s=i;break;case ii.SYMDIFFERENCE:s=Math.max(i,r)}return s},ii.createEmptyResult=function(t,e,n,i){var r=null;switch(ii.resultDimension(t,e,n)){case-1:r=i.createGeometryCollection(new Array(0).fill(null));break;case 0:r=i.createPoint();break;case 1:r=i.createLineString();break;case 2:r=i.createPolygon()}return r},ii.difference=function(t,e){return t.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,t,e,t.getFactory()):e.isEmpty()?t.copy():(t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.DIFFERENCE))},ii.isResultOfOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=t.getLocation(0),i=t.getLocation(1);return ii.isResultOfOp(n,i,e)}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2];switch(r===L.BOUNDARY&&(r=L.INTERIOR),s===L.BOUNDARY&&(s=L.INTERIOR),o){case ii.INTERSECTION:return r===L.INTERIOR&&s===L.INTERIOR;case ii.UNION:return r===L.INTERIOR||s===L.INTERIOR;case ii.DIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR;case ii.SYMDIFFERENCE:return r===L.INTERIOR&&s!==L.INTERIOR||r!==L.INTERIOR&&s===L.INTERIOR}return!1}},ii.INTERSECTION=1,ii.UNION=2,ii.DIFFERENCE=3,ii.SYMDIFFERENCE=4,e(ri.prototype,{selfSnap:function(t){var e=new Ie(t),n=e.snapTo(t,this.snapTolerance);return n},removeCommonBits:function(t){this.cbr=new Se,this.cbr.add(t[0]),this.cbr.add(t[1]);var e=new Array(2).fill(null);return e[0]=this.cbr.removeCommonBits(t[0].copy()),e[1]=this.cbr.removeCommonBits(t[1].copy()),e},prepareResult:function(t){return this.cbr.addCommonBits(t),t},getResultGeometry:function(t){var e=this.snap(this.geom),n=ii.overlayOp(e[0],e[1],t);return this.prepareResult(n)},checkValid:function(t){t.isValid()||A.out.println("Snapped geometry is invalid")},computeSnapTolerance:function(){this.snapTolerance=Ie.computeOverlaySnapTolerance(this.geom[0],this.geom[1])},snap:function(t){var e=this.removeCommonBits(t),n=Ie.snap(e[0],e[1],this.snapTolerance);return n},interfaces_:function(){return[]},getClass:function(){return ri}}),ri.overlayOp=function(t,e,n){var i=new ri(t,e);return i.getResultGeometry(n)},ri.union=function(t,e){return ri.overlayOp(t,e,ii.UNION)},ri.intersection=function(t,e){return ri.overlayOp(t,e,ii.INTERSECTION)},ri.symDifference=function(t,e){return ri.overlayOp(t,e,ii.SYMDIFFERENCE)},ri.difference=function(t,e){return ri.overlayOp(t,e,ii.DIFFERENCE)},e(si.prototype,{getResultGeometry:function(t){var e=null,n=!1,i=null;try{e=ii.overlayOp(this.geom[0],this.geom[1],t);var r=!0;r&&(n=!0)}catch(t){if(!(t instanceof l))throw t;i=t}finally{}if(!n)try{e=ri.overlayOp(this.geom[0],this.geom[1],t)}catch(t){throw t instanceof l?i:t}finally{}return e},interfaces_:function(){return[]},getClass:function(){return si}}),si.overlayOp=function(t,e,n){var i=new si(t,e);return i.getResultGeometry(n)},si.union=function(t,e){return si.overlayOp(t,e,ii.UNION)},si.intersection=function(t,e){return si.overlayOp(t,e,ii.INTERSECTION)},si.symDifference=function(t,e){return si.overlayOp(t,e,ii.SYMDIFFERENCE)},si.difference=function(t,e){return si.overlayOp(t,e,ii.DIFFERENCE)},e(oi.prototype,{addPolygon:function(t){if(t.isEmpty())return null;var e=null,n=0,i=this.horizontalBisector(t);if(0===i.getLength())n=0,e=i.getCoordinate();else{var r=si.overlayOp(i,t,ii.INTERSECTION),s=this.widestGeometry(r);n=s.getEnvelopeInternal().getWidth(),e=oi.centre(s.getEnvelopeInternal())}(null===this.interiorPoint||n>this.maxWidth)&&(this.interiorPoint=e,this.maxWidth=n)},getInteriorPoint:function(){return this.interiorPoint},widestGeometry:function t(){if(arguments[0]instanceof ft){var e=arguments[0];if(e.isEmpty())return e;for(var t=e.getGeometryN(0),n=1;n<e.getNumGeometries();n++)e.getGeometryN(n).getEnvelopeInternal().getWidth()>t.getEnvelopeInternal().getWidth()&&(t=e.getGeometryN(n));return t}if(arguments[0]instanceof B){var i=arguments[0];return i instanceof ft?this.widestGeometry(i):i}},horizontalBisector:function(t){var e=t.getEnvelopeInternal(),n=ai.getBisectorY(t);return this.factory.createLineString([new g(e.getMinX(),n),new g(e.getMaxX(),n)])},add:function(t){if(t instanceof Tt)this.addPolygon(t);else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))},interfaces_:function(){return[]},getClass:function(){return oi}}),oi.centre=function(t){return new g(oi.avg(t.getMinX(),t.getMaxX()),oi.avg(t.getMinY(),t.getMaxY()))},oi.avg=function(t,e){return(t+e)/2},e(ai.prototype,{updateInterval:function(t){t<=this.centreY?t>this.loY&&(this.loY=t):t>this.centreY&&t<this.hiY&&(this.hiY=t)},getBisectorY:function(){this.process(this.poly.getExteriorRing());for(var t=0;t<this.poly.getNumInteriorRing();t++)this.process(this.poly.getInteriorRingN(t));var e=oi.avg(this.hiY,this.loY);return e},process:function(t){for(var e=t.getCoordinateSequence(),n=0;n<e.size();n++){var i=e.getY(n);this.updateInterval(i)}},interfaces_:function(){return[]},getClass:function(){return ai}}),ai.getBisectorY=function(t){var e=new ai(t);return e.getBisectorY()},oi.SafeBisectorFinder=ai,e(ui.prototype,{addEndpoints:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addEndpoints(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addEndpoints(e.getGeometryN(n))}else if(arguments[0]instanceof Array){var i=arguments[0];this.add(i[0]),this.add(i[i.length-1])}},getInteriorPoint:function(){return this.interiorPoint},addInterior:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof St)this.addInterior(t.getCoordinates());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.addInterior(e.getGeometryN(n))}else if(arguments[0]instanceof Array)for(var i=arguments[0],n=1;n<i.length-1;n++)this.add(i[n])},add:function(t){var e=t.distance(this.centroid);e<this.minDistance&&(this.interiorPoint=new g(t),this.minDistance=e)},interfaces_:function(){return[]},getClass:function(){return ui}}),e(li.prototype,{getInteriorPoint:function(){return this.interiorPoint},add:function(){if(arguments[0]instanceof B){var t=arguments[0];if(t instanceof Lt)this.add(t.getCoordinate());else if(t instanceof ft)for(var e=t,n=0;n<e.getNumGeometries();n++)this.add(e.getGeometryN(n))}else if(arguments[0]instanceof g){var i=arguments[0],r=i.distance(this.centroid);r<this.minDistance&&(this.interiorPoint=new g(i),this.minDistance=r)}},interfaces_:function(){return[]},getClass:function(){return li}}),e(hi.prototype,{interfaces_:function(){return[]},getClass:function(){return hi}}),hi.toDegrees=function(t){return 180*t/Math.PI},hi.normalize=function(t){for(;t>Math.PI;)t-=hi.PI_TIMES_2;for(;t<=-Math.PI;)t+=hi.PI_TIMES_2;return t},hi.angle=function(){if(1===arguments.length){var t=arguments[0];return Math.atan2(t.y,t.x)}if(2===arguments.length){var e=arguments[0],n=arguments[1],i=n.x-e.x,r=n.y-e.y;return Math.atan2(r,i)}},hi.isAcute=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return a>0},hi.isObtuse=function(t,e,n){var i=t.x-e.x,r=t.y-e.y,s=n.x-e.x,o=n.y-e.y,a=i*s+r*o;return 0>a},hi.interiorAngle=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return Math.abs(r-i)},hi.normalizePositive=function(t){if(0>t){for(;0>t;)t+=hi.PI_TIMES_2;t>=hi.PI_TIMES_2&&(t=0)}else{for(;t>=hi.PI_TIMES_2;)t-=hi.PI_TIMES_2;0>t&&(t=0)}return t},hi.angleBetween=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n);return hi.diff(i,r)},hi.diff=function(t,e){var n=null;return n=e>t?e-t:t-e,n>Math.PI&&(n=2*Math.PI-n),n},hi.toRadians=function(t){return t*Math.PI/180},hi.getTurn=function(t,e){var n=Math.sin(e-t);return n>0?hi.COUNTERCLOCKWISE:0>n?hi.CLOCKWISE:hi.NONE},hi.angleBetweenOriented=function(t,e,n){var i=hi.angle(e,t),r=hi.angle(e,n),s=r-i;return s<=-Math.PI?s+hi.PI_TIMES_2:s>Math.PI?s-hi.PI_TIMES_2:s},hi.PI_TIMES_2=2*Math.PI,hi.PI_OVER_2=Math.PI/2,hi.PI_OVER_4=Math.PI/4,hi.COUNTERCLOCKWISE=he.COUNTERCLOCKWISE,hi.CLOCKWISE=he.CLOCKWISE,hi.NONE=he.COLLINEAR,e(ci.prototype,{area:function(){return ci.area(this.p0,this.p1,this.p2)},signedArea:function(){return ci.signedArea(this.p0,this.p1,this.p2)},interpolateZ:function(t){if(null===t)throw new i("Supplied point is null.");return ci.interpolateZ(t,this.p0,this.p1,this.p2)},longestSideLength:function(){return ci.longestSideLength(this.p0,this.p1,this.p2)},isAcute:function(){return ci.isAcute(this.p0,this.p1,this.p2)},circumcentre:function(){return ci.circumcentre(this.p0,this.p1,this.p2)},area3D:function(){return ci.area3D(this.p0,this.p1,this.p2)},centroid:function(){return ci.centroid(this.p0,this.p1,this.p2)},inCentre:function(){return ci.inCentre(this.p0,this.p1,this.p2)},interfaces_:function(){return[]},getClass:function(){return ci}}),ci.area=function(t,e,n){return Math.abs(((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2)},ci.signedArea=function(t,e,n){return((n.x-t.x)*(e.y-t.y)-(e.x-t.x)*(n.y-t.y))/2},ci.det=function(t,e,n,i){return t*i-e*n},ci.interpolateZ=function(t,e,n,i){var r=e.x,s=e.y,o=n.x-r,a=i.x-r,u=n.y-s,l=i.y-s,h=o*l-a*u,c=t.x-r,f=t.y-s,g=(l*c-a*f)/h,d=(-u*c+o*f)/h,p=e.z+g*(n.z-e.z)+d*(i.z-e.z);return p},ci.longestSideLength=function(t,e,n){var i=t.distance(e),r=e.distance(n),s=n.distance(t),o=i;return r>o&&(o=r),s>o&&(o=s),o},ci.isAcute=function(t,e,n){return hi.isAcute(t,e,n)&&hi.isAcute(e,n,t)?!!hi.isAcute(n,t,e):!1},ci.circumcentre=function(t,e,n){var i=n.x,r=n.y,s=t.x-i,o=t.y-r,a=e.x-i,u=e.y-r,l=2*ci.det(s,o,a,u),h=ci.det(o,s*s+o*o,u,a*a+u*u),c=ci.det(s,s*s+o*o,a,a*a+u*u),f=i-h/l,d=r+c/l;return new g(f,d)},ci.perpendicularBisector=function(t,e){var n=e.x-t.x,i=e.y-t.y,r=new F(t.x+n/2,t.y+i/2,1),s=new F(t.x-i+n/2,t.y+n+i/2,1);return new F(r,s)},ci.angleBisector=function(t,e,n){var i=e.distance(t),r=e.distance(n),s=i/(i+r),o=n.x-t.x,a=n.y-t.y,u=new g(t.x+s*o,t.y+s*a);return u},ci.area3D=function(t,e,n){var i=e.x-t.x,r=e.y-t.y,s=e.z-t.z,o=n.x-t.x,a=n.y-t.y,u=n.z-t.z,l=r*u-s*a,h=s*o-i*u,c=i*a-r*o,f=l*l+h*h+c*c,g=Math.sqrt(f)/2;return g},ci.centroid=function(t,e,n){var i=(t.x+e.x+n.x)/3,r=(t.y+e.y+n.y)/3;return new g(i,r)},ci.inCentre=function(t,e,n){var i=e.distance(n),r=t.distance(n),s=t.distance(e),o=i+r+s,a=(i*t.x+r*e.x+s*n.x)/o,u=(i*t.y+r*e.y+s*n.y)/o;return new g(a,u)},e(fi.prototype,{getRadius:function(){return this.compute(),this.radius},getDiameter:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[1];return this.input.getFactory().createLineString([t,e])},getExtremalPoints:function(){return this.compute(),this.extremalPts},computeCirclePoints:function(){if(this.input.isEmpty())return this.extremalPts=new Array(0).fill(null),null;if(1===this.input.getNumPoints()){var t=this.input.getCoordinates();return this.extremalPts=[new g(t[0])],null}var e=this.input.convexHull(),n=e.getCoordinates(),t=n;if(n[0].equals2D(n[n.length-1])&&(t=new Array(n.length-1).fill(null),H.copyDeep(n,0,t,0,n.length-1)),t.length<=2)return this.extremalPts=H.copyDeep(t),null;for(var i=fi.lowestPoint(t),r=fi.pointWitMinAngleWithX(t,i),s=0;s<t.length;s++){var o=fi.pointWithMinAngleWithSegment(t,i,r);if(hi.isObtuse(i,o,r))return this.extremalPts=[new g(i),new g(r)],null;if(hi.isObtuse(o,i,r))i=o;else{if(!hi.isObtuse(o,r,i))return this.extremalPts=[new g(i),new g(r),new g(o)],null;r=o}}f.shouldNeverReachHere("Logic failure in Minimum Bounding Circle algorithm!")},compute:function(){return null!==this.extremalPts?null:(this.computeCirclePoints(),this.computeCentre(),void(null!==this.centre&&(this.radius=this.centre.distance(this.extremalPts[0]))))},getFarthestPoints:function(){switch(this.compute(),this.extremalPts.length){case 0:return this.input.getFactory().createLineString();case 1:return this.input.getFactory().createPoint(this.centre)}var t=this.extremalPts[0],e=this.extremalPts[this.extremalPts.length-1];return this.input.getFactory().createLineString([t,e])},getCircle:function(){if(this.compute(),null===this.centre)return this.input.getFactory().createPolygon();var t=this.input.getFactory().createPoint(this.centre);return 0===this.radius?t:t.buffer(this.radius)},getCentre:function(){return this.compute(),this.centre},computeCentre:function(){switch(this.extremalPts.length){case 0:this.centre=null;break;case 1:this.centre=this.extremalPts[0];break;case 2:this.centre=new g((this.extremalPts[0].x+this.extremalPts[1].x)/2,(this.extremalPts[0].y+this.extremalPts[1].y)/2);break;case 3:this.centre=ci.circumcentre(this.extremalPts[0],this.extremalPts[1],this.extremalPts[2])}},interfaces_:function(){return[]},getClass:function(){return fi}}),fi.pointWitMinAngleWithX=function(t,e){for(var n=r.MAX_VALUE,i=null,s=0;s<t.length;s++){var o=t[s];if(o!==e){var a=o.x-e.x,u=o.y-e.y;0>u&&(u=-u);var l=Math.sqrt(a*a+u*u),h=u/l;n>h&&(n=h,i=o)}}return i},fi.lowestPoint=function(t){for(var e=t[0],n=1;n<t.length;n++)t[n].y<e.y&&(e=t[n]);return e},fi.pointWithMinAngleWithSegment=function(t,e,n){for(var i=r.MAX_VALUE,s=null,o=0;o<t.length;o++){var a=t[o];if(a!==e&&a!==n){var u=hi.angleBetween(e,a,n);i>u&&(i=u,s=a)}}return s},e(gi.prototype,{getWidthCoordinate:function(){return this.computeMinimumDiameter(),this.minWidthPt},getSupportingSegment:function(){return this.computeMinimumDiameter(),this.inputGeom.getFactory().createLineString([this.minBaseSeg.p0,this.minBaseSeg.p1])},getDiameter:function(){if(this.computeMinimumDiameter(),null===this.minWidthPt)return this.inputGeom.getFactory().createLineString(null);var t=this.minBaseSeg.project(this.minWidthPt);return this.inputGeom.getFactory().createLineString([t,this.minWidthPt])},computeWidthConvex:function(t){t instanceof Tt?this.convexHullPts=t.getExteriorRing().getCoordinates():this.convexHullPts=t.getCoordinates(),0===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=null,this.minBaseSeg=null):1===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[0]):2===this.convexHullPts.length||3===this.convexHullPts.length?(this.minWidth=0,this.minWidthPt=this.convexHullPts[0],this.minBaseSeg.p0=this.convexHullPts[0],this.minBaseSeg.p1=this.convexHullPts[1]):this.computeConvexRingMinDiameter(this.convexHullPts)},computeConvexRingMinDiameter:function(t){this.minWidth=r.MAX_VALUE;for(var e=1,n=new ce,i=0;i<t.length-1;i++)n.p0=t[i],n.p1=t[i+1],e=this.findMaxPerpDistance(t,n,e)},computeMinimumDiameter:function(){if(null!==this.minWidthPt)return null;if(this.isConvex)this.computeWidthConvex(this.inputGeom);else{var t=new me(this.inputGeom).getConvexHull();this.computeWidthConvex(t)}},getLength:function(){return this.computeMinimumDiameter(),this.minWidth},findMaxPerpDistance:function(t,e,n){for(var i=e.distancePerpendicular(t[n]),r=i,s=n,o=s;r>=i;)i=r,s=o,o=gi.nextIndex(t,s),r=e.distancePerpendicular(t[o]);return i<this.minWidth&&(this.minPtIndex=s,this.minWidth=i,this.minWidthPt=t[this.minPtIndex],this.minBaseSeg=new ce(e)),s},getMinimumRectangle:function(){if(this.computeMinimumDiameter(),0===this.minWidth)return this.minBaseSeg.p0.equals2D(this.minBaseSeg.p1)?this.inputGeom.getFactory().createPoint(this.minBaseSeg.p0):this.minBaseSeg.toGeometry(this.inputGeom.getFactory());for(var t=this.minBaseSeg.p1.x-this.minBaseSeg.p0.x,e=this.minBaseSeg.p1.y-this.minBaseSeg.p0.y,n=r.MAX_VALUE,i=-r.MAX_VALUE,s=r.MAX_VALUE,o=-r.MAX_VALUE,a=0;a<this.convexHullPts.length;a++){var u=gi.computeC(t,e,this.convexHullPts[a]);u>i&&(i=u),n>u&&(n=u);var l=gi.computeC(-e,t,this.convexHullPts[a]);l>o&&(o=l),s>l&&(s=l)}var h=gi.computeSegmentForLine(-t,-e,o),c=gi.computeSegmentForLine(-t,-e,s),f=gi.computeSegmentForLine(-e,t,i),g=gi.computeSegmentForLine(-e,t,n),d=f.lineIntersection(h),p=g.lineIntersection(h),v=g.lineIntersection(c),m=f.lineIntersection(c),y=this.inputGeom.getFactory().createLinearRing([d,p,v,m,d]);return this.inputGeom.getFactory().createPolygon(y,null)},interfaces_:function(){return[]},getClass:function(){return gi}}),gi.nextIndex=function(t,e){return e++,e>=t.length&&(e=0),e},gi.computeC=function(t,e,n){return t*n.y-e*n.x},gi.getMinimumDiameter=function(t){return new gi(t).getDiameter()},gi.getMinimumRectangle=function(t){return new gi(t).getMinimumRectangle()},gi.computeSegmentForLine=function(t,e,n){var i=null,r=null;return Math.abs(e)>Math.abs(t)?(i=new g(0,n/e),r=new g(1,n/e-t/e)):(i=new g(n/t,0),r=new g(n/t-e/t,1)),new ce(i,r)};var co=Object.freeze({Centroid:ge,CGAlgorithms:he,ConvexHull:me,InteriorPointArea:oi,InteriorPointLine:ui,InteriorPointPoint:li,RobustLineIntersector:ae,MinimumBoundingCircle:fi,MinimumDiameter:gi});e(di.prototype,{getResultGeometry:function(){return new pi(this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>=t)throw new i("Tolerance must be positive");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return di}}),di.densifyPoints=function(t,e,n){for(var i=new ce,r=new N,s=0;s<t.length-1;s++){i.p0=t[s],i.p1=t[s+1],r.add(i.p0,!1);var o=i.getLength(),a=Math.trunc(o/e)+1;if(a>1)for(var u=o/a,l=1;a>l;l++){var h=l*u/o,c=i.pointAlong(h);n.makePrecise(c),r.add(c,!1)}}return r.add(t[t.length-1],!1),r.toCoordinateArray()},di.densify=function(t,e){var n=new di(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(pi,xe),e(pi.prototype,{transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformPolygon:function(t,e){var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=di.densifyPoints(n,this.distanceTolerance,e.getPrecisionModel());return e instanceof St&&1===i.length&&(i=new Array(0).fill(null)),this.factory.getCoordinateSequenceFactory().create(i)},createValidArea:function(t){return t.buffer(0)},interfaces_:function(){return[]},getClass:function(){return pi}}),di.DensifyTransformer=pi;var fo=Object.freeze({Densifier:di});e(vi.prototype,{find:function(t){var e=this;do{if(null===e)return null;if(e.dest().equals2D(t))return e;e=e.oNext()}while(e!==this);return null},dest:function(){return this._sym._orig},oNext:function(){return this._sym._next},insert:function(t){if(this.oNext()===this)return this.insertAfter(t),null;var e=this.compareTo(t),n=this;do{var i=n.oNext(),r=i.compareTo(t);if(r!==e||i===this)return n.insertAfter(t),null;n=i}while(n!==this);f.shouldNeverReachHere()},insertAfter:function(t){f.equals(this._orig,t.orig());var e=this.oNext();this._sym.setNext(t),t.sym().setNext(e)},degree:function t(){var t=0,e=this;do t++,e=e.oNext();while(e!==this);return t},equals:function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return this._orig.equals2D(t)&&this._sym._orig.equals(e)}},deltaY:function(){return this._sym._orig.y-this._orig.y},sym:function(){return this._sym},prev:function(){return this._sym.next()._sym},compareAngularDirection:function(t){var e=this.deltaX(),n=this.deltaY(),i=t.deltaX(),r=t.deltaY();if(e===i&&n===r)return 0;var s=Je.quadrant(e,n),o=Je.quadrant(i,r);return s>o?1:o>s?-1:he.computeOrientation(t._orig,t.dest(),this.dest())},prevNode:function(){for(var t=this;2===t.degree();)if(t=t.prev(),t===this)return null;return t},compareTo:function(t){var e=t,n=this.compareAngularDirection(e);return n},next:function(){return this._next},setSym:function(t){this._sym=t},orig:function(){return this._orig},toString:function(){return"HE("+this._orig.x+" "+this._orig.y+", "+this._sym._orig.x+" "+this._sym._orig.y+")"},setNext:function(t){this._next=t},init:function(t){this.setSym(t),t.setSym(this),this.setNext(t),t.setNext(this)},deltaX:function(){return this._sym._orig.x-this._orig.x},interfaces_:function(){return[]},getClass:function(){return vi}}),vi.init=function(t,e){if(null!==t._sym||null!==e._sym||null!==t._next||null!==e._next)throw new IllegalStateException("Edges are already initialized");return t.init(e),t},vi.create=function(t,e){var n=new vi(t),i=new vi(e);return n.init(i),n},h(mi,vi),e(mi.prototype,{mark:function(){this._isMarked=!0},setMark:function(t){this._isMarked=t},isMarked:function(){return this._isMarked},interfaces_:function(){return[]},getClass:function(){return mi}}),mi.setMarkBoth=function(t,e){t.setMark(e),t.sym().setMark(e)},mi.isMarked=function(t){return t.isMarked()},mi.setMark=function(t,e){t.setMark(e)},mi.markBoth=function(t){t.mark(),t.sym().mark()},mi.mark=function(t){t.mark()},e(yi.prototype,{insert:function(t,e,n){var i=this.create(t,e);null!==n?n.insert(i):this.vertexMap.put(t,i);var r=this.vertexMap.get(e);return null!==r?r.insert(i.sym()):this.vertexMap.put(e,i.sym()),i},create:function(t,e){var n=this.createEdge(t),i=this.createEdge(e);return vi.init(n,i),n},createEdge:function(t){return new vi(t)},addEdge:function(t,e){if(!yi.isValidEdge(t,e))return null;var n=this.vertexMap.get(t),i=null;if(null!==n&&(i=n.find(e)),null!==i)return i;var r=this.insert(t,e,n);return r},getVertexEdges:function(){return this.vertexMap.values()},findEdge:function(t,e){var n=this.vertexMap.get(t);return null===n?null:n.find(e)},interfaces_:function(){return[]},getClass:function(){return yi}}),yi.isValidEdge=function(t,e){var n=e.compareTo(t);return 0!==n},h(xi,mi),e(xi.prototype,{setStart:function(){this._isStart=!0},isStart:function(){return this._isStart},interfaces_:function(){return[]},getClass:function(){return xi}}),h(Ei,yi),e(Ei.prototype,{createEdge:function(t){return new xi(t)},interfaces_:function(){return[]},getClass:function(){return Ei}}),e(Ii.prototype,{addLine:function(t){this.lines.add(this.factory.createLineString(t.toCoordinateArray()))},updateRingStartEdge:function(t){return t.isStart()||(t=t.sym(),t.isStart())?null===this.ringStartEdge?(this.ringStartEdge=t,null):void(t.orig().compareTo(this.ringStartEdge.orig())<0&&(this.ringStartEdge=t)):null},getResult:function(){return null===this.result&&this.computeResult(),this.result},process:function(t){var e=t.prevNode();null===e&&(e=t),this.stackEdges(e),this.buildLines()},buildRing:function(t){var e=new N,n=t;for(e.add(n.orig().copy(),!1);2===n.sym().degree();){var i=n.next();if(i===t)break;e.add(i.orig().copy(),!1),n=i}e.add(n.dest().copy(),!1),this.addLine(e)},buildLine:function(t){var e=new N,n=t;for(this.ringStartEdge=null,mi.markBoth(n),e.add(n.orig().copy(),!1);2===n.sym().degree();){this.updateRingStartEdge(n);var i=n.next();if(i===t)return this.buildRing(this.ringStartEdge),null;e.add(i.orig().copy(),!1),n=i,mi.markBoth(n)}e.add(n.dest().copy(),!1),this.stackEdges(n.sym()),this.addLine(e)},stackEdges:function(t){var e=t;do mi.isMarked(e)||this.nodeEdgeStack.add(e),e=e.oNext();while(e!==t)},computeResult:function(){for(var t=this.graph.getVertexEdges(),e=t.iterator();e.hasNext();){var n=e.next();mi.isMarked(n)||this.process(n)}this.result=this.factory.buildGeometry(this.lines)},buildLines:function(){for(;!this.nodeEdgeStack.empty();){var t=this.nodeEdgeStack.pop();mi.isMarked(t)||this.buildLine(t)}},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v))for(var e=arguments[0],n=e.iterator();n.hasNext();){var i=n.next();this.add(i)}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory());for(var s=r.getCoordinateSequence(),o=!1,n=1;n<s.size();n++){var a=this.graph.addEdge(s.getCoordinate(n-1),s.getCoordinate(n));null!==a&&(o||(a.setStart(),o=!0))}}},interfaces_:function(){return[]},getClass:function(){return Ii}}),Ii.dissolve=function(t){var e=new Ii;return e.add(t),e.getResult()};var go=Object.freeze({LineDissolver:Ii});e(Ni.prototype,{hasChildren:function(){for(var t=0;4>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;4>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},getNodeCount:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+1},size:function(){for(var t=0,e=0;4>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){if(!this.isSearchMatch(t))return null;e.addAll(this.items);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].addAllItemsFromOverlapping(t,e)},visitItems:function(t,e){for(var n=this.items.iterator();n.hasNext();)e.visitItem(n.next())},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;4>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},visit:function(t,e){if(!this.isSearchMatch(t))return null;this.visitItems(t,e);for(var n=0;4>n;n++)null!==this.subnode[n]&&this.subnode[n].visit(t,e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;4>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},isEmpty:function t(){var t=!0;this.items.isEmpty()||(t=!1);for(var e=0;4>e;e++)null!==this.subnode[e]&&(this.subnode[e].isEmpty()||(t=!1));return t},add:function(t){this.items.add(t)},interfaces_:function(){return[u]},getClass:function(){return Ni}}),Ni.getSubnodeIndex=function(t,e,n){var i=-1;return t.getMinX()>=e&&(t.getMinY()>=n&&(i=3),t.getMaxY()<=n&&(i=1)),t.getMaxX()<=e&&(t.getMinY()>=n&&(i=2),t.getMaxY()<=n&&(i=0)),i},Ci.exponent=function(t){return Si(64,t)-1023},Ci.powerOf2=function(t){return Math.pow(2,t)},e(wi.prototype,{getLevel:function(){return this.level},computeKey:function(){if(1===arguments.length){var t=arguments[0];for(this.level=wi.computeQuadLevel(t),this.env=new C,this.computeKey(this.level,t);!this.env.contains(t);)this.level+=1,this.computeKey(this.level,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=Ci.powerOf2(e);this.pt.x=Math.floor(n.getMinX()/i)*i,this.pt.y=Math.floor(n.getMinY()/i)*i,this.env.init(this.pt.x,this.pt.x+i,this.pt.y,this.pt.y+i)}},getEnvelope:function(){return this.env},getCentre:function(){return new g((this.env.getMinX()+this.env.getMaxX())/2,(this.env.getMinY()+this.env.getMaxY())/2)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return wi}}),wi.computeQuadLevel=function(t){var e=t.getWidth(),n=t.getHeight(),i=e>n?e:n,r=Ci.exponent(i)+1;return r},h(Li,Ni),e(Li.prototype,{find:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},isSearchMatch:function(t){return this.env.intersects(t)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getEnvelope:function(){return this.env},getNode:function(t){var e=Ni.getSubnodeIndex(t,this.centrex,this.centrey);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0,i=0,r=0;switch(t){case 0:e=this.env.getMinX(),n=this.centrex,i=this.env.getMinY(),r=this.centrey;break;case 1:e=this.centrex,n=this.env.getMaxX(),i=this.env.getMinY(),r=this.centrey;break;case 2:e=this.env.getMinX(),n=this.centrex,i=this.centrey,r=this.env.getMaxY();break;case 3:e=this.centrex,n=this.env.getMaxX(),i=this.centrey,r=this.env.getMaxY()}var s=new C(e,n,i,r),o=new Li(s,this.level-1);return o},insertNode:function(t){f.isTrue(null===this.env||this.env.contains(t.env));var e=Ni.getSubnodeIndex(t.env,this.centrex,this.centrey);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insertNode(t),this.subnode[e]=n}},interfaces_:function(){return[]},getClass:function(){return Li}}),Li.createNode=function(t){var e=new wi(t),n=new Li(e.getEnvelope(),e.getLevel());return n},Li.createExpanded=function(t,e){var n=new C(e);null!==t&&n.expandToInclude(t.env);var i=Li.createNode(n);return null!==t&&i.insertNode(t),i},e(Ri.prototype,{interfaces_:function(){return[]},getClass:function(){return Ri}}),Ri.isZeroWidth=function(t,e){var n=e-t;if(0===n)return!0;var i=Math.max(Math.abs(t),Math.abs(e)),r=n/i,s=Ci.exponent(r);return s<=Ri.MIN_BINARY_EXPONENT},Ri.MIN_BINARY_EXPONENT=-50,h(Ti,Ni),e(Ti.prototype,{insert:function(t,e){var n=Ni.getSubnodeIndex(t,Ti.origin.x,Ti.origin.y);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getEnvelope().contains(t)){var r=Li.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getEnvelope().contains(e));var i=Ri.isZeroWidth(e.getMinX(),e.getMaxX()),r=Ri.isZeroWidth(e.getMinY(),e.getMaxY()),s=null;s=i||r?t.find(e):t.getNode(e),s.add(n)},interfaces_:function(){return[]},getClass:function(){return Ti}}),Ti.origin=new g(0,0),e(Pi.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=Pi.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){var t=arguments[0],e=new Yn;return this.query(t,e),e.getItems()}if(2===arguments.length){var n=arguments[0],i=arguments[1];this.root.visit(n,i)}},queryAll:function(){var t=new I;return this.root.addAllItems(t),
t},remove:function(t,e){var n=Pi.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e);var n=t.getHeight();n<this.minExtent&&n>0&&(this.minExtent=n)},depth:function(){return null!==this.root?this.root.depth():0},isEmpty:function(){return null===this.root},interfaces_:function(){return[Fe,u]},getClass:function(){return Pi}}),Pi.ensureExtent=function(t,e){var n=t.getMinX(),i=t.getMaxX(),r=t.getMinY(),s=t.getMaxY();return n!==i&&r!==s?t:(n===i&&(n-=e/2,i=n+e/2),r===s&&(r-=e/2,s=r+e/2),new C(n,i,r,s))},Pi.serialVersionUID=-0x678b60c967a25400;var po=Object.freeze({Quadtree:Pi}),vo=Object.freeze({STRtree:ke}),mo=Object.freeze({quadtree:po,strtree:vo}),yo=["Point","MultiPoint","LineString","MultiLineString","Polygon","MultiPolygon"];e(bi.prototype,{read:function(t){var e=void 0;e="string"==typeof t?JSON.parse(t):t;var n=e.type;if(!xo[n])throw new Error("Unknown GeoJSON type: "+e.type);return-1!==yo.indexOf(n)?xo[n].apply(this,[e.coordinates]):"GeometryCollection"===n?xo[n].apply(this,[e.geometries]):xo[n].apply(this,[e])},write:function(t){var e=t.getGeometryType();if(!Eo[e])throw new Error("Geometry is not supported");return Eo[e].apply(this,[t])}});var xo={Feature:function(t){var e={};for(var n in t)e[n]=t[n];if(t.geometry){var i=t.geometry.type;if(!xo[i])throw new Error("Unknown GeoJSON type: "+t.type);e.geometry=this.read(t.geometry)}return t.bbox&&(e.bbox=xo.bbox.apply(this,[t.bbox])),e},FeatureCollection:function(t){var e={};if(t.features){e.features=[];for(var n=0;n<t.features.length;++n)e.features.push(this.read(t.features[n]))}return t.bbox&&(e.bbox=this.parse.bbox.apply(this,[t.bbox])),e},coordinates:function t(e){for(var t=[],n=0;n<e.length;++n){var i=e[n];t.push(new g(i[0],i[1]))}return t},bbox:function(t){return this.geometryFactory.createLinearRing([new g(t[0],t[1]),new g(t[2],t[1]),new g(t[2],t[3]),new g(t[0],t[3]),new g(t[0],t[1])])},Point:function(t){var e=new g(t[0],t[1]);return this.geometryFactory.createPoint(e)},MultiPoint:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.Point.apply(this,[t[n]]));return this.geometryFactory.createMultiPoint(e)},LineString:function(t){var e=xo.coordinates.apply(this,[t]);return this.geometryFactory.createLineString(e)},MultiLineString:function(t){for(var e=[],n=0;n<t.length;++n)e.push(xo.LineString.apply(this,[t[n]]));return this.geometryFactory.createMultiLineString(e)},Polygon:function(t){for(var e=xo.coordinates.apply(this,[t[0]]),n=this.geometryFactory.createLinearRing(e),i=[],r=1;r<t.length;++r){var s=t[r],o=xo.coordinates.apply(this,[s]),a=this.geometryFactory.createLinearRing(o);i.push(a)}return this.geometryFactory.createPolygon(n,i)},MultiPolygon:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(xo.Polygon.apply(this,[i]))}return this.geometryFactory.createMultiPolygon(e)},GeometryCollection:function(t){for(var e=[],n=0;n<t.length;++n){var i=t[n];e.push(this.read(i))}return this.geometryFactory.createGeometryCollection(e)}},Eo={coordinate:function(t){return[t.x,t.y]},Point:function(t){var e=Eo.coordinate.apply(this,[t.getCoordinate()]);return{type:"Point",coordinates:e}},MultiPoint:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Point.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPoint",coordinates:e}},LineString:function(t){for(var e=[],n=t.getCoordinates(),i=0;i<n.length;++i){var r=n[i];e.push(Eo.coordinate.apply(this,[r]))}return{type:"LineString",coordinates:e}},MultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.LineString.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiLineString",coordinates:e}},Polygon:function(t){var e=[],n=Eo.LineString.apply(this,[t.shell]);e.push(n.coordinates);for(var i=0;i<t.holes.length;++i){var r=t.holes[i],s=Eo.LineString.apply(this,[r]);e.push(s.coordinates)}return{type:"Polygon",coordinates:e}},MultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=Eo.Polygon.apply(this,[i]);e.push(r.coordinates)}return{type:"MultiPolygon",coordinates:e}},GeometryCollection:function(t){for(var e=[],n=0;n<t.geometries.length;++n){var i=t.geometries[n],r=i.getGeometryType();e.push(Eo[r].apply(this,[i]))}return{type:"GeometryCollection",geometries:e}}};e(Oi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){var e,n;if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(e=0,n=t.points.length;n>e;e++)this.precisionModel.makePrecise(t.points[e]);else if(t.geometries)for(e=0,n=t.geometries.length;n>e;e++)this.reducePrecision(t.geometries[e])}}),e(_i.prototype,{write:function(t){return this.parser.write(t)}}),e(Mi.prototype,{read:function(t){var e=this.parser.read(t);return this.precisionModel.getType()===ee.FIXED&&this.reducePrecision(e),e},reducePrecision:function(t){if(t.coordinate)this.precisionModel.makePrecise(t.coordinate);else if(t.points)for(var e=0,n=t.points.coordinates.length;n>e;e++)this.precisionModel.makePrecise(t.points.coordinates[e]);else if(t.geometries)for(var i=0,r=t.geometries.length;r>i;i++)this.reducePrecision(t.geometries[i])}}),e(Ai.prototype,{read:function(t){return t instanceof ol.geom.Point?this.convertFromPoint(t):t instanceof ol.geom.LineString?this.convertFromLineString(t):t instanceof ol.geom.LinearRing?this.convertFromLinearRing(t):t instanceof ol.geom.Polygon?this.convertFromPolygon(t):t instanceof ol.geom.MultiPoint?this.convertFromMultiPoint(t):t instanceof ol.geom.MultiLineString?this.convertFromMultiLineString(t):t instanceof ol.geom.MultiPolygon?this.convertFromMultiPolygon(t):t instanceof ol.geom.GeometryCollection?this.convertFromCollection(t):void 0},convertFromPoint:function(t){var e=t.getCoordinates();return this.geometryFactory.createPoint(new g(e[0],e[1]))},convertFromLineString:function(t){return this.geometryFactory.createLineString(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromLinearRing:function(t){return this.geometryFactory.createLinearRing(t.getCoordinates().map(function(t){return new g(t[0],t[1])}))},convertFromPolygon:function(t){for(var e=t.getLinearRings(),n=null,i=[],r=0;r<e.length;r++){var s=this.convertFromLinearRing(e[r]);0===r?n=s:i.push(s)}return this.geometryFactory.createPolygon(n,i)},convertFromMultiPoint:function(t){var e=t.getPoints().map(function(t){return this.convertFromPoint(t)},this);return this.geometryFactory.createMultiPoint(e)},convertFromMultiLineString:function(t){var e=t.getLineStrings().map(function(t){return this.convertFromLineString(t)},this);return this.geometryFactory.createMultiLineString(e)},convertFromMultiPolygon:function(t){var e=t.getPolygons().map(function(t){return this.convertFromPolygon(t)},this);return this.geometryFactory.createMultiPolygon(e)},convertFromCollection:function(t){var e=t.getGeometries().map(function(t){return this.read(t)},this);return this.geometryFactory.createGeometryCollection(e)},write:function(t){return"Point"===t.getGeometryType()?this.convertToPoint(t.getCoordinate()):"LineString"===t.getGeometryType()?this.convertToLineString(t):"LinearRing"===t.getGeometryType()?this.convertToLinearRing(t):"Polygon"===t.getGeometryType()?this.convertToPolygon(t):"MultiPoint"===t.getGeometryType()?this.convertToMultiPoint(t):"MultiLineString"===t.getGeometryType()?this.convertToMultiLineString(t):"MultiPolygon"===t.getGeometryType()?this.convertToMultiPolygon(t):"GeometryCollection"===t.getGeometryType()?this.convertToCollection(t):void 0},convertToPoint:function(t){return new ol.geom.Point([t.x,t.y])},convertToLineString:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LineString(e)},convertToLinearRing:function(t){var e=t.points.coordinates.map(Di);return new ol.geom.LinearRing(e)},convertToPolygon:function(t){for(var e=[t.shell.points.coordinates.map(Di)],n=0;n<t.holes.length;n++)e.push(t.holes[n].points.coordinates.map(Di));return new ol.geom.Polygon(e)},convertToMultiPoint:function(t){return new ol.geom.MultiPoint(t.getCoordinates().map(Di))},convertToMultiLineString:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToLineString(t.geometries[n]).getCoordinates());return new ol.geom.MultiLineString(e)},convertToMultiPolygon:function(t){for(var e=[],n=0;n<t.geometries.length;n++)e.push(this.convertToPolygon(t.geometries[n]).getCoordinates());return new ol.geom.MultiPolygon(e)},convertToCollection:function(t){for(var e=[],n=0;n<t.geometries.length;n++){var i=t.geometries[n];e.push(this.write(i))}return new ol.geom.GeometryCollection(e)}});var Io=Object.freeze({GeoJSONReader:Oi,GeoJSONWriter:_i,OL3Parser:Ai,WKTReader:Mi,WKTWriter:se});e(Fi.prototype,{rescale:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.rescale(n.getCoordinates())}else if(arguments[0]instanceof Array){var i=arguments[0],r=null,s=null;2===i.length&&(r=new g(i[0]),s=new g(i[1]));for(var e=0;e<i.length;e++)i[e].x=i[e].x/this.scaleFactor+this.offsetX,i[e].y=i[e].y/this.scaleFactor+this.offsetY;2===i.length&&i[0].equals2D(i[1])&&A.out.println(i)}},scale:function(){if(R(arguments[0],v)){for(var t=arguments[0],e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ke(this.scale(i.getCoordinates()),i.getData()))}return e}if(arguments[0]instanceof Array){for(var r=arguments[0],s=new Array(r.length).fill(null),n=0;n<r.length;n++)s[n]=new g(Math.round((r[n].x-this.offsetX)*this.scaleFactor),Math.round((r[n].y-this.offsetY)*this.scaleFactor),r[n].z);var o=H.removeRepeatedPoints(s);return o}},isIntegerPrecision:function(){return 1===this.scaleFactor},getNodedSubstrings:function(){var t=this.noder.getNodedSubstrings();return this.isScaled&&this.rescale(t),t},computeNodes:function(t){var e=t;this.isScaled&&(e=this.scale(t)),this.noder.computeNodes(e)},interfaces_:function(){return[tn]},getClass:function(){return Fi}});var No=Object.freeze({MCIndexNoder:nn,ScaledNoder:Fi,SegmentString:be});e(Gi.prototype,{isSimpleMultiPoint:function(t){if(t.isEmpty())return!0;for(var e=new at,n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n),r=i.getCoordinate();if(e.contains(r))return this.nonSimpleLocation=r,!1;e.add(r)}return!0},isSimplePolygonal:function(t){for(var e=kn.getLines(t),n=e.iterator();n.hasNext();){var i=n.next();if(!this.isSimpleLinearGeometry(i))return!1}return!0},hasClosedEndpointIntersection:function(t){for(var e=new rt,n=t.getEdgeIterator();n.hasNext();){var i=n.next(),r=(i.getMaximumSegmentIndex(),i.isClosed()),s=i.getCoordinate(0);this.addEndpoint(e,s,r);var o=i.getCoordinate(i.getNumPoints()-1);this.addEndpoint(e,o,r)}for(var n=e.values().iterator();n.hasNext();){var a=n.next();if(a.isClosed&&2!==a.degree)return this.nonSimpleLocation=a.getCoordinate(),!0}return!1},getNonSimpleLocation:function(){return this.nonSimpleLocation},isSimpleLinearGeometry:function(t){if(t.isEmpty())return!0;var e=new $n(0,t),n=new ae,i=e.computeSelfNodes(n,!0);return i.hasIntersection()?i.hasProperIntersection()?(this.nonSimpleLocation=i.getProperIntersectionPoint(),!1):this.hasNonEndpointIntersection(e)?!1:!this.isClosedEndpointsInInterior||!this.hasClosedEndpointIntersection(e):!0},hasNonEndpointIntersection:function(t){for(var e=t.getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getMaximumSegmentIndex(),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next();if(!s.isEndPoint(i))return this.nonSimpleLocation=s.getCoordinate(),!0}return!1},addEndpoint:function(t,e,n){var i=t.get(e);null===i&&(i=new qi(e),t.put(e,i)),i.addEndpoint(n)},computeSimple:function(t){return this.nonSimpleLocation=null,t.isEmpty()?!0:t instanceof St?this.isSimpleLinearGeometry(t):t instanceof gt?this.isSimpleLinearGeometry(t):t instanceof Pt?this.isSimpleMultiPoint(t):R(t,Rt)?this.isSimplePolygonal(t):t instanceof ft?this.isSimpleGeometryCollection(t):!0},isSimple:function(){return this.nonSimpleLocation=null,this.computeSimple(this.inputGeom)},isSimpleGeometryCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.computeSimple(n))return!1}return!0},interfaces_:function(){return[]},getClass:function(){return Gi}}),e(qi.prototype,{addEndpoint:function(t){this.degree++,this.isClosed|=t},getCoordinate:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return qi}}),Gi.EndpointInfo=qi,e(Bi.prototype,{getEndCapStyle:function(){return this.endCapStyle},isSingleSided:function(){return this._isSingleSided},setQuadrantSegments:function(t){this.quadrantSegments=t,0===this.quadrantSegments&&(this.joinStyle=Bi.JOIN_BEVEL),this.quadrantSegments<0&&(this.joinStyle=Bi.JOIN_MITRE,this.mitreLimit=Math.abs(this.quadrantSegments)),0>=t&&(this.quadrantSegments=1),this.joinStyle!==Bi.JOIN_ROUND&&(this.quadrantSegments=Bi.DEFAULT_QUADRANT_SEGMENTS)},getJoinStyle:function(){return this.joinStyle},setJoinStyle:function(t){this.joinStyle=t},setSimplifyFactor:function(t){this.simplifyFactor=0>t?0:t},getSimplifyFactor:function(){return this.simplifyFactor},getQuadrantSegments:function(){return this.quadrantSegments},setEndCapStyle:function(t){this.endCapStyle=t},getMitreLimit:function(){return this.mitreLimit},setMitreLimit:function(t){this.mitreLimit=t},setSingleSided:function(t){this._isSingleSided=t},interfaces_:function(){return[]},getClass:function(){return Bi}}),Bi.bufferDistanceError=function(t){var e=Math.PI/2/t;return 1-Math.cos(e/2)},Bi.CAP_ROUND=1,Bi.CAP_FLAT=2,Bi.CAP_SQUARE=3,Bi.JOIN_ROUND=1,Bi.JOIN_MITRE=2,Bi.JOIN_BEVEL=3,Bi.DEFAULT_QUADRANT_SEGMENTS=8,Bi.DEFAULT_MITRE_LIMIT=5,Bi.DEFAULT_SIMPLIFY_FACTOR=.01,e(zi.prototype,{getCoordinate:function(){return this.minCoord},getRightmostSide:function(t,e){var n=this.getRightmostSideOfSegment(t,e);return 0>n&&(n=this.getRightmostSideOfSegment(t,e-1)),0>n&&(this.minCoord=null,this.checkForRightmostCoordinate(t)),n},findRightmostEdgeAtVertex:function(){var t=this.minDe.getEdge().getCoordinates();f.isTrue(this.minIndex>0&&this.minIndex<t.length,"rightmost point expected to be interior vertex of edge");var e=t[this.minIndex-1],n=t[this.minIndex+1],i=he.computeOrientation(this.minCoord,n,e),r=!1;e.y<this.minCoord.y&&n.y<this.minCoord.y&&i===he.COUNTERCLOCKWISE?r=!0:e.y>this.minCoord.y&&n.y>this.minCoord.y&&i===he.CLOCKWISE&&(r=!0),r&&(this.minIndex=this.minIndex-1)},getRightmostSideOfSegment:function(t,e){var n=t.getEdge(),i=n.getCoordinates();if(0>e||e+1>=i.length)return-1;if(i[e].y===i[e+1].y)return-1;var r=cn.LEFT;return i[e].y<i[e+1].y&&(r=cn.RIGHT),r},getEdge:function(){return this.orientedDe},checkForRightmostCoordinate:function(t){for(var e=t.getEdge().getCoordinates(),n=0;n<e.length-1;n++)(null===this.minCoord||e[n].x>this.minCoord.x)&&(this.minDe=t,this.minIndex=n,this.minCoord=e[n])},findRightmostEdgeAtNode:function(){var t=this.minDe.getNode(),e=t.getEdges();this.minDe=e.getRightmostEdge(),this.minDe.isForward()||(this.minDe=this.minDe.getSym(),this.minIndex=this.minDe.getEdge().getCoordinates().length-1)},findEdge:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();n.isForward()&&this.checkForRightmostCoordinate(n)}f.isTrue(0!==this.minIndex||this.minCoord.equals(this.minDe.getCoordinate()),"inconsistency in rightmost processing"),0===this.minIndex?this.findRightmostEdgeAtNode():this.findRightmostEdgeAtVertex(),this.orientedDe=this.minDe;var i=this.getRightmostSide(this.minDe,this.minIndex);i===cn.LEFT&&(this.orientedDe=this.minDe.getSym())},interfaces_:function(){return[]},getClass:function(){return zi}}),Vi.prototype.addLast=function(t){this.array_.push(t)},Vi.prototype.removeFirst=function(){return this.array_.shift()},Vi.prototype.isEmpty=function(){return 0===this.array_.length},e(ki.prototype,{clearVisitedEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.setVisited(!1)}},getRightmostCoordinate:function(){return this.rightMostCoord},computeNodeDepth:function(t){for(var e=null,n=t.getEdges().iterator();n.hasNext();){var i=n.next();if(i.isVisited()||i.getSym().isVisited()){e=i;break}}if(null===e)throw new sn("unable to find edge to compute depths at "+t.getCoordinate());t.getEdges().computeDepths(e);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();i.setVisited(!0),this.copySymDepths(i)}},computeDepth:function(t){this.clearVisitedEdges();var e=this.finder.getEdge();e.getNode(),e.getLabel();e.setEdgeDepths(cn.RIGHT,t),this.copySymDepths(e),this.computeDepths(e)},create:function(t){this.addReachable(t),this.finder.findEdge(this.dirEdgeList),this.rightMostCoord=this.finder.getCoordinate()},findResultEdges:function(){for(var t=this.dirEdgeList.iterator();t.hasNext();){var e=t.next();e.getDepth(cn.RIGHT)>=1&&e.getDepth(cn.LEFT)<=0&&!e.isInteriorAreaEdge()&&e.setInResult(!0)}},computeDepths:function(t){var e=new J,n=new Vi,i=t.getNode();for(n.addLast(i),e.add(i),t.setVisited(!0);!n.isEmpty();){var r=n.removeFirst();e.add(r),this.computeNodeDepth(r);for(var s=r.getEdges().iterator();s.hasNext();){var o=s.next(),a=o.getSym();if(!a.isVisited()){var u=a.getNode();e.contains(u)||(n.addLast(u),e.add(u))}}}},compareTo:function(t){var e=t;return this.rightMostCoord.x<e.rightMostCoord.x?-1:this.rightMostCoord.x>e.rightMostCoord.x?1:0},getEnvelope:function(){if(null===this.env){for(var t=new C,e=this.dirEdgeList.iterator();e.hasNext();)for(var n=e.next(),i=n.getEdge().getCoordinates(),r=0;r<i.length-1;r++)t.expandToInclude(i[r]);this.env=t}return this.env},addReachable:function(t){var e=new pe;for(e.add(t);!e.empty();){var n=e.pop();this.add(n,e)}},copySymDepths:function(t){var e=t.getSym();e.setDepth(cn.LEFT,t.getDepth(cn.RIGHT)),e.setDepth(cn.RIGHT,t.getDepth(cn.LEFT))},add:function(t,e){t.setVisited(!0),this.nodes.add(t);for(var n=t.getEdges().iterator();n.hasNext();){var i=n.next();this.dirEdgeList.add(i);var r=i.getSym(),s=r.getNode();s.isVisited()||e.push(s)}},getNodes:function(){return this.nodes},getDirectedEdges:function(){return this.dirEdgeList},interfaces_:function(){return[s]},getClass:function(){return ki}}),e(Yi.prototype,{isDeletable:function(t,e,n,i){var r=this.inputLine[t],s=this.inputLine[e],o=this.inputLine[n];return this.isConcave(r,s,o)&&this.isShallow(r,s,o,i)?this.isShallowSampled(r,s,t,n,i):!1},deleteShallowConcavities:function(){for(var t=1,e=(this.inputLine.length-1,this.findNextNonDeletedIndex(t)),n=this.findNextNonDeletedIndex(e),i=!1;n<this.inputLine.length;){var r=!1;this.isDeletable(t,e,n,this.distanceTol)&&(this.isDeleted[e]=Yi.DELETE,r=!0,i=!0),t=r?n:e,e=this.findNextNonDeletedIndex(t),n=this.findNextNonDeletedIndex(e)}return i},isShallowConcavity:function(t,e,n,i){var r=he.computeOrientation(t,e,n),s=r===this.angleOrientation;if(!s)return!1;var o=he.distancePointLine(e,t,n);return i>o},isShallowSampled:function(t,e,n,i,r){var s=Math.trunc((i-n)/Yi.NUM_PTS_TO_CHECK);0>=s&&(s=1);for(var o=n;i>o;o+=s)if(!this.isShallow(t,e,this.inputLine[o],r))return!1;return!0},isConcave:function t(e,n,i){var r=he.computeOrientation(e,n,i),t=r===this.angleOrientation;return t},simplify:function(t){this.distanceTol=Math.abs(t),0>t&&(this.angleOrientation=he.CLOCKWISE),this.isDeleted=new Array(this.inputLine.length).fill(null);var e=!1;do e=this.deleteShallowConcavities();while(e);return this.collapseLine()},findNextNonDeletedIndex:function(t){for(var e=t+1;e<this.inputLine.length&&this.isDeleted[e]===Yi.DELETE;)e++;return e},isShallow:function(t,e,n,i){var r=he.distancePointLine(e,t,n);return i>r},collapseLine:function(){for(var t=new N,e=0;e<this.inputLine.length;e++)this.isDeleted[e]!==Yi.DELETE&&t.add(this.inputLine[e]);return t.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return Yi}}),Yi.simplify=function(t,e){var n=new Yi(t);return n.simplify(e)},Yi.INIT=0,Yi.DELETE=1,Yi.KEEP=1,Yi.NUM_PTS_TO_CHECK=10,e(Ui.prototype,{getCoordinates:function(){var t=this.ptList.toArray(Ui.COORDINATE_ARRAY_TYPE);return t},setPrecisionModel:function(t){this.precisionModel=t},addPt:function(t){var e=new g(t);return this.precisionModel.makePrecise(e),this.isRedundant(e)?null:void this.ptList.add(e)},reverse:function(){},addPts:function(t,e){if(e)for(var n=0;n<t.length;n++)this.addPt(t[n]);else for(var n=t.length-1;n>=0;n--)this.addPt(t[n])},isRedundant:function(t){if(this.ptList.size()<1)return!1;var e=this.ptList.get(this.ptList.size()-1),n=t.distance(e);return n<this.minimimVertexDistance},toString:function(){var t=new ie,e=t.createLineString(this.getCoordinates());return e.toString()},closeRing:function(){if(this.ptList.size()<1)return null;var t=new g(this.ptList.get(0)),e=this.ptList.get(this.ptList.size()-1),n=null;return this.ptList.size()>=2&&(n=this.ptList.get(this.ptList.size()-2)),t.equals(e)?null:void this.ptList.add(t)},setMinimumVertexDistance:function(t){this.minimimVertexDistance=t},interfaces_:function(){return[]},getClass:function(){return Ui}}),Ui.COORDINATE_ARRAY_TYPE=new Array(0).fill(null),e(Xi.prototype,{addNextSegment:function(t,e){if(this.s0=this.s1,this.s1=this.s2,this.s2=t,this.seg0.setCoordinates(this.s0,this.s1),this.computeOffsetSegment(this.seg0,this.side,this.distance,this.offset0),this.seg1.setCoordinates(this.s1,this.s2),this.computeOffsetSegment(this.seg1,this.side,this.distance,this.offset1),this.s1.equals(this.s2))return null;var n=he.computeOrientation(this.s0,this.s1,this.s2),i=n===he.CLOCKWISE&&this.side===cn.LEFT||n===he.COUNTERCLOCKWISE&&this.side===cn.RIGHT;0===n?this.addCollinear(e):i?this.addOutsideTurn(n,e):this.addInsideTurn(n,e)},addLineEndCap:function(t,e){var n=new ce(t,e),i=new ce;this.computeOffsetSegment(n,cn.LEFT,this.distance,i);var r=new ce;this.computeOffsetSegment(n,cn.RIGHT,this.distance,r);var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s);switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:this.segList.addPt(i.p1),this.addFilletArc(e,a+Math.PI/2,a-Math.PI/2,he.CLOCKWISE,this.distance),this.segList.addPt(r.p1);break;case Bi.CAP_FLAT:this.segList.addPt(i.p1),this.segList.addPt(r.p1);break;case Bi.CAP_SQUARE:var u=new g;u.x=Math.abs(this.distance)*Math.cos(a),u.y=Math.abs(this.distance)*Math.sin(a);var l=new g(i.p1.x+u.x,i.p1.y+u.y),h=new g(r.p1.x+u.x,r.p1.y+u.y);this.segList.addPt(l),this.segList.addPt(h)}},getCoordinates:function(){var t=this.segList.getCoordinates();return t},addMitreJoin:function(t,e,n,i){var r=!0,s=null;try{s=F.intersection(e.p0,e.p1,n.p0,n.p1);var o=0>=i?1:s.distance(t)/Math.abs(i);o>this.bufParams.getMitreLimit()&&(r=!1)}catch(t){if(!(t instanceof w))throw t;s=new g(0,0),r=!1}finally{}r?this.segList.addPt(s):this.addLimitedMitreJoin(e,n,i,this.bufParams.getMitreLimit())},addFilletCorner:function(t,e,n,i,r){var s=e.x-t.x,o=e.y-t.y,a=Math.atan2(o,s),u=n.x-t.x,l=n.y-t.y,h=Math.atan2(l,u);i===he.CLOCKWISE?h>=a&&(a+=2*Math.PI):a>=h&&(a-=2*Math.PI),this.segList.addPt(e),this.addFilletArc(t,a,h,i,r),this.segList.addPt(n)},addOutsideTurn:function(t,e){return this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.OFFSET_SEGMENT_SEPARATION_FACTOR?(this.segList.addPt(this.offset0.p1),null):void(this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?this.addMitreJoin(this.s1,this.offset0,this.offset1,this.distance):this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL?this.addBevelJoin(this.offset0,this.offset1):(e&&this.segList.addPt(this.offset0.p1),this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,t,this.distance),this.segList.addPt(this.offset1.p0)))},createSquare:function(t){this.segList.addPt(new g(t.x+this.distance,t.y+this.distance)),this.segList.addPt(new g(t.x+this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y-this.distance)),this.segList.addPt(new g(t.x-this.distance,t.y+this.distance)),this.segList.closeRing()},addSegments:function(t,e){this.segList.addPts(t,e)},addFirstSegment:function(){this.segList.addPt(this.offset1.p0)},addLastSegment:function(){this.segList.addPt(this.offset1.p1)},initSideSegments:function(t,e,n){this.s1=t,this.s2=e,this.side=n,this.seg1.setCoordinates(t,e),this.computeOffsetSegment(this.seg1,n,this.distance,this.offset1)},addLimitedMitreJoin:function(t,e,n,i){var r=this.seg0.p1,s=hi.angle(r,this.seg0.p0),o=(hi.angle(r,this.seg1.p1),hi.angleBetweenOriented(this.seg0.p0,r,this.seg1.p1)),a=o/2,u=hi.normalize(s+a),l=hi.normalize(u+Math.PI),h=i*n,c=h*Math.abs(Math.sin(a)),f=n-c,d=r.x+h*Math.cos(l),p=r.y+h*Math.sin(l),v=new g(d,p),m=new ce(r,v),y=m.pointAlongOffset(1,f),x=m.pointAlongOffset(1,-f);this.side===cn.LEFT?(this.segList.addPt(y),this.segList.addPt(x)):(this.segList.addPt(x),this.segList.addPt(y))},computeOffsetSegment:function(t,e,n,i){var r=e===cn.LEFT?1:-1,s=t.p1.x-t.p0.x,o=t.p1.y-t.p0.y,a=Math.sqrt(s*s+o*o),u=r*n*s/a,l=r*n*o/a;i.p0.x=t.p0.x-l,i.p0.y=t.p0.y+u,i.p1.x=t.p1.x-l,i.p1.y=t.p1.y+u},addFilletArc:function(t,e,n,i,r){var s=i===he.CLOCKWISE?-1:1,o=Math.abs(e-n),a=Math.trunc(o/this.filletAngleQuantum+.5);if(1>a)return null;var u=null,l=null;u=0,l=o/a;for(var h=u,c=new g;o>h;){var f=e+s*h;c.x=t.x+r*Math.cos(f),c.y=t.y+r*Math.sin(f),this.segList.addPt(c),h+=l}},addInsideTurn:function(t,e){if(this.li.computeIntersection(this.offset0.p0,this.offset0.p1,this.offset1.p0,this.offset1.p1),this.li.hasIntersection())this.segList.addPt(this.li.getIntersection(0));else if(this._hasNarrowConcaveAngle=!0,this.offset0.p1.distance(this.offset1.p0)<this.distance*Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR)this.segList.addPt(this.offset0.p1);else{if(this.segList.addPt(this.offset0.p1),this.closingSegLengthFactor>0){var n=new g((this.closingSegLengthFactor*this.offset0.p1.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset0.p1.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(n);var i=new g((this.closingSegLengthFactor*this.offset1.p0.x+this.s1.x)/(this.closingSegLengthFactor+1),(this.closingSegLengthFactor*this.offset1.p0.y+this.s1.y)/(this.closingSegLengthFactor+1));this.segList.addPt(i)}else this.segList.addPt(this.s1);this.segList.addPt(this.offset1.p0)}},createCircle:function(t){var e=new g(t.x+this.distance,t.y);this.segList.addPt(e),this.addFilletArc(t,0,2*Math.PI,-1,this.distance),this.segList.closeRing()},addBevelJoin:function(t,e){this.segList.addPt(t.p1),this.segList.addPt(e.p0)},init:function(t){this.distance=t,this.maxCurveSegmentError=t*(1-Math.cos(this.filletAngleQuantum/2)),this.segList=new Ui,this.segList.setPrecisionModel(this.precisionModel),this.segList.setMinimumVertexDistance(t*Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR)},addCollinear:function(t){this.li.computeIntersection(this.s0,this.s1,this.s1,this.s2);var e=this.li.getIntersectionNum();e>=2&&(this.bufParams.getJoinStyle()===Bi.JOIN_BEVEL||this.bufParams.getJoinStyle()===Bi.JOIN_MITRE?(t&&this.segList.addPt(this.offset0.p1),this.segList.addPt(this.offset1.p0)):this.addFilletCorner(this.s1,this.offset0.p1,this.offset1.p0,he.CLOCKWISE,this.distance))},closeRing:function(){this.segList.closeRing()},hasNarrowConcaveAngle:function(){return this._hasNarrowConcaveAngle},interfaces_:function(){return[]},getClass:function(){return Xi}}),Xi.OFFSET_SEGMENT_SEPARATION_FACTOR=.001,Xi.INSIDE_TURN_VERTEX_SNAP_DISTANCE_FACTOR=.001,Xi.CURVE_VERTEX_SNAP_DISTANCE_FACTOR=1e-6,Xi.MAX_CLOSING_SEG_LEN_FACTOR=80,e(Hi.prototype,{getOffsetCurve:function(t,e){if(this.distance=e,0===e)return null;var n=0>e,i=Math.abs(e),r=this.getSegGen(i);t.length<=1?this.computePointCurve(t[0],r):this.computeOffsetCurve(t,n,r);var s=r.getCoordinates();return n&&H.reverse(s),s},computeSingleSidedBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){n.addSegments(t,!0);var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{n.addSegments(t,!1);var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment(),n.closeRing()},computeRingBufferCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);e===cn.RIGHT&&(i=-i);var r=Yi.simplify(t,i),s=r.length-1;n.initSideSegments(r[s-1],r[0],e);for(var o=1;s>=o;o++){var a=1!==o;n.addNextSegment(r[o],a)}n.closeRing()},computeLineBufferCurve:function(t,e){var n=this.simplifyTolerance(this.distance),i=Yi.simplify(t,n),r=i.length-1;e.initSideSegments(i[0],i[1],cn.LEFT);for(var s=2;r>=s;s++)e.addNextSegment(i[s],!0);e.addLastSegment(),e.addLineEndCap(i[r-1],i[r]);var o=Yi.simplify(t,-n),a=o.length-1;e.initSideSegments(o[a],o[a-1],cn.LEFT);for(var s=a-2;s>=0;s--)e.addNextSegment(o[s],!0);e.addLastSegment(),e.addLineEndCap(o[1],o[0]),e.closeRing()},computePointCurve:function(t,e){switch(this.bufParams.getEndCapStyle()){case Bi.CAP_ROUND:e.createCircle(t);break;case Bi.CAP_SQUARE:e.createSquare(t)}},getLineCurve:function(t,e){if(this.distance=e,0>e&&!this.bufParams.isSingleSided())return null;if(0===e)return null;var n=Math.abs(e),i=this.getSegGen(n);if(t.length<=1)this.computePointCurve(t[0],i);else if(this.bufParams.isSingleSided()){var r=0>e;this.computeSingleSidedBufferCurve(t,r,i)}else this.computeLineBufferCurve(t,i);var s=i.getCoordinates();return s},getBufferParameters:function(){return this.bufParams},simplifyTolerance:function(t){return t*this.bufParams.getSimplifyFactor()},getRingCurve:function(t,e,n){if(this.distance=n,t.length<=2)return this.getLineCurve(t,n);if(0===n)return Hi.copyCoordinates(t);var i=this.getSegGen(n);return this.computeRingBufferCurve(t,e,i),i.getCoordinates()},computeOffsetCurve:function(t,e,n){var i=this.simplifyTolerance(this.distance);if(e){var r=Yi.simplify(t,-i),s=r.length-1;n.initSideSegments(r[s],r[s-1],cn.LEFT),n.addFirstSegment();for(var o=s-2;o>=0;o--)n.addNextSegment(r[o],!0)}else{var a=Yi.simplify(t,i),u=a.length-1;n.initSideSegments(a[0],a[1],cn.LEFT),n.addFirstSegment();for(var o=2;u>=o;o++)n.addNextSegment(a[o],!0)}n.addLastSegment()},getSegGen:function(t){return new Xi(this.precisionModel,this.bufParams,t)},interfaces_:function(){return[]},getClass:function(){return Hi}}),Hi.copyCoordinates=function(t){for(var e=new Array(t.length).fill(null),n=0;n<e.length;n++)e[n]=new g(t[n]);return e},e(Wi.prototype,{findStabbedSegments:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=this.subgraphs.iterator();n.hasNext();){var i=n.next(),r=i.getEnvelope();t.y<r.getMinY()||t.y>r.getMaxY()||this.findStabbedSegments(t,i.getDirectedEdges(),e)}return e}if(3===arguments.length)if(R(arguments[2],y)&&arguments[0]instanceof g&&arguments[1]instanceof In)for(var s=arguments[0],o=arguments[1],a=arguments[2],u=o.getEdge().getCoordinates(),n=0;n<u.length-1;n++){this.seg.p0=u[n],this.seg.p1=u[n+1],this.seg.p0.y>this.seg.p1.y&&this.seg.reverse();var l=Math.max(this.seg.p0.x,this.seg.p1.x);if(!(l<s.x||this.seg.isHorizontal()||s.y<this.seg.p0.y||s.y>this.seg.p1.y||he.computeOrientation(this.seg.p0,this.seg.p1,s)===he.RIGHT)){var h=o.getDepth(cn.LEFT);this.seg.p0.equals(u[n])||(h=o.getDepth(cn.RIGHT));var c=new ji(this.seg,h);a.add(c)}}else if(R(arguments[2],y)&&arguments[0]instanceof g&&R(arguments[1],y))for(var f=arguments[0],d=arguments[1],p=arguments[2],n=d.iterator();n.hasNext();){var v=n.next();v.isForward()&&this.findStabbedSegments(f,v,p)}},getDepth:function(t){var e=this.findStabbedSegments(t);if(0===e.size())return 0;var n=ho.min(e);return n.leftDepth},interfaces_:function(){return[]},getClass:function(){return Wi}}),e(ji.prototype,{compareTo:function(t){var e=t;if(this.upwardSeg.minX()>=e.upwardSeg.maxX())return 1;if(this.upwardSeg.maxX()<=e.upwardSeg.minX())return-1;var n=this.upwardSeg.orientationIndex(e.upwardSeg);return 0!==n?n:(n=-1*e.upwardSeg.orientationIndex(this.upwardSeg),0!==n?n:this.upwardSeg.compareTo(e.upwardSeg))},compareX:function(t,e){var n=t.p0.compareTo(e.p0);return 0!==n?n:t.p1.compareTo(e.p1)},toString:function(){return this.upwardSeg.toString()},interfaces_:function(){return[s]},getClass:function(){return ji}}),Wi.DepthSegment=ji,e(Ki.prototype,{addPoint:function(t){if(this.distance<=0)return null;
var e=t.getCoordinates(),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addPolygon:function(t){var e=this.distance,n=cn.LEFT;this.distance<0&&(e=-this.distance,n=cn.RIGHT);var i=t.getExteriorRing(),r=H.removeRepeatedPoints(i.getCoordinates());if(this.distance<0&&this.isErodedCompletely(i,this.distance))return null;if(this.distance<=0&&r.length<3)return null;this.addPolygonRing(r,e,n,L.EXTERIOR,L.INTERIOR);for(var s=0;s<t.getNumInteriorRing();s++){var o=t.getInteriorRingN(s),a=H.removeRepeatedPoints(o.getCoordinates());this.distance>0&&this.isErodedCompletely(o,-this.distance)||this.addPolygonRing(a,e,cn.opposite(n),L.INTERIOR,L.EXTERIOR)}},isTriangleErodedCompletely:function(t,e){var n=new ci(t[0],t[1],t[2]),i=n.inCentre(),r=he.distancePointLine(i,n.p0,n.p1);return r<Math.abs(e)},addLineString:function(t){if(this.distance<=0&&!this.curveBuilder.getBufferParameters().isSingleSided())return null;var e=H.removeRepeatedPoints(t.getCoordinates()),n=this.curveBuilder.getLineCurve(e,this.distance);this.addCurve(n,L.EXTERIOR,L.INTERIOR)},addCurve:function(t,e,n){if(null===t||t.length<2)return null;var i=new Ke(t,new gn(0,L.BOUNDARY,e,n));this.curveList.add(i)},getCurves:function(){return this.add(this.inputGeom),this.curveList},addPolygonRing:function(t,e,n,i,r){if(0===e&&t.length<bt.MINIMUM_VALID_SIZE)return null;var s=i,o=r;t.length>=bt.MINIMUM_VALID_SIZE&&he.isCCW(t)&&(s=r,o=i,n=cn.opposite(n));var a=this.curveBuilder.getRingCurve(t,n,e);this.addCurve(a,s,o)},add:function(t){if(t.isEmpty())return null;if(t instanceof Tt)this.addPolygon(t);else if(t instanceof St)this.addLineString(t);else if(t instanceof Lt)this.addPoint(t);else if(t instanceof Pt)this.addCollection(t);else if(t instanceof gt)this.addCollection(t);else if(t instanceof Ot)this.addCollection(t);else{if(!(t instanceof ft))throw new UnsupportedOperationException(t.getClass().getName());this.addCollection(t)}},isErodedCompletely:function(t,e){var n=t.getCoordinates();if(n.length<4)return 0>e;if(4===n.length)return this.isTriangleErodedCompletely(n,e);var i=t.getEnvelopeInternal(),r=Math.min(i.getHeight(),i.getWidth());return 0>e&&2*Math.abs(e)>r},addCollection:function(t){for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);this.add(n)}},interfaces_:function(){return[]},getClass:function(){return Ki}}),e(Zi.prototype,{isTrivialIntersection:function(t,e,n,i){if(t===n&&1===this.li.getIntersectionNum()){if(Zi.isAdjacentSegments(e,i))return!0;if(t.isClosed()){var r=t.size()-1;if(0===e&&i===r||0===i&&e===r)return!0}}return!1},getProperIntersectionPoint:function(){return this.properIntersectionPoint},hasProperInteriorIntersection:function(){return this.hasProperInterior},getLineIntersector:function(){return this.li},hasProperIntersection:function(){return this.hasProper},processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;this.numTests++;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&(this.numIntersections++,this.li.isInteriorIntersection()&&(this.numInteriorIntersections++,this.hasInterior=!0),this.isTrivialIntersection(t,e,n,i)||(this._hasIntersection=!0,t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1),this.li.isProper()&&(this.numProperIntersections++,this.hasProper=!0,this.hasProperInterior=!0)))},hasIntersection:function(){return this._hasIntersection},isDone:function(){return!1},hasInteriorIntersection:function(){return this.hasInterior},interfaces_:function(){return[on]},getClass:function(){return Zi}}),Zi.isAdjacentSegments=function(t,e){return 1===Math.abs(t-e)},e(Qi.prototype,{setWorkingPrecisionModel:function(t){this.workingPrecisionModel=t},insertUniqueEdge:function(t){var e=this.edgeList.findEqualEdge(t);if(null!==e){var n=e.getLabel(),i=t.getLabel();e.isPointwiseEqual(t)||(i=new gn(t.getLabel()),i.flip()),n.merge(i);var r=Qi.depthDelta(i),s=e.getDepthDelta(),o=s+r;e.setDepthDelta(o)}else this.edgeList.add(t),t.setDepthDelta(Qi.depthDelta(t.getLabel()))},buildSubgraphs:function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next(),s=r.getRightmostCoordinate(),o=new Wi(n),a=o.getDepth(s);r.computeDepth(a),r.findResultEdges(),n.add(r),e.add(r.getDirectedEdges(),r.getNodes())}},createSubgraphs:function(t){for(var e=new I,n=t.getNodes().iterator();n.hasNext();){var i=n.next();if(!i.isVisited()){var r=new ki;r.create(i),e.add(r)}}return ho.sort(e,ho.reverseOrder()),e},createEmptyResultGeometry:function(){var t=this.geomFact.createPolygon();return t},getNoder:function(t){if(null!==this.workingNoder)return this.workingNoder;var e=new nn,n=new ae;return n.setPrecisionModel(t),e.setSegmentIntersector(new Zi(n)),e},buffer:function(t,e){var n=this.workingPrecisionModel;null===n&&(n=t.getPrecisionModel()),this.geomFact=t.getFactory();var i=new Hi(n,this.bufParams),r=new Ki(t,e,i),s=r.getCurves();if(s.size()<=0)return this.createEmptyResultGeometry();this.computeNodedEdges(s,n),this.graph=new Cn(new On),this.graph.addEdges(this.edgeList.getEdges());var o=this.createSubgraphs(this.graph),a=new Sn(this.geomFact);this.buildSubgraphs(o,a);var u=a.getPolygons();if(u.size()<=0)return this.createEmptyResultGeometry();var l=this.geomFact.buildGeometry(u);return l},computeNodedEdges:function(t,e){var n=this.getNoder(e);n.computeNodes(t);for(var i=n.getNodedSubstrings(),r=i.iterator();r.hasNext();){var s=r.next(),o=s.getCoordinates();if(2!==o.length||!o[0].equals2D(o[1])){var a=s.getData(),u=new Jn(s.getCoordinates(),new gn(a));this.insertUniqueEdge(u)}}},setNoder:function(t){this.workingNoder=t},interfaces_:function(){return[]},getClass:function(){return Qi}}),Qi.depthDelta=function(t){var e=t.getLocation(0,cn.LEFT),n=t.getLocation(0,cn.RIGHT);return e===L.INTERIOR&&n===L.EXTERIOR?1:e===L.EXTERIOR&&n===L.INTERIOR?-1:0},Qi.convertSegStrings=function(t){for(var e=new ie,n=new I;t.hasNext();){var i=t.next(),r=e.createLineString(i.getCoordinates());n.add(r)}return e.buildGeometry(n)},e(Ji.prototype,{checkEndPtVertexIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next(),n=e.getCoordinates();this.checkEndPtVertexIntersections(n[0],this.segStrings),this.checkEndPtVertexIntersections(n[n.length-1],this.segStrings)}else if(2===arguments.length)for(var i=arguments[0],r=arguments[1],t=r.iterator();t.hasNext();)for(var e=t.next(),n=e.getCoordinates(),s=1;s<n.length-1;s++)if(n[s].equals(i))throw new l("found endpt/interior pt intersection at index "+s+" :pt "+i)},checkInteriorIntersections:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();)for(var e=t.next(),n=this.segStrings.iterator();n.hasNext();){var i=n.next();this.checkInteriorIntersections(e,i)}else if(2===arguments.length)for(var r=arguments[0],s=arguments[1],o=r.getCoordinates(),a=s.getCoordinates(),u=0;u<o.length-1;u++)for(var h=0;h<a.length-1;h++)this.checkInteriorIntersections(r,u,s,h);else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3];if(c===g&&f===d)return null;var p=c.getCoordinates()[f],v=c.getCoordinates()[f+1],m=g.getCoordinates()[d],y=g.getCoordinates()[d+1];if(this.li.computeIntersection(p,v,m,y),this.li.hasIntersection()&&(this.li.isProper()||this.hasInteriorIntersection(this.li,p,v)||this.hasInteriorIntersection(this.li,m,y)))throw new l("found non-noded intersection at "+p+"-"+v+" and "+m+"-"+y)}},checkValid:function(){this.checkEndPtVertexIntersections(),this.checkInteriorIntersections(),this.checkCollapses()},checkCollapses:function(){if(0===arguments.length)for(var t=this.segStrings.iterator();t.hasNext();){var e=t.next();this.checkCollapses(e)}else if(1===arguments.length)for(var n=arguments[0],i=n.getCoordinates(),t=0;t<i.length-2;t++)this.checkCollapse(i[t],i[t+1],i[t+2])},hasInteriorIntersection:function(t,e,n){for(var i=0;i<t.getIntersectionNum();i++){var r=t.getIntersection(i);if(!r.equals(e)&&!r.equals(n))return!0}return!1},checkCollapse:function(t,e,n){if(t.equals(n))throw new l("found non-noded collapse at "+Ji.fact.createLineString([t,e,n]))},interfaces_:function(){return[]},getClass:function(){return Ji}}),Ji.fact=new ie,e($i.prototype,{intersectsScaled:function(t,e){var n=Math.min(t.x,e.x),i=Math.max(t.x,e.x),r=Math.min(t.y,e.y),s=Math.max(t.y,e.y),o=this.maxx<n||this.minx>i||this.maxy<r||this.miny>s;if(o)return!1;var a=this.intersectsToleranceSquare(t,e);return f.isTrue(!(o&&a),"Found bad envelope test"),a},initCorners:function(t){var e=.5;this.minx=t.x-e,this.maxx=t.x+e,this.miny=t.y-e,this.maxy=t.y+e,this.corner[0]=new g(this.maxx,this.maxy),this.corner[1]=new g(this.minx,this.maxy),this.corner[2]=new g(this.minx,this.miny),this.corner[3]=new g(this.maxx,this.miny)},intersects:function(t,e){return 1===this.scaleFactor?this.intersectsScaled(t,e):(this.copyScaled(t,this.p0Scaled),this.copyScaled(e,this.p1Scaled),this.intersectsScaled(this.p0Scaled,this.p1Scaled))},scale:function(t){return Math.round(t*this.scaleFactor)},getCoordinate:function(){return this.originalPt},copyScaled:function(t,e){e.x=this.scale(t.x),e.y=this.scale(t.y)},getSafeEnvelope:function(){if(null===this.safeEnv){var t=$i.SAFE_ENV_EXPANSION_FACTOR/this.scaleFactor;this.safeEnv=new C(this.originalPt.x-t,this.originalPt.x+t,this.originalPt.y-t,this.originalPt.y+t)}return this.safeEnv},intersectsPixelClosure:function(t,e){return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.hasIntersection()?!0:(this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),!!this.li.hasIntersection())))},intersectsToleranceSquare:function(t,e){var n=!1,i=!1;return this.li.computeIntersection(t,e,this.corner[0],this.corner[1]),this.li.isProper()?!0:(this.li.computeIntersection(t,e,this.corner[1],this.corner[2]),this.li.isProper()?!0:(this.li.hasIntersection()&&(n=!0),this.li.computeIntersection(t,e,this.corner[2],this.corner[3]),this.li.isProper()?!0:(this.li.hasIntersection()&&(i=!0),this.li.computeIntersection(t,e,this.corner[3],this.corner[0]),this.li.isProper()?!0:n&&i?!0:t.equals(this.pt)?!0:!!e.equals(this.pt))))},addSnappedNode:function(t,e){var n=t.getCoordinate(e),i=t.getCoordinate(e+1);return this.intersects(n,i)?(t.addIntersection(this.getCoordinate(),e),!0):!1},interfaces_:function(){return[]},getClass:function(){return $i}}),$i.SAFE_ENV_EXPANSION_FACTOR=.75,e(tr.prototype,{select:function(){if(1===arguments.length){arguments[0]}else if(2===arguments.length){var t=arguments[0],e=arguments[1];t.getLineSegment(e,this.selectedSegment),this.select(this.selectedSegment)}},interfaces_:function(){return[]},getClass:function(){return tr}}),e(er.prototype,{snap:function(){if(1===arguments.length){var t=arguments[0];return this.snap(t,null,-1)}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2],r=e.getSafeEnvelope(),s=new nr(e,n,i);return this.index.query(r,{interfaces_:function(){return[Ae]},visitItem:function(t){var e=t;e.select(r,s)}}),s.isNodeAdded()}},interfaces_:function(){return[]},getClass:function(){return er}}),h(nr,tr),e(nr.prototype,{isNodeAdded:function(){return this._isNodeAdded},select:function(){if(2!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0],e=arguments[1],n=t.getContext();return null!==this.parentEdge&&n===this.parentEdge&&e===this.hotPixelVertexIndex?null:void(this._isNodeAdded=this.hotPixel.addSnappedNode(n,e))},interfaces_:function(){return[]},getClass:function(){return nr}}),er.HotPixelSnapAction=nr,e(ir.prototype,{processIntersections:function(t,e,n,i){if(t===n&&e===i)return null;var r=t.getCoordinates()[e],s=t.getCoordinates()[e+1],o=n.getCoordinates()[i],a=n.getCoordinates()[i+1];if(this.li.computeIntersection(r,s,o,a),this.li.hasIntersection()&&this.li.isInteriorIntersection()){for(var u=0;u<this.li.getIntersectionNum();u++)this.interiorIntersections.add(this.li.getIntersection(u));t.addIntersections(this.li,e,0),n.addIntersections(this.li,i,1)}},isDone:function(){return!1},getInteriorIntersections:function(){return this.interiorIntersections},interfaces_:function(){return[on]},getClass:function(){return ir}}),e(rr.prototype,{checkCorrectness:function(t){var e=Ke.getNodedSubstrings(t),n=new Ji(e);try{n.checkValid()}catch(t){if(!(t instanceof S))throw t;t.printStackTrace()}finally{}},getNodedSubstrings:function(){return Ke.getNodedSubstrings(this.nodedSegStrings)},snapRound:function(t,e){var n=this.findInteriorIntersections(t,e);this.computeIntersectionSnaps(n),this.computeVertexSnaps(t)},findInteriorIntersections:function(t,e){var n=new ir(e);return this.noder.setSegmentIntersector(n),this.noder.computeNodes(t),n.getInteriorIntersections()},computeVertexSnaps:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.computeVertexSnaps(n)}else if(arguments[0]instanceof Ke)for(var i=arguments[0],r=i.getCoordinates(),s=0;s<r.length;s++){var o=new $i(r[s],this.scaleFactor,this.li),a=this.pointSnapper.snap(o,i,s);a&&i.addIntersection(r[s],s)}},computeNodes:function(t){this.nodedSegStrings=t,this.noder=new nn,this.pointSnapper=new er(this.noder.getIndex()),this.snapRound(t,this.li)},computeIntersectionSnaps:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=new $i(n,this.scaleFactor,this.li);this.pointSnapper.snap(i)}},interfaces_:function(){return[tn]},getClass:function(){return rr}}),e(sr.prototype,{bufferFixedPrecision:function(t){var e=new Fi(new rr(new ee(1)),t.getScale()),n=new Qi(this.bufParams);n.setWorkingPrecisionModel(t),n.setNoder(e),this.resultGeometry=n.buffer(this.argGeom,this.distance)},bufferReducedPrecision:function(){if(0===arguments.length){for(var t=sr.MAX_PRECISION_DIGITS;t>=0;t--){try{this.bufferReducedPrecision(t)}catch(t){if(!(t instanceof sn))throw t;this.saveException=t}finally{}if(null!==this.resultGeometry)return null}throw this.saveException}if(1===arguments.length){var e=arguments[0],n=sr.precisionScaleFactor(this.argGeom,this.distance,e),i=new ee(n);this.bufferFixedPrecision(i)}},computeGeometry:function(){if(this.bufferOriginalPrecision(),null!==this.resultGeometry)return null;var t=this.argGeom.getFactory().getPrecisionModel();t.getType()===ee.FIXED?this.bufferFixedPrecision(t):this.bufferReducedPrecision()},setQuadrantSegments:function(t){this.bufParams.setQuadrantSegments(t)},bufferOriginalPrecision:function(){try{var t=new Qi(this.bufParams);this.resultGeometry=t.buffer(this.argGeom,this.distance)}catch(t){if(!(t instanceof l))throw t;this.saveException=t}finally{}},getResultGeometry:function(t){return this.distance=t,this.computeGeometry(),this.resultGeometry},setEndCapStyle:function(t){this.bufParams.setEndCapStyle(t)},interfaces_:function(){return[]},getClass:function(){return sr}}),sr.bufferOp=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new sr(t),i=n.getResultGeometry(e);return i}if(3===arguments.length){if(Number.isInteger(arguments[2])&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var r=arguments[0],s=arguments[1],o=arguments[2],a=new sr(r);a.setQuadrantSegments(o);var i=a.getResultGeometry(s);return i}if(arguments[2]instanceof Bi&&arguments[0]instanceof B&&"number"==typeof arguments[1]){var u=arguments[0],l=arguments[1],h=arguments[2],a=new sr(u,h),i=a.getResultGeometry(l);return i}}else if(4===arguments.length){var c=arguments[0],f=arguments[1],g=arguments[2],d=arguments[3],a=new sr(c);a.setQuadrantSegments(g),a.setEndCapStyle(d);var i=a.getResultGeometry(f);return i}},sr.precisionScaleFactor=function(t,e,n){var i=t.getEnvelopeInternal(),r=T.max(Math.abs(i.getMaxX()),Math.abs(i.getMaxY()),Math.abs(i.getMinX()),Math.abs(i.getMinY())),s=e>0?e:0,o=r+2*s,a=Math.trunc(Math.log(o)/Math.log(10)+1),u=n-a,l=Math.pow(10,u);return l},sr.CAP_ROUND=Bi.CAP_ROUND,sr.CAP_BUTT=Bi.CAP_FLAT,sr.CAP_FLAT=Bi.CAP_FLAT,sr.CAP_SQUARE=Bi.CAP_SQUARE,sr.MAX_PRECISION_DIGITS=12;var Co=Object.freeze({BufferOp:sr,BufferParameters:Bi});e(or.prototype,{filter:function(t){t instanceof Tt&&this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return or}}),or.getPolygons=function(){if(1===arguments.length){var t=arguments[0];return or.getPolygons(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Tt?n.add(e):e instanceof ft&&e.apply(new or(n)),n}},e(ar.prototype,{isInsideArea:function(){return this.segIndex===ar.INSIDE_AREA},getCoordinate:function(){return this.pt},getGeometryComponent:function(){return this.component},getSegmentIndex:function(){return this.segIndex},interfaces_:function(){return[]},getClass:function(){return ar}}),ar.INSIDE_AREA=-1,e(ur.prototype,{filter:function(t){t instanceof Lt&&this.pts.add(t)},interfaces_:function(){return[ht]},getClass:function(){return ur}}),ur.getPoints=function(){if(1===arguments.length){var t=arguments[0];return t instanceof Lt?ho.singletonList(t):ur.getPoints(t,new I)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return e instanceof Lt?n.add(e):e instanceof ft&&e.apply(new ur(n)),n}},e(lr.prototype,{filter:function(t){(t instanceof Lt||t instanceof St||t instanceof Tt)&&this.locations.add(new ar(t,0,t.getCoordinate()))},interfaces_:function(){return[ht]},getClass:function(){return lr}}),lr.getLocations=function(t){var e=new I;return t.apply(new lr(e)),e},e(hr.prototype,{computeContainmentDistance:function(){if(0===arguments.length){var t=new Array(2).fill(null);if(this.computeContainmentDistance(0,t),this.minDistance<=this.terminateDistance)return null;this.computeContainmentDistance(1,t)}else if(2===arguments.length){var e=arguments[0],n=arguments[1],i=1-e,r=or.getPolygons(this.geom[e]);if(r.size()>0){var s=lr.getLocations(this.geom[i]);if(this.computeContainmentDistance(s,r,n),this.minDistance<=this.terminateDistance)return this.minDistanceLocation[i]=n[0],this.minDistanceLocation[e]=n[1],null}}else if(3===arguments.length)if(arguments[2]instanceof Array&&R(arguments[0],y)&&R(arguments[1],y)){for(var o=arguments[0],a=arguments[1],u=arguments[2],l=0;l<o.size();l++)for(var h=o.get(l),c=0;c<a.size();c++)if(this.computeContainmentDistance(h,a.get(c),u),this.minDistance<=this.terminateDistance)return null}else if(arguments[2]instanceof Array&&arguments[0]instanceof ar&&arguments[1]instanceof Tt){var f=arguments[0],g=arguments[1],d=arguments[2],p=f.getCoordinate();if(L.EXTERIOR!==this.ptLocator.locate(p,g))return this.minDistance=0,d[0]=f,d[1]=new ar(g,p),null}},computeMinDistanceLinesPoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},computeFacetDistance:function(){var t=new Array(2).fill(null),e=kn.getLines(this.geom[0]),n=kn.getLines(this.geom[1]),i=ur.getPoints(this.geom[0]),r=ur.getPoints(this.geom[1]);return this.computeMinDistanceLines(e,n,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(e,r,t),this.updateMinDistance(t,!1),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistanceLinesPoints(n,i,t),this.updateMinDistance(t,!0),this.minDistance<=this.terminateDistance?null:(t[0]=null,t[1]=null,this.computeMinDistancePoints(i,r,t),void this.updateMinDistance(t,!1))))},nearestLocations:function(){return this.computeMinDistance(),this.minDistanceLocation},updateMinDistance:function(t,e){return null===t[0]?null:void(e?(this.minDistanceLocation[0]=t[1],this.minDistanceLocation[1]=t[0]):(this.minDistanceLocation[0]=t[0],this.minDistanceLocation[1]=t[1]))},nearestPoints:function(){this.computeMinDistance();var t=[this.minDistanceLocation[0].getCoordinate(),this.minDistanceLocation[1].getCoordinate()];return t},computeMinDistance:function(){if(0===arguments.length){if(null!==this.minDistanceLocation)return null;if(this.minDistanceLocation=new Array(2).fill(null),this.computeContainmentDistance(),this.minDistance<=this.terminateDistance)return null;this.computeFacetDistance()}else if(3===arguments.length)if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof Lt){var t=arguments[0],e=arguments[1],n=arguments[2];if(t.getEnvelopeInternal().distance(e.getEnvelopeInternal())>this.minDistance)return null;for(var i=t.getCoordinates(),r=e.getCoordinate(),s=0;s<i.length-1;s++){var o=he.distancePointLine(r,i[s],i[s+1]);if(o<this.minDistance){this.minDistance=o;var a=new ce(i[s],i[s+1]),u=a.closestPoint(r);n[0]=new ar(t,s,u),n[1]=new ar(e,0,r)}if(this.minDistance<=this.terminateDistance)return null}}else if(arguments[2]instanceof Array&&arguments[0]instanceof St&&arguments[1]instanceof St){var l=arguments[0],h=arguments[1],c=arguments[2];if(l.getEnvelopeInternal().distance(h.getEnvelopeInternal())>this.minDistance)return null;for(var i=l.getCoordinates(),f=h.getCoordinates(),s=0;s<i.length-1;s++)for(var g=0;g<f.length-1;g++){var o=he.distanceLineLine(i[s],i[s+1],f[g],f[g+1]);if(o<this.minDistance){this.minDistance=o;var d=new ce(i[s],i[s+1]),p=new ce(f[g],f[g+1]),v=d.closestPoints(p);c[0]=new ar(l,s,v[0]),c[1]=new ar(h,g,v[1])}if(this.minDistance<=this.terminateDistance)return null}}},computeMinDistancePoints:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s),a=r.getCoordinate().distance(o.getCoordinate());if(a<this.minDistance&&(this.minDistance=a,n[0]=new ar(r,0,r.getCoordinate()),n[1]=new ar(o,0,o.getCoordinate())),this.minDistance<=this.terminateDistance)return null}},distance:function(){if(null===this.geom[0]||null===this.geom[1])throw new i("null geometries are not supported");return this.geom[0].isEmpty()||this.geom[1].isEmpty()?0:(this.computeMinDistance(),this.minDistance)},computeMinDistanceLines:function(t,e,n){for(var i=0;i<t.size();i++)for(var r=t.get(i),s=0;s<e.size();s++){var o=e.get(s);if(this.computeMinDistance(r,o,n),this.minDistance<=this.terminateDistance)return null}},interfaces_:function(){return[]},getClass:function(){return hr}}),hr.distance=function(t,e){var n=new hr(t,e);return n.distance()},hr.isWithinDistance=function(t,e,n){var i=new hr(t,e,n);return i.distance()<=n},hr.nearestPoints=function(t,e){var n=new hr(t,e);return n.nearestPoints()};var So=Object.freeze({DistanceOp:hr});e(cr.prototype,{getCoordinates:function(){if(null===this.coordinates){for(var t=0,e=0,n=new N,i=this.directedEdges.iterator();i.hasNext();){var r=i.next();r.getEdgeDirection()?t++:e++,n.add(r.getEdge().getLine().getCoordinates(),!1,r.getEdgeDirection())}this.coordinates=n.toCoordinateArray(),e>t&&H.reverse(this.coordinates)}return this.coordinates},toLineString:function(){return this.factory.createLineString(this.getCoordinates())},add:function(t){this.directedEdges.add(t)},interfaces_:function(){return[]},getClass:function(){return cr}}),e(fr.prototype,{setVisited:function(t){this._isVisited=t},isMarked:function(){return this._isMarked},setData:function(t){this.data=t},getData:function(){return this.data},setMarked:function(t){this._isMarked=t},getContext:function(){return this.data},isVisited:function(){return this._isVisited},setContext:function(t){this.data=t},interfaces_:function(){return[]},getClass:function(){return fr}}),fr.getComponentWithVisitedState=function(t,e){for(;t.hasNext();){var n=t.next();if(n.isVisited()===e)return n}return null},fr.setVisited=function(t,e){for(;t.hasNext();){var n=t.next();n.setVisited(e)}},fr.setMarked=function(t,e){for(;t.hasNext();){var n=t.next();n.setMarked(e)}},h(gr,fr),e(gr.prototype,{isRemoved:function(){return null===this.parentEdge},compareDirection:function(t){return this.quadrant>t.quadrant?1:this.quadrant<t.quadrant?-1:he.computeOrientation(t.p0,t.p1,this.p1)},getCoordinate:function(){return this.from.getCoordinate()},print:function(t){var e=this.getClass().getName(),n=e.lastIndexOf("."),i=e.substring(n+1);t.print("  "+i+": "+this.p0+" - "+this.p1+" "+this.quadrant+":"+this.angle)},getDirectionPt:function(){return this.p1},getAngle:function(){return this.angle},compareTo:function(t){var e=t;return this.compareDirection(e)},getFromNode:function(){return this.from},getSym:function(){return this.sym},setEdge:function(t){this.parentEdge=t},remove:function(){this.sym=null,this.parentEdge=null},getEdge:function(){return this.parentEdge},getQuadrant:function(){return this.quadrant},setSym:function(t){this.sym=t},getToNode:function(){return this.to},getEdgeDirection:function(){return this.edgeDirection},interfaces_:function(){return[s]},getClass:function(){return gr}}),gr.toEdges=function(t){for(var e=new I,n=t.iterator();n.hasNext();)e.add(n.next().parentEdge);return e},h(dr,gr),e(dr.prototype,{getNext:function(){return 2!==this.getToNode().getDegree()?null:this.getToNode().getOutEdges().getEdges().get(0)===this.getSym()?this.getToNode().getOutEdges().getEdges().get(1):(f.isTrue(this.getToNode().getOutEdges().getEdges().get(1)===this.getSym()),this.getToNode().getOutEdges().getEdges().get(0))},interfaces_:function(){return[]},getClass:function(){return dr}}),h(pr,fr),e(pr.prototype,{isRemoved:function(){return null===this.dirEdge},setDirectedEdges:function(t,e){this.dirEdge=[t,e],t.setEdge(this),e.setEdge(this),t.setSym(e),e.setSym(t),t.getFromNode().addOutEdge(t),e.getFromNode().addOutEdge(e)},getDirEdge:function(){if(Number.isInteger(arguments[0])){var t=arguments[0];return this.dirEdge[t]}if(arguments[0]instanceof mr){var e=arguments[0];return this.dirEdge[0].getFromNode()===e?this.dirEdge[0]:this.dirEdge[1].getFromNode()===e?this.dirEdge[1]:null}},remove:function(){this.dirEdge=null},getOppositeNode:function(t){return this.dirEdge[0].getFromNode()===t?this.dirEdge[0].getToNode():this.dirEdge[1].getFromNode()===t?this.dirEdge[1].getToNode():null},interfaces_:function(){return[]},getClass:function(){return pr}}),e(vr.prototype,{getNextEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e+1))},getCoordinate:function(){var t=this.iterator();if(!t.hasNext())return null;var e=t.next();return e.getCoordinate()},iterator:function(){return this.sortEdges(),this.outEdges.iterator()},sortEdges:function(){this.sorted||(ho.sort(this.outEdges),this.sorted=!0)},remove:function(t){this.outEdges.remove(t)},getEdges:function(){return this.sortEdges(),this.outEdges},getNextCWEdge:function(t){var e=this.getIndex(t);return this.outEdges.get(this.getIndex(e-1))},getIndex:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n.getEdge()===t)return e}return-1}if(arguments[0]instanceof gr){var i=arguments[0];this.sortEdges();for(var e=0;e<this.outEdges.size();e++){var n=this.outEdges.get(e);if(n===i)return e}return-1}if(Number.isInteger(arguments[0])){var r=arguments[0],s=r%this.outEdges.size();return 0>s&&(s+=this.outEdges.size()),s}},add:function(t){this.outEdges.add(t),this.sorted=!1},getDegree:function(){return this.outEdges.size()},interfaces_:function(){return[]},getClass:function(){return vr}}),h(mr,fr),e(mr.prototype,{isRemoved:function(){return null===this.pt},addOutEdge:function(t){this.deStar.add(t)},getCoordinate:function(){return this.pt},getOutEdges:function(){return this.deStar},remove:function(){if(0===arguments.length)this.pt=null;else if(1===arguments.length){var t=arguments[0];this.deStar.remove(t)}},getIndex:function(t){return this.deStar.getIndex(t)},getDegree:function(){return this.deStar.getDegree()},interfaces_:function(){return[]},getClass:function(){return mr}}),mr.getEdgesBetween=function(t,e){var n=gr.toEdges(t.getOutEdges().getEdges()),i=new J(n),r=gr.toEdges(e.getOutEdges().getEdges());return i.retainAll(r),i},h(yr,pr),e(yr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return yr}}),e(xr.prototype,{find:function(t){return this.nodeMap.get(t)},iterator:function(){return this.nodeMap.values().iterator()},remove:function(t){return this.nodeMap.remove(t)},values:function(){return this.nodeMap.values()},add:function(t){return this.nodeMap.put(t.getCoordinate(),t),t},interfaces_:function(){return[]},getClass:function(){return xr}}),e(Er.prototype,{findNodesOfDegree:function(t){for(var e=new I,n=this.nodeIterator();n.hasNext();){var i=n.next();i.getDegree()===t&&e.add(i)}return e},dirEdgeIterator:function(){return this.dirEdges.iterator()},edgeIterator:function(){return this.edges.iterator()},remove:function(){if(arguments[0]instanceof pr){var t=arguments[0];this.remove(t.getDirEdge(0)),this.remove(t.getDirEdge(1)),this.edges.remove(t),t.remove()}else if(arguments[0]instanceof gr){var e=arguments[0],n=e.getSym();null!==n&&n.setSym(null),e.getFromNode().remove(e),e.remove(),this.dirEdges.remove(e)}else if(arguments[0]instanceof mr){for(var i=arguments[0],r=i.getOutEdges().getEdges(),s=r.iterator();s.hasNext();){var o=s.next(),n=o.getSym();null!==n&&this.remove(n),this.dirEdges.remove(o);var a=o.getEdge();null!==a&&this.edges.remove(a)}this.nodeMap.remove(i.getCoordinate()),i.remove()}},findNode:function(t){return this.nodeMap.find(t)},getEdges:function(){return this.edges},nodeIterator:function(){return this.nodeMap.iterator()},contains:function(){if(arguments[0]instanceof pr){var t=arguments[0];return this.edges.contains(t)}if(arguments[0]instanceof gr){var e=arguments[0];return this.dirEdges.contains(e)}},add:function(){if(arguments[0]instanceof mr){var t=arguments[0];this.nodeMap.add(t)}else if(arguments[0]instanceof pr){var e=arguments[0];this.edges.add(e),this.add(e.getDirEdge(0)),this.add(e.getDirEdge(1))}else if(arguments[0]instanceof gr){var n=arguments[0];this.dirEdges.add(n)}},getNodes:function(){return this.nodeMap.values()},interfaces_:function(){return[]},getClass:function(){return Er}}),h(Ir,Er),e(Ir.prototype,{addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<=1)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new dr(r,s,e[1],!0),a=new dr(s,r,e[e.length-2],!1),u=new yr(t);u.setDirectedEdges(o,a),this.add(u)},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},interfaces_:function(){return[]},getClass:function(){return Ir}}),e(Nr.prototype,{buildEdgeStringsForUnprocessedNodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();e.isMarked()||(f.isTrue(2===e.getDegree()),this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForNonDegree2Nodes:function(){for(var t=this.graph.getNodes().iterator();t.hasNext();){var e=t.next();2!==e.getDegree()&&(this.buildEdgeStringsStartingAt(e),e.setMarked(!0))}},buildEdgeStringsForObviousStartNodes:function(){this.buildEdgeStringsForNonDegree2Nodes()},getMergedLineStrings:function(){return this.merge(),this.mergedLineStrings},buildEdgeStringsStartingAt:function(t){for(var e=t.getOutEdges().iterator();e.hasNext();){var n=e.next();n.getEdge().isMarked()||this.edgeStrings.add(this.buildEdgeStringStartingWith(n))}},merge:function(){if(null!==this.mergedLineStrings)return null;fr.setMarked(this.graph.nodeIterator(),!1),fr.setMarked(this.graph.edgeIterator(),!1),this.edgeStrings=new I,this.buildEdgeStringsForObviousStartNodes(),this.buildEdgeStringsForIsolatedLoops(),this.mergedLineStrings=new I;for(var t=this.edgeStrings.iterator();t.hasNext();){var e=t.next();this.mergedLineStrings.add(e.toLineString())}},buildEdgeStringStartingWith:function(t){var e=new cr(this.factory),n=t;do e.add(n),n.getEdge().setMarked(!0),n=n.getNext();while(null!==n&&n!==t);return e},add:function(){if(arguments[0]instanceof B){var t=arguments[0];t.apply({interfaces_:function(){return[q]},filter:function(t){t instanceof St&&this.add(t)}})}else if(R(arguments[0],v)){var e=arguments[0];this.mergedLineStrings=null;for(var n=e.iterator();n.hasNext();){
var i=n.next();this.add(i)}}else if(arguments[0]instanceof St){var r=arguments[0];null===this.factory&&(this.factory=r.getFactory()),this.graph.addEdge(r)}},buildEdgeStringsForIsolatedLoops:function(){this.buildEdgeStringsForUnprocessedNodes()},interfaces_:function(){return[]},getClass:function(){return Nr}});var wo=Object.freeze({LineMerger:Nr}),Lo=Object.freeze({OverlayOp:ii});h(Cr,gr),e(Cr.prototype,{getNext:function(){return this.next},isInRing:function(){return null!==this.edgeRing},setRing:function(t){this.edgeRing=t},setLabel:function(t){this.label=t},getLabel:function(){return this.label},setNext:function(t){this.next=t},getRing:function(){return this.edgeRing},interfaces_:function(){return[]},getClass:function(){return Cr}}),h(Sr,pr),e(Sr.prototype,{getLine:function(){return this.line},interfaces_:function(){return[]},getClass:function(){return Sr}}),e(wr.prototype,{isIncluded:function(){return this._isIncluded},getCoordinates:function(){if(null===this.ringPts){for(var t=new N,e=this.deList.iterator();e.hasNext();){var n=e.next(),i=n.getEdge();wr.addEdge(i.getLine().getCoordinates(),n.getEdgeDirection(),t)}this.ringPts=t.toCoordinateArray()}return this.ringPts},isIncludedSet:function(){return this._isIncludedSet},isValid:function(){return this.getCoordinates(),this.ringPts.length<=3?!1:(this.getRing(),this.ring.isValid())},build:function(t){var e=t;do this.add(e),e.setRing(this),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t)},isOuterHole:function(){return this._isHole?!this.hasShell():!1},getPolygon:function(){var t=null;if(null!==this.holes){t=new Array(this.holes.size()).fill(null);for(var e=0;e<this.holes.size();e++)t[e]=this.holes.get(e)}var n=this.factory.createPolygon(this.ring,t);return n},isHole:function(){return this._isHole},isProcessed:function(){return this._isProcessed},addHole:function(){if(arguments[0]instanceof bt){var t=arguments[0];null===this.holes&&(this.holes=new I),this.holes.add(t)}else if(arguments[0]instanceof wr){var e=arguments[0];e.setShell(this);var n=e.getRing();null===this.holes&&(this.holes=new I),this.holes.add(n)}},setIncluded:function(t){this._isIncluded=t,this._isIncludedSet=!0},getOuterHole:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing();if(n.isOuterHole())return n}return null},computeHole:function(){var t=this.getRing();this._isHole=he.isCCW(t.getCoordinates())},hasShell:function(){return null!==this.shell},isOuterShell:function(){return null!==this.getOuterHole()},getLineString:function(){return this.getCoordinates(),this.factory.createLineString(this.ringPts)},toString:function(){return se.toLineString(new Gt(this.getCoordinates()))},getShell:function(){return this.isHole()?this.shell:this},add:function(t){this.deList.add(t)},getRing:function(){if(null!==this.ring)return this.ring;this.getCoordinates(),this.ringPts.length<3&&A.out.println(this.ringPts);try{this.ring=this.factory.createLinearRing(this.ringPts)}catch(t){if(!(t instanceof S))throw t;A.out.println(this.ringPts)}finally{}return this.ring},updateIncluded:function(){if(this.isHole())return null;for(var t=0;t<this.deList.size();t++){var e=this.deList.get(t),n=e.getSym().getRing().getShell();if(null!==n&&n.isIncludedSet())return this.setIncluded(!n.isIncluded()),null}},setShell:function(t){this.shell=t},setProcessed:function(t){this._isProcessed=t},interfaces_:function(){return[]},getClass:function(){return wr}}),wr.findDirEdgesInRing=function(t){var e=t,n=new I;do n.add(e),e=e.getNext(),f.isTrue(null!==e,"found null DE in ring"),f.isTrue(e===t||!e.isInRing(),"found DE already in ring");while(e!==t);return n},wr.addEdge=function(t,e,n){if(e)for(var i=0;i<t.length;i++)n.add(t[i],!1);else for(var i=t.length-1;i>=0;i--)n.add(t[i],!1)},wr.findEdgeRingContaining=function(t,e){for(var n=t.getRing(),i=n.getEnvelopeInternal(),r=n.getCoordinateN(0),s=null,o=null,a=e.iterator();a.hasNext();){var u=a.next(),l=u.getRing(),h=l.getEnvelopeInternal();if(!h.equals(i)&&h.contains(i)){r=H.ptNotInList(n.getCoordinates(),l.getCoordinates());var c=!1;he.isPointInRing(r,l.getCoordinates())&&(c=!0),c&&(null===s||o.contains(h))&&(s=u,o=s.getRing().getEnvelopeInternal())}}return s},e(Lr.prototype,{compare:function(t,e){var n=t,i=e;return n.getRing().getEnvelope().compareTo(i.getRing().getEnvelope())},interfaces_:function(){return[a]},getClass:function(){return Lr}}),wr.EnvelopeComparator=Lr,h(Rr,Er),e(Rr.prototype,{findEdgeRing:function(t){var e=new wr(this.factory);return e.build(t),e},computeDepthParity:function(){if(0===arguments.length)for(;;){var t=null;if(null===t)return null;this.computeDepthParity(t)}else if(1===arguments.length){arguments[0]}},computeNextCWEdges:function(){for(var t=this.nodeIterator();t.hasNext();){var e=t.next();Rr.computeNextCWEdges(e)}},addEdge:function(t){if(t.isEmpty())return null;var e=H.removeRepeatedPoints(t.getCoordinates());if(e.length<2)return null;var n=e[0],i=e[e.length-1],r=this.getNode(n),s=this.getNode(i),o=new Cr(r,s,e[1],!0),a=new Cr(s,r,e[e.length-2],!1),u=new Sr(t);u.setDirectedEdges(o,a),this.add(u)},deleteCutEdges:function(){this.computeNextCWEdges(),Rr.findLabeledEdgeRings(this.dirEdges);for(var t=new I,e=this.dirEdges.iterator();e.hasNext();){var n=e.next();if(!n.isMarked()){var i=n.getSym();if(n.getLabel()===i.getLabel()){n.setMarked(!0),i.setMarked(!0);var r=n.getEdge();t.add(r.getLine())}}}return t},getEdgeRings:function(){this.computeNextCWEdges(),Rr.label(this.dirEdges,-1);var t=Rr.findLabeledEdgeRings(this.dirEdges);this.convertMaximalToMinimalEdgeRings(t);for(var e=new I,n=this.dirEdges.iterator();n.hasNext();){var i=n.next();if(!i.isMarked()&&!i.isInRing()){var r=this.findEdgeRing(i);e.add(r)}}return e},getNode:function(t){var e=this.findNode(t);return null===e&&(e=new mr(t),this.add(e)),e},convertMaximalToMinimalEdgeRings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getLabel(),r=Rr.findIntersectionNodes(n,i);if(null!==r)for(var s=r.iterator();s.hasNext();){var o=s.next();Rr.computeNextCCWEdges(o,i)}}},deleteDangles:function(){for(var t=this.findNodesOfDegree(1),e=new J,n=new pe,i=t.iterator();i.hasNext();)n.push(i.next());for(;!n.isEmpty();){var r=n.pop();Rr.deleteAllEdges(r);for(var s=r.getOutEdges().getEdges(),i=s.iterator();i.hasNext();){var o=i.next();o.setMarked(!0);var a=o.getSym();null!==a&&a.setMarked(!0);var u=o.getEdge();e.add(u.getLine());var l=o.getToNode();1===Rr.getDegreeNonDeleted(l)&&n.push(l)}}return e},interfaces_:function(){return[]},getClass:function(){return Rr}}),Rr.findLabeledEdgeRings=function(t){for(var e=new I,n=1,i=t.iterator();i.hasNext();){var r=i.next();if(!(r.isMarked()||r.getLabel()>=0)){e.add(r);var s=wr.findDirEdgesInRing(r);Rr.label(s,n),n++}}return e},Rr.getDegreeNonDeleted=function(t){for(var e=t.getOutEdges().getEdges(),n=0,i=e.iterator();i.hasNext();){var r=i.next();r.isMarked()||n++}return n},Rr.deleteAllEdges=function(t){for(var e=t.getOutEdges().getEdges(),n=e.iterator();n.hasNext();){var i=n.next();i.setMarked(!0);var r=i.getSym();null!==r&&r.setMarked(!0)}},Rr.label=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();i.setLabel(e)}},Rr.computeNextCWEdges=function(t){for(var e=t.getOutEdges(),n=null,i=null,r=e.getEdges().iterator();r.hasNext();){var s=r.next();if(!s.isMarked()){if(null===n&&(n=s),null!==i){var o=i.getSym();o.setNext(s)}i=s}}if(null!==i){var o=i.getSym();o.setNext(n)}},Rr.computeNextCCWEdges=function(t,e){for(var n=t.getOutEdges(),i=null,r=null,s=n.getEdges(),o=s.size()-1;o>=0;o--){var a=s.get(o),u=a.getSym(),l=null;a.getLabel()===e&&(l=a);var h=null;u.getLabel()===e&&(h=u),null===l&&null===h||(null!==h&&(r=h),null!==l&&(null!==r&&(r.setNext(l),r=null),null===i&&(i=l)))}null!==r&&(f.isTrue(null!==i),r.setNext(i))},Rr.getDegree=function(t,e){for(var n=t.getOutEdges().getEdges(),i=0,r=n.iterator();r.hasNext();){var s=r.next();s.getLabel()===e&&i++}return i},Rr.findIntersectionNodes=function(t,e){var n=t,i=null;do{var r=n.getFromNode();Rr.getDegree(r,e)>1&&(null===i&&(i=new I),i.add(r)),n=n.getNext(),f.isTrue(null!==n,"found null DE in ring"),f.isTrue(n===t||!n.isInRing(),"found DE already in ring")}while(n!==t);return i},e(Tr.prototype,{getGeometry:function(){return null===this.geomFactory&&(this.geomFactory=new ie),this.polygonize(),this.extractOnlyPolygonal?this.geomFactory.buildGeometry(this.polyList):this.geomFactory.createGeometryCollection(ie.toGeometryArray(this.polyList))},getInvalidRingLines:function(){return this.polygonize(),this.invalidRingLines},findValidRings:function(t,e,n){for(var i=t.iterator();i.hasNext();){var r=i.next();r.isValid()?e.add(r):n.add(r.getLineString())}},polygonize:function(){if(null!==this.polyList)return null;if(this.polyList=new I,null===this.graph)return null;this.dangles=this.graph.deleteDangles(),this.cutEdges=this.graph.deleteCutEdges();var t=this.graph.getEdgeRings(),e=new I;this.invalidRingLines=new I,this.isCheckingRingsValid?this.findValidRings(t,e,this.invalidRingLines):e=t,this.findShellsAndHoles(e),Tr.assignHolesToShells(this.holeList,this.shellList),ho.sort(this.shellList,new wr.EnvelopeComparator);var n=!0;this.extractOnlyPolygonal&&(Tr.findDisjointShells(this.shellList),n=!1),this.polyList=Tr.extractPolygons(this.shellList,n)},getDangles:function(){return this.polygonize(),this.dangles},getCutEdges:function(){return this.polygonize(),this.cutEdges},getPolygons:function(){return this.polygonize(),this.polyList},add:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.add(n)}else if(arguments[0]instanceof St){var i=arguments[0];this.geomFactory=i.getFactory(),null===this.graph&&(this.graph=new Rr(this.geomFactory)),this.graph.addEdge(i)}else if(arguments[0]instanceof B){var r=arguments[0];r.apply(this.lineStringAdder)}},setCheckRingsValid:function(t){this.isCheckingRingsValid=t},findShellsAndHoles:function(t){this.holeList=new I,this.shellList=new I;for(var e=t.iterator();e.hasNext();){var n=e.next();n.computeHole(),n.isHole()?this.holeList.add(n):this.shellList.add(n)}},interfaces_:function(){return[]},getClass:function(){return Tr}}),Tr.findOuterShells=function(t){for(var e=t.iterator();e.hasNext();){var n=e.next(),i=n.getOuterHole();null===i||i.isProcessed()||(n.setIncluded(!0),i.setProcessed(!0))}},Tr.extractPolygons=function(t,e){for(var n=new I,i=t.iterator();i.hasNext();){var r=i.next();(e||r.isIncluded())&&n.add(r.getPolygon())}return n},Tr.assignHolesToShells=function(t,e){for(var n=t.iterator();n.hasNext();){var i=n.next();Tr.assignHoleToShell(i,e)}},Tr.assignHoleToShell=function(t,e){var n=wr.findEdgeRingContaining(t,e);null!==n&&n.addHole(t)},Tr.findDisjointShells=function(t){Tr.findOuterShells(t);var e=null;do{e=!1;for(var n=t.iterator();n.hasNext();){var i=n.next();i.isIncludedSet()||(i.updateIncluded(),i.isIncludedSet()||(e=!0))}}while(e)},e(Pr.prototype,{filter:function(t){t instanceof St&&this.p.add(t)},interfaces_:function(){return[q]},getClass:function(){return Pr}}),Tr.LineStringAdder=Pr;var Ro=Object.freeze({Polygonizer:Tr});e(br.prototype,{createEdgeEndForNext:function(t,e,n,i){var r=n.segmentIndex+1;if(r>=t.getNumPoints()&&null===i)return null;var s=t.getCoordinate(r);null!==i&&i.segmentIndex===n.segmentIndex&&(s=i.coord);var o=new En(t,n.coord,s,new gn(t.getLabel()));e.add(o)},createEdgeEndForPrev:function(t,e,n,i){var r=n.segmentIndex;if(0===n.dist){if(0===r)return null;r--}var s=t.getCoordinate(r);null!==i&&i.segmentIndex>=r&&(s=i.coord);var o=new gn(t.getLabel());o.flip();var a=new En(t,n.coord,s,o);e.add(a)},computeEdgeEnds:function(){if(1===arguments.length){for(var t=arguments[0],e=new I,n=t;n.hasNext();){var i=n.next();this.computeEdgeEnds(i,e)}return e}if(2===arguments.length){var r=arguments[0],s=arguments[1],o=r.getEdgeIntersectionList();o.addEndpoints();var a=o.iterator(),u=null,l=null;if(!a.hasNext())return null;var h=a.next();do u=l,l=h,h=null,a.hasNext()&&(h=a.next()),null!==l&&(this.createEdgeEndForPrev(r,s,l,u),this.createEdgeEndForNext(r,s,l,h));while(null!==l)}},interfaces_:function(){return[]},getClass:function(){return br}}),h(Or,En),e(Or.prototype,{insert:function(t){this.edgeEnds.add(t)},print:function(t){t.println("EdgeEndBundle--> Label: "+this.label);for(var e=this.iterator();e.hasNext();){var n=e.next();n.print(t),t.println()}},iterator:function(){return this.edgeEnds.iterator()},getEdgeEnds:function(){return this.edgeEnds},computeLabelOn:function(t,e){for(var n=0,i=!1,r=this.iterator();r.hasNext();){var s=r.next(),o=s.getLabel().getLocation(t);o===L.BOUNDARY&&n++,o===L.INTERIOR&&(i=!0)}var o=L.NONE;i&&(o=L.INTERIOR),n>0&&(o=$n.determineBoundary(e,n)),this.label.setLocation(t,o)},computeLabelSide:function(t,e){for(var n=this.iterator();n.hasNext();){var i=n.next();if(i.getLabel().isArea()){var r=i.getLabel().getLocation(t,e);if(r===L.INTERIOR)return this.label.setLocation(t,e,L.INTERIOR),null;r===L.EXTERIOR&&this.label.setLocation(t,e,L.EXTERIOR)}}},getLabel:function(){return this.label},computeLabelSides:function(t){this.computeLabelSide(t,cn.LEFT),this.computeLabelSide(t,cn.RIGHT)},updateIM:function(t){Jn.updateIM(this.label,t)},computeLabel:function(t){for(var e=!1,n=this.iterator();n.hasNext();){var i=n.next();i.getLabel().isArea()&&(e=!0)}e?this.label=new gn(L.NONE,L.NONE,L.NONE):this.label=new gn(L.NONE);for(var r=0;2>r;r++)this.computeLabelOn(r,t),e&&this.computeLabelSides(r)},interfaces_:function(){return[]},getClass:function(){return Or}}),h(_r,Pn),e(_r.prototype,{updateIM:function(t){for(var e=this.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}},insert:function(t){var e=this.edgeMap.get(t);null===e?(e=new Or(t),this.insertEdgeEnd(t,e)):e.insert(t)},interfaces_:function(){return[]},getClass:function(){return _r}}),h(Mr,yn),e(Mr.prototype,{updateIMFromEdges:function(t){this.edges.updateIM(t)},computeIM:function(t){t.setAtLeastIfValid(this.label.getLocation(0),this.label.getLocation(1),0)},interfaces_:function(){return[]},getClass:function(){return Mr}}),h(Dr,Nn),e(Dr.prototype,{createNode:function(t){return new Mr(t,new _r)},interfaces_:function(){return[]},getClass:function(){return Dr}}),e(Ar.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},computeProperIntersectionIM:function(t,e){var n=this.arg[0].getGeometry().getDimension(),i=this.arg[1].getGeometry().getDimension(),r=t.hasProperIntersection(),s=t.hasProperInteriorIntersection();2===n&&2===i?r&&e.setAtLeast("212101212"):2===n&&1===i?(r&&e.setAtLeast("FFF0FFFF2"),s&&e.setAtLeast("1FFFFF1FF")):1===n&&2===i?(r&&e.setAtLeast("F0FFFFFF2"),s&&e.setAtLeast("1F1FFFFFF")):1===n&&1===i&&s&&e.setAtLeast("0FFFFFFFF")},labelIsolatedEdges:function(t,e){for(var n=this.arg[t].getEdgeIterator();n.hasNext();){var i=n.next();i.isIsolated()&&(this.labelIsolatedEdge(i,e,this.arg[e].getGeometry()),this.isolatedEdges.add(i))}},labelIsolatedEdge:function(t,e,n){if(n.getDimension()>0){var i=this.ptLocator.locate(t.getCoordinate(),n);t.getLabel().setAllLocations(e,i)}else t.getLabel().setAllLocations(e,L.EXTERIOR)},computeIM:function(){var t=new fe;if(t.set(L.EXTERIOR,L.EXTERIOR,2),!this.arg[0].getGeometry().getEnvelopeInternal().intersects(this.arg[1].getGeometry().getEnvelopeInternal()))return this.computeDisjointIM(t),t;this.arg[0].computeSelfNodes(this.li,!1),this.arg[1].computeSelfNodes(this.li,!1);var e=this.arg[0].computeEdgeIntersections(this.arg[1],this.li,!1);this.computeIntersectionNodes(0),this.computeIntersectionNodes(1),this.copyNodesAndLabels(0),this.copyNodesAndLabels(1),this.labelIsolatedNodes(),this.computeProperIntersectionIM(e,t);var n=new br,i=n.computeEdgeEnds(this.arg[0].getEdgeIterator());this.insertEdgeEnds(i);var r=n.computeEdgeEnds(this.arg[1].getEdgeIterator());return this.insertEdgeEnds(r),this.labelNodeEdges(),this.labelIsolatedEdges(0,1),this.labelIsolatedEdges(1,0),this.updateIM(t),t},labelNodeEdges:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next();e.getEdges().computeLabelling(this.arg)}},copyNodesAndLabels:function(t){for(var e=this.arg[t].getNodeIterator();e.hasNext();){var n=e.next(),i=this.nodes.addNode(n.getCoordinate());i.setLabel(t,n.getLabel().getLocation(t))}},labelIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.find(s.coord);o.getLabel().isNull(t)&&(i===L.BOUNDARY?o.setLabelBoundary(t):o.setLabel(t,L.INTERIOR))}},labelIsolatedNode:function(t,e){var n=this.ptLocator.locate(t.getCoordinate(),this.arg[e].getGeometry());t.getLabel().setAllLocations(e,n)},computeIntersectionNodes:function(t){for(var e=this.arg[t].getEdgeIterator();e.hasNext();)for(var n=e.next(),i=n.getLabel().getLocation(t),r=n.getEdgeIntersectionList().iterator();r.hasNext();){var s=r.next(),o=this.nodes.addNode(s.coord);i===L.BOUNDARY?o.setLabelBoundary(t):o.getLabel().isNull(t)&&o.setLabel(t,L.INTERIOR)}},labelIsolatedNodes:function(){for(var t=this.nodes.iterator();t.hasNext();){var e=t.next(),n=e.getLabel();f.isTrue(n.getGeometryCount()>0,"node with empty label found"),e.isIsolated()&&(n.isNull(0)?this.labelIsolatedNode(e,0):this.labelIsolatedNode(e,1))}},updateIM:function(t){for(var e=this.isolatedEdges.iterator();e.hasNext();){var n=e.next();n.updateIM(t)}for(var i=this.nodes.iterator();i.hasNext();){var r=i.next();r.updateIM(t),r.updateIMFromEdges(t)}},computeDisjointIM:function(t){var e=this.arg[0].getGeometry();e.isEmpty()||(t.set(L.INTERIOR,L.EXTERIOR,e.getDimension()),t.set(L.BOUNDARY,L.EXTERIOR,e.getBoundaryDimension()));var n=this.arg[1].getGeometry();n.isEmpty()||(t.set(L.EXTERIOR,L.INTERIOR,n.getDimension()),t.set(L.EXTERIOR,L.BOUNDARY,n.getBoundaryDimension()))},interfaces_:function(){return[]},getClass:function(){return Ar}}),e(Fr.prototype,{isContainedInBoundary:function(t){if(t instanceof Tt)return!1;if(t instanceof Lt)return this.isPointContainedInBoundary(t);if(t instanceof St)return this.isLineStringContainedInBoundary(t);for(var e=0;e<t.getNumGeometries();e++){var n=t.getGeometryN(e);if(!this.isContainedInBoundary(n))return!1}return!0},isLineSegmentContainedInBoundary:function(t,e){if(t.equals(e))return this.isPointContainedInBoundary(t);if(t.x===e.x){if(t.x===this.rectEnv.getMinX()||t.x===this.rectEnv.getMaxX())return!0}else if(t.y===e.y&&(t.y===this.rectEnv.getMinY()||t.y===this.rectEnv.getMaxY()))return!0;return!1},isLineStringContainedInBoundary:function(t){for(var e=t.getCoordinateSequence(),n=new g,i=new g,r=0;r<e.size()-1;r++)if(e.getCoordinate(r,n),e.getCoordinate(r+1,i),!this.isLineSegmentContainedInBoundary(n,i))return!1;return!0},isPointContainedInBoundary:function(){if(arguments[0]instanceof Lt){var t=arguments[0];return this.isPointContainedInBoundary(t.getCoordinate())}if(arguments[0]instanceof g){var e=arguments[0];return e.x===this.rectEnv.getMinX()||e.x===this.rectEnv.getMaxX()||e.y===this.rectEnv.getMinY()||e.y===this.rectEnv.getMaxY()}},contains:function(t){return this.rectEnv.contains(t.getEnvelopeInternal())?!this.isContainedInBoundary(t):!1},interfaces_:function(){return[]},getClass:function(){return Fr}}),Fr.contains=function(t,e){var n=new Fr(t);return n.contains(e)},e(Gr.prototype,{intersects:function(t,e){var n=new C(t,e);if(!this.rectEnv.intersects(n))return!1;if(this.rectEnv.intersects(t))return!0;if(this.rectEnv.intersects(e))return!0;if(t.compareTo(e)>0){var i=t;t=e,e=i}var r=!1;return e.y>t.y&&(r=!0),r?this.li.computeIntersection(t,e,this.diagDown0,this.diagDown1):this.li.computeIntersection(t,e,this.diagUp0,this.diagUp1),!!this.li.hasIntersection()},interfaces_:function(){return[]},getClass:function(){return Gr}}),e(qr.prototype,{applyTo:function(t){for(var e=0;e<t.getNumGeometries()&&!this._isDone;e++){var n=t.getGeometryN(e);if(n instanceof ft)this.applyTo(n);else if(this.visit(n),this.isDone())return this._isDone=!0,null}},interfaces_:function(){return[]},getClass:function(){return qr}}),e(Br.prototype,{intersects:function(t){if(!this.rectEnv.intersects(t.getEnvelopeInternal()))return!1;var e=new zr(this.rectEnv);if(e.applyTo(t),e.intersects())return!0;var n=new Vr(this.rectangle);if(n.applyTo(t),n.containsPoint())return!0;var i=new kr(this.rectangle);return i.applyTo(t),!!i.intersects()},interfaces_:function(){return[]},getClass:function(){return Br}}),Br.intersects=function(t,e){var n=new Br(t);return n.intersects(e)},h(zr,qr),e(zr.prototype,{isDone:function(){return this._intersects===!0},visit:function(t){var e=t.getEnvelopeInternal();return this.rectEnv.intersects(e)?this.rectEnv.contains(e)?(this._intersects=!0,null):e.getMinX()>=this.rectEnv.getMinX()&&e.getMaxX()<=this.rectEnv.getMaxX()?(this._intersects=!0,null):e.getMinY()>=this.rectEnv.getMinY()&&e.getMaxY()<=this.rectEnv.getMaxY()?(this._intersects=!0,null):void 0:null},intersects:function(){return this._intersects},interfaces_:function(){return[]},getClass:function(){return zr}}),h(Vr,qr),e(Vr.prototype,{isDone:function(){return this._containsPoint===!0},visit:function(t){if(!(t instanceof Tt))return null;var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;for(var n=new g,i=0;4>i;i++)if(this.rectSeq.getCoordinate(i,n),e.contains(n)&&Tn.containsPointInPolygon(n,t))return this._containsPoint=!0,null},containsPoint:function(){return this._containsPoint},interfaces_:function(){return[]},getClass:function(){return Vr}}),h(kr,qr),e(kr.prototype,{intersects:function(){return this.hasIntersection},isDone:function(){return this.hasIntersection===!0},visit:function(t){var e=t.getEnvelopeInternal();if(!this.rectEnv.intersects(e))return null;var n=kn.getLines(t);this.checkIntersectionWithLineStrings(n)},checkIntersectionWithLineStrings:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();if(this.checkIntersectionWithSegments(n),this.hasIntersection)return null}},checkIntersectionWithSegments:function(t){for(var e=t.getCoordinateSequence(),n=1;n<e.size();n++)if(e.getCoordinate(n-1,this.p0),e.getCoordinate(n,this.p1),this.rectIntersector.intersects(this.p0,this.p1))return this.hasIntersection=!0,null},interfaces_:function(){return[]},getClass:function(){return kr}}),h(Yr,ti),e(Yr.prototype,{getIntersectionMatrix:function(){return this._relate.computeIM()},interfaces_:function(){return[]},getClass:function(){return Yr}}),Yr.covers=function(t,e){return t.getEnvelopeInternal().covers(e.getEnvelopeInternal())?t.isRectangle()?!0:Yr.relate(t,e).isCovers():!1},Yr.intersects=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?t.isRectangle()?Br.intersects(t,e):e.isRectangle()?Br.intersects(e,t):Yr.relate(t,e).isIntersects():!1},Yr.touches=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isTouches(t.getDimension(),e.getDimension()):!1},Yr.within=function(t,e){return e.contains(t)},Yr.coveredBy=function(t,e){return Yr.covers(e,t)},Yr.relate=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new Yr(t,e),i=n.getIntersectionMatrix();return i}if(3===arguments.length){if("string"==typeof arguments[2]&&arguments[0]instanceof B&&arguments[1]instanceof B){var r=arguments[0],s=arguments[1],o=arguments[2];return Yr.relateWithCheck(r,s).matches(o)}if(R(arguments[2],V)&&arguments[0]instanceof B&&arguments[1]instanceof B){var a=arguments[0],u=arguments[1],l=arguments[2],n=new Yr(a,u,l),i=n.getIntersectionMatrix();return i}}},Yr.overlaps=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isOverlaps(t.getDimension(),e.getDimension()):!1},Yr.disjoint=function(t,e){return!t.intersects(e)},Yr.relateWithCheck=function(t,e){return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),Yr.relate(t,e)},Yr.crosses=function(t,e){return t.getEnvelopeInternal().intersects(e.getEnvelopeInternal())?Yr.relate(t,e).isCrosses(t.getDimension(),e.getDimension()):!1},Yr.contains=function(t,e){return t.getEnvelopeInternal().contains(e.getEnvelopeInternal())?t.isRectangle()?Fr.contains(t,e):Yr.relate(t,e).isContains():!1};var To=Object.freeze({RelateOp:Yr});e(Ur.prototype,{extractElements:function(t,e){if(null===t)return null;for(var n=0;n<t.getNumGeometries();n++){var i=t.getGeometryN(n);this.skipEmpty&&i.isEmpty()||e.add(i)}},combine:function(){for(var t=new I,e=this.inputGeoms.iterator();e.hasNext();){var n=e.next();this.extractElements(n,t)}return 0===t.size()?null!==this.geomFactory?this.geomFactory.createGeometryCollection(null):null:this.geomFactory.buildGeometry(t)},interfaces_:function(){return[]},getClass:function(){return Ur}}),Ur.combine=function(){if(1===arguments.length){var t=arguments[0],e=new Ur(t);return e.combine()}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=new Ur(Ur.createList(n,i));return e.combine()}if(3===arguments.length){var r=arguments[0],s=arguments[1],o=arguments[2],e=new Ur(Ur.createList(r,s,o));return e.combine()}},Ur.extractFactory=function(t){return t.isEmpty()?null:t.iterator().next().getFactory()},Ur.createList=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1],n=new I;return n.add(t),n.add(e),n}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2],n=new I;return n.add(i),n.add(r),n.add(s),n}},e(Xr.prototype,{union:function(){for(var t=new Te,e=new at,n=0;n<this.pointGeom.getNumGeometries();n++){var i=this.pointGeom.getGeometryN(n),r=i.getCoordinate(),s=t.locate(r,this.otherGeom);s===L.EXTERIOR&&e.add(r)}if(0===e.size())return this.otherGeom;var o=null,a=H.toCoordinateArray(e);return o=1===a.length?this.geomFact.createPoint(a[0]):this.geomFact.createMultiPointFromCoords(a),Ur.combine(o,this.otherGeom)},interfaces_:function(){return[]},getClass:function(){return Xr}}),Xr.union=function(t,e){var n=new Xr(t,e);return n.union()},e(Hr.prototype,{filter:function(t){-1!==this.sortIndex&&t.getSortIndex()!==this.sortIndex||this.comps.add(t)},interfaces_:function(){return[ht]},getClass:function(){return Hr}}),Hr.extract=function(){if(2===arguments.length){var t=arguments[0],e=arguments[1];return Hr.extract(t,e,new I)}if(3===arguments.length){var n=arguments[0],i=arguments[1],r=arguments[2];return n.getSortIndex()===i?r.add(n):n instanceof ft&&n.apply(new Hr(i,r)),r}},e(Wr.prototype,{reduceToGeometries:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next(),r=null;R(i,y)?r=this.unionTree(i):i instanceof B&&(r=i),e.add(r)}return e},extractByEnvelope:function(t,e,n){for(var i=new I,r=0;r<e.getNumGeometries();r++){var s=e.getGeometryN(r);s.getEnvelopeInternal().intersects(t)?i.add(s):n.add(s)}return this.geomFactory.buildGeometry(i)},unionOptimized:function(t,e){var n=t.getEnvelopeInternal(),i=e.getEnvelopeInternal();if(!n.intersects(i)){var r=Ur.combine(t,e);return r}if(t.getNumGeometries()<=1&&e.getNumGeometries()<=1)return this.unionActual(t,e);var s=n.intersection(i);return this.unionUsingEnvelopeIntersection(t,e,s)},union:function(){if(null===this.inputPolys)throw new IllegalStateException("union() method cannot be called twice");if(this.inputPolys.isEmpty())return null;this.geomFactory=this.inputPolys.iterator().next().getFactory();for(var t=new ke(Wr.STRTREE_NODE_CAPACITY),e=this.inputPolys.iterator();e.hasNext();){var n=e.next();t.insert(n.getEnvelopeInternal(),n)}this.inputPolys=null;var i=t.itemsTree(),r=this.unionTree(i);return r},binaryUnion:function(){if(1===arguments.length){var t=arguments[0];return this.binaryUnion(t,0,t.size())}if(3===arguments.length){var e=arguments[0],n=arguments[1],i=arguments[2];if(1>=i-n){var r=Wr.getGeometry(e,n);return this.unionSafe(r,null)}if(i-n===2)return this.unionSafe(Wr.getGeometry(e,n),Wr.getGeometry(e,n+1));var s=Math.trunc((i+n)/2),r=this.binaryUnion(e,n,s),o=this.binaryUnion(e,s,i);return this.unionSafe(r,o)}},repeatedUnion:function(t){for(var e=null,n=t.iterator();n.hasNext();){var i=n.next();e=null===e?i.copy():e.union(i)}return e},unionSafe:function(t,e){return null===t&&null===e?null:null===t?e.copy():null===e?t.copy():this.unionOptimized(t,e)},unionActual:function(t,e){return Wr.restrictToPolygons(t.union(e))},unionTree:function(t){var e=this.reduceToGeometries(t),n=this.binaryUnion(e);return n},unionUsingEnvelopeIntersection:function(t,e,n){var i=new I,r=this.extractByEnvelope(n,t,i),s=this.extractByEnvelope(n,e,i),o=this.unionActual(r,s);i.add(o);var a=Ur.combine(i);return a},bufferUnion:function(){if(1===arguments.length){var t=arguments[0],e=t.get(0).getFactory(),n=e.buildGeometry(t),i=n.buffer(0);return i}if(2===arguments.length){var r=arguments[0],s=arguments[1],e=r.getFactory(),n=e.createGeometryCollection([r,s]),i=n.buffer(0);return i}},interfaces_:function(){return[]},getClass:function(){return Wr}}),Wr.restrictToPolygons=function(t){if(R(t,Rt))return t;var e=or.getPolygons(t);return 1===e.size()?e.get(0):t.getFactory().createMultiPolygon(ie.toPolygonArray(e))},Wr.getGeometry=function(t,e){return e>=t.size()?null:t.get(e)},Wr.union=function(t){var e=new Wr(t);return e.union()},Wr.STRTREE_NODE_CAPACITY=4,e(jr.prototype,{unionNoOpt:function(t){var e=this.geomFact.createPoint();return si.overlayOp(t,e,ii.UNION)},unionWithNull:function(t,e){return null===t&&null===e?null:null===e?t:null===t?e:t.union(e)},extract:function(){if(R(arguments[0],v))for(var t=arguments[0],e=t.iterator();e.hasNext();){var n=e.next();this.extract(n)}else if(arguments[0]instanceof B){var i=arguments[0];null===this.geomFact&&(this.geomFact=i.getFactory()),Hr.extract(i,B.SORTINDEX_POLYGON,this.polygons),Hr.extract(i,B.SORTINDEX_LINESTRING,this.lines),Hr.extract(i,B.SORTINDEX_POINT,this.points)}},union:function t(){if(null===this.geomFact)return null;var e=null;if(this.points.size()>0){var n=this.geomFact.buildGeometry(this.points);e=this.unionNoOpt(n)}var i=null;if(this.lines.size()>0){var r=this.geomFact.buildGeometry(this.lines);i=this.unionNoOpt(r)}var s=null;this.polygons.size()>0&&(s=Wr.union(this.polygons));var o=this.unionWithNull(i,s),t=null;return t=null===e?o:null===o?e:Xr.union(e,o),null===t?this.geomFact.createGeometryCollection():t},interfaces_:function(){return[]},getClass:function(){return jr}}),jr.union=function(){if(1===arguments.length){if(R(arguments[0],v)){var t=arguments[0],e=new jr(t);return e.union()}if(arguments[0]instanceof B){var n=arguments[0],e=new jr(n);return e.union()}}else if(2===arguments.length){var i=arguments[0],r=arguments[1],e=new jr(i,r);return e.union()}};var Po=Object.freeze({UnaryUnionOp:jr});e(Kr.prototype,{visitInteriorRing:function(t,e){var n=t.getCoordinates(),i=n[0],r=Kr.findDifferentPoint(n,i),s=e.findEdgeInSameDirection(i,r),o=e.findEdgeEnd(s),a=null;o.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR?a=o:o.getSym().getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&(a=o.getSym()),f.isTrue(null!==a,"unable to find dirEdge with Interior on RHS"),this.visitLinkedDirectedEdges(a)},visitShellInteriors:function(t,e){if(t instanceof Tt){var n=t;this.visitInteriorRing(n.getExteriorRing(),e)}if(t instanceof Ot)for(var i=t,r=0;r<i.getNumGeometries();r++){var n=i.getGeometryN(r);this.visitInteriorRing(n.getExteriorRing(),e)}},getCoordinate:function(){return this.disconnectedRingcoord},setInteriorEdgesInResult:function(t){for(var e=t.getEdgeEnds().iterator();e.hasNext();){var n=e.next();n.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR&&n.setInResult(!0)}},visitLinkedDirectedEdges:function(t){var e=t,n=t;do f.isTrue(null!==n,"found null Directed Edge"),n.setVisited(!0),n=n.getNext();while(n!==e)},buildEdgeRings:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();if(i.isInResult()&&null===i.getEdgeRing()){var r=new vn(i,this.geometryFactory);r.linkDirectedEdgesForMinimalEdgeRings();var s=r.buildMinimalRings();e.addAll(s)}}return e},hasUnvisitedShellEdge:function(t){for(var e=0;e<t.size();e++){var n=t.get(e);if(!n.isHole()){var i=n.getEdges(),r=i.get(0);if(r.getLabel().getLocation(0,cn.RIGHT)===L.INTERIOR)for(var s=0;s<i.size();s++)if(r=i.get(s),
!r.isVisited())return this.disconnectedRingcoord=r.getCoordinate(),!0}}return!1},isInteriorsConnected:function(){var t=new I;this.geomGraph.computeSplitEdges(t);var e=new Cn(new On);e.addEdges(t),this.setInteriorEdgesInResult(e),e.linkResultDirectedEdges();var n=this.buildEdgeRings(e.getEdgeEnds());return this.visitShellInteriors(this.geomGraph.getGeometry(),e),!this.hasUnvisitedShellEdge(n)},interfaces_:function(){return[]},getClass:function(){return Kr}}),Kr.findDifferentPoint=function(t,e){for(var n=0;n<t.length;n++)if(!t[n].equals(e))return t[n];return null},e(Zr.prototype,{hasChildren:function(){for(var t=0;2>t;t++)if(null!==this.subnode[t])return!0;return!1},isPrunable:function(){return!(this.hasChildren()||this.hasItems())},addAllItems:function(t){t.addAll(this.items);for(var e=0;2>e;e++)null!==this.subnode[e]&&this.subnode[e].addAllItems(t);return t},size:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].size());return t+this.items.size()},addAllItemsFromOverlapping:function(t,e){return null===t||this.isSearchMatch(t)?(e.addAll(this.items),null!==this.subnode[0]&&this.subnode[0].addAllItemsFromOverlapping(t,e),void(null!==this.subnode[1]&&this.subnode[1].addAllItemsFromOverlapping(t,e))):null},hasItems:function(){return!this.items.isEmpty()},remove:function(t,e){if(!this.isSearchMatch(t))return!1;for(var n=!1,i=0;2>i;i++)if(null!==this.subnode[i]&&(n=this.subnode[i].remove(t,e))){this.subnode[i].isPrunable()&&(this.subnode[i]=null);break}return n?n:n=this.items.remove(e)},getItems:function(){return this.items},depth:function(){for(var t=0,e=0;2>e;e++)if(null!==this.subnode[e]){var n=this.subnode[e].depth();n>t&&(t=n)}return t+1},nodeSize:function(){for(var t=0,e=0;2>e;e++)null!==this.subnode[e]&&(t+=this.subnode[e].nodeSize());return t+1},add:function(t){this.items.add(t)},interfaces_:function(){return[]},getClass:function(){return Zr}}),Zr.getSubnodeIndex=function(t,e){var n=-1;return t.min>=e&&(n=1),t.max<=e&&(n=0),n},e(Qr.prototype,{expandToInclude:function(t){t.max>this.max&&(this.max=t.max),t.min<this.min&&(this.min=t.min)},getWidth:function(){return this.max-this.min},overlaps:function(){if(1===arguments.length){var t=arguments[0];return this.overlaps(t.min,t.max)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return!(this.min>n||this.max<e)}},getMin:function(){return this.min},toString:function(){return"["+this.min+", "+this.max+"]"},contains:function(){if(1===arguments.length){if(arguments[0]instanceof Qr){var t=arguments[0];return this.contains(t.min,t.max)}if("number"==typeof arguments[0]){var e=arguments[0];return e>=this.min&&e<=this.max}}else if(2===arguments.length){var n=arguments[0],i=arguments[1];return n>=this.min&&i<=this.max}},init:function(t,e){this.min=t,this.max=e,t>e&&(this.min=e,this.max=t)},getMax:function(){return this.max},interfaces_:function(){return[]},getClass:function(){return Qr}}),e(Jr.prototype,{getInterval:function(){return this.interval},getLevel:function(){return this.level},computeKey:function(t){for(this.level=Jr.computeLevel(t),this.interval=new Qr,this.computeInterval(this.level,t);!this.interval.contains(t);)this.level+=1,this.computeInterval(this.level,t)},computeInterval:function(t,e){var n=Ci.powerOf2(t);this.pt=Math.floor(e.getMin()/n)*n,this.interval.init(this.pt,this.pt+n)},getPoint:function(){return this.pt},interfaces_:function(){return[]},getClass:function(){return Jr}}),Jr.computeLevel=function(t){var e=t.getWidth(),n=Ci.exponent(e)+1;return n},h($r,Zr),e($r.prototype,{getInterval:function(){return this.interval},find:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1===e)return this;if(null!==this.subnode[e]){var n=this.subnode[e];return n.find(t)}return this},insert:function(t){f.isTrue(null===this.interval||this.interval.contains(t.interval));var e=Zr.getSubnodeIndex(t.interval,this.centre);if(t.level===this.level-1)this.subnode[e]=t;else{var n=this.createSubnode(e);n.insert(t),this.subnode[e]=n}},isSearchMatch:function(t){return t.overlaps(this.interval)},getSubnode:function(t){return null===this.subnode[t]&&(this.subnode[t]=this.createSubnode(t)),this.subnode[t]},getNode:function(t){var e=Zr.getSubnodeIndex(t,this.centre);if(-1!==e){var n=this.getSubnode(e);return n.getNode(t)}return this},createSubnode:function(t){var e=0,n=0;switch(t){case 0:e=this.interval.getMin(),n=this.centre;break;case 1:e=this.centre,n=this.interval.getMax()}var i=new Qr(e,n),r=new $r(i,this.level-1);return r},interfaces_:function(){return[]},getClass:function(){return $r}}),$r.createNode=function(t){var e=new Jr(t),n=new $r(e.getInterval(),e.getLevel());return n},$r.createExpanded=function(t,e){var n=new Qr(e);null!==t&&n.expandToInclude(t.interval);var i=$r.createNode(n);return null!==t&&i.insert(t),i},h(ts,Zr),e(ts.prototype,{insert:function(t,e){var n=Zr.getSubnodeIndex(t,ts.origin);if(-1===n)return this.add(e),null;var i=this.subnode[n];if(null===i||!i.getInterval().contains(t)){var r=$r.createExpanded(i,t);this.subnode[n]=r}this.insertContained(this.subnode[n],t,e)},isSearchMatch:function(t){return!0},insertContained:function(t,e,n){f.isTrue(t.getInterval().contains(e));var i=Ri.isZeroWidth(e.getMin(),e.getMax()),r=null;r=i?t.find(e):t.getNode(e),r.add(n)},interfaces_:function(){return[]},getClass:function(){return ts}}),ts.origin=0,e(es.prototype,{size:function(){return null!==this.root?this.root.size():0},insert:function(t,e){this.collectStats(t);var n=es.ensureExtent(t,this.minExtent);this.root.insert(n,e)},query:function(){if(1===arguments.length){if("number"==typeof arguments[0]){var t=arguments[0];return this.query(new Qr(t,t))}if(arguments[0]instanceof Qr){var e=arguments[0],n=new I;return this.query(e,n),n}}else if(2===arguments.length){var i=arguments[0],r=arguments[1];this.root.addAllItemsFromOverlapping(i,r)}},iterator:function(){var t=new I;return this.root.addAllItems(t),t.iterator()},remove:function(t,e){var n=es.ensureExtent(t,this.minExtent);return this.root.remove(n,e)},collectStats:function(t){var e=t.getWidth();e<this.minExtent&&e>0&&(this.minExtent=e)},depth:function(){return null!==this.root?this.root.depth():0},nodeSize:function(){return null!==this.root?this.root.nodeSize():0},interfaces_:function(){return[]},getClass:function(){return es}}),es.ensureExtent=function(t,e){var n=t.getMin(),i=t.getMax();return n!==i?t:(n===i&&(n-=e/2,i=n+e/2),new Qr(n,i))},e(ns.prototype,{isInside:function(t){},interfaces_:function(){return[]},getClass:function(){return ns}}),e(is.prototype,{testLineSegment:function(t,e){var n=null,i=null,r=null,s=null,o=null,a=e.p0,u=e.p1;i=a.x-t.x,r=a.y-t.y,s=u.x-t.x,o=u.y-t.y,(r>0&&0>=o||o>0&&0>=r)&&(n=ue.signOfDet2x2(i,r,s,o)/(o-r),n>0&&this.crossings++)},buildIndex:function(){this.tree=new es;for(var t=H.removeRepeatedPoints(this.ring.getCoordinates()),e=$e.getChains(t),n=0;n<e.size();n++){var i=e.get(n),r=i.getEnvelope();this.interval.min=r.getMinY(),this.interval.max=r.getMaxY(),this.tree.insert(this.interval,i)}},testMonotoneChain:function(t,e,n){n.select(t,e)},isInside:function(t){this.crossings=0;var e=new C(r.NEGATIVE_INFINITY,r.POSITIVE_INFINITY,t.y,t.y);this.interval.min=t.y,this.interval.max=t.y;for(var n=this.tree.query(this.interval),i=new rs(this,t),s=n.iterator();s.hasNext();){var o=s.next();this.testMonotoneChain(e,i,o)}return this.crossings%2===1},interfaces_:function(){return[ns]},getClass:function(){return is}}),h(rs,tr),e(rs.prototype,{select:function(){if(1!==arguments.length)return tr.prototype.select.apply(this,arguments);var t=arguments[0];this.mcp.testLineSegment(this.p,t)},interfaces_:function(){return[]},getClass:function(){return rs}}),is.MCSelecter=rs,e(ss.prototype,{insertEdgeEnds:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.nodes.add(n)}},getNodeIterator:function(){return this.nodes.iterator()},copyNodesAndLabels:function(t,e){for(var n=t.getNodeIterator();n.hasNext();){var i=n.next(),r=this.nodes.addNode(i.getCoordinate());r.setLabel(e,i.getLabel().getLocation(e))}},build:function(t){this.computeIntersectionNodes(t,0),this.copyNodesAndLabels(t,0);var e=new br,n=e.computeEdgeEnds(t.getEdgeIterator());this.insertEdgeEnds(n)},computeIntersectionNodes:function(t,e){for(var n=t.getEdgeIterator();n.hasNext();)for(var i=n.next(),r=i.getLabel().getLocation(e),s=i.getEdgeIntersectionList().iterator();s.hasNext();){var o=s.next(),a=this.nodes.addNode(o.coord);r===L.BOUNDARY?a.setLabelBoundary(e):a.getLabel().isNull(e)&&a.setLabel(e,L.INTERIOR)}},interfaces_:function(){return[]},getClass:function(){return ss}}),e(os.prototype,{isNodeEdgeAreaLabelsConsistent:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();){var e=t.next();if(!e.getEdges().isAreaLabelsConsistent(this.geomGraph))return this.invalidPoint=e.getCoordinate().copy(),!1}return!0},getInvalidPoint:function(){return this.invalidPoint},hasDuplicateRings:function(){for(var t=this.nodeGraph.getNodeIterator();t.hasNext();)for(var e=t.next(),n=e.getEdges().iterator();n.hasNext();){var i=n.next();if(i.getEdgeEnds().size()>1)return this.invalidPoint=i.getEdge().getCoordinate(0),!0}return!1},isNodeConsistentArea:function(){var t=this.geomGraph.computeSelfNodes(this.li,!0,!0);return t.hasProperIntersection()?(this.invalidPoint=t.getProperIntersectionPoint(),!1):(this.nodeGraph.build(this.geomGraph),this.isNodeEdgeAreaLabelsConsistent())},interfaces_:function(){return[]},getClass:function(){return os}}),e(as.prototype,{buildIndex:function(){this.index=new ke;for(var t=0;t<this.rings.size();t++){var e=this.rings.get(t),n=e.getEnvelopeInternal();this.index.insert(n,e)}},getNestedPoint:function(){return this.nestedPt},isNonNested:function(){this.buildIndex();for(var t=0;t<this.rings.size();t++)for(var e=this.rings.get(t),n=e.getCoordinates(),i=this.index.query(e.getEnvelopeInternal()),r=0;r<i.size();r++){var s=i.get(r),o=s.getCoordinates();if(e!==s&&e.getEnvelopeInternal().intersects(s.getEnvelopeInternal())){var a=ls.findPtNotNode(n,s,this.graph);if(null!==a){var u=he.isPointInRing(a,o);if(u)return this.nestedPt=a,!1}}}return!0},add:function(t){this.rings.add(t),this.totalEnv.expandToInclude(t.getEnvelopeInternal())},interfaces_:function(){return[]},getClass:function(){return as}}),e(us.prototype,{getErrorType:function(){return this.errorType},getMessage:function(){return us.errMsg[this.errorType]},getCoordinate:function(){return this.pt},toString:function(){var t="";return null!==this.pt&&(t=" at or near point "+this.pt),this.getMessage()+t},interfaces_:function(){return[]},getClass:function(){return us}}),us.ERROR=0,us.REPEATED_POINT=1,us.HOLE_OUTSIDE_SHELL=2,us.NESTED_HOLES=3,us.DISCONNECTED_INTERIOR=4,us.SELF_INTERSECTION=5,us.RING_SELF_INTERSECTION=6,us.NESTED_SHELLS=7,us.DUPLICATE_RINGS=8,us.TOO_FEW_POINTS=9,us.INVALID_COORDINATE=10,us.RING_NOT_CLOSED=11,us.errMsg=["Topology Validation Error","Repeated Point","Hole lies outside shell","Holes are nested","Interior is disconnected","Self-intersection","Ring Self-intersection","Nested shells","Duplicate Rings","Too few distinct points in geometry component","Invalid Coordinate","Ring is not closed"],e(ls.prototype,{checkInvalidCoordinates:function(){if(arguments[0]instanceof Array){for(var t=arguments[0],e=0;e<t.length;e++)if(!ls.isValid(t[e]))return this.validErr=new us(us.INVALID_COORDINATE,t[e]),null}else if(arguments[0]instanceof Tt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getExteriorRing().getCoordinates()),null!==this.validErr)return null;for(var e=0;e<n.getNumInteriorRing();e++)if(this.checkInvalidCoordinates(n.getInteriorRingN(e).getCoordinates()),null!==this.validErr)return null}},checkHolesNotNested:function(t,e){for(var n=new as(e),i=0;i<t.getNumInteriorRing();i++){var r=t.getInteriorRingN(i);n.add(r)}var s=n.isNonNested();s||(this.validErr=new us(us.NESTED_HOLES,n.getNestedPoint()))},checkConsistentArea:function(t){var e=new os(t),n=e.isNodeConsistentArea();return n?void(e.hasDuplicateRings()&&(this.validErr=new us(us.DUPLICATE_RINGS,e.getInvalidPoint()))):(this.validErr=new us(us.SELF_INTERSECTION,e.getInvalidPoint()),null)},isValid:function(){return this.checkValid(this.parentGeometry),null===this.validErr},checkShellInsideHole:function(t,e,n){var i=t.getCoordinates(),r=e.getCoordinates(),s=ls.findPtNotNode(i,e,n);if(null!==s){var o=he.isPointInRing(s,r);if(!o)return s}var a=ls.findPtNotNode(r,t,n);if(null!==a){var u=he.isPointInRing(a,i);return u?a:null}return f.shouldNeverReachHere("points in shell and hole appear to be equal"),null},checkNoSelfIntersectingRings:function(t){for(var e=t.getEdgeIterator();e.hasNext();){var n=e.next();if(this.checkNoSelfIntersectingRing(n.getEdgeIntersectionList()),null!==this.validErr)return null}},checkConnectedInteriors:function(t){var e=new Kr(t);e.isInteriorsConnected()||(this.validErr=new us(us.DISCONNECTED_INTERIOR,e.getCoordinate()))},checkNoSelfIntersectingRing:function(t){for(var e=new at,n=!0,i=t.iterator();i.hasNext();){var r=i.next();if(n)n=!1;else{if(e.contains(r.coord))return this.validErr=new us(us.RING_SELF_INTERSECTION,r.coord),null;e.add(r.coord)}}},checkHolesInShell:function(t,e){for(var n=t.getExteriorRing(),i=new is(n),r=0;r<t.getNumInteriorRing();r++){var s=t.getInteriorRingN(r),o=ls.findPtNotNode(s.getCoordinates(),n,e);if(null===o)return null;var a=!i.isInside(o);if(a)return this.validErr=new us(us.HOLE_OUTSIDE_SHELL,o),null}},checkTooFewPoints:function(t){return t.hasTooFewPoints()?(this.validErr=new us(us.TOO_FEW_POINTS,t.getInvalidPoint()),null):void 0},getValidationError:function(){return this.checkValid(this.parentGeometry),this.validErr},checkValid:function(){if(arguments[0]instanceof Lt){var t=arguments[0];this.checkInvalidCoordinates(t.getCoordinates())}else if(arguments[0]instanceof Pt){var e=arguments[0];this.checkInvalidCoordinates(e.getCoordinates())}else if(arguments[0]instanceof bt){var n=arguments[0];if(this.checkInvalidCoordinates(n.getCoordinates()),null!==this.validErr)return null;if(this.checkClosedRing(n),null!==this.validErr)return null;var i=new $n(0,n);if(this.checkTooFewPoints(i),null!==this.validErr)return null;var r=new ae;i.computeSelfNodes(r,!0,!0),this.checkNoSelfIntersectingRings(i)}else if(arguments[0]instanceof St){var s=arguments[0];if(this.checkInvalidCoordinates(s.getCoordinates()),null!==this.validErr)return null;var i=new $n(0,s);this.checkTooFewPoints(i)}else if(arguments[0]instanceof Tt){var o=arguments[0];if(this.checkInvalidCoordinates(o),null!==this.validErr)return null;if(this.checkClosedRings(o),null!==this.validErr)return null;var i=new $n(0,o);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;if(this.checkHolesInShell(o,i),null!==this.validErr)return null;if(this.checkHolesNotNested(o,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof Ot){for(var a=arguments[0],u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkInvalidCoordinates(l),null!==this.validErr)return null;if(this.checkClosedRings(l),null!==this.validErr)return null}var i=new $n(0,a);if(this.checkTooFewPoints(i),null!==this.validErr)return null;if(this.checkConsistentArea(i),null!==this.validErr)return null;if(!this.isSelfTouchingRingFormingHoleValid&&(this.checkNoSelfIntersectingRings(i),null!==this.validErr))return null;for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesInShell(l,i),null!==this.validErr)return null}for(var u=0;u<a.getNumGeometries();u++){var l=a.getGeometryN(u);if(this.checkHolesNotNested(l,i),null!==this.validErr)return null}if(this.checkShellsNotNested(a,i),null!==this.validErr)return null;this.checkConnectedInteriors(i)}else if(arguments[0]instanceof ft)for(var h=arguments[0],u=0;u<h.getNumGeometries();u++){var c=h.getGeometryN(u);if(this.checkValid(c),null!==this.validErr)return null}else if(arguments[0]instanceof B){var f=arguments[0];if(this.validErr=null,f.isEmpty())return null;if(f instanceof Lt)this.checkValid(f);else if(f instanceof Pt)this.checkValid(f);else if(f instanceof bt)this.checkValid(f);else if(f instanceof St)this.checkValid(f);else if(f instanceof Tt)this.checkValid(f);else if(f instanceof Ot)this.checkValid(f);else{if(!(f instanceof ft))throw new UnsupportedOperationException(f.getClass().getName());this.checkValid(f)}}},setSelfTouchingRingFormingHoleValid:function(t){this.isSelfTouchingRingFormingHoleValid=t},checkShellNotNested:function(t,e,n){var i=t.getCoordinates(),r=e.getExteriorRing(),s=r.getCoordinates(),o=ls.findPtNotNode(i,r,n);if(null===o)return null;var a=he.isPointInRing(o,s);if(!a)return null;if(e.getNumInteriorRing()<=0)return this.validErr=new us(us.NESTED_SHELLS,o),null;for(var u=null,l=0;l<e.getNumInteriorRing();l++){var h=e.getInteriorRingN(l);if(u=this.checkShellInsideHole(t,h,n),null===u)return null}this.validErr=new us(us.NESTED_SHELLS,u)},checkClosedRings:function(t){if(this.checkClosedRing(t.getExteriorRing()),null!==this.validErr)return null;for(var e=0;e<t.getNumInteriorRing();e++)if(this.checkClosedRing(t.getInteriorRingN(e)),null!==this.validErr)return null},checkClosedRing:function(t){if(!t.isClosed()){var e=null;t.getNumPoints()>=1&&(e=t.getCoordinateN(0)),this.validErr=new us(us.RING_NOT_CLOSED,e)}},checkShellsNotNested:function(t,e){for(var n=0;n<t.getNumGeometries();n++)for(var i=t.getGeometryN(n),r=i.getExteriorRing(),s=0;s<t.getNumGeometries();s++)if(n!==s){var o=t.getGeometryN(s);if(this.checkShellNotNested(r,o,e),null!==this.validErr)return null}},interfaces_:function(){return[]},getClass:function(){return ls}}),ls.findPtNotNode=function(t,e,n){for(var i=n.findEdge(e),r=i.getEdgeIntersectionList(),s=0;s<t.length;s++){var o=t[s];if(!r.isIntersection(o))return o}return null},ls.isValid=function(){if(arguments[0]instanceof B){var t=arguments[0],e=new ls(t);return e.isValid()}if(arguments[0]instanceof g){var n=arguments[0];return r.isNaN(n.x)?!1:r.isInfinite(n.x)?!1:r.isNaN(n.y)?!1:!r.isInfinite(n.y)}};var bo=Object.freeze({IsValidOp:ls}),Oo=Object.freeze({BoundaryOp:dt,IsSimpleOp:Gi,buffer:Co,distance:So,linemerge:wo,overlay:Lo,polygonize:Ro,relate:To,union:Po,valid:bo});h(hs,_t.CoordinateOperation),e(hs.prototype,{editCoordinates:function(t,e){if(0===t.length)return null;for(var n=new Array(t.length).fill(null),i=0;i<t.length;i++){var r=new g(t[i]);this.targetPM.makePrecise(r),n[i]=r}var s=new N(n,!1),o=s.toCoordinateArray(),a=0;e instanceof St&&(a=2),e instanceof bt&&(a=4);var u=n;return this.removeCollapsed&&(u=null),o.length<a?u:o},interfaces_:function(){return[]},getClass:function(){return hs}}),e(cs.prototype,{fixPolygonalTopology:function(t){var e=t;this.changePrecisionModel||(e=this.changePM(t,this.targetPM));var n=e.buffer(0),i=n;return this.changePrecisionModel||(i=t.getFactory().createGeometry(n)),i},reducePointwise:function(t){var e=null;if(this.changePrecisionModel){var n=this.createFactory(t.getFactory(),this.targetPM);e=new _t(n)}else e=new _t;var i=this.removeCollapsed;t.getDimension()>=2&&(i=!0);var r=e.edit(t,new hs(this.targetPM,i));return r},changePM:function(t,e){var n=this.createEditor(t.getFactory(),e);return n.edit(t,new _t.NoOpGeometryOperation)},setRemoveCollapsedComponents:function(t){this.removeCollapsed=t},createFactory:function(t,e){var n=new ie(e,t.getSRID(),t.getCoordinateSequenceFactory());return n},setChangePrecisionModel:function(t){this.changePrecisionModel=t},reduce:function(t){var e=this.reducePointwise(t);return this.isPointwise?e:R(e,Rt)?e.isValid()?e:this.fixPolygonalTopology(e):e},setPointwise:function(t){this.isPointwise=t},createEditor:function(t,e){if(t.getPrecisionModel()===e)return new _t;var n=this.createFactory(t,e),i=new _t(n);return i},interfaces_:function(){return[]},getClass:function(){return cs}}),cs.reduce=function(t,e){var n=new cs(e);return n.reduce(t)},cs.reducePointwise=function(t,e){var n=new cs(e);return n.setPointwise(!0),n.reduce(t)};var _o=Object.freeze({GeometryPrecisionReducer:cs});e(fs.prototype,{simplifySection:function(t,e){if(t+1===e)return null;this.seg.p0=this.pts[t],this.seg.p1=this.pts[e];for(var n=-1,i=t,r=t+1;e>r;r++){var s=this.seg.distance(this.pts[r]);s>n&&(n=s,i=r)}if(n<=this.distanceTolerance)for(var r=t+1;e>r;r++)this.usePt[r]=!1;else this.simplifySection(t,i),this.simplifySection(i,e)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(){this.usePt=new Array(this.pts.length).fill(null);for(var t=0;t<this.pts.length;t++)this.usePt[t]=!0;this.simplifySection(0,this.pts.length-1);for(var e=new N,t=0;t<this.pts.length;t++)this.usePt[t]&&e.add(new g(this.pts[t]));return e.toCoordinateArray()},interfaces_:function(){return[]},getClass:function(){return fs}}),fs.simplify=function(t,e){var n=new fs(t);return n.setDistanceTolerance(e),n.simplify()},e(gs.prototype,{setEnsureValid:function(t){this.isEnsureValidTopology=t},getResultGeometry:function(){return this.inputGeom.isEmpty()?this.inputGeom.copy():new ds(this.isEnsureValidTopology,this.distanceTolerance).transform(this.inputGeom)},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.distanceTolerance=t},interfaces_:function(){return[]},getClass:function(){return gs}}),gs.simplify=function(t,e){var n=new gs(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(ds,xe),e(ds.prototype,{transformPolygon:function(t,e){if(t.isEmpty())return null;var n=xe.prototype.transformPolygon.call(this,t,e);return e instanceof Ot?n:this.createValidArea(n)},createValidArea:function(t){return this.isEnsureValidTopology?t.buffer(0):t},transformCoordinates:function(t,e){var n=t.toCoordinateArray(),i=null;return i=0===n.length?new Array(0).fill(null):fs.simplify(n,this.distanceTolerance),this.factory.getCoordinateSequenceFactory().create(i)},transformMultiPolygon:function(t,e){var n=xe.prototype.transformMultiPolygon.call(this,t,e);return this.createValidArea(n)},transformLinearRing:function(t,e){var n=e instanceof Tt,i=xe.prototype.transformLinearRing.call(this,t,e);return!n||i instanceof bt?i:null},interfaces_:function(){return[]},getClass:function(){return ds}}),gs.DPTransformer=ds,h(ps,ce),e(ps.prototype,{getIndex:function(){return this.index},getParent:function(){return this.parent},interfaces_:function(){return[]},getClass:function(){return ps}}),e(vs.prototype,{addToResult:function(t){this.resultSegs.add(t)},asLineString:function(){return this.parentLine.getFactory().createLineString(vs.extractCoordinates(this.resultSegs))},getResultSize:function(){var t=this.resultSegs.size();return 0===t?0:t+1},getParent:function(){return this.parentLine},getSegment:function(t){return this.segs[t]},getParentCoordinates:function(){return this.parentLine.getCoordinates()},getMinimumSize:function(){return this.minimumSize},asLinearRing:function(){return this.parentLine.getFactory().createLinearRing(vs.extractCoordinates(this.resultSegs))},getSegments:function(){return this.segs},init:function(){var t=this.parentLine.getCoordinates();this.segs=new Array(t.length-1).fill(null);for(var e=0;e<t.length-1;e++){var n=new ps(t[e],t[e+1],this.parentLine,e);this.segs[e]=n}},getResultCoordinates:function(){return vs.extractCoordinates(this.resultSegs)},interfaces_:function(){return[]},getClass:function(){return vs}}),vs.extractCoordinates=function(t){for(var e=new Array(t.size()+1).fill(null),n=null,i=0;i<t.size();i++)n=t.get(i),e[i]=n.p0;return e[e.length-1]=n.p1,e},e(ms.prototype,{remove:function(t){this.index.remove(new C(t.p0,t.p1),t)},add:function(){if(arguments[0]instanceof vs)for(var t=arguments[0],e=t.getSegments(),n=0;n<e.length;n++){var i=e[n];this.add(i)}else if(arguments[0]instanceof ce){var r=arguments[0];this.index.insert(new C(r.p0,r.p1),r)}},query:function(t){var e=new C(t.p0,t.p1),n=new ys(t);this.index.query(e,n);var i=n.getItems();return i},interfaces_:function(){return[]},getClass:function(){return ms}}),e(ys.prototype,{visitItem:function(t){var e=t;C.intersects(e.p0,e.p1,this.querySeg.p0,this.querySeg.p1)&&this.items.add(t)},getItems:function(){return this.items},interfaces_:function(){return[Ae]},getClass:function(){return ys}}),e(xs.prototype,{flatten:function(t,e){var n=this.linePts[t],i=this.linePts[e],r=new ce(n,i);return this.remove(this.line,t,e),this.outputIndex.add(r),r},hasBadIntersection:function(t,e,n){return this.hasBadOutputIntersection(n)?!0:!!this.hasBadInputIntersection(t,e,n)},setDistanceTolerance:function(t){this.distanceTolerance=t},simplifySection:function(t,e,n){n+=1;var i=new Array(2).fill(null);if(t+1===e){var r=this.line.getSegment(t);return this.line.addToResult(r),null}var s=!0;if(this.line.getResultSize()<this.line.getMinimumSize()){var o=n+1;o<this.line.getMinimumSize()&&(s=!1)}var a=new Array(1).fill(null),u=this.findFurthestPoint(this.linePts,t,e,a);a[0]>this.distanceTolerance&&(s=!1);var l=new ce;if(l.p0=this.linePts[t],l.p1=this.linePts[e],i[0]=t,i[1]=e,this.hasBadIntersection(this.line,i,l)&&(s=!1),s){var r=this.flatten(t,e);return this.line.addToResult(r),null}this.simplifySection(t,u,n),this.simplifySection(u,e,n)},hasBadOutputIntersection:function(t){for(var e=this.outputIndex.query(t),n=e.iterator();n.hasNext();){var i=n.next();if(this.hasInteriorIntersection(i,t))return!0}return!1},findFurthestPoint:function(t,e,n,i){var r=new ce;r.p0=t[e],r.p1=t[n];for(var s=-1,o=e,a=e+1;n>a;a++){var u=t[a],l=r.distance(u);l>s&&(s=l,o=a)}return i[0]=s,o},simplify:function(t){this.line=t,this.linePts=t.getParentCoordinates(),this.simplifySection(0,this.linePts.length-1,0)},remove:function(t,e,n){for(var i=e;n>i;i++){var r=t.getSegment(i);this.inputIndex.remove(r)}},hasInteriorIntersection:function(t,e){return this.li.computeIntersection(t.p0,t.p1,e.p0,e.p1),this.li.isInteriorIntersection()},hasBadInputIntersection:function(t,e,n){for(var i=this.inputIndex.query(n),r=i.iterator();r.hasNext();){var s=r.next();if(this.hasInteriorIntersection(s,n)){if(xs.isInLineSection(t,e,s))continue;return!0}}return!1},interfaces_:function(){return[]},getClass:function(){return xs}}),xs.isInLineSection=function(t,e,n){if(n.getParent()!==t.getParent())return!1;var i=n.getIndex();return i>=e[0]&&i<e[1]},e(Es.prototype,{setDistanceTolerance:function(t){this.distanceTolerance=t},simplify:function(t){for(var e=t.iterator();e.hasNext();)this.inputIndex.add(e.next());for(var e=t.iterator();e.hasNext();){var n=new xs(this.inputIndex,this.outputIndex);n.setDistanceTolerance(this.distanceTolerance),n.simplify(e.next())}},interfaces_:function(){return[]},getClass:function(){return Es}}),e(Is.prototype,{getResultGeometry:function(){if(this.inputGeom.isEmpty())return this.inputGeom.copy();this.linestringMap=new te,this.inputGeom.apply(new Cs(this)),this.lineSimplifier.simplify(this.linestringMap.values());var t=new Ns(this.linestringMap).transform(this.inputGeom);return t},setDistanceTolerance:function(t){if(0>t)throw new i("Tolerance must be non-negative");this.lineSimplifier.setDistanceTolerance(t)},interfaces_:function(){return[]},getClass:function(){return Is}}),Is.simplify=function(t,e){var n=new Is(t);return n.setDistanceTolerance(e),n.getResultGeometry()},h(Ns,xe),e(Ns.prototype,{transformCoordinates:function(t,e){if(0===t.size())return null;if(e instanceof St){var n=this.linestringMap.get(e);return this.createCoordinateSequence(n.getResultCoordinates())}return xe.prototype.transformCoordinates.call(this,t,e)},interfaces_:function(){return[]},getClass:function(){return Ns}}),e(Cs.prototype,{filter:function(t){if(t instanceof St){var e=t;if(e.isEmpty())return null;var n=e.isClosed()?4:2,i=new vs(e,n);this.tps.linestringMap.put(e,i)}},interfaces_:function(){return[q]},getClass:function(){return Cs}}),Is.LineStringTransformer=Ns,Is.LineStringMapBuilderFilter=Cs;var Mo=Object.freeze({DouglasPeuckerSimplifier:gs,TopologyPreservingSimplifier:Is});e(Ss.prototype,{splitAt:function(){if(1===arguments.length){var t=arguments[0],e=this.minimumLen/this.segLen;if(t.distance(this.seg.p0)<this.minimumLen)return this.splitPt=this.seg.pointAlong(e),null;if(t.distance(this.seg.p1)<this.minimumLen)return this.splitPt=Ss.pointAlongReverse(this.seg,e),null;this.splitPt=t}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.getConstrainedLength(n),s=r/this.segLen;i.equals2D(this.seg.p0)?this.splitPt=this.seg.pointAlong(s):this.splitPt=Ss.pointAlongReverse(this.seg,s)}},setMinimumLength:function(t){this.minimumLen=t},getConstrainedLength:function(t){return t<this.minimumLen?this.minimumLen:t},getSplitPoint:function(){return this.splitPt},interfaces_:function(){return[]},getClass:function(){return Ss}}),Ss.pointAlongReverse=function(t,e){var n=new g;return n.x=t.p1.x-e*(t.p1.x-t.p0.x),n.y=t.p1.y-e*(t.p1.y-t.p0.y),n},e(ws.prototype,{findSplitPoint:function(t,e){},interfaces_:function(){return[]},getClass:function(){return ws}}),e(Ls.prototype,{findSplitPoint:function(t,e){var n=t.getLineSegment(),i=n.getLength(),r=i/2,s=new Ss(n),o=Ls.projectedSplitPoint(t,e),a=2*o.distance(e)*.8,u=a;return u>r&&(u=r),s.setMinimumLength(u),s.splitAt(o),s.getSplitPoint()},interfaces_:function(){return[ws]},getClass:function(){return Ls}}),Ls.projectedSplitPoint=function(t,e){var n=t.getLineSegment(),i=n.project(e);return i},e(Rs.prototype,{interfaces_:function(){return[]},getClass:function(){return Rs}}),Rs.triArea=function(t,e,n){return(e.x-t.x)*(n.y-t.y)-(e.y-t.y)*(n.x-t.x)},Rs.isInCircleDDNormalized=function(t,e,n,i){var r=_.valueOf(t.x).selfSubtract(i.x),s=_.valueOf(t.y).selfSubtract(i.y),o=_.valueOf(e.x).selfSubtract(i.x),a=_.valueOf(e.y).selfSubtract(i.y),u=_.valueOf(n.x).selfSubtract(i.x),l=_.valueOf(n.y).selfSubtract(i.y),h=r.multiply(a).selfSubtract(o.multiply(s)),c=o.multiply(l).selfSubtract(u.multiply(a)),f=u.multiply(s).selfSubtract(r.multiply(l)),g=r.multiply(r).selfAdd(s.multiply(s)),d=o.multiply(o).selfAdd(a.multiply(a)),p=u.multiply(u).selfAdd(l.multiply(l)),v=g.selfMultiply(c).selfAdd(d.selfMultiply(f)).selfAdd(p.selfMultiply(h)),m=v.doubleValue()>0;return m},Rs.checkRobustInCircle=function(t,e,n,i){var r=Rs.isInCircleNonRobust(t,e,n,i),s=Rs.isInCircleDDSlow(t,e,n,i),o=Rs.isInCircleCC(t,e,n,i),a=ci.circumcentre(t,e,n);A.out.println("p radius diff a = "+Math.abs(i.distance(a)-t.distance(a))/t.distance(a)),r===s&&r===o||(A.out.println("inCircle robustness failure (double result = "+r+", DD result = "+s+", CC result = "+o+")"),A.out.println(se.toLineString(new Gt([t,e,n,i]))),A.out.println("Circumcentre = "+se.toPoint(a)+" radius = "+t.distance(a)),A.out.println("p radius diff a = "+Math.abs(i.distance(a)/t.distance(a)-1)),A.out.println("p radius diff b = "+Math.abs(i.distance(a)/e.distance(a)-1)),A.out.println("p radius diff c = "+Math.abs(i.distance(a)/n.distance(a)-1)),A.out.println())},Rs.isInCircleDDFast=function(t,e,n,i){var r=_.sqr(t.x).selfAdd(_.sqr(t.y)).selfMultiply(Rs.triAreaDDFast(e,n,i)),s=_.sqr(e.x).selfAdd(_.sqr(e.y)).selfMultiply(Rs.triAreaDDFast(t,n,i)),o=_.sqr(n.x).selfAdd(_.sqr(n.y)).selfMultiply(Rs.triAreaDDFast(t,e,i)),a=_.sqr(i.x).selfAdd(_.sqr(i.y)).selfMultiply(Rs.triAreaDDFast(t,e,n)),u=r.selfSubtract(s).selfAdd(o).selfSubtract(a),l=u.doubleValue()>0;return l},Rs.isInCircleCC=function(t,e,n,i){var r=ci.circumcentre(t,e,n),s=t.distance(r),o=i.distance(r)-s;return 0>=o},Rs.isInCircleNormalized=function(t,e,n,i){var r=t.x-i.x,s=t.y-i.y,o=e.x-i.x,a=e.y-i.y,u=n.x-i.x,l=n.y-i.y,h=r*a-o*s,c=o*l-u*a,f=u*s-r*l,g=r*r+s*s,d=o*o+a*a,p=u*u+l*l,v=g*c+d*f+p*h;return v>0},Rs.isInCircleDDSlow=function(t,e,n,i){var r=_.valueOf(i.x),s=_.valueOf(i.y),o=_.valueOf(t.x),a=_.valueOf(t.y),u=_.valueOf(e.x),l=_.valueOf(e.y),h=_.valueOf(n.x),c=_.valueOf(n.y),f=o.multiply(o).add(a.multiply(a)).multiply(Rs.triAreaDDSlow(u,l,h,c,r,s)),g=u.multiply(u).add(l.multiply(l)).multiply(Rs.triAreaDDSlow(o,a,h,c,r,s)),d=h.multiply(h).add(c.multiply(c)).multiply(Rs.triAreaDDSlow(o,a,u,l,r,s)),p=r.multiply(r).add(s.multiply(s)).multiply(Rs.triAreaDDSlow(o,a,u,l,h,c)),v=f.subtract(g).add(d).subtract(p),m=v.doubleValue()>0;
return m},Rs.isInCircleNonRobust=function(t,e,n,i){var r=(t.x*t.x+t.y*t.y)*Rs.triArea(e,n,i)-(e.x*e.x+e.y*e.y)*Rs.triArea(t,n,i)+(n.x*n.x+n.y*n.y)*Rs.triArea(t,e,i)-(i.x*i.x+i.y*i.y)*Rs.triArea(t,e,n)>0;return r},Rs.isInCircleRobust=function(t,e,n,i){return Rs.isInCircleNormalized(t,e,n,i)},Rs.triAreaDDSlow=function(t,e,n,i,r,s){return n.subtract(t).multiply(s.subtract(e)).subtract(i.subtract(e).multiply(r.subtract(t)))},Rs.triAreaDDFast=function(t,e,n){var i=_.valueOf(e.x).selfSubtract(t.x).selfMultiply(_.valueOf(n.y).selfSubtract(t.y)),r=_.valueOf(e.y).selfSubtract(t.y).selfMultiply(_.valueOf(n.x).selfSubtract(t.x));return i.selfSubtract(r)},e(Ts.prototype,{circleCenter:function(t,e){var n=new Ts(this.getX(),this.getY()),i=this.bisector(n,t),r=this.bisector(t,e),s=new F(i,r),o=null;try{o=new Ts(s.getX(),s.getY())}catch(i){if(!(i instanceof w))throw i;A.err.println("a: "+n+"  b: "+t+"  c: "+e),A.err.println(i)}finally{}return o},dot:function(t){return this.p.x*t.getX()+this.p.y*t.getY()},magn:function(){return Math.sqrt(this.p.x*this.p.x+this.p.y*this.p.y)},getZ:function(){return this.p.z},bisector:function(t,e){var n=e.getX()-t.getX(),i=e.getY()-t.getY(),r=new F(t.getX()+n/2,t.getY()+i/2,1),s=new F(t.getX()-i+n/2,t.getY()+n+i/2,1);return new F(r,s)},equals:function(){if(1===arguments.length){var t=arguments[0];return this.p.x===t.getX()&&this.p.y===t.getY()}if(2===arguments.length){var e=arguments[0],n=arguments[1];return this.p.distance(e.getCoordinate())<n}},getCoordinate:function(){return this.p},isInCircle:function(t,e,n){return Rs.isInCircleRobust(t.p,e.p,n.p,this.p)},interpolateZValue:function(t,e,n){var i=t.getX(),r=t.getY(),s=e.getX()-i,o=n.getX()-i,a=e.getY()-r,u=n.getY()-r,l=s*u-o*a,h=this.getX()-i,c=this.getY()-r,f=(u*h-o*c)/l,g=(-a*h+s*c)/l,d=t.getZ()+f*(e.getZ()-t.getZ())+g*(n.getZ()-t.getZ());return d},midPoint:function(t){var e=(this.p.x+t.getX())/2,n=(this.p.y+t.getY())/2,i=(this.p.z+t.getZ())/2;return new Ts(e,n,i)},rightOf:function(t){return this.isCCW(t.dest(),t.orig())},isCCW:function(t,e){return(t.p.x-this.p.x)*(e.p.y-this.p.y)-(t.p.y-this.p.y)*(e.p.x-this.p.x)>0},getX:function(){return this.p.x},crossProduct:function(t){return this.p.x*t.getY()-this.p.y*t.getX()},setZ:function(t){this.p.z=t},times:function(t){return new Ts(t*this.p.x,t*this.p.y)},cross:function(){return new Ts(this.p.y,-this.p.x)},leftOf:function(t){return this.isCCW(t.orig(),t.dest())},toString:function(){return"POINT ("+this.p.x+" "+this.p.y+")"},sub:function(t){return new Ts(this.p.x-t.getX(),this.p.y-t.getY())},getY:function(){return this.p.y},classify:function(t,e){var n=this,i=e.sub(t),r=n.sub(t),s=i.crossProduct(r);return s>0?Ts.LEFT:0>s?Ts.RIGHT:i.getX()*r.getX()<0||i.getY()*r.getY()<0?Ts.BEHIND:i.magn()<r.magn()?Ts.BEYOND:t.equals(n)?Ts.ORIGIN:e.equals(n)?Ts.DESTINATION:Ts.BETWEEN},sum:function(t){return new Ts(this.p.x+t.getX(),this.p.y+t.getY())},distance:function(t,e){return Math.sqrt(Math.pow(e.getX()-t.getX(),2)+Math.pow(e.getY()-t.getY(),2))},circumRadiusRatio:function(t,e){var n=this.circleCenter(t,e),i=this.distance(n,t),r=this.distance(this,t),s=this.distance(t,e);return r>s&&(r=s),s=this.distance(e,this),r>s&&(r=s),i/r},interfaces_:function(){return[]},getClass:function(){return Ts}}),Ts.interpolateZ=function(){if(3===arguments.length){var t=arguments[0],e=arguments[1],n=arguments[2],i=e.distance(n),r=t.distance(e),s=n.z-e.z,o=e.z+s*(r/i);return o}if(4===arguments.length){var a=arguments[0],u=arguments[1],l=arguments[2],h=arguments[3],c=u.x,f=u.y,g=l.x-c,d=h.x-c,p=l.y-f,v=h.y-f,m=g*v-d*p,y=a.x-c,x=a.y-f,E=(v*y-d*x)/m,I=(-p*y+g*x)/m,N=u.z+E*(l.z-u.z)+I*(h.z-u.z);return N}},Ts.LEFT=0,Ts.RIGHT=1,Ts.BEYOND=2,Ts.BEHIND=3,Ts.BETWEEN=4,Ts.ORIGIN=5,Ts.DESTINATION=6,h(Ps,Ts),e(Ps.prototype,{getConstraint:function(){return this.constraint},setOnConstraint:function(t){this._isOnConstraint=t},merge:function(t){t._isOnConstraint&&(this._isOnConstraint=!0,this.constraint=t.constraint)},isOnConstraint:function(){return this._isOnConstraint},setConstraint:function(t){this._isOnConstraint=!0,this.constraint=t},interfaces_:function(){return[]},getClass:function(){return Ps}}),e(bs.prototype,{equalsNonOriented:function(t){return this.equalsOriented(t)?!0:!!this.equalsOriented(t.sym())},toLineSegment:function(){return new ce(this.vertex.getCoordinate(),this.dest().getCoordinate())},dest:function(){return this.sym().orig()},oNext:function(){return this.next},equalsOriented:function(t){return!(!this.orig().getCoordinate().equals2D(t.orig().getCoordinate())||!this.dest().getCoordinate().equals2D(t.dest().getCoordinate()))},dNext:function(){return this.sym().oNext().sym()},lPrev:function(){return this.next.sym()},rPrev:function(){return this.sym().oNext()},rot:function(){return this._rot},oPrev:function(){return this._rot.next._rot},sym:function(){return this._rot._rot},setOrig:function(t){this.vertex=t},lNext:function(){return this.invRot().oNext().rot()},getLength:function(){return this.orig().getCoordinate().distance(this.dest().getCoordinate())},invRot:function(){return this._rot.sym()},setDest:function(t){this.sym().setOrig(t)},setData:function(t){this.data=t},getData:function(){return this.data},delete:function(){this._rot=null},orig:function(){return this.vertex},rNext:function(){return this._rot.next.invRot()},toString:function(){var t=this.vertex.getCoordinate(),e=this.dest().getCoordinate();return se.toLineString(t,e)},isLive:function(){return null!==this._rot},getPrimary:function(){return this.orig().getCoordinate().compareTo(this.dest().getCoordinate())<=0?this:this.sym()},dPrev:function(){return this.invRot().oNext().invRot()},setNext:function(t){this.next=t},interfaces_:function(){return[]},getClass:function(){return bs}}),bs.makeEdge=function(t,e){var n=new bs,i=new bs,r=new bs,s=new bs;n._rot=i,i._rot=r,r._rot=s,s._rot=n,n.setNext(n),i.setNext(s),r.setNext(r),s.setNext(i);var o=n;return o.setOrig(t),o.setDest(e),o},bs.swap=function(t){var e=t.oPrev(),n=t.sym().oPrev();bs.splice(t,e),bs.splice(t.sym(),n),bs.splice(t,e.lNext()),bs.splice(t.sym(),n.lNext()),t.setOrig(e.dest()),t.setDest(n.dest())},bs.splice=function(t,e){var n=t.oNext().rot(),i=e.oNext().rot(),r=e.oNext(),s=t.oNext(),o=i.oNext(),a=n.oNext();t.setNext(r),e.setNext(s),n.setNext(o),i.setNext(a)},bs.connect=function(t,e){var n=bs.makeEdge(t.dest(),e.orig());return bs.splice(n,t.lNext()),bs.splice(n.sym(),e),n},e(Os.prototype,{insertSite:function(t){var e=this.subdiv.locate(t);if(this.subdiv.isVertexOfEdge(e,t))return e;this.subdiv.isOnEdge(e,t.getCoordinate())&&(e=e.oPrev(),this.subdiv.delete(e.oNext()));var n=this.subdiv.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.subdiv.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);for(;;){var r=e.oPrev();if(r.dest().rightOf(e)&&t.isInCircle(e.orig(),r.dest(),e.dest()))bs.swap(e),e=e.oPrev();else{if(e.oNext()===i)return n;e=e.oNext().lPrev()}}},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},interfaces_:function(){return[]},getClass:function(){return Os}}),e(_s.prototype,{locate:function(t){},interfaces_:function(){return[]},getClass:function(){return _s}}),e(Ms.prototype,{init:function(){this.lastEdge=this.findEdge()},locate:function(t){this.lastEdge.isLive()||this.init();var e=this.subdiv.locateFromEdge(t,this.lastEdge);return this.lastEdge=e,e},findEdge:function(){var t=this.subdiv.getEdges();return t.iterator().next()},interfaces_:function(){return[_s]},getClass:function(){return Ms}}),h(Ds,l),e(Ds.prototype,{getSegment:function(){return this.seg},interfaces_:function(){return[]},getClass:function(){return Ds}}),Ds.msgWithSpatial=function(t,e){return null!==e?t+" [ "+e+" ]":t},e(As.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return As}}),e(Fs.prototype,{getTriangleVertices:function(t){var e=new Bs;return this.visitTriangles(e,t),e.getTriangleVertices()},isFrameVertex:function(t){return t.equals(this.frameVertex[0])?!0:t.equals(this.frameVertex[1])?!0:!!t.equals(this.frameVertex[2])},isVertexOfEdge:function(t,e){return!(!e.equals(t.orig(),this.tolerance)&&!e.equals(t.dest(),this.tolerance))},connect:function(t,e){var n=bs.connect(t,e);return this.quadEdges.add(n),n},getVoronoiCellPolygon:function(t,e){var n=new I,i=t;do{var r=t.rot().orig().getCoordinate();n.add(r),t=t.oPrev()}while(t!==i);var s=new N;s.addAll(n,!1),s.closeRing(),s.size()<4&&(A.out.println(s),s.add(s.get(s.size()-1),!0));var o=s.toCoordinateArray(),a=e.createPolygon(e.createLinearRing(o),null),u=i.orig();return a.setUserData(u.getCoordinate()),a},setLocator:function(t){this.locator=t},initSubdiv:function(){var t=this.makeEdge(this.frameVertex[0],this.frameVertex[1]),e=this.makeEdge(this.frameVertex[1],this.frameVertex[2]);bs.splice(t.sym(),e);var n=this.makeEdge(this.frameVertex[2],this.frameVertex[0]);return bs.splice(e.sym(),n),bs.splice(n.sym(),t),t},isFrameBorderEdge:function(t){var e=new Array(3).fill(null);Fs.getTriangleEdges(t,e);var n=new Array(3).fill(null);Fs.getTriangleEdges(t.sym(),n);var i=t.lNext().dest();if(this.isFrameVertex(i))return!0;var r=t.sym().lNext().dest();return!!this.isFrameVertex(r)},makeEdge:function(t,e){var n=bs.makeEdge(t,e);return this.quadEdges.add(n),n},visitTriangles:function(t,e){this.visitedKey++;var n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=this.fetchTriangleToVisit(r,n,e,i);null!==s&&t.visit(s)}}},isFrameEdge:function(t){return!(!this.isFrameVertex(t.orig())&&!this.isFrameVertex(t.dest()))},isOnEdge:function(t,e){this.seg.setCoordinates(t.orig().getCoordinate(),t.dest().getCoordinate());var n=this.seg.distance(e);return n<this.edgeCoincidenceTolerance},getEnvelope:function(){return new C(this.frameEnv)},createFrame:function(t){var e=t.getWidth(),n=t.getHeight(),i=0;i=e>n?10*e:10*n,this.frameVertex[0]=new Ts((t.getMaxX()+t.getMinX())/2,t.getMaxY()+i),this.frameVertex[1]=new Ts(t.getMinX()-i,t.getMinY()-i),this.frameVertex[2]=new Ts(t.getMaxX()+i,t.getMinY()-i),this.frameEnv=new C(this.frameVertex[0].getCoordinate(),this.frameVertex[1].getCoordinate()),this.frameEnv.expandToInclude(this.frameVertex[2].getCoordinate())},getTriangleCoordinates:function(t){var e=new zs;return this.visitTriangles(e,t),e.getTriangles()},getVertices:function(t){for(var e=new J,n=this.quadEdges.iterator();n.hasNext();){var i=n.next(),r=i.orig();!t&&this.isFrameVertex(r)||e.add(r);var s=i.dest();!t&&this.isFrameVertex(s)||e.add(s)}return e},fetchTriangleToVisit:function(t,e,n,i){var r=t,s=0,o=!1;do{this.triEdges[s]=r,this.isFrameEdge(r)&&(o=!0);var a=r.sym();i.contains(a)||e.push(a),i.add(r),s++,r=r.lNext()}while(r!==t);return o&&!n?null:this.triEdges},getEdges:function(){if(0===arguments.length)return this.quadEdges;if(1===arguments.length){for(var t=arguments[0],e=this.getPrimaryEdges(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createLineString([s.orig().getCoordinate(),s.dest().getCoordinate()])}return t.createMultiLineString(n)}},getVertexUniqueEdges:function(t){for(var e=new I,n=new J,i=this.quadEdges.iterator();i.hasNext();){var r=i.next(),s=r.orig();n.contains(s)||(n.add(s),!t&&this.isFrameVertex(s)||e.add(r));var o=r.sym(),a=o.orig();n.contains(a)||(n.add(a),!t&&this.isFrameVertex(a)||e.add(o))}return e},getTriangleEdges:function(t){var e=new qs;return this.visitTriangles(e,t),e.getTriangleEdges()},getPrimaryEdges:function(t){this.visitedKey++;var e=new I,n=new pe;n.push(this.startingEdge);for(var i=new J;!n.empty();){var r=n.pop();if(!i.contains(r)){var s=r.getPrimary();!t&&this.isFrameEdge(s)||e.add(s),n.push(r.oNext()),n.push(r.sym().oNext()),i.add(r),i.add(r.sym())}}return e},delete:function(t){bs.splice(t,t.oPrev()),bs.splice(t.sym(),t.sym().oPrev());var e=t.sym(),n=t.rot(),i=t.rot().sym();this.quadEdges.remove(t),this.quadEdges.remove(e),this.quadEdges.remove(n),this.quadEdges.remove(i),t.delete(),e.delete(),n.delete(),i.delete()},locateFromEdge:function(t,e){for(var n=0,i=this.quadEdges.size(),r=e;;){if(n++,n>i)throw new Ds(r.toLineSegment());if(t.equals(r.orig())||t.equals(r.dest()))break;if(t.rightOf(r))r=r.sym();else if(t.rightOf(r.oNext())){if(t.rightOf(r.dPrev()))break;r=r.dPrev()}else r=r.oNext()}return r},getTolerance:function(){return this.tolerance},getVoronoiCellPolygons:function(t){this.visitTriangles(new Gs,!0);for(var e=new I,n=this.getVertexUniqueEdges(!1),i=n.iterator();i.hasNext();){var r=i.next();e.add(this.getVoronoiCellPolygon(r,t))}return e},getVoronoiDiagram:function(t){var e=this.getVoronoiCellPolygons(t);return t.createGeometryCollection(ie.toGeometryArray(e))},getTriangles:function(t){for(var e=this.getTriangleCoordinates(!1),n=new Array(e.size()).fill(null),i=0,r=e.iterator();r.hasNext();){var s=r.next();n[i++]=t.createPolygon(t.createLinearRing(s),null)}return t.createGeometryCollection(n)},insertSite:function(t){var e=this.locate(t);if(t.equals(e.orig(),this.tolerance)||t.equals(e.dest(),this.tolerance))return e;var n=this.makeEdge(e.orig(),t);bs.splice(n,e);var i=n;do n=this.connect(e,n.sym()),e=n.oPrev();while(e.lNext()!==i);return i},locate:function(){if(1===arguments.length){if(arguments[0]instanceof Ts){var t=arguments[0];return this.locator.locate(t)}if(arguments[0]instanceof g){var e=arguments[0];return this.locator.locate(new Ts(e))}}else if(2===arguments.length){var n=arguments[0],i=arguments[1],r=this.locator.locate(new Ts(n));if(null===r)return null;var s=r;r.dest().getCoordinate().equals2D(n)&&(s=r.sym());var o=s;do{if(o.dest().getCoordinate().equals2D(i))return o;o=o.oNext()}while(o!==s);return null}},interfaces_:function(){return[]},getClass:function(){return Fs}}),Fs.getTriangleEdges=function(t,e){if(e[0]=t,e[1]=e[0].lNext(),e[2]=e[1].lNext(),e[2].lNext()!==e[0])throw new i("Edges do not form a triangle")},e(Gs.prototype,{visit:function(t){for(var e=t[0].orig().getCoordinate(),n=t[1].orig().getCoordinate(),i=t[2].orig().getCoordinate(),r=ci.circumcentre(e,n,i),s=new Ts(r),o=0;3>o;o++)t[o].rot().setOrig(s)},interfaces_:function(){return[As]},getClass:function(){return Gs}}),e(qs.prototype,{getTriangleEdges:function(){return this.triList},visit:function(t){this.triList.add(t.clone())},interfaces_:function(){return[As]},getClass:function(){return qs}}),e(Bs.prototype,{visit:function(t){this.triList.add([t[0].orig(),t[1].orig(),t[2].orig()])},getTriangleVertices:function(){return this.triList},interfaces_:function(){return[As]},getClass:function(){return Bs}}),e(zs.prototype,{checkTriangleSize:function(t){var e="";t.length>=2?e=se.toLineString(t[0],t[1]):t.length>=1&&(e=se.toPoint(t[0]))},visit:function(t){this.coordList.clear();for(var e=0;3>e;e++){var n=t[e].orig();this.coordList.add(n.getCoordinate())}if(this.coordList.size()>0){this.coordList.closeRing();var i=this.coordList.toCoordinateArray();if(4!==i.length)return null;this.triCoords.add(i)}},getTriangles:function(){return this.triCoords},interfaces_:function(){return[As]},getClass:function(){return zs}}),Fs.TriangleCircumcentreVisitor=Gs,Fs.TriangleEdgesListVisitor=qs,Fs.TriangleVertexListVisitor=Bs,Fs.TriangleCoordinatesVisitor=zs,Fs.EDGE_COINCIDENCE_TOL_FACTOR=1e3,e(Vs.prototype,{getLineSegment:function(){return this.ls},getEndZ:function(){var t=this.ls.getCoordinate(1);return t.z},getStartZ:function(){var t=this.ls.getCoordinate(0);return t.z},intersection:function(t){return this.ls.intersection(t.getLineSegment())},getStart:function(){return this.ls.getCoordinate(0)},getEnd:function(){return this.ls.getCoordinate(1)},getEndY:function(){var t=this.ls.getCoordinate(1);return t.y},getStartX:function(){var t=this.ls.getCoordinate(0);return t.x},equalsTopo:function(t){return this.ls.equalsTopo(t.getLineSegment())},getStartY:function(){var t=this.ls.getCoordinate(0);return t.y},setData:function(t){this.data=t},getData:function(){return this.data},getEndX:function(){var t=this.ls.getCoordinate(1);return t.x},toString:function(){return this.ls.toString()},interfaces_:function(){return[]},getClass:function(){return Vs}}),e(ks.prototype,{visit:function(t){},interfaces_:function(){return[]},getClass:function(){return ks}}),e(Ys.prototype,{isRepeated:function(){return this.count>1},getRight:function(){return this.right},getCoordinate:function(){return this.p},setLeft:function(t){this.left=t},getX:function(){return this.p.x},getData:function(){return this.data},getCount:function(){return this.count},getLeft:function(){return this.left},getY:function(){return this.p.y},increment:function(){this.count=this.count+1},setRight:function(t){this.right=t},interfaces_:function(){return[]},getClass:function(){return Ys}}),e(Us.prototype,{insert:function(){if(1===arguments.length){var t=arguments[0];return this.insert(t,null)}if(2===arguments.length){var e=arguments[0],n=arguments[1];if(null===this.root)return this.root=new Ys(e,n),this.root;if(this.tolerance>0){var i=this.findBestMatchNode(e);if(null!==i)return i.increment(),i}return this.insertExact(e,n)}},query:function(){var t=arguments,e=this;if(1===arguments.length){var n=arguments[0],i=new I;return this.query(n,i),i}if(2===arguments.length)if(arguments[0]instanceof C&&R(arguments[1],y))!function(){var n=t[0],i=t[1];e.queryNode(e.root,n,!0,{interfaces_:function(){return[ks]},visit:function(t){i.add(t)}})}();else if(arguments[0]instanceof C&&R(arguments[1],ks)){var r=arguments[0],s=arguments[1];this.queryNode(this.root,r,!0,s)}},queryNode:function(t,e,n,i){if(null===t)return null;var r=null,s=null,o=null;n?(r=e.getMinX(),s=e.getMaxX(),o=t.getX()):(r=e.getMinY(),s=e.getMaxY(),o=t.getY());var a=o>r,u=s>=o;a&&this.queryNode(t.getLeft(),e,!n,i),e.contains(t.getCoordinate())&&i.visit(t),u&&this.queryNode(t.getRight(),e,!n,i)},findBestMatchNode:function(t){var e=new Xs(t,this.tolerance);return this.query(e.queryEnvelope(),e),e.getNode()},isEmpty:function(){return null===this.root},insertExact:function(t,e){for(var n=this.root,i=this.root,r=!0,s=!0;null!==n;){if(null!==n){var o=t.distance(n.getCoordinate())<=this.tolerance;if(o)return n.increment(),n}s=r?t.x<n.getX():t.y<n.getY(),i=n,n=s?n.getLeft():n.getRight(),r=!r}this.numberOfNodes=this.numberOfNodes+1;var a=new Ys(t,e);return s?i.setLeft(a):i.setRight(a),a},interfaces_:function(){return[]},getClass:function(){return Us}}),Us.toCoordinates=function(){if(1===arguments.length){var t=arguments[0];return Us.toCoordinates(t,!1)}if(2===arguments.length){for(var e=arguments[0],n=arguments[1],i=new N,r=e.iterator();r.hasNext();)for(var s=r.next(),o=n?s.getCount():1,a=0;o>a;a++)i.add(s.getCoordinate(),!0);return i.toCoordinateArray()}},e(Xs.prototype,{visit:function(t){var e=this.p.distance(t.getCoordinate()),n=e<=this.tolerance;if(!n)return null;var i=!1;(null===this.matchNode||e<this.matchDist||null!==this.matchNode&&e===this.matchDist&&t.getCoordinate().compareTo(this.matchNode.getCoordinate())<1)&&(i=!0),i&&(this.matchNode=t,this.matchDist=e)},queryEnvelope:function(){var t=new C(this.p);return t.expandBy(this.tolerance),t},getNode:function(){return this.matchNode},interfaces_:function(){return[ks]},getClass:function(){return Xs}}),Us.BestMatchVisitor=Xs,e(Hs.prototype,{getInitialVertices:function(){return this.initialVertices},getKDT:function(){return this.kdt},enforceConstraints:function(){this.addConstraintVertices();var t=0,e=0;do e=this.enforceGabriel(this.segments),t++;while(e>0&&t<Hs.MAX_SPLIT_ITER)},insertSites:function(t){for(var e=t.iterator();e.hasNext();){var n=e.next();this.insertSite(n)}},getVertexFactory:function(){return this.vertexFactory},getPointArray:function(){for(var t=new Array(this.initialVertices.size()+this.segVertices.size()).fill(null),e=0,n=this.initialVertices.iterator();n.hasNext();){var i=n.next();t[e++]=i.getCoordinate()}for(var r=this.segVertices.iterator();r.hasNext();){var i=r.next();t[e++]=i.getCoordinate()}return t},setConstraints:function(t,e){this.segments=t,this.segVertices=e},computeConvexHull:function(){var t=new ie,e=this.getPointArray(),n=new me(e,t);this.convexHull=n.getConvexHull()},addConstraintVertices:function(){this.computeConvexHull(),this.insertSites(this.segVertices)},findNonGabrielPoint:function(t){var e=t.getStart(),n=t.getEnd(),i=new g((e.x+n.x)/2,(e.y+n.y)/2),s=e.distance(i),o=new C(i);o.expandBy(s);for(var a=this.kdt.query(o),u=null,l=r.MAX_VALUE,h=a.iterator();h.hasNext();){var c=h.next(),f=c.getCoordinate();if(!f.equals2D(e)&&!f.equals2D(n)){var d=i.distance(f);if(s>d){var p=d;(null===u||l>p)&&(u=f,l=p)}}}return u},getConstraintSegments:function(){return this.segments},setSplitPointFinder:function(t){this.splitFinder=t},getConvexHull:function(){return this.convexHull},getTolerance:function(){return this.tolerance},enforceGabriel:function(t){for(var e=new I,n=0,i=new I,r=t.iterator();r.hasNext();){var s=r.next(),o=this.findNonGabrielPoint(s);if(null!==o){this.splitPt=this.splitFinder.findSplitPoint(s,o);var a=this.createVertex(this.splitPt,s),u=(this.insertSite(a),new Vs(s.getStartX(),s.getStartY(),s.getStartZ(),a.getX(),a.getY(),a.getZ(),s.getData())),l=new Vs(a.getX(),a.getY(),a.getZ(),s.getEndX(),s.getEndY(),s.getEndZ(),s.getData());e.add(u),e.add(l),i.add(s),n+=1}}return t.removeAll(i),t.addAll(e),n},createVertex:function(){if(1===arguments.length){var t=arguments[0],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(t,null):new Ps(t)}if(2===arguments.length){var n=arguments[0],i=arguments[1],e=null;return e=null!==this.vertexFactory?this.vertexFactory.createVertex(n,i):new Ps(n),e.setOnConstraint(!0),e}},getSubdivision:function(){return this.subdiv},computeBoundingBox:function(){var t=Hs.computeVertexEnvelope(this.initialVertices),e=Hs.computeVertexEnvelope(this.segVertices),n=new C(t);n.expandToInclude(e);var i=.2*n.getWidth(),r=.2*n.getHeight(),s=Math.max(i,r);this.computeAreaEnv=new C(n),this.computeAreaEnv.expandBy(s)},setVertexFactory:function(t){this.vertexFactory=t},formInitialDelaunay:function(){this.computeBoundingBox(),this.subdiv=new Fs(this.computeAreaEnv,this.tolerance),this.subdiv.setLocator(new Ms(this.subdiv)),this.incDel=new Os(this.subdiv),this.insertSites(this.initialVertices)},insertSite:function(){if(arguments[0]instanceof Ps){var t=arguments[0],e=this.kdt.insert(t.getCoordinate(),t);if(e.isRepeated()){var n=e.getData();return n.merge(t),n}return this.incDel.insertSite(t),t}if(arguments[0]instanceof g){var i=arguments[0];this.insertSite(this.createVertex(i))}},interfaces_:function(){return[]},getClass:function(){return Hs}}),Hs.computeVertexEnvelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i.getCoordinate())}return e},Hs.MAX_SPLIT_ITER=99,e(Ws.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var n=new Os(this.subdiv);n.insertSites(e)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},interfaces_:function(){return[]},getClass:function(){return Ws}}),Ws.extractUniqueCoordinates=function(t){if(null===t)return new N;var e=t.getCoordinates();return Ws.unique(e)},Ws.envelope=function(t){for(var e=new C,n=t.iterator();n.hasNext();){var i=n.next();e.expandToInclude(i)}return e},Ws.unique=function(t){var e=H.copyDeep(t);ut.sort(e);var n=new N(e,!1);return n},Ws.toVertices=function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();e.add(new Ts(i))}return e},e(js.prototype,{createSiteVertices:function(t){for(var e=new I,n=t.iterator();n.hasNext();){var i=n.next();this.constraintVertexMap.containsKey(i)||e.add(new Ps(i))}return e},create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords),e=new I;null!==this.constraintLines&&(t.expandToInclude(this.constraintLines.getEnvelopeInternal()),this.createVertices(this.constraintLines),e=js.createConstraintSegments(this.constraintLines));var n=this.createSiteVertices(this.siteCoords),i=new Hs(n,this.tolerance);i.setConstraints(e,new I(this.constraintVertexMap.values())),i.formInitialDelaunay(),i.enforceConstraints(),this.subdiv=i.getSubdivision()},setTolerance:function(t){this.tolerance=t},setConstraints:function(t){this.constraintLines=t},setSites:function(t){this.siteCoords=Ws.extractUniqueCoordinates(t)},getEdges:function(t){return this.create(),this.subdiv.getEdges(t)},getSubdivision:function(){return this.create(),this.subdiv},getTriangles:function(t){return this.create(),this.subdiv.getTriangles(t)},createVertices:function(t){for(var e=t.getCoordinates(),n=0;n<e.length;n++){var i=new Ps(e[n]);this.constraintVertexMap.put(e[n],i)}},interfaces_:function(){return[]},getClass:function(){return js}}),js.createConstraintSegments=function(){if(1===arguments.length){for(var t=arguments[0],e=kn.getLines(t),n=new I,i=e.iterator();i.hasNext();){var r=i.next();js.createConstraintSegments(r,n)}return n}if(2===arguments.length)for(var s=arguments[0],o=arguments[1],a=s.getCoordinates(),i=1;i<a.length;i++)o.add(new Vs(a[i-1],a[i]))},e(Ks.prototype,{create:function(){if(null!==this.subdiv)return null;var t=Ws.envelope(this.siteCoords);this.diagramEnv=t;var e=Math.max(this.diagramEnv.getWidth(),this.diagramEnv.getHeight());this.diagramEnv.expandBy(e),null!==this.clipEnv&&this.diagramEnv.expandToInclude(this.clipEnv);var n=Ws.toVertices(this.siteCoords);this.subdiv=new Fs(t,this.tolerance);var i=new Os(this.subdiv);i.insertSites(n)},getDiagram:function(t){this.create();var e=this.subdiv.getVoronoiDiagram(t);return Ks.clipGeometryCollection(e,this.diagramEnv)},setTolerance:function(t){this.tolerance=t},setSites:function(){if(arguments[0]instanceof B){var t=arguments[0];this.siteCoords=Ws.extractUniqueCoordinates(t)}else if(R(arguments[0],v)){var e=arguments[0];this.siteCoords=Ws.unique(H.toCoordinateArray(e))}},setClipEnvelope:function(t){this.clipEnv=t},getSubdivision:function(){return this.create(),this.subdiv},interfaces_:function(){return[]},getClass:function(){return Ks}}),Ks.clipGeometryCollection=function(t,e){for(var n=t.getFactory().toGeometry(e),i=new I,r=0;r<t.getNumGeometries();r++){var s=t.getGeometryN(r),o=null;e.contains(s.getEnvelopeInternal())?o=s:e.intersects(s.getEnvelopeInternal())&&(o=n.intersection(s),o.setUserData(s.getUserData())),null===o||o.isEmpty()||i.add(o)}return t.getFactory().createGeometryCollection(ie.toGeometryArray(i))};var Do=Object.freeze({ConformingDelaunayTriangulationBuilder:js,DelaunayTriangulationBuilder:Ws,VoronoiDiagramBuilder:Ks});e(Zs.prototype,{interfaces_:function(){return[]},getClass:function(){return Zs}}),Zs.union=function(t,e){if(t.isEmpty()||e.isEmpty()){if(t.isEmpty()&&e.isEmpty())return ii.createEmptyResult(ii.UNION,t,e,t.getFactory());if(t.isEmpty())return e.copy();if(e.isEmpty())return t.copy()}return t.checkNotGeometryCollection(t),t.checkNotGeometryCollection(e),si.overlayOp(t,e,ii.UNION)},e(B.prototype,{equalsTopo:function(t){return this.getEnvelopeInternal().equals(t.getEnvelopeInternal())?Yr.relate(this,t).isEquals(this.getDimension(),t.getDimension()):!1},union:function(){if(0===arguments.length)return jr.union(this);if(1===arguments.length){var t=arguments[0];return Zs.union(this,t)}},isValid:function(){return ls.isValid(this)},intersection:function(t){if(this.isEmpty()||t.isEmpty())return ii.createEmptyResult(ii.INTERSECTION,this,t,this.factory);if(this.isGeometryCollection()){var e=t;return hn.map(this,{interfaces_:function(){return[MapOp]},map:function(t){return t.intersection(e)}})}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.INTERSECTION)},covers:function(t){return Yr.covers(this,t)},coveredBy:function(t){return Yr.coveredBy(this,t)},touches:function(t){return Yr.touches(this,t)},intersects:function(t){return Yr.intersects(this,t)},within:function(t){return Yr.within(this,t)},overlaps:function(t){return Yr.overlaps(this,t)},disjoint:function(t){return Yr.disjoint(this,t)},crosses:function(t){return Yr.crosses(this,t)},buffer:function(){if(1===arguments.length){var t=arguments[0];return sr.bufferOp(this,t)}if(2===arguments.length){var e=arguments[0],n=arguments[1];return sr.bufferOp(this,e,n)}if(3===arguments.length){var i=arguments[0],r=arguments[1],s=arguments[2];return sr.bufferOp(this,i,r,s)}},convexHull:function(){return new me(this).getConvexHull()},relate:function(){for(var t=arguments.length,e=Array(t),n=0;t>n;n++)e[n]=arguments[n];return Yr.relate.apply(Yr,[this].concat(e))},getCentroid:function(){if(this.isEmpty())return this.factory.createPoint();var t=ge.getCentroid(this);return this.createPointFromInternalCoord(t,this)},getInteriorPoint:function(){if(this.isEmpty())return this.factory.createPoint();var t=null,e=this.getDimension();if(0===e){var n=new li(this);t=n.getInteriorPoint()}else if(1===e){var n=new ui(this);t=n.getInteriorPoint()}else{var n=new oi(this);t=n.getInteriorPoint()}return this.createPointFromInternalCoord(t,this)},symDifference:function(t){if(this.isEmpty()||t.isEmpty()){if(this.isEmpty()&&t.isEmpty())return ii.createEmptyResult(ii.SYMDIFFERENCE,this,t,this.factory);if(this.isEmpty())return t.copy();if(t.isEmpty())return this.copy()}return this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.SYMDIFFERENCE)},createPointFromInternalCoord:function(t,e){return e.getPrecisionModel().makePrecise(t),e.getFactory().createPoint(t)},toText:function(){var t=new se;return t.write(this)},toString:function(){this.toText()},contains:function(t){return Yr.contains(this,t)},difference:function(t){return this.isEmpty()?ii.createEmptyResult(ii.DIFFERENCE,this,t,this.factory):t.isEmpty()?this.copy():(this.checkNotGeometryCollection(this),this.checkNotGeometryCollection(t),si.overlayOp(this,t,ii.DIFFERENCE))},isSimple:function(){var t=new Gi(this);return t.isSimple()},isWithinDistance:function(t,e){var n=this.getEnvelopeInternal().distance(t.getEnvelopeInternal());return n>e?!1:hr.isWithinDistance(this,t,e)},distance:function(t){return hr.distance(this,t)},isEquivalentClass:function(t){return this.getClass()===t.getClass()}});var Ao="1.1.2 (248dab8)";t.version=Ao,t.algorithm=co,t.densify=fo,t.dissolve=go,t.geom=lo,t.index=mo,t.io=Io,t.noding=No,t.operation=Oo,t.precision=_o,t.simplify=Mo,t.triangulate=Do});


/***/ }),

/***/ "./node_modules/monotone-convex-hull-2d/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/monotone-convex-hull-2d/index.js ***!
  \*******************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = monotoneConvexHull2D

var orient = __webpack_require__(/*! robust-orientation */ "./node_modules/robust-orientation/orientation.js")[3]

function monotoneConvexHull2D(points) {
  var n = points.length

  if(n < 3) {
    var result = new Array(n)
    for(var i=0; i<n; ++i) {
      result[i] = i
    }

    if(n === 2 &&
       points[0][0] === points[1][0] &&
       points[0][1] === points[1][1]) {
      return [0]
    }

    return result
  }

  //Sort point indices along x-axis
  var sorted = new Array(n)
  for(var i=0; i<n; ++i) {
    sorted[i] = i
  }
  sorted.sort(function(a,b) {
    var d = points[a][0]-points[b][0]
    if(d) {
      return d
    }
    return points[a][1] - points[b][1]
  })

  //Construct upper and lower hulls
  var lower = [sorted[0], sorted[1]]
  var upper = [sorted[0], sorted[1]]

  for(var i=2; i<n; ++i) {
    var idx = sorted[i]
    var p   = points[idx]

    //Insert into lower list
    var m = lower.length
    while(m > 1 && orient(
        points[lower[m-2]], 
        points[lower[m-1]], 
        p) <= 0) {
      m -= 1
      lower.pop()
    }
    lower.push(idx)

    //Insert into upper list
    m = upper.length
    while(m > 1 && orient(
        points[upper[m-2]], 
        points[upper[m-1]], 
        p) >= 0) {
      m -= 1
      upper.pop()
    }
    upper.push(idx)
  }

  //Merge lists together
  var result = new Array(upper.length + lower.length - 2)
  var ptr    = 0
  for(var i=0, nl=lower.length; i<nl; ++i) {
    result[ptr++] = lower[i]
  }
  for(var j=upper.length-2; j>0; --j) {
    result[ptr++] = upper[j]
  }

  //Return result
  return result
}

/***/ }),

/***/ "./node_modules/quickselect/quickselect.js":
/*!*************************************************!*\
  !*** ./node_modules/quickselect/quickselect.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

(function (global, factory) {
	 true ? module.exports = factory() :
	undefined;
}(this, (function () { 'use strict';

function quickselect(arr, k, left, right, compare) {
    quickselectStep(arr, k, left || 0, right || (arr.length - 1), compare || defaultCompare);
}

function quickselectStep(arr, k, left, right, compare) {

    while (right > left) {
        if (right - left > 600) {
            var n = right - left + 1;
            var m = k - left + 1;
            var z = Math.log(n);
            var s = 0.5 * Math.exp(2 * z / 3);
            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);
            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));
            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));
            quickselectStep(arr, k, newLeft, newRight, compare);
        }

        var t = arr[k];
        var i = left;
        var j = right;

        swap(arr, left, k);
        if (compare(arr[right], t) > 0) swap(arr, left, right);

        while (i < j) {
            swap(arr, i, j);
            i++;
            j--;
            while (compare(arr[i], t) < 0) i++;
            while (compare(arr[j], t) > 0) j--;
        }

        if (compare(arr[left], t) === 0) swap(arr, left, j);
        else {
            j++;
            swap(arr, j, right);
        }

        if (j <= k) left = j + 1;
        if (k <= j) right = j - 1;
    }
}

function swap(arr, i, j) {
    var tmp = arr[i];
    arr[i] = arr[j];
    arr[j] = tmp;
}

function defaultCompare(a, b) {
    return a < b ? -1 : a > b ? 1 : 0;
}

return quickselect;

})));


/***/ }),

/***/ "./node_modules/rbush/index.js":
/*!*************************************!*\
  !*** ./node_modules/rbush/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = rbush;
module.exports.default = rbush;

var quickselect = __webpack_require__(/*! quickselect */ "./node_modules/quickselect/quickselect.js");

function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}

rbush.prototype = {

    all: function () {
        return this._all(this.data, []);
    },

    search: function (bbox) {

        var node = this.data,
            result = [],
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return result;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf) result.push(child);
                    else if (contains(bbox, childBBox)) this._all(child, result);
                    else nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return result;
    },

    collides: function (bbox) {

        var node = this.data,
            toBBox = this.toBBox;

        if (!intersects(bbox, node)) return false;

        var nodesToSearch = [],
            i, len, child, childBBox;

        while (node) {
            for (i = 0, len = node.children.length; i < len; i++) {

                child = node.children[i];
                childBBox = node.leaf ? toBBox(child) : child;

                if (intersects(bbox, childBBox)) {
                    if (node.leaf || contains(bbox, childBBox)) return true;
                    nodesToSearch.push(child);
                }
            }
            node = nodesToSearch.pop();
        }

        return false;
    },

    load: function (data) {
        if (!(data && data.length)) return this;

        if (data.length < this._minEntries) {
            for (var i = 0, len = data.length; i < len; i++) {
                this.insert(data[i]);
            }
            return this;
        }

        // recursively build the tree with the given data from scratch using OMT algorithm
        var node = this._build(data.slice(), 0, data.length - 1, 0);

        if (!this.data.children.length) {
            // save as is if tree is empty
            this.data = node;

        } else if (this.data.height === node.height) {
            // split root if trees have the same height
            this._splitRoot(this.data, node);

        } else {
            if (this.data.height < node.height) {
                // swap trees if inserted one is bigger
                var tmpNode = this.data;
                this.data = node;
                node = tmpNode;
            }

            // insert the small tree into the large tree at appropriate level
            this._insert(node, this.data.height - node.height - 1, true);
        }

        return this;
    },

    insert: function (item) {
        if (item) this._insert(item, this.data.height - 1);
        return this;
    },

    clear: function () {
        this.data = createNode([]);
        return this;
    },

    remove: function (item, equalsFn) {
        if (!item) return this;

        var node = this.data,
            bbox = this.toBBox(item),
            path = [],
            indexes = [],
            i, parent, index, goingUp;

        // depth-first iterative tree traversal
        while (node || path.length) {

            if (!node) { // go up
                node = path.pop();
                parent = path[path.length - 1];
                i = indexes.pop();
                goingUp = true;
            }

            if (node.leaf) { // check current node
                index = findItem(item, node.children, equalsFn);

                if (index !== -1) {
                    // item found, remove the item and condense tree upwards
                    node.children.splice(index, 1);
                    path.push(node);
                    this._condense(path);
                    return this;
                }
            }

            if (!goingUp && !node.leaf && contains(node, bbox)) { // go down
                path.push(node);
                indexes.push(i);
                i = 0;
                parent = node;
                node = node.children[0];

            } else if (parent) { // go right
                i++;
                node = parent.children[i];
                goingUp = false;

            } else node = null; // nothing found
        }

        return this;
    },

    toBBox: function (item) { return item; },

    compareMinX: compareNodeMinX,
    compareMinY: compareNodeMinY,

    toJSON: function () { return this.data; },

    fromJSON: function (data) {
        this.data = data;
        return this;
    },

    _all: function (node, result) {
        var nodesToSearch = [];
        while (node) {
            if (node.leaf) result.push.apply(result, node.children);
            else nodesToSearch.push.apply(nodesToSearch, node.children);

            node = nodesToSearch.pop();
        }
        return result;
    },

    _build: function (items, left, right, height) {

        var N = right - left + 1,
            M = this._maxEntries,
            node;

        if (N <= M) {
            // reached leaf level; return leaf
            node = createNode(items.slice(left, right + 1));
            calcBBox(node, this.toBBox);
            return node;
        }

        if (!height) {
            // target height of the bulk-loaded tree
            height = Math.ceil(Math.log(N) / Math.log(M));

            // target number of root entries to maximize storage utilization
            M = Math.ceil(N / Math.pow(M, height - 1));
        }

        node = createNode([]);
        node.leaf = false;
        node.height = height;

        // split the items into M mostly square tiles

        var N2 = Math.ceil(N / M),
            N1 = N2 * Math.ceil(Math.sqrt(M)),
            i, j, right2, right3;

        multiSelect(items, left, right, N1, this.compareMinX);

        for (i = left; i <= right; i += N1) {

            right2 = Math.min(i + N1 - 1, right);

            multiSelect(items, i, right2, N2, this.compareMinY);

            for (j = i; j <= right2; j += N2) {

                right3 = Math.min(j + N2 - 1, right2);

                // pack each entry recursively
                node.children.push(this._build(items, j, right3, height - 1));
            }
        }

        calcBBox(node, this.toBBox);

        return node;
    },

    _chooseSubtree: function (bbox, node, level, path) {

        var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

        while (true) {
            path.push(node);

            if (node.leaf || path.length - 1 === level) break;

            minArea = minEnlargement = Infinity;

            for (i = 0, len = node.children.length; i < len; i++) {
                child = node.children[i];
                area = bboxArea(child);
                enlargement = enlargedArea(bbox, child) - area;

                // choose entry with the least area enlargement
                if (enlargement < minEnlargement) {
                    minEnlargement = enlargement;
                    minArea = area < minArea ? area : minArea;
                    targetNode = child;

                } else if (enlargement === minEnlargement) {
                    // otherwise choose one with the smallest area
                    if (area < minArea) {
                        minArea = area;
                        targetNode = child;
                    }
                }
            }

            node = targetNode || node.children[0];
        }

        return node;
    },

    _insert: function (item, level, isNode) {

        var toBBox = this.toBBox,
            bbox = isNode ? item : toBBox(item),
            insertPath = [];

        // find the best node for accommodating the item, saving all nodes along the path too
        var node = this._chooseSubtree(bbox, this.data, level, insertPath);

        // put the item into the node
        node.children.push(item);
        extend(node, bbox);

        // split on node overflow; propagate upwards if necessary
        while (level >= 0) {
            if (insertPath[level].children.length > this._maxEntries) {
                this._split(insertPath, level);
                level--;
            } else break;
        }

        // adjust bboxes along the insertion path
        this._adjustParentBBoxes(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

        var node = insertPath[level],
            M = node.children.length,
            m = this._minEntries;

        this._chooseSplitAxis(node, m, M);

        var splitIndex = this._chooseSplitIndex(node, m, M);

        var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
        newNode.height = node.height;
        newNode.leaf = node.leaf;

        calcBBox(node, this.toBBox);
        calcBBox(newNode, this.toBBox);

        if (level) insertPath[level - 1].children.push(newNode);
        else this._splitRoot(node, newNode);
    },

    _splitRoot: function (node, newNode) {
        // split root node
        this.data = createNode([node, newNode]);
        this.data.height = node.height + 1;
        this.data.leaf = false;
        calcBBox(this.data, this.toBBox);
    },

    _chooseSplitIndex: function (node, m, M) {

        var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

        minOverlap = minArea = Infinity;

        for (i = m; i <= M - m; i++) {
            bbox1 = distBBox(node, 0, i, this.toBBox);
            bbox2 = distBBox(node, i, M, this.toBBox);

            overlap = intersectionArea(bbox1, bbox2);
            area = bboxArea(bbox1) + bboxArea(bbox2);

            // choose distribution with minimum overlap
            if (overlap < minOverlap) {
                minOverlap = overlap;
                index = i;

                minArea = area < minArea ? area : minArea;

            } else if (overlap === minOverlap) {
                // otherwise choose distribution with minimum area
                if (area < minArea) {
                    minArea = area;
                    index = i;
                }
            }
        }

        return index;
    },

    // sorts node children by the best axis for split
    _chooseSplitAxis: function (node, m, M) {

        var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
            compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
            xMargin = this._allDistMargin(node, m, M, compareMinX),
            yMargin = this._allDistMargin(node, m, M, compareMinY);

        // if total distributions margin value is minimal for x, sort by minX,
        // otherwise it's already sorted by minY
        if (xMargin < yMargin) node.children.sort(compareMinX);
    },

    // total margin of all possible split distributions where each node is at least m full
    _allDistMargin: function (node, m, M, compare) {

        node.children.sort(compare);

        var toBBox = this.toBBox,
            leftBBox = distBBox(node, 0, m, toBBox),
            rightBBox = distBBox(node, M - m, M, toBBox),
            margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
            i, child;

        for (i = m; i < M - m; i++) {
            child = node.children[i];
            extend(leftBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(leftBBox);
        }

        for (i = M - m - 1; i >= m; i--) {
            child = node.children[i];
            extend(rightBBox, node.leaf ? toBBox(child) : child);
            margin += bboxMargin(rightBBox);
        }

        return margin;
    },

    _adjustParentBBoxes: function (bbox, path, level) {
        // adjust bboxes along the given tree path
        for (var i = level; i >= 0; i--) {
            extend(path[i], bbox);
        }
    },

    _condense: function (path) {
        // go through the path, removing empty nodes and updating bboxes
        for (var i = path.length - 1, siblings; i >= 0; i--) {
            if (path[i].children.length === 0) {
                if (i > 0) {
                    siblings = path[i - 1].children;
                    siblings.splice(siblings.indexOf(path[i]), 1);

                } else this.clear();

            } else calcBBox(path[i], this.toBBox);
        }
    },

    _initFormat: function (format) {
        // data format (minX, minY, maxX, maxY accessors)

        // uses eval-type function compilation instead of just accepting a toBBox function
        // because the algorithms are very sensitive to sorting functions performance,
        // so they should be dead simple and without inner calls

        var compareArr = ['return a', ' - b', ';'];

        this.compareMinX = new Function('a', 'b', compareArr.join(format[0]));
        this.compareMinY = new Function('a', 'b', compareArr.join(format[1]));

        this.toBBox = new Function('a',
            'return {minX: a' + format[0] +
            ', minY: a' + format[1] +
            ', maxX: a' + format[2] +
            ', maxY: a' + format[3] + '};');
    }
};

function findItem(item, items, equalsFn) {
    if (!equalsFn) return items.indexOf(item);

    for (var i = 0; i < items.length; i++) {
        if (equalsFn(item, items[i])) return i;
    }
    return -1;
}

// calculate node's bbox from bboxes of its children
function calcBBox(node, toBBox) {
    distBBox(node, 0, node.children.length, toBBox, node);
}

// min bounding rectangle of node children from k to p-1
function distBBox(node, k, p, toBBox, destNode) {
    if (!destNode) destNode = createNode(null);
    destNode.minX = Infinity;
    destNode.minY = Infinity;
    destNode.maxX = -Infinity;
    destNode.maxY = -Infinity;

    for (var i = k, child; i < p; i++) {
        child = node.children[i];
        extend(destNode, node.leaf ? toBBox(child) : child);
    }

    return destNode;
}

function extend(a, b) {
    a.minX = Math.min(a.minX, b.minX);
    a.minY = Math.min(a.minY, b.minY);
    a.maxX = Math.max(a.maxX, b.maxX);
    a.maxY = Math.max(a.maxY, b.maxY);
    return a;
}

function compareNodeMinX(a, b) { return a.minX - b.minX; }
function compareNodeMinY(a, b) { return a.minY - b.minY; }

function bboxArea(a)   { return (a.maxX - a.minX) * (a.maxY - a.minY); }
function bboxMargin(a) { return (a.maxX - a.minX) + (a.maxY - a.minY); }

function enlargedArea(a, b) {
    return (Math.max(b.maxX, a.maxX) - Math.min(b.minX, a.minX)) *
           (Math.max(b.maxY, a.maxY) - Math.min(b.minY, a.minY));
}

function intersectionArea(a, b) {
    var minX = Math.max(a.minX, b.minX),
        minY = Math.max(a.minY, b.minY),
        maxX = Math.min(a.maxX, b.maxX),
        maxY = Math.min(a.maxY, b.maxY);

    return Math.max(0, maxX - minX) *
           Math.max(0, maxY - minY);
}

function contains(a, b) {
    return a.minX <= b.minX &&
           a.minY <= b.minY &&
           b.maxX <= a.maxX &&
           b.maxY <= a.maxY;
}

function intersects(a, b) {
    return b.minX <= a.maxX &&
           b.minY <= a.maxY &&
           b.maxX >= a.minX &&
           b.maxY >= a.minY;
}

function createNode(children) {
    return {
        children: children,
        height: 1,
        leaf: true,
        minX: Infinity,
        minY: Infinity,
        maxX: -Infinity,
        maxY: -Infinity
    };
}

// sort an array so that items come in groups of n unsorted items, with groups sorted between each other;
// combines selection algorithm with binary divide & conquer approach

function multiSelect(arr, left, right, n, compare) {
    var stack = [left, right],
        mid;

    while (stack.length) {
        right = stack.pop();
        left = stack.pop();

        if (right - left <= n) continue;

        mid = left + Math.ceil((right - left) / n / 2) * n;
        quickselect(arr, mid, left, right, compare);

        stack.push(left, mid, mid, right);
    }
}


/***/ }),

/***/ "./node_modules/robust-orientation/orientation.js":
/*!********************************************************!*\
  !*** ./node_modules/robust-orientation/orientation.js ***!
  \********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var twoProduct = __webpack_require__(/*! two-product */ "./node_modules/two-product/two-product.js")
var robustSum = __webpack_require__(/*! robust-sum */ "./node_modules/robust-sum/robust-sum.js")
var robustScale = __webpack_require__(/*! robust-scale */ "./node_modules/robust-scale/robust-scale.js")
var robustSubtract = __webpack_require__(/*! robust-subtract */ "./node_modules/robust-subtract/robust-diff.js")

var NUM_EXPAND = 5

var EPSILON     = 1.1102230246251565e-16
var ERRBOUND3   = (3.0 + 16.0 * EPSILON) * EPSILON
var ERRBOUND4   = (7.0 + 56.0 * EPSILON) * EPSILON

function cofactor(m, c) {
  var result = new Array(m.length-1)
  for(var i=1; i<m.length; ++i) {
    var r = result[i-1] = new Array(m.length-1)
    for(var j=0,k=0; j<m.length; ++j) {
      if(j === c) {
        continue
      }
      r[k++] = m[i][j]
    }
  }
  return result
}

function matrix(n) {
  var result = new Array(n)
  for(var i=0; i<n; ++i) {
    result[i] = new Array(n)
    for(var j=0; j<n; ++j) {
      result[i][j] = ["m", j, "[", (n-i-1), "]"].join("")
    }
  }
  return result
}

function sign(n) {
  if(n & 1) {
    return "-"
  }
  return ""
}

function generateSum(expr) {
  if(expr.length === 1) {
    return expr[0]
  } else if(expr.length === 2) {
    return ["sum(", expr[0], ",", expr[1], ")"].join("")
  } else {
    var m = expr.length>>1
    return ["sum(", generateSum(expr.slice(0, m)), ",", generateSum(expr.slice(m)), ")"].join("")
  }
}

function determinant(m) {
  if(m.length === 2) {
    return [["sum(prod(", m[0][0], ",", m[1][1], "),prod(-", m[0][1], ",", m[1][0], "))"].join("")]
  } else {
    var expr = []
    for(var i=0; i<m.length; ++i) {
      expr.push(["scale(", generateSum(determinant(cofactor(m, i))), ",", sign(i), m[0][i], ")"].join(""))
    }
    return expr
  }
}

function orientation(n) {
  var pos = []
  var neg = []
  var m = matrix(n)
  var args = []
  for(var i=0; i<n; ++i) {
    if((i&1)===0) {
      pos.push.apply(pos, determinant(cofactor(m, i)))
    } else {
      neg.push.apply(neg, determinant(cofactor(m, i)))
    }
    args.push("m" + i)
  }
  var posExpr = generateSum(pos)
  var negExpr = generateSum(neg)
  var funcName = "orientation" + n + "Exact"
  var code = ["function ", funcName, "(", args.join(), "){var p=", posExpr, ",n=", negExpr, ",d=sub(p,n);\
return d[d.length-1];};return ", funcName].join("")
  var proc = new Function("sum", "prod", "scale", "sub", code)
  return proc(robustSum, twoProduct, robustScale, robustSubtract)
}

var orientation3Exact = orientation(3)
var orientation4Exact = orientation(4)

var CACHED = [
  function orientation0() { return 0 },
  function orientation1() { return 0 },
  function orientation2(a, b) { 
    return b[0] - a[0]
  },
  function orientation3(a, b, c) {
    var l = (a[1] - c[1]) * (b[0] - c[0])
    var r = (a[0] - c[0]) * (b[1] - c[1])
    var det = l - r
    var s
    if(l > 0) {
      if(r <= 0) {
        return det
      } else {
        s = l + r
      }
    } else if(l < 0) {
      if(r >= 0) {
        return det
      } else {
        s = -(l + r)
      }
    } else {
      return det
    }
    var tol = ERRBOUND3 * s
    if(det >= tol || det <= -tol) {
      return det
    }
    return orientation3Exact(a, b, c)
  },
  function orientation4(a,b,c,d) {
    var adx = a[0] - d[0]
    var bdx = b[0] - d[0]
    var cdx = c[0] - d[0]
    var ady = a[1] - d[1]
    var bdy = b[1] - d[1]
    var cdy = c[1] - d[1]
    var adz = a[2] - d[2]
    var bdz = b[2] - d[2]
    var cdz = c[2] - d[2]
    var bdxcdy = bdx * cdy
    var cdxbdy = cdx * bdy
    var cdxady = cdx * ady
    var adxcdy = adx * cdy
    var adxbdy = adx * bdy
    var bdxady = bdx * ady
    var det = adz * (bdxcdy - cdxbdy) 
            + bdz * (cdxady - adxcdy)
            + cdz * (adxbdy - bdxady)
    var permanent = (Math.abs(bdxcdy) + Math.abs(cdxbdy)) * Math.abs(adz)
                  + (Math.abs(cdxady) + Math.abs(adxcdy)) * Math.abs(bdz)
                  + (Math.abs(adxbdy) + Math.abs(bdxady)) * Math.abs(cdz)
    var tol = ERRBOUND4 * permanent
    if ((det > tol) || (-det > tol)) {
      return det
    }
    return orientation4Exact(a,b,c,d)
  }
]

function slowOrient(args) {
  var proc = CACHED[args.length]
  if(!proc) {
    proc = CACHED[args.length] = orientation(args.length)
  }
  return proc.apply(undefined, args)
}

function generateOrientationProc() {
  while(CACHED.length <= NUM_EXPAND) {
    CACHED.push(orientation(CACHED.length))
  }
  var args = []
  var procArgs = ["slow"]
  for(var i=0; i<=NUM_EXPAND; ++i) {
    args.push("a" + i)
    procArgs.push("o" + i)
  }
  var code = [
    "function getOrientation(", args.join(), "){switch(arguments.length){case 0:case 1:return 0;"
  ]
  for(var i=2; i<=NUM_EXPAND; ++i) {
    code.push("case ", i, ":return o", i, "(", args.slice(0, i).join(), ");")
  }
  code.push("}var s=new Array(arguments.length);for(var i=0;i<arguments.length;++i){s[i]=arguments[i]};return slow(s);}return getOrientation")
  procArgs.push(code.join(""))

  var proc = Function.apply(undefined, procArgs)
  module.exports = proc.apply(undefined, [slowOrient].concat(CACHED))
  for(var i=0; i<=NUM_EXPAND; ++i) {
    module.exports[i] = CACHED[i]
  }
}

generateOrientationProc()

/***/ }),

/***/ "./node_modules/robust-scale/robust-scale.js":
/*!***************************************************!*\
  !*** ./node_modules/robust-scale/robust-scale.js ***!
  \***************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var twoProduct = __webpack_require__(/*! two-product */ "./node_modules/two-product/two-product.js")
var twoSum = __webpack_require__(/*! two-sum */ "./node_modules/two-sum/two-sum.js")

module.exports = scaleLinearExpansion

function scaleLinearExpansion(e, scale) {
  var n = e.length
  if(n === 1) {
    var ts = twoProduct(e[0], scale)
    if(ts[0]) {
      return ts
    }
    return [ ts[1] ]
  }
  var g = new Array(2 * n)
  var q = [0.1, 0.1]
  var t = [0.1, 0.1]
  var count = 0
  twoProduct(e[0], scale, q)
  if(q[0]) {
    g[count++] = q[0]
  }
  for(var i=1; i<n; ++i) {
    twoProduct(e[i], scale, t)
    var pq = q[1]
    twoSum(pq, t[0], q)
    if(q[0]) {
      g[count++] = q[0]
    }
    var a = t[1]
    var b = q[1]
    var x = a + b
    var bv = x - a
    var y = b - bv
    q[1] = x
    if(y) {
      g[count++] = y
    }
  }
  if(q[1]) {
    g[count++] = q[1]
  }
  if(count === 0) {
    g[count++] = 0.0
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/robust-subtract/robust-diff.js":
/*!*****************************************************!*\
  !*** ./node_modules/robust-subtract/robust-diff.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = robustSubtract

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function robustSubtract(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], -f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = -f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = -f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = -f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/robust-sum/robust-sum.js":
/*!***********************************************!*\
  !*** ./node_modules/robust-sum/robust-sum.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = linearExpansionSum

//Easy case: Add two scalars
function scalarScalar(a, b) {
  var x = a + b
  var bv = x - a
  var av = x - bv
  var br = b - bv
  var ar = a - av
  var y = ar + br
  if(y) {
    return [y, x]
  }
  return [x]
}

function linearExpansionSum(e, f) {
  var ne = e.length|0
  var nf = f.length|0
  if(ne === 1 && nf === 1) {
    return scalarScalar(e[0], f[0])
  }
  var n = ne + nf
  var g = new Array(n)
  var count = 0
  var eptr = 0
  var fptr = 0
  var abs = Math.abs
  var ei = e[eptr]
  var ea = abs(ei)
  var fi = f[fptr]
  var fa = abs(fi)
  var a, b
  if(ea < fa) {
    b = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    b = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  if((eptr < ne && ea < fa) || (fptr >= nf)) {
    a = ei
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
      ea = abs(ei)
    }
  } else {
    a = fi
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
      fa = abs(fi)
    }
  }
  var x = a + b
  var bv = x - a
  var y = b - bv
  var q0 = y
  var q1 = x
  var _x, _bv, _av, _br, _ar
  while(eptr < ne && fptr < nf) {
    if(ea < fa) {
      a = ei
      eptr += 1
      if(eptr < ne) {
        ei = e[eptr]
        ea = abs(ei)
      }
    } else {
      a = fi
      fptr += 1
      if(fptr < nf) {
        fi = f[fptr]
        fa = abs(fi)
      }
    }
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
  }
  while(eptr < ne) {
    a = ei
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    }
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    eptr += 1
    if(eptr < ne) {
      ei = e[eptr]
    }
  }
  while(fptr < nf) {
    a = fi
    b = q0
    x = a + b
    bv = x - a
    y = b - bv
    if(y) {
      g[count++] = y
    } 
    _x = q1 + x
    _bv = _x - q1
    _av = _x - _bv
    _br = x - _bv
    _ar = q1 - _av
    q0 = _ar + _br
    q1 = _x
    fptr += 1
    if(fptr < nf) {
      fi = f[fptr]
    }
  }
  if(q0) {
    g[count++] = q0
  }
  if(q1) {
    g[count++] = q1
  }
  if(!count) {
    g[count++] = 0.0  
  }
  g.length = count
  return g
}

/***/ }),

/***/ "./node_modules/simplicial-complex/topology.js":
/*!*****************************************************!*\
  !*** ./node_modules/simplicial-complex/topology.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 "use restrict";

var bits      = __webpack_require__(/*! bit-twiddle */ "./node_modules/bit-twiddle/twiddle.js")
  , UnionFind = __webpack_require__(/*! union-find */ "./node_modules/union-find/index.js")

//Returns the dimension of a cell complex
function dimension(cells) {
  var d = 0
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    d = max(d, cells[i].length)
  }
  return d-1
}
exports.dimension = dimension

//Counts the number of vertices in faces
function countVertices(cells) {
  var vc = -1
    , max = Math.max
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0, jl=c.length; j<jl; ++j) {
      vc = max(vc, c[j])
    }
  }
  return vc+1
}
exports.countVertices = countVertices

//Returns a deep copy of cells
function cloneCells(cells) {
  var ncells = new Array(cells.length)
  for(var i=0, il=cells.length; i<il; ++i) {
    ncells[i] = cells[i].slice(0)
  }
  return ncells
}
exports.cloneCells = cloneCells

//Ranks a pair of cells up to permutation
function compareCells(a, b) {
  var n = a.length
    , t = a.length - b.length
    , min = Math.min
  if(t) {
    return t
  }
  switch(n) {
    case 0:
      return 0;
    case 1:
      return a[0] - b[0];
    case 2:
      var d = a[0]+a[1]-b[0]-b[1]
      if(d) {
        return d
      }
      return min(a[0],a[1]) - min(b[0],b[1])
    case 3:
      var l1 = a[0]+a[1]
        , m1 = b[0]+b[1]
      d = l1+a[2] - (m1+b[2])
      if(d) {
        return d
      }
      var l0 = min(a[0], a[1])
        , m0 = min(b[0], b[1])
        , d  = min(l0, a[2]) - min(m0, b[2])
      if(d) {
        return d
      }
      return min(l0+a[2], l1) - min(m0+b[2], m1)
    
    //TODO: Maybe optimize n=4 as well?
    
    default:
      var as = a.slice(0)
      as.sort()
      var bs = b.slice(0)
      bs.sort()
      for(var i=0; i<n; ++i) {
        t = as[i] - bs[i]
        if(t) {
          return t
        }
      }
      return 0
  }
}
exports.compareCells = compareCells

function compareZipped(a, b) {
  return compareCells(a[0], b[0])
}

//Puts a cell complex into normal order for the purposes of findCell queries
function normalize(cells, attr) {
  if(attr) {
    var len = cells.length
    var zipped = new Array(len)
    for(var i=0; i<len; ++i) {
      zipped[i] = [cells[i], attr[i]]
    }
    zipped.sort(compareZipped)
    for(var i=0; i<len; ++i) {
      cells[i] = zipped[i][0]
      attr[i] = zipped[i][1]
    }
    return cells
  } else {
    cells.sort(compareCells)
    return cells
  }
}
exports.normalize = normalize

//Removes all duplicate cells in the complex
function unique(cells) {
  if(cells.length === 0) {
    return []
  }
  var ptr = 1
    , len = cells.length
  for(var i=1; i<len; ++i) {
    var a = cells[i]
    if(compareCells(a, cells[i-1])) {
      if(i === ptr) {
        ptr++
        continue
      }
      cells[ptr++] = a
    }
  }
  cells.length = ptr
  return cells
}
exports.unique = unique;

//Finds a cell in a normalized cell complex
function findCell(cells, c) {
  var lo = 0
    , hi = cells.length-1
    , r  = -1
  while (lo <= hi) {
    var mid = (lo + hi) >> 1
      , s   = compareCells(cells[mid], c)
    if(s <= 0) {
      if(s === 0) {
        r = mid
      }
      lo = mid + 1
    } else if(s > 0) {
      hi = mid - 1
    }
  }
  return r
}
exports.findCell = findCell;

//Builds an index for an n-cell.  This is more general than dual, but less efficient
function incidence(from_cells, to_cells) {
  var index = new Array(from_cells.length)
  for(var i=0, il=index.length; i<il; ++i) {
    index[i] = []
  }
  var b = []
  for(var i=0, n=to_cells.length; i<n; ++i) {
    var c = to_cells[i]
    var cl = c.length
    for(var k=1, kn=(1<<cl); k<kn; ++k) {
      b.length = bits.popCount(k)
      var l = 0
      for(var j=0; j<cl; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      var idx=findCell(from_cells, b)
      if(idx < 0) {
        continue
      }
      while(true) {
        index[idx++].push(i)
        if(idx >= from_cells.length || compareCells(from_cells[idx], b) !== 0) {
          break
        }
      }
    }
  }
  return index
}
exports.incidence = incidence

//Computes the dual of the mesh.  This is basically an optimized version of buildIndex for the situation where from_cells is just the list of vertices
function dual(cells, vertex_count) {
  if(!vertex_count) {
    return incidence(unique(skeleton(cells, 0)), cells, 0)
  }
  var res = new Array(vertex_count)
  for(var i=0; i<vertex_count; ++i) {
    res[i] = []
  }
  for(var i=0, len=cells.length; i<len; ++i) {
    var c = cells[i]
    for(var j=0, cl=c.length; j<cl; ++j) {
      res[c[j]].push(i)
    }
  }
  return res
}
exports.dual = dual

//Enumerates all cells in the complex
function explode(cells) {
  var result = []
  for(var i=0, il=cells.length; i<il; ++i) {
    var c = cells[i]
      , cl = c.length|0
    for(var j=1, jl=(1<<cl); j<jl; ++j) {
      var b = []
      for(var k=0; k<cl; ++k) {
        if((j >>> k) & 1) {
          b.push(c[k])
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.explode = explode

//Enumerates all of the n-cells of a cell complex
function skeleton(cells, n) {
  if(n < 0) {
    return []
  }
  var result = []
    , k0     = (1<<(n+1))-1
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var k=k0; k<(1<<c.length); k=bits.nextCombination(k)) {
      var b = new Array(n+1)
        , l = 0
      for(var j=0; j<c.length; ++j) {
        if(k & (1<<j)) {
          b[l++] = c[j]
        }
      }
      result.push(b)
    }
  }
  return normalize(result)
}
exports.skeleton = skeleton;

//Computes the boundary of all cells, does not remove duplicates
function boundary(cells) {
  var res = []
  for(var i=0,il=cells.length; i<il; ++i) {
    var c = cells[i]
    for(var j=0,cl=c.length; j<cl; ++j) {
      var b = new Array(c.length-1)
      for(var k=0, l=0; k<cl; ++k) {
        if(k !== j) {
          b[l++] = c[k]
        }
      }
      res.push(b)
    }
  }
  return normalize(res)
}
exports.boundary = boundary;

//Computes connected components for a dense cell complex
function connectedComponents_dense(cells, vertex_count) {
  var labels = new UnionFind(vertex_count)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      for(var k=j+1; k<c.length; ++k) {
        labels.link(c[j], c[k])
      }
    }
  }
  var components = []
    , component_labels = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(cells[i][0])
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a sparse graph
function connectedComponents_sparse(cells) {
  var vertices  = unique(normalize(skeleton(cells, 0)))
    , labels    = new UnionFind(vertices.length)
  for(var i=0; i<cells.length; ++i) {
    var c = cells[i]
    for(var j=0; j<c.length; ++j) {
      var vj = findCell(vertices, [c[j]])
      for(var k=j+1; k<c.length; ++k) {
        labels.link(vj, findCell(vertices, [c[k]]))
      }
    }
  }
  var components        = []
    , component_labels  = labels.ranks
  for(var i=0; i<component_labels.length; ++i) {
    component_labels[i] = -1
  }
  for(var i=0; i<cells.length; ++i) {
    var l = labels.find(findCell(vertices, [cells[i][0]]));
    if(component_labels[l] < 0) {
      component_labels[l] = components.length
      components.push([cells[i].slice(0)])
    } else {
      components[component_labels[l]].push(cells[i].slice(0))
    }
  }
  return components
}

//Computes connected components for a cell complex
function connectedComponents(cells, vertex_count) {
  if(vertex_count) {
    return connectedComponents_dense(cells, vertex_count)
  }
  return connectedComponents_sparse(cells)
}
exports.connectedComponents = connectedComponents


/***/ }),

/***/ "./node_modules/simplify-js/simplify.js":
/*!**********************************************!*\
  !*** ./node_modules/simplify-js/simplify.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_RESULT__;/*
 (c) 2017, Vladimir Agafonkin
 Simplify.js, a high-performance JS polyline simplification library
 mourner.github.io/simplify-js
*/

(function () { 'use strict';

// to suit your point format, run search/replace for '.x' and '.y';
// for 3D version, see 3d branch (configurability would draw significant performance overhead)

// square distance between 2 points
function getSqDist(p1, p2) {

    var dx = p1.x - p2.x,
        dy = p1.y - p2.y;

    return dx * dx + dy * dy;
}

// square distance from a point to a segment
function getSqSegDist(p, p1, p2) {

    var x = p1.x,
        y = p1.y,
        dx = p2.x - x,
        dy = p2.y - y;

    if (dx !== 0 || dy !== 0) {

        var t = ((p.x - x) * dx + (p.y - y) * dy) / (dx * dx + dy * dy);

        if (t > 1) {
            x = p2.x;
            y = p2.y;

        } else if (t > 0) {
            x += dx * t;
            y += dy * t;
        }
    }

    dx = p.x - x;
    dy = p.y - y;

    return dx * dx + dy * dy;
}
// rest of the code doesn't care about point format

// basic distance-based simplification
function simplifyRadialDist(points, sqTolerance) {

    var prevPoint = points[0],
        newPoints = [prevPoint],
        point;

    for (var i = 1, len = points.length; i < len; i++) {
        point = points[i];

        if (getSqDist(point, prevPoint) > sqTolerance) {
            newPoints.push(point);
            prevPoint = point;
        }
    }

    if (prevPoint !== point) newPoints.push(point);

    return newPoints;
}

function simplifyDPStep(points, first, last, sqTolerance, simplified) {
    var maxSqDist = sqTolerance,
        index;

    for (var i = first + 1; i < last; i++) {
        var sqDist = getSqSegDist(points[i], points[first], points[last]);

        if (sqDist > maxSqDist) {
            index = i;
            maxSqDist = sqDist;
        }
    }

    if (maxSqDist > sqTolerance) {
        if (index - first > 1) simplifyDPStep(points, first, index, sqTolerance, simplified);
        simplified.push(points[index]);
        if (last - index > 1) simplifyDPStep(points, index, last, sqTolerance, simplified);
    }
}

// simplification using Ramer-Douglas-Peucker algorithm
function simplifyDouglasPeucker(points, sqTolerance) {
    var last = points.length - 1;

    var simplified = [points[0]];
    simplifyDPStep(points, 0, last, sqTolerance, simplified);
    simplified.push(points[last]);

    return simplified;
}

// both algorithms combined for awesome performance
function simplify(points, tolerance, highestQuality) {

    if (points.length <= 2) return points;

    var sqTolerance = tolerance !== undefined ? tolerance * tolerance : 1;

    points = highestQuality ? points : simplifyRadialDist(points, sqTolerance);
    points = simplifyDouglasPeucker(points, sqTolerance);

    return points;
}

// export as AMD module / Node module / browser or worker variable
if (true) !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() { return simplify; }).call(exports, __webpack_require__, exports, module),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
else {}

})();


/***/ }),

/***/ "./node_modules/turf-along/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-along/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var measureDistance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");

/**
 * Takes a {@link LineString|line} and returns a {@link Point|point} at a specified distance along the line.
 *
 * @name along
 * @param {Feature<LineString>} line input line
 * @param {number} distance distance along the line
 * @param {String} [units=miles] can be degrees, radians, miles, or kilometers
 * @return {Feature<Point>} Point `distance` `units` along the line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var along = turf.along(line, 1, 'miles');
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, along]
 * };
 *
 * //=result
 */
module.exports = function (line, distance, units) {
    var coords;
    if (line.type === 'Feature') coords = line.geometry.coordinates;
    else if (line.type === 'LineString') coords = line.coordinates;
    else throw new Error('input must be a LineString Feature or Geometry');

    var travelled = 0;
    for (var i = 0; i < coords.length; i++) {
        if (distance >= travelled && i === coords.length - 1) break;
        else if (travelled >= distance) {
            var overshot = distance - travelled;
            if (!overshot) return point(coords[i]);
            else {
                var direction = bearing(coords[i], coords[i - 1]) - 180;
                var interpolated = destination(coords[i], overshot, direction, units);
                return interpolated;
            }
        } else {
            travelled += measureDistance(coords[i], coords[i + 1], units);
        }
    }
    return point(coords[coords.length - 1]);
};


/***/ }),

/***/ "./node_modules/turf-area/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-area/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var geometryArea = __webpack_require__(/*! geojson-area */ "./node_modules/geojson-area/index.js").geometry;

/**
 * Takes a one or more features and returns their area
 * in square meters.
 *
 * @param {(Feature|FeatureCollection)} input input features
 * @return {Number} area in square meters
 * @example
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-67.031021, 10.458102],
 *           [-67.031021, 10.53372],
 *           [-66.929397, 10.53372],
 *           [-66.929397, 10.458102],
 *           [-67.031021, 10.458102]
 *         ]]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-66.919784, 10.397325],
 *           [-66.919784, 10.513467],
 *           [-66.805114, 10.513467],
 *           [-66.805114, 10.397325],
 *           [-66.919784, 10.397325]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 *
 * var area = turf.area(polygons);
 *
 * //=area
 */
function area(input) {
    if (input.type === 'FeatureCollection') {
        for (var i = 0, sum = 0; i < input.features.length; i++) {
            if (input.features[i].geometry) {
                sum += geometryArea(input.features[i].geometry);
            }
        }
        return sum;
    } else if (input.type === 'Feature') {
        return geometryArea(input.geometry);
    } else {
        return geometryArea(input);
    }
}
module.exports = area;


/***/ }),

/***/ "./node_modules/turf-bbox-polygon/index.js":
/*!*************************************************!*\
  !*** ./node_modules/turf-bbox-polygon/index.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;

/**
 * Takes a bbox and returns an equivalent {@link Polygon|polygon}.
 *
 * @name bboxPolygon
 * @param {Array<number>} bbox an Array of bounding box coordinates in the form: ```[xLow, yLow, xHigh, yHigh]```
 * @return {Feature<Polygon>} a Polygon representation of the bounding box
 * @example
 * var bbox = [0, 0, 10, 10];
 *
 * var poly = turf.bboxPolygon(bbox);
 *
 * //=poly
 */

module.exports = function (bbox) {
    var lowLeft = [bbox[0], bbox[1]];
    var topLeft = [bbox[0], bbox[3]];
    var topRight = [bbox[2], bbox[3]];
    var lowRight = [bbox[2], bbox[1]];

    return polygon([[
        lowLeft,
        lowRight,
        topRight,
        topLeft,
        lowLeft
    ]]);
};


/***/ }),

/***/ "./node_modules/turf-bbox/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-bbox/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;

/**
 * Takes a set of features, calculates the bbox of all input features, and returns a bounding box.
 *
 * @name bbox
 * @param {(Feature|FeatureCollection)} geojson input features
 * @return {Array<number>} the bounding box of `input` given
 * as an array in WSEN order (west, south, east, north)
 * @example
 * var input = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.175329, 22.2524]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.170007, 22.267969]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.200649, 22.274641]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [114.186744, 22.265745]
 *       }
 *     }
 *   ]
 * };
 *
 * var bbox = turf.bbox(input);
 *
 * var bboxPolygon = turf.bboxPolygon(bbox);
 *
 * var resultFeatures = input.features.concat(bboxPolygon);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (geojson) {
    var bbox = [Infinity, Infinity, -Infinity, -Infinity];
    each(geojson, function (coord) {
        if (bbox[0] > coord[0]) bbox[0] = coord[0];
        if (bbox[1] > coord[1]) bbox[1] = coord[1];
        if (bbox[2] < coord[0]) bbox[2] = coord[0];
        if (bbox[3] < coord[1]) bbox[3] = coord[1];
    });
    return bbox;
};


/***/ }),

/***/ "./node_modules/turf-bearing/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-bearing/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Takes two {@link Point|points} and finds the geographic bearing between them.
 *
 * @name bearing
 * @param {Feature<Point>} start starting Point
 * @param {Feature<Point>} end ending Point
 * @returns {Number} bearing in decimal degrees
 * @example
 * var point1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#f00'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var point2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": '#0f0'
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [point1, point2]
 * };
 *
 * //=points
 *
 * var bearing = turf.bearing(point1, point2);
 *
 * //=bearing
 */
module.exports = function (start, end) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(start);
    var coordinates2 = getCoord(end);

    var lon1 = degrees2radians * coordinates1[0];
    var lon2 = degrees2radians * coordinates2[0];
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];
    var a = Math.sin(lon2 - lon1) * Math.cos(lat2);
    var b = Math.cos(lat1) * Math.sin(lat2) -
        Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);

    var bearing = radians2degrees * Math.atan2(a, b);

    return bearing;
};


/***/ }),

/***/ "./node_modules/turf-bezier/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-bezier/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var Spline = __webpack_require__(/*! ./spline.js */ "./node_modules/turf-bezier/spline.js");

/**
 * Takes a {@link LineString|line} and returns a curved version
 * by applying a [Bezier spline](http://en.wikipedia.org/wiki/B%C3%A9zier_spline)
 * algorithm.
 *
 * The bezier spline implementation is by [Leszek Rybicki](http://leszek.rybicki.cc/).
 *
 * @name bezier
 * @param {Feature<LineString>} line input LineString
 * @param {Number} [resolution=10000] time in milliseconds between points
 * @param {Number} [sharpness=0.85] a measure of how curvy the path should be between splines
 * @returns {Feature<LineString>} curved line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {
 *     "stroke": "#f00"
 *   },
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-76.091308, 18.427501],
 *       [-76.695556, 18.729501],
 *       [-76.552734, 19.40443],
 *       [-74.61914, 19.134789],
 *       [-73.652343, 20.07657],
 *       [-73.157958, 20.210656]
 *     ]
 *   }
 * };
 *
 * var curved = turf.bezier(line);
 * curved.properties = { stroke: '#0f0' };
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, curved]
 * };
 *
 * //=result
 */
module.exports = function (line, resolution, sharpness) {
    var lineOut = linestring([]);

    lineOut.properties = line.properties;

    var spline = new Spline({
        points: line.geometry.coordinates.map(function (pt) {
            return {x: pt[0], y: pt[1]};
        }),
        duration: resolution,
        sharpness: sharpness
    });

    for (var i = 0; i < spline.duration; i += 10) {
        var pos = spline.pos(i);
        if (Math.floor(i / 100) % 2 === 0) {
            lineOut.geometry.coordinates.push([pos.x, pos.y]);
        }
    }

    return lineOut;
};


/***/ }),

/***/ "./node_modules/turf-bezier/spline.js":
/*!********************************************!*\
  !*** ./node_modules/turf-bezier/spline.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable */

 /**
   * BezierSpline
   * https://github.com/leszekr/bezier-spline-js
   *
   * @private
   * @copyright
   * Copyright (c) 2013 Leszek Rybicki
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
var Spline = function (options) {
    this.points = options.points || [];
    this.duration = options.duration || 10000;
    this.sharpness = options.sharpness || 0.85;
    this.centers = [];
    this.controls = [];
    this.stepLength = options.stepLength || 60;
    this.length = this.points.length;
    this.delay = 0;
    // this is to ensure compatibility with the 2d version
    for (var i = 0; i < this.length; i++) this.points[i].z = this.points[i].z || 0;
    for (var i = 0; i < this.length - 1; i++) {
        var p1 = this.points[i];
        var p2 = this.points[i + 1];
        this.centers.push({
            x: (p1.x + p2.x) / 2,
            y: (p1.y + p2.y) / 2,
            z: (p1.z + p2.z) / 2
        });
    }
    this.controls.push([this.points[0], this.points[0]]);
    for (var i = 0; i < this.centers.length - 1; i++) {
        var p1 = this.centers[i];
        var p2 = this.centers[i + 1];
        var dx = this.points[i + 1].x - (this.centers[i].x + this.centers[i + 1].x) / 2;
        var dy = this.points[i + 1].y - (this.centers[i].y + this.centers[i + 1].y) / 2;
        var dz = this.points[i + 1].z - (this.centers[i].y + this.centers[i + 1].z) / 2;
        this.controls.push([{
            x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i].x + dx),
            y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i].y + dy),
            z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i].z + dz)},
            {
                x: (1.0 - this.sharpness) * this.points[i + 1].x + this.sharpness * (this.centers[i + 1].x + dx),
                y: (1.0 - this.sharpness) * this.points[i + 1].y + this.sharpness * (this.centers[i + 1].y + dy),
                z: (1.0 - this.sharpness) * this.points[i + 1].z + this.sharpness * (this.centers[i + 1].z + dz)}]);
    }
    this.controls.push([this.points[this.length - 1], this.points[this.length - 1]]);
    this.steps = this.cacheSteps(this.stepLength);
    return this;
};

  /*
    Caches an array of equidistant (more or less) points on the curve.
  */
Spline.prototype.cacheSteps = function (mindist) {
    var steps = [];
    var laststep = this.pos(0);
    steps.push(0);
    for (var t = 0; t < this.duration; t += 10) {
        var step = this.pos(t);
        var dist = Math.sqrt((step.x - laststep.x) * (step.x - laststep.x) + (step.y - laststep.y) * (step.y - laststep.y) + (step.z - laststep.z) * (step.z - laststep.z));
        if (dist > mindist) {
            steps.push(t);
            laststep = step;
        }
    }
    return steps;
};

  /*
    returns angle and speed in the given point in the curve
  */
Spline.prototype.vector = function (t) {
    var p1 = this.pos(t + 10);
    var p2 = this.pos(t - 10);
    return {
        angle:180 * Math.atan2(p1.y - p2.y, p1.x - p2.x) / 3.14,
        speed:Math.sqrt((p2.x - p1.x) * (p2.x - p1.x) + (p2.y - p1.y) * (p2.y - p1.y) + (p2.z - p1.z) * (p2.z - p1.z))
    };
};

  /*
    Gets the position of the point, given time.

    WARNING: The speed is not constant. The time it takes between control points is constant.

    For constant speed, use Spline.steps[i];
  */
Spline.prototype.pos = function (time) {

    function bezier(t, p1, c1, c2, p2) {
        var B = function (t) {
            var t2 = t * t, t3 = t2 * t;
            return [(t3), (3 * t2 * (1 - t)), (3 * t * (1 - t) * (1 - t)), ((1 - t) * (1 - t) * (1 - t))];
        };
        var b = B(t);
        var pos = {
            x : p2.x * b[0] + c2.x * b[1] + c1.x * b[2] + p1.x * b[3],
            y : p2.y * b[0] + c2.y * b[1] + c1.y * b[2] + p1.y * b[3],
            z : p2.z * b[0] + c2.z * b[1] + c1.z * b[2] + p1.z * b[3]
        };
        return pos;
    }
    var t = time - this.delay;
    if (t < 0) t = 0;
    if (t > this.duration) t = this.duration - 1;
    //t = t-this.delay;
    var t2 = (t) / this.duration;
    if (t2 >= 1) return this.points[this.length - 1];

    var n = Math.floor((this.points.length - 1) * t2);
    var t1 = (this.length - 1) * t2 - n;
    return bezier(t1, this.points[n], this.controls[n][1], this.controls[n + 1][0], this.points[n + 1]);
};

module.exports = Spline;


/***/ }),

/***/ "./node_modules/turf-buffer/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-buffer/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://stackoverflow.com/questions/839899/how-do-i-calculate-a-point-on-a-circles-circumference
// radians = degrees * (pi/180)
// https://github.com/bjornharrtell/jsts/blob/master/examples/buffer.html

var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");
var featureCollection = helpers.featureCollection;
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");
var normalize = __webpack_require__(/*! geojson-normalize */ "./node_modules/geojson-normalize/index.js");

/**
 * Calculates a buffer for input features for a given radius. Units supported are miles, kilometers, and degrees.
 *
 * @name buffer
 * @param {(Feature|FeatureCollection)} feature input to be buffered
 * @param {number} distance distance to draw the buffer
 * @param {string} unit any of the options supported by turf units
 * @return {FeatureCollection<Polygon>|FeatureCollection<MultiPolygon>|Polygon|MultiPolygon} buffered features
 *
 * @example
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-90.548630, 14.616599]
 *   }
 * };
 * var unit = 'miles';
 *
 * var buffered = turf.buffer(pt, 500, unit);
 * var result = turf.featurecollection([buffered, pt]);
 *
 * //=result
 */

module.exports = function (feature, radius, units) {

    var degrees = helpers.distanceToDegrees(radius, units);
    var fc = normalize(feature);
    var buffered = normalize(featureCollection(fc.features.map(function (f) {
        return bufferOp(f, degrees);
    })));

    if (buffered.features.length > 1) return buffered;
    else if (buffered.features.length === 1) return buffered.features[0];
};

function bufferOp(feature, radius) {
    var reader = new jsts.io.GeoJSONReader();
    var geom = reader.read(feature.geometry);
    var buffered = geom.buffer(radius);
    var writer = new jsts.io.GeoJSONWriter();
    buffered = writer.write(buffered);

    return {
        type: 'Feature',
        geometry: buffered,
        properties: {}
    };
}


/***/ }),

/***/ "./node_modules/turf-center/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-center/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js"),
    point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a {@link FeatureCollection} and returns the absolute center point of all features.
 *
 * @name center
 * @param {FeatureCollection} features input features
 * @return {Feature<Point>} a Point feature at the
 * absolute center point of all input features
 * @example
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.522259, 35.4691]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.502754, 35.463455]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508269, 35.463245]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.516809, 35.465779]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.515372, 35.467072]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.509363, 35.463053]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.511123, 35.466601]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.518547, 35.469327]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.519706, 35.469659]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.517839, 35.466998]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.508678, 35.464942]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-97.514914, 35.463453]
 *       }
 *     }
 *   ]
 * };
 *
 * var centerPt = turf.center(features);
 * centerPt.properties['marker-size'] = 'large';
 * centerPt.properties['marker-color'] = '#000';
 *
 * var resultFeatures = features.features.concat(centerPt);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (layer) {
    var ext = bbox(layer);
    var x = (ext[0] + ext[2]) / 2;
    var y = (ext[1] + ext[3]) / 2;
    return point([x, y]);
};


/***/ }),

/***/ "./node_modules/turf-centroid/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-centroid/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes one or more features and calculates the centroid using
 * the mean of all vertices.
 * This lessens the effect of small islands and artifacts when calculating
 * the centroid of a set of polygons.
 *
 * @name centroid
 * @param {(Feature|FeatureCollection)} features input features
 * @return {Feature<Point>} the centroid of the input features
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [105.818939,21.004714],
 *       [105.818939,21.061754],
 *       [105.890007,21.061754],
 *       [105.890007,21.004714],
 *       [105.818939,21.004714]
 *     ]]
 *   }
 * };
 *
 * var centroidPt = turf.centroid(poly);
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [poly, centroidPt]
 * };
 *
 * //=result
 */
module.exports = function (features) {
    var xSum = 0, ySum = 0, len = 0;
    each(features, function (coord) {
        xSum += coord[0];
        ySum += coord[1];
        len++;
    }, true);
    return point([xSum / len, ySum / len]);
};


/***/ }),

/***/ "./node_modules/turf-collect/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-collect/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");

/**
 * Joins attributes FeatureCollection of polygons with a FeatureCollection of
 * points. Given an `inProperty` on points and an `outProperty` for polygons,
 * this finds every point that lies within each polygon, collects the `inProperty`
 * values from those points, and adds them as an array to `outProperty` on the
 * polygon.
 *
 * @name collect
 * @param {FeatureCollection<Polygon>} polygons polygons with values on which to aggregate
 * @param {FeatureCollection<Point>} points points to be aggregated
 * @param {string} inProperty property to be nested from
 * @param {string} outProperty property to be nested into
 * @return {FeatureCollection<Polygon>} polygons with properties listed based on `outField`
 * @example
 * var poly1 = polygon([[[0,0],[10,0],[10,10],[0,10],[0,0]]]);
 * var poly2 = polygon([[[10,0],[20,10],[20,20],[20,0],[10,0]]]);
 * var polyFC = featurecollection([poly1, poly2]);
 * var pt1 = point([5,5], {population: 200});
 * var pt2 = point([1,3], {population: 600});
 * var pt3 = point([14,2], {population: 100});
 * var pt4 = point([13,1], {population: 200});
 * var pt5 = point([19,7], {population: 300});
 * var ptFC = featurecollection([pt1, pt2, pt3, pt4, pt5]);
 * var aggregated = aggregate(polyFC, ptFC, 'population', 'values');
 *
 * aggregated.features[0].properties.values // => [200, 600]);
 */
module.exports = function collect(polygons, points, inProperty, outProperty) {
    polygons.features.forEach(function (poly) {
        var values = points.features.filter(function (pt) {
            return inside(pt, poly);
        }).map(function (pt) {
            return pt.properties[inProperty];
        });

        if (!poly.properties) {
            poly.properties = {};
        }

        poly.properties[outProperty] = values;
    });

    return polygons;
};


/***/ }),

/***/ "./node_modules/turf-combine/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-combine/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var meta = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js");

/**
 * Combines a {@link FeatureCollection} of {@link Point},
 * {@link LineString}, or {@link Polygon} features
 * into {@link MultiPoint}, {@link MultiLineString}, or
 * {@link MultiPolygon} features.
 *
 * @name combine
 * @param {FeatureCollection<(Point|LineString|Polygon)>} fc a FeatureCollection of any type
 * @return {FeatureCollection<(MultiPoint|MultiLineString|MultiPolygon)>} a FeatureCollection of corresponding type to input
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.026432, 47.49134]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [19.074497, 47.509548]
 *       }
 *     }
 *   ]
 * };
 *
 * var combined = turf.combine(fc);
 *
 * //=combined
 */

module.exports = function (fc) {
    var groups = {
        MultiPoint: {coordinates: [], properties: []},
        MultiLineString: {coordinates: [], properties: []},
        MultiPolygon: {coordinates: [], properties: []}
    };

    var multiMapping = Object.keys(groups).reduce(function (memo, item) {
        memo[item.replace('Multi', '')] = item;
        return memo;
    }, {});

    function addToGroup(feature, key, multi) {
        if (!multi) {
            groups[key].coordinates.push(feature.geometry.coordinates);
        } else {
            groups[key].coordinates = groups[key].coordinates.concat(feature.geometry.coordinates);
        }
        groups[key].properties.push(feature.properties);
    }

    meta.featureEach(fc, function (feature) {
        if (!feature.geometry) return;
        if (groups[feature.geometry.type]) {
            addToGroup(feature, feature.geometry.type, true);
        } else if (multiMapping[feature.geometry.type]) {
            addToGroup(feature, multiMapping[feature.geometry.type], false);
        }
    });

    return {
        type: 'FeatureCollection',
        features: Object.keys(groups)
            .filter(function (key) {
                return groups[key].coordinates.length;
            })
            .sort()
            .map(function (key) {
                return {
                    type: 'Feature',
                    properties: {
                        collectedProperties: groups[key].properties
                    },
                    geometry: {
                        type: key,
                        coordinates: groups[key].coordinates
                    }
                };
            })
    };
};


/***/ }),

/***/ "./node_modules/turf-concave/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-concave/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// 1. run tin on points
// 2. calculate lenth of all edges and area of all triangles
// 3. remove triangles that fail the max length test
// 4. buffer the results slightly
// 5. merge the results
var tin = __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js");
var union = __webpack_require__(/*! turf-union */ "./node_modules/turf-union/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a set of {@link Point|points} and returns a concave hull polygon.
 *
 * Internally, this uses [turf-tin](https://github.com/Turfjs/turf-tin) to generate geometries.
 *
 * @param {FeatureCollection<Point>} points input points
 * @param {number} maxEdge the size of an edge necessary for part of the
 * hull to become concave (in miles)
 * @param {string} units used for maxEdge distance (miles or kilometers)
 * @returns {Feature<Polygon>} a concave hull
 * @throws {Error} if maxEdge parameter is missing
 * @throws {Error} if units parameter is missing
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.601226, 44.642643]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.591442, 44.651436]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.580799, 44.648749]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.573589, 44.641788]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.587665, 44.64533]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-63.595218, 44.64765]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.concave(points, 1, 'miles');
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
function concave(points, maxEdge, units) {
    if (typeof maxEdge !== 'number') throw new Error('maxEdge parameter is required');
    if (typeof units !== 'string') throw new Error('units parameter is required');

    var tinPolys = tin(points);
    var filteredPolys = tinPolys.features.filter(filterTriangles);
    tinPolys.features = filteredPolys;

    function filterTriangles(triangle) {
        var pt1 = triangle.geometry.coordinates[0][0];
        var pt2 = triangle.geometry.coordinates[0][1];
        var pt3 = triangle.geometry.coordinates[0][2];
        var dist1 = distance(pt1, pt2, units);
        var dist2 = distance(pt2, pt3, units);
        var dist3 = distance(pt1, pt3, units);
        return (dist1 <= maxEdge && dist2 <= maxEdge && dist3 <= maxEdge);
    }

    return merge(tinPolys);
}

function merge(polygons) {
    var merged = JSON.parse(JSON.stringify(polygons.features[0])),
        features = polygons.features;

    for (var i = 0, len = features.length; i < len; i++) {
        var poly = features[i];
        if (poly.geometry) {
            merged = union(merged, poly);
        }
    }
    return merged;
}

module.exports = concave;


/***/ }),

/***/ "./node_modules/turf-convex/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-convex/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach,
    convexHull = __webpack_require__(/*! convex-hull */ "./node_modules/convex-hull/ch.js"),
    polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;

/**
 * Takes a set of {@link Point|points} and returns a
 * [convex hull](http://en.wikipedia.org/wiki/Convex_hull) polygon.
 *
 * Internally this uses
 * the [convex-hull](https://github.com/mikolalysenko/convex-hull) module that
 * implements a [monotone chain hull](http://en.wikibooks.org/wiki/Algorithm_Implementation/Geometry/Convex_hull/Monotone_chain).
 *
 * @name convex
 * @param {FeatureCollection<Point>} featurecollection input points
 * @returns {Feature<Polygon>} a convex hull
 * @example
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.404052, 43.8424511]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.579833, 43.659924]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.360107, 43.516688]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.14038, 43.588348]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [10.195312, 43.755225]
 *       }
 *     }
 *   ]
 * };
 *
 * var hull = turf.convex(points);
 *
 * var resultFeatures = points.features.concat(hull);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (featurecollection) {
    var points = [];
    each(featurecollection, function (coord) { points.push(coord); });
    var hull = convexHull(points);
    if (hull.length > 0) {
        var ring = [];
        for (var i = 0; i < hull.length; i++) {
            ring.push(points[hull[i][0]]);
        }
        ring.push(points[hull[hull.length - 1][1]]);
        return polygon([ring]);
    }
    return undefined;
};


/***/ }),

/***/ "./node_modules/turf-destination/index.js":
/*!************************************************!*\
  !*** ./node_modules/turf-destination/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html
var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");
var point = helpers.point;
var distanceToRadians = helpers.distanceToRadians;

/**
 * Takes a {@link Point} and calculates the location of a destination point given a distance in degrees, radians, miles, or kilometers; and bearing in degrees. This uses the [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula) to account for global curvature.
 *
 * @name destination
 * @param {Feature<Point>} from starting point
 * @param {number} distance distance from the starting point
 * @param {number} bearing ranging from -180 to 180
 * @param {String} [units=kilometers] miles, kilometers, degrees, or radians
 * @returns {Feature<Point>} destination point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var distance = 50;
 * var bearing = 90;
 * var units = 'miles';
 *
 * var destination = turf.destination(point, distance, bearing, units);
 * destination.properties['marker-color'] = '#f00';
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [point, destination]
 * };
 *
 * //=result
 */
module.exports = function (from, distance, bearing, units) {
    var degrees2radians = Math.PI / 180;
    var radians2degrees = 180 / Math.PI;
    var coordinates1 = getCoord(from);
    var longitude1 = degrees2radians * coordinates1[0];
    var latitude1 = degrees2radians * coordinates1[1];
    var bearing_rad = degrees2radians * bearing;

    var radians = distanceToRadians(distance, units);

    var latitude2 = Math.asin(Math.sin(latitude1) * Math.cos(radians) +
        Math.cos(latitude1) * Math.sin(radians) * Math.cos(bearing_rad));
    var longitude2 = longitude1 + Math.atan2(Math.sin(bearing_rad) *
        Math.sin(radians) * Math.cos(latitude1),
        Math.cos(radians) - Math.sin(latitude1) * Math.sin(latitude2));

    return point([radians2degrees * longitude2, radians2degrees * latitude2]);
};


/***/ }),

/***/ "./node_modules/turf-difference/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-difference/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Finds the difference between two {@link Polygon|polygons} by clipping the second
 * polygon from the first.
 *
 * @name difference
 * @param {Feature<Polygon>} poly1 input Polygon feaure
 * @param {Feature<Polygon>} poly2 Polygon feature to difference from `poly1`
 * @return {Feature<Polygon>} a Polygon feature showing the area of `poly1` excluding the area of `poly2`
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.738586, -23.596711],
 *       [-46.738586, -23.458207],
 *       [-46.560058, -23.458207],
 *       [-46.560058, -23.596711],
 *       [-46.738586, -23.596711]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-46.650009, -23.631314],
 *       [-46.650009, -23.5237],
 *       [-46.509246, -23.5237],
 *       [-46.509246, -23.631314],
 *       [-46.650009, -23.631314]
 *     ]]
 *   }
 * };
 *
 * var differenced = turf.difference(poly1, poly2);
 * differenced.properties.fill = '#f00';
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * //=polygons
 *
 * //=differenced
 */

module.exports = function (p1, p2) {
    var poly1 = JSON.parse(JSON.stringify(p1));
    var poly2 = JSON.parse(JSON.stringify(p2));
    if (poly1.type !== 'Feature') {
        poly1 = {
            type: 'Feature',
            properties: {},
            geometry: poly1
        };
    }
    if (poly2.type !== 'Feature') {
        poly2 = {
            type: 'Feature',
            properties: {},
            geometry: poly2
        };
    }

    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(poly1.geometry));
    var b = reader.read(JSON.stringify(poly2.geometry));
    var differenced = a.difference(b);

    if (differenced.isEmpty()) return undefined;

    var writer = new jsts.io.GeoJSONWriter();
    var geojsonGeometry = writer.write(differenced);

    poly1.geometry = differenced;

    return {
        type: 'Feature',
        properties: poly1.properties,
        geometry: geojsonGeometry
    };
};


/***/ }),

/***/ "./node_modules/turf-distance/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-distance/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var getCoord = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js").getCoord;
var radiansToDistance = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").radiansToDistance;
//http://en.wikipedia.org/wiki/Haversine_formula
//http://www.movable-type.co.uk/scripts/latlong.html

/**
 * Calculates the distance between two {@link Point|points} in degrees, radians,
 * miles, or kilometers. This uses the
 * [Haversine formula](http://en.wikipedia.org/wiki/Haversine_formula)
 * to account for global curvature.
 *
 * @name distance
 * @param {Feature<Point>} from origin point
 * @param {Feature<Point>} to destination point
 * @param {String} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Number} distance between the two points
 * @example
 * var from = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.343, 39.984]
 *   }
 * };
 * var to = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.534, 39.123]
 *   }
 * };
 * var units = "miles";
 *
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [from, to]
 * };
 *
 * //=points
 *
 * var distance = turf.distance(from, to, units);
 *
 * //=distance
 */
module.exports = function (from, to, units) {
    var degrees2radians = Math.PI / 180;
    var coordinates1 = getCoord(from);
    var coordinates2 = getCoord(to);
    var dLat = degrees2radians * (coordinates2[1] - coordinates1[1]);
    var dLon = degrees2radians * (coordinates2[0] - coordinates1[0]);
    var lat1 = degrees2radians * coordinates1[1];
    var lat2 = degrees2radians * coordinates2[1];

    var a = Math.pow(Math.sin(dLat / 2), 2) +
          Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);

    return radiansToDistance(2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a)), units);
};


/***/ }),

/***/ "./node_modules/turf-envelope/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-envelope/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js");
var bboxPolygon = __webpack_require__(/*! turf-bbox-polygon */ "./node_modules/turf-bbox-polygon/index.js");

/**
 * Takes any number of features and returns a rectangular {@link Polygon} that encompasses all vertices.
 *
 * @name envelope
 * @param {FeatureCollection} fc input features
 * @return {Feature<Polygon>} a rectangular Polygon feature that encompasses all vertices
 * @example
 * var fc = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location A"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.343, 39.984]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location B"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.833, 39.284]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {
 *         "name": "Location C"
 *       },
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-75.534, 39.123]
 *       }
 *     }
 *   ]
 * };
 *
 * var enveloped = turf.envelope(fc);
 *
 * var resultFeatures = fc.features.concat(enveloped);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

module.exports = function (features) {
    return bboxPolygon(bbox(features));
};


/***/ }),

/***/ "./node_modules/turf-explode/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-explode/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var each = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a feature or set of features and returns all positions as
 * {@link Point|points}.
 *
 * @name explode
 * @param {(Feature|FeatureCollection)} geojson input features
 * @return {FeatureCollection<point>} points representing the exploded input features
 * @throws {Error} if it encounters an unknown geometry type
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [177.434692, -17.77517],
 *       [177.402076, -17.779093],
 *       [177.38079, -17.803937],
 *       [177.40242, -17.826164],
 *       [177.438468, -17.824857],
 *       [177.454948, -17.796746],
 *       [177.434692, -17.77517]
 *     ]]
 *   }
 * };
 *
 * var points = turf.explode(poly);
 *
 * //=poly
 *
 * //=points
 */
module.exports = function (geojson) {
    var points = [];
    each(geojson, function (coord) {
        points.push(point(coord));
    });
    return featureCollection(points);
};


/***/ }),

/***/ "./node_modules/turf-flip/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-flip/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var coordEach = __webpack_require__(/*! turf-meta */ "./node_modules/turf-meta/index.js").coordEach;

/**
 * Takes input features and flips all of their coordinates
 * from `[x, y]` to `[y, x]`.
 *
 * @name flip
 * @param {(Feature|FeatureCollection)} input input features
 * @returns {(Feature|FeatureCollection)} a feature or set of features of the same type as `input` with flipped coordinates
 * @example
 * var serbia = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [20.566406, 43.421008]
 *   }
 * };
 *
 * //=serbia
 *
 * var saudiArabia = turf.flip(serbia);
 *
 * //=saudiArabia
 */
module.exports = function flip(input) {
    // ensure that we don't modify features in-place and changes to the
    // output do not change the previous feature, including changes to nested
    // properties.
    input = JSON.parse(JSON.stringify(input));

    coordEach(input, function (coord) {
        coord.reverse();
    });
    return input;
};


/***/ }),

/***/ "./node_modules/turf-grid/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-grid/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-point */ "./node_modules/turf-point/index.js");

/**
 * Takes a bounding box and a cell depth and returns a {@link FeatureCollection} of {@link Point} features in a grid.
 *
 * @module turf/grid
 * @category interpolation
 * @param {Array<number>} extent extent in [minX, minY, maxX, maxY] order
 * @param {Number} depth how many cells to output
 * @return {FeatureCollection} grid as FeatureCollection with {@link Point} features
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var depth = 10;
 *
 * var grid = turf.grid(extent, depth);
 *
 * //=grid
 */
module.exports = function(extents, depth) {
  var xmin = extents[0];
  var ymin = extents[1];
  var xmax = extents[2];
  var ymax = extents[3];
  var interval = (xmax - xmin) / depth;
  var coords = [];
  var fc = {
    type: 'FeatureCollection',
    features: []
  };

  for (var x=0; x<=depth; x++){
    for (var y=0;y<=depth; y++){
      fc.features.push(point([(x * interval) + xmin, (y * interval) + ymin]));
    }
  }
  return fc;
}


/***/ }),

/***/ "./node_modules/turf-helpers/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-helpers/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Wraps a GeoJSON {@link Geometry} in a GeoJSON {@link Feature}.
 *
 * @name feature
 * @param {Geometry} geometry input geometry
 * @param {Object} properties properties
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var geometry = {
 *      "type": "Point",
 *      "coordinates": [
 *        67.5,
 *        32.84267363195431
 *      ]
 *    }
 *
 * var feature = turf.feature(geometry);
 *
 * //=feature
 */
function feature(geometry, properties) {
    return {
        type: 'Feature',
        properties: properties || {},
        geometry: geometry
    };
}

module.exports.feature = feature;

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @name point
 * @param {number[]} coordinates longitude, latitude position (each in decimal degrees)
 * @param {Object=} properties an Object that is used as the {@link Feature}'s
 * properties
 * @returns {Feature<Point>} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
module.exports.point = function (coordinates, properties) {
    if (!Array.isArray(coordinates)) throw new Error('Coordinates must be an array');
    if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
    return feature({
        type: 'Point',
        coordinates: coordinates.slice()
    }, properties);
};

/**
 * Takes an array of LinearRings and optionally an {@link Object} with properties and returns a {@link Polygon} feature.
 *
 * @name polygon
 * @param {Array<Array<Array<number>>>} coordinates an array of LinearRings
 * @param {Object=} properties a properties object
 * @returns {Feature<Polygon>} a Polygon feature
 * @throws {Error} throw an error if a LinearRing of the polygon has too few positions
 * or if a LinearRing of the Polygon does not have matching Positions at the
 * beginning & end.
 * @example
 * var polygon = turf.polygon([[
 *  [-2.275543, 53.464547],
 *  [-2.275543, 53.489271],
 *  [-2.215118, 53.489271],
 *  [-2.215118, 53.464547],
 *  [-2.275543, 53.464547]
 * ]], { name: 'poly1', population: 400});
 *
 * //=polygon
 */
module.exports.polygon = function (coordinates, properties) {

    if (!coordinates) throw new Error('No coordinates passed');

    for (var i = 0; i < coordinates.length; i++) {
        var ring = coordinates[i];
        if (ring.length < 4) {
            throw new Error('Each LinearRing of a Polygon must have 4 or more Positions.');
        }
        for (var j = 0; j < ring[ring.length - 1].length; j++) {
            if (ring[ring.length - 1][j] !== ring[0][j]) {
                throw new Error('First and last Position are not equivalent.');
            }
        }
    }

    return feature({
        type: 'Polygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link LineString} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name lineString
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<LineString>} a LineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var linestring1 = turf.lineString([
 *	[-21.964416, 64.148203],
 *	[-21.956176, 64.141316],
 *	[-21.93901, 64.135924],
 *	[-21.927337, 64.136673]
 * ]);
 * var linestring2 = turf.lineString([
 *	[-21.929054, 64.127985],
 *	[-21.912918, 64.134726],
 *	[-21.916007, 64.141016],
 * 	[-21.930084, 64.14446]
 * ], {name: 'line 1', distance: 145});
 *
 * //=linestring1
 *
 * //=linestring2
 */
module.exports.lineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'LineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Takes one or more {@link Feature|Features} and creates a {@link FeatureCollection}.
 *
 * @name featureCollection
 * @param {Feature[]} features input features
 * @returns {FeatureCollection} a FeatureCollection of input features
 * @example
 * var features = [
 *  turf.point([-75.343, 39.984], {name: 'Location A'}),
 *  turf.point([-75.833, 39.284], {name: 'Location B'}),
 *  turf.point([-75.534, 39.123], {name: 'Location C'})
 * ];
 *
 * var fc = turf.featureCollection(features);
 *
 * //=fc
 */
module.exports.featureCollection = function (features) {
    return {
        type: 'FeatureCollection',
        features: features
    };
};

/**
 * Creates a {@link Feature<MultiLineString>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiLineString
 * @param {Array<Array<Array<number>>>} coordinates an array of LineStrings
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiLineString>} a MultiLineString feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiLine = turf.multiLineString([[[0,0],[10,10]]]);
 *
 * //=multiLine
 *
 */
module.exports.multiLineString = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiLineString',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<MultiPoint>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPoint
 * @param {Array<Array<number>>} coordinates an array of Positions
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPoint>} a MultiPoint feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPt = turf.multiPoint([[0,0],[10,10]]);
 *
 * //=multiPt
 *
 */
module.exports.multiPoint = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPoint',
        coordinates: coordinates
    }, properties);
};


/**
 * Creates a {@link Feature<MultiPolygon>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name multiPolygon
 * @param {Array<Array<Array<Array<number>>>>} coordinates an array of Polygons
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<MultiPolygon>} a multipolygon feature
 * @throws {Error} if no coordinates are passed
 * @example
 * var multiPoly = turf.multiPolygon([[[[0,0],[0,10],[10,10],[10,0],[0,0]]]);
 *
 * //=multiPoly
 *
 */
module.exports.multiPolygon = function (coordinates, properties) {
    if (!coordinates) {
        throw new Error('No coordinates passed');
    }
    return feature({
        type: 'MultiPolygon',
        coordinates: coordinates
    }, properties);
};

/**
 * Creates a {@link Feature<GeometryCollection>} based on a
 * coordinate array. Properties can be added optionally.
 *
 * @name geometryCollection
 * @param {Array<{Geometry}>} geometries an array of GeoJSON Geometries
 * @param {Object=} properties an Object of key-value pairs to add as properties
 * @returns {Feature<GeometryCollection>} a geometrycollection feature
 * @example
 * var pt = {
 *     "type": "Point",
 *       "coordinates": [100, 0]
 *     };
 * var line = {
 *     "type": "LineString",
 *     "coordinates": [ [101, 0], [102, 1] ]
 *   };
 * var collection = turf.geometrycollection([[0,0],[10,10]]);
 *
 * //=collection
 */
module.exports.geometryCollection = function (geometries, properties) {
    return feature({
        type: 'GeometryCollection',
        geometries: geometries
    }, properties);
};

var factors = {
    miles: 3960,
    nauticalmiles: 3441.145,
    degrees: 57.2957795,
    radians: 1,
    inches: 250905600,
    yards: 6969600,
    meters: 6373000,
    metres: 6373000,
    kilometers: 6373,
    kilometres: 6373
};

/*
 * Convert a distance measurement from radians to a more friendly unit.
 *
 * @name radiansToDistance
 * @param {number} distance in radians across the sphere
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} distance
 */
module.exports.radiansToDistance = function (radians, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return radians * factor;
};

/*
 * Convert a distance measurement from a real-world unit into radians
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} radians
 */
module.exports.distanceToRadians = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return distance / factor;
};

/*
 * Convert a distance measurement from a real-world unit into degrees
 *
 * @name distanceToRadians
 * @param {number} distance in real units
 * @param {string=kilometers} units: one of miles, nauticalmiles, degrees, radians,
 * inches, yards, metres, meters, kilometres, kilometers.
 * @returns {number} degrees
 */
module.exports.distanceToDegrees = function (distance, units) {
    var factor = factors[units || 'kilometers'];
    if (factor === undefined) {
        throw new Error('Invalid unit');
    }
    return (distance / factor) * 57.2958;
};


/***/ }),

/***/ "./node_modules/turf-hex-grid/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-hex-grid/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

//Precompute cosines and sines of angles used in hexagon creation
// for performance gain
var cosines = [];
var sines = [];
for (var i = 0; i < 6; i++) {
    var angle = 2 * Math.PI / 6 * i;
    cosines.push(Math.cos(angle));
    sines.push(Math.sin(angle));
}

/**
 * Takes a bounding box and a cell size in degrees and returns a {@link FeatureCollection} of flat-topped
 * hexagons ({@link Polygon} features) aligned in an "odd-q" vertical grid as
 * described in [Hexagonal Grids](http://www.redblobgames.com/grids/hexagons/).
 *
 * @name hexGrid
 * @param {Array<number>} bbox bounding box in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of cell in specified units
 * @param {string} units used in calculating cellWidth ('miles' or 'kilometers')
 * @param {boolean} triangles whether to return as triangles instead of hexagons
 * @return {FeatureCollection<Polygon>} a hexagonal grid
 * @example
 * var bbox = [-96,31,-84,40];
 * var cellWidth = 50;
 * var units = 'miles';
 *
 * var hexgrid = turf.hexGrid(bbox, cellWidth, units);
 *
 * //=hexgrid
 */
module.exports = function hexGrid(bbox, cellSize, units, triangles) {
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);
    var radius = cellWidth / 2;

    var hex_width = radius * 2;
    var hex_height = Math.sqrt(3) / 2 * cellHeight;

    var box_width = bbox[2] - bbox[0];
    var box_height = bbox[3] - bbox[1];

    var x_interval = 3 / 4 * hex_width;
    var y_interval = hex_height;

    var x_span = box_width / (hex_width - radius / 2);
    var x_count = Math.ceil(x_span);
    if (Math.round(x_span) === x_count) {
        x_count++;
    }

    var x_adjust = ((x_count * x_interval - radius / 2) - box_width) / 2 - radius / 2;

    var y_count = Math.ceil(box_height / hex_height);

    var y_adjust = (box_height - y_count * hex_height) / 2;

    var hasOffsetY = y_count * hex_height - box_height > hex_height / 2;
    if (hasOffsetY) {
        y_adjust -= hex_height / 4;
    }

    var fc = featurecollection([]);
    for (var x = 0; x < x_count; x++) {
        for (var y = 0; y <= y_count; y++) {

            var isOdd = x % 2 === 1;
            if (y === 0 && isOdd) {
                continue;
            }

            if (y === 0 && hasOffsetY) {
                continue;
            }

            var center_x = x * x_interval + bbox[0] - x_adjust;
            var center_y = y * y_interval + bbox[1] + y_adjust;

            if (isOdd) {
                center_y -= hex_height / 2;
            }
            if (triangles) {
                fc.features.push.apply(fc.features, hexTriangles([center_x, center_y], cellWidth / 2, cellHeight / 2));
            } else {
                fc.features.push(hexagon([center_x, center_y], cellWidth / 2, cellHeight / 2));
            }
        }
    }

    return fc;
};

//Center should be [x, y]
function hexagon(center, rx, ry) {
    var vertices = [];
    for (var i = 0; i < 6; i++) {
        var x = center[0] + rx * cosines[i];
        var y = center[1] + ry * sines[i];
        vertices.push([x, y]);
    }
    //first and last vertex must be the same
    vertices.push(vertices[0]);
    return polygon([vertices]);
}

//Center should be [x, y]
function hexTriangles(center, rx, ry) {
    var triangles = [];
    for (var i = 0; i < 6; i++) {
        var vertices = [];
        vertices.push(center);
        vertices.push([
            center[0] + rx * cosines[i],
            center[1] + ry * sines[i]
        ]);
        vertices.push([
            center[0] + rx * cosines[(i + 1) % 6],
            center[1] + ry * sines[(i + 1) % 6]
        ]);
        vertices.push(center);
        triangles.push(polygon([vertices]));
    }
    return triangles;
}


/***/ }),

/***/ "./node_modules/turf-inside/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-inside/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var invariant = __webpack_require__(/*! turf-invariant */ "./node_modules/turf-invariant/index.js");

// http://en.wikipedia.org/wiki/Even%E2%80%93odd_rule
// modified from: https://github.com/substack/point-in-polygon/blob/master/index.js
// which was modified from http://www.ecse.rpi.edu/Homepages/wrf/Research/Short_Notes/pnpoly.html

/**
 * Takes a {@link Point} and a {@link Polygon} or {@link MultiPolygon} and determines if the point resides inside the polygon. The polygon can
 * be convex or concave. The function accounts for holes.
 *
 * @name inside
 * @param {Feature<Point>} point input point
 * @param {Feature<(Polygon|MultiPolygon)>} polygon input polygon or multipolygon
 * @return {Boolean} `true` if the Point is inside the Polygon; `false` if the Point is not inside the Polygon
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#f00"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.467285, 40.75766]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-111.873779, 40.647303]
 *   }
 * };
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-112.074279, 40.52215],
 *       [-112.074279, 40.853293],
 *       [-111.610107, 40.853293],
 *       [-111.610107, 40.52215],
 *       [-112.074279, 40.52215]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, poly]
 * };
 *
 * //=features
 *
 * var isInside1 = turf.inside(pt1, poly);
 * //=isInside1
 *
 * var isInside2 = turf.inside(pt2, poly);
 * //=isInside2
 */
module.exports = function input(point, polygon) {
    var pt = invariant.getCoord(point);
    var polys = polygon.geometry.coordinates;
    // normalize to multipolygon
    if (polygon.geometry.type === 'Polygon') polys = [polys];

    for (var i = 0, insidePoly = false; i < polys.length && !insidePoly; i++) {
        // check if it is in the outer ring first
        if (inRing(pt, polys[i][0])) {
            var inHole = false;
            var k = 1;
            // check for the point in any of the holes
            while (k < polys[i].length && !inHole) {
                if (inRing(pt, polys[i][k])) {
                    inHole = true;
                }
                k++;
            }
            if (!inHole) insidePoly = true;
        }
    }
    return insidePoly;
};

// pt is [x,y] and ring is [[x,y], [x,y],..]
function inRing(pt, ring) {
    var isInside = false;
    for (var i = 0, j = ring.length - 1; i < ring.length; j = i++) {
        var xi = ring[i][0], yi = ring[i][1];
        var xj = ring[j][0], yj = ring[j][1];
        var intersect = ((yi > pt[1]) !== (yj > pt[1])) &&
        (pt[0] < (xj - xi) * (pt[1] - yi) / (yj - yi) + xi);
        if (intersect) isInside = !isInside;
    }
    return isInside;
}


/***/ }),

/***/ "./node_modules/turf-intersect/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-intersect/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html
var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Takes two {@link Polygon|polygons} and finds their intersection. If they share a border, returns the border; if they don't intersect, returns undefined.
 *
 * @name intersect
 * @param {Feature<Polygon>} poly1 the first polygon
 * @param {Feature<Polygon>} poly2 the second polygon
 * @return {(Feature<Polygon>|undefined|Feature<MultiLineString>)} if `poly1` and `poly2` overlap, returns a Polygon feature representing the area they overlap; if `poly1` and `poly2` do not overlap, returns `undefined`; if `poly1` and `poly2` share a border, a MultiLineString of the locations where their borders are shared
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-122.801742, 45.48565],
 *       [-122.801742, 45.60491],
 *       [-122.584762, 45.60491],
 *       [-122.584762, 45.48565],
 *       [-122.801742, 45.48565]
 *     ]]
 *   }
 * }
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-122.520217, 45.535693],
 *       [-122.64038, 45.553967],
 *       [-122.720031, 45.526554],
 *       [-122.669906, 45.507309],
 *       [-122.723464, 45.446643],
 *       [-122.532577, 45.408574],
 *       [-122.487258, 45.477466],
 *       [-122.520217, 45.535693]
 *     ]]
 *   }
 * }
 *
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var intersection = turf.intersect(poly1, poly2);
 *
 * //=polygons
 *
 * //=intersection
 */
module.exports = function intersect(poly1, poly2) {
    var geom1, geom2;
    if (poly1.type === 'Feature') geom1 = poly1.geometry;
    else geom1 = poly1;
    if (poly2.type === 'Feature') geom2 = poly2.geometry;
    else geom2 = poly2;
    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(geom1));
    var b = reader.read(JSON.stringify(geom2));
    var intersection = a.intersection(b);

    if (intersection.isEmpty()) {
        return undefined;
    }

    var writer = new jsts.io.GeoJSONWriter();

    var geojsonGeometry = writer.write(intersection);
    return {
        type: 'Feature',
        properties: {},
        geometry: geojsonGeometry
    };
};


/***/ }),

/***/ "./node_modules/turf-invariant/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-invariant/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Unwrap a coordinate from a Feature with a Point geometry, a Point
 * geometry, or a single coordinate.
 *
 * @param {*} obj any value
 * @returns {Array<number>} a coordinate
 */
function getCoord(obj) {
    if (Array.isArray(obj) &&
        typeof obj[0] === 'number' &&
        typeof obj[1] === 'number') {
        return obj;
    } else if (obj) {
        if (obj.type === 'Feature' &&
            obj.geometry &&
            obj.geometry.type === 'Point' &&
            Array.isArray(obj.geometry.coordinates)) {
            return obj.geometry.coordinates;
        } else if (obj.type === 'Point' &&
            Array.isArray(obj.coordinates)) {
            return obj.coordinates;
        }
    }
    throw new Error('A coordinate, feature, or point geometry is required');
}

/**
 * Enforce expectations about types of GeoJSON objects for Turf.
 *
 * @alias geojsonType
 * @param {GeoJSON} value any GeoJSON object
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function geojsonType(value, type, name) {
    if (!type || !name) throw new Error('type and name required');

    if (!value || value.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + value.type);
    }
}

/**
 * Enforce expectations about types of {@link Feature} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias featureOf
 * @param {Feature} feature a feature with an expected geometry type
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} error if value is not the expected type.
 */
function featureOf(feature, type, name) {
    if (!name) throw new Error('.featureOf() requires a name');
    if (!feature || feature.type !== 'Feature' || !feature.geometry) {
        throw new Error('Invalid input to ' + name + ', Feature with geometry required');
    }
    if (!feature.geometry || feature.geometry.type !== type) {
        throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
    }
}

/**
 * Enforce expectations about types of {@link FeatureCollection} inputs for Turf.
 * Internally this uses {@link geojsonType} to judge geometry types.
 *
 * @alias collectionOf
 * @param {FeatureCollection} featurecollection a featurecollection for which features will be judged
 * @param {string} type expected GeoJSON type
 * @param {string} name name of calling function
 * @throws {Error} if value is not the expected type.
 */
function collectionOf(featurecollection, type, name) {
    if (!name) throw new Error('.collectionOf() requires a name');
    if (!featurecollection || featurecollection.type !== 'FeatureCollection') {
        throw new Error('Invalid input to ' + name + ', FeatureCollection required');
    }
    for (var i = 0; i < featurecollection.features.length; i++) {
        var feature = featurecollection.features[i];
        if (!feature || feature.type !== 'Feature' || !feature.geometry) {
            throw new Error('Invalid input to ' + name + ', Feature with geometry required');
        }
        if (!feature.geometry || feature.geometry.type !== type) {
            throw new Error('Invalid input to ' + name + ': must be a ' + type + ', given ' + feature.geometry.type);
        }
    }
}

module.exports.geojsonType = geojsonType;
module.exports.collectionOf = collectionOf;
module.exports.featureOf = featureOf;
module.exports.getCoord = getCoord;


/***/ }),

/***/ "./node_modules/turf-isolines/conrec.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-isolines/conrec.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/* eslint-disable */

/*
 * Copyright (c) 2010, Jason Davies.
 *
 * All rights reserved.  This code is based on Bradley White's Java version,
 * which is in turn based on Nicholas Yue's C++ version, which in turn is based
 * on Paul D. Bourke's original Fortran version.  See below for the respective
 * copyright notices.
 *
 * See http://local.wasp.uwa.edu.au/~pbourke/papers/conrec/ for the original
 * paper by Paul D. Bourke.
 *
 * The vector conversion code is based on http://apptree.net/conrec.htm by
 * Graham Cox.
 *
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in the
 *       documentation and/or other materials provided with the distribution.
 *     * Neither the name of the <organization> nor the
 *       names of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL <COPYRIGHT HOLDER> BE LIABLE FOR ANY
 * DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES
 * (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;
 * LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND
 * ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 * THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

/*
 * Copyright (c) 1996-1997 Nicholas Yue
 *
 * This software is copyrighted by Nicholas Yue. This code is based on Paul D.
 * Bourke's CONREC.F routine.
 *
 * The authors hereby grant permission to use, copy, and distribute this
 * software and its documentation for any purpose, provided that existing
 * copyright notices are retained in all copies and that this notice is
 * included verbatim in any distributions. Additionally, the authors grant
 * permission to modify this software and its documentation for any purpose,
 * provided that such modifications are not distributed without the explicit
 * consent of the authors and that existing copyright notices are retained in
 * all copies. Some of the algorithms implemented by this software are
 * patented, observe all applicable patent law.
 *
 * IN NO EVENT SHALL THE AUTHORS OR DISTRIBUTORS BE LIABLE TO ANY PARTY FOR
 * DIRECT, INDIRECT, SPECIAL, INCIDENTAL, OR CONSEQUENTIAL DAMAGES ARISING OUT
 * OF THE USE OF THIS SOFTWARE, ITS DOCUMENTATION, OR ANY DERIVATIVES THEREOF,
 * EVEN IF THE AUTHORS HAVE BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 *
 * THE AUTHORS AND DISTRIBUTORS SPECIFICALLY DISCLAIM ANY WARRANTIES,
 * INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT.  THIS SOFTWARE IS
 * PROVIDED ON AN "AS IS" BASIS, AND THE AUTHORS AND DISTRIBUTORS HAVE NO
 * OBLIGATION TO PROVIDE MAINTENANCE, SUPPORT, UPDATES, ENHANCEMENTS, OR
 * MODIFICATIONS.
 */


  module.exports = Conrec;

  var EPSILON = 1e-10;

  function pointsEqual(a, b) {
      var x = a.x - b.x, y = a.y - b.y;
      return x * x + y * y < EPSILON;
  }

  function reverseList(list) {
      var pp = list.head;

      while (pp) {
      // swap prev/next pointers
          var temp = pp.next;
          pp.next = pp.prev;
          pp.prev = temp;

      // continue through the list
          pp = temp;
      }

    // swap head/tail pointers
      var temp = list.head;
      list.head = list.tail;
      list.tail = temp;
  }

  function ContourBuilder(level) {
      this.level = level;
      this.s = null;
      this.count = 0;
  }
  ContourBuilder.prototype.remove_seq = function (list) {
    // if list is the first item, static ptr s is updated
      if (list.prev) {
          list.prev.next = list.next;
      } else {
          this.s = list.next;
      }

      if (list.next) {
          list.next.prev = list.prev;
      }
      --this.count;
  };
  ContourBuilder.prototype.addSegment = function (a, b) {
      var ss = this.s;
      var ma = null;
      var mb = null;
      var prependA = false;
      var prependB = false;

      while (ss) {
          if (ma == null) {
        // no match for a yet
              if (pointsEqual(a, ss.head.p)) {
                  ma = ss;
                  prependA = true;
              } else if (pointsEqual(a, ss.tail.p)) {
                  ma = ss;
              }
          }
          if (mb == null) {
        // no match for b yet
              if (pointsEqual(b, ss.head.p)) {
                  mb = ss;
                  prependB = true;
              } else if (pointsEqual(b, ss.tail.p)) {
                  mb = ss;
              }
          }
      // if we matched both no need to continue searching
          if (mb != null && ma != null) {
              break;
          } else {
              ss = ss.next;
          }
      }

    // c is the case selector based on which of ma and/or mb are set
      var c = ((ma != null) ? 1 : 0) | ((mb != null) ? 2 : 0);

      switch (c) {
      case 0:   // both unmatched, add as new sequence
          var aa = {p: a, prev: null};
          var bb = {p: b, next: null};
          aa.next = bb;
          bb.prev = aa;

        // create sequence element and push onto head of main list. The order
        // of items in this list is unimportant
          ma = {head: aa, tail: bb, next: this.s, prev: null, closed: false};
          if (this.s) {
              this.s.prev = ma;
          }
          this.s = ma;

          ++this.count;    // not essential - tracks number of unmerged sequences
          break;

      case 1:   // a matched, b did not - thus b extends sequence ma
          var pp = {p: b};

          if (prependA) {
              pp.next = ma.head;
              pp.prev = null;
              ma.head.prev = pp;
              ma.head = pp;
          } else {
              pp.next = null;
              pp.prev = ma.tail;
              ma.tail.next = pp;
              ma.tail = pp;
          }
          break;

      case 2:   // b matched, a did not - thus a extends sequence mb
          var pp = {p: a};

          if (prependB) {
              pp.next = mb.head;
              pp.prev = null;
              mb.head.prev = pp;
              mb.head = pp;
          } else {
              pp.next = null;
              pp.prev = mb.tail;
              mb.tail.next = pp;
              mb.tail = pp;
          }
          break;

      case 3:   // both matched, can merge sequences
        // if the sequences are the same, do nothing, as we are simply closing this path (could set a flag)

          if (ma === mb) {
              var pp = {p: ma.tail.p, next: ma.head, prev: null};
              ma.head.prev = pp;
              ma.head = pp;
              ma.closed = true;
              break;
          }

        // there are 4 ways the sequence pair can be joined. The current setting of prependA and
        // prependB will tell us which type of join is needed. For head/head and tail/tail joins
        // one sequence needs to be reversed
          switch ((prependA ? 1 : 0) | (prependB ? 2 : 0)) {
          case 0:   // tail-tail
            // reverse ma and append to mb
              reverseList(ma);
            // fall through to head/tail case
          case 1:   // head-tail
            // ma is appended to mb and ma discarded
              mb.tail.next = ma.head;
              ma.head.prev = mb.tail;
              mb.tail = ma.tail;

            //discard ma sequence record
              this.remove_seq(ma);
              break;

          case 3:   // head-head
            // reverse ma and append mb to it
              reverseList(ma);
            // fall through to tail/head case
          case 2:   // tail-head
            // mb is appended to ma and mb is discarded
              ma.tail.next = mb.head;
              mb.head.prev = ma.tail;
              ma.tail = mb.tail;

            //discard mb sequence record
              this.remove_seq(mb);
              break;
          }
      }
  };

  /*
   * Implements CONREC.
   *
   * @private
   * @param {function} drawContour function for drawing contour.  Defaults to a
   *                               custom "contour builder", which populates the
   *                               contours property.
   */
  function Conrec(drawContour) {
      if (!drawContour) {
          var c = this;
          c.contours = {};
      /**
       * drawContour - interface for implementing the user supplied method to
       * render the countours.
       *
       * Draws a line between the start and end coordinates.
       *
       * @private
       * @param startX    - start coordinate for X
       * @param startY    - start coordinate for Y
       * @param endX      - end coordinate for X
       * @param endY      - end coordinate for Y
       * @param contourLevel - Contour level for line.
       */
          this.drawContour = function (startX, startY, endX, endY, contourLevel, k) {
              var cb = c.contours[k];
              if (!cb) {
                  cb = c.contours[k] = new ContourBuilder(contourLevel);
              }
              cb.addSegment({x: startX, y: startY}, {x: endX, y: endY});
          };
          this.contourList = function () {
              var l = [];
              var a = c.contours;
              for (var k in a) {
                  var s = a[k].s;
                  var level = a[k].level;
                  while (s) {
                      var h = s.head;
                      var l2 = [];
                      l2.level = level;
                      l2.k = k;
                      while (h && h.p) {
                          l2.push(h.p);
                          h = h.next;
                      }
                      l.push(l2);
                      s = s.next;
                  }
              }
              l.sort(function (a, b) { return a.k - b.k; });
              return l;
          };
      } else {
          this.drawContour = drawContour;
      }
      this.h  = new Array(5);
      this.sh = new Array(5);
      this.xh = new Array(5);
      this.yh = new Array(5);
  }

  /*
   * contour is a contouring subroutine for rectangularily spaced data
   *
   * It emits calls to a line drawing subroutine supplied by the user which
   * draws a contour map corresponding to real*4data on a randomly spaced
   * rectangular grid. The coordinates emitted are in the same units given in
   * the x() and y() arrays.
   *
   * Any number of contour levels may be specified but they must be in order of
   * increasing value.
   *
   *
   * @param {number[][]} d - matrix of data to contour
   * @param {number} ilb,iub,jlb,jub - index bounds of data matrix
   *
   *             The following two, one dimensional arrays (x and y) contain
   *             the horizontal and vertical coordinates of each sample points.
   * @param {number[]} x  - data matrix column coordinates
   * @param {number[]} y  - data matrix row coordinates
   * @param {number} nc   - number of contour levels
   * @param {number[]} z  - contour levels in increasing order.
   */
  Conrec.prototype.contour = function (d, ilb, iub, jlb, jub, x, y, nc, z) {
      var h = this.h, sh = this.sh, xh = this.xh, yh = this.yh;
      var drawContour = this.drawContour;
      this.contours = {};

      var xsect = function (p1, p2) {
          return (h[p2] * xh[p1] - h[p1] * xh[p2]) / (h[p2] - h[p1]);
      };

      var ysect = function (p1, p2) {
          return (h[p2] * yh[p1] - h[p1] * yh[p2]) / (h[p2] - h[p1]);
      };
      var m1;
      var m2;
      var m3;
      var case_value;
      var dmin;
      var dmax;
      var x1 = 0.0;
      var x2 = 0.0;
      var y1 = 0.0;
      var y2 = 0.0;

    // The indexing of im and jm should be noted as it has to start from zero
    // unlike the fortran counter part
      var im = [0, 1, 1, 0];
      var jm = [0, 0, 1, 1];

    // Note that castab is arranged differently from the FORTRAN code because
    // Fortran and C/C++ arrays are transposed of each other, in this case
    // it is more tricky as castab is in 3 dimensions
      var castab = [
          [
        [0, 0, 8], [0, 2, 5], [7, 6, 9]
          ],
          [
        [0, 3, 4], [1, 3, 1], [4, 3, 0]
          ],
          [
        [9, 6, 7], [5, 2, 0], [8, 0, 0]
          ]
      ];

      for (var j = (jub - 1); j >= jlb; j--) {
          for (var i = ilb; i <= iub - 1; i++) {
              var temp1, temp2;
              temp1 = Math.min(d[i][j], d[i][j + 1]);
              temp2 = Math.min(d[i + 1][j], d[i + 1][j + 1]);
              dmin  = Math.min(temp1, temp2);
              temp1 = Math.max(d[i][j], d[i][j + 1]);
              temp2 = Math.max(d[i + 1][j], d[i + 1][j + 1]);
              dmax  = Math.max(temp1, temp2);

              if (dmax >= z[0] && dmin <= z[nc - 1]) {
                  for (var k = 0; k < nc; k++) {
                      if (z[k] >= dmin && z[k] <= dmax) {
                          for (var m = 4; m >= 0; m--) {
                            if (m > 0) {
                  // The indexing of im and jm should be noted as it has to
                  // start from zero
                              h[m] = d[i + im[m - 1]][j + jm[m - 1]] - z[k];
                              xh[m] = x[i + im[m - 1]];
                              yh[m] = y[j + jm[m - 1]];
                          } else {
                              h[0] = 0.25 * (h[1] + h[2] + h[3] + h[4]);
                              xh[0] = 0.5 * (x[i] + x[i + 1]);
                              yh[0] = 0.5 * (y[j] + y[j + 1]);
                          }
                            if (h[m] > EPSILON) {
                              sh[m] = 1;
                          } else if (h[m] < -EPSILON) {
                            sh[m] = -1;
                        } else
                  sh[m] = 0;
                        }
              //
              // Note: at this stage the relative heights of the corners and the
              // centre are in the h array, and the corresponding coordinates are
              // in the xh and yh arrays. The centre of the box is indexed by 0
              // and the 4 corners by 1 to 4 as shown below.
              // Each triangle is then indexed by the parameter m, and the 3
              // vertices of each triangle are indexed by parameters m1,m2,and
              // m3.
              // It is assumed that the centre of the box is always vertex 2
              // though this isimportant only when all 3 vertices lie exactly on
              // the same contour level, in which case only the side of the box
              // is drawn.
              //
              //
              //      vertex 4 +-------------------+ vertex 3
              //               | \               / |
              //               |   \    m-3    /   |
              //               |     \       /     |
              //               |       \   /       |
              //               |  m=2    X   m=2   |       the centre is vertex 0
              //               |       /   \       |
              //               |     /       \     |
              //               |   /    m=1    \   |
              //               | /               \ |
              //      vertex 1 +-------------------+ vertex 2
              //
              //
              //
              //               Scan each triangle in the box
              //
                          for (m = 1; m <= 4; m++) {
                            m1 = m;
                            m2 = 0;
                            if (m != 4) {
                              m3 = m + 1;
                          } else {
                              m3 = 1;
                          }
                            case_value = castab[sh[m1] + 1][sh[m2] + 1][sh[m3] + 1];
                            if (case_value != 0) {
                              switch (case_value) {
                            case 1: // Line between vertices 1 and 2
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xh[m2];
                                y2 = yh[m2];
                                break;
                            case 2: // Line between vertices 2 and 3
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xh[m3];
                                y2 = yh[m3];
                                break;
                            case 3: // Line between vertices 3 and 1
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xh[m1];
                                y2 = yh[m1];
                                break;
                            case 4: // Line between vertex 1 and side 2-3
                                x1 = xh[m1];
                                y1 = yh[m1];
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 5: // Line between vertex 2 and side 3-1
                                x1 = xh[m2];
                                y1 = yh[m2];
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 6: //  Line between vertex 3 and side 1-2
                                x1 = xh[m3];
                                y1 = yh[m3];
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            case 7: // Line between sides 1-2 and 2-3
                                x1 = xsect(m1, m2);
                                y1 = ysect(m1, m2);
                                x2 = xsect(m2, m3);
                                y2 = ysect(m2, m3);
                                break;
                            case 8: // Line between sides 2-3 and 3-1
                                x1 = xsect(m2, m3);
                                y1 = ysect(m2, m3);
                                x2 = xsect(m3, m1);
                                y2 = ysect(m3, m1);
                                break;
                            case 9: // Line between sides 3-1 and 1-2
                                x1 = xsect(m3, m1);
                                y1 = ysect(m3, m1);
                                x2 = xsect(m1, m2);
                                y2 = ysect(m1, m2);
                                break;
                            default:
                                break;
                            }
                  // Put your processing code here and comment out the printf
                  //printf("%f %f %f %f %f\n",x1,y1,x2,y2,z[k]);
                              drawContour(x1, y1, x2, y2, z[k], k);
                          }
                        }
                      }
                  }
              }
          }
      }
  };


/***/ }),

/***/ "./node_modules/turf-isolines/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-isolines/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//https://github.com/jasondavies/conrec.js
//http://stackoverflow.com/questions/263305/drawing-a-topographical-map
var tin = __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js");
var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var grid = __webpack_require__(/*! turf-grid */ "./node_modules/turf-grid/index.js");
var bbox = __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js");
var planepoint = __webpack_require__(/*! turf-planepoint */ "./node_modules/turf-planepoint/index.js");
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var square = __webpack_require__(/*! turf-square */ "./node_modules/turf-square/index.js");
var Conrec = __webpack_require__(/*! ./conrec */ "./node_modules/turf-isolines/conrec.js");

/**
 * Takes {@link Point|points} with z-values and an array of
 * value breaks and generates [isolines](http://en.wikipedia.org/wiki/Isoline).
 *
 * @name isolines
 * @param {FeatureCollection<Point>} points input points
 * @param {string} z the property name in `points` from which z-values will be pulled
 * @param {number} resolution resolution of the underlying grid
 * @param {Array<number>} breaks where to draw contours
 * @returns {FeatureCollection<LineString>} isolines
 * @example
 * // create random points with random
 * // z-values in their properties
 * var points = turf.random('point', 100, {
 *   bbox: [0, 30, 20, 50]
 * });
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = Math.random() * 10;
 * }
 * var breaks = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10];
 * var isolined = turf.isolines(points, 'z', 15, breaks);
 * //=isolined
 */
module.exports = function (points, z, resolution, breaks) {
    var tinResult = tin(points, z);
    var bboxBBox = bbox(points);
    var squareBBox = square(bboxBBox);
    var gridResult = grid(squareBBox, resolution);
    var data = [];

    for (var i = 0; i < gridResult.features.length; i++) {
        var pt = gridResult.features[i];
        for (var j = 0; j < tinResult.features.length; j++) {
            var triangle = tinResult.features[j];
            if (inside(pt, triangle)) {
                pt.properties = {};
                pt.properties[z] = planepoint(pt, triangle);
            }
        }
    }

    var depth = Math.sqrt(gridResult.features.length);
    for (var x = 0; x < depth; x++) {
        var xGroup = gridResult.features.slice(x * depth, (x + 1) * depth);
        var xFlat = [];

        for (var g = 0; g < xGroup.length; g++) {
            if (xGroup[g].properties) {
                xFlat.push(xGroup[g].properties[z]);
            } else {
                xFlat.push(0);
            }
        }
        data.push(xFlat);
    }
    var interval = (squareBBox[2] - squareBBox[0]) / depth;
    var xCoordinates = [];
    var yCoordinates = [];
    for (var d = 0; d < depth; d++) {
        xCoordinates.push(d * interval + squareBBox[0]);
        yCoordinates.push(d * interval + squareBBox[1]);
    }

    var c = new Conrec();
    c.contour(data, 0, resolution, 0, resolution, xCoordinates, yCoordinates, breaks.length, breaks);
    var contourList = c.contourList();

    var fc = featurecollection([]);
    contourList.forEach(function (c) {
        if (c.length > 2) {
            var polyCoordinates = [];
            c.forEach(function (coord) {
                polyCoordinates.push([coord.x, coord.y]);
            });
            var poly = linestring(polyCoordinates);
            poly.properties = {};
            poly.properties[z] = c.level;

            fc.features.push(poly);
        }
    });

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-kinks/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-kinks/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/**
 * Takes a {@link Polygon|polygon} and returns {@link Point|points} at all self-intersections.
 *
 * @name kinks
 * @param {Feature<Polygon>|Polygon} polygon input polygon
 * @returns {FeatureCollection<Point>} self-intersections
 * @example
 * var poly = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-12.034835, 8.901183],
 *       [-12.060413, 8.899826],
 *       [-12.03638, 8.873199],
 *       [-12.059383, 8.871418],
 *       [-12.034835, 8.901183]
 *     ]]
 *   }
 * };
 *
 * var kinks = turf.kinks(poly);
 *
 * var resultFeatures = kinks.intersections.features.concat(poly);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

module.exports = function (polyIn) {
    var poly;
    var results = {
        type: 'FeatureCollection',
        features: []
    };
    if (polyIn.type === 'Feature') {
        poly = polyIn.geometry;
    } else {
        poly = polyIn;
    }
    poly.coordinates.forEach(function (ring1) {
        poly.coordinates.forEach(function (ring2) {
            for (var i = 0; i < ring1.length - 1; i++) {
                for (var k = 0; k < ring2.length - 1; k++) {
                    // don't check adjacent sides of a given ring, since of course they intersect in a vertex.
                    if (ring1 === ring2 && (Math.abs(i - k) === 1 || Math.abs(i - k) === ring1.length - 2)) {
                        continue;
                    }

                    var intersection = lineIntersects(ring1[i][0], ring1[i][1], ring1[i + 1][0], ring1[i + 1][1],
                        ring2[k][0], ring2[k][1], ring2[k + 1][0], ring2[k + 1][1]);
                    if (intersection) {
                        results.features.push(point([intersection[0], intersection[1]]));
                    }
                }
            }
        });
    });
    return results;
};


// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2,
        result = {
            x: null,
            y: null,
            onLine1: false,
            onLine2: false
        };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a >= 0 && a <= 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b >= 0 && b <= 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/turf-line-distance/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-line-distance/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;

/**
 * Takes a {@link LineString|line} and measures its length in the specified units.
 *
 * @name lineDistance
 * @param {Feature<LineString>} line line to measure
 * @param {String} [units=kilometers] can be degrees, radians, miles, or kilometers
 * @return {Number} length of the input line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 *
 * var length = turf.lineDistance(line, 'miles');
 *
 * //=line
 *
 * //=length
 */
module.exports = function lineDistance(line, units) {
    if (line.type === 'FeatureCollection') {
        return line.features.reduce(function (memo, feature) {
            return memo + lineDistance(feature, units);
        }, 0);
    }

    var geometry = line.type === 'Feature' ? line.geometry : line;
    var d, i;

    if (geometry.type === 'LineString') {
        return length(geometry.coordinates, units);
    } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
        d = 0;
        for (i = 0; i < geometry.coordinates.length; i++) {
            d += length(geometry.coordinates[i], units);
        }
        return d;
    } else if (line.type === 'MultiPolygon') {
        d = 0;
        for (i = 0; i < geometry.coordinates.length; i++) {
            for (var j = 0; j < geometry.coordinates[i].length; j++) {
                d += length(geometry.coordinates[i][j], units);
            }
        }
        return d;
    } else {
        throw new Error('input must be a LineString, MultiLineString, ' +
            'Polygon, or MultiPolygon Feature or Geometry (or a FeatureCollection ' +
            'containing only those types)');
    }

};

function length(coords, units) {
    var travelled = 0;
    var prevCoords = point(coords[0]);
    var curCoords = point(coords[0]);
    var temp;
    for (var i = 1; i < coords.length; i++) {
        curCoords.geometry.coordinates = coords[i];
        travelled += distance(prevCoords, curCoords, units);
        temp = prevCoords;
        prevCoords = curCoords;
        curCoords = temp;
    }
    return travelled;
}


/***/ }),

/***/ "./node_modules/turf-line-slice/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-line-slice/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var linestring = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").lineString;
var pointOnLine = __webpack_require__(/*! turf-point-on-line */ "./node_modules/turf-point-on-line/index.js");

/**
 * Takes a {@link LineString|line}, a start {@link Point}, and a stop point
 * and returns a subsection of the line in-between those points.
 * The start & stop points don't need to fall exactly on the line.
 *
 * This can be useful for extracting only the part of a route between waypoints.
 *
 * @name lineSlice
 * @param {Feature<Point>} point1 starting point
 * @param {Feature<Point>} point2 stopping point
 * @param {Feature<LineString>|LineString} line line to slice
 * @return {Feature<LineString>} sliced line
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var start = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.029609, 38.881946]
 *   }
 * };
 * var stop = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.021884, 38.889563]
 *   }
 * };
 *
 * var sliced = turf.lineSlice(start, stop, line);
 *
 * //=line
 *
 * //=sliced
 */

module.exports = function lineSlice(startPt, stopPt, line) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    var startVertex = pointOnLine(line, startPt);
    var stopVertex = pointOnLine(line, stopPt);
    var ends;
    if (startVertex.properties.index <= stopVertex.properties.index) {
        ends = [startVertex, stopVertex];
    } else {
        ends = [stopVertex, startVertex];
    }
    var clipLine = linestring([ends[0].geometry.coordinates], {});
    for (var i = ends[0].properties.index + 1; i < ends[1].properties.index + 1; i++) {
        clipLine.geometry.coordinates.push(coords[i]);
    }
    clipLine.geometry.coordinates.push(ends[1].geometry.coordinates);
    return clipLine;
};


/***/ }),

/***/ "./node_modules/turf-meta/index.js":
/*!*****************************************!*\
  !*** ./node_modules/turf-meta/index.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Iterate over coordinates in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @example
 * var point = { type: 'Point', coordinates: [0, 0] };
 * coordEach(point, function(coords) {
 *   // coords is equal to [0, 0]
 * });
 */
function coordEach(layer, callback, excludeWrapCoord) {
    var i, j, k, g, l, geometry, stopG, coords,
        geometryMaybeCollection,
        wrapShrink = 0,
        isGeometryCollection,
        isFeatureCollection = layer.type === 'FeatureCollection',
        isFeature = layer.type === 'Feature',
        stop = isFeatureCollection ? layer.features.length : 1;

  // This logic may look a little weird. The reason why it is that way
  // is because it's trying to be fast. GeoJSON supports multiple kinds
  // of objects at its root: FeatureCollection, Features, Geometries.
  // This function has the responsibility of handling all of them, and that
  // means that some of the `for` loops you see below actually just don't apply
  // to certain inputs. For instance, if you give this just a
  // Point geometry, then both loops are short-circuited and all we do
  // is gradually rename the input until it's called 'geometry'.
  //
  // This also aims to allocate as few resources as possible: just a
  // few numbers and booleans, rather than any temporary arrays as would
  // be required with the normalization approach.
    for (i = 0; i < stop; i++) {

        geometryMaybeCollection = (isFeatureCollection ? layer.features[i].geometry :
        (isFeature ? layer.geometry : layer));
        isGeometryCollection = geometryMaybeCollection.type === 'GeometryCollection';
        stopG = isGeometryCollection ? geometryMaybeCollection.geometries.length : 1;

        for (g = 0; g < stopG; g++) {
            geometry = isGeometryCollection ?
            geometryMaybeCollection.geometries[g] : geometryMaybeCollection;
            coords = geometry.coordinates;

            wrapShrink = (excludeWrapCoord &&
                (geometry.type === 'Polygon' || geometry.type === 'MultiPolygon')) ?
                1 : 0;

            if (geometry.type === 'Point') {
                callback(coords);
            } else if (geometry.type === 'LineString' || geometry.type === 'MultiPoint') {
                for (j = 0; j < coords.length; j++) callback(coords[j]);
            } else if (geometry.type === 'Polygon' || geometry.type === 'MultiLineString') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length - wrapShrink; k++)
                        callback(coords[j][k]);
            } else if (geometry.type === 'MultiPolygon') {
                for (j = 0; j < coords.length; j++)
                    for (k = 0; k < coords[j].length; k++)
                        for (l = 0; l < coords[j][k].length - wrapShrink; l++)
                            callback(coords[j][k][l]);
            } else {
                throw new Error('Unknown Geometry Type');
            }
        }
    }
}
module.exports.coordEach = coordEach;

/**
 * Reduce coordinates in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all coordinates is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, value) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @param {boolean=} excludeWrapCoord whether or not to include
 * the final coordinate of LinearRings that wraps the ring in its iteration.
 * @return {*} combined value
 */
function coordReduce(layer, callback, memo, excludeWrapCoord) {
    coordEach(layer, function (coord) {
        memo = callback(memo, coord);
    }, excludeWrapCoord);
    return memo;
}
module.exports.coordReduce = coordReduce;

/**
 * Iterate over property objects in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var point = { type: 'Feature', geometry: null, properties: { foo: 1 } };
 * propEach(point, function(props) {
 *   // props is equal to { foo: 1}
 * });
 */
function propEach(layer, callback) {
    var i;
    switch (layer.type) {
    case 'FeatureCollection':
        for (i = 0; i < layer.features.length; i++) {
            callback(layer.features[i].properties);
        }
        break;
    case 'Feature':
        callback(layer.properties);
        break;
    }
}
module.exports.propEach = propEach;

/**
 * Reduce properties in any GeoJSON object into a single value,
 * similar to how Array.reduce works. However, in this case we lazily run
 * the reduction, so an array of all properties is unnecessary.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (memo, coord) and returns
 * a new memo
 * @param {*} memo the starting value of memo: can be any type.
 * @return {*} combined value
 */
function propReduce(layer, callback, memo) {
    propEach(layer, function (prop) {
        memo = callback(memo, prop);
    });
    return memo;
}
module.exports.propReduce = propReduce;

/**
 * Iterate over features in any GeoJSON object, similar to
 * Array.forEach.
 *
 * @param {Object} layer any GeoJSON object
 * @param {Function} callback a method that takes (value)
 * @example
 * var feature = { type: 'Feature', geometry: null, properties: {} };
 * featureEach(feature, function(feature) {
 *   // feature == feature
 * });
 */
function featureEach(layer, callback) {
    if (layer.type === 'Feature') {
        callback(layer);
    } else if (layer.type === 'FeatureCollection') {
        for (var i = 0; i < layer.features.length; i++) {
            callback(layer.features[i]);
        }
    }
}
module.exports.featureEach = featureEach;

/**
 * Get all coordinates from any GeoJSON object, returning an array of coordinate
 * arrays.
 * @param {Object} layer any GeoJSON object
 * @return {Array<Array<Number>>} coordinate position array
 */
function coordAll(layer) {
    var coords = [];
    coordEach(layer, function (coord) {
        coords.push(coord);
    });
    return coords;
}
module.exports.coordAll = coordAll;


/***/ }),

/***/ "./node_modules/turf-midpoint/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-midpoint/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes two {@link Point|points} and returns a point midway between them.
 * The midpoint is calculated geodesically, meaning the curvature of the earth is taken into account.
 *
 * @name midpoint
 * @param {Feature<Point>} from first point
 * @param {Feature<Point>} to second point
 * @return {Feature<Point>} a point midway between `pt1` and `pt2`
 * @example
 * var pt1 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [144.834823, -37.771257]
 *   }
 * };
 * var pt2 = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [145.14244, -37.830937]
 *   }
 * };
 *
 * var midpointed = turf.midpoint(pt1, pt2);
 * midpointed.properties['marker-color'] = '#f00';
 *
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [pt1, pt2, midpointed]
 * };
 *
 * //=result
 */
module.exports = function (from, to) {
    var dist = distance(from, to, 'miles');
    var heading = bearing(from, to);
    var midpoint = destination(from, dist / 2, heading, 'miles');

    return midpoint;
};


/***/ }),

/***/ "./node_modules/turf-nearest/index.js":
/*!********************************************!*\
  !*** ./node_modules/turf-nearest/index.js ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a reference {@link Point|point} and a FeatureCollection of Features
 * with Point geometries and returns the
 * point from the FeatureCollection closest to the reference. This calculation
 * is geodesic.
 *
 * @name nearest
 * @param {Feature<Point>} targetPoint the reference point
 * @param {FeatureCollection<Point>} points against input point set
 * @return {Feature<Point>} the closest point in the set to the reference point
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {
 *     "marker-color": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [28.965797, 41.010086]
 *   }
 * };
 * var against = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.973865, 41.011122]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.948459, 41.024204]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [28.938674, 41.013324]
 *       }
 *     }
 *   ]
 * };
 *
 * var nearest = turf.nearest(point, against);
 * nearest.properties['marker-color'] = '#f00';
 *
 * var resultFeatures = against.features.concat(point);
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": resultFeatures
 * };
 *
 * //=result
 */
module.exports = function (targetPoint, points) {
    var nearestPoint, minDist = Infinity;
    for (var i = 0; i < points.features.length; i++) {
        var distanceToPoint = distance(targetPoint, points.features[i], 'miles');
        if (distanceToPoint < minDist) {
            nearestPoint = points.features[i];
            minDist = distanceToPoint;
        }
    }
    return nearestPoint;
};


/***/ }),

/***/ "./node_modules/turf-planepoint/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-planepoint/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Takes a triangular plane as a {@link Polygon}
 * and a {@link Point} within that triangle and returns the z-value
 * at that point. The Polygon needs to have properties `a`, `b`, and `c`
 * that define the values at its three corners.
 *
 * @name planepoint
 * @param {Feature<Point>} point the Point for which a z-value will be calculated
 * @param {Feature<Polygon>} triangle a Polygon feature with three vertices
 * @return {Number} the z-value for `interpolatedPoint`
 * @example
 * var point = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-75.3221, 39.529]
 *   }
 * };
 * var point = turf.point([-75.3221, 39.529]);
 * // triangle is a polygon with "a", "b",
 * // and "c" values representing
 * // the values of the coordinates in order.
 * var triangle = {
 *   "type": "Feature",
 *   "properties": {
 *     "a": 11,
 *     "b": 122,
 *     "c": 44
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-75.1221, 39.57],
 *       [-75.58, 39.18],
 *       [-75.97, 39.86],
 *       [-75.1221, 39.57]
 *     ]]
 *   }
 * };
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [triangle, point]
 * };
 *
 * var zValue = turf.planepoint(point, triangle);
 *
 * //=features
 *
 * //=zValue
 */
module.exports = function (point, triangle) {
    var x = point.geometry.coordinates[0],
        y = point.geometry.coordinates[1],
        x1 = triangle.geometry.coordinates[0][0][0],
        y1 = triangle.geometry.coordinates[0][0][1],
        z1 = triangle.properties.a,
        x2 = triangle.geometry.coordinates[0][1][0],
        y2 = triangle.geometry.coordinates[0][1][1],
        z2 = triangle.properties.b,
        x3 = triangle.geometry.coordinates[0][2][0],
        y3 = triangle.geometry.coordinates[0][2][1],
        z3 = triangle.properties.c;

    var z = (z3 * (x - x1) * (y - y2) + z1 * (x - x2) * (y - y3) + z2 * (x - x3) * (y - y1) -
      z2 * (x - x1) * (y - y3) - z3 * (x - x2) * (y - y1) - z1 * (x - x3) * (y - y2)) /
      ((x - x1) * (y - y2) + (x - x2) * (y - y3) + (x - x3) * (y - y1) -
       (x - x1) * (y - y3) - (x - x2) * (y - y1) - (x - x3) * (y - y2));

    return z;
};


/***/ }),

/***/ "./node_modules/turf-point-grid/index.js":
/*!***********************************************!*\
  !*** ./node_modules/turf-point-grid/index.js ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
/**
 * Takes a bounding box and a cell depth and returns a set of {@link Point|points} in a grid.
 *
 * @name pointGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize the distance across each cell
 * @param {string} [units=kilometers] used in calculating cellWidth, can be degrees, radians, miles, or kilometers
 * @return {FeatureCollection<Point>} grid of points
 * @example
 * var extent = [-70.823364, -33.553984, -70.473175, -33.302986];
 * var cellWidth = 3;
 * var units = 'miles';
 *
 * var grid = turf.pointGrid(extent, cellWidth, units);
 *
 * //=grid
 */
module.exports = function pointGrid(bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            fc.features.push(point([currentX, currentY]));

            currentY += cellHeight;
        }
        currentX += cellWidth;
    }

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-point-on-line/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-point-on-line/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var bearing = __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js");
var destination = __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js");

/**
 * Takes a {@link Point} and a {@link LineString} and calculates the closest Point on the LineString.
 *
 * @name pointOnLine
 * @param {Feature<LineString>} line line to snap to
 * @param {Feature<Point>} point point to snap from
 * @return {Feature<Point>} closest point on the `line` to `point`
 * @example
 * var line = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "LineString",
 *     "coordinates": [
 *       [-77.031669, 38.878605],
 *       [-77.029609, 38.881946],
 *       [-77.020339, 38.884084],
 *       [-77.025661, 38.885821],
 *       [-77.021884, 38.889563],
 *       [-77.019824, 38.892368]
 *     ]
 *   }
 * };
 * var pt = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Point",
 *     "coordinates": [-77.037076, 38.884017]
 *   }
 * };
 *
 * var snapped = turf.pointOnLine(line, pt);
 * snapped.properties['marker-color'] = '#00f'
 *
 * var result = {
 *   "type": "FeatureCollection",
 *   "features": [line, pt, snapped]
 * };
 *
 * //=result
 */

module.exports = function (line, pt) {
    var coords;
    if (line.type === 'Feature') {
        coords = line.geometry.coordinates;
    } else if (line.type === 'LineString') {
        coords = line.coordinates;
    } else {
        throw new Error('input must be a LineString Feature or Geometry');
    }

    return pointOnLine(pt, coords);
};

function pointOnLine(pt, coords) {
    var units = 'miles';
    var closestPt = point([Infinity, Infinity], {
        dist: Infinity
    });
    for (var i = 0; i < coords.length - 1; i++) {
        var start = point(coords[i]);
        var stop = point(coords[i + 1]);
        //start
        start.properties.dist = distance(pt, start, units);
        //stop
        stop.properties.dist = distance(pt, stop, units);
        //perpendicular
        var heightDistance = Math.max(start.properties.dist, stop.properties.dist);
        var direction = bearing(start, stop);
        var perpendicularPt1 = destination(pt, heightDistance, direction + 90, units);
        var perpendicularPt2 = destination(pt, heightDistance, direction - 90, units);
        var intersect = lineIntersects(
        perpendicularPt1.geometry.coordinates[0],
        perpendicularPt1.geometry.coordinates[1],
        perpendicularPt2.geometry.coordinates[0],
        perpendicularPt2.geometry.coordinates[1],
        start.geometry.coordinates[0],
        start.geometry.coordinates[1],
        stop.geometry.coordinates[0],
        stop.geometry.coordinates[1]
        );
        var intersectPt;
        if (intersect) {
            intersectPt = point(intersect);
            intersectPt.properties.dist = distance(pt, intersectPt, units);
        }

        if (start.properties.dist < closestPt.properties.dist) {
            closestPt = start;
            closestPt.properties.index = i;
        }
        if (stop.properties.dist < closestPt.properties.dist) {
            closestPt = stop;
            closestPt.properties.index = i;
        }
        if (intersectPt && intersectPt.properties.dist < closestPt.properties.dist) {
            closestPt = intersectPt;
            closestPt.properties.index = i;
        }
    }

    return closestPt;
}

// modified from http://jsfiddle.net/justin_c_rounds/Gd2S2/light/
function lineIntersects(line1StartX, line1StartY, line1EndX, line1EndY, line2StartX, line2StartY, line2EndX, line2EndY) {
    // if the lines intersect, the result contains the x and y of the intersection (treating the lines as infinite) and booleans for whether line segment 1 or line segment 2 contain the point
    var denominator, a, b, numerator1, numerator2;
    var result = {
        x: null,
        y: null,
        onLine1: false,
        onLine2: false
    };
    denominator = ((line2EndY - line2StartY) * (line1EndX - line1StartX)) - ((line2EndX - line2StartX) * (line1EndY - line1StartY));
    if (denominator === 0) {
        if (result.x !== null && result.y !== null) {
            return result;
        } else {
            return false;
        }
    }
    a = line1StartY - line2StartY;
    b = line1StartX - line2StartX;
    numerator1 = ((line2EndX - line2StartX) * a) - ((line2EndY - line2StartY) * b);
    numerator2 = ((line1EndX - line1StartX) * a) - ((line1EndY - line1StartY) * b);
    a = numerator1 / denominator;
    b = numerator2 / denominator;

    // if we cast these lines infinitely in both directions, they intersect here:
    result.x = line1StartX + (a * (line1EndX - line1StartX));
    result.y = line1StartY + (a * (line1EndY - line1StartY));

    // if line1 is a segment and line2 is infinite, they intersect if:
    if (a > 0 && a < 1) {
        result.onLine1 = true;
    }
    // if line2 is a segment and line1 is infinite, they intersect if:
    if (b > 0 && b < 1) {
        result.onLine2 = true;
    }
    // if line1 and line2 are segments, they intersect if both of the above are true
    if (result.onLine1 && result.onLine2) {
        return [result.x, result.y];
    } else {
        return false;
    }
}


/***/ }),

/***/ "./node_modules/turf-point-on-surface/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/turf-point-on-surface/index.js ***!
  \*****************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var centroid = __webpack_require__(/*! turf-center */ "./node_modules/turf-center/index.js");
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");
var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var explode = __webpack_require__(/*! turf-explode */ "./node_modules/turf-explode/index.js");

/**
 * Takes a feature and returns a {@link Point} guaranteed to be on the surface of the feature.
 *
 * * Given a {@link Polygon}, the point will be in the area of the polygon
 * * Given a {@link LineString}, the point will be along the string
 * * Given a {@link Point}, the point will the same as the input
 *
 * @param {(Feature|FeatureCollection)} fc any feature or set of features
 * @returns {Feature} a point on the surface of `input`
 * @example
 * // create a random polygon
 * var polygon = turf.random('polygon');
 *
 * //=polygon
 *
 * var pointOnPolygon = turf.pointOnSurface(polygon);
 *
* var resultFeatures = polygon.features.concat(pointOnPolygon);
* var result = {
*   "type": "FeatureCollection",
*   "features": resultFeatures
* };
 *
 * //=result
 */
function pointOnSurface(fc) {
    // normalize
    if (fc.type !== 'FeatureCollection') {
        if (fc.type !== 'Feature') {
            fc = {
                type: 'Feature',
                geometry: fc,
                properties: {}
            };
        }
        fc = featureCollection([fc]);
    }

    //get centroid
    var cent = centroid(fc);

    // check to see if centroid is on surface
    var onSurface = false;
    var i = 0;
    while (!onSurface && i < fc.features.length) {
        var geom = fc.features[i].geometry;
        var x, y, x1, y1, x2, y2, k;
        var onLine = false;
        if (geom.type === 'Point') {
            if (cent.geometry.coordinates[0] === geom.coordinates[0] &&
        cent.geometry.coordinates[1] === geom.coordinates[1]) {
                onSurface = true;
            }
        } else if (geom.type === 'MultiPoint') {
            var onMultiPoint = false;
            k = 0;
            while (!onMultiPoint && k < geom.coordinates.length) {
                if (cent.geometry.coordinates[0] === geom.coordinates[k][0] &&
          cent.geometry.coordinates[1] === geom.coordinates[k][1]) {
                    onSurface = true;
                    onMultiPoint = true;
                }
                k++;
            }
        } else if (geom.type === 'LineString') {
            k = 0;
            while (!onLine && k < geom.coordinates.length - 1) {
                x = cent.geometry.coordinates[0];
                y = cent.geometry.coordinates[1];
                x1 = geom.coordinates[k][0];
                y1 = geom.coordinates[k][1];
                x2 = geom.coordinates[k + 1][0];
                y2 = geom.coordinates[k + 1][1];
                if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                    onLine = true;
                    onSurface = true;
                }
                k++;
            }
        } else if (geom.type === 'MultiLineString') {
            var j = 0;
            while (j < geom.coordinates.length) {
                onLine = false;
                k = 0;
                var line = geom.coordinates[j];
                while (!onLine && k < line.length - 1) {
                    x = cent.geometry.coordinates[0];
                    y = cent.geometry.coordinates[1];
                    x1 = line[k][0];
                    y1 = line[k][1];
                    x2 = line[k + 1][0];
                    y2 = line[k + 1][1];
                    if (pointOnSegment(x, y, x1, y1, x2, y2)) {
                        onLine = true;
                        onSurface = true;
                    }
                    k++;
                }
                j++;
            }
        } else if (geom.type === 'Polygon' || geom.type === 'MultiPolygon') {
            var f = {
                type: 'Feature',
                geometry: geom,
                properties: {}
            };
            if (inside(cent, f)) {
                onSurface = true;
            }
        }
        i++;
    }
    if (onSurface) {
        return cent;
    } else {
        var vertices = featureCollection([]);
        for (i = 0; i < fc.features.length; i++) {
            vertices.features = vertices.features.concat(explode(fc.features[i]).features);
        }
        var closestVertex;
        var closestDistance = Infinity;
        for (i = 0; i < vertices.features.length; i++) {
            var dist = distance(cent, vertices.features[i], 'miles');
            if (dist < closestDistance) {
                closestDistance = dist;
                closestVertex = vertices.features[i];
            }
        }
        return closestVertex;
    }
}

function pointOnSegment(x, y, x1, y1, x2, y2) {
    var ab = Math.sqrt((x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1));
    var ap = Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    var pb = Math.sqrt((x2 - x) * (x2 - x) + (y2 - y) * (y2 - y));
    if (ab === ap + pb) {
        return true;
    }
}

module.exports = pointOnSurface;


/***/ }),

/***/ "./node_modules/turf-point/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-point/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Takes coordinates and properties (optional) and returns a new {@link Point} feature.
 *
 * @module turf/point
 * @category helper
 * @param {number} longitude position west to east in decimal degrees
 * @param {number} latitude position south to north in decimal degrees
 * @param {Object} properties an Object that is used as the {@link Feature}'s
 * properties
 * @return {Point} a Point feature
 * @example
 * var pt1 = turf.point([-75.343, 39.984]);
 *
 * //=pt1
 */
var isArray = Array.isArray || function(arg) {
  return Object.prototype.toString.call(arg) === '[object Array]';
};
module.exports = function(coordinates, properties) {
  if (!isArray(coordinates)) throw new Error('Coordinates must be an array');
  if (coordinates.length < 2) throw new Error('Coordinates must be at least 2 numbers long');
  return {
    type: "Feature",
    geometry: {
      type: "Point",
      coordinates: coordinates
    },
    properties: properties || {}
  };
};


/***/ }),

/***/ "./node_modules/turf-random/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-random/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var random = __webpack_require__(/*! geojson-random */ "./node_modules/geojson-random/index.js");

/**
 * Generates random {@link GeoJSON} data, including {@link Point|Points} and {@link Polygon|Polygons}, for testing
 * and experimentation.
 *
 * @name random
 * @param {String} [type='point'] type of features desired: 'points' or 'polygons'
 * @param {Number} [count=1] how many geometries should be generated.
 * @param {Object} options options relevant to the feature desired. Can include:
 * @param {Array<number>} options.bbox a bounding box inside of which geometries
 * are placed. In the case of {@link Point} features, they are guaranteed to be within this bounds,
 * while {@link Polygon} features have their centroid within the bounds.
 * @param {Number} [options.num_vertices=10] options.vertices the number of vertices added
 * to polygon features.
 * @param {Number} [options.max_radial_length=10] the total number of decimal
 * degrees longitude or latitude that a polygon can extent outwards to
 * from its center.
 * @return {FeatureCollection} generated random features
 * @example
 * var points = turf.random('points', 100, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=points
 *
 * var polygons = turf.random('polygons', 4, {
 *   bbox: [-70, 40, -60, 60]
 * });
 *
 * //=polygons
 */
module.exports = function (type, count, options) {
    options = options || {};
    count = count || 1;
    switch (type) {
    case 'point':
    case 'points':
    case undefined:
        return random.point(count, options.bbox);
    case 'polygon':
    case 'polygons':
        return random.polygon(
                count,
                options.num_vertices,
                options.max_radial_length,
                options.bbox);
    default:
        throw new Error('Unknown type given: valid options are points and polygons');
    }
};


/***/ }),

/***/ "./node_modules/turf-sample/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-sample/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// http://stackoverflow.com/questions/11935175/sampling-a-random-subset-from-an-array
var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a {@link FeatureCollection} and returns a FeatureCollection with given number of {@link Feature|features} at random.
 *
 * @name sample
 * @param {FeatureCollection} featurecollection set of input features
 * @param {number} num number of features to select
 * @return {FeatureCollection} a FeatureCollection with `n` features
 * @example
 * var points = turf.random('points', 1000);
 *
 * //=points
 *
 * var sample = turf.sample(points, 10);
 *
 * //=sample
 */
module.exports = function (featurecollection, num) {
    var outFC = featureCollection(getRandomSubarray(featurecollection.features, num));
    return outFC;
};

function getRandomSubarray(arr, size) {
    var shuffled = arr.slice(0), i = arr.length, min = i - size, temp, index;
    while (i-- > min) {
        index = Math.floor((i + 1) * Math.random());
        temp = shuffled[index];
        shuffled[index] = shuffled[i];
        shuffled[i] = temp;
    }
    return shuffled.slice(min);
}


/***/ }),

/***/ "./node_modules/turf-simplify/index.js":
/*!*********************************************!*\
  !*** ./node_modules/turf-simplify/index.js ***!
  \*********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var simplify = __webpack_require__(/*! simplify-js */ "./node_modules/simplify-js/simplify.js");

// supported GeoJSON geometries, used to check whether to wrap in simpleFeature()
var supportedTypes = ['LineString', 'MultiLineString', 'Polygon', 'MultiPolygon'];

/**
 * Takes a {@link LineString} or {@link Polygon} and returns a simplified version. Internally uses [simplify-js](http://mourner.github.io/simplify-js/) to perform simplification.
 *
 * @name simplify
 * @param {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} feature feature to be simplified
 * @param {number} tolerance simplification tolerance
 * @param {boolean} highQuality whether or not to spend more time to create
 * a higher-quality simplification with a different algorithm
 * @return {Feature<(LineString|Polygon|MultiLineString|MultiPolygon)>|FeatureCollection|GeometryCollection} a simplified feature
 * @example
  * var feature = {
 *   "type": "Feature",
 *   "properties": {},
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-70.603637, -33.399918],
 *       [-70.614624, -33.395332],
 *       [-70.639343, -33.392466],
 *       [-70.659942, -33.394759],
 *       [-70.683975, -33.404504],
 *       [-70.697021, -33.419406],
 *       [-70.701141, -33.434306],
 *       [-70.700454, -33.446339],
 *       [-70.694274, -33.458369],
 *       [-70.682601, -33.465816],
 *       [-70.668869, -33.472117],
 *       [-70.646209, -33.473835],
 *       [-70.624923, -33.472117],
 *       [-70.609817, -33.468107],
 *       [-70.595397, -33.458369],
 *       [-70.587158, -33.442901],
 *       [-70.587158, -33.426283],
 *       [-70.590591, -33.414248],
 *       [-70.594711, -33.406224],
 *       [-70.603637, -33.399918]
 *     ]]
 *   }
 * };

 * var tolerance = 0.01;
 *
 * var simplified = turf.simplify(
 *  feature, tolerance, false);
 *
 * //=feature
 *
 * //=simplified
 */
module.exports = function (feature, tolerance, highQuality) {
    if (feature.type === 'Feature') {
        return simpleFeature(
            simplifyHelper(feature, tolerance, highQuality),
            feature.properties);
    } else if (feature.type === 'FeatureCollection') {
        return {
            type: 'FeatureCollection',
            features: feature.features.map(function (f) {
                var simplified = simplifyHelper(f, tolerance, highQuality);

                // we create simpleFeature here because it doesn't apply to GeometryCollection
                // so we can't create it at simplifyHelper()
                if (supportedTypes.indexOf(simplified.type) > -1) {
                    return simpleFeature(simplified, f.properties);
                } else {
                    return simplified;
                }
            })
        };
    } else if (feature.type === 'GeometryCollection') {
        return {
            type: 'GeometryCollection',
            geometries: feature.geometries.map(function (g) {
                if (supportedTypes.indexOf(g.type) > -1) {
                    return simplifyHelper({
                        type: 'Feature',
                        geometry: g
                    }, tolerance, highQuality);
                }
                return g;
            })
        };
    } else {
        return feature;
    }
};


function simplifyHelper(feature, tolerance, highQuality) {
    if (feature.geometry.type === 'LineString') {
        return {
            type: 'LineString',
            coordinates: simplifyLine(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiLineString') {
        return {
            type: 'MultiLineString',
            coordinates: feature.geometry.coordinates.map(function (lines) {
                return simplifyLine(lines, tolerance, highQuality);
            })
        };
    } else if (feature.geometry.type === 'Polygon') {
        return {
            type: 'Polygon',
            coordinates: simplifyPolygon(feature.geometry.coordinates, tolerance, highQuality)
        };
    } else if (feature.geometry.type === 'MultiPolygon') {
        return {
            type: 'MultiPolygon',
            coordinates: feature.geometry.coordinates.map(function (rings) {
                return simplifyPolygon(rings, tolerance, highQuality);
            })
        };
    } else {
        // unsupported geometry type supplied
        return feature;
    }
}

/*
* returns true if ring's first coordinate is the same as its last
*/
function checkValidity(ring) {
    if (ring.length < 3) {
        return false;
    //if the last point is the same as the first, it's not a triangle
    } else if (ring.length === 3 &&
      ((ring[2][0] === ring[0][0]) && (ring[2][1] === ring[0][1]))) {
        return false;
    } else {
        return true;
    }
}

function simpleFeature(geom, properties) {
    return {
        type: 'Feature',
        geometry: geom,
        properties: properties
    };
}

function simplifyLine(coordinates, tolerance, highQuality) {
    return simplify(coordinates.map(function (coord) {
        return {x: coord[0], y: coord[1]};
    }), tolerance, highQuality).map(function (coords) {
        return [coords.x, coords.y];
    });
}

function simplifyPolygon(coordinates, tolerance, highQuality) {
    return coordinates.map(function (ring) {
        var pts = ring.map(function (coord) {
            return {x: coord[0], y: coord[1]};
        });
        if (pts.length < 4) {
            throw new Error('Invalid polygon');
        }
        var simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
            return [coords.x, coords.y];
        });
        //remove 1 percent of tolerance until enough points to make a triangle
        while (!checkValidity(simpleRing)) {
            tolerance -= tolerance * 0.01;
            simpleRing = simplify(pts, tolerance, highQuality).map(function (coords) {
                return [coords.x, coords.y];
            });
        }
        if (
            (simpleRing[simpleRing.length - 1][0] !== simpleRing[0][0]) ||
                (simpleRing[simpleRing.length - 1][1] !== simpleRing[0][1])) {
            simpleRing.push(simpleRing[0]);
        }
        return simpleRing;
    });
}


/***/ }),

/***/ "./node_modules/turf-square-grid/index.js":
/*!************************************************!*\
  !*** ./node_modules/turf-square-grid/index.js ***!
  \************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var point = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").point;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and a cell depth and returns a set of square {@link Polygon|polygons} in a grid.
 *
 * @name squareGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize width of each cell
 * @param {string} units units to use for cellWidth
 * @return {FeatureCollection<Polygon>} grid a grid of polygons
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var squareGrid = turf.squareGrid(extent, cellWidth, units);
 *
 * //=squareGrid
 */
module.exports = function squareGrid(bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[2], bbox[1]]), units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance(point([bbox[0], bbox[1]]), point([bbox[0], bbox[3]]), units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            var cellPoly = polygon([[
                [currentX, currentY],
                [currentX, currentY + cellHeight],
                [currentX + cellWidth, currentY + cellHeight],
                [currentX + cellWidth, currentY],
                [currentX, currentY]
            ]]);
            fc.features.push(cellPoly);

            currentY += cellHeight;
        }
        currentX += cellWidth;
    }

    return fc;
};


/***/ }),

/***/ "./node_modules/turf-square/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-square/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and calculates the minimum square bounding box that
 * would contain the input.
 *
 * @name square
 * @param {Array<number>} bbox a bounding box
 * @return {Array<number>} a square surrounding `bbox`
 * @example
 * var bbox = [-20,-20,-15,0];
 *
 * var squared = turf.square(bbox);
 *
 * var features = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     turf.bboxPolygon(bbox),
 *     turf.bboxPolygon(squared)
 *   ]
 * };
 *
 * //=features
 */
module.exports = function (bbox) {
    var horizontalDistance = distance(bbox.slice(0, 2), [bbox[2], bbox[1]], 'miles');
    var verticalDistance = distance(bbox.slice(0, 2), [bbox[0], bbox[3]], 'miles');
    if (horizontalDistance >= verticalDistance) {
        var verticalMidpoint = (bbox[1] + bbox[3]) / 2;
        return [
            bbox[0],
            verticalMidpoint - ((bbox[2] - bbox[0]) / 2),
            bbox[2],
            verticalMidpoint + ((bbox[2] - bbox[0]) / 2)
        ];
    } else {
        var horizontalMidpoint = (bbox[0] + bbox[2]) / 2;
        return [
            horizontalMidpoint - ((bbox[3] - bbox[1]) / 2),
            bbox[1],
            horizontalMidpoint + ((bbox[3] - bbox[1]) / 2),
            bbox[3]
        ];
    }
};


/***/ }),

/***/ "./node_modules/turf-tag/index.js":
/*!****************************************!*\
  !*** ./node_modules/turf-tag/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and performs a spatial join.
 *
 * @name tag
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @param {string} field property in `polygons` to add to joined Point features
 * @param {string} outField property in `points` in which to store joined property from `polygons
 * @return {FeatureCollection<Point>} points with `containingPolyId` property containing values from `polyId`
 * @example
 * var bbox = [0, 0, 10, 10];
 * // create a triangular grid of polygons
 * var triangleGrid = turf.triangleGrid(bbox, 50, 'miles');
 * triangleGrid.features.forEach(function(f) {
 *   f.properties.fill = '#' +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16) +
 *     (~~(Math.random() * 16)).toString(16);
 *   f.properties.stroke = 0;
 *   f.properties['fill-opacity'] = 1;
 * });
 * var randomPoints = turf.random('point', 30, {
 *   bbox: bbox
 * });
 * var both = turf.featurecollection(
 *   triangleGrid.features.concat(randomPoints.features));
 *
 * //=both
 *
 * var tagged = turf.tag(randomPoints, triangleGrid,
 *                       'fill', 'marker-color');
 *
 * //=tagged
 */
module.exports = function (points, polygons, field, outField) {
    // prevent mutations
    points = JSON.parse(JSON.stringify(points));
    polygons = JSON.parse(JSON.stringify(polygons));
    points.features.forEach(function (pt) {
        if (!pt.properties) {
            pt.properties = {};
        }
        polygons.features.forEach(function (poly) {
            if (pt.properties[outField] === undefined) {
                var isInside = inside(pt, poly);
                if (isInside) {
                    pt.properties[outField] = poly.properties[field];
                }
            }
        });
    });
    return points;
};


/***/ }),

/***/ "./node_modules/turf-tesselate/index.js":
/*!**********************************************!*\
  !*** ./node_modules/turf-tesselate/index.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var earcut = __webpack_require__(/*! earcut */ "./node_modules/earcut/src/earcut.js");

/**
 * Tesselates a {@link Feature<Polygon>} into a {@link FeatureCollection<Polygon>} of triangles
 * using [earcut](https://github.com/mapbox/earcut).
 *
 * @name tesselate
 * @param {Feature<Polygon>} polygon the polygon to tesselate
 * @returns {FeatureCollection<Polygon>} a geometrycollection feature
 * @example
 * var polygon = {"type":"Feature","id":"USA-CA","properties":{"name":"California"},"geometry":{"type":"Polygon","coordinates":[[[-123.233256,42.006186],[-122.378853,42.011663],[-121.037003,41.995232],[-120.001861,41.995232],[-119.996384,40.264519],[-120.001861,38.999346],[-118.71478,38.101128],[-117.498899,37.21934],[-116.540435,36.501861],[-115.85034,35.970598],[-114.634459,35.00118],[-114.634459,34.87521],[-114.470151,34.710902],[-114.333228,34.448009],[-114.136058,34.305608],[-114.256551,34.174162],[-114.415382,34.108438],[-114.535874,33.933176],[-114.497536,33.697668],[-114.524921,33.54979],[-114.727567,33.40739],[-114.661844,33.034958],[-114.524921,33.029481],[-114.470151,32.843265],[-114.524921,32.755634],[-114.72209,32.717295],[-116.04751,32.624187],[-117.126467,32.536556],[-117.24696,32.668003],[-117.252437,32.876127],[-117.329114,33.122589],[-117.471515,33.297851],[-117.7837,33.538836],[-118.183517,33.763391],[-118.260194,33.703145],[-118.413548,33.741483],[-118.391641,33.840068],[-118.566903,34.042715],[-118.802411,33.998899],[-119.218659,34.146777],[-119.278905,34.26727],[-119.558229,34.415147],[-119.875891,34.40967],[-120.138784,34.475393],[-120.472878,34.448009],[-120.64814,34.579455],[-120.609801,34.858779],[-120.670048,34.902595],[-120.631709,35.099764],[-120.894602,35.247642],[-120.905556,35.450289],[-121.004141,35.461243],[-121.168449,35.636505],[-121.283465,35.674843],[-121.332757,35.784382],[-121.716143,36.195153],[-121.896882,36.315645],[-121.935221,36.638785],[-121.858544,36.6114],[-121.787344,36.803093],[-121.929744,36.978355],[-122.105006,36.956447],[-122.335038,37.115279],[-122.417192,37.241248],[-122.400761,37.361741],[-122.515777,37.520572],[-122.515777,37.783465],[-122.329561,37.783465],[-122.406238,38.15042],[-122.488392,38.112082],[-122.504823,37.931343],[-122.701993,37.893004],[-122.937501,38.029928],[-122.97584,38.265436],[-123.129194,38.451652],[-123.331841,38.566668],[-123.44138,38.698114],[-123.737134,38.95553],[-123.687842,39.032208],[-123.824765,39.366301],[-123.764519,39.552517],[-123.85215,39.831841],[-124.109566,40.105688],[-124.361506,40.259042],[-124.410798,40.439781],[-124.158859,40.877937],[-124.109566,41.025814],[-124.158859,41.14083],[-124.065751,41.442061],[-124.147905,41.715908],[-124.257444,41.781632],[-124.213628,42.000709],[-123.233256,42.006186]]]}};
 *
 * var triangles = turf.tesselate(polygon);
 *
 * //=triangles
 */

module.exports = function (poly) {
    if (!poly.geometry || (poly.geometry.type !== 'Polygon' && poly.geometry.type !== 'MultiPolygon')) {
        throw new Error('input must be a Polygon or MultiPolygon');
    }

    var fc = {type: 'FeatureCollection', features: []};

    if (poly.geometry.type === 'Polygon') {
        fc.features = processPolygon(poly.geometry.coordinates);
    } else {
        poly.geometry.coordinates.forEach(function (coordinates) {
            fc.features = fc.features.concat(processPolygon(coordinates));
        });
    }

    return fc;
};

function processPolygon(coordinates) {
    var data = flattenCoords(coordinates);
    var dim = 2;
    var result = earcut(data.vertices, data.holes, dim);

    var features = [];
    var vertices = [];

    result.forEach(function (vert, i) {
        var index = result[i];
        vertices.push([data.vertices[index * dim], data.vertices[index * dim + 1]]);
    });

    for (var i = 0; i < vertices.length; i += 3) {
        var coords = vertices.slice(i, i + 3);
        coords.push(vertices[i]);
        features.push(polygon([coords]));
    }

    return features;
}

function flattenCoords(data) {
    var dim = data[0][0].length,
        result = {vertices: [], holes: [], dimensions: dim},
        holeIndex = 0;

    for (var i = 0; i < data.length; i++) {
        for (var j = 0; j < data[i].length; j++) {
            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);
        }
        if (i > 0) {
            holeIndex += data[i - 1].length;
            result.holes.push(holeIndex);
        }
    }

    return result;
}


/***/ }),

/***/ "./node_modules/turf-tin/index.js":
/*!****************************************!*\
  !*** ./node_modules/turf-tin/index.js ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

//http://en.wikipedia.org/wiki/Delaunay_triangulation
//https://github.com/ironwallaby/delaunay
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a set of {@link Point|points} and the name of a z-value property and
 * creates a [Triangulated Irregular Network](http://en.wikipedia.org/wiki/Triangulated_irregular_network),
 * or a TIN for short, returned as a collection of Polygons. These are often used
 * for developing elevation contour maps or stepped heat visualizations.
 *
 * This triangulates the points, as well as adds properties called `a`, `b`,
 * and `c` representing the value of the given `propertyName` at each of
 * the points that represent the corners of the triangle.
 *
 * @name tin
 * @param {FeatureCollection<Point>} points input points
 * @param {String=} z name of the property from which to pull z values
 * This is optional: if not given, then there will be no extra data added to the derived triangles.
 * @return {FeatureCollection<Polygon>} TIN output
 * @example
 * // generate some random point data
 * var points = turf.random('points', 30, {
 *   bbox: [50, 30, 70, 50]
 * });
 * //=points
 * // add a random property to each point between 0 and 9
 * for (var i = 0; i < points.features.length; i++) {
 *   points.features[i].properties.z = ~~(Math.random() * 9);
 * }
 * var tin = turf.tin(points, 'z')
 * for (var i = 0; i < tin.features.length; i++) {
 *   var properties  = tin.features[i].properties;
 *   // roughly turn the properties of each
 *   // triangle into a fill color
 *   // so we can visualize the result
 *   properties.fill = '#' + properties.a +
 *     properties.b + properties.c;
 * }
 * //=tin
 */
module.exports = function (points, z) {
    //break down points
    return featurecollection(triangulate(points.features.map(function (p) {
        var point = {
            x: p.geometry.coordinates[0],
            y: p.geometry.coordinates[1]
        };
        if (z) point.z = p.properties[z];
        return point;
    })).map(function (triangle) {
        return polygon([[
        [triangle.a.x, triangle.a.y],
        [triangle.b.x, triangle.b.y],
        [triangle.c.x, triangle.c.y],
        [triangle.a.x, triangle.a.y]
        ]], {
            a: triangle.a.z,
            b: triangle.b.z,
            c: triangle.c.z
        });
    }));
};

function Triangle(a, b, c) {
    this.a = a;
    this.b = b;
    this.c = c;

    var A = b.x - a.x,
        B = b.y - a.y,
        C = c.x - a.x,
        D = c.y - a.y,
        E = A * (a.x + b.x) + B * (a.y + b.y),
        F = C * (a.x + c.x) + D * (a.y + c.y),
        G = 2 * (A * (c.y - b.y) - B * (c.x - b.x)),
        minx, miny, dx, dy;

    // If the points of the triangle are collinear, then just find the
    // extremes and use the midpoint as the center of the circumcircle.
    if (Math.abs(G) < 0.000001) {
        minx = Math.min(a.x, b.x, c.x);
        miny = Math.min(a.y, b.y, c.y);
        dx = (Math.max(a.x, b.x, c.x) - minx) * 0.5;
        dy = (Math.max(a.y, b.y, c.y) - miny) * 0.5;

        this.x = minx + dx;
        this.y = miny + dy;
        this.r = dx * dx + dy * dy;
    } else {
        this.x = (D * E - B * F) / G;
        this.y = (A * F - C * E) / G;
        dx = this.x - a.x;
        dy = this.y - a.y;
        this.r = dx * dx + dy * dy;
    }
}

function byX(a, b) {
    return b.x - a.x;
}

function dedup(edges) {
    var j = edges.length,
        a, b, i, m, n;

    outer:
  while (j) {
      b = edges[--j];
      a = edges[--j];
      i = j;
      while (i) {
          n = edges[--i];
          m = edges[--i];
          if ((a === m && b === n) || (a === n && b === m)) {
              edges.splice(j, 2);
              edges.splice(i, 2);
              j -= 2;
              continue outer;
          }
      }
  }
}

function triangulate(vertices) {
    // Bail if there aren't enough vertices to form any triangles.
    if (vertices.length < 3)
        return [];

    // Ensure the vertex array is in order of descending X coordinate
    // (which is needed to ensure a subquadratic runtime), and then find
    // the bounding box around the points.
    vertices.sort(byX);

    var i = vertices.length - 1,
        xmin = vertices[i].x,
        xmax = vertices[0].x,
        ymin = vertices[i].y,
        ymax = ymin;

    while (i--) {
        if (vertices[i].y < ymin)
            ymin = vertices[i].y;
        if (vertices[i].y > ymax)
            ymax = vertices[i].y;
    }

    //Find a supertriangle, which is a triangle that surrounds all the
    //vertices. This is used like something of a sentinel value to remove
    //cases in the main algorithm, and is removed before we return any
    // results.

    // Once found, put it in the "open" list. (The "open" list is for
    // triangles who may still need to be considered; the "closed" list is
    // for triangles which do not.)
    var dx = xmax - xmin,
        dy = ymax - ymin,
        dmax = (dx > dy) ? dx : dy,
        xmid = (xmax + xmin) * 0.5,
        ymid = (ymax + ymin) * 0.5,
        open = [
            new Triangle({
                x: xmid - 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }, {
                x: xmid,
                y: ymid + 20 * dmax,
                __sentinel: true
            }, {
                x: xmid + 20 * dmax,
                y: ymid - dmax,
                __sentinel: true
            }
        )],
        closed = [],
        edges = [],
        j, a, b;

    // Incrementally add each vertex to the mesh.
    i = vertices.length;
    while (i--) {
        // For each open triangle, check to see if the current point is
        // inside it's circumcircle. If it is, remove the triangle and add
        // it's edges to an edge list.
        edges.length = 0;
        j = open.length;
        while (j--) {
            // If this point is to the right of this triangle's circumcircle,
            // then this triangle should never get checked again. Remove it
            // from the open list, add it to the closed list, and skip.
            dx = vertices[i].x - open[j].x;
            if (dx > 0 && dx * dx > open[j].r) {
                closed.push(open[j]);
                open.splice(j, 1);
                continue;
            }

            // If not, skip this triangle.
            dy = vertices[i].y - open[j].y;
            if (dx * dx + dy * dy > open[j].r)
                continue;

            // Remove the triangle and add it's edges to the edge list.
            edges.push(
        open[j].a, open[j].b,
        open[j].b, open[j].c,
        open[j].c, open[j].a
      );
            open.splice(j, 1);
        }

        // Remove any doubled edges.
        dedup(edges);

        // Add a new triangle for each edge.
        j = edges.length;
        while (j) {
            b = edges[--j];
            a = edges[--j];
            open.push(new Triangle(a, b, vertices[i]));
        }
    }

    // Copy any remaining open triangles to the closed list, and then
    // remove any triangles that share a vertex with the supertriangle.
    Array.prototype.push.apply(closed, open);

    i = closed.length;
    while (i--)
        if (closed[i].a.__sentinel ||
      closed[i].b.__sentinel ||
      closed[i].c.__sentinel)
            closed.splice(i, 1);

    return closed;
}


/***/ }),

/***/ "./node_modules/turf-triangle-grid/index.js":
/*!**************************************************!*\
  !*** ./node_modules/turf-triangle-grid/index.js ***!
  \**************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var featurecollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;
var polygon = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").polygon;
var distance = __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js");

/**
 * Takes a bounding box and a cell depth and returns a set of triangular {@link Polygon|polygons} in a grid.
 *
 * @name triangleGrid
 * @param {Array<number>} bbox extent in [minX, minY, maxX, maxY] order
 * @param {number} cellSize dimension of each cell
 * @param {string} units units to use for cellWidth
 * @return {FeatureCollection<Polygon>} grid of polygons
 * @example
 * var extent = [-77.3876953125,38.71980474264239,-76.9482421875,39.027718840211605];
 * var cellWidth = 10;
 * var units = 'miles';
 *
 * var triangleGrid = turf.triangleGrid(extent, cellWidth, units);
 *
 * //=triangleGrid
 */
module.exports = function (bbox, cellSize, units) {
    var fc = featurecollection([]);
    var xFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[2], bbox[1]], units));
    var cellWidth = xFraction * (bbox[2] - bbox[0]);
    var yFraction = cellSize / (distance([bbox[0], bbox[1]], [bbox[0], bbox[3]], units));
    var cellHeight = yFraction * (bbox[3] - bbox[1]);

    var xi = 0;
    var currentX = bbox[0];
    while (currentX <= bbox[2]) {
        var yi = 0;
        var currentY = bbox[1];
        while (currentY <= bbox[3]) {
            if (xi % 2 === 0 && yi % 2 === 0) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            } else if (xi % 2 === 0 && yi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 0 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]));
            } else if (yi % 2 === 1 && xi % 2 === 1) {
                fc.features.push(polygon([[
                    [currentX, currentY],
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY]
                ]]), polygon([[
                    [currentX, currentY + cellHeight],
                    [currentX + cellWidth, currentY + cellHeight],
                    [currentX + cellWidth, currentY],
                    [currentX, currentY + cellHeight]
                ]]));
            }
            currentY += cellHeight;
            yi++;
        }
        xi++;
        currentX += cellWidth;
    }
    return fc;
};



/***/ }),

/***/ "./node_modules/turf-union/index.js":
/*!******************************************!*\
  !*** ./node_modules/turf-union/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

// look here for help http://svn.osgeo.org/grass/grass/branches/releasebranch_6_4/vector/v.overlay/main.c
//must be array of polygons

// depend on jsts for now https://github.com/bjornharrtell/jsts/blob/master/examples/overlay.html

var jsts = __webpack_require__(/*! jsts */ "./node_modules/jsts/dist/jsts.min.js");

/**
 * Takes two {@link Polygon|polygons} and returns a combined polygon. If the input polygons are not contiguous, this function returns a {@link MultiPolygon} feature.
 *
 * @name union
 * @param {Feature<Polygon>} poly1 input polygon
 * @param {Feature<Polygon>} poly2 another input polygon
 * @return {Feature<(Polygon|MultiPolygon)>} a combined {@link Polygon} or {@link MultiPolygon} feature
 * @example
 * var poly1 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#0f0"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.574787, 35.594087],
 *       [-82.574787, 35.615581],
 *       [-82.545261, 35.615581],
 *       [-82.545261, 35.594087],
 *       [-82.574787, 35.594087]
 *     ]]
 *   }
 * };
 * var poly2 = {
 *   "type": "Feature",
 *   "properties": {
 *     "fill": "#00f"
 *   },
 *   "geometry": {
 *     "type": "Polygon",
 *     "coordinates": [[
 *       [-82.560024, 35.585153],
 *       [-82.560024, 35.602602],
 *       [-82.52964, 35.602602],
 *       [-82.52964, 35.585153],
 *       [-82.560024, 35.585153]
 *     ]]
 *   }
 * };
 * var polygons = {
 *   "type": "FeatureCollection",
 *   "features": [poly1, poly2]
 * };
 *
 * var union = turf.union(poly1, poly2);
 *
 * //=polygons
 *
 * //=union
 */
module.exports = function (poly1, poly2) {
    var reader = new jsts.io.GeoJSONReader();
    var a = reader.read(JSON.stringify(poly1.geometry));
    var b = reader.read(JSON.stringify(poly2.geometry));
    var union = a.union(b);
    var writer = new jsts.io.GeoJSONWriter();

    union = writer.write(union);
    return {
        type: 'Feature',
        geometry: union,
        properties: poly1.properties
    };
};


/***/ }),

/***/ "./node_modules/turf-within/index.js":
/*!*******************************************!*\
  !*** ./node_modules/turf-within/index.js ***!
  \*******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var inside = __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js");
var featureCollection = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js").featureCollection;

/**
 * Takes a set of {@link Point|points} and a set of {@link Polygon|polygons} and returns the points that fall within the polygons.
 *
 * @name within
 * @param {FeatureCollection<Point>} points input points
 * @param {FeatureCollection<Polygon>} polygons input polygons
 * @return {FeatureCollection<Point>} points that land within at least one polygon
 * @example
 * var searchWithin = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Polygon",
 *         "coordinates": [[
 *           [-46.653,-23.543],
 *           [-46.634,-23.5346],
 *           [-46.613,-23.543],
 *           [-46.614,-23.559],
 *           [-46.631,-23.567],
 *           [-46.653,-23.560],
 *           [-46.653,-23.543]
 *         ]]
 *       }
 *     }
 *   ]
 * };
 * var points = {
 *   "type": "FeatureCollection",
 *   "features": [
 *     {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6318, -23.5523]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6246, -23.5325]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.6062, -23.5513]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.663, -23.554]
 *       }
 *     }, {
 *       "type": "Feature",
 *       "properties": {},
 *       "geometry": {
 *         "type": "Point",
 *         "coordinates": [-46.643, -23.557]
 *       }
 *     }
 *   ]
 * };
 *
 * var ptsWithin = turf.within(points, searchWithin);
 *
 * //=points
 *
 * //=searchWithin
 *
 * //=ptsWithin
 */
module.exports = function (points, polygons) {
    var pointsWithin = featureCollection([]);
    for (var i = 0; i < polygons.features.length; i++) {
        for (var j = 0; j < points.features.length; j++) {
            var isInside = inside(points.features[j], polygons.features[i]);
            if (isInside) {
                pointsWithin.features.push(points.features[j]);
            }
        }
    }
    return pointsWithin;
};


/***/ }),

/***/ "./node_modules/turf/index.js":
/*!************************************!*\
  !*** ./node_modules/turf/index.js ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

/*eslint global-require: 0*/

/**
 * Turf is a modular geospatial analysis engine written in JavaScript. It performs geospatial
 * processing tasks with GeoJSON data and can be run on a server or in a browser.
 *
 * @module turf
 * @summary Geospatial analysis for JavaScript
 */
module.exports = {
    isolines: __webpack_require__(/*! turf-isolines */ "./node_modules/turf-isolines/index.js"),
    convex: __webpack_require__(/*! turf-convex */ "./node_modules/turf-convex/index.js"),
    within: __webpack_require__(/*! turf-within */ "./node_modules/turf-within/index.js"),
    concave: __webpack_require__(/*! turf-concave */ "./node_modules/turf-concave/index.js"),
    difference: __webpack_require__(/*! turf-difference */ "./node_modules/turf-difference/index.js"),
    collect: __webpack_require__(/*! turf-collect */ "./node_modules/turf-collect/index.js"),
    flip: __webpack_require__(/*! turf-flip */ "./node_modules/turf-flip/index.js"),
    simplify: __webpack_require__(/*! turf-simplify */ "./node_modules/turf-simplify/index.js"),
    bezier: __webpack_require__(/*! turf-bezier */ "./node_modules/turf-bezier/index.js"),
    tag: __webpack_require__(/*! turf-tag */ "./node_modules/turf-tag/index.js"),
    sample: __webpack_require__(/*! turf-sample */ "./node_modules/turf-sample/index.js"),
    envelope: __webpack_require__(/*! turf-envelope */ "./node_modules/turf-envelope/index.js"),
    square: __webpack_require__(/*! turf-square */ "./node_modules/turf-square/index.js"),
    midpoint: __webpack_require__(/*! turf-midpoint */ "./node_modules/turf-midpoint/index.js"),
    buffer: __webpack_require__(/*! turf-buffer */ "./node_modules/turf-buffer/index.js"),
    center: __webpack_require__(/*! turf-center */ "./node_modules/turf-center/index.js"),
    centroid: __webpack_require__(/*! turf-centroid */ "./node_modules/turf-centroid/index.js"),
    combine: __webpack_require__(/*! turf-combine */ "./node_modules/turf-combine/index.js"),
    distance: __webpack_require__(/*! turf-distance */ "./node_modules/turf-distance/index.js"),
    explode: __webpack_require__(/*! turf-explode */ "./node_modules/turf-explode/index.js"),
    bbox: __webpack_require__(/*! turf-bbox */ "./node_modules/turf-bbox/index.js"),
    tesselate: __webpack_require__(/*! turf-tesselate */ "./node_modules/turf-tesselate/index.js"),
    bboxPolygon: __webpack_require__(/*! turf-bbox-polygon */ "./node_modules/turf-bbox-polygon/index.js"),
    inside: __webpack_require__(/*! turf-inside */ "./node_modules/turf-inside/index.js"),
    intersect: __webpack_require__(/*! turf-intersect */ "./node_modules/turf-intersect/index.js"),
    nearest: __webpack_require__(/*! turf-nearest */ "./node_modules/turf-nearest/index.js"),
    planepoint: __webpack_require__(/*! turf-planepoint */ "./node_modules/turf-planepoint/index.js"),
    random: __webpack_require__(/*! turf-random */ "./node_modules/turf-random/index.js"),
    tin: __webpack_require__(/*! turf-tin */ "./node_modules/turf-tin/index.js"),
    union: __webpack_require__(/*! turf-union */ "./node_modules/turf-union/index.js"),
    bearing: __webpack_require__(/*! turf-bearing */ "./node_modules/turf-bearing/index.js"),
    destination: __webpack_require__(/*! turf-destination */ "./node_modules/turf-destination/index.js"),
    kinks: __webpack_require__(/*! turf-kinks */ "./node_modules/turf-kinks/index.js"),
    pointOnSurface: __webpack_require__(/*! turf-point-on-surface */ "./node_modules/turf-point-on-surface/index.js"),
    area: __webpack_require__(/*! turf-area */ "./node_modules/turf-area/index.js"),
    along: __webpack_require__(/*! turf-along */ "./node_modules/turf-along/index.js"),
    lineDistance: __webpack_require__(/*! turf-line-distance */ "./node_modules/turf-line-distance/index.js"),
    lineSlice: __webpack_require__(/*! turf-line-slice */ "./node_modules/turf-line-slice/index.js"),
    pointOnLine: __webpack_require__(/*! turf-point-on-line */ "./node_modules/turf-point-on-line/index.js"),
    pointGrid: __webpack_require__(/*! turf-point-grid */ "./node_modules/turf-point-grid/index.js"),
    squareGrid: __webpack_require__(/*! turf-square-grid */ "./node_modules/turf-square-grid/index.js"),
    triangleGrid: __webpack_require__(/*! turf-triangle-grid */ "./node_modules/turf-triangle-grid/index.js"),
    hexGrid: __webpack_require__(/*! turf-hex-grid */ "./node_modules/turf-hex-grid/index.js")
};

var helpers = __webpack_require__(/*! turf-helpers */ "./node_modules/turf-helpers/index.js");

module.exports.point = helpers.point;
module.exports.polygon = helpers.polygon;
module.exports.lineString = helpers.lineString;
module.exports.multiPoint = helpers.multiPoint;
module.exports.multiPolygon = helpers.multiPolygon;
module.exports.multiLineString = helpers.multiLineString;
module.exports.feature = helpers.feature;
module.exports.featureCollection = helpers.featureCollection;
module.exports.geometryCollection = helpers.geometryCollection;


/***/ }),

/***/ "./node_modules/two-product/two-product.js":
/*!*************************************************!*\
  !*** ./node_modules/two-product/two-product.js ***!
  \*************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = twoProduct

var SPLITTER = +(Math.pow(2, 27) + 1.0)

function twoProduct(a, b, result) {
  var x = a * b

  var c = SPLITTER * a
  var abig = c - a
  var ahi = c - abig
  var alo = a - ahi

  var d = SPLITTER * b
  var bbig = d - b
  var bhi = d - bbig
  var blo = b - bhi

  var err1 = x - (ahi * bhi)
  var err2 = err1 - (alo * bhi)
  var err3 = err2 - (ahi * blo)

  var y = alo * blo - err3

  if(result) {
    result[0] = y
    result[1] = x
    return result
  }

  return [ y, x ]
}

/***/ }),

/***/ "./node_modules/two-sum/two-sum.js":
/*!*****************************************!*\
  !*** ./node_modules/two-sum/two-sum.js ***!
  \*****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = fastTwoSum

function fastTwoSum(a, b, result) {
	var x = a + b
	var bv = x - a
	var av = x - bv
	var br = b - bv
	var ar = a - av
	if(result) {
		result[0] = ar + br
		result[1] = x
		return result
	}
	return [ar+br, x]
}

/***/ }),

/***/ "./node_modules/union-find/index.js":
/*!******************************************!*\
  !*** ./node_modules/union-find/index.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
 "use restrict";

module.exports = UnionFind;

function UnionFind(count) {
  this.roots = new Array(count);
  this.ranks = new Array(count);
  
  for(var i=0; i<count; ++i) {
    this.roots[i] = i;
    this.ranks[i] = 0;
  }
}

var proto = UnionFind.prototype

Object.defineProperty(proto, "length", {
  "get": function() {
    return this.roots.length
  }
})

proto.makeSet = function() {
  var n = this.roots.length;
  this.roots.push(n);
  this.ranks.push(0);
  return n;
}

proto.find = function(x) {
  var x0 = x
  var roots = this.roots;
  while(roots[x] !== x) {
    x = roots[x]
  }
  while(roots[x0] !== x) {
    var y = roots[x0]
    roots[x0] = x
    x0 = y
  }
  return x;
}

proto.link = function(x, y) {
  var xr = this.find(x)
    , yr = this.find(y);
  if(xr === yr) {
    return;
  }
  var ranks = this.ranks
    , roots = this.roots
    , xd    = ranks[xr]
    , yd    = ranks[yr];
  if(xd < yd) {
    roots[xr] = yr;
  } else if(yd < xd) {
    roots[yr] = xr;
  } else {
    roots[yr] = xr;
    ++ranks[xr];
  }
}

/***/ }),

/***/ "./node_modules/uuid/lib/bytesToUuid.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/bytesToUuid.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  // join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
  return ([
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]], '-',
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]],
    bth[buf[i++]], bth[buf[i++]]
  ]).join('');
}

module.exports = bytesToUuid;


/***/ }),

/***/ "./node_modules/uuid/lib/rng-browser.js":
/*!**********************************************!*\
  !*** ./node_modules/uuid/lib/rng-browser.js ***!
  \**********************************************/
/*! no static exports found */
/***/ (function(module, exports) {

// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection

// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var getRandomValues = (typeof(crypto) != 'undefined' && crypto.getRandomValues && crypto.getRandomValues.bind(crypto)) ||
                      (typeof(msCrypto) != 'undefined' && typeof window.msCrypto.getRandomValues == 'function' && msCrypto.getRandomValues.bind(msCrypto));

if (getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16); // eslint-disable-line no-undef

  module.exports = function whatwgRNG() {
    getRandomValues(rnds8);
    return rnds8;
  };
} else {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var rnds = new Array(16);

  module.exports = function mathRNG() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}


/***/ }),

/***/ "./node_modules/uuid/v1.js":
/*!*********************************!*\
  !*** ./node_modules/uuid/v1.js ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(/*! ./lib/rng */ "./node_modules/uuid/lib/rng-browser.js");
var bytesToUuid = __webpack_require__(/*! ./lib/bytesToUuid */ "./node_modules/uuid/lib/bytesToUuid.js");

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

var _nodeId;
var _clockseq;

// Previous uuid creation time
var _lastMSecs = 0;
var _lastNSecs = 0;

// See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};
  var node = options.node || _nodeId;
  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // node and clockseq need to be initialized to random values if they're not
  // specified.  We do this lazily to minimize issues related to insufficient
  // system entropy.  See #189
  if (node == null || clockseq == null) {
    var seedBytes = rng();
    if (node == null) {
      // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
      node = _nodeId = [
        seedBytes[0] | 0x01,
        seedBytes[1], seedBytes[2], seedBytes[3], seedBytes[4], seedBytes[5]
      ];
    }
    if (clockseq == null) {
      // Per 4.2.2, randomize (14 bit) clockseq
      clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
    }
  }

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),

/***/ "./node_modules/wgs84/index.js":
/*!*************************************!*\
  !*** ./node_modules/wgs84/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports) {

module.exports.RADIUS = 6378137;
module.exports.FLATTENING = 1/298.257223563;
module.exports.POLAR_RADIUS = 6356752.3142;


/***/ }),

/***/ "./src/app/App.ts":
/*!************************!*\
  !*** ./src/app/App.ts ***!
  \************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return App; });
/* harmony import */ var _engine_Engine__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/Engine */ "./src/engine/Engine.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasKeyboardAdaptor__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasKeyboardAdaptor */ "./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasMouseAdaptor__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasMouseAdaptor */ "./src/html5-canvas/HTML5CanvasMouseAdaptor.ts");
/* harmony import */ var _html5_canvas_HTML5CanvasViewportAdaptor__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../html5-canvas/HTML5CanvasViewportAdaptor */ "./src/html5-canvas/HTML5CanvasViewportAdaptor.ts");
/* harmony import */ var framework_presentation_systems_StyleSystem__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framework/presentation/systems/StyleSystem */ "./src/framework/presentation/systems/StyleSystem.ts");
/* harmony import */ var framework_presentation_systems_ImageSystem__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! framework/presentation/systems/ImageSystem */ "./src/framework/presentation/systems/ImageSystem.ts");
/* harmony import */ var framework_presentation_systems_LabelSystem__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! framework/presentation/systems/LabelSystem */ "./src/framework/presentation/systems/LabelSystem.ts");
/* harmony import */ var framework_presentation_systems_AnimatedImageSystem__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! framework/presentation/systems/AnimatedImageSystem */ "./src/framework/presentation/systems/AnimatedImageSystem.ts");
/* eslint-disable @typescript-eslint/no-unused-vars */








class App {
    constructor({ canvas }) {
        this.__viewport = new _html5_canvas_HTML5CanvasViewportAdaptor__WEBPACK_IMPORTED_MODULE_3__["default"](canvas);
        this.__mouse = new _html5_canvas_HTML5CanvasMouseAdaptor__WEBPACK_IMPORTED_MODULE_2__["default"](canvas);
        this.__keyboard = new _html5_canvas_HTML5CanvasKeyboardAdaptor__WEBPACK_IMPORTED_MODULE_1__["default"](canvas);
        this.__engine = new _engine_Engine__WEBPACK_IMPORTED_MODULE_0__["default"](this.__viewport);
        this.__initSystems();
        this.__initInputsHandlers();
    }
    load(src) {
        return this.__viewport.load(src);
    }
    create(EntityConstructor, data) {
        return this.__engine.entities.create(EntityConstructor, data);
    }
    start() {
        setInterval(this.__once.bind(this), 1000 / 240);
    }
    __once() {
        this.__mouse.once();
        this.__keyboard.once();
        this.__engine.once();
        this.__viewport.refresh();
        this.__engine.draw();
    }
    __initInputsHandlers() {
        const propagateMouseInput = (mouseEvent) => this.__engine.mouse = mouseEvent;
        this.__mouse.handler({
            mouseenter: propagateMouseInput,
            mousemove: propagateMouseInput,
            mouseleave: propagateMouseInput,
            mousedown: propagateMouseInput,
            mouseup: propagateMouseInput,
            click: propagateMouseInput,
            none: propagateMouseInput,
        });
        const propagateKeyboardInput = (keyboardEvent) => this.__engine.keyboard = keyboardEvent;
        this.__keyboard.handler({
            keydown: propagateKeyboardInput,
            keypress: propagateKeyboardInput,
            keyup: propagateKeyboardInput,
        });
    }
    __initSystems() {
        [
            // InteractiveSystem,
            framework_presentation_systems_StyleSystem__WEBPACK_IMPORTED_MODULE_4__["default"],
            framework_presentation_systems_ImageSystem__WEBPACK_IMPORTED_MODULE_5__["default"],
            framework_presentation_systems_LabelSystem__WEBPACK_IMPORTED_MODULE_6__["default"],
            framework_presentation_systems_AnimatedImageSystem__WEBPACK_IMPORTED_MODULE_7__["default"],
        ].forEach((SystemClass) => this.__engine.add(SystemClass));
    }
}


/***/ }),

/***/ "./src/app/contraptions/abstracts/Contraption.ts":
/*!*******************************************************!*\
  !*** ./src/app/contraptions/abstracts/Contraption.ts ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Contraption; });
/* harmony import */ var _ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../ui/abstracts/UIEntity */ "./src/app/ui/abstracts/UIEntity.ts");

class Contraption extends _ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super(...arguments);
        this.inputs = [];
        this.outputs = [];
    }
    $destroy() {
        super.$destroy();
        this.inputs.forEach((input) => input.$destroy());
        this.outputs.forEach((output) => output.$destroy());
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/Actuator.ts":
/*!************************************************!*\
  !*** ./src/app/contraptions/parts/Actuator.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Actuator; });
/* harmony import */ var _digital_logic_entities_InputTerminal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../digital-logic/entities/InputTerminal */ "./src/app/digital-logic/entities/InputTerminal.ts");

class Actuator extends _digital_logic_entities_InputTerminal__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({}) {
        super(Object.assign({ x: 0, y: 0 }, arguments[0]));
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/Claw.ts":
/*!********************************************!*\
  !*** ./src/app/contraptions/parts/Claw.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Claw; });
/* harmony import */ var _Actuator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Actuator */ "./src/app/contraptions/parts/Actuator.ts");
/* harmony import */ var _abstracts_Contraption__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../abstracts/Contraption */ "./src/app/contraptions/abstracts/Contraption.ts");
/* harmony import */ var _HorizontalThreadedAxle__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./HorizontalThreadedAxle */ "./src/app/contraptions/parts/HorizontalThreadedAxle.ts");
/* harmony import */ var _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./abstracts/MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");
/* harmony import */ var _framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../../framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");
/* harmony import */ var _framework_presentation_components_StyleComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../../framework/presentation/components/StyleComponent */ "./src/framework/presentation/components/StyleComponent.ts");
/* harmony import */ var _TouchActivator__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./TouchActivator */ "./src/app/contraptions/parts/TouchActivator.ts");
/* harmony import */ var _TouchSensor__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./TouchSensor */ "./src/app/contraptions/parts/TouchSensor.ts");








class Claw extends _abstracts_Contraption__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor({ x, y }) {
        super(arguments[0]);
        this.__wrist = this._$master.create(_abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_3__["default"], {
            x, y: y - 15,
            shape: {
                vertices: [
                    { x: 10, y: 5 },
                    { x: -10, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ],
            },
        });
        this.__palm = this._$master.create(_TouchActivator__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x, y: y + 10,
            shape: {
                vertices: [
                    { x: 10, y: 10 },
                    { x: -10, y: 10 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                ],
            },
        });
        this.__leftHub = this._$master.create(_TouchSensor__WEBPACK_IMPORTED_MODULE_7__["default"], {
            x: x - 52, y: y + 10,
            shape: {
                vertices: [
                    { x: 2, y: 10 },
                    { x: -2, y: 10 },
                    { x: -2, y: -10 },
                    { x: 2, y: -10 },
                ],
            },
            labelText: 'open-sensor',
        });
        this.__rightHub = this._$master.create(_abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_3__["default"], {
            x: x + 52, y: y + 10, shape: {
                vertices: [
                    { x: 2, y: 10 },
                    { x: -2, y: 10 },
                    { x: -2, y: -10 },
                    { x: 2, y: -10 },
                ],
            },
        });
        this.__leftThread = this._$master.create(_HorizontalThreadedAxle__WEBPACK_IMPORTED_MODULE_2__["default"], {
            x: x - 30, y: y + 10, width: 40, height: 20,
        });
        this.__rightThread = this._$master.create(_HorizontalThreadedAxle__WEBPACK_IMPORTED_MODULE_2__["default"], {
            x: x + 30, y: y + 10, width: 40, height: 20,
        });
        this.__leftTooth = this._$master.create(_TouchActivator__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x: x - 40, y: y + 10, shape: {
                vertices: [
                    { x: 10, y: 60 },
                    { x: -0, y: 60 },
                    { x: -0, y: 20 },
                    { x: -10, y: 20 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                ],
            },
        });
        this.__leftTooth.$patch(_framework_presentation_components_StyleComponent__WEBPACK_IMPORTED_MODULE_5__["default"])({ zIndex: 1 });
        this.__rightTooth = this._$master.create(_TouchSensor__WEBPACK_IMPORTED_MODULE_7__["default"], {
            x: x + 40, y: y + 10, shape: {
                vertices: [
                    { x: 0, y: 20 },
                    { x: 0, y: 60 },
                    { x: -10, y: 60 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                    { x: 10, y: 20 },
                ],
            },
            labelText: 'closed-sensor',
        });
        this.__rightTooth.$patch(_framework_presentation_components_StyleComponent__WEBPACK_IMPORTED_MODULE_5__["default"])({ zIndex: 1 });
        this.__openMotor = this._$master.create(_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'open',
        });
        this.__closeMotor = this._$master.create(_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'close',
        });
        this.inputs = [this.__openMotor, this.__closeMotor];
        this.outputs = [this.__leftHub.output, this.__rightTooth.output];
    }
    once() {
        if (this.__rightTooth.isHigh && this.__closeMotor.isHigh) {
            return this.off();
        }
        if (this.__leftHub.isHigh && this.__openMotor.isHigh) {
            return this.off();
        }
        if (this.__openMotor.isHigh && this.__closeMotor.isHigh) {
            return this.off();
        }
        if (this.__closeMotor.isHigh) {
            this.__leftThread.right();
            this.__rightThread.left();
            const leftToothPose = this.__leftTooth.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"]);
            const rightToothPose = this.__rightTooth.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"]);
            this.__leftTooth.$patch(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"])({
                x: leftToothPose.x + 1,
            });
            this.__rightTooth.$patch(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"])({
                x: rightToothPose.x - 1,
            });
        }
        if (this.__openMotor.isHigh) {
            this.__leftThread.left();
            this.__rightThread.right();
            const leftToothPose = this.__leftTooth.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"]);
            const rightToothPose = this.__rightTooth.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"]);
            this.__leftTooth.$patch(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"])({
                x: leftToothPose.x - 1,
            });
            this.__rightTooth.$patch(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_4__["default"])({
                x: rightToothPose.x + 1,
            });
        }
    }
    off() {
        this.__leftThread.off();
        this.__rightThread.off();
    }
    reset() {
        this.__wrist.reset();
        this.__palm.reset();
        this.__leftHub.reset();
        this.__rightHub.reset();
        this.__leftThread.reset();
        this.__rightThread.reset();
        this.__leftTooth.reset();
        this.__leftTooth.reset();
        this.__rightTooth.reset();
    }
    step(poseStep) {
        this.__wrist.step(poseStep);
        this.__palm.step(poseStep);
        this.__leftHub.step(poseStep);
        this.__rightHub.step(poseStep);
        this.__leftThread.step(poseStep);
        this.__rightThread.step(poseStep);
        this.__leftTooth.step(poseStep);
        this.__rightTooth.step(poseStep);
    }
    $destroy() {
        super.$destroy();
        this.__wrist.$destroy();
        this.__palm.$destroy();
        this.__leftHub.$destroy();
        this.__rightHub.$destroy();
        this.__leftThread.$destroy();
        this.__rightThread.$destroy();
        this.__leftTooth.$destroy();
        this.__rightTooth.$destroy();
        this.__openMotor.$destroy();
        this.__closeMotor.$destroy();
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/HorizontalThreadedAxle.ts":
/*!**************************************************************!*\
  !*** ./src/app/contraptions/parts/HorizontalThreadedAxle.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HorizontalThreadedAxle; });
/* harmony import */ var _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstracts/MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");
/* harmony import */ var framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! framework/presentation/components/AnimationComponent */ "./src/framework/presentation/components/AnimationComponent.ts");


class HorizontalThreadedAxle extends _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ x, y, width, height }) {
        super({ x, y });
        this.__threads = [];
        for (let i = 0, L = width / 10; i < L; i++) {
            const thread = this._$master.create(_abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__["default"], {
                x: x - width / 2 + i * 10 + 5,
                y: y,
            });
            thread.$add(framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_1__["default"])({
                images: [
                    './threaded-axle-1.png',
                    './threaded-axle-2.png',
                    './threaded-axle-3.png',
                    './threaded-axle-4.png',
                    './threaded-axle-5.png',
                    './threaded-axle-6.png',
                    './threaded-axle-7.png',
                    './threaded-axle-8.png',
                    './threaded-axle-9.png',
                    './threaded-axle-10.png',
                ].map((src) => ({ src, width: 10, height, opacity: 1, zIndex: 0 })),
                frame: 0,
                speed: 1,
                cooldown: 0,
                isPaused: true,
            });
            this.__threads.push(thread);
        }
    }
    left() {
        this.__threads.forEach((thread) => {
            thread.$patch(framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_1__["default"])({
                isPaused: false,
                isReversed: false,
            });
        });
    }
    right() {
        this.__threads.forEach((thread) => {
            thread.$patch(framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_1__["default"])({
                isPaused: false,
                isReversed: true,
            });
        });
    }
    off() {
        this.__threads.forEach((thread) => {
            thread.$patch(framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_1__["default"])({
                isPaused: true,
            });
        });
    }
    step(poseStep) {
        super.step(poseStep);
        this.__threads.forEach((thread) => {
            thread.step(poseStep);
        });
    }
    reset() {
        super.reset();
        this.__threads.forEach((thread) => {
            thread.reset();
        });
    }
    $destroy() {
        super.$destroy();
        this.__threads.forEach((thread) => {
            thread.$destroy();
        });
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/TouchActivator.ts":
/*!******************************************************!*\
  !*** ./src/app/contraptions/parts/TouchActivator.ts ***!
  \******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TouchActivator; });
/* harmony import */ var _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstracts/MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");

class TouchActivator extends _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/app/contraptions/parts/TouchSensor.ts":
/*!***************************************************!*\
  !*** ./src/app/contraptions/parts/TouchSensor.ts ***!
  \***************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TouchSensor; });
/* harmony import */ var _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstracts/MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");
/* harmony import */ var _digital_logic_entities_OutputTerminal__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../digital-logic/entities/OutputTerminal */ "./src/app/digital-logic/entities/OutputTerminal.ts");
/* harmony import */ var _TouchActivator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./TouchActivator */ "./src/app/contraptions/parts/TouchActivator.ts");
/* harmony import */ var _framework_helpers_entities__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../framework/helpers/entities */ "./src/framework/helpers/entities.ts");




class TouchSensor extends _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ labelText }) {
        super(arguments[0]);
        this.output = this._$master.create(_digital_logic_entities_OutputTerminal__WEBPACK_IMPORTED_MODULE_1__["default"], { x: 0, y: 0, labelText });
    }
    get isHigh() {
        return this.output.isHigh;
    }
    get isLow() {
        return this.output.isLow;
    }
    get isOff() {
        return this.output.isOff;
    }
    once() {
        const target = this._$master.find(_TouchActivator__WEBPACK_IMPORTED_MODULE_2__["default"])((activator) => {
            return Object(_framework_helpers_entities__WEBPACK_IMPORTED_MODULE_3__["entitiesTouch"])(this, activator);
        });
        if (target) {
            this.output.high();
        }
        else {
            this.output.low();
        }
    }
    $destroy() {
        super.$destroy();
        this.output.$destroy();
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/VerticalThreadedAxle.ts":
/*!************************************************************!*\
  !*** ./src/app/contraptions/parts/VerticalThreadedAxle.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return VerticalThreadedAxle; });
/* harmony import */ var _framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/presentation/components/AnimationComponent */ "./src/framework/presentation/components/AnimationComponent.ts");
/* harmony import */ var _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./abstracts/MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");


class VerticalThreadedAxle extends _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor({ x, y, width, height }) {
        super({ x, y });
        this.__threads = [];
        for (let i = 0, L = height / 10; i < L; i++) {
            const thread = this._$master.create(_abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_1__["default"], {
                x,
                y: y - height / 2 + i * 10 + 5,
            });
            thread.$add(_framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({
                images: [
                    './threaded-axle-1.png',
                    './threaded-axle-2.png',
                    './threaded-axle-3.png',
                    './threaded-axle-4.png',
                    './threaded-axle-5.png',
                    './threaded-axle-6.png',
                    './threaded-axle-7.png',
                    './threaded-axle-8.png',
                    './threaded-axle-9.png',
                    './threaded-axle-10.png',
                ].map((src) => ({ src, width: 10, height: width, rotate: -Math.PI / 2, opacity: 1, zIndex: 0 })),
                frame: 0,
                speed: 1,
                cooldown: 0,
                isPaused: true,
            });
            this.__threads.push(thread);
        }
    }
    up() {
        this.__animate({ isPaused: false, isReversed: true });
    }
    down() {
        this.__animate({ isPaused: false, isReversed: false });
    }
    off() {
        this.__animate({ isPaused: true });
    }
    step(poseStep) {
        this.__all(this.step.name, poseStep);
    }
    reset() {
        this.__all(this.reset.name);
    }
    $destroy() {
        this.__all(this.$destroy.name);
    }
    __animate(settings) {
        this.__threads.forEach((thread) => thread.$patch(_framework_presentation_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_0__["default"])(settings));
    }
    __all(methodName, arg) {
        _abstracts_MachinePart__WEBPACK_IMPORTED_MODULE_1__["default"].prototype[methodName].call(this, arg);
        this.__threads.forEach((thread) => thread[methodName](arg));
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/abstracts/MachinePart.ts":
/*!*************************************************************!*\
  !*** ./src/app/contraptions/parts/abstracts/MachinePart.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MachinePart; });
/* harmony import */ var _framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");
/* harmony import */ var app_ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! app/ui/abstracts/UIEntity */ "./src/app/ui/abstracts/UIEntity.ts");


class MachinePart extends app_ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor(template) {
        super(template);
        this.__initialPose = this.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_0__["default"]);
    }
    reset() {
        this.$mutate(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_0__["default"])(this.__initialPose);
    }
    step(poseStep) {
        const pose = this.$copy(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_0__["default"]);
        pose.x += poseStep.x || 0;
        pose.y += poseStep.y || 0;
        pose.a += poseStep.a || 0;
        this.$mutate(_framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_0__["default"])(pose);
    }
}


/***/ }),

/***/ "./src/app/contraptions/parts/abstracts/Prize.ts":
/*!*******************************************************!*\
  !*** ./src/app/contraptions/parts/abstracts/Prize.ts ***!
  \*******************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return MachineTarget; });
/* harmony import */ var _MachinePart__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./MachinePart */ "./src/app/contraptions/parts/abstracts/MachinePart.ts");

class MachineTarget extends _MachinePart__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({}) {
        super(arguments[0]);
    }
}


/***/ }),

/***/ "./src/app/contraptions/the-claw/TheClaw.ts":
/*!**************************************************!*\
  !*** ./src/app/contraptions/the-claw/TheClaw.ts ***!
  \**************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return TheClaw; });
/* harmony import */ var _parts_Actuator__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../parts/Actuator */ "./src/app/contraptions/parts/Actuator.ts");
/* harmony import */ var _parts_Claw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../parts/Claw */ "./src/app/contraptions/parts/Claw.ts");
/* harmony import */ var _abstracts_Contraption__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../abstracts/Contraption */ "./src/app/contraptions/abstracts/Contraption.ts");
/* harmony import */ var _parts_HorizontalThreadedAxle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../parts/HorizontalThreadedAxle */ "./src/app/contraptions/parts/HorizontalThreadedAxle.ts");
/* harmony import */ var _parts_abstracts_Prize__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../parts/abstracts/Prize */ "./src/app/contraptions/parts/abstracts/Prize.ts");
/* harmony import */ var _parts_TouchActivator__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../parts/TouchActivator */ "./src/app/contraptions/parts/TouchActivator.ts");
/* harmony import */ var _parts_TouchSensor__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../parts/TouchSensor */ "./src/app/contraptions/parts/TouchSensor.ts");
/* harmony import */ var _parts_VerticalThreadedAxle__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ../parts/VerticalThreadedAxle */ "./src/app/contraptions/parts/VerticalThreadedAxle.ts");








class TheClaw extends _abstracts_Contraption__WEBPACK_IMPORTED_MODULE_2__["default"] {
    constructor({ x, y }) {
        super(arguments[0]);
        this.__horizontalRail = this._$master.create(_parts_HorizontalThreadedAxle__WEBPACK_IMPORTED_MODULE_3__["default"], { x, y, width: 300, height: 20 });
        this.__carriage = this._$master.create(_parts_TouchActivator__WEBPACK_IMPORTED_MODULE_5__["default"], {
            x: x - 130, y,
            shape: {
                vertices: [
                    { x: 20, y: 30 },
                    { x: -20, y: 30 },
                    { x: -20, y: -30 },
                    { x: 20, y: -30 },
                ],
            },
            style: { colour: 'WHITE', opacity: 1, fill: 'rgba(0,0,0,0)', zIndex: 1 },
        });
        this.__verticalRail = this._$master.create(_parts_VerticalThreadedAxle__WEBPACK_IMPORTED_MODULE_7__["default"], {
            x: x - 130, y, width: 20, height: 200,
        });
        this.__leftSensor = this._$master.create(_parts_TouchSensor__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x: x - 170, y,
            shape: {
                vertices: [
                    { x: 20, y: 20 },
                    { x: -20, y: 20 },
                    { x: -20, y: -20 },
                    { x: 20, y: -20 },
                ],
            },
            labelText: 'left-sensor',
        });
        this.__rightSensor = this._$master.create(_parts_TouchSensor__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x: x + 170, y,
            shape: {
                vertices: [
                    { x: 20, y: 20 },
                    { x: -20, y: 20 },
                    { x: -20, y: -20 },
                    { x: 20, y: -20 },
                ],
            },
            labelText: 'right-sensor',
        });
        this.__topSensor = this._$master.create(_parts_TouchSensor__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x: x - 130, y: y - 105,
            shape: {
                vertices: [
                    { x: 20, y: 5 },
                    { x: -20, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ],
            },
            labelText: 'top-sensor',
        });
        this.__bottomSensor = this._$master.create(_parts_TouchSensor__WEBPACK_IMPORTED_MODULE_6__["default"], {
            x: x - 130, y: y + 105,
            shape: {
                vertices: [
                    { x: 20, y: 5 },
                    { x: -20, y: 5 },
                    { x: -20, y: -5 },
                    { x: 20, y: -5 },
                ],
            },
            labelText: 'bottom-sensor',
        });
        this.__leftMotor = this._$master.create(_parts_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'move-left',
        });
        this.__rightMotor = this._$master.create(_parts_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'move-right',
        });
        this.__topMotor = this._$master.create(_parts_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'move-up',
        });
        this.__bottomMotor = this._$master.create(_parts_Actuator__WEBPACK_IMPORTED_MODULE_0__["default"], {
            labelText: 'move-down',
        });
        this.__claw = this._$master.create(_parts_Claw__WEBPACK_IMPORTED_MODULE_1__["default"], {
            x: x - 130, y: y + 130,
        });
        this.__prize = this._$master.create(_parts_abstracts_Prize__WEBPACK_IMPORTED_MODULE_4__["default"], {
            x: x + 130,
            y: y + 250,
            shape: {
                vertices: [
                    { x: 10, y: 20 },
                    { x: -10, y: 20 },
                    { x: -10, y: -20 },
                    { x: 10, y: -20 },
                ],
            },
        });
        this.inputs = [
            this.__leftMotor,
            this.__topMotor,
            this.__claw.inputs[0],
            this.__rightMotor,
            this.__bottomMotor,
            this.__claw.inputs[1],
        ];
        this.outputs = [
            this.__leftSensor.output,
            this.__bottomSensor.output,
            this.__claw.outputs[1],
            this.__rightSensor.output,
            this.__topSensor.output,
            this.__claw.outputs[0],
        ];
    }
    once() {
        this.__updateHorizontalState();
        this.__updateVerticalState();
    }
    off() {
        this.__offX();
        this.__offY();
    }
    reset() {
        this.__horizontalRail.reset();
        this.__carriage.reset();
        this.__verticalRail.reset();
        this.__leftSensor.reset();
        this.__rightSensor.reset();
        this.__topSensor.reset();
        this.__bottomSensor.reset();
        this.__claw.reset();
    }
    $destroy() {
        super.$destroy();
        this.__horizontalRail.$destroy();
        this.__verticalRail.$destroy();
        this.__carriage.$destroy();
        this.__leftMotor.$destroy();
        this.__rightMotor.$destroy();
        this.__topMotor.$destroy();
        this.__bottomMotor.$destroy();
        this.__leftSensor.$destroy();
        this.__rightSensor.$destroy();
        this.__topSensor.$destroy();
        this.__bottomSensor.$destroy();
        this.__claw.$destroy();
        this.__prize.$destroy();
    }
    __updateHorizontalState() {
        if (this.__leftMotor.isHigh && this.__rightMotor.isHigh) {
            return this.__offX();
        }
        if (this.__leftMotor.isLow && this.__rightMotor.isLow) {
            return this.__offX();
        }
        if (this.__leftMotor.isHigh) {
            if (this.__leftSensor.isHigh) {
                return this.__offX();
            }
            return this.__left();
        }
        if (this.__rightMotor.isHigh) {
            if (this.__rightSensor.isHigh) {
                return this.__offX();
            }
            return this.__right();
        }
        return this.__offX();
    }
    __updateVerticalState() {
        if (this.__topMotor.isHigh && this.__bottomMotor.isHigh) {
            return this.__offY();
        }
        if (this.__topMotor.isLow && this.__bottomMotor.isLow) {
            return this.__offY();
        }
        if (this.__topMotor.isHigh) {
            if (this.__bottomSensor.isHigh) {
                return this.__offY();
            }
            return this.__up();
        }
        if (this.__bottomMotor.isHigh) {
            if (this.__topSensor.isHigh) {
                return this.__offY();
            }
            return this.__down();
        }
        return this.__offY();
    }
    __left() {
        this.__carriage.step({ x: -1 });
        this.__verticalRail.step({ x: -1 });
        this.__topSensor.step({ x: -1 });
        this.__bottomSensor.step({ x: -1 });
        this.__horizontalRail.left();
        this.__claw.step({ x: -1 });
    }
    __right() {
        this.__carriage.step({ x: 1 });
        this.__verticalRail.step({ x: 1 });
        this.__topSensor.step({ x: 1 });
        this.__bottomSensor.step({ x: 1 });
        this.__horizontalRail.right();
        this.__claw.step({ x: 1 });
    }
    __up() {
        this.__verticalRail.step({ y: -1 });
        this.__topSensor.step({ y: -1 });
        this.__bottomSensor.step({ y: -1 });
        this.__verticalRail.up();
        this.__claw.step({ y: -1 });
    }
    __down() {
        this.__verticalRail.step({ y: 1 });
        this.__topSensor.step({ y: 1 });
        this.__bottomSensor.step({ y: 1 });
        this.__verticalRail.down();
        this.__claw.step({ y: 1 });
    }
    __offX() {
        this.__carriage.step({ x: 0 });
        this.__verticalRail.step({ x: 0 });
        this.__topSensor.step({ x: 0 });
        this.__bottomSensor.step({ x: 0 });
        this.__horizontalRail.off();
        this.__claw.step({ x: 0 });
    }
    __offY() {
        this.__verticalRail.step({ y: 0 });
        this.__topSensor.step({ y: 0 });
        this.__bottomSensor.step({ y: 0 });
        this.__verticalRail.off();
        this.__claw.step({ y: 0 });
    }
}


/***/ }),

/***/ "./src/app/digital-logic/entities/InputTerminal.ts":
/*!*********************************************************!*\
  !*** ./src/app/digital-logic/entities/InputTerminal.ts ***!
  \*********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InputTerminal; });
/* harmony import */ var _abstracts_Terminal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstracts/Terminal */ "./src/app/digital-logic/entities/abstracts/Terminal.ts");

class InputTerminal extends _abstracts_Terminal__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({}) {
        super(Object.assign({ src: './Terminal_in.png' }, arguments[0]));
    }
}


/***/ }),

/***/ "./src/app/digital-logic/entities/OutputTerminal.ts":
/*!**********************************************************!*\
  !*** ./src/app/digital-logic/entities/OutputTerminal.ts ***!
  \**********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return OutputTerminal; });
/* harmony import */ var _abstracts_Terminal__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./abstracts/Terminal */ "./src/app/digital-logic/entities/abstracts/Terminal.ts");

class OutputTerminal extends _abstracts_Terminal__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({}) {
        super(Object.assign({ src: './Terminal_out.png' }, arguments[0]));
    }
}


/***/ }),

/***/ "./src/app/digital-logic/entities/abstracts/Terminal.ts":
/*!**************************************************************!*\
  !*** ./src/app/digital-logic/entities/abstracts/Terminal.ts ***!
  \**************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Terminal; });
/* harmony import */ var _framework_presentation_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../../framework/presentation/components/ImageComponent */ "./src/framework/presentation/components/ImageComponent.ts");
/* harmony import */ var _framework_presentation_components_LabelComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../../framework/presentation/components/LabelComponent */ "./src/framework/presentation/components/LabelComponent.ts");
/* harmony import */ var _enums_STATE__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../enums/STATE */ "./src/app/digital-logic/enums/STATE.ts");
/* harmony import */ var _ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../../ui/abstracts/UIEntity */ "./src/app/ui/abstracts/UIEntity.ts");




const LABEL_COLOUR_MAP = {
    [_enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].HIGH]: 'GREEN',
    [_enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].LOW]: 'RED',
    [_enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].OFF]: 'WHITE',
};
class Terminal extends _ui_abstracts_UIEntity__WEBPACK_IMPORTED_MODULE_3__["default"] {
    constructor({ x, y, src, labelText }) {
        super(Object.assign({
            pose: { x, y, a: 0 },
            width: 20,
            height: 20,
            label: labelText ? {
                text: labelText,
                fontSize: 20,
                offset: { x: 15, y: 7 },
                colour: 'WHITE',
                fill: 'rgba(0,0,0,0)',
                opacity: 1,
                zIndex: 0,
            } : undefined,
            image: {
                src,
                opacity: 1,
                zIndex: 0,
            },
        }, arguments[0]));
        this.__s = _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].OFF;
        this.__src = src;
    }
    get isHigh() {
        return this.__s === _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].HIGH;
    }
    get isLow() {
        return this.__s === _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].LOW;
    }
    get isOff() {
        return this.__s === _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].OFF;
    }
    get __state() {
        return this.__s;
    }
    set __state(state) {
        this.__s = state;
        this.$patch(_framework_presentation_components_LabelComponent__WEBPACK_IMPORTED_MODULE_1__["default"])({
            colour: LABEL_COLOUR_MAP[state],
        });
    }
    high() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].HIGH;
    }
    low() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].LOW;
    }
    off() {
        this.__state = _enums_STATE__WEBPACK_IMPORTED_MODULE_2__["STATE"].OFF;
    }
    $mouseenter() {
        this.$patch(_framework_presentation_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({ src: './Terminal_hovered.png' });
    }
    $mouseleave() {
        this.$patch(_framework_presentation_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({ src: this.__src });
    }
    $mousemove() {
        //
    }
    $mousedown() {
        //
    }
    $mouseup() {
        //
    }
    $click() {
        //
    }
}


/***/ }),

/***/ "./src/app/digital-logic/enums/STATE.ts":
/*!**********************************************!*\
  !*** ./src/app/digital-logic/enums/STATE.ts ***!
  \**********************************************/
/*! exports provided: STATE */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "STATE", function() { return STATE; });
var STATE;
(function (STATE) {
    STATE[STATE["HIGH"] = 0] = "HIGH";
    STATE[STATE["LOW"] = 1] = "LOW";
    STATE[STATE["OFF"] = 2] = "OFF";
})(STATE || (STATE = {}));


/***/ }),

/***/ "./src/app/main.ts":
/*!*************************!*\
  !*** ./src/app/main.ts ***!
  \*************************/
/*! no exports provided */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _App__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./App */ "./src/app/App.ts");
/* harmony import */ var _contraptions_the_claw_TheClaw__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./contraptions/the-claw/TheClaw */ "./src/app/contraptions/the-claw/TheClaw.ts");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! jquery */ "./node_modules/jquery/dist/jquery.js");
/* harmony import */ var jquery__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(jquery__WEBPACK_IMPORTED_MODULE_2__);
/* eslint-disable @typescript-eslint/no-unused-vars */



const canvas = jquery__WEBPACK_IMPORTED_MODULE_2___default()('#app-target').get(0);
canvas.focus();
canvas.width = 1280;
canvas.height = 680;
const app = new _App__WEBPACK_IMPORTED_MODULE_0__["default"]({ canvas });
[
    './threaded-axle-1.png',
    './threaded-axle-2.png',
    './threaded-axle-3.png',
    './threaded-axle-4.png',
    './threaded-axle-5.png',
    './threaded-axle-6.png',
    './threaded-axle-7.png',
    './threaded-axle-8.png',
    './threaded-axle-9.png',
    './threaded-axle-10.png',
].forEach((src) => app.load(src));
// app.create(HorizontalThreadedAxle, { x: 1040, y: 340, width: 300, height: 20 });
const claw = app.create(_contraptions_the_claw_TheClaw__WEBPACK_IMPORTED_MODULE_1__["default"], { x: 1040, y: 340 });
// app.create(EditorView, { contraption: claw });
app.start();


/***/ }),

/***/ "./src/app/ui/abstracts/UIEntity.ts":
/*!******************************************!*\
  !*** ./src/app/ui/abstracts/UIEntity.ts ***!
  \******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return UIEntity; });
/* harmony import */ var _framework_presentation_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../../framework/presentation/components/ImageComponent */ "./src/framework/presentation/components/ImageComponent.ts");
/* harmony import */ var _framework_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../framework/geometry/components/ShapeComponent */ "./src/framework/geometry/components/ShapeComponent.ts");
/* harmony import */ var _framework_presentation_components_StyleComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../../framework/presentation/components/StyleComponent */ "./src/framework/presentation/components/StyleComponent.ts");
/* harmony import */ var framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");
/* harmony import */ var framework_interactive_InteractiveEntity__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! framework/interactive/InteractiveEntity */ "./src/framework/interactive/InteractiveEntity.ts");
/* harmony import */ var framework_presentation_components_LabelComponent__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! framework/presentation/components/LabelComponent */ "./src/framework/presentation/components/LabelComponent.ts");






const componentKeyMap = {
    pose: framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_3__["default"],
    shape: _framework_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_1__["default"],
    style: _framework_presentation_components_StyleComponent__WEBPACK_IMPORTED_MODULE_2__["default"],
    label: framework_presentation_components_LabelComponent__WEBPACK_IMPORTED_MODULE_5__["default"],
    image: _framework_presentation_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__["default"],
};
const applyEntityTemplateToEntity = (template, entity) => {
    Object.keys(componentKeyMap).forEach((key) => {
        const data = template[key];
        if (!data) {
            return;
        }
        entity.$add(componentKeyMap[key])(data);
    });
};
class UIEntity extends framework_interactive_InteractiveEntity__WEBPACK_IMPORTED_MODULE_4__["default"] {
    constructor(template) {
        super();
        template.pose = { x: template.x, y: template.y, a: 0 };
        if ((template.width && template.height)) {
            template.shape = {
                vertices: [
                    { x: template.width / 2, y: template.height / 2 },
                    { x: -template.width / 2, y: template.height / 2 },
                    { x: -template.width / 2, y: -template.height / 2 },
                    { x: template.width / 2, y: -template.height / 2 },
                ],
            };
        }
        if (template.shape) {
            template.style = { colour: 'WHITE', opacity: 1, fill: 'rgba(0,0,0,0)', zIndex: 0 };
        }
        applyEntityTemplateToEntity(template, this);
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    $mousemove(e) {
        //
    }
    $mouseenter(e) {
        //
    }
    $mouseleave(e) {
        //
    }
    $mousedown(e) {
        //
    }
    $mouseup(e) {
        //
    }
    $click(e) {
        //
    }
}


/***/ }),

/***/ "./src/engine/ComponentMaster.ts":
/*!***************************************!*\
  !*** ./src/engine/ComponentMaster.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ComponentMaster; });
/* harmony import */ var foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! foundation/concretes/Dictionary */ "./src/foundation/concretes/Dictionary.ts");

class ComponentMaster {
    constructor() {
        this.__componentMap = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]();
    }
    create(entity, ComponentConstructor, data) {
        let collection = this.__componentMap.read(ComponentConstructor.name);
        if (!collection) {
            collection = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_0__["default"]();
            this.__componentMap.write({
                key: ComponentConstructor.name,
                value: collection,
            });
        }
        const component = new ComponentConstructor({ data, entity });
        collection.write({
            key: component.id,
            value: component,
        });
        return component;
    }
    destroy(component) {
        if (!this.__componentMap.read(component.constructor.name)) {
            return;
        }
        return this.__componentMap.read(component.constructor.name).delete(component.id);
    }
    forEvery(ComponentCls) {
        const collection = this.__componentMap.read(ComponentCls.name);
        return collection ? collection.forEach.bind(collection) : () => undefined;
    }
}


/***/ }),

/***/ "./src/engine/Engine.ts":
/*!******************************!*\
  !*** ./src/engine/Engine.ts ***!
  \******************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Engine; });
/* harmony import */ var _EntityMaster__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./EntityMaster */ "./src/engine/EntityMaster.ts");
/* harmony import */ var foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! foundation/concretes/Dictionary */ "./src/foundation/concretes/Dictionary.ts");


class Engine {
    constructor(viewport) {
        this.viewport = viewport;
        this.entities = new _EntityMaster__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.__systems = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.__t = new Date();
    }
    get components() {
        return this.entities.componentMaster;
    }
    once() {
        const now = new Date();
        this.delta = now.getTime() - this.__t.getTime();
        this.__t = now;
        this.__systems.forEach((system) => system.once());
        this.entities.once();
    }
    draw() {
        this.__systems.forEach((system) => system.draw());
        this.viewport.once();
    }
    add(SystemClass) {
        this.__systems.write({
            key: SystemClass.name,
            value: new SystemClass(this),
        });
    }
    remove(SystemClass) {
        this.__systems.delete(SystemClass.name);
    }
}


/***/ }),

/***/ "./src/engine/Entity.ts":
/*!******************************!*\
  !*** ./src/engine/Entity.ts ***!
  \******************************/
/*! exports provided: IOC, default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IOC", function() { return IOC; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Entity; });
/* harmony import */ var foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! foundation/abstracts/Unique */ "./src/foundation/abstracts/Unique.ts");
/* harmony import */ var foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! foundation/concretes/Dictionary */ "./src/foundation/concretes/Dictionary.ts");


const IOC = {
    master: undefined,
};
class Entity extends foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor() {
        super();
        this.__components = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.__master__(IOC.master);
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    __master__(master) {
        this.__master = master;
    }
    get _$master() {
        return this.__master;
    }
    $destroy() {
        return this._$master.destroy(this);
    }
    $add(ComponentClass) {
        return (data) => {
            if (!this.__components.read(ComponentClass.name)) {
                this.__components.write({
                    key: ComponentClass.name,
                    value: this._$master.componentMaster.create(this, ComponentClass, data),
                });
            }
        };
    }
    $remove(ComponentClass) {
        if (!this.__components.read(ComponentClass.name)) {
            return;
        }
        this._$master.componentMaster.destroy(this.__components.read(ComponentClass.name));
        this.__components.delete(ComponentClass.name);
    }
    $copy(ComponentClass) {
        return this.__components.read(ComponentClass.name).copy();
    }
    $mutate(ComponentClass) {
        return (data) => this.__components.read(ComponentClass.name).mutate(data);
    }
    $patch(ComponentClass) {
        return (data) => this.__components.read(ComponentClass.name).patch(data);
    }
    $forEach(fn) {
        return this.__components.forEach(fn);
    }
}


/***/ }),

/***/ "./src/engine/EntityMaster.ts":
/*!************************************!*\
  !*** ./src/engine/EntityMaster.ts ***!
  \************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return EntityMaster; });
/* harmony import */ var _ComponentMaster__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./ComponentMaster */ "./src/engine/ComponentMaster.ts");
/* harmony import */ var foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! foundation/concretes/Dictionary */ "./src/foundation/concretes/Dictionary.ts");
/* harmony import */ var _Entity__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Entity */ "./src/engine/Entity.ts");



class EntityMaster {
    constructor() {
        this.componentMaster = new _ComponentMaster__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.__entityMap = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__["default"]();
        this.__cTargets = [];
        this.__dTargets = [];
        _Entity__WEBPACK_IMPORTED_MODULE_2__["IOC"].master = this;
    }
    create(EntityConstructor, data) {
        const instance = new EntityConstructor(data);
        this.__cTargets.push(instance);
        return instance;
    }
    destroy(entity) {
        this.__dTargets.push(entity);
    }
    forEvery(EntityCls) {
        const collection = this.__entityMap.read(EntityCls.name);
        return collection ? collection.forEach.bind(collection) : () => undefined;
    }
    find(EntityCls) {
        return (fn) => {
            const result = this.__entityMap.read(EntityCls.name).find(fn);
            if (result) {
                return result;
            }
            return undefined;
        };
    }
    once() {
        this.__createTargets();
        this.__destroyTargets();
    }
    __createTargets() {
        while (this.__cTargets.length) {
            const instance = this.__cTargets.shift();
            let target = instance;
            while (target) {
                let collection = this.__entityMap.read(target.constructor.name);
                if (!collection) {
                    collection = new foundation_concretes_Dictionary__WEBPACK_IMPORTED_MODULE_1__["default"]();
                    this.__entityMap.write({
                        key: target.constructor.name,
                        value: collection,
                    });
                }
                collection.write({ key: instance.id, value: instance });
                target = target.__proto__;
            }
        }
    }
    __destroyTargets() {
        while (this.__dTargets.length) {
            const entity = this.__dTargets.shift();
            entity.$forEach((component) => {
                this.componentMaster.destroy(component);
            });
            let target = entity;
            while (target) {
                this.__entityMap.read(target.constructor.name).delete(entity.id);
                target = target.__proto__;
            }
        }
    }
}


/***/ }),

/***/ "./src/engine/KeyboardHandler.ts":
/*!***************************************!*\
  !*** ./src/engine/KeyboardHandler.ts ***!
  \***************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return KeyboardHandler; });
class KeyboardHandler {
    // constructor() {
    //   this.keydowns = {};
    //   this.keypresses = {};
    //   this.keyups = {};
    // }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    keydown(keyboardEvent) {
        // this.__handle(keyboardEvent, this.keydowns);
    }
    keypress(keyboardEvent) {
        // this.__handle(keyboardEvent, this.keypresses);
    }
    keyup(keyboardEvent) {
        // this.__handle(keyboardEvent, this.keyups);
    }
}


/***/ }),

/***/ "./src/engine/abstracts/Component.ts":
/*!*******************************************!*\
  !*** ./src/engine/abstracts/Component.ts ***!
  \*******************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Component; });
/* harmony import */ var foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! foundation/abstracts/Unique */ "./src/foundation/abstracts/Unique.ts");

class Component extends foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor({ data, entity }) {
        super();
        this.$entity = entity;
        this.mutate(data);
    }
    copy() {
        return this.__clone(this.__data);
    }
    mutate(data) {
        this.__data = this.__clone(data);
    }
    patch(data) {
        this.mutate(Object.assign(this.copy(), data));
    }
    __clone(data) {
        return JSON.parse(JSON.stringify(data));
    }
}


/***/ }),

/***/ "./src/engine/abstracts/System.ts":
/*!****************************************!*\
  !*** ./src/engine/abstracts/System.ts ***!
  \****************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return System; });
/* harmony import */ var foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! foundation/abstracts/Unique */ "./src/foundation/abstracts/Unique.ts");

class System extends foundation_abstracts_Unique__WEBPACK_IMPORTED_MODULE_0__["default"] {
    constructor($engine) {
        super();
        this.$engine = $engine;
    }
    once() { return; }
    draw() { return; }
}


/***/ }),

/***/ "./src/foundation/abstracts/Unique.ts":
/*!********************************************!*\
  !*** ./src/foundation/abstracts/Unique.ts ***!
  \********************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Unique; });
const uuidv1 = __webpack_require__(/*! uuid/v1 */ "./node_modules/uuid/v1.js");
class Unique {
    constructor(id) {
        this.__id__(id || Unique.generateUuid());
    }
    static generateUuid() {
        return uuidv1();
    }
    get id() {
        return this.__id;
    }
    // eslint-disable-next-line @typescript-eslint/naming-convention
    __id__(id) {
        this.__id = id;
    }
}


/***/ }),

/***/ "./src/foundation/concretes/Dictionary.ts":
/*!************************************************!*\
  !*** ./src/foundation/concretes/Dictionary.ts ***!
  \************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Dictionary; });
class Dictionary {
    constructor() {
        this.__data = {};
    }
    get length() {
        return Object.keys(this.__data).length;
    }
    read(key) {
        return this.__data[key];
    }
    write({ key, value }) {
        this.__data[key] = value;
    }
    delete(key) {
        delete this.__data[key];
    }
    find(fn) {
        const key = Object.keys(this.__data).find((k) => fn(this.__data[k]));
        return this.__data[key || -1];
    }
    forEach(fn) {
        Object.keys(this.__data).forEach((key) => {
            if (this.__data[key]) {
                fn(this.__data[key]);
            }
        });
    }
    toArray() {
        return Object.keys(this.__data).map((key) => {
            return this.__data[key];
        }).filter((target) => !!target);
    }
}


/***/ }),

/***/ "./src/framework/geometry/components/PoseComponent.ts":
/*!************************************************************!*\
  !*** ./src/framework/geometry/components/PoseComponent.ts ***!
  \************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return PoseComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class PoseComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/geometry/components/ShapeComponent.ts":
/*!*************************************************************!*\
  !*** ./src/framework/geometry/components/ShapeComponent.ts ***!
  \*************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ShapeComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class ShapeComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/helpers/entities.ts":
/*!*******************************************!*\
  !*** ./src/framework/helpers/entities.ts ***!
  \*******************************************/
/*! exports provided: entityContainsPoint, entitiesTouch, entityContainsEntity, entityTouchesLine */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityContainsPoint", function() { return entityContainsPoint; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entitiesTouch", function() { return entitiesTouch; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityContainsEntity", function() { return entityContainsEntity; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "entityTouchesLine", function() { return entityTouchesLine; });
/* harmony import */ var _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @turf/boolean-contains */ "./node_modules/@turf/boolean-contains/index.js");
/* harmony import */ var _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @turf/boolean-point-in-polygon */ "./node_modules/@turf/boolean-point-in-polygon/index.js");
/* harmony import */ var _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");
/* harmony import */ var _geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../geometry/components/ShapeComponent */ "./src/framework/geometry/components/ShapeComponent.ts");
/* harmony import */ var _geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./geometry */ "./src/framework/helpers/geometry.ts");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! turf */ "./node_modules/turf/index.js");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(turf__WEBPACK_IMPORTED_MODULE_5__);






const booleanOverlaps = __webpack_require__(/*! @turf/boolean-overlap */ "./node_modules/@turf/boolean-overlap/index.js").default;
const lineIntersect = __webpack_require__(/*! @turf/line-intersect */ "./node_modules/@turf/line-intersect/index.js").default;
const entityContainsPoint = (entity, point) => {
    const shape = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    return _turf_boolean_point_in_polygon__WEBPACK_IMPORTED_MODULE_1___default()(turf__WEBPACK_IMPORTED_MODULE_5___default.a.point([point.x, point.y]), Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape));
};
const entitiesTouch = (entity1, entity2) => {
    const shape1 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity1.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity1.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    const shape2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity2.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity2.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    const geoJSON1 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1);
    const geoJSON2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2);
    return _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(geoJSON1, geoJSON2) ||
        _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(geoJSON2, geoJSON1) ||
        booleanOverlaps(geoJSON1, geoJSON2) ||
        booleanOverlaps(geoJSON2, geoJSON1);
};
const entityContainsEntity = (entity1, entity2) => {
    const shape1 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity1.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity1.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    const shape2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity2.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity2.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    const geoJSON1 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape1);
    const geoJSON2 = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape2);
    return _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(geoJSON1, geoJSON2) || _turf_boolean_contains__WEBPACK_IMPORTED_MODULE_0___default()(geoJSON2, geoJSON1);
};
const entityTouchesLine = (entity, points) => {
    const shape = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(entity.$copy(_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), entity.$copy(_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]));
    const polygon = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromShapeToGeoJSON"])(shape);
    const line = Object(_geometry__WEBPACK_IMPORTED_MODULE_4__["fromPointsToGeoJSON"])(points);
    return lineIntersect(polygon, line).features.length > 0;
};


/***/ }),

/***/ "./src/framework/helpers/geometry.ts":
/*!*******************************************!*\
  !*** ./src/framework/helpers/geometry.ts ***!
  \*******************************************/
/*! exports provided: rotatePointAboutOrigin, transformShape, fromPointsToGeoJSON, fromShapeToGeoJSON, fromGeoJSONCoordinatesToShapes, fromShapeToBoundary, getEuclideanDistanceBetweenPoints, getAngleBetweenPoints, pow2 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "rotatePointAboutOrigin", function() { return rotatePointAboutOrigin; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "transformShape", function() { return transformShape; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromPointsToGeoJSON", function() { return fromPointsToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromShapeToGeoJSON", function() { return fromShapeToGeoJSON; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromGeoJSONCoordinatesToShapes", function() { return fromGeoJSONCoordinatesToShapes; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fromShapeToBoundary", function() { return fromShapeToBoundary; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getEuclideanDistanceBetweenPoints", function() { return getEuclideanDistanceBetweenPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getAngleBetweenPoints", function() { return getAngleBetweenPoints; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "pow2", function() { return pow2; });
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! turf */ "./node_modules/turf/index.js");
/* harmony import */ var turf__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(turf__WEBPACK_IMPORTED_MODULE_0__);

const rotatePointAboutOrigin = ({ point, orientation }) => {
    const s = Math.sin(orientation);
    const c = Math.cos(orientation);
    return {
        x: point.x * c - point.y * s,
        y: point.x * s + point.y * c,
    };
};
const transformShape = (shape, pose) => {
    return {
        vertices: shape.vertices.map((p) => {
            const point = rotatePointAboutOrigin({ point: p, orientation: pose.a });
            return {
                x: point.x + pose.x,
                y: point.y + pose.y,
            };
        }),
    };
};
const fromPointsToGeoJSON = (points) => {
    return turf__WEBPACK_IMPORTED_MODULE_0___default.a.lineString(points.map((point) => [point.x, point.y]));
};
const fromShapeToGeoJSON = (shape) => {
    return turf__WEBPACK_IMPORTED_MODULE_0___default.a.polygon([
        shape.vertices.map((vertex) => [vertex.x, vertex.y]).concat([[shape.vertices[0].x, shape.vertices[0].y]]),
    ]);
};
const fromGeoJSONCoordinatesToShapes = (geoJSON) => {
    if (!geoJSON) {
        return [];
    }
    if (geoJSON.geometry.type === 'Polygon') {
        return geoJSON.geometry.coordinates.map((vertices) => {
            return { vertices: vertices.map((vertex) => ({ x: vertex[0], y: vertex[1] })) };
        });
    }
    if (geoJSON.geometry.type === 'MultiPolygon') {
        const shapes = [];
        geoJSON.geometry.coordinates.forEach((polygon) => {
            shapes.push(polygon.map((vertices) => {
                return { vertices: vertices.map((vertex) => ({ x: vertex[0], y: vertex[1] })) };
            })[0]);
        });
        return shapes;
    }
    return [];
};
const fromShapeToBoundary = (shape) => {
    const geojson = fromShapeToGeoJSON(shape);
    const bbox = turf__WEBPACK_IMPORTED_MODULE_0___default.a.bbox(geojson);
    return {
        minX: bbox[0],
        minY: bbox[1],
        maxX: bbox[2],
        maxY: bbox[3],
    };
};
const getEuclideanDistanceBetweenPoints = (p1, p2) => {
    return Math.sqrt(Math.pow((p2.x - p1.x), 2) + Math.pow(p2.y - p1.y, 2));
};
const getAngleBetweenPoints = (p1, p2) => {
    return Math.atan2(p2.y - p1.y, p2.x - p1.x);
};
const pow2 = (target) => {
    return Math.pow(target, 2);
};


/***/ }),

/***/ "./src/framework/interactive/InteractiveComponent.ts":
/*!***********************************************************!*\
  !*** ./src/framework/interactive/InteractiveComponent.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InteractiveComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class InteractiveComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/interactive/InteractiveEntity.ts":
/*!********************************************************!*\
  !*** ./src/framework/interactive/InteractiveEntity.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return InteractiveEntity; });
/* harmony import */ var _InteractiveComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./InteractiveComponent */ "./src/framework/interactive/InteractiveComponent.ts");
/* harmony import */ var engine_Entity__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! engine/Entity */ "./src/engine/Entity.ts");


class InteractiveEntity extends engine_Entity__WEBPACK_IMPORTED_MODULE_1__["default"] {
    constructor() {
        super();
        this.$add(_InteractiveComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({
            isEnabled: true,
            isHovered: false,
            mouseenter: this.$mouseenter,
            mouseleave: this.$mouseleave,
            mousemove: this.$mousemove,
            mousedown: this.$mousedown,
            mouseup: this.$mouseup,
            click: this.$click,
        });
    }
    $enable() {
        this.$patch(_InteractiveComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({ isEnabled: true });
    }
    $disable() {
        this.$patch(_InteractiveComponent__WEBPACK_IMPORTED_MODULE_0__["default"])({ isEnabled: false });
    }
}


/***/ }),

/***/ "./src/framework/presentation/components/AnimationComponent.ts":
/*!*********************************************************************!*\
  !*** ./src/framework/presentation/components/AnimationComponent.ts ***!
  \*********************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimatedImageComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class AnimatedImageComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/presentation/components/ImageComponent.ts":
/*!*****************************************************************!*\
  !*** ./src/framework/presentation/components/ImageComponent.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class ImageComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/presentation/components/LabelComponent.ts":
/*!*****************************************************************!*\
  !*** ./src/framework/presentation/components/LabelComponent.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class LabelComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/presentation/components/StyleComponent.ts":
/*!*****************************************************************!*\
  !*** ./src/framework/presentation/components/StyleComponent.ts ***!
  \*****************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StyleComponent; });
/* harmony import */ var engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! engine/abstracts/Component */ "./src/engine/abstracts/Component.ts");

class StyleComponent extends engine_abstracts_Component__WEBPACK_IMPORTED_MODULE_0__["default"] {
}


/***/ }),

/***/ "./src/framework/presentation/systems/AnimatedImageSystem.ts":
/*!*******************************************************************!*\
  !*** ./src/framework/presentation/systems/AnimatedImageSystem.ts ***!
  \*******************************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return AnimatedImageSystem; });
/* harmony import */ var _components_AnimationComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/AnimationComponent */ "./src/framework/presentation/components/AnimationComponent.ts");
/* harmony import */ var _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../engine/abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");



class AnimatedImageSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__["default"] {
    draw() {
        this.$engine.components.forEvery(_components_AnimationComponent__WEBPACK_IMPORTED_MODULE_0__["default"])((animation) => {
            const data = animation.copy();
            if (data.cooldown === data.speed) {
                data.cooldown = 0;
                if (data.isReversed) {
                    data.frame--;
                }
                else {
                    data.frame++;
                }
                if (data.frame > data.images.length - 1) {
                    data.frame = 0;
                }
                if (data.frame < 0) {
                    data.frame = data.images.length - 1;
                }
            }
            else if (!data.isPaused) {
                data.cooldown++;
            }
            animation.mutate(data);
            this.$engine.viewport.drawImage({
                pose: animation.$entity.$copy(framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]) || { x: 0, y: 0, a: 0 },
                image: data.images[data.frame],
            });
        });
    }
}


/***/ }),

/***/ "./src/framework/presentation/systems/ImageSystem.ts":
/*!***********************************************************!*\
  !*** ./src/framework/presentation/systems/ImageSystem.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return ImageSystem; });
/* harmony import */ var _components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/ImageComponent */ "./src/framework/presentation/components/ImageComponent.ts");
/* harmony import */ var _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../engine/abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");



class ImageSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__["default"] {
    draw() {
        this.$engine.components.forEvery(_components_ImageComponent__WEBPACK_IMPORTED_MODULE_0__["default"])((image) => {
            if (!image.copy().src) {
                return;
            }
            this.$engine.viewport.drawImage({
                pose: image.$entity.$copy(framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]) || { x: 0, y: 0, a: 0 },
                image: image.copy(),
            });
        });
    }
}


/***/ }),

/***/ "./src/framework/presentation/systems/LabelSystem.ts":
/*!***********************************************************!*\
  !*** ./src/framework/presentation/systems/LabelSystem.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return LabelSystem; });
/* harmony import */ var _components_LabelComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/LabelComponent */ "./src/framework/presentation/components/LabelComponent.ts");
/* harmony import */ var _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../engine/abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");



class LabelSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__["default"] {
    draw() {
        this.$engine.components.forEvery(_components_LabelComponent__WEBPACK_IMPORTED_MODULE_0__["default"])((label) => {
            if (!label.copy().text) {
                return;
            }
            this.$engine.viewport.drawLabel({
                pose: label.$entity.$copy(framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]),
                label: label.copy(),
            });
        });
    }
}


/***/ }),

/***/ "./src/framework/presentation/systems/StyleSystem.ts":
/*!***********************************************************!*\
  !*** ./src/framework/presentation/systems/StyleSystem.ts ***!
  \***********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return StyleSystem; });
/* harmony import */ var _components_StyleComponent__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../components/StyleComponent */ "./src/framework/presentation/components/StyleComponent.ts");
/* harmony import */ var _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../../engine/abstracts/System */ "./src/engine/abstracts/System.ts");
/* harmony import */ var framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! framework/geometry/components/PoseComponent */ "./src/framework/geometry/components/PoseComponent.ts");
/* harmony import */ var framework_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! framework/geometry/components/ShapeComponent */ "./src/framework/geometry/components/ShapeComponent.ts");
/* harmony import */ var _helpers_geometry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../helpers/geometry */ "./src/framework/helpers/geometry.ts");





class StyleSystem extends _engine_abstracts_System__WEBPACK_IMPORTED_MODULE_1__["default"] {
    draw() {
        this.$engine.components.forEvery(_components_StyleComponent__WEBPACK_IMPORTED_MODULE_0__["default"])((style) => {
            const pose = style.$entity.$copy(framework_geometry_components_PoseComponent__WEBPACK_IMPORTED_MODULE_2__["default"]);
            this.$engine.viewport.drawShape({
                path: Object(_helpers_geometry__WEBPACK_IMPORTED_MODULE_4__["transformShape"])(style.$entity.$copy(framework_geometry_components_ShapeComponent__WEBPACK_IMPORTED_MODULE_3__["default"]), pose).vertices,
                style: style.copy(),
            });
        });
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts":
/*!********************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasKeyboardAdaptor.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTML5CanvasKeyboardAdapter; });
/* harmony import */ var _engine_KeyboardHandler__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../engine/KeyboardHandler */ "./src/engine/KeyboardHandler.ts");

class HTML5CanvasKeyboardAdapter {
    constructor(canvas) {
        this.__canvas = canvas;
        this.__buffer = [];
        this.__handler = new _engine_KeyboardHandler__WEBPACK_IMPORTED_MODULE_0__["default"]();
        this.__bindKeyboardEvents();
    }
    once() {
        const input = this.__buffer.shift();
        if (input) {
            this.__handler[input.name](input);
        }
    }
    handler(handler) {
        this.__handler = handler;
    }
    __bindKeyboardEvents() {
        [
            'keydown',
            'keypress',
            'keyup',
        ]
            .forEach((key) => {
            this.__canvas[`on${key}`] = (ke) => {
                this.__buffer.push({
                    name: key,
                    key: ke.key,
                });
            };
        });
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasMouseAdaptor.ts":
/*!*****************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasMouseAdaptor.ts ***!
  \*****************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTML5CanvasMouseAdaptor; });
/* eslint-disable @typescript-eslint/no-unused-vars */
const defaultHandler = {
    mouseenter: () => undefined,
    mousemove: (mouseEvent) => undefined,
    mouseleave: () => undefined,
    mousedown: (mouseEvent) => undefined,
    mouseup: (mouseEvent) => undefined,
    click: (mouseEvent) => undefined,
    none: () => undefined,
};
/* eslint-enable @typescript-eslint/no-unused-vars */
class HTML5CanvasMouseAdaptor {
    constructor(canvas) {
        this.__canvas = canvas;
        this.__buffer = [];
        this.__handler = defaultHandler;
        this.__bindMouseEvents();
    }
    once() {
        const event = this.__buffer.shift();
        if (event) {
            this.__handler[event.name](event);
        }
        else {
            this.__handler.none({
                name: 'none',
                x: 0,
                y: 0,
                isCtrlDown: false,
                isShiftDown: false,
            });
        }
    }
    handler(handler) {
        this.__handler = handler;
    }
    __bindMouseEvents() {
        [
            'mouseenter',
            'mousemove',
            'mouseleave',
            'mousedown',
            'mouseup',
            'click',
        ]
            .forEach((key) => {
            this.__canvas[`on${key}`] = (ev) => {
                const boundingClientRect = this.__canvas.getBoundingClientRect();
                this.__buffer.push({
                    name: ev.type,
                    x: ev.clientX - boundingClientRect.left,
                    y: ev.clientY - boundingClientRect.top,
                    isCtrlDown: ev.ctrlKey,
                    isShiftDown: ev.shiftKey,
                });
            };
        });
    }
}


/***/ }),

/***/ "./src/html5-canvas/HTML5CanvasViewportAdaptor.ts":
/*!********************************************************!*\
  !*** ./src/html5-canvas/HTML5CanvasViewportAdaptor.ts ***!
  \********************************************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return HTML5CanvasViewportAdaptor; });
var __decorate = (undefined && undefined.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
function atomic(target, key, descriptor) {
    const fn = descriptor.value;
    descriptor.value = function () {
        this.ctx.save();
        fn.call(this, ...arguments);
        this.ctx.restore();
    };
}
class HTML5CanvasViewportAdaptor {
    constructor(canvas) {
        this.__imageBuffer = {};
        this.__zBuffer = [];
        this.ctx = canvas.getContext('2d');
        this.width = canvas.clientWidth;
        this.height = canvas.clientHeight;
    }
    load(src) {
        if (!this.__imageBuffer[src]) {
            this.__imageBuffer[src] = new Image();
            this.__imageBuffer[src].src = src;
        }
        return this.__imageBuffer[src];
    }
    refresh() {
        this.ctx.clearRect(0, 0, this.width, this.height);
    }
    once() {
        const zBuffer = this.__zBuffer.map((target) => {
            if (!target.payload.style) {
                target.payload.style = { zIndex: 0 };
                return target;
            }
            if (!target.payload.style.zIndex) {
                target.payload.style.zIndex = 0;
                return target;
            }
            return target;
        });
        const zOrdered = zBuffer.sort((a, b) => a.payload.style.zIndex - b.payload.style.zIndex);
        zOrdered.forEach((target) => {
            this[`__${target.method}`](target.payload);
        });
        this.__zBuffer = [];
    }
    /* eslint-disable @typescript-eslint/no-unused-vars */
    drawImage({ pose, image }) {
        this.__zBuffer.push({ method: 'drawImage', payload: arguments[0] });
    }
    drawShape({ path, style }) {
        this.__zBuffer.push({ method: 'drawShape', payload: arguments[0] });
    }
    drawLine({ path, style }) {
        this.__zBuffer.push({ method: 'drawLine', payload: arguments[0] });
    }
    drawLabel({ pose, label }) {
        this.__zBuffer.push({ method: 'drawLabel', payload: arguments[0] });
    }
    drawCircle({ position, radius, style }) {
        this.__zBuffer.push({ method: 'drawCircle', payload: arguments[0] });
    }
    /* eslint-enable @typescript-eslint/no-unused-vars */
    __drawImage({ pose, image }) {
        const asset = this.load(image.src || './favicon.ico');
        this.ctx.translate(pose.x, pose.y);
        this.ctx.rotate(image.rotate || 0);
        this.ctx.drawImage(asset, -(image.width || asset.width) / 2, -(image.height || asset.height) / 2, image.width || asset.width, image.height || asset.height);
    }
    __drawShape({ path, style }) {
        this.ctx.globalAlpha = style.opacity;
        this.ctx.strokeStyle = style.colour;
        this.ctx.beginPath();
        path.forEach((p) => {
            this.ctx.lineTo(p.x, p.y);
        });
        this.ctx.fillStyle = style.fill;
        this.ctx.fill();
        this.ctx.closePath();
        this.ctx.stroke();
    }
    __drawLine({ points, style }) {
        this.ctx.strokeStyle = style.colour;
        this.ctx.beginPath();
        points.forEach((p) => {
            this.ctx.lineTo(p.x, p.y);
        });
        this.ctx.stroke();
    }
    __drawLabel({ pose, label }) {
        this.ctx.fillStyle = label.colour;
        this.ctx.font = `${label.fontSize}px Arial`;
        this.ctx.fillText(label.text, pose.x + label.offset.x, pose.y + label.offset.y);
    }
    __drawCircle({ position, radius, style }) {
        this.ctx.strokeStyle = style.colour;
        this.ctx.beginPath();
        this.ctx.arc(position.x, position.y, radius, 0, 2 * Math.PI);
        this.ctx.stroke();
    }
}
__decorate([
    atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawImage", null);
__decorate([
    atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawShape", null);
__decorate([
    atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawLine", null);
__decorate([
    atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawLabel", null);
__decorate([
    atomic
], HTML5CanvasViewportAdaptor.prototype, "__drawCircle", null);


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jib3gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2JlYXJpbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jvb2xlYW4tY29udGFpbnMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Jvb2xlYW4tb3ZlcmxhcC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvYm9vbGVhbi1wb2ludC1pbi1wb2x5Z29uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9ib29sZWFuLXBvaW50LW9uLWxpbmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL2Rlc3RpbmF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvaW52YXJpYW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9saW5lLWludGVyc2VjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvQHR1cmYvbGluZS1vdmVybGFwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9AdHVyZi9saW5lLXNlZ21lbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL21ldGEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL0B0dXJmL25lYXJlc3QtcG9pbnQtb24tbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYWZmaW5lLWh1bGwvYWZmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9iaXQtdHdpZGRsZS90d2lkZGxlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb252ZXgtaHVsbC9jaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvY29udmV4LWh1bGwvbGliL2NoMWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NvbnZleC1odWxsL2xpYi9jaDJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jb252ZXgtaHVsbC9saWIvY2huZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVlcC1lcXVhbC9saWIvaXNfYXJndW1lbnRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9kZWVwLWVxdWFsL2xpYi9rZXlzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9lYXJjdXQvc3JjL2VhcmN1dC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1hcmVhL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW9qc29uLWVxdWFsaXR5L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9nZW9qc29uLW5vcm1hbGl6ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ2VvanNvbi1yYW5kb20vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dlb2pzb24tcmJ1c2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2luY3JlbWVudGFsLWNvbnZleC1odWxsL2ljaC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvanF1ZXJ5L2Rpc3QvanF1ZXJ5LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9qc3RzL2Rpc3QvanN0cy5taW4uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL21vbm90b25lLWNvbnZleC1odWxsLTJkL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9xdWlja3NlbGVjdC9xdWlja3NlbGVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcmJ1c2gvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3JvYnVzdC1vcmllbnRhdGlvbi9vcmllbnRhdGlvbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcm9idXN0LXNjYWxlL3JvYnVzdC1zY2FsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvcm9idXN0LXN1YnRyYWN0L3JvYnVzdC1kaWZmLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9yb2J1c3Qtc3VtL3JvYnVzdC1zdW0uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NpbXBsaWNpYWwtY29tcGxleC90b3BvbG9neS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc2ltcGxpZnktanMvc2ltcGxpZnkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYWxvbmcvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYXJlYS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iYm94LXBvbHlnb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtYmJveC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iZWFyaW5nL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWJlemllci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1iZXppZXIvc3BsaW5lLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWJ1ZmZlci9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1jZW50ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY2VudHJvaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY29sbGVjdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1jb21iaW5lL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWNvbmNhdmUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtY29udmV4L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWRlc3RpbmF0aW9uL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWRpZmZlcmVuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZGlzdGFuY2UvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZW52ZWxvcGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtZXhwbG9kZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1mbGlwL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaGVscGVycy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1oZXgtZ3JpZC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1pbnNpZGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaW50ZXJzZWN0L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLWludmFyaWFudC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1pc29saW5lcy9jb25yZWMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtaXNvbGluZXMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYta2lua3MvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbGluZS1kaXN0YW5jZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1saW5lLXNsaWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLW1ldGEvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbWlkcG9pbnQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtbmVhcmVzdC9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1wbGFuZXBvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXBvaW50LWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtcG9pbnQtb24tbGluZS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1wb2ludC1vbi1zdXJmYWNlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXBvaW50L2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXJhbmRvbS9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi1zYW1wbGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc2ltcGxpZnkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc3F1YXJlLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtc3F1YXJlL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXRhZy9pbmRleC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHVyZi10ZXNzZWxhdGUvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtdGluL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmLXRyaWFuZ2xlLWdyaWQvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtdW5pb24vaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3R1cmYtd2l0aGluL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90dXJmL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90d28tcHJvZHVjdC90d28tcHJvZHVjdC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdHdvLXN1bS90d28tc3VtLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91bmlvbi1maW5kL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy91dWlkL2xpYi9ieXRlc1RvVXVpZC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdXVpZC9saWIvcm5nLWJyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3V1aWQvdjEuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3dnczg0L2luZGV4LmpzIiwid2VicGFjazovLy8uL3NyYy9hcHAvQXBwLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvY29udHJhcHRpb25zL2Fic3RyYWN0cy9Db250cmFwdGlvbi50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRyYXB0aW9ucy9wYXJ0cy9BY3R1YXRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRyYXB0aW9ucy9wYXJ0cy9DbGF3LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvY29udHJhcHRpb25zL3BhcnRzL0hvcml6b250YWxUaHJlYWRlZEF4bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250cmFwdGlvbnMvcGFydHMvVG91Y2hBY3RpdmF0b3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250cmFwdGlvbnMvcGFydHMvVG91Y2hTZW5zb3IudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250cmFwdGlvbnMvcGFydHMvVmVydGljYWxUaHJlYWRlZEF4bGUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC9jb250cmFwdGlvbnMvcGFydHMvYWJzdHJhY3RzL01hY2hpbmVQYXJ0LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvY29udHJhcHRpb25zL3BhcnRzL2Fic3RyYWN0cy9Qcml6ZS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2NvbnRyYXB0aW9ucy90aGUtY2xhdy9UaGVDbGF3LnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZGlnaXRhbC1sb2dpYy9lbnRpdGllcy9JbnB1dFRlcm1pbmFsLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZGlnaXRhbC1sb2dpYy9lbnRpdGllcy9PdXRwdXRUZXJtaW5hbC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL2RpZ2l0YWwtbG9naWMvZW50aXRpZXMvYWJzdHJhY3RzL1Rlcm1pbmFsLnRzIiwid2VicGFjazovLy8uL3NyYy9hcHAvZGlnaXRhbC1sb2dpYy9lbnVtcy9TVEFURS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvYXBwL21haW4udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2FwcC91aS9hYnN0cmFjdHMvVUlFbnRpdHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9Db21wb25lbnRNYXN0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9FbmdpbmUudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9FbnRpdHkudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9FbnRpdHlNYXN0ZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9LZXlib2FyZEhhbmRsZXIudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2VuZ2luZS9hYnN0cmFjdHMvQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9lbmdpbmUvYWJzdHJhY3RzL1N5c3RlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZm91bmRhdGlvbi9hYnN0cmFjdHMvVW5pcXVlLnRzIiwid2VicGFjazovLy8uL3NyYy9mb3VuZGF0aW9uL2NvbmNyZXRlcy9EaWN0aW9uYXJ5LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvZ2VvbWV0cnkvY29tcG9uZW50cy9Qb3NlQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvZ2VvbWV0cnkvY29tcG9uZW50cy9TaGFwZUNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL2hlbHBlcnMvZW50aXRpZXMudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9oZWxwZXJzL2dlb21ldHJ5LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvaW50ZXJhY3RpdmUvSW50ZXJhY3RpdmVDb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9pbnRlcmFjdGl2ZS9JbnRlcmFjdGl2ZUVudGl0eS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9jb21wb25lbnRzL0FuaW1hdGlvbkNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9jb21wb25lbnRzL0ltYWdlQ29tcG9uZW50LnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvTGFiZWxDb21wb25lbnQudHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9wcmVzZW50YXRpb24vY29tcG9uZW50cy9TdHlsZUNvbXBvbmVudC50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9zeXN0ZW1zL0FuaW1hdGVkSW1hZ2VTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2ZyYW1ld29yay9wcmVzZW50YXRpb24vc3lzdGVtcy9JbWFnZVN5c3RlbS50cyIsIndlYnBhY2s6Ly8vLi9zcmMvZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9zeXN0ZW1zL0xhYmVsU3lzdGVtLnRzIiwid2VicGFjazovLy8uL3NyYy9mcmFtZXdvcmsvcHJlc2VudGF0aW9uL3N5c3RlbXMvU3R5bGVTeXN0ZW0udHMiLCJ3ZWJwYWNrOi8vLy4vc3JjL2h0bWw1LWNhbnZhcy9IVE1MNUNhbnZhc0tleWJvYXJkQWRhcHRvci50cyIsIndlYnBhY2s6Ly8vLi9zcmMvaHRtbDUtY2FudmFzL0hUTUw1Q2FudmFzTW91c2VBZGFwdG9yLnRzIiwid2VicGFjazovLy8uL3NyYy9odG1sNS1jYW52YXMvSFRNTDVDYW52YXNWaWV3cG9ydEFkYXB0b3IudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtRQUFBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxHQUFHOztRQUVIO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBO1FBQ0E7UUFDQSxPQUFPO1FBQ1A7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSTtRQUNKOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsTUFBTTtRQUNOO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSzs7UUFFTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQSw2QkFBNkI7UUFDN0IsNkJBQTZCO1FBQzdCO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EscUJBQXFCLGdCQUFnQjtRQUNyQztRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBLHFCQUFxQixnQkFBZ0I7UUFDckM7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSzs7UUFFTDtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxLQUFLO1FBQ0w7UUFDQTtRQUNBLEtBQUs7UUFDTDtRQUNBO1FBQ0E7UUFDQSxLQUFLOztRQUVMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBOztRQUVBO1FBQ0E7UUFDQSxrQkFBa0IsOEJBQThCO1FBQ2hEO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQSxJQUFJO1FBQ0o7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQSxNQUFNO1FBQ047UUFDQTtRQUNBO1FBQ0EsT0FBTztRQUNQO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsSUFBSTtRQUNKO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsS0FBSztRQUNMO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLG9CQUFvQiwyQkFBMkI7UUFDL0M7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLE9BQU87UUFDUDtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0EsbUJBQW1CLGNBQWM7UUFDakM7UUFDQTtRQUNBO1FBQ0E7O1FBRUE7UUFDQTtRQUNBO1FBQ0E7UUFDQTs7UUFFQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBLGdCQUFnQixLQUFLO1FBQ3JCO1FBQ0E7UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0EsZ0JBQWdCLFlBQVk7UUFDNUI7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVBO1FBQ0E7UUFDQSxjQUFjLDRCQUE0QjtRQUMxQztRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLE1BQU07UUFDTjtRQUNBOztRQUVBO1FBQ0E7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBLElBQUk7O1FBRUo7UUFDQTtRQUNBO1FBQ0E7UUFDQTtRQUNBOztRQUVB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RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5Q0FBeUM7O0FBRXpDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5Qzs7QUFFekMscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHlDQUF5QyxTQUFTO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLGVBQWUsa0JBQWtCO0FBQ2pDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7O0FBRUEsaUNBQWlDLCtCQUErQjs7QUFFaEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBLGtEQUFrRDs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixZQUFZO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEtBQUs7O0FBRUw7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7O0FBRUEsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlELFNBQVM7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGVBQWUsc0JBQXNCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esc0NBQXNDLFNBQVM7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IseUNBQXlDO0FBQzNEOztBQUVBLG1CQUFtQixpQkFBaUI7QUFDcEMsdUJBQXVCLG9CQUFvQjtBQUMzQywyQkFBMkIsU0FBUztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7Ozs7Ozs7Ozs7QUN6b0JBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTzs7QUFFM0I7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMEJBQTBCO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix5QkFBeUI7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixtQkFBbUI7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxNQUFNO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQixrQkFBa0I7QUFDckMseUNBQXlDO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBLGFBQWEsbUNBQW1DO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQ3hGQTtBQUNBLGdCQUFnQixtQkFBTyxDQUFDLHNEQUFZOztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsZUFBZSxlQUFlO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxzQkFBc0I7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdDQUFnQyxhQUFhO0FBQzdDOztBQUVBOzs7Ozs7Ozs7Ozs7QUNoS0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsYUFBYSxPQUFPO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBLGFBQWE7QUFDYjtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7OztBQzFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsV0FBVztBQUMxQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9EQUFvRDs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQSxpQ0FBaUMsMkNBQTJDO0FBQzVFOztBQUVBLGdCQUFnQiw0QkFBNEI7QUFDNUMsZ0JBQWdCLG9CQUFvQjtBQUNwQyxnQkFBZ0Isb0JBQW9COztBQUVwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7O0FDdEdBLFlBQVksbUJBQU8sQ0FBQyw0Q0FBTztBQUMzQixjQUFjLG1CQUFPLENBQUMsNERBQWU7QUFDckMsV0FBVyxtQkFBTyxDQUFDLHNEQUFZO0FBQy9CLGVBQWUsbUJBQU8sQ0FBQyxzREFBWTtBQUNuQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsT0FBTztBQUNsQjtBQUNBLGFBQWEsTUFBTTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsaUNBQWlDO0FBQ2hELGlCQUFpQixNQUFNO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsU0FBUztBQUN4QixpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsTUFBTTtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixJQUFJO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLElBQUk7QUFDbkIsaUJBQWlCLE1BQU07QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZCw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNEJBQTRCLHVCQUF1QjtBQUNuRDtBQUNBO0FBQ0EsZUFBZSwrQkFBK0I7QUFDOUMsaUJBQWlCLE9BQU8sZUFBZTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7QUMvTVk7O0FBRVo7QUFDQTtBQUNBOztBQUVBOztBQUVBLGFBQWEsbUJBQU8sQ0FBQyw0RUFBb0I7QUFDekMsa0JBQWtCLG1CQUFPLENBQUMseUVBQW9COztBQUU5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMscUJBQXFCO0FBQ3RELGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQSxjQUFjLGNBQWM7QUFDNUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxnQkFBZ0IsTUFBTTtBQUN0QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHVDO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixNQUFNO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxrQkFBa0IsTUFBTTtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLGNBQWMsdUJBQXVCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxNQUFNO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBLGdCQUFnQixNQUFNO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsTUFBTTtBQUNwQjtBQUNBO0FBQ0EsZ0JBQWdCLE1BQU07QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixNQUFNO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQkFBZ0IsS0FBSztBQUNyQjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7OztBQzdiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLE1BQU0sS0FBMEI7O0FBRWhDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTs7O0FBR0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7OztBQUdBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FBSUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxZQUFZOztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUYsb0JBQW9COztBQUVwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRiw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLGtCQUFrQixrQ0FBa0M7QUFDcEQsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLFlBQVk7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsU0FBUztBQUNsQjtBQUNBOztBQUVBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFNBQVMsWUFBWTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTLFNBQVM7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDLElBQUk7QUFDdEM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBLGdCQUFnQixJQUFJOztBQUVwQjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSwwQ0FBMEMsSUFBSTtBQUM5QztBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRCxTQUFTOztBQUVUO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhLHlCQUF5QjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsU0FBUztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEIsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxRQUFRO0FBQ25CLGFBQWEsT0FBTztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxPQUFPO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLE9BQU87QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsUUFBUSw2QkFBNkI7QUFDaEQ7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLFNBQVM7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGdCQUFnQjtBQUMzQixhQUFhLHVCQUF1QjtBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxXQUFXLGVBQWU7QUFDMUIsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQixhQUFhLE9BQU87QUFDcEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsVUFBVTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQSxlQUFlOztBQUVmLFNBQVM7O0FBRVQ7QUFDQSxRQUFRLGlDQUFpQztBQUN6QyxRQUFRLG9CQUFvQjtBQUM1QixRQUFRLHNDQUFzQztBQUM5QyxRQUFRO0FBQ1IsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSw2REFBNkQ7O0FBRTdEO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQzs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTzs7QUFFUDtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4REFBOEQ7O0FBRTlEO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQzs7QUFFM0M7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7O0FBRWxDO0FBQ0E7QUFDQTtBQUNBLDhDQUE4Qzs7QUFFOUM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0EsaUVBQWlFLFVBQVU7QUFDM0Usc0NBQXNDLDJCQUEyQjtBQUNqRTtBQUNBLGdDQUFnQyxNQUFNO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsVUFBVSxZQUFZO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBLFVBQVUsWUFBWTtBQUN0QjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsVUFBVTtBQUNwQjtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQSxVQUFVLGNBQWM7QUFDeEI7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxZQUFZLHVFQUF1RTtBQUNuRjtBQUNBO0FBQ0EsWUFBWSw0QkFBNEI7QUFDeEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLDREQUE0RDs7QUFFNUQ7QUFDQTtBQUNBO0FBQ0EseUNBQXlDOztBQUV6QztBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQSxPQUFPOztBQUVQO0FBQ0E7O0FBRUEsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxRQUFRLFNBQVM7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUgsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsV0FBVyxTQUFTO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixpREFBaUQ7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pELFVBQVUsNENBQTRDO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsV0FBVyxnQkFBZ0I7QUFDM0I7QUFDQSxXQUFXLFFBQVE7QUFDbkIsV0FBVyxNQUFNO0FBQ2pCLFdBQVcsTUFBTTtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTs7QUFFQSxDQUFDOzs7O0FBSUQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsUUFBUSxHQUFHO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsZ0JBQWdCLFNBQVM7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7O0FBRUEsY0FBYyxTQUFTO0FBQ3ZCO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVLE9BQU87QUFDakIsMEJBQTBCLHdCQUF3Qjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0EsMENBQTBDO0FBQzFDLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQztBQUNEOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsY0FBYztBQUN4QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7O0FBRVI7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07O0FBRU47QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBLHdDQUF3QyxzQ0FBc0M7QUFDOUUsb0NBQW9DLHVDQUF1QztBQUMzRSxvQ0FBb0Msc0NBQXNDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxXQUFXOztBQUVYO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUzs7QUFFVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFROztBQUVSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQ0FBb0M7QUFDcEMscUNBQXFDO0FBQ3JDLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FBS0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7OztBQUtBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVUsU0FBUztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0JBQStCO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCLGFBQWE7QUFDcEMsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxvQkFBb0IsU0FBUztBQUM3Qjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOztBQUVKO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDs7QUFFQTs7O0FBR0E7O0FBRUE7Ozs7QUFJQTtBQUNBO0FBQ0EsR0FBRztBQUNILGNBQWM7O0FBRWQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLGlCQUFpQixnQkFBZ0I7QUFDakM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7QUFDRDs7QUFFQTs7QUFFQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7OztBQUdBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLEVBQUU7QUFDRjs7QUFFQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsUUFBUSxPQUFPO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUdBLHNCQUFzQjs7QUFFdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTztBQUNmOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFLGdCQUFnQjtBQUNsQjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsV0FBVzs7QUFFWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFOztBQUVGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxjQUFjLHNCQUFzQjtBQUNwQztBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSwrREFBK0Q7QUFDL0Q7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxVQUFVLGNBQWM7O0FBRXhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQW1CO0FBQ3BDOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsdUNBQXVDO0FBQ2pFO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1Qix1REFBdUQ7QUFDOUU7O0FBRUE7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssK0NBQStDO0FBQ3BEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxjQUFjLHFDQUFxQztBQUNuRDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDs7QUFFQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOzs7QUFHRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSwyQ0FBMkMsT0FBTztBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qjs7QUFFOUI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsVUFBVSxPQUFPO0FBQ2pCOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsK0JBQStCO0FBQ3ZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx3Q0FBd0MsT0FBTztBQUMvQztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMscUNBQXFDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUEsU0FBUyw4QkFBOEI7QUFDdkM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVMsV0FBVztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7O0FBR0E7Ozs7QUFJQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsK0NBQStDLGNBQWMsV0FBVztBQUN4RSxtQkFBbUIsVUFBVTtBQUM3QjtBQUNBLHNCQUFzQixjQUFjLHNCQUFzQixnQkFBZ0I7QUFDMUUsZ0JBQWdCLFdBQVcsWUFBWTtBQUN2QyxjQUFjO0FBQ2Q7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNkNBQTZDO0FBQzdDO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOzs7QUFHRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0RBQStEO0FBQzNFO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFFBQVEsT0FBTzs7QUFFZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLGFBQWE7O0FBRWI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUEsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0JBQWdCO0FBQ2xDO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBLFVBQVUsT0FBTztBQUNqQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7O0FBRUE7QUFDQTtBQUNBOztBQUVBLFdBQVcsU0FBUztBQUNwQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXOztBQUVYO0FBQ0E7QUFDQTtBQUNBLFFBQVEsT0FBTztBQUNmO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxnQkFBZ0I7QUFDeEI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLGlEQUFpRCwwQkFBMEI7QUFDM0U7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFD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QVcsa0JBQWtCO0FBQzdCLGNBQWM7QUFDZCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBLFFBQVEsbUJBQW1CO0FBQzNCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7O0FBRUY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7O0FBRUEsaUNBQWlDO0FBQ2pDO0FBQ0E7O0FBRUEsSUFBSTtBQUNKOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBLFdBQVcsU0FBUztBQUNwQjs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7Ozs7QUFLRDs7O0FBR0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7O0FBRUE7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMkNBQTJDO0FBQzNDOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxLQUFLO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLENBQUM7O0FBRUQ7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7QUFHRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLHFDQUFxQzs7QUFFcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBLGFBQWE7O0FBRWI7Ozs7QUFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSCxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBOztBQUVBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVILEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLEtBQUs7QUFDTDs7QUFFQSxXQUFXO0FBQ1gsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7O0FBRWhCLGdEQUFnRDtBQUNoRDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx3REFBd0Q7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCOztBQUVqQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQSxJQUFJOztBQUVKO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLFNBQVM7QUFDVDs7QUFFQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsaUJBQWlCO0FBQ2pCLFNBQVM7O0FBRVQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7O0FBRUg7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHOztBQUVIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0EsMkJBQTJCOztBQUUzQjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0Esa0NBQWtDOztBQUVsQztBQUNBLHNCQUFzQjtBQUN0QiwyQkFBMkI7O0FBRTNCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLE9BQU87O0FBRVA7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0RBQXNEO0FBQ3REO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7QUFFSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7OztBQUdBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsSUFBSTtBQUNKO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBOztBQUVBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsdUJBQXVCO0FBQ2xDLFdBQVcseUJBQXlCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7O0FBRUo7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CLGFBQWEsdUNBQXVDO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07O0FBRU47QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7Ozs7O0FBS0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRzs7QUFFSDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDs7QUFFQTtBQUNBOzs7OztBQUtBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7Ozs7QUFLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBLHFEQUFxRDtBQUNyRDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxtQkFBbUI7O0FBRW5CO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQSxHQUFHO0FBQ0g7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDOztBQUVEO0FBQ0EsY0FBYyxzREFBc0Q7QUFDcEU7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7O0FBR0Q7QUFDQSxjQUFjLG1DQUFtQztBQUNqRCxlQUFlLDZEQUE2RDtBQUM1RTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsRUFBRTtBQUNGLENBQUM7OztBQUdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOzs7OztBQUtEOztBQUVBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7O0FBRUY7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFOzs7OztBQUtGO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ3RDLGFBQWEsbUJBQU8sQ0FBQyxrREFBUzs7QUFFOUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWMsS0FBSztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDOzs7Ozs7Ozs7Ozs7QUNqRFk7O0FBRVo7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQzs7Ozs7Ozs7Ozs7O0FDM0pZOztBQUVaOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFNOzhEQVFOIiwiZmlsZSI6ImJ1bmRsZS5qcyIsInNvdXJjZXNDb250ZW50IjpbIiBcdGZ1bmN0aW9uIGhvdERpc3Bvc2VDaHVuayhjaHVua0lkKSB7XG4gXHRcdGRlbGV0ZSBpbnN0YWxsZWRDaHVua3NbY2h1bmtJZF07XG4gXHR9XG4gXHR2YXIgcGFyZW50SG90VXBkYXRlQ2FsbGJhY2sgPSB3aW5kb3dbXCJ3ZWJwYWNrSG90VXBkYXRlXCJdO1xuIFx0d2luZG93W1wid2VicGFja0hvdFVwZGF0ZVwiXSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gd2VicGFja0hvdFVwZGF0ZUNhbGxiYWNrKGNodW5rSWQsIG1vcmVNb2R1bGVzKSB7XG4gXHRcdGhvdEFkZFVwZGF0ZUNodW5rKGNodW5rSWQsIG1vcmVNb2R1bGVzKTtcbiBcdFx0aWYgKHBhcmVudEhvdFVwZGF0ZUNhbGxiYWNrKSBwYXJlbnRIb3RVcGRhdGVDYWxsYmFjayhjaHVua0lkLCBtb3JlTW9kdWxlcyk7XG4gXHR9IDtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3REb3dubG9hZFVwZGF0ZUNodW5rKGNodW5rSWQpIHtcbiBcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gXHRcdHNjcmlwdC5jaGFyc2V0ID0gXCJ1dGYtOFwiO1xuIFx0XHRzY3JpcHQuc3JjID0gX193ZWJwYWNrX3JlcXVpcmVfXy5wICsgXCJcIiArIGNodW5rSWQgKyBcIi5cIiArIGhvdEN1cnJlbnRIYXNoICsgXCIuaG90LXVwZGF0ZS5qc1wiO1xuIFx0XHRpZiAobnVsbCkgc2NyaXB0LmNyb3NzT3JpZ2luID0gbnVsbDtcbiBcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuIFx0fVxuXG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdGZ1bmN0aW9uIGhvdERvd25sb2FkTWFuaWZlc3QocmVxdWVzdFRpbWVvdXQpIHtcbiBcdFx0cmVxdWVzdFRpbWVvdXQgPSByZXF1ZXN0VGltZW91dCB8fCAxMDAwMDtcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdGlmICh0eXBlb2YgWE1MSHR0cFJlcXVlc3QgPT09IFwidW5kZWZpbmVkXCIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QobmV3IEVycm9yKFwiTm8gYnJvd3NlciBzdXBwb3J0XCIpKTtcbiBcdFx0XHR9XG4gXHRcdFx0dHJ5IHtcbiBcdFx0XHRcdHZhciByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gXHRcdFx0XHR2YXIgcmVxdWVzdFBhdGggPSBfX3dlYnBhY2tfcmVxdWlyZV9fLnAgKyBcIlwiICsgaG90Q3VycmVudEhhc2ggKyBcIi5ob3QtdXBkYXRlLmpzb25cIjtcbiBcdFx0XHRcdHJlcXVlc3Qub3BlbihcIkdFVFwiLCByZXF1ZXN0UGF0aCwgdHJ1ZSk7XG4gXHRcdFx0XHRyZXF1ZXN0LnRpbWVvdXQgPSByZXF1ZXN0VGltZW91dDtcbiBcdFx0XHRcdHJlcXVlc3Quc2VuZChudWxsKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdHJldHVybiByZWplY3QoZXJyKTtcbiBcdFx0XHR9XG4gXHRcdFx0cmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQpIHJldHVybjtcbiBcdFx0XHRcdGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuIFx0XHRcdFx0XHQvLyB0aW1lb3V0XG4gXHRcdFx0XHRcdHJlamVjdChcbiBcdFx0XHRcdFx0XHRuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiB0aW1lZCBvdXQuXCIpXG4gXHRcdFx0XHRcdCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzID09PSA0MDQpIHtcbiBcdFx0XHRcdFx0Ly8gbm8gdXBkYXRlIGF2YWlsYWJsZVxuIFx0XHRcdFx0XHRyZXNvbHZlKCk7XG4gXHRcdFx0XHR9IGVsc2UgaWYgKHJlcXVlc3Quc3RhdHVzICE9PSAyMDAgJiYgcmVxdWVzdC5zdGF0dXMgIT09IDMwNCkge1xuIFx0XHRcdFx0XHQvLyBvdGhlciBmYWlsdXJlXG4gXHRcdFx0XHRcdHJlamVjdChuZXcgRXJyb3IoXCJNYW5pZmVzdCByZXF1ZXN0IHRvIFwiICsgcmVxdWVzdFBhdGggKyBcIiBmYWlsZWQuXCIpKTtcbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdC8vIHN1Y2Nlc3NcbiBcdFx0XHRcdFx0dHJ5IHtcbiBcdFx0XHRcdFx0XHR2YXIgdXBkYXRlID0gSlNPTi5wYXJzZShyZXF1ZXN0LnJlc3BvbnNlVGV4dCk7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGUpIHtcbiBcdFx0XHRcdFx0XHRyZWplY3QoZSk7XG4gXHRcdFx0XHRcdFx0cmV0dXJuO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdHJlc29sdmUodXBkYXRlKTtcbiBcdFx0XHRcdH1cbiBcdFx0XHR9O1xuIFx0XHR9KTtcbiBcdH1cblxuIFx0dmFyIGhvdEFwcGx5T25VcGRhdGUgPSB0cnVlO1xuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHR2YXIgaG90Q3VycmVudEhhc2ggPSBcIjhkY2Q2MzI0YzlhYjYwMWY3Y2IwXCI7XG4gXHR2YXIgaG90UmVxdWVzdFRpbWVvdXQgPSAxMDAwMDtcbiBcdHZhciBob3RDdXJyZW50TW9kdWxlRGF0YSA9IHt9O1xuIFx0dmFyIGhvdEN1cnJlbnRDaGlsZE1vZHVsZTtcbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0dmFyIGhvdEN1cnJlbnRQYXJlbnRzID0gW107XG4gXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW51c2VkLXZhcnNcbiBcdHZhciBob3RDdXJyZW50UGFyZW50c1RlbXAgPSBbXTtcblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVSZXF1aXJlKG1vZHVsZUlkKSB7XG4gXHRcdHZhciBtZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRpZiAoIW1lKSByZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXztcbiBcdFx0dmFyIGZuID0gZnVuY3Rpb24ocmVxdWVzdCkge1xuIFx0XHRcdGlmIChtZS5ob3QuYWN0aXZlKSB7XG4gXHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XSkge1xuIFx0XHRcdFx0XHRpZiAoaW5zdGFsbGVkTW9kdWxlc1tyZXF1ZXN0XS5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpID09PSAtMSkge1xuIFx0XHRcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbcmVxdWVzdF0ucGFyZW50cy5wdXNoKG1vZHVsZUlkKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0aG90Q3VycmVudFBhcmVudHMgPSBbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRob3RDdXJyZW50Q2hpbGRNb2R1bGUgPSByZXF1ZXN0O1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKG1lLmNoaWxkcmVuLmluZGV4T2YocmVxdWVzdCkgPT09IC0xKSB7XG4gXHRcdFx0XHRcdG1lLmNoaWxkcmVuLnB1c2gocmVxdWVzdCk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdGNvbnNvbGUud2FybihcbiBcdFx0XHRcdFx0XCJbSE1SXSB1bmV4cGVjdGVkIHJlcXVpcmUoXCIgK1xuIFx0XHRcdFx0XHRcdHJlcXVlc3QgK1xuIFx0XHRcdFx0XHRcdFwiKSBmcm9tIGRpc3Bvc2VkIG1vZHVsZSBcIiArXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWRcbiBcdFx0XHRcdCk7XG4gXHRcdFx0XHRob3RDdXJyZW50UGFyZW50cyA9IFtdO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhyZXF1ZXN0KTtcbiBcdFx0fTtcbiBcdFx0dmFyIE9iamVjdEZhY3RvcnkgPSBmdW5jdGlvbiBPYmplY3RGYWN0b3J5KG5hbWUpIHtcbiBcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG4gXHRcdFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fW25hbWVdO1xuIFx0XHRcdFx0fSxcbiBcdFx0XHRcdHNldDogZnVuY3Rpb24odmFsdWUpIHtcbiBcdFx0XHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfX1tuYW1lXSA9IHZhbHVlO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH07XG4gXHRcdH07XG4gXHRcdGZvciAodmFyIG5hbWUgaW4gX193ZWJwYWNrX3JlcXVpcmVfXykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChfX3dlYnBhY2tfcmVxdWlyZV9fLCBuYW1lKSAmJlxuIFx0XHRcdFx0bmFtZSAhPT0gXCJlXCIgJiZcbiBcdFx0XHRcdG5hbWUgIT09IFwidFwiXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZm4sIG5hbWUsIE9iamVjdEZhY3RvcnkobmFtZSkpO1xuIFx0XHRcdH1cbiBcdFx0fVxuIFx0XHRmbi5lID0gZnVuY3Rpb24oY2h1bmtJZCkge1xuIFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicmVhZHlcIikgaG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHRob3RDaHVua3NMb2FkaW5nKys7XG4gXHRcdFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18uZShjaHVua0lkKS50aGVuKGZpbmlzaENodW5rTG9hZGluZywgZnVuY3Rpb24oZXJyKSB7XG4gXHRcdFx0XHRmaW5pc2hDaHVua0xvYWRpbmcoKTtcbiBcdFx0XHRcdHRocm93IGVycjtcbiBcdFx0XHR9KTtcblxuIFx0XHRcdGZ1bmN0aW9uIGZpbmlzaENodW5rTG9hZGluZygpIHtcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmctLTtcbiBcdFx0XHRcdGlmIChob3RTdGF0dXMgPT09IFwicHJlcGFyZVwiKSB7XG4gXHRcdFx0XHRcdGlmICghaG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdKSB7XG4gXHRcdFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0aWYgKGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiYgaG90V2FpdGluZ0ZpbGVzID09PSAwKSB7XG4gXHRcdFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9O1xuIFx0XHRmbi50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0XHRpZiAobW9kZSAmIDEpIHZhbHVlID0gZm4odmFsdWUpO1xuIFx0XHRcdHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLnQodmFsdWUsIG1vZGUgJiB+MSk7XG4gXHRcdH07XG4gXHRcdHJldHVybiBmbjtcbiBcdH1cblxuIFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG4gXHRmdW5jdGlvbiBob3RDcmVhdGVNb2R1bGUobW9kdWxlSWQpIHtcbiBcdFx0dmFyIGhvdCA9IHtcbiBcdFx0XHQvLyBwcml2YXRlIHN0dWZmXG4gXHRcdFx0X2FjY2VwdGVkRGVwZW5kZW5jaWVzOiB7fSxcbiBcdFx0XHRfZGVjbGluZWREZXBlbmRlbmNpZXM6IHt9LFxuIFx0XHRcdF9zZWxmQWNjZXB0ZWQ6IGZhbHNlLFxuIFx0XHRcdF9zZWxmRGVjbGluZWQ6IGZhbHNlLFxuIFx0XHRcdF9zZWxmSW52YWxpZGF0ZWQ6IGZhbHNlLFxuIFx0XHRcdF9kaXNwb3NlSGFuZGxlcnM6IFtdLFxuIFx0XHRcdF9tYWluOiBob3RDdXJyZW50Q2hpbGRNb2R1bGUgIT09IG1vZHVsZUlkLFxuXG4gXHRcdFx0Ly8gTW9kdWxlIEFQSVxuIFx0XHRcdGFjdGl2ZTogdHJ1ZSxcbiBcdFx0XHRhY2NlcHQ6IGZ1bmN0aW9uKGRlcCwgY2FsbGJhY2spIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmQWNjZXB0ZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJmdW5jdGlvblwiKSBob3QuX3NlbGZBY2NlcHRlZCA9IGRlcDtcbiBcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBkZXAgPT09IFwib2JqZWN0XCIpXG4gXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgZGVwLmxlbmd0aDsgaSsrKVxuIFx0XHRcdFx0XHRcdGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwW2ldXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0XHRlbHNlIGhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwXSA9IGNhbGxiYWNrIHx8IGZ1bmN0aW9uKCkge307XG4gXHRcdFx0fSxcbiBcdFx0XHRkZWNsaW5lOiBmdW5jdGlvbihkZXApIHtcbiBcdFx0XHRcdGlmIChkZXAgPT09IHVuZGVmaW5lZCkgaG90Ll9zZWxmRGVjbGluZWQgPSB0cnVlO1xuIFx0XHRcdFx0ZWxzZSBpZiAodHlwZW9mIGRlcCA9PT0gXCJvYmplY3RcIilcbiBcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBkZXAubGVuZ3RoOyBpKyspXG4gXHRcdFx0XHRcdFx0aG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBbaV1dID0gdHJ1ZTtcbiBcdFx0XHRcdGVsc2UgaG90Ll9kZWNsaW5lZERlcGVuZGVuY2llc1tkZXBdID0gdHJ1ZTtcbiBcdFx0XHR9LFxuIFx0XHRcdGRpc3Bvc2U6IGZ1bmN0aW9uKGNhbGxiYWNrKSB7XG4gXHRcdFx0XHRob3QuX2Rpc3Bvc2VIYW5kbGVycy5wdXNoKGNhbGxiYWNrKTtcbiBcdFx0XHR9LFxuIFx0XHRcdGFkZERpc3Bvc2VIYW5kbGVyOiBmdW5jdGlvbihjYWxsYmFjaykge1xuIFx0XHRcdFx0aG90Ll9kaXNwb3NlSGFuZGxlcnMucHVzaChjYWxsYmFjayk7XG4gXHRcdFx0fSxcbiBcdFx0XHRyZW1vdmVEaXNwb3NlSGFuZGxlcjogZnVuY3Rpb24oY2FsbGJhY2spIHtcbiBcdFx0XHRcdHZhciBpZHggPSBob3QuX2Rpc3Bvc2VIYW5kbGVycy5pbmRleE9mKGNhbGxiYWNrKTtcbiBcdFx0XHRcdGlmIChpZHggPj0gMCkgaG90Ll9kaXNwb3NlSGFuZGxlcnMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0fSxcbiBcdFx0XHRpbnZhbGlkYXRlOiBmdW5jdGlvbigpIHtcbiBcdFx0XHRcdHRoaXMuX3NlbGZJbnZhbGlkYXRlZCA9IHRydWU7XG4gXHRcdFx0XHRzd2l0Y2ggKGhvdFN0YXR1cykge1xuIFx0XHRcdFx0XHRjYXNlIFwiaWRsZVwiOlxuIFx0XHRcdFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xuIFx0XHRcdFx0XHRcdGhvdFVwZGF0ZVttb2R1bGVJZF0gPSBtb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdFx0XHRob3RTZXRTdGF0dXMoXCJyZWFkeVwiKTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcInJlYWR5XCI6XG4gXHRcdFx0XHRcdFx0aG90QXBwbHlJbnZhbGlkYXRlZE1vZHVsZShtb2R1bGVJZCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJwcmVwYXJlXCI6XG4gXHRcdFx0XHRcdGNhc2UgXCJjaGVja1wiOlxuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZVwiOlxuIFx0XHRcdFx0XHRjYXNlIFwiYXBwbHlcIjpcbiBcdFx0XHRcdFx0XHQoaG90UXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzID1cbiBcdFx0XHRcdFx0XHRcdGhvdFF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcyB8fCBbXSkucHVzaChtb2R1bGVJZCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGRlZmF1bHQ6XG4gXHRcdFx0XHRcdFx0Ly8gaWdub3JlIHJlcXVlc3RzIGluIGVycm9yIHN0YXRlc1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH0sXG5cbiBcdFx0XHQvLyBNYW5hZ2VtZW50IEFQSVxuIFx0XHRcdGNoZWNrOiBob3RDaGVjayxcbiBcdFx0XHRhcHBseTogaG90QXBwbHksXG4gXHRcdFx0c3RhdHVzOiBmdW5jdGlvbihsKSB7XG4gXHRcdFx0XHRpZiAoIWwpIHJldHVybiBob3RTdGF0dXM7XG4gXHRcdFx0XHRob3RTdGF0dXNIYW5kbGVycy5wdXNoKGwpO1xuIFx0XHRcdH0sXG4gXHRcdFx0YWRkU3RhdHVzSGFuZGxlcjogZnVuY3Rpb24obCkge1xuIFx0XHRcdFx0aG90U3RhdHVzSGFuZGxlcnMucHVzaChsKTtcbiBcdFx0XHR9LFxuIFx0XHRcdHJlbW92ZVN0YXR1c0hhbmRsZXI6IGZ1bmN0aW9uKGwpIHtcbiBcdFx0XHRcdHZhciBpZHggPSBob3RTdGF0dXNIYW5kbGVycy5pbmRleE9mKGwpO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSBob3RTdGF0dXNIYW5kbGVycy5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHR9LFxuXG4gXHRcdFx0Ly9pbmhlcml0IGZyb20gcHJldmlvdXMgZGlzcG9zZSBjYWxsXG4gXHRcdFx0ZGF0YTogaG90Q3VycmVudE1vZHVsZURhdGFbbW9kdWxlSWRdXG4gXHRcdH07XG4gXHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IHVuZGVmaW5lZDtcbiBcdFx0cmV0dXJuIGhvdDtcbiBcdH1cblxuIFx0dmFyIGhvdFN0YXR1c0hhbmRsZXJzID0gW107XG4gXHR2YXIgaG90U3RhdHVzID0gXCJpZGxlXCI7XG5cbiBcdGZ1bmN0aW9uIGhvdFNldFN0YXR1cyhuZXdTdGF0dXMpIHtcbiBcdFx0aG90U3RhdHVzID0gbmV3U3RhdHVzO1xuIFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGhvdFN0YXR1c0hhbmRsZXJzLmxlbmd0aDsgaSsrKVxuIFx0XHRcdGhvdFN0YXR1c0hhbmRsZXJzW2ldLmNhbGwobnVsbCwgbmV3U3RhdHVzKTtcbiBcdH1cblxuIFx0Ly8gd2hpbGUgZG93bmxvYWRpbmdcbiBcdHZhciBob3RXYWl0aW5nRmlsZXMgPSAwO1xuIFx0dmFyIGhvdENodW5rc0xvYWRpbmcgPSAwO1xuIFx0dmFyIGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xuIFx0dmFyIGhvdFJlcXVlc3RlZEZpbGVzTWFwID0ge307XG4gXHR2YXIgaG90QXZhaWxhYmxlRmlsZXNNYXAgPSB7fTtcbiBcdHZhciBob3REZWZlcnJlZDtcblxuIFx0Ly8gVGhlIHVwZGF0ZSBpbmZvXG4gXHR2YXIgaG90VXBkYXRlLCBob3RVcGRhdGVOZXdIYXNoLCBob3RRdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXM7XG5cbiBcdGZ1bmN0aW9uIHRvTW9kdWxlSWQoaWQpIHtcbiBcdFx0dmFyIGlzTnVtYmVyID0gK2lkICsgXCJcIiA9PT0gaWQ7XG4gXHRcdHJldHVybiBpc051bWJlciA/ICtpZCA6IGlkO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RDaGVjayhhcHBseSkge1xuIFx0XHRpZiAoaG90U3RhdHVzICE9PSBcImlkbGVcIikge1xuIFx0XHRcdHRocm93IG5ldyBFcnJvcihcImNoZWNrKCkgaXMgb25seSBhbGxvd2VkIGluIGlkbGUgc3RhdHVzXCIpO1xuIFx0XHR9XG4gXHRcdGhvdEFwcGx5T25VcGRhdGUgPSBhcHBseTtcbiBcdFx0aG90U2V0U3RhdHVzKFwiY2hlY2tcIik7XG4gXHRcdHJldHVybiBob3REb3dubG9hZE1hbmlmZXN0KGhvdFJlcXVlc3RUaW1lb3V0KS50aGVuKGZ1bmN0aW9uKHVwZGF0ZSkge1xuIFx0XHRcdGlmICghdXBkYXRlKSB7XG4gXHRcdFx0XHRob3RTZXRTdGF0dXMoaG90QXBwbHlJbnZhbGlkYXRlZE1vZHVsZXMoKSA/IFwicmVhZHlcIiA6IFwiaWRsZVwiKTtcbiBcdFx0XHRcdHJldHVybiBudWxsO1xuIFx0XHRcdH1cbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGhvdFdhaXRpbmdGaWxlc01hcCA9IHt9O1xuIFx0XHRcdGhvdEF2YWlsYWJsZUZpbGVzTWFwID0gdXBkYXRlLmM7XG4gXHRcdFx0aG90VXBkYXRlTmV3SGFzaCA9IHVwZGF0ZS5oO1xuXG4gXHRcdFx0aG90U2V0U3RhdHVzKFwicHJlcGFyZVwiKTtcbiBcdFx0XHR2YXIgcHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuIFx0XHRcdFx0aG90RGVmZXJyZWQgPSB7XG4gXHRcdFx0XHRcdHJlc29sdmU6IHJlc29sdmUsXG4gXHRcdFx0XHRcdHJlamVjdDogcmVqZWN0XG4gXHRcdFx0XHR9O1xuIFx0XHRcdH0pO1xuIFx0XHRcdGhvdFVwZGF0ZSA9IHt9O1xuIFx0XHRcdHZhciBjaHVua0lkID0gXCJtYWluXCI7XG4gXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWxvbmUtYmxvY2tzXG4gXHRcdFx0e1xuIFx0XHRcdFx0aG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0fVxuIFx0XHRcdGlmIChcbiBcdFx0XHRcdGhvdFN0YXR1cyA9PT0gXCJwcmVwYXJlXCIgJiZcbiBcdFx0XHRcdGhvdENodW5rc0xvYWRpbmcgPT09IDAgJiZcbiBcdFx0XHRcdGhvdFdhaXRpbmdGaWxlcyA9PT0gMFxuIFx0XHRcdCkge1xuIFx0XHRcdFx0aG90VXBkYXRlRG93bmxvYWRlZCgpO1xuIFx0XHRcdH1cbiBcdFx0XHRyZXR1cm4gcHJvbWlzZTtcbiBcdFx0fSk7XG4gXHR9XG5cbiBcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtdmFyc1xuIFx0ZnVuY3Rpb24gaG90QWRkVXBkYXRlQ2h1bmsoY2h1bmtJZCwgbW9yZU1vZHVsZXMpIHtcbiBcdFx0aWYgKCFob3RBdmFpbGFibGVGaWxlc01hcFtjaHVua0lkXSB8fCAhaG90UmVxdWVzdGVkRmlsZXNNYXBbY2h1bmtJZF0pXG4gXHRcdFx0cmV0dXJuO1xuIFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IGZhbHNlO1xuIFx0XHRmb3IgKHZhciBtb2R1bGVJZCBpbiBtb3JlTW9kdWxlcykge1xuIFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwobW9yZU1vZHVsZXMsIG1vZHVsZUlkKSkge1xuIFx0XHRcdFx0aG90VXBkYXRlW21vZHVsZUlkXSA9IG1vcmVNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHR9XG4gXHRcdH1cbiBcdFx0aWYgKC0taG90V2FpdGluZ0ZpbGVzID09PSAwICYmIGhvdENodW5rc0xvYWRpbmcgPT09IDApIHtcbiBcdFx0XHRob3RVcGRhdGVEb3dubG9hZGVkKCk7XG4gXHRcdH1cbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90RW5zdXJlVXBkYXRlQ2h1bmsoY2h1bmtJZCkge1xuIFx0XHRpZiAoIWhvdEF2YWlsYWJsZUZpbGVzTWFwW2NodW5rSWRdKSB7XG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzTWFwW2NodW5rSWRdID0gdHJ1ZTtcbiBcdFx0fSBlbHNlIHtcbiBcdFx0XHRob3RSZXF1ZXN0ZWRGaWxlc01hcFtjaHVua0lkXSA9IHRydWU7XG4gXHRcdFx0aG90V2FpdGluZ0ZpbGVzKys7XG4gXHRcdFx0aG90RG93bmxvYWRVcGRhdGVDaHVuayhjaHVua0lkKTtcbiBcdFx0fVxuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RVcGRhdGVEb3dubG9hZGVkKCkge1xuIFx0XHRob3RTZXRTdGF0dXMoXCJyZWFkeVwiKTtcbiBcdFx0dmFyIGRlZmVycmVkID0gaG90RGVmZXJyZWQ7XG4gXHRcdGhvdERlZmVycmVkID0gbnVsbDtcbiBcdFx0aWYgKCFkZWZlcnJlZCkgcmV0dXJuO1xuIFx0XHRpZiAoaG90QXBwbHlPblVwZGF0ZSkge1xuIFx0XHRcdC8vIFdyYXAgZGVmZXJyZWQgb2JqZWN0IGluIFByb21pc2UgdG8gbWFyayBpdCBhcyBhIHdlbGwtaGFuZGxlZCBQcm9taXNlIHRvXG4gXHRcdFx0Ly8gYXZvaWQgdHJpZ2dlcmluZyB1bmNhdWdodCBleGNlcHRpb24gd2FybmluZyBpbiBDaHJvbWUuXG4gXHRcdFx0Ly8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ2NTY2NlxuIFx0XHRcdFByb21pc2UucmVzb2x2ZSgpXG4gXHRcdFx0XHQudGhlbihmdW5jdGlvbigpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIGhvdEFwcGx5KGhvdEFwcGx5T25VcGRhdGUpO1xuIFx0XHRcdFx0fSlcbiBcdFx0XHRcdC50aGVuKFxuIFx0XHRcdFx0XHRmdW5jdGlvbihyZXN1bHQpIHtcbiBcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKHJlc3VsdCk7XG4gXHRcdFx0XHRcdH0sXG4gXHRcdFx0XHRcdGZ1bmN0aW9uKGVycikge1xuIFx0XHRcdFx0XHRcdGRlZmVycmVkLnJlamVjdChlcnIpO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHQpO1xuIFx0XHR9IGVsc2Uge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0XHRmb3IgKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcbiBcdFx0XHRcdGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoaG90VXBkYXRlLCBpZCkpIHtcbiBcdFx0XHRcdFx0b3V0ZGF0ZWRNb2R1bGVzLnB1c2godG9Nb2R1bGVJZChpZCkpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0XHRkZWZlcnJlZC5yZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdH1cbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90QXBwbHkob3B0aW9ucykge1xuIFx0XHRpZiAoaG90U3RhdHVzICE9PSBcInJlYWR5XCIpXG4gXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiYXBwbHkoKSBpcyBvbmx5IGFsbG93ZWQgaW4gcmVhZHkgc3RhdHVzXCIpO1xuIFx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiBcdFx0cmV0dXJuIGhvdEFwcGx5SW50ZXJuYWwob3B0aW9ucyk7XG4gXHR9XG5cbiBcdGZ1bmN0aW9uIGhvdEFwcGx5SW50ZXJuYWwob3B0aW9ucykge1xuIFx0XHRob3RBcHBseUludmFsaWRhdGVkTW9kdWxlcygpO1xuXG4gXHRcdHZhciBjYjtcbiBcdFx0dmFyIGk7XG4gXHRcdHZhciBqO1xuIFx0XHR2YXIgbW9kdWxlO1xuIFx0XHR2YXIgbW9kdWxlSWQ7XG5cbiBcdFx0ZnVuY3Rpb24gZ2V0QWZmZWN0ZWRTdHVmZih1cGRhdGVNb2R1bGVJZCkge1xuIFx0XHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbdXBkYXRlTW9kdWxlSWRdO1xuIFx0XHRcdHZhciBvdXRkYXRlZERlcGVuZGVuY2llcyA9IHt9O1xuXG4gXHRcdFx0dmFyIHF1ZXVlID0gb3V0ZGF0ZWRNb2R1bGVzLm1hcChmdW5jdGlvbihpZCkge1xuIFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0Y2hhaW46IFtpZF0sXG4gXHRcdFx0XHRcdGlkOiBpZFxuIFx0XHRcdFx0fTtcbiBcdFx0XHR9KTtcbiBcdFx0XHR3aGlsZSAocXVldWUubGVuZ3RoID4gMCkge1xuIFx0XHRcdFx0dmFyIHF1ZXVlSXRlbSA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdFx0dmFyIG1vZHVsZUlkID0gcXVldWVJdGVtLmlkO1xuIFx0XHRcdFx0dmFyIGNoYWluID0gcXVldWVJdGVtLmNoYWluO1xuIFx0XHRcdFx0bW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRpZiAoXG4gXHRcdFx0XHRcdCFtb2R1bGUgfHxcbiBcdFx0XHRcdFx0KG1vZHVsZS5ob3QuX3NlbGZBY2NlcHRlZCAmJiAhbW9kdWxlLmhvdC5fc2VsZkludmFsaWRhdGVkKVxuIFx0XHRcdFx0KVxuIFx0XHRcdFx0XHRjb250aW51ZTtcbiBcdFx0XHRcdGlmIChtb2R1bGUuaG90Ll9zZWxmRGVjbGluZWQpIHtcbiBcdFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0XHR0eXBlOiBcInNlbGYtZGVjbGluZWRcIixcbiBcdFx0XHRcdFx0XHRjaGFpbjogY2hhaW4sXG4gXHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkXG4gXHRcdFx0XHRcdH07XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAobW9kdWxlLmhvdC5fbWFpbikge1xuIFx0XHRcdFx0XHRyZXR1cm4ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwidW5hY2NlcHRlZFwiLFxuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbW9kdWxlLnBhcmVudHMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0dmFyIHBhcmVudElkID0gbW9kdWxlLnBhcmVudHNbaV07XG4gXHRcdFx0XHRcdHZhciBwYXJlbnQgPSBpbnN0YWxsZWRNb2R1bGVzW3BhcmVudElkXTtcbiBcdFx0XHRcdFx0aWYgKCFwYXJlbnQpIGNvbnRpbnVlO1xuIFx0XHRcdFx0XHRpZiAocGFyZW50LmhvdC5fZGVjbGluZWREZXBlbmRlbmNpZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0XHRcdFx0cmV0dXJuIHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwiZGVjbGluZWRcIixcbiBcdFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG4gXHRcdFx0XHRcdFx0XHRtb2R1bGVJZDogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdFx0XHRwYXJlbnRJZDogcGFyZW50SWRcbiBcdFx0XHRcdFx0XHR9O1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmIChvdXRkYXRlZE1vZHVsZXMuaW5kZXhPZihwYXJlbnRJZCkgIT09IC0xKSBjb250aW51ZTtcbiBcdFx0XHRcdFx0aWYgKHBhcmVudC5ob3QuX2FjY2VwdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSkge1xuIFx0XHRcdFx0XHRcdGlmICghb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdKVxuIFx0XHRcdFx0XHRcdFx0b3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdID0gW107XG4gXHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdLCBbbW9kdWxlSWRdKTtcbiBcdFx0XHRcdFx0XHRjb250aW51ZTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRkZWxldGUgb3V0ZGF0ZWREZXBlbmRlbmNpZXNbcGFyZW50SWRdO1xuIFx0XHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMucHVzaChwYXJlbnRJZCk7XG4gXHRcdFx0XHRcdHF1ZXVlLnB1c2goe1xuIFx0XHRcdFx0XHRcdGNoYWluOiBjaGFpbi5jb25jYXQoW3BhcmVudElkXSksXG4gXHRcdFx0XHRcdFx0aWQ6IHBhcmVudElkXG4gXHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cblxuIFx0XHRcdHJldHVybiB7XG4gXHRcdFx0XHR0eXBlOiBcImFjY2VwdGVkXCIsXG4gXHRcdFx0XHRtb2R1bGVJZDogdXBkYXRlTW9kdWxlSWQsXG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXM6IG91dGRhdGVkTW9kdWxlcyxcbiBcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzOiBvdXRkYXRlZERlcGVuZGVuY2llc1xuIFx0XHRcdH07XG4gXHRcdH1cblxuIFx0XHRmdW5jdGlvbiBhZGRBbGxUb1NldChhLCBiKSB7XG4gXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBiLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHR2YXIgaXRlbSA9IGJbaV07XG4gXHRcdFx0XHRpZiAoYS5pbmRleE9mKGl0ZW0pID09PSAtMSkgYS5wdXNoKGl0ZW0pO1xuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIGF0IGJlZ2luIGFsbCB1cGRhdGVzIG1vZHVsZXMgYXJlIG91dGRhdGVkXG4gXHRcdC8vIHRoZSBcIm91dGRhdGVkXCIgc3RhdHVzIGNhbiBwcm9wYWdhdGUgdG8gcGFyZW50cyBpZiB0aGV5IGRvbid0IGFjY2VwdCB0aGUgY2hpbGRyZW5cbiBcdFx0dmFyIG91dGRhdGVkRGVwZW5kZW5jaWVzID0ge307XG4gXHRcdHZhciBvdXRkYXRlZE1vZHVsZXMgPSBbXTtcbiBcdFx0dmFyIGFwcGxpZWRVcGRhdGUgPSB7fTtcblxuIFx0XHR2YXIgd2FyblVuZXhwZWN0ZWRSZXF1aXJlID0gZnVuY3Rpb24gd2FyblVuZXhwZWN0ZWRSZXF1aXJlKCkge1xuIFx0XHRcdGNvbnNvbGUud2FybihcbiBcdFx0XHRcdFwiW0hNUl0gdW5leHBlY3RlZCByZXF1aXJlKFwiICsgcmVzdWx0Lm1vZHVsZUlkICsgXCIpIHRvIGRpc3Bvc2VkIG1vZHVsZVwiXG4gXHRcdFx0KTtcbiBcdFx0fTtcblxuIFx0XHRmb3IgKHZhciBpZCBpbiBob3RVcGRhdGUpIHtcbiBcdFx0XHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGhvdFVwZGF0ZSwgaWQpKSB7XG4gXHRcdFx0XHRtb2R1bGVJZCA9IHRvTW9kdWxlSWQoaWQpO1xuIFx0XHRcdFx0LyoqIEB0eXBlIHtUT0RPfSAqL1xuIFx0XHRcdFx0dmFyIHJlc3VsdDtcbiBcdFx0XHRcdGlmIChob3RVcGRhdGVbaWRdKSB7XG4gXHRcdFx0XHRcdHJlc3VsdCA9IGdldEFmZmVjdGVkU3R1ZmYobW9kdWxlSWQpO1xuIFx0XHRcdFx0fSBlbHNlIHtcbiBcdFx0XHRcdFx0cmVzdWx0ID0ge1xuIFx0XHRcdFx0XHRcdHR5cGU6IFwiZGlzcG9zZWRcIixcbiBcdFx0XHRcdFx0XHRtb2R1bGVJZDogaWRcbiBcdFx0XHRcdFx0fTtcbiBcdFx0XHRcdH1cbiBcdFx0XHRcdC8qKiBAdHlwZSB7RXJyb3J8ZmFsc2V9ICovXG4gXHRcdFx0XHR2YXIgYWJvcnRFcnJvciA9IGZhbHNlO1xuIFx0XHRcdFx0dmFyIGRvQXBwbHkgPSBmYWxzZTtcbiBcdFx0XHRcdHZhciBkb0Rpc3Bvc2UgPSBmYWxzZTtcbiBcdFx0XHRcdHZhciBjaGFpbkluZm8gPSBcIlwiO1xuIFx0XHRcdFx0aWYgKHJlc3VsdC5jaGFpbikge1xuIFx0XHRcdFx0XHRjaGFpbkluZm8gPSBcIlxcblVwZGF0ZSBwcm9wYWdhdGlvbjogXCIgKyByZXN1bHQuY2hhaW4uam9pbihcIiAtPiBcIik7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRzd2l0Y2ggKHJlc3VsdC50eXBlKSB7XG4gXHRcdFx0XHRcdGNhc2UgXCJzZWxmLWRlY2xpbmVkXCI6XG4gXHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25EZWNsaW5lZCkgb3B0aW9ucy5vbkRlY2xpbmVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZURlY2xpbmVkKVxuIFx0XHRcdFx0XHRcdFx0YWJvcnRFcnJvciA9IG5ldyBFcnJvcihcbiBcdFx0XHRcdFx0XHRcdFx0XCJBYm9ydGVkIGJlY2F1c2Ugb2Ygc2VsZiBkZWNsaW5lOiBcIiArXG4gXHRcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm1vZHVsZUlkICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRjaGFpbkluZm9cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJkZWNsaW5lZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRGVjbGluZWQpIG9wdGlvbnMub25EZWNsaW5lZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVEZWNsaW5lZClcbiBcdFx0XHRcdFx0XHRcdGFib3J0RXJyb3IgPSBuZXcgRXJyb3IoXG4gXHRcdFx0XHRcdFx0XHRcdFwiQWJvcnRlZCBiZWNhdXNlIG9mIGRlY2xpbmVkIGRlcGVuZGVuY3k6IFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQubW9kdWxlSWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdFwiIGluIFwiICtcbiBcdFx0XHRcdFx0XHRcdFx0XHRyZXN1bHQucGFyZW50SWQgK1xuIFx0XHRcdFx0XHRcdFx0XHRcdGNoYWluSW5mb1xuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHRicmVhaztcbiBcdFx0XHRcdFx0Y2FzZSBcInVuYWNjZXB0ZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vblVuYWNjZXB0ZWQpIG9wdGlvbnMub25VbmFjY2VwdGVkKHJlc3VsdCk7XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZVVuYWNjZXB0ZWQpXG4gXHRcdFx0XHRcdFx0XHRhYm9ydEVycm9yID0gbmV3IEVycm9yKFxuIFx0XHRcdFx0XHRcdFx0XHRcIkFib3J0ZWQgYmVjYXVzZSBcIiArIG1vZHVsZUlkICsgXCIgaXMgbm90IGFjY2VwdGVkXCIgKyBjaGFpbkluZm9cbiBcdFx0XHRcdFx0XHRcdCk7XG4gXHRcdFx0XHRcdFx0YnJlYWs7XG4gXHRcdFx0XHRcdGNhc2UgXCJhY2NlcHRlZFwiOlxuIFx0XHRcdFx0XHRcdGlmIChvcHRpb25zLm9uQWNjZXB0ZWQpIG9wdGlvbnMub25BY2NlcHRlZChyZXN1bHQpO1xuIFx0XHRcdFx0XHRcdGRvQXBwbHkgPSB0cnVlO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRjYXNlIFwiZGlzcG9zZWRcIjpcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkRpc3Bvc2VkKSBvcHRpb25zLm9uRGlzcG9zZWQocmVzdWx0KTtcbiBcdFx0XHRcdFx0XHRkb0Rpc3Bvc2UgPSB0cnVlO1xuIFx0XHRcdFx0XHRcdGJyZWFrO1xuIFx0XHRcdFx0XHRkZWZhdWx0OlxuIFx0XHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcIlVuZXhjZXB0aW9uIHR5cGUgXCIgKyByZXN1bHQudHlwZSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0XHRpZiAoYWJvcnRFcnJvcikge1xuIFx0XHRcdFx0XHRob3RTZXRTdGF0dXMoXCJhYm9ydFwiKTtcbiBcdFx0XHRcdFx0cmV0dXJuIFByb21pc2UucmVqZWN0KGFib3J0RXJyb3IpO1xuIFx0XHRcdFx0fVxuIFx0XHRcdFx0aWYgKGRvQXBwbHkpIHtcbiBcdFx0XHRcdFx0YXBwbGllZFVwZGF0ZVttb2R1bGVJZF0gPSBob3RVcGRhdGVbbW9kdWxlSWRdO1xuIFx0XHRcdFx0XHRhZGRBbGxUb1NldChvdXRkYXRlZE1vZHVsZXMsIHJlc3VsdC5vdXRkYXRlZE1vZHVsZXMpO1xuIFx0XHRcdFx0XHRmb3IgKG1vZHVsZUlkIGluIHJlc3VsdC5vdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdFx0XHRcdGlmIChcbiBcdFx0XHRcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChcbiBcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzLFxuIFx0XHRcdFx0XHRcdFx0XHRtb2R1bGVJZFxuIFx0XHRcdFx0XHRcdFx0KVxuIFx0XHRcdFx0XHRcdCkge1xuIFx0XHRcdFx0XHRcdFx0aWYgKCFvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF0pXG4gXHRcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSA9IFtdO1xuIFx0XHRcdFx0XHRcdFx0YWRkQWxsVG9TZXQoXG4gXHRcdFx0XHRcdFx0XHRcdG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXSxcbiBcdFx0XHRcdFx0XHRcdFx0cmVzdWx0Lm91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXVxuIFx0XHRcdFx0XHRcdFx0KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHRcdGlmIChkb0Rpc3Bvc2UpIHtcbiBcdFx0XHRcdFx0YWRkQWxsVG9TZXQob3V0ZGF0ZWRNb2R1bGVzLCBbcmVzdWx0Lm1vZHVsZUlkXSk7XG4gXHRcdFx0XHRcdGFwcGxpZWRVcGRhdGVbbW9kdWxlSWRdID0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlO1xuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIFN0b3JlIHNlbGYgYWNjZXB0ZWQgb3V0ZGF0ZWQgbW9kdWxlcyB0byByZXF1aXJlIHRoZW0gbGF0ZXIgYnkgdGhlIG1vZHVsZSBzeXN0ZW1cbiBcdFx0dmFyIG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlcyA9IFtdO1xuIFx0XHRmb3IgKGkgPSAwOyBpIDwgb3V0ZGF0ZWRNb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0bW9kdWxlSWQgPSBvdXRkYXRlZE1vZHVsZXNbaV07XG4gXHRcdFx0aWYgKFxuIFx0XHRcdFx0aW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gJiZcbiBcdFx0XHRcdGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkFjY2VwdGVkICYmXG4gXHRcdFx0XHQvLyByZW1vdmVkIHNlbGYtYWNjZXB0ZWQgbW9kdWxlcyBzaG91bGQgbm90IGJlIHJlcXVpcmVkXG4gXHRcdFx0XHRhcHBsaWVkVXBkYXRlW21vZHVsZUlkXSAhPT0gd2FyblVuZXhwZWN0ZWRSZXF1aXJlICYmXG4gXHRcdFx0XHQvLyB3aGVuIGNhbGxlZCBpbnZhbGlkYXRlIHNlbGYtYWNjZXB0aW5nIGlzIG5vdCBwb3NzaWJsZVxuIFx0XHRcdFx0IWluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmhvdC5fc2VsZkludmFsaWRhdGVkXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMucHVzaCh7XG4gXHRcdFx0XHRcdG1vZHVsZTogbW9kdWxlSWQsXG4gXHRcdFx0XHRcdHBhcmVudHM6IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLnBhcmVudHMuc2xpY2UoKSxcbiBcdFx0XHRcdFx0ZXJyb3JIYW5kbGVyOiBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXS5ob3QuX3NlbGZBY2NlcHRlZFxuIFx0XHRcdFx0fSk7XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gTm93IGluIFwiZGlzcG9zZVwiIHBoYXNlXG4gXHRcdGhvdFNldFN0YXR1cyhcImRpc3Bvc2VcIik7XG4gXHRcdE9iamVjdC5rZXlzKGhvdEF2YWlsYWJsZUZpbGVzTWFwKS5mb3JFYWNoKGZ1bmN0aW9uKGNodW5rSWQpIHtcbiBcdFx0XHRpZiAoaG90QXZhaWxhYmxlRmlsZXNNYXBbY2h1bmtJZF0gPT09IGZhbHNlKSB7XG4gXHRcdFx0XHRob3REaXNwb3NlQ2h1bmsoY2h1bmtJZCk7XG4gXHRcdFx0fVxuIFx0XHR9KTtcblxuIFx0XHR2YXIgaWR4O1xuIFx0XHR2YXIgcXVldWUgPSBvdXRkYXRlZE1vZHVsZXMuc2xpY2UoKTtcbiBcdFx0d2hpbGUgKHF1ZXVlLmxlbmd0aCA+IDApIHtcbiBcdFx0XHRtb2R1bGVJZCA9IHF1ZXVlLnBvcCgpO1xuIFx0XHRcdG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdO1xuIFx0XHRcdGlmICghbW9kdWxlKSBjb250aW51ZTtcblxuIFx0XHRcdHZhciBkYXRhID0ge307XG5cbiBcdFx0XHQvLyBDYWxsIGRpc3Bvc2UgaGFuZGxlcnNcbiBcdFx0XHR2YXIgZGlzcG9zZUhhbmRsZXJzID0gbW9kdWxlLmhvdC5fZGlzcG9zZUhhbmRsZXJzO1xuIFx0XHRcdGZvciAoaiA9IDA7IGogPCBkaXNwb3NlSGFuZGxlcnMubGVuZ3RoOyBqKyspIHtcbiBcdFx0XHRcdGNiID0gZGlzcG9zZUhhbmRsZXJzW2pdO1xuIFx0XHRcdFx0Y2IoZGF0YSk7XG4gXHRcdFx0fVxuIFx0XHRcdGhvdEN1cnJlbnRNb2R1bGVEYXRhW21vZHVsZUlkXSA9IGRhdGE7XG5cbiBcdFx0XHQvLyBkaXNhYmxlIG1vZHVsZSAodGhpcyBkaXNhYmxlcyByZXF1aXJlcyBmcm9tIHRoaXMgbW9kdWxlKVxuIFx0XHRcdG1vZHVsZS5ob3QuYWN0aXZlID0gZmFsc2U7XG5cbiBcdFx0XHQvLyByZW1vdmUgbW9kdWxlIGZyb20gY2FjaGVcbiBcdFx0XHRkZWxldGUgaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF07XG5cbiBcdFx0XHQvLyB3aGVuIGRpc3Bvc2luZyB0aGVyZSBpcyBubyBuZWVkIHRvIGNhbGwgZGlzcG9zZSBoYW5kbGVyXG4gXHRcdFx0ZGVsZXRlIG91dGRhdGVkRGVwZW5kZW5jaWVzW21vZHVsZUlkXTtcblxuIFx0XHRcdC8vIHJlbW92ZSBcInBhcmVudHNcIiByZWZlcmVuY2VzIGZyb20gYWxsIGNoaWxkcmVuXG4gXHRcdFx0Zm9yIChqID0gMDsgaiA8IG1vZHVsZS5jaGlsZHJlbi5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0dmFyIGNoaWxkID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGUuY2hpbGRyZW5bal1dO1xuIFx0XHRcdFx0aWYgKCFjaGlsZCkgY29udGludWU7XG4gXHRcdFx0XHRpZHggPSBjaGlsZC5wYXJlbnRzLmluZGV4T2YobW9kdWxlSWQpO1xuIFx0XHRcdFx0aWYgKGlkeCA+PSAwKSB7XG4gXHRcdFx0XHRcdGNoaWxkLnBhcmVudHMuc3BsaWNlKGlkeCwgMSk7XG4gXHRcdFx0XHR9XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gcmVtb3ZlIG91dGRhdGVkIGRlcGVuZGVuY3kgZnJvbSBtb2R1bGUgY2hpbGRyZW5cbiBcdFx0dmFyIGRlcGVuZGVuY3k7XG4gXHRcdHZhciBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcztcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdGZvciAoaiA9IDA7IGogPCBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llcy5sZW5ndGg7IGorKykge1xuIFx0XHRcdFx0XHRcdGRlcGVuZGVuY3kgPSBtb2R1bGVPdXRkYXRlZERlcGVuZGVuY2llc1tqXTtcbiBcdFx0XHRcdFx0XHRpZHggPSBtb2R1bGUuY2hpbGRyZW4uaW5kZXhPZihkZXBlbmRlbmN5KTtcbiBcdFx0XHRcdFx0XHRpZiAoaWR4ID49IDApIG1vZHVsZS5jaGlsZHJlbi5zcGxpY2UoaWR4LCAxKTtcbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIE5vdyBpbiBcImFwcGx5XCIgcGhhc2VcbiBcdFx0aG90U2V0U3RhdHVzKFwiYXBwbHlcIik7XG5cbiBcdFx0aWYgKGhvdFVwZGF0ZU5ld0hhc2ggIT09IHVuZGVmaW5lZCkge1xuIFx0XHRcdGhvdEN1cnJlbnRIYXNoID0gaG90VXBkYXRlTmV3SGFzaDtcbiBcdFx0XHRob3RVcGRhdGVOZXdIYXNoID0gdW5kZWZpbmVkO1xuIFx0XHR9XG4gXHRcdGhvdFVwZGF0ZSA9IHVuZGVmaW5lZDtcblxuIFx0XHQvLyBpbnNlcnQgbmV3IGNvZGVcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBhcHBsaWVkVXBkYXRlKSB7XG4gXHRcdFx0aWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChhcHBsaWVkVXBkYXRlLCBtb2R1bGVJZCkpIHtcbiBcdFx0XHRcdG1vZHVsZXNbbW9kdWxlSWRdID0gYXBwbGllZFVwZGF0ZVttb2R1bGVJZF07XG4gXHRcdFx0fVxuIFx0XHR9XG5cbiBcdFx0Ly8gY2FsbCBhY2NlcHQgaGFuZGxlcnNcbiBcdFx0dmFyIGVycm9yID0gbnVsbDtcbiBcdFx0Zm9yIChtb2R1bGVJZCBpbiBvdXRkYXRlZERlcGVuZGVuY2llcykge1xuIFx0XHRcdGlmIChcbiBcdFx0XHRcdE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvdXRkYXRlZERlcGVuZGVuY2llcywgbW9kdWxlSWQpXG4gXHRcdFx0KSB7XG4gXHRcdFx0XHRtb2R1bGUgPSBpbnN0YWxsZWRNb2R1bGVzW21vZHVsZUlkXTtcbiBcdFx0XHRcdGlmIChtb2R1bGUpIHtcbiBcdFx0XHRcdFx0bW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMgPSBvdXRkYXRlZERlcGVuZGVuY2llc1ttb2R1bGVJZF07XG4gXHRcdFx0XHRcdHZhciBjYWxsYmFja3MgPSBbXTtcbiBcdFx0XHRcdFx0Zm9yIChpID0gMDsgaSA8IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzLmxlbmd0aDsgaSsrKSB7XG4gXHRcdFx0XHRcdFx0ZGVwZW5kZW5jeSA9IG1vZHVsZU91dGRhdGVkRGVwZW5kZW5jaWVzW2ldO1xuIFx0XHRcdFx0XHRcdGNiID0gbW9kdWxlLmhvdC5fYWNjZXB0ZWREZXBlbmRlbmNpZXNbZGVwZW5kZW5jeV07XG4gXHRcdFx0XHRcdFx0aWYgKGNiKSB7XG4gXHRcdFx0XHRcdFx0XHRpZiAoY2FsbGJhY2tzLmluZGV4T2YoY2IpICE9PSAtMSkgY29udGludWU7XG4gXHRcdFx0XHRcdFx0XHRjYWxsYmFja3MucHVzaChjYik7XG4gXHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGZvciAoaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHRcdFx0XHRjYiA9IGNhbGxiYWNrc1tpXTtcbiBcdFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdFx0Y2IobW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXMpO1xuIFx0XHRcdFx0XHRcdH0gY2F0Y2ggKGVycikge1xuIFx0XHRcdFx0XHRcdFx0aWYgKG9wdGlvbnMub25FcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0XHR0eXBlOiBcImFjY2VwdC1lcnJvcmVkXCIsXG4gXHRcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRcdGRlcGVuZGVuY3lJZDogbW9kdWxlT3V0ZGF0ZWREZXBlbmRlbmNpZXNbaV0sXG4gXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyO1xuIFx0XHRcdFx0XHRcdFx0fVxuIFx0XHRcdFx0XHRcdH1cbiBcdFx0XHRcdFx0fVxuIFx0XHRcdFx0fVxuIFx0XHRcdH1cbiBcdFx0fVxuXG4gXHRcdC8vIExvYWQgc2VsZiBhY2NlcHRlZCBtb2R1bGVzXG4gXHRcdGZvciAoaSA9IDA7IGkgPCBvdXRkYXRlZFNlbGZBY2NlcHRlZE1vZHVsZXMubGVuZ3RoOyBpKyspIHtcbiBcdFx0XHR2YXIgaXRlbSA9IG91dGRhdGVkU2VsZkFjY2VwdGVkTW9kdWxlc1tpXTtcbiBcdFx0XHRtb2R1bGVJZCA9IGl0ZW0ubW9kdWxlO1xuIFx0XHRcdGhvdEN1cnJlbnRQYXJlbnRzID0gaXRlbS5wYXJlbnRzO1xuIFx0XHRcdGhvdEN1cnJlbnRDaGlsZE1vZHVsZSA9IG1vZHVsZUlkO1xuIFx0XHRcdHRyeSB7XG4gXHRcdFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKTtcbiBcdFx0XHR9IGNhdGNoIChlcnIpIHtcbiBcdFx0XHRcdGlmICh0eXBlb2YgaXRlbS5lcnJvckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikge1xuIFx0XHRcdFx0XHR0cnkge1xuIFx0XHRcdFx0XHRcdGl0ZW0uZXJyb3JIYW5kbGVyKGVycik7XG4gXHRcdFx0XHRcdH0gY2F0Y2ggKGVycjIpIHtcbiBcdFx0XHRcdFx0XHRpZiAob3B0aW9ucy5vbkVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdFx0dHlwZTogXCJzZWxmLWFjY2VwdC1lcnJvci1oYW5kbGVyLWVycm9yZWRcIixcbiBcdFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0XHRlcnJvcjogZXJyMixcbiBcdFx0XHRcdFx0XHRcdFx0b3JpZ2luYWxFcnJvcjogZXJyXG4gXHRcdFx0XHRcdFx0XHR9KTtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFvcHRpb25zLmlnbm9yZUVycm9yZWQpIHtcbiBcdFx0XHRcdFx0XHRcdGlmICghZXJyb3IpIGVycm9yID0gZXJyMjtcbiBcdFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH0gZWxzZSB7XG4gXHRcdFx0XHRcdGlmIChvcHRpb25zLm9uRXJyb3JlZCkge1xuIFx0XHRcdFx0XHRcdG9wdGlvbnMub25FcnJvcmVkKHtcbiBcdFx0XHRcdFx0XHRcdHR5cGU6IFwic2VsZi1hY2NlcHQtZXJyb3JlZFwiLFxuIFx0XHRcdFx0XHRcdFx0bW9kdWxlSWQ6IG1vZHVsZUlkLFxuIFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGVyclxuIFx0XHRcdFx0XHRcdH0pO1xuIFx0XHRcdFx0XHR9XG4gXHRcdFx0XHRcdGlmICghb3B0aW9ucy5pZ25vcmVFcnJvcmVkKSB7XG4gXHRcdFx0XHRcdFx0aWYgKCFlcnJvcikgZXJyb3IgPSBlcnI7XG4gXHRcdFx0XHRcdH1cbiBcdFx0XHRcdH1cbiBcdFx0XHR9XG4gXHRcdH1cblxuIFx0XHQvLyBoYW5kbGUgZXJyb3JzIGluIGFjY2VwdCBoYW5kbGVycyBhbmQgc2VsZiBhY2NlcHRlZCBtb2R1bGUgbG9hZFxuIFx0XHRpZiAoZXJyb3IpIHtcbiBcdFx0XHRob3RTZXRTdGF0dXMoXCJmYWlsXCIpO1xuIFx0XHRcdHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XG4gXHRcdH1cblxuIFx0XHRpZiAoaG90UXVldWVkSW52YWxpZGF0ZWRNb2R1bGVzKSB7XG4gXHRcdFx0cmV0dXJuIGhvdEFwcGx5SW50ZXJuYWwob3B0aW9ucykudGhlbihmdW5jdGlvbihsaXN0KSB7XG4gXHRcdFx0XHRvdXRkYXRlZE1vZHVsZXMuZm9yRWFjaChmdW5jdGlvbihtb2R1bGVJZCkge1xuIFx0XHRcdFx0XHRpZiAobGlzdC5pbmRleE9mKG1vZHVsZUlkKSA8IDApIGxpc3QucHVzaChtb2R1bGVJZCk7XG4gXHRcdFx0XHR9KTtcbiBcdFx0XHRcdHJldHVybiBsaXN0O1xuIFx0XHRcdH0pO1xuIFx0XHR9XG5cbiBcdFx0aG90U2V0U3RhdHVzKFwiaWRsZVwiKTtcbiBcdFx0cmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uKHJlc29sdmUpIHtcbiBcdFx0XHRyZXNvbHZlKG91dGRhdGVkTW9kdWxlcyk7XG4gXHRcdH0pO1xuIFx0fVxuXG4gXHRmdW5jdGlvbiBob3RBcHBseUludmFsaWRhdGVkTW9kdWxlcygpIHtcbiBcdFx0aWYgKGhvdFF1ZXVlZEludmFsaWRhdGVkTW9kdWxlcykge1xuIFx0XHRcdGlmICghaG90VXBkYXRlKSBob3RVcGRhdGUgPSB7fTtcbiBcdFx0XHRob3RRdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMuZm9yRWFjaChob3RBcHBseUludmFsaWRhdGVkTW9kdWxlKTtcbiBcdFx0XHRob3RRdWV1ZWRJbnZhbGlkYXRlZE1vZHVsZXMgPSB1bmRlZmluZWQ7XG4gXHRcdFx0cmV0dXJuIHRydWU7XG4gXHRcdH1cbiBcdH1cblxuIFx0ZnVuY3Rpb24gaG90QXBwbHlJbnZhbGlkYXRlZE1vZHVsZShtb2R1bGVJZCkge1xuIFx0XHRpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChob3RVcGRhdGUsIG1vZHVsZUlkKSlcbiBcdFx0XHRob3RVcGRhdGVbbW9kdWxlSWRdID0gbW9kdWxlc1ttb2R1bGVJZF07XG4gXHR9XG5cbiBcdC8vIFRoZSBtb2R1bGUgY2FjaGVcbiBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG5cbiBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG5cbiBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4gXHRcdFx0cmV0dXJuIGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdLmV4cG9ydHM7XG4gXHRcdH1cbiBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbiBcdFx0dmFyIG1vZHVsZSA9IGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdID0ge1xuIFx0XHRcdGk6IG1vZHVsZUlkLFxuIFx0XHRcdGw6IGZhbHNlLFxuIFx0XHRcdGV4cG9ydHM6IHt9LFxuIFx0XHRcdGhvdDogaG90Q3JlYXRlTW9kdWxlKG1vZHVsZUlkKSxcbiBcdFx0XHRwYXJlbnRzOiAoaG90Q3VycmVudFBhcmVudHNUZW1wID0gaG90Q3VycmVudFBhcmVudHMsIGhvdEN1cnJlbnRQYXJlbnRzID0gW10sIGhvdEN1cnJlbnRQYXJlbnRzVGVtcCksXG4gXHRcdFx0Y2hpbGRyZW46IFtdXG4gXHRcdH07XG5cbiBcdFx0Ly8gRXhlY3V0ZSB0aGUgbW9kdWxlIGZ1bmN0aW9uXG4gXHRcdG1vZHVsZXNbbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIGhvdENyZWF0ZVJlcXVpcmUobW9kdWxlSWQpKTtcblxuIFx0XHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG4gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcblxuIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4gXHR9XG5cblxuIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGVzIG9iamVjdCAoX193ZWJwYWNrX21vZHVsZXNfXylcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubSA9IG1vZHVsZXM7XG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlIGNhY2hlXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmMgPSBpbnN0YWxsZWRNb2R1bGVzO1xuXG4gXHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9uIGZvciBoYXJtb255IGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uZCA9IGZ1bmN0aW9uKGV4cG9ydHMsIG5hbWUsIGdldHRlcikge1xuIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIG5hbWUsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBnZXR0ZXIgfSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbiBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbiBcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFN5bWJvbC50b1N0cmluZ1RhZywgeyB2YWx1ZTogJ01vZHVsZScgfSk7XG4gXHRcdH1cbiBcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbiBcdH07XG5cbiBcdC8vIGNyZWF0ZSBhIGZha2UgbmFtZXNwYWNlIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDE6IHZhbHVlIGlzIGEgbW9kdWxlIGlkLCByZXF1aXJlIGl0XG4gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbiBcdC8vIG1vZGUgJiA0OiByZXR1cm4gdmFsdWUgd2hlbiBhbHJlYWR5IG5zIG9iamVjdFxuIFx0Ly8gbW9kZSAmIDh8MTogYmVoYXZlIGxpa2UgcmVxdWlyZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbiBcdFx0aWYobW9kZSAmIDEpIHZhbHVlID0gX193ZWJwYWNrX3JlcXVpcmVfXyh2YWx1ZSk7XG4gXHRcdGlmKG1vZGUgJiA4KSByZXR1cm4gdmFsdWU7XG4gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4gXHRcdHZhciBucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gXHRcdF9fd2VicGFja19yZXF1aXJlX18ucihucyk7XG4gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbiBcdFx0aWYobW9kZSAmIDIgJiYgdHlwZW9mIHZhbHVlICE9ICdzdHJpbmcnKSBmb3IodmFyIGtleSBpbiB2YWx1ZSkgX193ZWJwYWNrX3JlcXVpcmVfXy5kKG5zLCBrZXksIGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gdmFsdWVba2V5XTsgfS5iaW5kKG51bGwsIGtleSkpO1xuIFx0XHRyZXR1cm4gbnM7XG4gXHR9O1xuXG4gXHQvLyBnZXREZWZhdWx0RXhwb3J0IGZ1bmN0aW9uIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9uLWhhcm1vbnkgbW9kdWxlc1xuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4gXHRcdHZhciBnZXR0ZXIgPSBtb2R1bGUgJiYgbW9kdWxlLl9fZXNNb2R1bGUgP1xuIFx0XHRcdGZ1bmN0aW9uIGdldERlZmF1bHQoKSB7IHJldHVybiBtb2R1bGVbJ2RlZmF1bHQnXTsgfSA6XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbiBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgJ2EnLCBnZXR0ZXIpO1xuIFx0XHRyZXR1cm4gZ2V0dGVyO1xuIFx0fTtcblxuIFx0Ly8gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG5cbiBcdC8vIF9fd2VicGFja19wdWJsaWNfcGF0aF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuXG4gXHQvLyBfX3dlYnBhY2tfaGFzaF9fXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmggPSBmdW5jdGlvbigpIHsgcmV0dXJuIGhvdEN1cnJlbnRIYXNoOyB9O1xuXG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIGhvdENyZWF0ZVJlcXVpcmUoXCIuL3NyYy9hcHAvbWFpbi50c1wiKShfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSBcIi4vc3JjL2FwcC9tYWluLnRzXCIpO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIGZlYXR1cmVzLCBjYWxjdWxhdGVzIHRoZSBiYm94IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXG4gKlxuICogQG5hbWUgYmJveFxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybnMge0JCb3h9IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0gdHVyZi5saW5lU3RyaW5nKFtbLTc0LCA0MF0sIFstNzgsIDQyXSwgWy04MiwgMzVdXSk7XG4gKiB2YXIgYmJveCA9IHR1cmYuYmJveChsaW5lKTtcbiAqIHZhciBiYm94UG9seWdvbiA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIGJib3hQb2x5Z29uXVxuICovXG5mdW5jdGlvbiBiYm94KGdlb2pzb24pIHtcbiAgICB2YXIgcmVzdWx0ID0gW0luZmluaXR5LCBJbmZpbml0eSwgLUluZmluaXR5LCAtSW5maW5pdHldO1xuICAgIG1ldGFfMS5jb29yZEVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIGlmIChyZXN1bHRbMF0gPiBjb29yZFswXSkge1xuICAgICAgICAgICAgcmVzdWx0WzBdID0gY29vcmRbMF07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdFsxXSA+IGNvb3JkWzFdKSB7XG4gICAgICAgICAgICByZXN1bHRbMV0gPSBjb29yZFsxXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0WzJdIDwgY29vcmRbMF0pIHtcbiAgICAgICAgICAgIHJlc3VsdFsyXSA9IGNvb3JkWzBdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHRbM10gPCBjb29yZFsxXSkge1xuICAgICAgICAgICAgcmVzdWx0WzNdID0gY29vcmRbMV07XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYmJveDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCJAdHVyZi9oZWxwZXJzXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vIGh0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG4vKipcbiAqIFRha2VzIHR3byB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgZmluZHMgdGhlIGdlb2dyYXBoaWMgYmVhcmluZyBiZXR3ZWVuIHRoZW0sXG4gKiBpLmUuIHRoZSBhbmdsZSBtZWFzdXJlZCBpbiBkZWdyZWVzIGZyb20gdGhlIG5vcnRoIGxpbmUgKDAgZGVncmVlcylcbiAqXG4gKiBAbmFtZSBiZWFyaW5nXG4gKiBAcGFyYW0ge0Nvb3JkfSBzdGFydCBzdGFydGluZyBQb2ludFxuICogQHBhcmFtIHtDb29yZH0gZW5kIGVuZGluZyBQb2ludFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmZpbmFsPWZhbHNlXSBjYWxjdWxhdGVzIHRoZSBmaW5hbCBiZWFyaW5nIGlmIHRydWVcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGJlYXJpbmcgaW4gZGVjaW1hbCBkZWdyZWVzLCBiZXR3ZWVuIC0xODAgYW5kIDE4MCBkZWdyZWVzIChwb3NpdGl2ZSBjbG9ja3dpc2UpXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50MSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICogdmFyIHBvaW50MiA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10pO1xuICpcbiAqIHZhciBiZWFyaW5nID0gdHVyZi5iZWFyaW5nKHBvaW50MSwgcG9pbnQyKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbcG9pbnQxLCBwb2ludDJdXG4gKiBwb2ludDEucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCdcbiAqIHBvaW50Mi5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjMGYwJ1xuICogcG9pbnQxLnByb3BlcnRpZXMuYmVhcmluZyA9IGJlYXJpbmdcbiAqL1xuZnVuY3Rpb24gYmVhcmluZyhzdGFydCwgZW5kLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyBSZXZlcnNlIGNhbGN1bGF0aW9uXG4gICAgaWYgKG9wdGlvbnMuZmluYWwgPT09IHRydWUpIHtcbiAgICAgICAgcmV0dXJuIGNhbGN1bGF0ZUZpbmFsQmVhcmluZyhzdGFydCwgZW5kKTtcbiAgICB9XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGludmFyaWFudF8xLmdldENvb3JkKHN0YXJ0KTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmQoZW5kKTtcbiAgICB2YXIgbG9uMSA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMVswXSk7XG4gICAgdmFyIGxvbjIgPSBoZWxwZXJzXzEuZGVncmVlc1RvUmFkaWFucyhjb29yZGluYXRlczJbMF0pO1xuICAgIHZhciBsYXQxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgbGF0MiA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMlsxXSk7XG4gICAgdmFyIGEgPSBNYXRoLnNpbihsb24yIC0gbG9uMSkgKiBNYXRoLmNvcyhsYXQyKTtcbiAgICB2YXIgYiA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obGF0MikgLVxuICAgICAgICBNYXRoLnNpbihsYXQxKSAqIE1hdGguY29zKGxhdDIpICogTWF0aC5jb3MobG9uMiAtIGxvbjEpO1xuICAgIHJldHVybiBoZWxwZXJzXzEucmFkaWFuc1RvRGVncmVlcyhNYXRoLmF0YW4yKGEsIGIpKTtcbn1cbi8qKlxuICogQ2FsY3VsYXRlcyBGaW5hbCBCZWFyaW5nXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7Q29vcmR9IHN0YXJ0IHN0YXJ0aW5nIFBvaW50XG4gKiBAcGFyYW0ge0Nvb3JkfSBlbmQgZW5kaW5nIFBvaW50XG4gKiBAcmV0dXJucyB7bnVtYmVyfSBiZWFyaW5nXG4gKi9cbmZ1bmN0aW9uIGNhbGN1bGF0ZUZpbmFsQmVhcmluZyhzdGFydCwgZW5kKSB7XG4gICAgLy8gU3dhcCBzdGFydCAmIGVuZFxuICAgIHZhciBiZWFyID0gYmVhcmluZyhlbmQsIHN0YXJ0KTtcbiAgICBiZWFyID0gKGJlYXIgKyAxODApICUgMzYwO1xuICAgIHJldHVybiBiZWFyO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYmVhcmluZztcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmJveF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJAdHVyZi9iYm94XCIpKTtcbnZhciBib29sZWFuX3BvaW50X2luX3BvbHlnb25fMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1pbi1wb2x5Z29uXCIpKTtcbnZhciBib29sZWFuX3BvaW50X29uX2xpbmVfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1vbi1saW5lXCIpKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG4vKipcbiAqIEJvb2xlYW4tY29udGFpbnMgcmV0dXJucyBUcnVlIGlmIHRoZSBzZWNvbmQgZ2VvbWV0cnkgaXMgY29tcGxldGVseSBjb250YWluZWQgYnkgdGhlIGZpcnN0IGdlb21ldHJ5LlxuICogVGhlIGludGVyaW9ycyBvZiBib3RoIGdlb21ldHJpZXMgbXVzdCBpbnRlcnNlY3QgYW5kLCB0aGUgaW50ZXJpb3IgYW5kIGJvdW5kYXJ5IG9mIHRoZSBzZWNvbmRhcnkgKGdlb21ldHJ5IGIpXG4gKiBtdXN0IG5vdCBpbnRlcnNlY3QgdGhlIGV4dGVyaW9yIG9mIHRoZSBwcmltYXJ5IChnZW9tZXRyeSBhKS5cbiAqIEJvb2xlYW4tY29udGFpbnMgcmV0dXJucyB0aGUgZXhhY3Qgb3Bwb3NpdGUgcmVzdWx0IG9mIHRoZSBgQHR1cmYvYm9vbGVhbi13aXRoaW5gLlxuICpcbiAqIEBuYW1lIGJvb2xlYW5Db250YWluc1xuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPGFueT59IGZlYXR1cmUxIEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPGFueT59IGZlYXR1cmUyIEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbWzEsIDFdLCBbMSwgMl0sIFsxLCAzXSwgWzEsIDRdXSk7XG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFsxLCAyXSk7XG4gKlxuICogdHVyZi5ib29sZWFuQ29udGFpbnMobGluZSwgcG9pbnQpO1xuICogLy89dHJ1ZVxuICovXG5mdW5jdGlvbiBib29sZWFuQ29udGFpbnMoZmVhdHVyZTEsIGZlYXR1cmUyKSB7XG4gICAgdmFyIGdlb20xID0gaW52YXJpYW50XzEuZ2V0R2VvbShmZWF0dXJlMSk7XG4gICAgdmFyIGdlb20yID0gaW52YXJpYW50XzEuZ2V0R2VvbShmZWF0dXJlMik7XG4gICAgdmFyIHR5cGUxID0gaW52YXJpYW50XzEuZ2V0VHlwZShmZWF0dXJlMSk7XG4gICAgdmFyIHR5cGUyID0gaW52YXJpYW50XzEuZ2V0VHlwZShmZWF0dXJlMik7XG4gICAgdmFyIGNvb3JkczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMoZmVhdHVyZTEpO1xuICAgIHZhciBjb29yZHMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGZlYXR1cmUyKTtcbiAgICBzd2l0Y2ggKHR5cGUxKSB7XG4gICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlMikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29tcGFyZUNvb3Jkcyhjb29yZHMxLCBjb29yZHMyKTtcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZWF0dXJlMiBcIiArIHR5cGUyICsgXCIgZ2VvbWV0cnkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgIHN3aXRjaCAodHlwZTIpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwiUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzUG9pbnRJbk11bHRpUG9pbnQoZ2VvbTEsIGdlb20yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNdWx0aVBvaW50SW5NdWx0aVBvaW50KGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIgKyB0eXBlMiArIFwiIGdlb21ldHJ5IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUyKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlBvaW50XCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGdlb20yLCBnZW9tMSwgeyBpZ25vcmVFbmRWZXJ0aWNlczogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTGluZVN0cmluZ1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNMaW5lT25MaW5lKGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgY2FzZSBcIk11bHRpUG9pbnRcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTXVsdGlQb2ludE9uTGluZShnZW9tMSwgZ2VvbTIpO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImZlYXR1cmUyIFwiICsgdHlwZTIgKyBcIiBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwiUG9seWdvblwiOlxuICAgICAgICAgICAgc3dpdGNoICh0eXBlMikge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChnZW9tMiwgZ2VvbTEsIHsgaWdub3JlQm91bmRhcnk6IHRydWUgfSk7XG4gICAgICAgICAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGlzTGluZUluUG9seShnZW9tMSwgZ2VvbTIpO1xuICAgICAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBpc1BvbHlJblBvbHkoZ2VvbTEsIGdlb20yKTtcbiAgICAgICAgICAgICAgICBjYXNlIFwiTXVsdGlQb2ludFwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNNdWx0aVBvaW50SW5Qb2x5KGdlb20xLCBnZW9tMik7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZmVhdHVyZTIgXCIgKyB0eXBlMiArIFwiIGdlb21ldHJ5IG5vdCBzdXBwb3J0ZWRcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJmZWF0dXJlMSBcIiArIHR5cGUxICsgXCIgZ2VvbWV0cnkgbm90IHN1cHBvcnRlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuQ29udGFpbnM7XG5mdW5jdGlvbiBpc1BvaW50SW5NdWx0aVBvaW50KG11bHRpUG9pbnQsIHB0KSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIG91dHB1dCA9IGZhbHNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCBtdWx0aVBvaW50LmNvb3JkaW5hdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChjb21wYXJlQ29vcmRzKG11bHRpUG9pbnQuY29vcmRpbmF0ZXNbaV0sIHB0LmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgb3V0cHV0ID0gdHJ1ZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59XG5leHBvcnRzLmlzUG9pbnRJbk11bHRpUG9pbnQgPSBpc1BvaW50SW5NdWx0aVBvaW50O1xuZnVuY3Rpb24gaXNNdWx0aVBvaW50SW5NdWx0aVBvaW50KG11bHRpUG9pbnQxLCBtdWx0aVBvaW50Mikge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtdWx0aVBvaW50Mi5jb29yZGluYXRlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgdmFyIGNvb3JkMiA9IF9hW19pXTtcbiAgICAgICAgdmFyIG1hdGNoRm91bmQgPSBmYWxzZTtcbiAgICAgICAgZm9yICh2YXIgX2IgPSAwLCBfYyA9IG11bHRpUG9pbnQxLmNvb3JkaW5hdGVzOyBfYiA8IF9jLmxlbmd0aDsgX2IrKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkMSA9IF9jW19iXTtcbiAgICAgICAgICAgIGlmIChjb21wYXJlQ29vcmRzKGNvb3JkMiwgY29vcmQxKSkge1xuICAgICAgICAgICAgICAgIG1hdGNoRm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICghbWF0Y2hGb3VuZCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRJbk11bHRpUG9pbnQgPSBpc011bHRpUG9pbnRJbk11bHRpUG9pbnQ7XG5mdW5jdGlvbiBpc011bHRpUG9pbnRPbkxpbmUobGluZVN0cmluZywgbXVsdGlQb2ludCkge1xuICAgIHZhciBoYXZlRm91bmRJbnRlcmlvclBvaW50ID0gZmFsc2U7XG4gICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IG11bHRpUG9pbnQuY29vcmRpbmF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb29yZCA9IF9hW19pXTtcbiAgICAgICAgaWYgKGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmQsIGxpbmVTdHJpbmcsIHsgaWdub3JlRW5kVmVydGljZXM6IHRydWUgfSkpIHtcbiAgICAgICAgICAgIGhhdmVGb3VuZEludGVyaW9yUG9pbnQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChjb29yZCwgbGluZVN0cmluZykpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAoaGF2ZUZvdW5kSW50ZXJpb3JQb2ludCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRPbkxpbmUgPSBpc011bHRpUG9pbnRPbkxpbmU7XG5mdW5jdGlvbiBpc011bHRpUG9pbnRJblBvbHkocG9seWdvbiwgbXVsdGlQb2ludCkge1xuICAgIGZvciAodmFyIF9pID0gMCwgX2EgPSBtdWx0aVBvaW50LmNvb3JkaW5hdGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgY29vcmQgPSBfYVtfaV07XG4gICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChjb29yZCwgcG9seWdvbiwgeyBpZ25vcmVCb3VuZGFyeTogdHJ1ZSB9KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc011bHRpUG9pbnRJblBvbHkgPSBpc011bHRpUG9pbnRJblBvbHk7XG5mdW5jdGlvbiBpc0xpbmVPbkxpbmUobGluZVN0cmluZzEsIGxpbmVTdHJpbmcyKSB7XG4gICAgdmFyIGhhdmVGb3VuZEludGVyaW9yUG9pbnQgPSBmYWxzZTtcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gbGluZVN0cmluZzIuY29vcmRpbmF0ZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciBjb29yZHMgPSBfYVtfaV07XG4gICAgICAgIGlmIChib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KHsgdHlwZTogXCJQb2ludFwiLCBjb29yZGluYXRlczogY29vcmRzIH0sIGxpbmVTdHJpbmcxLCB7IGlnbm9yZUVuZFZlcnRpY2VzOiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBoYXZlRm91bmRJbnRlcmlvclBvaW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoeyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBjb29yZHMgfSwgbGluZVN0cmluZzEsIHsgaWdub3JlRW5kVmVydGljZXM6IGZhbHNlIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGhhdmVGb3VuZEludGVyaW9yUG9pbnQ7XG59XG5leHBvcnRzLmlzTGluZU9uTGluZSA9IGlzTGluZU9uTGluZTtcbmZ1bmN0aW9uIGlzTGluZUluUG9seShwb2x5Z29uLCBsaW5lc3RyaW5nKSB7XG4gICAgdmFyIG91dHB1dCA9IGZhbHNlO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgcG9seUJib3ggPSBiYm94XzEuZGVmYXVsdChwb2x5Z29uKTtcbiAgICB2YXIgbGluZUJib3ggPSBiYm94XzEuZGVmYXVsdChsaW5lc3RyaW5nKTtcbiAgICBpZiAoIWRvQkJveE92ZXJsYXAocG9seUJib3gsIGxpbmVCYm94KSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoaTsgaSA8IGxpbmVzdHJpbmcuY29vcmRpbmF0ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBtaWRQb2ludCA9IGdldE1pZHBvaW50KGxpbmVzdHJpbmcuY29vcmRpbmF0ZXNbaV0sIGxpbmVzdHJpbmcuY29vcmRpbmF0ZXNbaSArIDFdKTtcbiAgICAgICAgaWYgKGJvb2xlYW5fcG9pbnRfaW5fcG9seWdvbl8xLmRlZmF1bHQoeyB0eXBlOiBcIlBvaW50XCIsIGNvb3JkaW5hdGVzOiBtaWRQb2ludCB9LCBwb2x5Z29uLCB7IGlnbm9yZUJvdW5kYXJ5OiB0cnVlIH0pKSB7XG4gICAgICAgICAgICBvdXRwdXQgPSB0cnVlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbn1cbmV4cG9ydHMuaXNMaW5lSW5Qb2x5ID0gaXNMaW5lSW5Qb2x5O1xuLyoqXG4gKiBJcyBQb2x5Z29uMiBpbiBQb2x5Z29uMVxuICogT25seSB0YWtlcyBpbnRvIGFjY291bnQgb3V0ZXIgcmluZ3NcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPFBvbHlnb24+fSBmZWF0dXJlMSBQb2x5Z29uMVxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPFBvbHlnb24+fSBmZWF0dXJlMiBQb2x5Z29uMlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNQb2x5SW5Qb2x5KGZlYXR1cmUxLCBmZWF0dXJlMikge1xuICAgIC8vIEhhbmRsZSBOdWxsc1xuICAgIGlmIChmZWF0dXJlMS50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBmZWF0dXJlMS5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChmZWF0dXJlMi50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBmZWF0dXJlMi5nZW9tZXRyeSA9PT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHZhciBwb2x5MUJib3ggPSBiYm94XzEuZGVmYXVsdChmZWF0dXJlMSk7XG4gICAgdmFyIHBvbHkyQmJveCA9IGJib3hfMS5kZWZhdWx0KGZlYXR1cmUyKTtcbiAgICBpZiAoIWRvQkJveE92ZXJsYXAocG9seTFCYm94LCBwb2x5MkJib3gpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGNvb3JkcyA9IGludmFyaWFudF8xLmdldEdlb20oZmVhdHVyZTIpLmNvb3JkaW5hdGVzO1xuICAgIGZvciAodmFyIF9pID0gMCwgY29vcmRzXzEgPSBjb29yZHM7IF9pIDwgY29vcmRzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgIHZhciByaW5nID0gY29vcmRzXzFbX2ldO1xuICAgICAgICBmb3IgKHZhciBfYSA9IDAsIHJpbmdfMSA9IHJpbmc7IF9hIDwgcmluZ18xLmxlbmd0aDsgX2ErKykge1xuICAgICAgICAgICAgdmFyIGNvb3JkID0gcmluZ18xW19hXTtcbiAgICAgICAgICAgIGlmICghYm9vbGVhbl9wb2ludF9pbl9wb2x5Z29uXzEuZGVmYXVsdChjb29yZCwgZmVhdHVyZTEpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufVxuZXhwb3J0cy5pc1BvbHlJblBvbHkgPSBpc1BvbHlJblBvbHk7XG5mdW5jdGlvbiBkb0JCb3hPdmVybGFwKGJib3gxLCBiYm94Mikge1xuICAgIGlmIChiYm94MVswXSA+IGJib3gyWzBdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKGJib3gxWzJdIDwgYmJveDJbMl0pIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYmJveDFbMV0gPiBiYm94MlsxXSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChiYm94MVszXSA8IGJib3gyWzNdKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmRvQkJveE92ZXJsYXAgPSBkb0JCb3hPdmVybGFwO1xuLyoqXG4gKiBjb21wYXJlQ29vcmRzXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7UG9zaXRpb259IHBhaXIxIHBvaW50IFt4LHldXG4gKiBAcGFyYW0ge1Bvc2l0aW9ufSBwYWlyMiBwb2ludCBbeCx5XVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2UgaWYgY29vcmQgcGFpcnMgbWF0Y2hcbiAqL1xuZnVuY3Rpb24gY29tcGFyZUNvb3JkcyhwYWlyMSwgcGFpcjIpIHtcbiAgICByZXR1cm4gcGFpcjFbMF0gPT09IHBhaXIyWzBdICYmIHBhaXIxWzFdID09PSBwYWlyMlsxXTtcbn1cbmV4cG9ydHMuY29tcGFyZUNvb3JkcyA9IGNvbXBhcmVDb29yZHM7XG5mdW5jdGlvbiBnZXRNaWRwb2ludChwYWlyMSwgcGFpcjIpIHtcbiAgICByZXR1cm4gWyhwYWlyMVswXSArIHBhaXIyWzBdKSAvIDIsIChwYWlyMVsxXSArIHBhaXIyWzFdKSAvIDJdO1xufVxuZXhwb3J0cy5nZXRNaWRwb2ludCA9IGdldE1pZHBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgaW52YXJpYW50XzEgPSByZXF1aXJlKFwiQHR1cmYvaW52YXJpYW50XCIpO1xudmFyIGxpbmVfb3ZlcmxhcF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtb3ZlcmxhcFwiKTtcbnZhciBsaW5lX2ludGVyc2VjdF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtaW50ZXJzZWN0XCIpO1xudmFyIEdlb2pzb25FcXVhbGl0eSA9IHJlcXVpcmUoXCJnZW9qc29uLWVxdWFsaXR5XCIpO1xuLyoqXG4gKiBDb21wYXJlcyB0d28gZ2VvbWV0cmllcyBvZiB0aGUgc2FtZSBkaW1lbnNpb24gYW5kIHJldHVybnMgdHJ1ZSBpZiB0aGVpciBpbnRlcnNlY3Rpb24gc2V0IHJlc3VsdHMgaW4gYSBnZW9tZXRyeVxuICogZGlmZmVyZW50IGZyb20gYm90aCBidXQgb2YgdGhlIHNhbWUgZGltZW5zaW9uLiBJdCBhcHBsaWVzIHRvIFBvbHlnb24vUG9seWdvbiwgTGluZVN0cmluZy9MaW5lU3RyaW5nLFxuICogTXVsdGlwb2ludC9NdWx0aXBvaW50LCBNdWx0aUxpbmVTdHJpbmcvTXVsdGlMaW5lU3RyaW5nIGFuZCBNdWx0aVBvbHlnb24vTXVsdGlQb2x5Z29uLlxuICpcbiAqIEBuYW1lIGJvb2xlYW5PdmVybGFwXG4gKiBAcGFyYW0gIHtHZW9tZXRyeXxGZWF0dXJlPExpbmVTdHJpbmd8TXVsdGlMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlQb2x5Z29uPn0gZmVhdHVyZTEgaW5wdXRcbiAqIEBwYXJhbSAge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xNdWx0aUxpbmVTdHJpbmd8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBmZWF0dXJlMiBpbnB1dFxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSB0dXJmLnBvbHlnb24oW1tbMCwwXSxbMCw1XSxbNSw1XSxbNSwwXSxbMCwwXV1dKTtcbiAqIHZhciBwb2x5MiA9IHR1cmYucG9seWdvbihbW1sxLDFdLFsxLDZdLFs2LDZdLFs2LDFdLFsxLDFdXV0pO1xuICogdmFyIHBvbHkzID0gdHVyZi5wb2x5Z29uKFtbWzEwLDEwXSxbMTAsMTVdLFsxNSwxNV0sWzE1LDEwXSxbMTAsMTBdXV0pO1xuICpcbiAqIHR1cmYuYm9vbGVhbk92ZXJsYXAocG9seTEsIHBvbHkyKVxuICogLy89dHJ1ZVxuICogdHVyZi5ib29sZWFuT3ZlcmxhcChwb2x5MiwgcG9seTMpXG4gKiAvLz1mYWxzZVxuICovXG5mdW5jdGlvbiBib29sZWFuT3ZlcmxhcChmZWF0dXJlMSwgZmVhdHVyZTIpIHtcbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKCFmZWF0dXJlMSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdmZWF0dXJlMSBpcyByZXF1aXJlZCcpO1xuICAgIGlmICghZmVhdHVyZTIpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZmVhdHVyZTIgaXMgcmVxdWlyZWQnKTtcbiAgICB2YXIgdHlwZTEgPSBpbnZhcmlhbnRfMS5nZXRUeXBlKGZlYXR1cmUxKTtcbiAgICB2YXIgdHlwZTIgPSBpbnZhcmlhbnRfMS5nZXRUeXBlKGZlYXR1cmUyKTtcbiAgICBpZiAodHlwZTEgIT09IHR5cGUyKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2ZlYXR1cmVzIG11c3QgYmUgb2YgdGhlIHNhbWUgdHlwZScpO1xuICAgIGlmICh0eXBlMSA9PT0gJ1BvaW50JylcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQb2ludCBnZW9tZXRyeSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgLy8gZmVhdHVyZXMgbXVzdCBiZSBub3QgZXF1YWxcbiAgICB2YXIgZXF1YWxpdHkgPSBuZXcgR2VvanNvbkVxdWFsaXR5KHsgcHJlY2lzaW9uOiA2IH0pO1xuICAgIGlmIChlcXVhbGl0eS5jb21wYXJlKGZlYXR1cmUxLCBmZWF0dXJlMikpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB2YXIgb3ZlcmxhcCA9IDA7XG4gICAgc3dpdGNoICh0eXBlMSkge1xuICAgICAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgICAgIHZhciBjb29yZHMxID0gbWV0YV8xLmNvb3JkQWxsKGZlYXR1cmUxKTtcbiAgICAgICAgICAgIHZhciBjb29yZHMyID0gbWV0YV8xLmNvb3JkQWxsKGZlYXR1cmUyKTtcbiAgICAgICAgICAgIGNvb3JkczEuZm9yRWFjaChmdW5jdGlvbiAoY29vcmQxKSB7XG4gICAgICAgICAgICAgICAgY29vcmRzMi5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZDIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkMVswXSA9PT0gY29vcmQyWzBdICYmIGNvb3JkMVsxXSA9PT0gY29vcmQyWzFdKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICBtZXRhXzEuc2VnbWVudEVhY2goZmVhdHVyZTEsIGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgICAgICAgICAgIG1ldGFfMS5zZWdtZW50RWFjaChmZWF0dXJlMiwgZnVuY3Rpb24gKHNlZ21lbnQyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX292ZXJsYXBfMS5kZWZhdWx0KHNlZ21lbnQxLCBzZWdtZW50MikuZmVhdHVyZXMubGVuZ3RoKVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcCsrO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGNhc2UgJ011bHRpUG9seWdvbic6XG4gICAgICAgICAgICBtZXRhXzEuc2VnbWVudEVhY2goZmVhdHVyZTEsIGZ1bmN0aW9uIChzZWdtZW50MSkge1xuICAgICAgICAgICAgICAgIG1ldGFfMS5zZWdtZW50RWFjaChmZWF0dXJlMiwgZnVuY3Rpb24gKHNlZ21lbnQyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChsaW5lX2ludGVyc2VjdF8xLmRlZmF1bHQoc2VnbWVudDEsIHNlZ21lbnQyKS5mZWF0dXJlcy5sZW5ndGgpXG4gICAgICAgICAgICAgICAgICAgICAgICBvdmVybGFwKys7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gb3ZlcmxhcCA+IDA7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuT3ZlcmxhcDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbiVFMiU4MCU5M29kZF9ydWxlXG4vLyBtb2RpZmllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gd2hpY2ggd2FzIG1vZGlmaWVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGEge0BsaW5rIFBvbHlnb259IG9yIHtAbGluayBNdWx0aVBvbHlnb259IGFuZCBkZXRlcm1pbmVzIGlmIHRoZSBwb2ludFxuICogcmVzaWRlcyBpbnNpZGUgdGhlIHBvbHlnb24uIFRoZSBwb2x5Z29uIGNhbiBiZSBjb252ZXggb3IgY29uY2F2ZS4gVGhlIGZ1bmN0aW9uIGFjY291bnRzIGZvciBob2xlcy5cbiAqXG4gKiBAbmFtZSBib29sZWFuUG9pbnRJblBvbHlnb25cbiAqIEBwYXJhbSB7Q29vcmR9IHBvaW50IGlucHV0IHBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbnxNdWx0aVBvbHlnb24+fSBwb2x5Z29uIGlucHV0IHBvbHlnb24gb3IgbXVsdGlwb2x5Z29uXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlQm91bmRhcnk9ZmFsc2VdIFRydWUgaWYgcG9seWdvbiBib3VuZGFyeSBzaG91bGQgYmUgaWdub3JlZCB3aGVuIGRldGVybWluaW5nIGlmXG4gKiB0aGUgcG9pbnQgaXMgaW5zaWRlIHRoZSBwb2x5Z29uIG90aGVyd2lzZSBmYWxzZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSBgdHJ1ZWAgaWYgdGhlIFBvaW50IGlzIGluc2lkZSB0aGUgUG9seWdvbjsgYGZhbHNlYCBpZiB0aGUgUG9pbnQgaXMgbm90IGluc2lkZSB0aGUgUG9seWdvblxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYucG9pbnQoWy03NywgNDRdKTtcbiAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbXG4gKiAgIFstODEsIDQxXSxcbiAqICAgWy04MSwgNDddLFxuICogICBbLTcyLCA0N10sXG4gKiAgIFstNzIsIDQxXSxcbiAqICAgWy04MSwgNDFdXG4gKiBdXSk7XG4gKlxuICogdHVyZi5ib29sZWFuUG9pbnRJblBvbHlnb24ocHQsIHBvbHkpO1xuICogLy89IHRydWVcbiAqL1xuZnVuY3Rpb24gYm9vbGVhblBvaW50SW5Qb2x5Z29uKHBvaW50LCBwb2x5Z29uLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICAvLyB2YWxpZGF0aW9uXG4gICAgaWYgKCFwb2ludCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwb2ludCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFwb2x5Z29uKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInBvbHlnb24gaXMgcmVxdWlyZWRcIik7XG4gICAgfVxuICAgIHZhciBwdCA9IGludmFyaWFudF8xLmdldENvb3JkKHBvaW50KTtcbiAgICB2YXIgZ2VvbSA9IGludmFyaWFudF8xLmdldEdlb20ocG9seWdvbik7XG4gICAgdmFyIHR5cGUgPSBnZW9tLnR5cGU7XG4gICAgdmFyIGJib3ggPSBwb2x5Z29uLmJib3g7XG4gICAgdmFyIHBvbHlzID0gZ2VvbS5jb29yZGluYXRlcztcbiAgICAvLyBRdWljayBlbGltaW5hdGlvbiBpZiBwb2ludCBpcyBub3QgaW5zaWRlIGJib3hcbiAgICBpZiAoYmJveCAmJiBpbkJCb3gocHQsIGJib3gpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIG5vcm1hbGl6ZSB0byBtdWx0aXBvbHlnb25cbiAgICBpZiAodHlwZSA9PT0gXCJQb2x5Z29uXCIpIHtcbiAgICAgICAgcG9seXMgPSBbcG9seXNdO1xuICAgIH1cbiAgICB2YXIgaW5zaWRlUG9seSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcG9seXMubGVuZ3RoICYmICFpbnNpZGVQb2x5OyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIG91dGVyIHJpbmcgZmlyc3RcbiAgICAgICAgaWYgKGluUmluZyhwdCwgcG9seXNbaV1bMF0sIG9wdGlvbnMuaWdub3JlQm91bmRhcnkpKSB7XG4gICAgICAgICAgICB2YXIgaW5Ib2xlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgayA9IDE7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdGhlIHBvaW50IGluIGFueSBvZiB0aGUgaG9sZXNcbiAgICAgICAgICAgIHdoaWxlIChrIDwgcG9seXNbaV0ubGVuZ3RoICYmICFpbkhvbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5SaW5nKHB0LCBwb2x5c1tpXVtrXSwgIW9wdGlvbnMuaWdub3JlQm91bmRhcnkpKSB7XG4gICAgICAgICAgICAgICAgICAgIGluSG9sZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaW5Ib2xlKSB7XG4gICAgICAgICAgICAgICAgaW5zaWRlUG9seSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGluc2lkZVBvbHk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBib29sZWFuUG9pbnRJblBvbHlnb247XG4vKipcbiAqIGluUmluZ1xuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IHB0IFt4LHldXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PG51bWJlcj4+fSByaW5nIFtbeCx5XSwgW3gseV0sLi5dXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGlnbm9yZUJvdW5kYXJ5IGlnbm9yZUJvdW5kYXJ5XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gaW5SaW5nXG4gKi9cbmZ1bmN0aW9uIGluUmluZyhwdCwgcmluZywgaWdub3JlQm91bmRhcnkpIHtcbiAgICB2YXIgaXNJbnNpZGUgPSBmYWxzZTtcbiAgICBpZiAocmluZ1swXVswXSA9PT0gcmluZ1tyaW5nLmxlbmd0aCAtIDFdWzBdICYmIHJpbmdbMF1bMV0gPT09IHJpbmdbcmluZy5sZW5ndGggLSAxXVsxXSkge1xuICAgICAgICByaW5nID0gcmluZy5zbGljZSgwLCByaW5nLmxlbmd0aCAtIDEpO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgaiA9IHJpbmcubGVuZ3RoIC0gMTsgaSA8IHJpbmcubGVuZ3RoOyBqID0gaSsrKSB7XG4gICAgICAgIHZhciB4aSA9IHJpbmdbaV1bMF07XG4gICAgICAgIHZhciB5aSA9IHJpbmdbaV1bMV07XG4gICAgICAgIHZhciB4aiA9IHJpbmdbal1bMF07XG4gICAgICAgIHZhciB5aiA9IHJpbmdbal1bMV07XG4gICAgICAgIHZhciBvbkJvdW5kYXJ5ID0gKHB0WzFdICogKHhpIC0geGopICsgeWkgKiAoeGogLSBwdFswXSkgKyB5aiAqIChwdFswXSAtIHhpKSA9PT0gMCkgJiZcbiAgICAgICAgICAgICgoeGkgLSBwdFswXSkgKiAoeGogLSBwdFswXSkgPD0gMCkgJiYgKCh5aSAtIHB0WzFdKSAqICh5aiAtIHB0WzFdKSA8PSAwKTtcbiAgICAgICAgaWYgKG9uQm91bmRhcnkpIHtcbiAgICAgICAgICAgIHJldHVybiAhaWdub3JlQm91bmRhcnk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGludGVyc2VjdCA9ICgoeWkgPiBwdFsxXSkgIT09ICh5aiA+IHB0WzFdKSkgJiZcbiAgICAgICAgICAgIChwdFswXSA8ICh4aiAtIHhpKSAqIChwdFsxXSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzSW5zaWRlO1xufVxuLyoqXG4gKiBpbkJCb3hcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb3NpdGlvbn0gcHQgcG9pbnQgW3gseV1cbiAqIEBwYXJhbSB7QkJveH0gYmJveCBCQm94IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZS9mYWxzZSBpZiBwb2ludCBpcyBpbnNpZGUgQkJveFxuICovXG5mdW5jdGlvbiBpbkJCb3gocHQsIGJib3gpIHtcbiAgICByZXR1cm4gYmJveFswXSA8PSBwdFswXSAmJlxuICAgICAgICBiYm94WzFdIDw9IHB0WzFdICYmXG4gICAgICAgIGJib3hbMl0gPj0gcHRbMF0gJiZcbiAgICAgICAgYmJveFszXSA+PSBwdFsxXTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8qKlxuICogUmV0dXJucyB0cnVlIGlmIGEgcG9pbnQgaXMgb24gYSBsaW5lLiBBY2NlcHRzIGEgb3B0aW9uYWwgcGFyYW1ldGVyIHRvIGlnbm9yZSB0aGVcbiAqIHN0YXJ0IGFuZCBlbmQgdmVydGljZXMgb2YgdGhlIGxpbmVzdHJpbmcuXG4gKlxuICogQG5hbWUgYm9vbGVhblBvaW50T25MaW5lXG4gKiBAcGFyYW0ge0Nvb3JkfSBwdCBHZW9KU09OIFBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgR2VvSlNPTiBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuaWdub3JlRW5kVmVydGljZXM9ZmFsc2VdIHdoZXRoZXIgdG8gaWdub3JlIHRoZSBzdGFydCBhbmQgZW5kIHZlcnRpY2VzLlxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB0dXJmLnBvaW50KFswLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbWy0xLCAtMV0sWzEsIDFdLFsxLjUsIDIuMl1dKTtcbiAqIHZhciBpc1BvaW50T25MaW5lID0gdHVyZi5ib29sZWFuUG9pbnRPbkxpbmUocHQsIGxpbmUpO1xuICogLy89dHJ1ZVxuICovXG5mdW5jdGlvbiBib29sZWFuUG9pbnRPbkxpbmUocHQsIGxpbmUsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIE5vcm1hbGl6ZSBpbnB1dHNcbiAgICB2YXIgcHRDb29yZHMgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChwdCk7XG4gICAgdmFyIGxpbmVDb29yZHMgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobGluZSk7XG4gICAgLy8gTWFpblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGluZUNvb3Jkcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIGlnbm9yZUJvdW5kYXJ5ID0gZmFsc2U7XG4gICAgICAgIGlmIChvcHRpb25zLmlnbm9yZUVuZFZlcnRpY2VzKSB7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGlnbm9yZUJvdW5kYXJ5ID0gXCJzdGFydFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGkgPT09IGxpbmVDb29yZHMubGVuZ3RoIC0gMikge1xuICAgICAgICAgICAgICAgIGlnbm9yZUJvdW5kYXJ5ID0gXCJlbmRcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpID09PSAwICYmIGkgKyAxID09PSBsaW5lQ29vcmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgICAgICBpZ25vcmVCb3VuZGFyeSA9IFwiYm90aFwiO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpc1BvaW50T25MaW5lU2VnbWVudChsaW5lQ29vcmRzW2ldLCBsaW5lQ29vcmRzW2kgKyAxXSwgcHRDb29yZHMsIGlnbm9yZUJvdW5kYXJ5KSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuLy8gU2VlIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzQ4MzM4MjMvMTk3OTA4NVxuLyoqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtQb3NpdGlvbn0gbGluZVNlZ21lbnRTdGFydCBjb29yZCBwYWlyIG9mIHN0YXJ0IG9mIGxpbmVcbiAqIEBwYXJhbSB7UG9zaXRpb259IGxpbmVTZWdtZW50RW5kIGNvb3JkIHBhaXIgb2YgZW5kIG9mIGxpbmVcbiAqIEBwYXJhbSB7UG9zaXRpb259IHB0IGNvb3JkIHBhaXIgb2YgcG9pbnQgdG8gY2hlY2tcbiAqIEBwYXJhbSB7Ym9vbGVhbnxzdHJpbmd9IGV4Y2x1ZGVCb3VuZGFyeSB3aGV0aGVyIHRoZSBwb2ludCBpcyBhbGxvd2VkIHRvIGZhbGwgb24gdGhlIGxpbmUgZW5kcy5cbiAqIElmIHRydWUgd2hpY2ggZW5kIHRvIGlnbm9yZS5cbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzUG9pbnRPbkxpbmVTZWdtZW50KGxpbmVTZWdtZW50U3RhcnQsIGxpbmVTZWdtZW50RW5kLCBwdCwgZXhjbHVkZUJvdW5kYXJ5KSB7XG4gICAgdmFyIHggPSBwdFswXTtcbiAgICB2YXIgeSA9IHB0WzFdO1xuICAgIHZhciB4MSA9IGxpbmVTZWdtZW50U3RhcnRbMF07XG4gICAgdmFyIHkxID0gbGluZVNlZ21lbnRTdGFydFsxXTtcbiAgICB2YXIgeDIgPSBsaW5lU2VnbWVudEVuZFswXTtcbiAgICB2YXIgeTIgPSBsaW5lU2VnbWVudEVuZFsxXTtcbiAgICB2YXIgZHhjID0gcHRbMF0gLSB4MTtcbiAgICB2YXIgZHljID0gcHRbMV0gLSB5MTtcbiAgICB2YXIgZHhsID0geDIgLSB4MTtcbiAgICB2YXIgZHlsID0geTIgLSB5MTtcbiAgICB2YXIgY3Jvc3MgPSBkeGMgKiBkeWwgLSBkeWMgKiBkeGw7XG4gICAgaWYgKGNyb3NzICE9PSAwKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFleGNsdWRlQm91bmRhcnkpIHtcbiAgICAgICAgaWYgKE1hdGguYWJzKGR4bCkgPj0gTWF0aC5hYnMoZHlsKSkge1xuICAgICAgICAgICAgcmV0dXJuIGR4bCA+IDAgPyB4MSA8PSB4ICYmIHggPD0geDIgOiB4MiA8PSB4ICYmIHggPD0geDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8PSB5ICYmIHkgPD0geTIgOiB5MiA8PSB5ICYmIHkgPD0geTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4Y2x1ZGVCb3VuZGFyeSA9PT0gXCJzdGFydFwiKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeGwpID49IE1hdGguYWJzKGR5bCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkeGwgPiAwID8geDEgPCB4ICYmIHggPD0geDIgOiB4MiA8PSB4ICYmIHggPCB4MTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZHlsID4gMCA/IHkxIDwgeSAmJiB5IDw9IHkyIDogeTIgPD0geSAmJiB5IDwgeTE7XG4gICAgfVxuICAgIGVsc2UgaWYgKGV4Y2x1ZGVCb3VuZGFyeSA9PT0gXCJlbmRcIikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoZHhsKSA+PSBNYXRoLmFicyhkeWwpKSB7XG4gICAgICAgICAgICByZXR1cm4gZHhsID4gMCA/IHgxIDw9IHggJiYgeCA8IHgyIDogeDIgPCB4ICYmIHggPD0geDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8PSB5ICYmIHkgPCB5MiA6IHkyIDwgeSAmJiB5IDw9IHkxO1xuICAgIH1cbiAgICBlbHNlIGlmIChleGNsdWRlQm91bmRhcnkgPT09IFwiYm90aFwiKSB7XG4gICAgICAgIGlmIChNYXRoLmFicyhkeGwpID49IE1hdGguYWJzKGR5bCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkeGwgPiAwID8geDEgPCB4ICYmIHggPCB4MiA6IHgyIDwgeCAmJiB4IDwgeDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGR5bCA+IDAgPyB5MSA8IHkgJiYgeSA8IHkyIDogeTIgPCB5ICYmIHkgPCB5MTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gYm9vbGVhblBvaW50T25MaW5lO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vLyBodHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxudmFyIGhlbHBlcnNfMSA9IHJlcXVpcmUoXCJAdHVyZi9oZWxwZXJzXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBjYWxjdWxhdGVzIHRoZSBsb2NhdGlvbiBvZiBhIGRlc3RpbmF0aW9uIHBvaW50IGdpdmVuIGEgZGlzdGFuY2UgaW5cbiAqIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzOyBhbmQgYmVhcmluZyBpbiBkZWdyZWVzLlxuICogVGhpcyB1c2VzIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpIHRvIGFjY291bnQgZm9yIGdsb2JhbCBjdXJ2YXR1cmUuXG4gKlxuICogQG5hbWUgZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7Q29vcmR9IG9yaWdpbiBzdGFydGluZyBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGRpc3RhbmNlIGZyb20gdGhlIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgcmFuZ2luZyBmcm9tIC0xODAgdG8gMTgwXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy51bml0cz0na2lsb21ldGVycyddIG1pbGVzLCBraWxvbWV0ZXJzLCBkZWdyZWVzLCBvciByYWRpYW5zXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIHByb3BlcnRpZXMgdG8gUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gZGVzdGluYXRpb24gcG9pbnRcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnQgPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciBkaXN0YW5jZSA9IDUwO1xuICogdmFyIGJlYXJpbmcgPSA5MDtcbiAqIHZhciBvcHRpb25zID0ge3VuaXRzOiAnbWlsZXMnfTtcbiAqXG4gKiB2YXIgZGVzdGluYXRpb24gPSB0dXJmLmRlc3RpbmF0aW9uKHBvaW50LCBkaXN0YW5jZSwgYmVhcmluZywgb3B0aW9ucyk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW3BvaW50LCBkZXN0aW5hdGlvbl1cbiAqIGRlc3RpbmF0aW9uLnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyNmMDAnO1xuICogcG9pbnQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnIzBmMCc7XG4gKi9cbmZ1bmN0aW9uIGRlc3RpbmF0aW9uKG9yaWdpbiwgZGlzdGFuY2UsIGJlYXJpbmcsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIC8vIEhhbmRsZSBpbnB1dFxuICAgIHZhciBjb29yZGluYXRlczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChvcmlnaW4pO1xuICAgIHZhciBsb25naXR1ZGUxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzBdKTtcbiAgICB2YXIgbGF0aXR1ZGUxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgYmVhcmluZ1JhZCA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGJlYXJpbmcpO1xuICAgIHZhciByYWRpYW5zID0gaGVscGVyc18xLmxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgb3B0aW9ucy51bml0cyk7XG4gICAgLy8gTWFpblxuICAgIHZhciBsYXRpdHVkZTIgPSBNYXRoLmFzaW4oTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguY29zKHJhZGlhbnMpICtcbiAgICAgICAgTWF0aC5jb3MobGF0aXR1ZGUxKSAqIE1hdGguc2luKHJhZGlhbnMpICogTWF0aC5jb3MoYmVhcmluZ1JhZCkpO1xuICAgIHZhciBsb25naXR1ZGUyID0gbG9uZ2l0dWRlMSArIE1hdGguYXRhbjIoTWF0aC5zaW4oYmVhcmluZ1JhZCkgKiBNYXRoLnNpbihyYWRpYW5zKSAqIE1hdGguY29zKGxhdGl0dWRlMSksIE1hdGguY29zKHJhZGlhbnMpIC0gTWF0aC5zaW4obGF0aXR1ZGUxKSAqIE1hdGguc2luKGxhdGl0dWRlMikpO1xuICAgIHZhciBsbmcgPSBoZWxwZXJzXzEucmFkaWFuc1RvRGVncmVlcyhsb25naXR1ZGUyKTtcbiAgICB2YXIgbGF0ID0gaGVscGVyc18xLnJhZGlhbnNUb0RlZ3JlZXMobGF0aXR1ZGUyKTtcbiAgICByZXR1cm4gaGVscGVyc18xLnBvaW50KFtsbmcsIGxhdF0sIG9wdGlvbnMucHJvcGVydGllcyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkZXN0aW5hdGlvbjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbi8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuLy9odHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxuLyoqXG4gKiBDYWxjdWxhdGVzIHRoZSBkaXN0YW5jZSBiZXR3ZWVuIHR3byB7QGxpbmsgUG9pbnR8cG9pbnRzfSBpbiBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVycy5cbiAqIFRoaXMgdXNlcyB0aGUgW0hhdmVyc2luZSBmb3JtdWxhXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhKSB0byBhY2NvdW50IGZvciBnbG9iYWwgY3VydmF0dXJlLlxuICpcbiAqIEBuYW1lIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0Nvb3JkfSBmcm9tIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtDb29yZH0gdG8gZGVzdGluYXRpb24gcG9pbnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLnVuaXRzPSdraWxvbWV0ZXJzJ10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSB0d28gcG9pbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZyb20gPSB0dXJmLnBvaW50KFstNzUuMzQzLCAzOS45ODRdKTtcbiAqIHZhciB0byA9IHR1cmYucG9pbnQoWy03NS41MzQsIDM5LjEyM10pO1xuICogdmFyIG9wdGlvbnMgPSB7dW5pdHM6ICdtaWxlcyd9O1xuICpcbiAqIHZhciBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICpcbiAqIC8vYWRkVG9NYXBcbiAqIHZhciBhZGRUb01hcCA9IFtmcm9tLCB0b107XG4gKiBmcm9tLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqIHRvLnByb3BlcnRpZXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAqL1xuZnVuY3Rpb24gZGlzdGFuY2UoZnJvbSwgdG8sIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjb29yZGluYXRlczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZChmcm9tKTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmQodG8pO1xuICAgIHZhciBkTGF0ID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoKGNvb3JkaW5hdGVzMlsxXSAtIGNvb3JkaW5hdGVzMVsxXSkpO1xuICAgIHZhciBkTG9uID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoKGNvb3JkaW5hdGVzMlswXSAtIGNvb3JkaW5hdGVzMVswXSkpO1xuICAgIHZhciBsYXQxID0gaGVscGVyc18xLmRlZ3JlZXNUb1JhZGlhbnMoY29vcmRpbmF0ZXMxWzFdKTtcbiAgICB2YXIgbGF0MiA9IGhlbHBlcnNfMS5kZWdyZWVzVG9SYWRpYW5zKGNvb3JkaW5hdGVzMlsxXSk7XG4gICAgdmFyIGEgPSBNYXRoLnBvdyhNYXRoLnNpbihkTGF0IC8gMiksIDIpICtcbiAgICAgICAgTWF0aC5wb3coTWF0aC5zaW4oZExvbiAvIDIpLCAyKSAqIE1hdGguY29zKGxhdDEpICogTWF0aC5jb3MobGF0Mik7XG4gICAgcmV0dXJuIGhlbHBlcnNfMS5yYWRpYW5zVG9MZW5ndGgoMiAqIE1hdGguYXRhbjIoTWF0aC5zcXJ0KGEpLCBNYXRoLnNxcnQoMSAtIGEpKSwgb3B0aW9ucy51bml0cyk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSBkaXN0YW5jZTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBAbW9kdWxlIGhlbHBlcnNcbiAqL1xuLyoqXG4gKiBFYXJ0aCBSYWRpdXMgdXNlZCB3aXRoIHRoZSBIYXJ2ZXNpbmUgZm9ybXVsYSBhbmQgYXBwcm94aW1hdGVzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBFYXJ0aC5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge251bWJlcn1cbiAqL1xuZXhwb3J0cy5lYXJ0aFJhZGl1cyA9IDYzNzEwMDguODtcbi8qKlxuICogVW5pdCBvZiBtZWFzdXJlbWVudCBmYWN0b3JzIHVzaW5nIGEgc3BoZXJpY2FsIChub24tZWxsaXBzb2lkKSBlYXJ0aCByYWRpdXMuXG4gKlxuICogQG1lbWJlcm9mIGhlbHBlcnNcbiAqIEB0eXBlIHtPYmplY3R9XG4gKi9cbmV4cG9ydHMuZmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDEwMCxcbiAgICBjZW50aW1ldHJlczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDEwMCxcbiAgICBkZWdyZWVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTExMzI1LFxuICAgIGZlZXQ6IGV4cG9ydHMuZWFydGhSYWRpdXMgKiAzLjI4MDg0LFxuICAgIGluY2hlczogZXhwb3J0cy5lYXJ0aFJhZGl1cyAqIDM5LjM3MCxcbiAgICBraWxvbWV0ZXJzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgICBraWxvbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTAwMCxcbiAgICBtZXRlcnM6IGV4cG9ydHMuZWFydGhSYWRpdXMsXG4gICAgbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzLFxuICAgIG1pbGVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTYwOS4zNDQsXG4gICAgbWlsbGltZXRlcnM6IGV4cG9ydHMuZWFydGhSYWRpdXMgKiAxMDAwLFxuICAgIG1pbGxpbWV0cmVzOiBleHBvcnRzLmVhcnRoUmFkaXVzICogMTAwMCxcbiAgICBuYXV0aWNhbG1pbGVzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMTg1MixcbiAgICByYWRpYW5zOiAxLFxuICAgIHlhcmRzOiBleHBvcnRzLmVhcnRoUmFkaXVzIC8gMS4wOTM2LFxufTtcbi8qKlxuICogVW5pdHMgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIG1ldGVyLlxuICpcbiAqIEBtZW1iZXJvZiBoZWxwZXJzXG4gKiBAdHlwZSB7T2JqZWN0fVxuICovXG5leHBvcnRzLnVuaXRzRmFjdG9ycyA9IHtcbiAgICBjZW50aW1ldGVyczogMTAwLFxuICAgIGNlbnRpbWV0cmVzOiAxMDAsXG4gICAgZGVncmVlczogMSAvIDExMTMyNSxcbiAgICBmZWV0OiAzLjI4MDg0LFxuICAgIGluY2hlczogMzkuMzcwLFxuICAgIGtpbG9tZXRlcnM6IDEgLyAxMDAwLFxuICAgIGtpbG9tZXRyZXM6IDEgLyAxMDAwLFxuICAgIG1ldGVyczogMSxcbiAgICBtZXRyZXM6IDEsXG4gICAgbWlsZXM6IDEgLyAxNjA5LjM0NCxcbiAgICBtaWxsaW1ldGVyczogMTAwMCxcbiAgICBtaWxsaW1ldHJlczogMTAwMCxcbiAgICBuYXV0aWNhbG1pbGVzOiAxIC8gMTg1MixcbiAgICByYWRpYW5zOiAxIC8gZXhwb3J0cy5lYXJ0aFJhZGl1cyxcbiAgICB5YXJkczogMSAvIDEuMDkzNixcbn07XG4vKipcbiAqIEFyZWEgb2YgbWVhc3VyZW1lbnQgZmFjdG9ycyBiYXNlZCBvbiAxIHNxdWFyZSBtZXRlci5cbiAqXG4gKiBAbWVtYmVyb2YgaGVscGVyc1xuICogQHR5cGUge09iamVjdH1cbiAqL1xuZXhwb3J0cy5hcmVhRmFjdG9ycyA9IHtcbiAgICBhY3JlczogMC4wMDAyNDcxMDUsXG4gICAgY2VudGltZXRlcnM6IDEwMDAwLFxuICAgIGNlbnRpbWV0cmVzOiAxMDAwMCxcbiAgICBmZWV0OiAxMC43NjM5MTA0MTcsXG4gICAgaW5jaGVzOiAxNTUwLjAwMzEwMDAwNixcbiAgICBraWxvbWV0ZXJzOiAwLjAwMDAwMSxcbiAgICBraWxvbWV0cmVzOiAwLjAwMDAwMSxcbiAgICBtZXRlcnM6IDEsXG4gICAgbWV0cmVzOiAxLFxuICAgIG1pbGVzOiAzLjg2ZS03LFxuICAgIG1pbGxpbWV0ZXJzOiAxMDAwMDAwLFxuICAgIG1pbGxpbWV0cmVzOiAxMDAwMDAwLFxuICAgIHlhcmRzOiAxLjE5NTk5MDA0Nixcbn07XG4vKipcbiAqIFdyYXBzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGluIGEgR2VvSlNPTiB7QGxpbmsgRmVhdHVyZX0uXG4gKlxuICogQG5hbWUgZmVhdHVyZVxuICogQHBhcmFtIHtHZW9tZXRyeX0gZ2VvbWV0cnkgaW5wdXQgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZX0gYSBHZW9KU09OIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvbWV0cnkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNTBdXG4gKiB9O1xuICpcbiAqIHZhciBmZWF0dXJlID0gdHVyZi5mZWF0dXJlKGdlb21ldHJ5KTtcbiAqXG4gKiAvLz1mZWF0dXJlXG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGZlYXQgPSB7IHR5cGU6IFwiRmVhdHVyZVwiIH07XG4gICAgaWYgKG9wdGlvbnMuaWQgPT09IDAgfHwgb3B0aW9ucy5pZCkge1xuICAgICAgICBmZWF0LmlkID0gb3B0aW9ucy5pZDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMuYmJveCkge1xuICAgICAgICBmZWF0LmJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgfVxuICAgIGZlYXQucHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwge307XG4gICAgZmVhdC5nZW9tZXRyeSA9IGdlb207XG4gICAgcmV0dXJuIGZlYXQ7XG59XG5leHBvcnRzLmZlYXR1cmUgPSBmZWF0dXJlO1xuLyoqXG4gKiBDcmVhdGVzIGEgR2VvSlNPTiB7QGxpbmsgR2VvbWV0cnl9IGZyb20gYSBHZW9tZXRyeSBzdHJpbmcgdHlwZSAmIGNvb3JkaW5hdGVzLlxuICogRm9yIEdlb21ldHJ5Q29sbGVjdGlvbiB0eXBlIHVzZSBgaGVscGVycy5nZW9tZXRyeUNvbGxlY3Rpb25gXG4gKlxuICogQG5hbWUgZ2VvbWV0cnlcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIEdlb21ldHJ5IFR5cGVcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgQ29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHJldHVybnMge0dlb21ldHJ5fSBhIEdlb0pTT04gR2VvbWV0cnlcbiAqIEBleGFtcGxlXG4gKiB2YXIgdHlwZSA9IFwiUG9pbnRcIjtcbiAqIHZhciBjb29yZGluYXRlcyA9IFsxMTAsIDUwXTtcbiAqIHZhciBnZW9tZXRyeSA9IHR1cmYuZ2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMpO1xuICogLy8gPT4gZ2VvbWV0cnlcbiAqL1xuZnVuY3Rpb24gZ2VvbWV0cnkodHlwZSwgY29vcmRpbmF0ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiUG9pbnRcIjogcmV0dXJuIHBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIkxpbmVTdHJpbmdcIjogcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRpbmF0ZXMpLmdlb21ldHJ5O1xuICAgICAgICBjYXNlIFwiUG9seWdvblwiOiByZXR1cm4gcG9seWdvbihjb29yZGluYXRlcykuZ2VvbWV0cnk7XG4gICAgICAgIGNhc2UgXCJNdWx0aVBvaW50XCI6IHJldHVybiBtdWx0aVBvaW50KGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpTGluZVN0cmluZ1wiOiByZXR1cm4gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgY2FzZSBcIk11bHRpUG9seWdvblwiOiByZXR1cm4gbXVsdGlQb2x5Z29uKGNvb3JkaW5hdGVzKS5nZW9tZXRyeTtcbiAgICAgICAgZGVmYXVsdDogdGhyb3cgbmV3IEVycm9yKHR5cGUgKyBcIiBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbn1cbmV4cG9ydHMuZ2VvbWV0cnkgPSBnZW9tZXRyeTtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmV9IGZyb20gYSBQb3NpdGlvbi5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZGluYXRlcyBsb25naXR1ZGUsIGxhdGl0dWRlIHBvc2l0aW9uIChlYWNoIGluIGRlY2ltYWwgZGVncmVlcylcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcHJvcGVydGllcz17fV0gYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGEgUG9pbnQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXBvaW50XG4gKi9cbmZ1bmN0aW9uIHBvaW50KGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9pbnQgPSBwb2ludDtcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBQb2ludH0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvaW50IGNvb3JkaW5hdGVzLlxuICpcbiAqIEBuYW1lIHBvaW50c1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9pbnRzXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSB0aGVzZSBwcm9wZXJ0aWVzIHRvIGVhY2ggRmVhdHVyZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXVxuICogYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlQ29sbGVjdGlvblxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBQb2ludCBGZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucG9pbnRzKFtcbiAqICAgWy03NSwgMzldLFxuICogICBbLTgwLCA0NV0sXG4gKiAgIFstNzgsIDUwXVxuICogXSk7XG4gKlxuICogLy89cG9pbnRzXG4gKi9cbmZ1bmN0aW9uIHBvaW50cyhjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmRzKSB7XG4gICAgICAgIHJldHVybiBwb2ludChjb29yZHMsIHByb3BlcnRpZXMpO1xuICAgIH0pLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9pbnRzID0gcG9pbnRzO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIFBvbHlnb259IHtAbGluayBGZWF0dXJlfSBmcm9tIGFuIEFycmF5IG9mIExpbmVhclJpbmdzLlxuICpcbiAqIEBuYW1lIHBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBQb2x5Z29uIEZlYXR1cmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1stNSwgNTJdLCBbLTQsIDU2XSwgWy0yLCA1MV0sIFstNywgNTRdLCBbLTUsIDUyXV1dLCB7IG5hbWU6ICdwb2x5MScgfSk7XG4gKlxuICogLy89cG9seWdvblxuICovXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBmb3IgKHZhciBfaSA9IDAsIGNvb3JkaW5hdGVzXzEgPSBjb29yZGluYXRlczsgX2kgPCBjb29yZGluYXRlc18xLmxlbmd0aDsgX2krKykge1xuICAgICAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzXzFbX2ldO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJFYWNoIExpbmVhclJpbmcgb2YgYSBQb2x5Z29uIG11c3QgaGF2ZSA0IG9yIG1vcmUgUG9zaXRpb25zLlwiKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHJpbmdbcmluZy5sZW5ndGggLSAxXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgLy8gQ2hlY2sgaWYgZmlyc3QgcG9pbnQgb2YgUG9seWdvbiBjb250YWlucyB0d28gbnVtYmVyc1xuICAgICAgICAgICAgaWYgKHJpbmdbcmluZy5sZW5ndGggLSAxXVtqXSAhPT0gcmluZ1swXVtqXSkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9seWdvbiA9IHBvbHlnb247XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgUG9seWdvbn0ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIFBvbHlnb24gY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgcG9seWdvbnNcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9seWdvbiBjb29yZGluYXRlc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFBvbHlnb24gRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLnBvbHlnb25zKFtcbiAqICAgW1tbLTUsIDUyXSwgWy00LCA1Nl0sIFstMiwgNTFdLCBbLTcsIDU0XSwgWy01LCA1Ml1dXSxcbiAqICAgW1tbLTE1LCA0Ml0sIFstMTQsIDQ2XSwgWy0xMiwgNDFdLCBbLTE3LCA0NF0sIFstMTUsIDQyXV1dLFxuICogXSk7XG4gKlxuICogLy89cG9seWdvbnNcbiAqL1xuZnVuY3Rpb24gcG9seWdvbnMoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gcG9seWdvbihjb29yZHMsIHByb3BlcnRpZXMpO1xuICAgIH0pLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMucG9seWdvbnMgPSBwb2x5Z29ucztcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSB7QGxpbmsgRmVhdHVyZX0gZnJvbSBhbiBBcnJheSBvZiBQb3NpdGlvbnMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ1xuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdH0gW3Byb3BlcnRpZXM9e31dIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBbb3B0aW9ucy5iYm94XSBCb3VuZGluZyBCb3ggQXJyYXkgW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF0gYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IExpbmVTdHJpbmcgRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5nMSA9IHR1cmYubGluZVN0cmluZyhbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSwge25hbWU6ICdsaW5lIDEnfSk7XG4gKiB2YXIgbGluZXN0cmluZzIgPSB0dXJmLmxpbmVTdHJpbmcoW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV0sIHtuYW1lOiAnbGluZSAyJ30pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmcxXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5mdW5jdGlvbiBsaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IGJlIGFuIGFycmF5IG9mIHR3byBvciBtb3JlIHBvc2l0aW9uc1wiKTtcbiAgICB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiTGluZVN0cmluZ1wiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubGluZVN0cmluZyA9IGxpbmVTdHJpbmc7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgTGluZVN0cmluZ30ge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBmcm9tIGFuIEFycmF5IG9mIExpbmVTdHJpbmcgY29vcmRpbmF0ZXMuXG4gKlxuICogQG5hbWUgbGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdXG4gKiBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVDb2xsZWN0aW9uXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IFtvcHRpb25zLmlkXSBJZGVudGlmaWVyIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZUNvbGxlY3Rpb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gTGluZVN0cmluZyBGZWF0dXJlQ29sbGVjdGlvblxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lc3RyaW5ncyA9IHR1cmYubGluZVN0cmluZ3MoW1xuICogICBbWy0yNCwgNjNdLCBbLTIzLCA2MF0sIFstMjUsIDY1XSwgWy0yMCwgNjldXSxcbiAqICAgW1stMTQsIDQzXSwgWy0xMywgNDBdLCBbLTE1LCA0NV0sIFstMTAsIDQ5XV1cbiAqIF0pO1xuICpcbiAqIC8vPWxpbmVzdHJpbmdzXG4gKi9cbmZ1bmN0aW9uIGxpbmVTdHJpbmdzKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICByZXR1cm4gZmVhdHVyZUNvbGxlY3Rpb24oY29vcmRpbmF0ZXMubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgcmV0dXJuIGxpbmVTdHJpbmcoY29vcmRzLCBwcm9wZXJ0aWVzKTtcbiAgICB9KSwgb3B0aW9ucyk7XG59XG5leHBvcnRzLmxpbmVTdHJpbmdzID0gbGluZVN0cmluZ3M7XG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIHtAbGluayBGZWF0dXJlfEZlYXR1cmVzfSBhbmQgY3JlYXRlcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0uXG4gKlxuICogQG5hbWUgZmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RmVhdHVyZVtdfSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IFtvcHRpb25zLmJib3hdIEJvdW5kaW5nIEJveCBBcnJheSBbd2VzdCwgc291dGgsIGVhc3QsIG5vcnRoXSBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEBwYXJhbSB7c3RyaW5nfG51bWJlcn0gW29wdGlvbnMuaWRdIElkZW50aWZpZXIgYXNzb2NpYXRlZCB3aXRoIHRoZSBGZWF0dXJlXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IEZlYXR1cmVDb2xsZWN0aW9uIG9mIEZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxvY2F0aW9uQSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0sIHtuYW1lOiAnTG9jYXRpb24gQSd9KTtcbiAqIHZhciBsb2NhdGlvbkIgPSB0dXJmLnBvaW50KFstNzUuODMzLCAzOS4yODRdLCB7bmFtZTogJ0xvY2F0aW9uIEInfSk7XG4gKiB2YXIgbG9jYXRpb25DID0gdHVyZi5wb2ludChbLTc1LjUzNCwgMzkuMTIzXSwge25hbWU6ICdMb2NhdGlvbiBDJ30pO1xuICpcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIGxvY2F0aW9uQSxcbiAqICAgbG9jYXRpb25CLFxuICogICBsb2NhdGlvbkNcbiAqIF0pO1xuICpcbiAqIC8vPWNvbGxlY3Rpb25cbiAqL1xuZnVuY3Rpb24gZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBmYyA9IHsgdHlwZTogXCJGZWF0dXJlQ29sbGVjdGlvblwiIH07XG4gICAgaWYgKG9wdGlvbnMuaWQpIHtcbiAgICAgICAgZmMuaWQgPSBvcHRpb25zLmlkO1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5iYm94KSB7XG4gICAgICAgIGZjLmJib3ggPSBvcHRpb25zLmJib3g7XG4gICAgfVxuICAgIGZjLmZlYXR1cmVzID0gZmVhdHVyZXM7XG4gICAgcmV0dXJuIGZjO1xufVxuZXhwb3J0cy5mZWF0dXJlQ29sbGVjdGlvbiA9IGZlYXR1cmVDb2xsZWN0aW9uO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBtdWx0aUxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lU3RyaW5nc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGEgTXVsdGlMaW5lU3RyaW5nIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtbWzAsMF0sWzEwLDEwXV1dKTtcbiAqXG4gKiAvLz1tdWx0aUxpbmVcbiAqL1xuZnVuY3Rpb24gbXVsdGlMaW5lU3RyaW5nKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzLCBvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgPT09IHZvaWQgMCkgeyBvcHRpb25zID0ge307IH1cbiAgICB2YXIgZ2VvbSA9IHtcbiAgICAgICAgdHlwZTogXCJNdWx0aUxpbmVTdHJpbmdcIixcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzLFxuICAgIH07XG4gICAgcmV0dXJuIGZlYXR1cmUoZ2VvbSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG59XG5leHBvcnRzLm11bHRpTGluZVN0cmluZyA9IG11bHRpTGluZVN0cmluZztcbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpUG9pbnQ+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9pbnRcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9pbnQ+fSBhIE11bHRpUG9pbnQgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbXVsdGlQdCA9IHR1cmYubXVsdGlQb2ludChbWzAsMF0sWzEwLDEwXV0pO1xuICpcbiAqIC8vPW11bHRpUHRcbiAqL1xuZnVuY3Rpb24gbXVsdGlQb2ludChjb29yZGluYXRlcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiTXVsdGlQb2ludFwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubXVsdGlQb2ludCA9IG11bHRpUG9pbnQ7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvbHlnb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9seWdvbj59IGEgbXVsdGlwb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtbW1swLDBdLFswLDEwXSxbMTAsMTBdLFsxMCwwXSxbMCwwXV1dXSk7XG4gKlxuICogLy89bXVsdGlQb2x5XG4gKlxuICovXG5mdW5jdGlvbiBtdWx0aVBvbHlnb24oY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBnZW9tID0ge1xuICAgICAgICB0eXBlOiBcIk11bHRpUG9seWdvblwiLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMubXVsdGlQb2x5Z29uID0gbXVsdGlQb2x5Z29uO1xuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8R2VvbWV0cnlDb2xsZWN0aW9uPn0gYmFzZWQgb24gYVxuICogY29vcmRpbmF0ZSBhcnJheS4gUHJvcGVydGllcyBjYW4gYmUgYWRkZWQgb3B0aW9uYWxseS5cbiAqXG4gKiBAbmFtZSBnZW9tZXRyeUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7QXJyYXk8R2VvbWV0cnk+fSBnZW9tZXRyaWVzIGFuIGFycmF5IG9mIEdlb0pTT04gR2VvbWV0cmllc1xuICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzPXt9XSBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIFBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gW29wdGlvbnMuYmJveF0gQm91bmRpbmcgQm94IEFycmF5IFt3ZXN0LCBzb3V0aCwgZWFzdCwgbm9ydGhdIGFzc29jaWF0ZWQgd2l0aCB0aGUgRmVhdHVyZVxuICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSBbb3B0aW9ucy5pZF0gSWRlbnRpZmllciBhc3NvY2lhdGVkIHdpdGggdGhlIEZlYXR1cmVcbiAqIEByZXR1cm5zIHtGZWF0dXJlPEdlb21ldHJ5Q29sbGVjdGlvbj59IGEgR2VvSlNPTiBHZW9tZXRyeUNvbGxlY3Rpb24gRmVhdHVyZVxuICogQGV4YW1wbGVcbiAqIHZhciBwdCA9IHR1cmYuZ2VvbWV0cnkoXCJQb2ludFwiLCBbMTAwLCAwXSk7XG4gKiB2YXIgbGluZSA9IHR1cmYuZ2VvbWV0cnkoXCJMaW5lU3RyaW5nXCIsIFtbMTAxLCAwXSwgWzEwMiwgMV1dKTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeUNvbGxlY3Rpb24oW3B0LCBsaW5lXSk7XG4gKlxuICogLy8gPT4gY29sbGVjdGlvblxuICovXG5mdW5jdGlvbiBnZW9tZXRyeUNvbGxlY3Rpb24oZ2VvbWV0cmllcywgcHJvcGVydGllcywgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgdmFyIGdlb20gPSB7XG4gICAgICAgIHR5cGU6IFwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsXG4gICAgICAgIGdlb21ldHJpZXM6IGdlb21ldHJpZXMsXG4gICAgfTtcbiAgICByZXR1cm4gZmVhdHVyZShnZW9tLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbn1cbmV4cG9ydHMuZ2VvbWV0cnlDb2xsZWN0aW9uID0gZ2VvbWV0cnlDb2xsZWN0aW9uO1xuLyoqXG4gKiBSb3VuZCBudW1iZXIgdG8gcHJlY2lzaW9uXG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IG51bSBOdW1iZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbcHJlY2lzaW9uPTBdIFByZWNpc2lvblxuICogQHJldHVybnMge251bWJlcn0gcm91bmRlZCBudW1iZXJcbiAqIEBleGFtcGxlXG4gKiB0dXJmLnJvdW5kKDEyMC40MzIxKVxuICogLy89MTIwXG4gKlxuICogdHVyZi5yb3VuZCgxMjAuNDMyMSwgMilcbiAqIC8vPTEyMC40M1xuICovXG5mdW5jdGlvbiByb3VuZChudW0sIHByZWNpc2lvbikge1xuICAgIGlmIChwcmVjaXNpb24gPT09IHZvaWQgMCkgeyBwcmVjaXNpb24gPSAwOyB9XG4gICAgaWYgKHByZWNpc2lvbiAmJiAhKHByZWNpc2lvbiA+PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJwcmVjaXNpb24gbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgdmFyIG11bHRpcGxpZXIgPSBNYXRoLnBvdygxMCwgcHJlY2lzaW9uIHx8IDApO1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG51bSAqIG11bHRpcGxpZXIpIC8gbXVsdGlwbGllcjtcbn1cbmV4cG9ydHMucm91bmQgPSByb3VuZDtcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSByYWRpYW5zIHRvIGEgbW9yZSBmcmllbmRseSB1bml0LlxuICogVmFsaWQgdW5pdHM6IG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBpbmNoZXMsIHlhcmRzLCBtZXRlcnMsIG1ldHJlcywga2lsb21ldGVycywgY2VudGltZXRlcnMsIGZlZXRcbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9MZW5ndGhcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nfSBbdW5pdHM9XCJraWxvbWV0ZXJzXCJdIGNhbiBiZSBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVycyBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsXG4gKiBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBkaXN0YW5jZVxuICovXG5mdW5jdGlvbiByYWRpYW5zVG9MZW5ndGgocmFkaWFucywgdW5pdHMpIHtcbiAgICBpZiAodW5pdHMgPT09IHZvaWQgMCkgeyB1bml0cyA9IFwia2lsb21ldGVyc1wiOyB9XG4gICAgdmFyIGZhY3RvciA9IGV4cG9ydHMuZmFjdG9yc1t1bml0c107XG4gICAgaWYgKCFmYWN0b3IpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKHVuaXRzICsgXCIgdW5pdHMgaXMgaW52YWxpZFwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59XG5leHBvcnRzLnJhZGlhbnNUb0xlbmd0aCA9IHJhZGlhbnNUb0xlbmd0aDtcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIHJhZGlhbnNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9SYWRpYW5zXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoVG9SYWRpYW5zKGRpc3RhbmNlLCB1bml0cykge1xuICAgIGlmICh1bml0cyA9PT0gdm9pZCAwKSB7IHVuaXRzID0gXCJraWxvbWV0ZXJzXCI7IH1cbiAgICB2YXIgZmFjdG9yID0gZXhwb3J0cy5mYWN0b3JzW3VuaXRzXTtcbiAgICBpZiAoIWZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IodW5pdHMgKyBcIiB1bml0cyBpcyBpbnZhbGlkXCIpO1xuICAgIH1cbiAgICByZXR1cm4gZGlzdGFuY2UgLyBmYWN0b3I7XG59XG5leHBvcnRzLmxlbmd0aFRvUmFkaWFucyA9IGxlbmd0aFRvUmFkaWFucztcbi8qKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IChhc3N1bWluZyBhIHNwaGVyaWNhbCBFYXJ0aCkgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGNlbnRpbWV0ZXJzLCBraWxvbWV0cmVzLCBmZWV0XG4gKlxuICogQG5hbWUgbGVuZ3RoVG9EZWdyZWVzXG4gKiBAcGFyYW0ge251bWJlcn0gZGlzdGFuY2UgaW4gcmVhbCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IFt1bml0cz1cImtpbG9tZXRlcnNcIl0gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzIGluY2hlcywgeWFyZHMsIG1ldHJlcyxcbiAqIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXNcbiAqL1xuZnVuY3Rpb24gbGVuZ3RoVG9EZWdyZWVzKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHJldHVybiByYWRpYW5zVG9EZWdyZWVzKGxlbmd0aFRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpKTtcbn1cbmV4cG9ydHMubGVuZ3RoVG9EZWdyZWVzID0gbGVuZ3RoVG9EZWdyZWVzO1xuLyoqXG4gKiBDb252ZXJ0cyBhbnkgYmVhcmluZyBhbmdsZSBmcm9tIHRoZSBub3J0aCBsaW5lIGRpcmVjdGlvbiAocG9zaXRpdmUgY2xvY2t3aXNlKVxuICogYW5kIHJldHVybnMgYW4gYW5nbGUgYmV0d2VlbiAwLTM2MCBkZWdyZWVzIChwb3NpdGl2ZSBjbG9ja3dpc2UpLCAwIGJlaW5nIHRoZSBub3J0aCBsaW5lXG4gKlxuICogQG5hbWUgYmVhcmluZ1RvQXppbXV0aFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgYW5nbGUsIGJldHdlZW4gLTE4MCBhbmQgKzE4MCBkZWdyZWVzXG4gKiBAcmV0dXJucyB7bnVtYmVyfSBhbmdsZSBiZXR3ZWVuIDAgYW5kIDM2MCBkZWdyZWVzXG4gKi9cbmZ1bmN0aW9uIGJlYXJpbmdUb0F6aW11dGgoYmVhcmluZykge1xuICAgIHZhciBhbmdsZSA9IGJlYXJpbmcgJSAzNjA7XG4gICAgaWYgKGFuZ2xlIDwgMCkge1xuICAgICAgICBhbmdsZSArPSAzNjA7XG4gICAgfVxuICAgIHJldHVybiBhbmdsZTtcbn1cbmV4cG9ydHMuYmVhcmluZ1RvQXppbXV0aCA9IGJlYXJpbmdUb0F6aW11dGg7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIHJhZGlhbnMgdG8gZGVncmVlc1xuICpcbiAqIEBuYW1lIHJhZGlhbnNUb0RlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSByYWRpYW5zIGFuZ2xlIGluIHJhZGlhbnNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXMgYmV0d2VlbiAwIGFuZCAzNjAgZGVncmVlc1xuICovXG5mdW5jdGlvbiByYWRpYW5zVG9EZWdyZWVzKHJhZGlhbnMpIHtcbiAgICB2YXIgZGVncmVlcyA9IHJhZGlhbnMgJSAoMiAqIE1hdGguUEkpO1xuICAgIHJldHVybiBkZWdyZWVzICogMTgwIC8gTWF0aC5QSTtcbn1cbmV4cG9ydHMucmFkaWFuc1RvRGVncmVlcyA9IHJhZGlhbnNUb0RlZ3JlZXM7XG4vKipcbiAqIENvbnZlcnRzIGFuIGFuZ2xlIGluIGRlZ3JlZXMgdG8gcmFkaWFuc1xuICpcbiAqIEBuYW1lIGRlZ3JlZXNUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkZWdyZWVzIGFuZ2xlIGJldHdlZW4gMCBhbmQgMzYwIGRlZ3JlZXNcbiAqIEByZXR1cm5zIHtudW1iZXJ9IGFuZ2xlIGluIHJhZGlhbnNcbiAqL1xuZnVuY3Rpb24gZGVncmVlc1RvUmFkaWFucyhkZWdyZWVzKSB7XG4gICAgdmFyIHJhZGlhbnMgPSBkZWdyZWVzICUgMzYwO1xuICAgIHJldHVybiByYWRpYW5zICogTWF0aC5QSSAvIDE4MDtcbn1cbmV4cG9ydHMuZGVncmVlc1RvUmFkaWFucyA9IGRlZ3JlZXNUb1JhZGlhbnM7XG4vKipcbiAqIENvbnZlcnRzIGEgbGVuZ3RoIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBtaWxlcywgbmF1dGljYWxtaWxlcywgaW5jaGVzLCB5YXJkcywgbWV0ZXJzLCBtZXRyZXMsIGtpbG9tZXRlcnMsIGNlbnRpbWV0ZXJzLCBmZWV0XG4gKlxuICogQHBhcmFtIHtudW1iZXJ9IGxlbmd0aCB0byBiZSBjb252ZXJ0ZWRcbiAqIEBwYXJhbSB7VW5pdHN9IFtvcmlnaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIG9mIHRoZSBsZW5ndGhcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgbGVuZ3RoXG4gKi9cbmZ1bmN0aW9uIGNvbnZlcnRMZW5ndGgobGVuZ3RoLCBvcmlnaW5hbFVuaXQsIGZpbmFsVW5pdCkge1xuICAgIGlmIChvcmlnaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBvcmlnaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmICghKGxlbmd0aCA+PSAwKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJsZW5ndGggbXVzdCBiZSBhIHBvc2l0aXZlIG51bWJlclwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnNUb0xlbmd0aChsZW5ndGhUb1JhZGlhbnMobGVuZ3RoLCBvcmlnaW5hbFVuaXQpLCBmaW5hbFVuaXQpO1xufVxuZXhwb3J0cy5jb252ZXJ0TGVuZ3RoID0gY29udmVydExlbmd0aDtcbi8qKlxuICogQ29udmVydHMgYSBhcmVhIHRvIHRoZSByZXF1ZXN0ZWQgdW5pdC5cbiAqIFZhbGlkIHVuaXRzOiBraWxvbWV0ZXJzLCBraWxvbWV0cmVzLCBtZXRlcnMsIG1ldHJlcywgY2VudGltZXRyZXMsIG1pbGxpbWV0ZXJzLCBhY3JlcywgbWlsZXMsIHlhcmRzLCBmZWV0LCBpbmNoZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBhcmVhIHRvIGJlIGNvbnZlcnRlZFxuICogQHBhcmFtIHtVbml0c30gW29yaWdpbmFsVW5pdD1cIm1ldGVyc1wiXSBvZiB0aGUgZGlzdGFuY2VcbiAqIEBwYXJhbSB7VW5pdHN9IFtmaW5hbFVuaXQ9XCJraWxvbWV0ZXJzXCJdIHJldHVybmVkIHVuaXRcbiAqIEByZXR1cm5zIHtudW1iZXJ9IHRoZSBjb252ZXJ0ZWQgZGlzdGFuY2VcbiAqL1xuZnVuY3Rpb24gY29udmVydEFyZWEoYXJlYSwgb3JpZ2luYWxVbml0LCBmaW5hbFVuaXQpIHtcbiAgICBpZiAob3JpZ2luYWxVbml0ID09PSB2b2lkIDApIHsgb3JpZ2luYWxVbml0ID0gXCJtZXRlcnNcIjsgfVxuICAgIGlmIChmaW5hbFVuaXQgPT09IHZvaWQgMCkgeyBmaW5hbFVuaXQgPSBcImtpbG9tZXRlcnNcIjsgfVxuICAgIGlmICghKGFyZWEgPj0gMCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYXJlYSBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyXCIpO1xuICAgIH1cbiAgICB2YXIgc3RhcnRGYWN0b3IgPSBleHBvcnRzLmFyZWFGYWN0b3JzW29yaWdpbmFsVW5pdF07XG4gICAgaWYgKCFzdGFydEZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIG9yaWdpbmFsIHVuaXRzXCIpO1xuICAgIH1cbiAgICB2YXIgZmluYWxGYWN0b3IgPSBleHBvcnRzLmFyZWFGYWN0b3JzW2ZpbmFsVW5pdF07XG4gICAgaWYgKCFmaW5hbEZhY3Rvcikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJpbnZhbGlkIGZpbmFsIHVuaXRzXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKGFyZWEgLyBzdGFydEZhY3RvcikgKiBmaW5hbEZhY3Rvcjtcbn1cbmV4cG9ydHMuY29udmVydEFyZWEgPSBjb252ZXJ0QXJlYTtcbi8qKlxuICogaXNOdW1iZXJcbiAqXG4gKiBAcGFyYW0geyp9IG51bSBOdW1iZXIgdG8gdmFsaWRhdGVcbiAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlL2ZhbHNlXG4gKiBAZXhhbXBsZVxuICogdHVyZi5pc051bWJlcigxMjMpXG4gKiAvLz10cnVlXG4gKiB0dXJmLmlzTnVtYmVyKCdmb28nKVxuICogLy89ZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIobnVtKSB7XG4gICAgcmV0dXJuICFpc05hTihudW0pICYmIG51bSAhPT0gbnVsbCAmJiAhQXJyYXkuaXNBcnJheShudW0pICYmICEvXlxccyokLy50ZXN0KG51bSk7XG59XG5leHBvcnRzLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4vKipcbiAqIGlzT2JqZWN0XG4gKlxuICogQHBhcmFtIHsqfSBpbnB1dCB2YXJpYWJsZSB0byB2YWxpZGF0ZVxuICogQHJldHVybnMge2Jvb2xlYW59IHRydWUvZmFsc2VcbiAqIEBleGFtcGxlXG4gKiB0dXJmLmlzT2JqZWN0KHtlbGV2YXRpb246IDEwfSlcbiAqIC8vPXRydWVcbiAqIHR1cmYuaXNPYmplY3QoJ2ZvbycpXG4gKiAvLz1mYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdChpbnB1dCkge1xuICAgIHJldHVybiAoISFpbnB1dCkgJiYgKGlucHV0LmNvbnN0cnVjdG9yID09PSBPYmplY3QpO1xufVxuZXhwb3J0cy5pc09iamVjdCA9IGlzT2JqZWN0O1xuLyoqXG4gKiBWYWxpZGF0ZSBCQm94XG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBCQm94IHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgQkJveCBpcyBub3QgdmFsaWRcbiAqIEBleGFtcGxlXG4gKiB2YWxpZGF0ZUJCb3goWy0xODAsIC00MCwgMTEwLCA1MF0pXG4gKiAvLz1PS1xuICogdmFsaWRhdGVCQm94KFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlQkJveCgnRm9vJylcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3goNSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3gobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUJCb3godW5kZWZpbmVkKVxuICogLy89RXJyb3JcbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVCQm94KGJib3gpIHtcbiAgICBpZiAoIWJib3gpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmJveCBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGJib3gpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheVwiKTtcbiAgICB9XG4gICAgaWYgKGJib3gubGVuZ3RoICE9PSA0ICYmIGJib3gubGVuZ3RoICE9PSA2KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImJib3ggbXVzdCBiZSBhbiBBcnJheSBvZiA0IG9yIDYgbnVtYmVyc1wiKTtcbiAgICB9XG4gICAgYmJveC5mb3JFYWNoKGZ1bmN0aW9uIChudW0pIHtcbiAgICAgICAgaWYgKCFpc051bWJlcihudW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJiYm94IG11c3Qgb25seSBjb250YWluIG51bWJlcnNcIik7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmV4cG9ydHMudmFsaWRhdGVCQm94ID0gdmFsaWRhdGVCQm94O1xuLyoqXG4gKiBWYWxpZGF0ZSBJZFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge3N0cmluZ3xudW1iZXJ9IGlkIElkIHRvIHZhbGlkYXRlXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEB0aHJvd3MgRXJyb3IgaWYgSWQgaXMgbm90IHZhbGlkXG4gKiBAZXhhbXBsZVxuICogdmFsaWRhdGVJZChbLTE4MCwgLTQwLCAxMTAsIDUwXSlcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKFstMTgwLCAtNDBdKVxuICogLy89RXJyb3JcbiAqIHZhbGlkYXRlSWQoJ0ZvbycpXG4gKiAvLz1PS1xuICogdmFsaWRhdGVJZCg1KVxuICogLy89T0tcbiAqIHZhbGlkYXRlSWQobnVsbClcbiAqIC8vPUVycm9yXG4gKiB2YWxpZGF0ZUlkKHVuZGVmaW5lZClcbiAqIC8vPUVycm9yXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlSWQoaWQpIHtcbiAgICBpZiAoIWlkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImlkIGlzIHJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBpZiAoW1wic3RyaW5nXCIsIFwibnVtYmVyXCJdLmluZGV4T2YodHlwZW9mIGlkKSA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaWQgbXVzdCBiZSBhIG51bWJlciBvciBhIHN0cmluZ1wiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlSWQgPSB2YWxpZGF0ZUlkO1xuLy8gRGVwcmVjYXRlZCBtZXRob2RzXG5mdW5jdGlvbiByYWRpYW5zMmRlZ3JlZXMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHJhZGlhbnNUb0RlZ3JlZXNgXCIpO1xufVxuZXhwb3J0cy5yYWRpYW5zMmRlZ3JlZXMgPSByYWRpYW5zMmRlZ3JlZXM7XG5mdW5jdGlvbiBkZWdyZWVzMnJhZGlhbnMoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGRlZ3JlZXNUb1JhZGlhbnNgXCIpO1xufVxuZXhwb3J0cy5kZWdyZWVzMnJhZGlhbnMgPSBkZWdyZWVzMnJhZGlhbnM7XG5mdW5jdGlvbiBkaXN0YW5jZVRvRGVncmVlcygpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBgbGVuZ3RoVG9EZWdyZWVzYFwiKTtcbn1cbmV4cG9ydHMuZGlzdGFuY2VUb0RlZ3JlZXMgPSBkaXN0YW5jZVRvRGVncmVlcztcbmZ1bmN0aW9uIGRpc3RhbmNlVG9SYWRpYW5zKCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIm1ldGhvZCBoYXMgYmVlbiByZW5hbWVkIHRvIGBsZW5ndGhUb1JhZGlhbnNgXCIpO1xufVxuZXhwb3J0cy5kaXN0YW5jZVRvUmFkaWFucyA9IGRpc3RhbmNlVG9SYWRpYW5zO1xuZnVuY3Rpb24gcmFkaWFuc1RvRGlzdGFuY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYHJhZGlhbnNUb0xlbmd0aGBcIik7XG59XG5leHBvcnRzLnJhZGlhbnNUb0Rpc3RhbmNlID0gcmFkaWFuc1RvRGlzdGFuY2U7XG5mdW5jdGlvbiBiZWFyaW5nVG9BbmdsZSgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJtZXRob2QgaGFzIGJlZW4gcmVuYW1lZCB0byBgYmVhcmluZ1RvQXppbXV0aGBcIik7XG59XG5leHBvcnRzLmJlYXJpbmdUb0FuZ2xlID0gYmVhcmluZ1RvQW5nbGU7XG5mdW5jdGlvbiBjb252ZXJ0RGlzdGFuY2UoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwibWV0aG9kIGhhcyBiZWVuIHJlbmFtZWQgdG8gYGNvbnZlcnRMZW5ndGhgXCIpO1xufVxuZXhwb3J0cy5jb252ZXJ0RGlzdGFuY2UgPSBjb252ZXJ0RGlzdGFuY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIkB0dXJmL2hlbHBlcnNcIik7XHJcbi8qKlxyXG4gKiBVbndyYXAgYSBjb29yZGluYXRlIGZyb20gYSBQb2ludCBGZWF0dXJlLCBHZW9tZXRyeSBvciBhIHNpbmdsZSBjb29yZGluYXRlLlxyXG4gKlxyXG4gKiBAbmFtZSBnZXRDb29yZFxyXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj58R2VvbWV0cnk8UG9pbnQ+fEZlYXR1cmU8UG9pbnQ+fSBjb29yZCBHZW9KU09OIFBvaW50IG9yIGFuIEFycmF5IG9mIG51bWJlcnNcclxuICogQHJldHVybnMge0FycmF5PG51bWJlcj59IGNvb3JkaW5hdGVzXHJcbiAqIEBleGFtcGxlXHJcbiAqIHZhciBwdCA9IHR1cmYucG9pbnQoWzEwLCAxMF0pO1xyXG4gKlxyXG4gKiB2YXIgY29vcmQgPSB0dXJmLmdldENvb3JkKHB0KTtcclxuICogLy89IFsxMCwgMTBdXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRDb29yZChjb29yZCkge1xyXG4gICAgaWYgKCFjb29yZCkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIGlzIHJlcXVpcmVkXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGNvb3JkKSkge1xyXG4gICAgICAgIGlmIChjb29yZC50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBjb29yZC5nZW9tZXRyeSAhPT0gbnVsbCAmJiBjb29yZC5nZW9tZXRyeS50eXBlID09PSBcIlBvaW50XCIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNvb3JkLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoY29vcmQudHlwZSA9PT0gXCJQb2ludFwiKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjb29yZC5jb29yZGluYXRlcztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjb29yZCkgJiYgY29vcmQubGVuZ3RoID49IDIgJiYgIUFycmF5LmlzQXJyYXkoY29vcmRbMF0pICYmICFBcnJheS5pc0FycmF5KGNvb3JkWzFdKSkge1xyXG4gICAgICAgIHJldHVybiBjb29yZDtcclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkIG11c3QgYmUgR2VvSlNPTiBQb2ludCBvciBhbiBBcnJheSBvZiBudW1iZXJzXCIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29vcmQgPSBnZXRDb29yZDtcclxuLyoqXHJcbiAqIFVud3JhcCBjb29yZGluYXRlcyBmcm9tIGEgRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XHJcbiAqXHJcbiAqIEBuYW1lIGdldENvb3Jkc1xyXG4gKiBAcGFyYW0ge0FycmF5PGFueT58R2VvbWV0cnl8RmVhdHVyZX0gY29vcmRzIEZlYXR1cmUsIEdlb21ldHJ5IE9iamVjdCBvciBhbiBBcnJheVxyXG4gKiBAcmV0dXJucyB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXNcclxuICogQGV4YW1wbGVcclxuICogdmFyIHBvbHkgPSB0dXJmLnBvbHlnb24oW1tbMTE5LjMyLCAtOC43XSwgWzExOS41NSwgLTguNjldLCBbMTE5LjUxLCAtOC41NF0sIFsxMTkuMzIsIC04LjddXV0pO1xyXG4gKlxyXG4gKiB2YXIgY29vcmRzID0gdHVyZi5nZXRDb29yZHMocG9seSk7XHJcbiAqIC8vPSBbW1sxMTkuMzIsIC04LjddLCBbMTE5LjU1LCAtOC42OV0sIFsxMTkuNTEsIC04LjU0XSwgWzExOS4zMiwgLTguN11dXVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q29vcmRzKGNvb3Jkcykge1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRzKSkge1xyXG4gICAgICAgIHJldHVybiBjb29yZHM7XHJcbiAgICB9XHJcbiAgICAvLyBGZWF0dXJlXHJcbiAgICBpZiAoY29vcmRzLnR5cGUgPT09IFwiRmVhdHVyZVwiKSB7XHJcbiAgICAgICAgaWYgKGNvb3Jkcy5nZW9tZXRyeSAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIC8vIEdlb21ldHJ5XHJcbiAgICAgICAgaWYgKGNvb3Jkcy5jb29yZGluYXRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gY29vcmRzLmNvb3JkaW5hdGVzO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHRocm93IG5ldyBFcnJvcihcImNvb3JkcyBtdXN0IGJlIEdlb0pTT04gRmVhdHVyZSwgR2VvbWV0cnkgT2JqZWN0IG9yIGFuIEFycmF5XCIpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Q29vcmRzID0gZ2V0Q29vcmRzO1xyXG4vKipcclxuICogQ2hlY2tzIGlmIGNvb3JkaW5hdGVzIGNvbnRhaW5zIGEgbnVtYmVyXHJcbiAqXHJcbiAqIEBuYW1lIGNvbnRhaW5zTnVtYmVyXHJcbiAqIEBwYXJhbSB7QXJyYXk8YW55Pn0gY29vcmRpbmF0ZXMgR2VvSlNPTiBDb29yZGluYXRlc1xyXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gdHJ1ZSBpZiBBcnJheSBjb250YWlucyBhIG51bWJlclxyXG4gKi9cclxuZnVuY3Rpb24gY29udGFpbnNOdW1iZXIoY29vcmRpbmF0ZXMpIHtcclxuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPiAxICYmIGhlbHBlcnNfMS5pc051bWJlcihjb29yZGluYXRlc1swXSkgJiYgaGVscGVyc18xLmlzTnVtYmVyKGNvb3JkaW5hdGVzWzFdKSkge1xyXG4gICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgfVxyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoY29vcmRpbmF0ZXNbMF0pICYmIGNvb3JkaW5hdGVzWzBdLmxlbmd0aCkge1xyXG4gICAgICAgIHJldHVybiBjb250YWluc051bWJlcihjb29yZGluYXRlc1swXSk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJjb29yZGluYXRlcyBtdXN0IG9ubHkgY29udGFpbiBudW1iZXJzXCIpO1xyXG59XHJcbmV4cG9ydHMuY29udGFpbnNOdW1iZXIgPSBjb250YWluc051bWJlcjtcclxuLyoqXHJcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIEdlb0pTT04gb2JqZWN0cyBmb3IgVHVyZi5cclxuICpcclxuICogQG5hbWUgZ2VvanNvblR5cGVcclxuICogQHBhcmFtIHtHZW9KU09OfSB2YWx1ZSBhbnkgR2VvSlNPTiBvYmplY3RcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gZ2VvanNvblR5cGUodmFsdWUsIHR5cGUsIG5hbWUpIHtcclxuICAgIGlmICghdHlwZSB8fCAhbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInR5cGUgYW5kIG5hbWUgcmVxdWlyZWRcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICsgbmFtZSArIFwiOiBtdXN0IGJlIGEgXCIgKyB0eXBlICsgXCIsIGdpdmVuIFwiICsgdmFsdWUudHlwZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5nZW9qc29uVHlwZSA9IGdlb2pzb25UeXBlO1xyXG4vKipcclxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmV9IGlucHV0cyBmb3IgVHVyZi5cclxuICogSW50ZXJuYWxseSB0aGlzIHVzZXMge0BsaW5rIGdlb2pzb25UeXBlfSB0byBqdWRnZSBnZW9tZXRyeSB0eXBlcy5cclxuICpcclxuICogQG5hbWUgZmVhdHVyZU9mXHJcbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBhIGZlYXR1cmUgd2l0aCBhbiBleHBlY3RlZCBnZW9tZXRyeSB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlIGV4cGVjdGVkIEdlb0pTT04gdHlwZVxyXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cclxuICogQHRocm93cyB7RXJyb3J9IGVycm9yIGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cclxuICovXHJcbmZ1bmN0aW9uIGZlYXR1cmVPZihmZWF0dXJlLCB0eXBlLCBuYW1lKSB7XHJcbiAgICBpZiAoIWZlYXR1cmUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJObyBmZWF0dXJlIHBhc3NlZFwiKTtcclxuICAgIH1cclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIi5mZWF0dXJlT2YoKSByZXF1aXJlcyBhIG5hbWVcIik7XHJcbiAgICB9XHJcbiAgICBpZiAoIWZlYXR1cmUgfHwgZmVhdHVyZS50eXBlICE9PSBcIkZlYXR1cmVcIiB8fCAhZmVhdHVyZS5nZW9tZXRyeSkge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCIsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZFwiKTtcclxuICAgIH1cclxuICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IHR5cGUpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGlucHV0IHRvIFwiICsgbmFtZSArIFwiOiBtdXN0IGJlIGEgXCIgKyB0eXBlICsgXCIsIGdpdmVuIFwiICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmZlYXR1cmVPZiA9IGZlYXR1cmVPZjtcclxuLyoqXHJcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gaW5wdXRzIGZvciBUdXJmLlxyXG4gKiBJbnRlcm5hbGx5IHRoaXMgdXNlcyB7QGxpbmsgZ2VvanNvblR5cGV9IHRvIGp1ZGdlIGdlb21ldHJ5IHR5cGVzLlxyXG4gKlxyXG4gKiBAbmFtZSBjb2xsZWN0aW9uT2ZcclxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbn0gZmVhdHVyZUNvbGxlY3Rpb24gYSBGZWF0dXJlQ29sbGVjdGlvbiBmb3Igd2hpY2ggZmVhdHVyZXMgd2lsbCBiZSBqdWRnZWRcclxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdmFsdWUgaXMgbm90IHRoZSBleHBlY3RlZCB0eXBlLlxyXG4gKi9cclxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKGZlYXR1cmVDb2xsZWN0aW9uLCB0eXBlLCBuYW1lKSB7XHJcbiAgICBpZiAoIWZlYXR1cmVDb2xsZWN0aW9uKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTm8gZmVhdHVyZUNvbGxlY3Rpb24gcGFzc2VkXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCFuYW1lKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiLmNvbGxlY3Rpb25PZigpIHJlcXVpcmVzIGEgbmFtZVwiKTtcclxuICAgIH1cclxuICAgIGlmICghZmVhdHVyZUNvbGxlY3Rpb24gfHwgZmVhdHVyZUNvbGxlY3Rpb24udHlwZSAhPT0gXCJGZWF0dXJlQ29sbGVjdGlvblwiKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBcIiArIG5hbWUgKyBcIiwgRmVhdHVyZUNvbGxlY3Rpb24gcmVxdWlyZWRcIik7XHJcbiAgICB9XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gZmVhdHVyZUNvbGxlY3Rpb24uZmVhdHVyZXM7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFyIGZlYXR1cmUgPSBfYVtfaV07XHJcbiAgICAgICAgaWYgKCFmZWF0dXJlIHx8IGZlYXR1cmUudHlwZSAhPT0gXCJGZWF0dXJlXCIgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBcIiArIG5hbWUgKyBcIiwgRmVhdHVyZSB3aXRoIGdlb21ldHJ5IHJlcXVpcmVkXCIpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkgfHwgZmVhdHVyZS5nZW9tZXRyeS50eXBlICE9PSB0eXBlKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgaW5wdXQgdG8gXCIgKyBuYW1lICsgXCI6IG11c3QgYmUgYSBcIiArIHR5cGUgKyBcIiwgZ2l2ZW4gXCIgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLmNvbGxlY3Rpb25PZiA9IGNvbGxlY3Rpb25PZjtcclxuLyoqXHJcbiAqIEdldCBHZW9tZXRyeSBmcm9tIEZlYXR1cmUgb3IgR2VvbWV0cnkgT2JqZWN0XHJcbiAqXHJcbiAqIEBwYXJhbSB7RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBHZW9KU09OIEZlYXR1cmUgb3IgR2VvbWV0cnkgT2JqZWN0XHJcbiAqIEByZXR1cm5zIHtHZW9tZXRyeXxudWxsfSBHZW9KU09OIEdlb21ldHJ5IE9iamVjdFxyXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgZ2VvanNvbiBpcyBub3QgYSBGZWF0dXJlIG9yIEdlb21ldHJ5IE9iamVjdFxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcG9pbnQgPSB7XHJcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDQwXVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiB2YXIgZ2VvbSA9IHR1cmYuZ2V0R2VvbShwb2ludClcclxuICogLy89e1widHlwZVwiOiBcIlBvaW50XCIsIFwiY29vcmRpbmF0ZXNcIjogWzExMCwgNDBdfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0R2VvbShnZW9qc29uKSB7XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIikge1xyXG4gICAgICAgIHJldHVybiBnZW9qc29uLmdlb21ldHJ5O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdlb2pzb247XHJcbn1cclxuZXhwb3J0cy5nZXRHZW9tID0gZ2V0R2VvbTtcclxuLyoqXHJcbiAqIEdldCBHZW9KU09OIG9iamVjdCdzIHR5cGUsIEdlb21ldHJ5IHR5cGUgaXMgcHJpb3JpdGl6ZS5cclxuICpcclxuICogQHBhcmFtIHtHZW9KU09OfSBnZW9qc29uIEdlb0pTT04gb2JqZWN0XHJcbiAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT1cImdlb2pzb25cIl0gbmFtZSBvZiB0aGUgdmFyaWFibGUgdG8gZGlzcGxheSBpbiBlcnJvciBtZXNzYWdlXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IEdlb0pTT04gdHlwZVxyXG4gKiBAZXhhbXBsZVxyXG4gKiB2YXIgcG9pbnQgPSB7XHJcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxyXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcclxuICogICBcImdlb21ldHJ5XCI6IHtcclxuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXHJcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTAsIDQwXVxyXG4gKiAgIH1cclxuICogfVxyXG4gKiB2YXIgZ2VvbSA9IHR1cmYuZ2V0VHlwZShwb2ludClcclxuICogLy89XCJQb2ludFwiXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRUeXBlKGdlb2pzb24sIG5hbWUpIHtcclxuICAgIGlmIChnZW9qc29uLnR5cGUgPT09IFwiRmVhdHVyZUNvbGxlY3Rpb25cIikge1xyXG4gICAgICAgIHJldHVybiBcIkZlYXR1cmVDb2xsZWN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkdlb21ldHJ5Q29sbGVjdGlvblwiKSB7XHJcbiAgICAgICAgcmV0dXJuIFwiR2VvbWV0cnlDb2xsZWN0aW9uXCI7XHJcbiAgICB9XHJcbiAgICBpZiAoZ2VvanNvbi50eXBlID09PSBcIkZlYXR1cmVcIiAmJiBnZW9qc29uLmdlb21ldHJ5ICE9PSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdlb2pzb24uZ2VvbWV0cnkudHlwZTtcclxuICAgIH1cclxuICAgIHJldHVybiBnZW9qc29uLnR5cGU7XHJcbn1cclxuZXhwb3J0cy5nZXRUeXBlID0gZ2V0VHlwZTtcclxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19pbXBvcnREZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydERlZmF1bHQpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICByZXR1cm4gKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgPyBtb2QgOiB7IFwiZGVmYXVsdFwiOiBtb2QgfTtcbn1cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG52YXIgbGluZV9zZWdtZW50XzEgPSBfX2ltcG9ydERlZmF1bHQocmVxdWlyZShcIkB0dXJmL2xpbmUtc2VnbWVudFwiKSk7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgZ2VvanNvbl9yYnVzaF8xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJnZW9qc29uLXJidXNoXCIpKTtcbi8qKlxuICogVGFrZXMgYW55IExpbmVTdHJpbmcgb3IgUG9seWdvbiBHZW9KU09OIGFuZCByZXR1cm5zIHRoZSBpbnRlcnNlY3RpbmcgcG9pbnQocykuXG4gKlxuICogQG5hbWUgbGluZUludGVyc2VjdFxuICogQHBhcmFtIHtHZW9KU09OfSBsaW5lMSBhbnkgTGluZVN0cmluZyBvciBQb2x5Z29uXG4gKiBAcGFyYW0ge0dlb0pTT059IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50KHMpIHRoYXQgaW50ZXJzZWN0IGJvdGhcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZTEgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMjYsIC0xMV0sIFsxMjksIC0yMV1dKTtcbiAqIHZhciBsaW5lMiA9IHR1cmYubGluZVN0cmluZyhbWzEyMywgLTE4XSwgWzEzMSwgLTE0XV0pO1xuICogdmFyIGludGVyc2VjdHMgPSB0dXJmLmxpbmVJbnRlcnNlY3QobGluZTEsIGxpbmUyKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbbGluZTEsIGxpbmUyLCBpbnRlcnNlY3RzXVxuICovXG5mdW5jdGlvbiBsaW5lSW50ZXJzZWN0KGxpbmUxLCBsaW5lMikge1xuICAgIHZhciB1bmlxdWUgPSB7fTtcbiAgICB2YXIgcmVzdWx0cyA9IFtdO1xuICAgIC8vIEZpcnN0LCBub3JtYWxpemUgZ2VvbWV0cmllcyB0byBmZWF0dXJlc1xuICAgIC8vIFRoZW4sIGhhbmRsZSBzaW1wbGUgMi12ZXJ0ZXggc2VnbWVudHNcbiAgICBpZiAobGluZTEudHlwZSA9PT0gXCJMaW5lU3RyaW5nXCIpIHtcbiAgICAgICAgbGluZTEgPSBoZWxwZXJzXzEuZmVhdHVyZShsaW5lMSk7XG4gICAgfVxuICAgIGlmIChsaW5lMi50eXBlID09PSBcIkxpbmVTdHJpbmdcIikge1xuICAgICAgICBsaW5lMiA9IGhlbHBlcnNfMS5mZWF0dXJlKGxpbmUyKTtcbiAgICB9XG4gICAgaWYgKGxpbmUxLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmXG4gICAgICAgIGxpbmUyLnR5cGUgPT09IFwiRmVhdHVyZVwiICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5ICE9PSBudWxsICYmXG4gICAgICAgIGxpbmUyLmdlb21ldHJ5ICE9PSBudWxsICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiICYmXG4gICAgICAgIGxpbmUyLmdlb21ldHJ5LnR5cGUgPT09IFwiTGluZVN0cmluZ1wiICYmXG4gICAgICAgIGxpbmUxLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmxlbmd0aCA9PT0gMiAmJlxuICAgICAgICBsaW5lMi5nZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgdmFyIGludGVyc2VjdCA9IGludGVyc2VjdHMobGluZTEsIGxpbmUyKTtcbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgcmVzdWx0cy5wdXNoKGludGVyc2VjdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGhlbHBlcnNfMS5mZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbiAgICB9XG4gICAgLy8gSGFuZGxlcyBjb21wbGV4IEdlb0pTT04gR2VvbWV0cmllc1xuICAgIHZhciB0cmVlID0gZ2VvanNvbl9yYnVzaF8xLmRlZmF1bHQoKTtcbiAgICB0cmVlLmxvYWQobGluZV9zZWdtZW50XzEuZGVmYXVsdChsaW5lMikpO1xuICAgIG1ldGFfMS5mZWF0dXJlRWFjaChsaW5lX3NlZ21lbnRfMS5kZWZhdWx0KGxpbmUxKSwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgbWV0YV8xLmZlYXR1cmVFYWNoKHRyZWUuc2VhcmNoKHNlZ21lbnQpLCBmdW5jdGlvbiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBpbnRlcnNlY3RzKHNlZ21lbnQsIG1hdGNoKTtcbiAgICAgICAgICAgIGlmIChpbnRlcnNlY3QpIHtcbiAgICAgICAgICAgICAgICAvLyBwcmV2ZW50IGR1cGxpY2F0ZSBwb2ludHMgaHR0cHM6Ly9naXRodWIuY29tL1R1cmZqcy90dXJmL2lzc3Vlcy82ODhcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGludGVyc2VjdCkuam9pbihcIixcIik7XG4gICAgICAgICAgICAgICAgaWYgKCF1bmlxdWVba2V5XSkge1xuICAgICAgICAgICAgICAgICAgICB1bmlxdWVba2V5XSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChpbnRlcnNlY3QpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGhlbHBlcnNfMS5mZWF0dXJlQ29sbGVjdGlvbihyZXN1bHRzKTtcbn1cbi8qKlxuICogRmluZCBhIHBvaW50IHRoYXQgaW50ZXJzZWN0cyBMaW5lU3RyaW5ncyB3aXRoIHR3byBjb29yZGluYXRlcyBlYWNoXG4gKlxuICogQHByaXZhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZTEgR2VvSlNPTiBMaW5lU3RyaW5nIChNdXN0IG9ubHkgY29udGFpbiAyIGNvb3JkaW5hdGVzKVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lMiBHZW9KU09OIExpbmVTdHJpbmcgKE11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXMpXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGludGVyc2VjdGluZyBHZW9KU09OIFBvaW50XG4gKi9cbmZ1bmN0aW9uIGludGVyc2VjdHMobGluZTEsIGxpbmUyKSB7XG4gICAgdmFyIGNvb3JkczEgPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobGluZTEpO1xuICAgIHZhciBjb29yZHMyID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGxpbmUyKTtcbiAgICBpZiAoY29vcmRzMS5sZW5ndGggIT09IDIpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiPGludGVyc2VjdHM+IGxpbmUxIG11c3Qgb25seSBjb250YWluIDIgY29vcmRpbmF0ZXNcIik7XG4gICAgfVxuICAgIGlmIChjb29yZHMyLmxlbmd0aCAhPT0gMikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCI8aW50ZXJzZWN0cz4gbGluZTIgbXVzdCBvbmx5IGNvbnRhaW4gMiBjb29yZGluYXRlc1wiKTtcbiAgICB9XG4gICAgdmFyIHgxID0gY29vcmRzMVswXVswXTtcbiAgICB2YXIgeTEgPSBjb29yZHMxWzBdWzFdO1xuICAgIHZhciB4MiA9IGNvb3JkczFbMV1bMF07XG4gICAgdmFyIHkyID0gY29vcmRzMVsxXVsxXTtcbiAgICB2YXIgeDMgPSBjb29yZHMyWzBdWzBdO1xuICAgIHZhciB5MyA9IGNvb3JkczJbMF1bMV07XG4gICAgdmFyIHg0ID0gY29vcmRzMlsxXVswXTtcbiAgICB2YXIgeTQgPSBjb29yZHMyWzFdWzFdO1xuICAgIHZhciBkZW5vbSA9ICgoeTQgLSB5MykgKiAoeDIgLSB4MSkpIC0gKCh4NCAtIHgzKSAqICh5MiAtIHkxKSk7XG4gICAgdmFyIG51bWVBID0gKCh4NCAtIHgzKSAqICh5MSAtIHkzKSkgLSAoKHk0IC0geTMpICogKHgxIC0geDMpKTtcbiAgICB2YXIgbnVtZUIgPSAoKHgyIC0geDEpICogKHkxIC0geTMpKSAtICgoeTIgLSB5MSkgKiAoeDEgLSB4MykpO1xuICAgIGlmIChkZW5vbSA9PT0gMCkge1xuICAgICAgICBpZiAobnVtZUEgPT09IDAgJiYgbnVtZUIgPT09IDApIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICB2YXIgdUEgPSBudW1lQSAvIGRlbm9tO1xuICAgIHZhciB1QiA9IG51bWVCIC8gZGVub207XG4gICAgaWYgKHVBID49IDAgJiYgdUEgPD0gMSAmJiB1QiA+PSAwICYmIHVCIDw9IDEpIHtcbiAgICAgICAgdmFyIHggPSB4MSArICh1QSAqICh4MiAtIHgxKSk7XG4gICAgICAgIHZhciB5ID0geTEgKyAodUEgKiAoeTIgLSB5MSkpO1xuICAgICAgICByZXR1cm4gaGVscGVyc18xLnBvaW50KFt4LCB5XSk7XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbGluZUludGVyc2VjdDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIGdlb2pzb25fcmJ1c2hfMSA9IHJlcXVpcmUoXCJnZW9qc29uLXJidXNoXCIpO1xudmFyIGxpbmVfc2VnbWVudF8xID0gcmVxdWlyZShcIkB0dXJmL2xpbmUtc2VnbWVudFwiKTtcbnZhciBuZWFyZXN0X3BvaW50X29uX2xpbmVfMSA9IHJlcXVpcmUoXCJAdHVyZi9uZWFyZXN0LXBvaW50LW9uLWxpbmVcIik7XG52YXIgYm9vbGVhbl9wb2ludF9vbl9saW5lXzEgPSByZXF1aXJlKFwiQHR1cmYvYm9vbGVhbi1wb2ludC1vbi1saW5lXCIpO1xudmFyIGludmFyaWFudF8xID0gcmVxdWlyZShcIkB0dXJmL2ludmFyaWFudFwiKTtcbnZhciBtZXRhXzEgPSByZXF1aXJlKFwiQHR1cmYvbWV0YVwiKTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBlcXVhbCA9IHJlcXVpcmUoXCJkZWVwLWVxdWFsXCIpO1xuLyoqXG4gKiBUYWtlcyBhbnkgTGluZVN0cmluZyBvciBQb2x5Z29uIGFuZCByZXR1cm5zIHRoZSBvdmVybGFwcGluZyBsaW5lcyBiZXR3ZWVuIGJvdGggZmVhdHVyZXMuXG4gKlxuICogQG5hbWUgbGluZU92ZXJsYXBcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUxIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZ3xQb2x5Z29ufE11bHRpUG9seWdvbj59IGxpbmUyIGFueSBMaW5lU3RyaW5nIG9yIFBvbHlnb25cbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRvbGVyYW5jZT0wXSBUb2xlcmFuY2UgZGlzdGFuY2UgdG8gbWF0Y2ggb3ZlcmxhcHBpbmcgbGluZSBzZWdtZW50cyAoaW4ga2lsb21ldGVycylcbiAqIEByZXR1cm5zIHtGZWF0dXJlQ29sbGVjdGlvbjxMaW5lU3RyaW5nPn0gbGluZXMocykgdGhhdCBhcmUgb3ZlcmxhcHBpbmcgYmV0d2VlbiBib3RoIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUxID0gdHVyZi5saW5lU3RyaW5nKFtbMTE1LCAtMzVdLCBbMTI1LCAtMzBdLCBbMTM1LCAtMzBdLCBbMTQ1LCAtMzVdXSk7XG4gKiB2YXIgbGluZTIgPSB0dXJmLmxpbmVTdHJpbmcoW1sxMTUsIC0yNV0sIFsxMjUsIC0zMF0sIFsxMzUsIC0zMF0sIFsxNDUsIC0yNV1dKTtcbiAqXG4gKiB2YXIgb3ZlcmxhcHBpbmcgPSB0dXJmLmxpbmVPdmVybGFwKGxpbmUxLCBsaW5lMik7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUxLCBsaW5lMiwgb3ZlcmxhcHBpbmddXG4gKi9cbmZ1bmN0aW9uIGxpbmVPdmVybGFwKGxpbmUxLCBsaW5lMiwgb3B0aW9ucykge1xuICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XG4gICAgLy8gT3B0aW9uYWwgcGFyYW1ldGVyc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghaGVscGVyc18xLmlzT2JqZWN0KG9wdGlvbnMpKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgaXMgaW52YWxpZCcpO1xuICAgIHZhciB0b2xlcmFuY2UgPSBvcHRpb25zLnRvbGVyYW5jZSB8fCAwO1xuICAgIC8vIENvbnRhaW5lcnNcbiAgICB2YXIgZmVhdHVyZXMgPSBbXTtcbiAgICAvLyBDcmVhdGUgU3BhdGlhbCBJbmRleFxuICAgIHZhciB0cmVlID0gZ2VvanNvbl9yYnVzaF8xLmRlZmF1bHQoKTtcbiAgICAvLyBUby1EbyAtLSBIQUNLIHdheSB0byBzdXBwb3J0IHR5cGVzY3JpcHRcbiAgICB2YXIgbGluZSA9IGxpbmVfc2VnbWVudF8xLmRlZmF1bHQobGluZTEpO1xuICAgIHRyZWUubG9hZChsaW5lKTtcbiAgICB2YXIgb3ZlcmxhcFNlZ21lbnQ7XG4gICAgLy8gTGluZSBJbnRlcnNlY3Rpb25cbiAgICAvLyBJdGVyYXRlIG92ZXIgbGluZSBzZWdtZW50c1xuICAgIG1ldGFfMS5zZWdtZW50RWFjaChsaW5lMiwgZnVuY3Rpb24gKHNlZ21lbnQpIHtcbiAgICAgICAgdmFyIGRvZXNPdmVybGFwcyA9IGZhbHNlO1xuICAgICAgICAvLyBJdGVyYXRlIG92ZXIgZWFjaCBzZWdtZW50cyB3aGljaCBmYWxscyB3aXRoaW4gdGhlIHNhbWUgYm91bmRzXG4gICAgICAgIG1ldGFfMS5mZWF0dXJlRWFjaCh0cmVlLnNlYXJjaChzZWdtZW50KSwgZnVuY3Rpb24gKG1hdGNoKSB7XG4gICAgICAgICAgICBpZiAoZG9lc092ZXJsYXBzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHZhciBjb29yZHNTZWdtZW50ID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKHNlZ21lbnQpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICB2YXIgY29vcmRzTWF0Y2ggPSBpbnZhcmlhbnRfMS5nZXRDb29yZHMobWF0Y2gpLnNvcnQoKTtcbiAgICAgICAgICAgICAgICAvLyBTZWdtZW50IG92ZXJsYXBzIGZlYXR1cmVcbiAgICAgICAgICAgICAgICBpZiAoZXF1YWwoY29vcmRzU2VnbWVudCwgY29vcmRzTWF0Y2gpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRvZXNPdmVybGFwcyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIC8vIE92ZXJsYXBzIGFscmVhZHkgZXhpc3RzIC0gb25seSBhcHBlbmQgbGFzdCBjb29yZGluYXRlIG9mIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgICAgICAvLyBNYXRjaCBzZWdtZW50cyB3aGljaCBkb24ndCBzaGFyZSBub2RlcyAoSXNzdWUgIzkwMSlcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoKHRvbGVyYW5jZSA9PT0gMCkgP1xuICAgICAgICAgICAgICAgICAgICBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGNvb3Jkc1NlZ21lbnRbMF0sIG1hdGNoKSAmJiBib29sZWFuX3BvaW50X29uX2xpbmVfMS5kZWZhdWx0KGNvb3Jkc1NlZ21lbnRbMV0sIG1hdGNoKSA6XG4gICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfcG9pbnRfb25fbGluZV8xLmRlZmF1bHQobWF0Y2gsIGNvb3Jkc1NlZ21lbnRbMF0pLnByb3BlcnRpZXMuZGlzdCA8PSB0b2xlcmFuY2UgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG5lYXJlc3RfcG9pbnRfb25fbGluZV8xLmRlZmF1bHQobWF0Y2gsIGNvb3Jkc1NlZ21lbnRbMV0pLnByb3BlcnRpZXMuZGlzdCA8PSB0b2xlcmFuY2UpIHtcbiAgICAgICAgICAgICAgICAgICAgZG9lc092ZXJsYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBzZWdtZW50KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBzZWdtZW50O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICgodG9sZXJhbmNlID09PSAwKSA/XG4gICAgICAgICAgICAgICAgICAgIGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmRzTWF0Y2hbMF0sIHNlZ21lbnQpICYmIGJvb2xlYW5fcG9pbnRfb25fbGluZV8xLmRlZmF1bHQoY29vcmRzTWF0Y2hbMV0sIHNlZ21lbnQpIDpcbiAgICAgICAgICAgICAgICAgICAgbmVhcmVzdF9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChzZWdtZW50LCBjb29yZHNNYXRjaFswXSkucHJvcGVydGllcy5kaXN0IDw9IHRvbGVyYW5jZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgbmVhcmVzdF9wb2ludF9vbl9saW5lXzEuZGVmYXVsdChzZWdtZW50LCBjb29yZHNNYXRjaFsxXSkucHJvcGVydGllcy5kaXN0IDw9IHRvbGVyYW5jZSkge1xuICAgICAgICAgICAgICAgICAgICAvLyBEbyBub3QgZGVmaW5lIChkb2VzT3ZlcmxhcCA9IHRydWUpIHNpbmNlIG1vcmUgbWF0Y2hlcyBjYW4gb2NjdXIgd2l0aGluIHRoZSBzYW1lIHNlZ21lbnRcbiAgICAgICAgICAgICAgICAgICAgLy8gZG9lc092ZXJsYXBzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG92ZXJsYXBTZWdtZW50KVxuICAgICAgICAgICAgICAgICAgICAgICAgb3ZlcmxhcFNlZ21lbnQgPSBjb25jYXRTZWdtZW50KG92ZXJsYXBTZWdtZW50LCBtYXRjaCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIG92ZXJsYXBTZWdtZW50ID0gbWF0Y2g7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gU2VnbWVudCBkb2Vzbid0IG92ZXJsYXAgLSBhZGQgb3ZlcmxhcHMgdG8gcmVzdWx0cyAmIHJlc2V0XG4gICAgICAgIGlmIChkb2VzT3ZlcmxhcHMgPT09IGZhbHNlICYmIG92ZXJsYXBTZWdtZW50KSB7XG4gICAgICAgICAgICBmZWF0dXJlcy5wdXNoKG92ZXJsYXBTZWdtZW50KTtcbiAgICAgICAgICAgIG92ZXJsYXBTZWdtZW50ID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgLy8gQWRkIGxhc3Qgc2VnbWVudCBpZiBleGlzdHNcbiAgICBpZiAob3ZlcmxhcFNlZ21lbnQpXG4gICAgICAgIGZlYXR1cmVzLnB1c2gob3ZlcmxhcFNlZ21lbnQpO1xuICAgIHJldHVybiBoZWxwZXJzXzEuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xufVxuLyoqXG4gKiBDb25jYXQgU2VnbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgTGluZVN0cmluZ1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBzZWdtZW50IDItdmVydGV4IExpbmVTdHJpbmdcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjb25jYXQgbGluZXN0cmluZ1xuICovXG5mdW5jdGlvbiBjb25jYXRTZWdtZW50KGxpbmUsIHNlZ21lbnQpIHtcbiAgICB2YXIgY29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKHNlZ21lbnQpO1xuICAgIHZhciBsaW5lQ29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGxpbmUpO1xuICAgIHZhciBzdGFydCA9IGxpbmVDb29yZHNbMF07XG4gICAgdmFyIGVuZCA9IGxpbmVDb29yZHNbbGluZUNvb3Jkcy5sZW5ndGggLSAxXTtcbiAgICB2YXIgZ2VvbSA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgaWYgKGVxdWFsKGNvb3Jkc1swXSwgc3RhcnQpKVxuICAgICAgICBnZW9tLnVuc2hpZnQoY29vcmRzWzFdKTtcbiAgICBlbHNlIGlmIChlcXVhbChjb29yZHNbMF0sIGVuZCkpXG4gICAgICAgIGdlb20ucHVzaChjb29yZHNbMV0pO1xuICAgIGVsc2UgaWYgKGVxdWFsKGNvb3Jkc1sxXSwgc3RhcnQpKVxuICAgICAgICBnZW9tLnVuc2hpZnQoY29vcmRzWzBdKTtcbiAgICBlbHNlIGlmIChlcXVhbChjb29yZHNbMV0sIGVuZCkpXG4gICAgICAgIGdlb20ucHVzaChjb29yZHNbMF0pO1xuICAgIHJldHVybiBsaW5lO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gbGluZU92ZXJsYXA7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBoZWxwZXJzXzEgPSByZXF1aXJlKFwiQHR1cmYvaGVscGVyc1wiKTtcbnZhciBpbnZhcmlhbnRfMSA9IHJlcXVpcmUoXCJAdHVyZi9pbnZhcmlhbnRcIik7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb259IG9mIDItdmVydGV4IHtAbGluayBMaW5lU3RyaW5nfSBzZWdtZW50cyBmcm9tIGFcbiAqIHtAbGluayBMaW5lU3RyaW5nfChNdWx0aSlMaW5lU3RyaW5nfSBvciB7QGxpbmsgUG9seWdvbnwoTXVsdGkpUG9seWdvbn0uXG4gKlxuICogQG5hbWUgbGluZVNlZ21lbnRcbiAqIEBwYXJhbSB7R2VvSlNPTn0gZ2VvanNvbiBHZW9KU09OIFBvbHlnb24gb3IgTGluZVN0cmluZ1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPExpbmVTdHJpbmc+fSAyLXZlcnRleCBsaW5lIHNlZ21lbnRzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICogdmFyIHNlZ21lbnRzID0gdHVyZi5saW5lU2VnbWVudChwb2x5Z29uKTtcbiAqXG4gKiAvL2FkZFRvTWFwXG4gKiB2YXIgYWRkVG9NYXAgPSBbcG9seWdvbiwgc2VnbWVudHNdXG4gKi9cbmZ1bmN0aW9uIGxpbmVTZWdtZW50KGdlb2pzb24pIHtcbiAgICBpZiAoIWdlb2pzb24pIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiZ2VvanNvbiBpcyByZXF1aXJlZFwiKTtcbiAgICB9XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBtZXRhXzEuZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgbGluZVNlZ21lbnRGZWF0dXJlKGZlYXR1cmUsIHJlc3VsdHMpO1xuICAgIH0pO1xuICAgIHJldHVybiBoZWxwZXJzXzEuZmVhdHVyZUNvbGxlY3Rpb24ocmVzdWx0cyk7XG59XG4vKipcbiAqIExpbmUgU2VnbWVudFxuICpcbiAqIEBwcml2YXRlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29uPn0gZ2VvanNvbiBMaW5lIG9yIHBvbHlnb24gZmVhdHVyZVxuICogQHBhcmFtIHtBcnJheX0gcmVzdWx0cyBwdXNoIHRvIHJlc3VsdHNcbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5mdW5jdGlvbiBsaW5lU2VnbWVudEZlYXR1cmUoZ2VvanNvbiwgcmVzdWx0cykge1xuICAgIHZhciBjb29yZHMgPSBbXTtcbiAgICB2YXIgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgIGlmIChnZW9tZXRyeSAhPT0gbnVsbCkge1xuICAgICAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJQb2x5Z29uXCI6XG4gICAgICAgICAgICAgICAgY29vcmRzID0gaW52YXJpYW50XzEuZ2V0Q29vcmRzKGdlb21ldHJ5KTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJMaW5lU3RyaW5nXCI6XG4gICAgICAgICAgICAgICAgY29vcmRzID0gW2ludmFyaWFudF8xLmdldENvb3JkcyhnZW9tZXRyeSldO1xuICAgICAgICB9XG4gICAgICAgIGNvb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgdmFyIHNlZ21lbnRzID0gY3JlYXRlU2VnbWVudHMoY29vcmQsIGdlb2pzb24ucHJvcGVydGllcyk7XG4gICAgICAgICAgICBzZWdtZW50cy5mb3JFYWNoKGZ1bmN0aW9uIChzZWdtZW50KSB7XG4gICAgICAgICAgICAgICAgc2VnbWVudC5pZCA9IHJlc3VsdHMubGVuZ3RoO1xuICAgICAgICAgICAgICAgIHJlc3VsdHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4vKipcbiAqIENyZWF0ZSBTZWdtZW50cyBmcm9tIExpbmVTdHJpbmcgY29vcmRpbmF0ZXNcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRzIExpbmVTdHJpbmcgY29vcmRpbmF0ZXNcbiAqIEBwYXJhbSB7Kn0gcHJvcGVydGllcyBHZW9KU09OIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtBcnJheTxGZWF0dXJlPExpbmVTdHJpbmc+Pn0gbGluZSBzZWdtZW50c1xuICovXG5mdW5jdGlvbiBjcmVhdGVTZWdtZW50cyhjb29yZHMsIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgc2VnbWVudHMgPSBbXTtcbiAgICBjb29yZHMucmVkdWNlKGZ1bmN0aW9uIChwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3Jkcykge1xuICAgICAgICB2YXIgc2VnbWVudCA9IGhlbHBlcnNfMS5saW5lU3RyaW5nKFtwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3Jkc10sIHByb3BlcnRpZXMpO1xuICAgICAgICBzZWdtZW50LmJib3ggPSBiYm94KHByZXZpb3VzQ29vcmRzLCBjdXJyZW50Q29vcmRzKTtcbiAgICAgICAgc2VnbWVudHMucHVzaChzZWdtZW50KTtcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRDb29yZHM7XG4gICAgfSk7XG4gICAgcmV0dXJuIHNlZ21lbnRzO1xufVxuLyoqXG4gKiBDcmVhdGUgQkJveCBiZXR3ZWVuIHR3byBjb29yZGluYXRlcyAoZmFzdGVyIHRoYW4gQHR1cmYvYmJveClcbiAqXG4gKiBAcHJpdmF0ZVxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjb29yZHMxIFBvaW50IGNvb3JkaW5hdGVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY29vcmRzMiBQb2ludCBjb29yZGluYXRlXG4gKiBAcmV0dXJucyB7QkJveH0gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF1cbiAqL1xuZnVuY3Rpb24gYmJveChjb29yZHMxLCBjb29yZHMyKSB7XG4gICAgdmFyIHgxID0gY29vcmRzMVswXTtcbiAgICB2YXIgeTEgPSBjb29yZHMxWzFdO1xuICAgIHZhciB4MiA9IGNvb3JkczJbMF07XG4gICAgdmFyIHkyID0gY29vcmRzMlsxXTtcbiAgICB2YXIgd2VzdCA9ICh4MSA8IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIHNvdXRoID0gKHkxIDwgeTIpID8geTEgOiB5MjtcbiAgICB2YXIgZWFzdCA9ICh4MSA+IHgyKSA/IHgxIDogeDI7XG4gICAgdmFyIG5vcnRoID0gKHkxID4geTIpID8geTEgOiB5MjtcbiAgICByZXR1cm4gW3dlc3QsIHNvdXRoLCBlYXN0LCBub3J0aF07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBsaW5lU2VnbWVudDtcbiIsIid1c2Ugc3RyaWN0JztcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCdAdHVyZi9oZWxwZXJzJyk7XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkRWFjaFxuICpcbiAqIEBjYWxsYmFjayBjb29yZEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBjdXJyZW50Q29vcmQgVGhlIGN1cnJlbnQgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gY29vcmRJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgY29vcmRpbmF0ZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZ2VvbWV0cnlJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgR2VvbWV0cnkgYmVpbmcgcHJvY2Vzc2VkLlxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIGNvb3JkaW5hdGVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBjb29yZEVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtcImZvb1wiOiBcImJhclwifSksXG4gKiAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtcImhlbGxvXCI6IFwid29ybGRcIn0pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmNvb3JkRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1jdXJyZW50Q29vcmRcbiAqICAgLy89Y29vcmRJbmRleFxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89Z2VvbWV0cnlJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGNvb3JkRWFjaChnZW9qc29uLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAgIC8vIEhhbmRsZXMgbnVsbCBHZW9tZXRyeSAtLSBTa2lwcyB0aGlzIEdlb0pTT05cbiAgICBpZiAoZ2VvanNvbiA9PT0gbnVsbCkgcmV0dXJuO1xuICAgIHZhciBqLCBrLCBsLCBnZW9tZXRyeSwgc3RvcEcsIGNvb3JkcyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIHdyYXBTaHJpbmsgPSAwLFxuICAgICAgICBjb29yZEluZGV4ID0gMCxcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24sXG4gICAgICAgIHR5cGUgPSBnZW9qc29uLnR5cGUsXG4gICAgICAgIGlzRmVhdHVyZUNvbGxlY3Rpb24gPSB0eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBpc0ZlYXR1cmUgPSB0eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gICAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gICAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAgIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gICAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKHZhciBmZWF0dXJlSW5kZXggPSAwOyBmZWF0dXJlSW5kZXggPCBzdG9wOyBmZWF0dXJlSW5kZXgrKykge1xuICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbiA9IChpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5IDpcbiAgICAgICAgICAgIChpc0ZlYXR1cmUgPyBnZW9qc29uLmdlb21ldHJ5IDogZ2VvanNvbikpO1xuICAgICAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbiA9IChnZW9tZXRyeU1heWJlQ29sbGVjdGlvbikgPyBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJyA6IGZhbHNlO1xuICAgICAgICBzdG9wRyA9IGlzR2VvbWV0cnlDb2xsZWN0aW9uID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllcy5sZW5ndGggOiAxO1xuXG4gICAgICAgIGZvciAodmFyIGdlb21JbmRleCA9IDA7IGdlb21JbmRleCA8IHN0b3BHOyBnZW9tSW5kZXgrKykge1xuICAgICAgICAgICAgdmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDtcbiAgICAgICAgICAgIHZhciBnZW9tZXRyeUluZGV4ID0gMDtcbiAgICAgICAgICAgIGdlb21ldHJ5ID0gaXNHZW9tZXRyeUNvbGxlY3Rpb24gP1xuICAgICAgICAgICAgICAgIGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXNbZ2VvbUluZGV4XSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGVzIG51bGwgR2VvbWV0cnkgLS0gU2tpcHMgdGhpcyBnZW9tZXRyeVxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSBjb250aW51ZTtcbiAgICAgICAgICAgIGNvb3JkcyA9IGdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICAgICAgdmFyIGdlb21UeXBlID0gZ2VvbWV0cnkudHlwZTtcblxuICAgICAgICAgICAgd3JhcFNocmluayA9IChleGNsdWRlV3JhcENvb3JkICYmIChnZW9tVHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21UeXBlID09PSAnTXVsdGlQb2x5Z29uJykpID8gMSA6IDA7XG5cbiAgICAgICAgICAgIHN3aXRjaCAoZ2VvbVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgbnVsbDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY2FsbGJhY2soY29vcmRzW2pdLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZ2VvbVR5cGUgPT09ICdNdWx0aVBvaW50JykgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnTGluZVN0cmluZycpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGsgPSAwOyBrIDwgY29vcmRzW2pdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGsrKykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZEluZGV4Kys7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykgbXVsdGlGZWF0dXJlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnUG9seWdvbicpIGdlb21ldHJ5SW5kZXgrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGdlb21UeXBlID09PSAnUG9seWdvbicpIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAobCA9IDA7IGwgPCBjb29yZHNbal1ba10ubGVuZ3RoIC0gd3JhcFNocmluazsgbCsrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGNvb3Jkc1tqXVtrXVtsXSwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29vcmRJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZ2VvbWV0cnlJbmRleCsrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIG11bHRpRmVhdHVyZUluZGV4Kys7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnR2VvbWV0cnlDb2xsZWN0aW9uJzpcbiAgICAgICAgICAgICAgICBmb3IgKGogPSAwOyBqIDwgZ2VvbWV0cnkuZ2VvbWV0cmllcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNvb3JkRWFjaChnZW9tZXRyeS5nZW9tZXRyaWVzW2pdLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBHZW9tZXRyeSBUeXBlJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGNvb3JkUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgY29vcmRSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gY3VycmVudENvb3JkIFRoZSBjdXJyZW50IGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGNvb3JkSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIGNvb3JkaW5hdGUgYmVpbmcgcHJvY2Vzc2VkLlxuICogU3RhcnRzIGF0IGluZGV4IDAsIGlmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCwgYW5kIGF0IGluZGV4IDEgb3RoZXJ3aXNlLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gbXVsdGlGZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIE11bHRpLUZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKClcbiAqXG4gKiBAbmFtZSBjb29yZFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxHZW9tZXRyeXxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudENvb3JkLCBjb29yZEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEBwYXJhbSB7Ym9vbGVhbn0gW2V4Y2x1ZGVXcmFwQ29vcmQ9ZmFsc2VdIHdoZXRoZXIgb3Igbm90IHRvIGluY2x1ZGUgdGhlIGZpbmFsIGNvb3JkaW5hdGUgb2YgTGluZWFyUmluZ3MgdGhhdCB3cmFwcyB0aGUgcmluZyBpbiBpdHMgaXRlcmF0aW9uLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5jb29yZFJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRDb29yZCwgY29vcmRJbmRleCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRDb29yZFxuICogICAvLz1jb29yZEluZGV4XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50Q29vcmQ7XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSwgZXhjbHVkZVdyYXBDb29yZCkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGNvb3JkRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudENvb3JkLCBjb29yZEluZGV4LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAgIGlmIChjb29yZEluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudENvb3JkO1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpO1xuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBwcm9wRWFjaFxuICpcbiAqIEBjYWxsYmFjayBwcm9wRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge09iamVjdH0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBwcm9wRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICAgIHR1cmYucG9pbnQoWzI2LCAzN10sIHtmb286ICdiYXInfSksXG4gKiAgICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYucHJvcEVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50UHJvcGVydGllcywgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHByb3BFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZ2VvanNvbi5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLCBpKSA9PT0gZmFsc2UpIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICBjYWxsYmFjayhnZW9qc29uLnByb3BlcnRpZXMsIDApO1xuICAgICAgICBicmVhaztcbiAgICB9XG59XG5cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgcHJvcFJlZHVjZVxuICpcbiAqIFRoZSBmaXJzdCB0aW1lIHRoZSBjYWxsYmFjayBmdW5jdGlvbiBpcyBjYWxsZWQsIHRoZSB2YWx1ZXMgcHJvdmlkZWQgYXMgYXJndW1lbnRzIGRlcGVuZFxuICogb24gd2hldGhlciB0aGUgcmVkdWNlIG1ldGhvZCBoYXMgYW4gaW5pdGlhbFZhbHVlIGFyZ3VtZW50LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBwcm92aWRlZCB0byB0aGUgcmVkdWNlIG1ldGhvZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIGluaXRpYWxWYWx1ZS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIElmIGFuIGluaXRpYWxWYWx1ZSBpcyBub3QgcHJvdmlkZWQ6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgc2Vjb25kIGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogQGNhbGxiYWNrIHByb3BSZWR1Y2VDYWxsYmFja1xuICogQHBhcmFtIHsqfSBwcmV2aW91c1ZhbHVlIFRoZSBhY2N1bXVsYXRlZCB2YWx1ZSBwcmV2aW91c2x5IHJldHVybmVkIGluIHRoZSBsYXN0IGludm9jYXRpb25cbiAqIG9mIHRoZSBjYWxsYmFjaywgb3IgaW5pdGlhbFZhbHVlLCBpZiBzdXBwbGllZC5cbiAqIEBwYXJhbSB7Kn0gY3VycmVudFByb3BlcnRpZXMgVGhlIGN1cnJlbnQgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBwcm9wZXJ0aWVzIGluIGFueSBHZW9KU09OIG9iamVjdCBpbnRvIGEgc2luZ2xlIHZhbHVlLFxuICogc2ltaWxhciB0byBob3cgQXJyYXkucmVkdWNlIHdvcmtzLiBIb3dldmVyLCBpbiB0aGlzIGNhc2Ugd2UgbGF6aWx5IHJ1blxuICogdGhlIHJlZHVjdGlvbiwgc28gYW4gYXJyYXkgb2YgYWxsIHByb3BlcnRpZXMgaXMgdW5uZWNlc3NhcnkuXG4gKlxuICogQG5hbWUgcHJvcFJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleClcbiAqIEBwYXJhbSB7Kn0gW2luaXRpYWxWYWx1ZV0gVmFsdWUgdG8gdXNlIGFzIHRoZSBmaXJzdCBhcmd1bWVudCB0byB0aGUgZmlyc3QgY2FsbCBvZiB0aGUgY2FsbGJhY2suXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHZhbHVlIHRoYXQgcmVzdWx0cyBmcm9tIHRoZSByZWR1Y3Rpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5wcm9wUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudFByb3BlcnRpZXNcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBwcm9wRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudFByb3BlcnRpZXMsIGZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudFByb3BlcnRpZXM7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRQcm9wZXJ0aWVzLCBmZWF0dXJlSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmZWF0dXJlRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmU8YW55Pn0gY3VycmVudEZlYXR1cmUgVGhlIGN1cnJlbnQgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmZWF0dXJlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQG5hbWUgZmVhdHVyZUVhY2hcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcmV0dXJucyB7dm9pZH1cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgdHVyZi5wb2ludChbMzYsIDUzXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmVhdHVyZUVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZlYXR1cmVFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgaWYgKGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNhbGxiYWNrKGdlb2pzb24sIDApO1xuICAgIH0gZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb2pzb24uZmVhdHVyZXNbaV0sIGkpID09PSBmYWxzZSkgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGZlYXR1cmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBmZWF0dXJlUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWQuXG4gKi9cblxuLyoqXG4gKiBSZWR1Y2UgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZlYXR1cmVSZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7XCJmb29cIjogXCJiYXJcIn0pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7XCJoZWxsb1wiOiBcIndvcmxkXCJ9KVxuICogXSk7XG4gKlxuICogdHVyZi5mZWF0dXJlUmVkdWNlKGZlYXR1cmVzLCBmdW5jdGlvbiAocHJldmlvdXNWYWx1ZSwgY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRGZWF0dXJlXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICByZXR1cm4gY3VycmVudEZlYXR1cmVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlUmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICBmZWF0dXJlRWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY3VycmVudEZlYXR1cmUsIGZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIEdldCBhbGwgY29vcmRpbmF0ZXMgZnJvbSBhbnkgR2VvSlNPTiBvYmplY3QuXG4gKlxuICogQG5hbWUgY29vcmRBbGxcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEByZXR1cm5zIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZSBwb3NpdGlvbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oW1xuICogICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdmFyIGNvb3JkcyA9IHR1cmYuY29vcmRBbGwoZmVhdHVyZXMpO1xuICogLy89IFtbMjYsIDM3XSwgWzM2LCA1M11dXG4gKi9cbmZ1bmN0aW9uIGNvb3JkQWxsKGdlb2pzb24pIHtcbiAgICB2YXIgY29vcmRzID0gW107XG4gICAgY29vcmRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBjb29yZHMucHVzaChjb29yZCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGNvb3Jkcztcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3IgZ2VvbUVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbUVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBlYWNoIGdlb21ldHJ5IGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5mb3JFYWNoKClcbiAqXG4gKiBAbmFtZSBnZW9tRWFjaFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAoY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gdHVyZi5mZWF0dXJlQ29sbGVjdGlvbihbXG4gKiAgICAgdHVyZi5wb2ludChbMjYsIDM3XSwge2ZvbzogJ2Jhcid9KSxcbiAqICAgICB0dXJmLnBvaW50KFszNiwgNTNdLCB7aGVsbG86ICd3b3JsZCd9KVxuICogXSk7XG4gKlxuICogdHVyZi5nZW9tRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGdlb21FYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgdmFyIGksIGosIGcsIGdlb21ldHJ5LCBzdG9wRyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIGlzR2VvbWV0cnlDb2xsZWN0aW9uLFxuICAgICAgICBmZWF0dXJlUHJvcGVydGllcyxcbiAgICAgICAgZmVhdHVyZUJCb3gsXG4gICAgICAgIGZlYXR1cmVJZCxcbiAgICAgICAgZmVhdHVyZUluZGV4ID0gMCxcbiAgICAgICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGdlb2pzb24udHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgaXNGZWF0dXJlID0gZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScsXG4gICAgICAgIHN0b3AgPSBpc0ZlYXR1cmVDb2xsZWN0aW9uID8gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gICAgLy8gVGhpcyBsb2dpYyBtYXkgbG9vayBhIGxpdHRsZSB3ZWlyZC4gVGhlIHJlYXNvbiB3aHkgaXQgaXMgdGhhdCB3YXlcbiAgICAvLyBpcyBiZWNhdXNlIGl0J3MgdHJ5aW5nIHRvIGJlIGZhc3QuIEdlb0pTT04gc3VwcG9ydHMgbXVsdGlwbGUga2luZHNcbiAgICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gICAgLy8gVGhpcyBmdW5jdGlvbiBoYXMgdGhlIHJlc3BvbnNpYmlsaXR5IG9mIGhhbmRsaW5nIGFsbCBvZiB0aGVtLCBhbmQgdGhhdFxuICAgIC8vIG1lYW5zIHRoYXQgc29tZSBvZiB0aGUgYGZvcmAgbG9vcHMgeW91IHNlZSBiZWxvdyBhY3R1YWxseSBqdXN0IGRvbid0IGFwcGx5XG4gICAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgICAvLyBQb2ludCBnZW9tZXRyeSwgdGhlbiBib3RoIGxvb3BzIGFyZSBzaG9ydC1jaXJjdWl0ZWQgYW5kIGFsbCB3ZSBkb1xuICAgIC8vIGlzIGdyYWR1YWxseSByZW5hbWUgdGhlIGlucHV0IHVudGlsIGl0J3MgY2FsbGVkICdnZW9tZXRyeScuXG4gICAgLy9cbiAgICAvLyBUaGlzIGFsc28gYWltcyB0byBhbGxvY2F0ZSBhcyBmZXcgcmVzb3VyY2VzIGFzIHBvc3NpYmxlOiBqdXN0IGFcbiAgICAvLyBmZXcgbnVtYmVycyBhbmQgYm9vbGVhbnMsIHJhdGhlciB0aGFuIGFueSB0ZW1wb3JhcnkgYXJyYXlzIGFzIHdvdWxkXG4gICAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG5cbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uZ2VvbWV0cnkgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uZ2VvbWV0cnkgOiBnZW9qc29uKSk7XG4gICAgICAgIGZlYXR1cmVQcm9wZXJ0aWVzID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24ucHJvcGVydGllcyA6IHt9KSk7XG4gICAgICAgIGZlYXR1cmVCQm94ID0gKGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBnZW9qc29uLmZlYXR1cmVzW2ldLmJib3ggOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uYmJveCA6IHVuZGVmaW5lZCkpO1xuICAgICAgICBmZWF0dXJlSWQgPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGdlb2pzb24uZmVhdHVyZXNbaV0uaWQgOlxuICAgICAgICAgICAgKGlzRmVhdHVyZSA/IGdlb2pzb24uaWQgOiB1bmRlZmluZWQpKTtcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSAoZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24pID8gZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24udHlwZSA9PT0gJ0dlb21ldHJ5Q29sbGVjdGlvbicgOiBmYWxzZTtcbiAgICAgICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/XG4gICAgICAgICAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24uZ2VvbWV0cmllc1tnXSA6IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uO1xuXG4gICAgICAgICAgICAvLyBIYW5kbGUgbnVsbCBHZW9tZXRyeVxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5ID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKG51bGwsIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChnZW9tZXRyeS50eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgICAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgY2FzZSAnTXVsdGlQb2x5Z29uJzoge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdHZW9tZXRyeUNvbGxlY3Rpb24nOiB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGdlb21ldHJ5Lmdlb21ldHJpZXMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNhbGxiYWNrKGdlb21ldHJ5Lmdlb21ldHJpZXNbal0sIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIEdlb21ldHJ5IFR5cGUnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGluY3JlYXNlIGBmZWF0dXJlSW5kZXhgIHBlciBlYWNoIGZlYXR1cmVcbiAgICAgICAgZmVhdHVyZUluZGV4Kys7XG4gICAgfVxufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBnZW9tUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZ2VvbVJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtHZW9tZXRyeX0gY3VycmVudEdlb21ldHJ5IFRoZSBjdXJyZW50IEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtPYmplY3R9IGZlYXR1cmVQcm9wZXJ0aWVzIFRoZSBjdXJyZW50IEZlYXR1cmUgUHJvcGVydGllcyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGZlYXR1cmVCQm94IFRoZSBjdXJyZW50IEZlYXR1cmUgQkJveCBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcnxzdHJpbmd9IGZlYXR1cmVJZCBUaGUgY3VycmVudCBGZWF0dXJlIElkIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBnZW9tZXRyeSBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkucmVkdWNlKCkuXG4gKlxuICogQG5hbWUgZ2VvbVJlZHVjZVxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudEdlb21ldHJ5LCBmZWF0dXJlSW5kZXgsIGZlYXR1cmVQcm9wZXJ0aWVzLCBmZWF0dXJlQkJveCwgZmVhdHVyZUlkKVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYucG9pbnQoWzM2LCA1M10sIHtoZWxsbzogJ3dvcmxkJ30pXG4gKiBdKTtcbiAqXG4gKiB0dXJmLmdlb21SZWR1Y2UoZmVhdHVyZXMsIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpIHtcbiAqICAgLy89cHJldmlvdXNWYWx1ZVxuICogICAvLz1jdXJyZW50R2VvbWV0cnlcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPWZlYXR1cmVQcm9wZXJ0aWVzXG4gKiAgIC8vPWZlYXR1cmVCQm94XG4gKiAgIC8vPWZlYXR1cmVJZFxuICogICByZXR1cm4gY3VycmVudEdlb21ldHJ5XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gZ2VvbVJlZHVjZShnZW9qc29uLCBjYWxsYmFjaywgaW5pdGlhbFZhbHVlKSB7XG4gICAgdmFyIHByZXZpb3VzVmFsdWUgPSBpbml0aWFsVmFsdWU7XG4gICAgZ2VvbUVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGN1cnJlbnRHZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBmZWF0dXJlUHJvcGVydGllcywgZmVhdHVyZUJCb3gsIGZlYXR1cmVJZCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEdlb21ldHJ5O1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50R2VvbWV0cnksIGZlYXR1cmVJbmRleCwgZmVhdHVyZVByb3BlcnRpZXMsIGZlYXR1cmVCQm94LCBmZWF0dXJlSWQpO1xuICAgIH0pO1xuICAgIHJldHVybiBwcmV2aW91c1ZhbHVlO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuRWFjaFxuICpcbiAqIEBjYWxsYmFjayBmbGF0dGVuRWFjaENhbGxiYWNrXG4gKiBAcGFyYW0ge0ZlYXR1cmV9IGN1cnJlbnRGZWF0dXJlIFRoZSBjdXJyZW50IGZsYXR0ZW5lZCBmZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5FYWNoXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleClcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlbkVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICogICAvLz1jdXJyZW50RmVhdHVyZVxuICogICAvLz1mZWF0dXJlSW5kZXhcbiAqICAgLy89bXVsdGlGZWF0dXJlSW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmbGF0dGVuRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAgIGdlb21FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChnZW9tZXRyeSwgZmVhdHVyZUluZGV4LCBwcm9wZXJ0aWVzLCBiYm94LCBpZCkge1xuICAgICAgICAvLyBDYWxsYmFjayBmb3Igc2luZ2xlIGdlb21ldHJ5XG4gICAgICAgIHZhciB0eXBlID0gKGdlb21ldHJ5ID09PSBudWxsKSA/IG51bGwgOiBnZW9tZXRyeS50eXBlO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSBudWxsOlxuICAgICAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhoZWxwZXJzLmZlYXR1cmUoZ2VvbWV0cnksIHByb3BlcnRpZXMsIHtiYm94OiBiYm94LCBpZDogaWR9KSwgZmVhdHVyZUluZGV4LCAwKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBnZW9tVHlwZTtcblxuICAgICAgICAvLyBDYWxsYmFjayBmb3IgbXVsdGktZ2VvbWV0cnlcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgJ011bHRpUG9pbnQnOlxuICAgICAgICAgICAgZ2VvbVR5cGUgPSAnUG9pbnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgICAgICBnZW9tVHlwZSA9ICdMaW5lU3RyaW5nJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgZ2VvbVR5cGUgPSAnUG9seWdvbic7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAodmFyIG11bHRpRmVhdHVyZUluZGV4ID0gMDsgbXVsdGlGZWF0dXJlSW5kZXggPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IG11bHRpRmVhdHVyZUluZGV4KyspIHtcbiAgICAgICAgICAgIHZhciBjb29yZGluYXRlID0gZ2VvbWV0cnkuY29vcmRpbmF0ZXNbbXVsdGlGZWF0dXJlSW5kZXhdO1xuICAgICAgICAgICAgdmFyIGdlb20gPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogZ2VvbVR5cGUsXG4gICAgICAgICAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soaGVscGVycy5mZWF0dXJlKGdlb20sIHByb3BlcnRpZXMpLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBmbGF0dGVuUmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgZmxhdHRlblJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlfSBjdXJyZW50RmVhdHVyZSBUaGUgY3VycmVudCBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSBmbGF0dGVuZWQgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpLlxuICpcbiAqIEBuYW1lIGZsYXR0ZW5SZWR1Y2VcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHsqfSBUaGUgdmFsdWUgdGhhdCByZXN1bHRzIGZyb20gdGhlIHJlZHVjdGlvbi5cbiAqIEBleGFtcGxlXG4gKiB2YXIgZmVhdHVyZXMgPSB0dXJmLmZlYXR1cmVDb2xsZWN0aW9uKFtcbiAqICAgICB0dXJmLnBvaW50KFsyNiwgMzddLCB7Zm9vOiAnYmFyJ30pLFxuICogICAgIHR1cmYubXVsdGlQb2ludChbWzQwLCAzMF0sIFszNiwgNTNdXSwge2hlbGxvOiAnd29ybGQnfSlcbiAqIF0pO1xuICpcbiAqIHR1cmYuZmxhdHRlblJlZHVjZShmZWF0dXJlcywgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KSB7XG4gKiAgIC8vPXByZXZpb3VzVmFsdWVcbiAqICAgLy89Y3VycmVudEZlYXR1cmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50RmVhdHVyZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGZsYXR0ZW5SZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGZsYXR0ZW5FYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50RmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIG11bHRpRmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudEZlYXR1cmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRGZWF0dXJlLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBDYWxsYmFjayBmb3Igc2VnbWVudEVhY2hcbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudEVhY2hDYWxsYmFja1xuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICovXG5cbi8qKlxuICogSXRlcmF0ZSBvdmVyIDItdmVydGV4IGxpbmUgc2VnbWVudCBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaCgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KVxuICogQHJldHVybnMge3ZvaWR9XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB0dXJmLnBvbHlnb24oW1tbLTUwLCA1XSwgWy00MCwgLTEwXSwgWy01MCwgLTEwXSwgWy00MCwgNV0sIFstNTAsIDVdXV0pO1xuICpcbiAqIC8vIEl0ZXJhdGUgb3ZlciBHZW9KU09OIGJ5IDItdmVydGV4IHNlZ21lbnRzXG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gKiAgIC8vPWN1cnJlbnRTZWdtZW50XG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIC8vPXNlZ21lbnRJbmRleFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciB0b3RhbCA9IDA7XG4gKiB0dXJmLnNlZ21lbnRFYWNoKHBvbHlnb24sIGZ1bmN0aW9uICgpIHtcbiAqICAgICB0b3RhbCsrO1xuICogfSk7XG4gKi9cbmZ1bmN0aW9uIHNlZ21lbnRFYWNoKGdlb2pzb24sIGNhbGxiYWNrKSB7XG4gICAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICAgICAgdmFyIHNlZ21lbnRJbmRleCA9IDA7XG5cbiAgICAgICAgLy8gRXhjbHVkZSBudWxsIEdlb21ldHJpZXNcbiAgICAgICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5KSByZXR1cm47XG4gICAgICAgIC8vIChNdWx0aSlQb2ludCBnZW9tZXRyaWVzIGRvIG5vdCBjb250YWluIHNlZ21lbnRzIHRoZXJlZm9yZSB0aGV5IGFyZSBpZ25vcmVkIGR1cmluZyB0aGlzIG9wZXJhdGlvbi5cbiAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgIGlmICh0eXBlID09PSAnUG9pbnQnIHx8IHR5cGUgPT09ICdNdWx0aVBvaW50JykgcmV0dXJuO1xuXG4gICAgICAgIC8vIEdlbmVyYXRlIDItdmVydGV4IGxpbmUgc2VnbWVudHNcbiAgICAgICAgdmFyIHByZXZpb3VzQ29vcmRzO1xuICAgICAgICB2YXIgcHJldmlvdXNGZWF0dXJlSW5kZXggPSAwO1xuICAgICAgICB2YXIgcHJldmlvdXNNdWx0aUluZGV4ID0gMDtcbiAgICAgICAgdmFyIHByZXZHZW9tSW5kZXggPSAwO1xuICAgICAgICBpZiAoY29vcmRFYWNoKGZlYXR1cmUsIGZ1bmN0aW9uIChjdXJyZW50Q29vcmQsIGNvb3JkSW5kZXgsIGZlYXR1cmVJbmRleENvb3JkLCBtdWx0aVBhcnRJbmRleENvb3JkLCBnZW9tZXRyeUluZGV4KSB7XG4gICAgICAgICAgICAvLyBTaW11bGF0aW5nIGEgbWV0YS5jb29yZFJlZHVjZSgpIHNpbmNlIGByZWR1Y2VgIG9wZXJhdGlvbnMgY2Fubm90IGJlIHN0b3BwZWQgYnkgcmV0dXJuaW5nIGBmYWxzZWBcbiAgICAgICAgICAgIGlmIChwcmV2aW91c0Nvb3JkcyA9PT0gdW5kZWZpbmVkIHx8IGZlYXR1cmVJbmRleCA+IHByZXZpb3VzRmVhdHVyZUluZGV4IHx8IG11bHRpUGFydEluZGV4Q29vcmQgPiBwcmV2aW91c011bHRpSW5kZXggfHwgZ2VvbWV0cnlJbmRleCA+IHByZXZHZW9tSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0Nvb3JkcyA9IGN1cnJlbnRDb29yZDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c0ZlYXR1cmVJbmRleCA9IGZlYXR1cmVJbmRleDtcbiAgICAgICAgICAgICAgICBwcmV2aW91c011bHRpSW5kZXggPSBtdWx0aVBhcnRJbmRleENvb3JkO1xuICAgICAgICAgICAgICAgIHByZXZHZW9tSW5kZXggPSBnZW9tZXRyeUluZGV4O1xuICAgICAgICAgICAgICAgIHNlZ21lbnRJbmRleCA9IDA7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGN1cnJlbnRTZWdtZW50ID0gaGVscGVycy5saW5lU3RyaW5nKFtwcmV2aW91c0Nvb3JkcywgY3VycmVudENvb3JkXSwgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICAgICAgICAgIGlmIChjYWxsYmFjayhjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIHNlZ21lbnRJbmRleCsrO1xuICAgICAgICAgICAgcHJldmlvdXNDb29yZHMgPSBjdXJyZW50Q29vcmQ7XG4gICAgICAgIH0pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIENhbGxiYWNrIGZvciBzZWdtZW50UmVkdWNlXG4gKlxuICogVGhlIGZpcnN0IHRpbWUgdGhlIGNhbGxiYWNrIGZ1bmN0aW9uIGlzIGNhbGxlZCwgdGhlIHZhbHVlcyBwcm92aWRlZCBhcyBhcmd1bWVudHMgZGVwZW5kXG4gKiBvbiB3aGV0aGVyIHRoZSByZWR1Y2UgbWV0aG9kIGhhcyBhbiBpbml0aWFsVmFsdWUgYXJndW1lbnQuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIHByb3ZpZGVkIHRvIHRoZSByZWR1Y2UgbWV0aG9kOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgaW5pdGlhbFZhbHVlLlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIGZpcnN0IGVsZW1lbnQgcHJlc2VudCBpbiB0aGUgYXJyYXkuXG4gKlxuICogSWYgYW4gaW5pdGlhbFZhbHVlIGlzIG5vdCBwcm92aWRlZDpcbiAqICAtIFRoZSBwcmV2aW91c1ZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqICAtIFRoZSBjdXJyZW50VmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBzZWNvbmQgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBAY2FsbGJhY2sgc2VnbWVudFJlZHVjZUNhbGxiYWNrXG4gKiBAcGFyYW0geyp9IHByZXZpb3VzVmFsdWUgVGhlIGFjY3VtdWxhdGVkIHZhbHVlIHByZXZpb3VzbHkgcmV0dXJuZWQgaW4gdGhlIGxhc3QgaW52b2NhdGlvblxuICogb2YgdGhlIGNhbGxiYWNrLCBvciBpbml0aWFsVmFsdWUsIGlmIHN1cHBsaWVkLlxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJyZW50U2VnbWVudCBUaGUgY3VycmVudCBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBmZWF0dXJlSW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEZlYXR1cmUgYmVpbmcgcHJvY2Vzc2VkLlxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZC5cbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gc2VnbWVudEluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBTZWdtZW50IGJlaW5nIHByb2Nlc3NlZC5cbiAqL1xuXG4vKipcbiAqIFJlZHVjZSAyLXZlcnRleCBsaW5lIHNlZ21lbnQgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvIEFycmF5LnJlZHVjZSgpXG4gKiAoTXVsdGkpUG9pbnQgZ2VvbWV0cmllcyBkbyBub3QgY29udGFpbiBzZWdtZW50cyB0aGVyZWZvcmUgdGhleSBhcmUgaWdub3JlZCBkdXJpbmcgdGhpcyBvcGVyYXRpb24uXG4gKlxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfEdlb21ldHJ5fSBnZW9qc29uIGFueSBHZW9KU09OXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgY3VycmVudEluZGV4KVxuICogQHBhcmFtIHsqfSBbaW5pdGlhbFZhbHVlXSBWYWx1ZSB0byB1c2UgYXMgdGhlIGZpcnN0IGFyZ3VtZW50IHRvIHRoZSBmaXJzdCBjYWxsIG9mIHRoZSBjYWxsYmFjay5cbiAqIEByZXR1cm5zIHt2b2lkfVxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5Z29uID0gdHVyZi5wb2x5Z29uKFtbWy01MCwgNV0sIFstNDAsIC0xMF0sIFstNTAsIC0xMF0sIFstNDAsIDVdLCBbLTUwLCA1XV1dKTtcbiAqXG4gKiAvLyBJdGVyYXRlIG92ZXIgR2VvSlNPTiBieSAyLXZlcnRleCBzZWdtZW50c1xuICogdHVyZi5zZWdtZW50UmVkdWNlKHBvbHlnb24sIGZ1bmN0aW9uIChwcmV2aW91c1NlZ21lbnQsIGN1cnJlbnRTZWdtZW50LCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4LCBzZWdtZW50SW5kZXgpIHtcbiAqICAgLy89IHByZXZpb3VzU2VnbWVudFxuICogICAvLz0gY3VycmVudFNlZ21lbnRcbiAqICAgLy89IGZlYXR1cmVJbmRleFxuICogICAvLz0gbXVsdGlGZWF0dXJlSW5kZXhcbiAqICAgLy89IGdlb21ldHJ5SW5kZXhcbiAqICAgLy89IHNlZ21lbnRJbmV4XG4gKiAgIHJldHVybiBjdXJyZW50U2VnbWVudFxuICogfSk7XG4gKlxuICogLy8gQ2FsY3VsYXRlIHRoZSB0b3RhbCBudW1iZXIgb2Ygc2VnbWVudHNcbiAqIHZhciBpbml0aWFsVmFsdWUgPSAwXG4gKiB2YXIgdG90YWwgPSB0dXJmLnNlZ21lbnRSZWR1Y2UocG9seWdvbiwgZnVuY3Rpb24gKHByZXZpb3VzVmFsdWUpIHtcbiAqICAgICBwcmV2aW91c1ZhbHVlKys7XG4gKiAgICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG4gKiB9LCBpbml0aWFsVmFsdWUpO1xuICovXG5mdW5jdGlvbiBzZWdtZW50UmVkdWNlKGdlb2pzb24sIGNhbGxiYWNrLCBpbml0aWFsVmFsdWUpIHtcbiAgICB2YXIgcHJldmlvdXNWYWx1ZSA9IGluaXRpYWxWYWx1ZTtcbiAgICB2YXIgc3RhcnRlZCA9IGZhbHNlO1xuICAgIHNlZ21lbnRFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KSB7XG4gICAgICAgIGlmIChzdGFydGVkID09PSBmYWxzZSAmJiBpbml0aWFsVmFsdWUgPT09IHVuZGVmaW5lZCkgcHJldmlvdXNWYWx1ZSA9IGN1cnJlbnRTZWdtZW50O1xuICAgICAgICBlbHNlIHByZXZpb3VzVmFsdWUgPSBjYWxsYmFjayhwcmV2aW91c1ZhbHVlLCBjdXJyZW50U2VnbWVudCwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCwgc2VnbWVudEluZGV4KTtcbiAgICAgICAgc3RhcnRlZCA9IHRydWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHByZXZpb3VzVmFsdWU7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVFYWNoXG4gKlxuICogQGNhbGxiYWNrIGxpbmVFYWNoQ2FsbGJhY2tcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gY3VycmVudExpbmUgVGhlIGN1cnJlbnQgTGluZVN0cmluZ3xMaW5lYXJSaW5nIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aUZlYXR1cmVJbmRleCBUaGUgY3VycmVudCBpbmRleCBvZiB0aGUgTXVsdGktRmVhdHVyZSBiZWluZyBwcm9jZXNzZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSBnZW9tZXRyeUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBHZW9tZXRyeSBiZWluZyBwcm9jZXNzZWRcbiAqL1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBsaW5lIG9yIHJpbmcgY29vcmRpbmF0ZXMgaW4gTGluZVN0cmluZywgUG9seWdvbiwgTXVsdGlMaW5lU3RyaW5nLCBNdWx0aVBvbHlnb24gRmVhdHVyZXMgb3IgR2VvbWV0cmllcyxcbiAqIHNpbWlsYXIgdG8gQXJyYXkuZm9yRWFjaC5cbiAqXG4gKiBAbmFtZSBsaW5lRWFjaFxuICogQHBhcmFtIHtHZW9tZXRyeXxGZWF0dXJlPExpbmVTdHJpbmd8UG9seWdvbnxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29uPn0gZ2VvanNvbiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KVxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbXG4gKiAgIFtbMjYsIDM3XSwgWzM1LCA0NV1dLFxuICogICBbWzM2LCA1M10sIFszOCwgNTBdLCBbNDEsIDU1XV1cbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZUVhY2gobXVsdGlMaW5lLCBmdW5jdGlvbiAoY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpIHtcbiAqICAgLy89Y3VycmVudExpbmVcbiAqICAgLy89ZmVhdHVyZUluZGV4XG4gKiAgIC8vPW11bHRpRmVhdHVyZUluZGV4XG4gKiAgIC8vPWdlb21ldHJ5SW5kZXhcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBsaW5lRWFjaChnZW9qc29uLCBjYWxsYmFjaykge1xuICAgIC8vIHZhbGlkYXRpb25cbiAgICBpZiAoIWdlb2pzb24pIHRocm93IG5ldyBFcnJvcignZ2VvanNvbiBpcyByZXF1aXJlZCcpO1xuXG4gICAgZmxhdHRlbkVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGZlYXR1cmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgpIHtcbiAgICAgICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybjtcbiAgICAgICAgdmFyIHR5cGUgPSBmZWF0dXJlLmdlb21ldHJ5LnR5cGU7XG4gICAgICAgIHZhciBjb29yZHMgPSBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2soZmVhdHVyZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgMCwgMCkgPT09IGZhbHNlKSByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgICAgICBmb3IgKHZhciBnZW9tZXRyeUluZGV4ID0gMDsgZ2VvbWV0cnlJbmRleCA8IGNvb3Jkcy5sZW5ndGg7IGdlb21ldHJ5SW5kZXgrKykge1xuICAgICAgICAgICAgICAgIGlmIChjYWxsYmFjayhoZWxwZXJzLmxpbmVTdHJpbmcoY29vcmRzW2dlb21ldHJ5SW5kZXhdLCBmZWF0dXJlLnByb3BlcnRpZXMpLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5cbi8qKlxuICogQ2FsbGJhY2sgZm9yIGxpbmVSZWR1Y2VcbiAqXG4gKiBUaGUgZmlyc3QgdGltZSB0aGUgY2FsbGJhY2sgZnVuY3Rpb24gaXMgY2FsbGVkLCB0aGUgdmFsdWVzIHByb3ZpZGVkIGFzIGFyZ3VtZW50cyBkZXBlbmRcbiAqIG9uIHdoZXRoZXIgdGhlIHJlZHVjZSBtZXRob2QgaGFzIGFuIGluaXRpYWxWYWx1ZSBhcmd1bWVudC5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgcHJvdmlkZWQgdG8gdGhlIHJlZHVjZSBtZXRob2Q6XG4gKiAgLSBUaGUgcHJldmlvdXNWYWx1ZSBhcmd1bWVudCBpcyBpbml0aWFsVmFsdWUuXG4gKiAgLSBUaGUgY3VycmVudFZhbHVlIGFyZ3VtZW50IGlzIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgZWxlbWVudCBwcmVzZW50IGluIHRoZSBhcnJheS5cbiAqXG4gKiBJZiBhbiBpbml0aWFsVmFsdWUgaXMgbm90IHByb3ZpZGVkOlxuICogIC0gVGhlIHByZXZpb3VzVmFsdWUgYXJndW1lbnQgaXMgdGhlIHZhbHVlIG9mIHRoZSBmaXJzdCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICogIC0gVGhlIGN1cnJlbnRWYWx1ZSBhcmd1bWVudCBpcyB0aGUgdmFsdWUgb2YgdGhlIHNlY29uZCBlbGVtZW50IHByZXNlbnQgaW4gdGhlIGFycmF5LlxuICpcbiAqIEBjYWxsYmFjayBsaW5lUmVkdWNlQ2FsbGJhY2tcbiAqIEBwYXJhbSB7Kn0gcHJldmlvdXNWYWx1ZSBUaGUgYWNjdW11bGF0ZWQgdmFsdWUgcHJldmlvdXNseSByZXR1cm5lZCBpbiB0aGUgbGFzdCBpbnZvY2F0aW9uXG4gKiBvZiB0aGUgY2FsbGJhY2ssIG9yIGluaXRpYWxWYWx1ZSwgaWYgc3VwcGxpZWQuXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGN1cnJlbnRMaW5lIFRoZSBjdXJyZW50IExpbmVTdHJpbmd8TGluZWFyUmluZyBiZWluZyBwcm9jZXNzZWQuXG4gKiBAcGFyYW0ge251bWJlcn0gZmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBGZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IG11bHRpRmVhdHVyZUluZGV4IFRoZSBjdXJyZW50IGluZGV4IG9mIHRoZSBNdWx0aS1GZWF0dXJlIGJlaW5nIHByb2Nlc3NlZFxuICogQHBhcmFtIHtudW1iZXJ9IGdlb21ldHJ5SW5kZXggVGhlIGN1cnJlbnQgaW5kZXggb2YgdGhlIEdlb21ldHJ5IGJlaW5nIHByb2Nlc3NlZFxuICovXG5cbi8qKlxuICogUmVkdWNlIGZlYXR1cmVzIGluIGFueSBHZW9KU09OIG9iamVjdCwgc2ltaWxhciB0byBBcnJheS5yZWR1Y2UoKS5cbiAqXG4gKiBAbmFtZSBsaW5lUmVkdWNlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fEZlYXR1cmU8TGluZVN0cmluZ3xQb2x5Z29ufE11bHRpTGluZVN0cmluZ3xNdWx0aVBvbHlnb24+fSBnZW9qc29uIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAocHJldmlvdXNWYWx1ZSwgY3VycmVudExpbmUsIGZlYXR1cmVJbmRleCwgbXVsdGlGZWF0dXJlSW5kZXgsIGdlb21ldHJ5SW5kZXgpXG4gKiBAcGFyYW0geyp9IFtpbml0aWFsVmFsdWVdIFZhbHVlIHRvIHVzZSBhcyB0aGUgZmlyc3QgYXJndW1lbnQgdG8gdGhlIGZpcnN0IGNhbGwgb2YgdGhlIGNhbGxiYWNrLlxuICogQHJldHVybnMgeyp9IFRoZSB2YWx1ZSB0aGF0IHJlc3VsdHMgZnJvbSB0aGUgcmVkdWN0aW9uLlxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVBvbHkgPSB0dXJmLm11bHRpUG9seWdvbihbXG4gKiAgIHR1cmYucG9seWdvbihbW1sxMiw0OF0sWzIsNDFdLFsyNCwzOF0sWzEyLDQ4XV0sIFtbOSw0NF0sWzEzLDQxXSxbMTMsNDVdLFs5LDQ0XV1dKSxcbiAqICAgdHVyZi5wb2x5Z29uKFtbWzUsIDVdLCBbMCwgMF0sIFsyLCAyXSwgWzQsIDRdLCBbNSwgNV1dXSlcbiAqIF0pO1xuICpcbiAqIHR1cmYubGluZVJlZHVjZShtdWx0aVBvbHksIGZ1bmN0aW9uIChwcmV2aW91c1ZhbHVlLCBjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICogICAvLz1wcmV2aW91c1ZhbHVlXG4gKiAgIC8vPWN1cnJlbnRMaW5lXG4gKiAgIC8vPWZlYXR1cmVJbmRleFxuICogICAvLz1tdWx0aUZlYXR1cmVJbmRleFxuICogICAvLz1nZW9tZXRyeUluZGV4XG4gKiAgIHJldHVybiBjdXJyZW50TGluZVxuICogfSk7XG4gKi9cbmZ1bmN0aW9uIGxpbmVSZWR1Y2UoZ2VvanNvbiwgY2FsbGJhY2ssIGluaXRpYWxWYWx1ZSkge1xuICAgIHZhciBwcmV2aW91c1ZhbHVlID0gaW5pdGlhbFZhbHVlO1xuICAgIGxpbmVFYWNoKGdlb2pzb24sIGZ1bmN0aW9uIChjdXJyZW50TGluZSwgZmVhdHVyZUluZGV4LCBtdWx0aUZlYXR1cmVJbmRleCwgZ2VvbWV0cnlJbmRleCkge1xuICAgICAgICBpZiAoZmVhdHVyZUluZGV4ID09PSAwICYmIGluaXRpYWxWYWx1ZSA9PT0gdW5kZWZpbmVkKSBwcmV2aW91c1ZhbHVlID0gY3VycmVudExpbmU7XG4gICAgICAgIGVsc2UgcHJldmlvdXNWYWx1ZSA9IGNhbGxiYWNrKHByZXZpb3VzVmFsdWUsIGN1cnJlbnRMaW5lLCBmZWF0dXJlSW5kZXgsIG11bHRpRmVhdHVyZUluZGV4LCBnZW9tZXRyeUluZGV4KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcHJldmlvdXNWYWx1ZTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgMi12ZXJ0ZXggTGluZVN0cmluZyBTZWdtZW50IGZyb20gYSBHZW9KU09OIHVzaW5nIGBAdHVyZi9tZXRhYCBpbmRleGVzLlxuICpcbiAqIE5lZ2F0aXZlIGluZGV4ZXMgYXJlIHBlcm1pdHRlZC5cbiAqIFBvaW50ICYgTXVsdGlQb2ludCB3aWxsIGFsd2F5cyByZXR1cm4gbnVsbC5cbiAqXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufEZlYXR1cmV8R2VvbWV0cnl9IGdlb2pzb24gQW55IEdlb0pTT04gRmVhdHVyZSBvciBHZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZmVhdHVyZUluZGV4PTBdIEZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tdWx0aUZlYXR1cmVJbmRleD0wXSBNdWx0aS1GZWF0dXJlIEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuZ2VvbWV0cnlJbmRleD0wXSBHZW9tZXRyeSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnNlZ21lbnRJbmRleD0wXSBTZWdtZW50IEluZGV4XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnMucHJvcGVydGllcz17fV0gVHJhbnNsYXRlIFByb3BlcnRpZXMgdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QkJveH0gW29wdGlvbnMuYmJveD17fV0gVHJhbnNsYXRlIEJCb3ggdG8gb3V0cHV0IExpbmVTdHJpbmdcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgTGluZVN0cmluZ1xuICogQHJldHVybnMge0ZlYXR1cmU8TGluZVN0cmluZz59IDItdmVydGV4IEdlb0pTT04gRmVhdHVyZSBMaW5lU3RyaW5nXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFNlZ21lbnQobXVsdGlMaW5lKTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWzEwLCAxMF0sIFs1MCwgMzBdXT4+XG4gKlxuICogLy8gRmlyc3QgU2VnbWVudCBvZiAybmQgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogMX0pO1xuICogLy8gPT4gRmVhdHVyZTxMaW5lU3RyaW5nPFtbLTEwLCAtMTBdLCBbLTUwLCAtMzBdXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIExhc3QgTXVsdGkgRmVhdHVyZVxuICogdHVyZi5maW5kU2VnbWVudChtdWx0aUxpbmUsIHttdWx0aUZlYXR1cmVJbmRleDogLTEsIHNlZ21lbnRJbmRleDogLTF9KTtcbiAqIC8vID0+IEZlYXR1cmU8TGluZVN0cmluZzxbWy01MCwgLTMwXSwgWy0zMCwgLTQwXV0+PlxuICovXG5mdW5jdGlvbiBmaW5kU2VnbWVudChnZW9qc29uLCBvcHRpb25zKSB7XG4gICAgLy8gT3B0aW9uYWwgUGFyYW1ldGVyc1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIGlmICghaGVscGVycy5pc09iamVjdChvcHRpb25zKSkgdGhyb3cgbmV3IEVycm9yKCdvcHRpb25zIGlzIGludmFsaWQnKTtcbiAgICB2YXIgZmVhdHVyZUluZGV4ID0gb3B0aW9ucy5mZWF0dXJlSW5kZXggfHwgMDtcbiAgICB2YXIgbXVsdGlGZWF0dXJlSW5kZXggPSBvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4IHx8IDA7XG4gICAgdmFyIGdlb21ldHJ5SW5kZXggPSBvcHRpb25zLmdlb21ldHJ5SW5kZXggfHwgMDtcbiAgICB2YXIgc2VnbWVudEluZGV4ID0gb3B0aW9ucy5zZWdtZW50SW5kZXggfHwgMDtcblxuICAgIC8vIEZpbmQgRmVhdHVyZUluZGV4XG4gICAgdmFyIHByb3BlcnRpZXMgPSBvcHRpb25zLnByb3BlcnRpZXM7XG4gICAgdmFyIGdlb21ldHJ5O1xuXG4gICAgc3dpdGNoIChnZW9qc29uLnR5cGUpIHtcbiAgICBjYXNlICdGZWF0dXJlQ29sbGVjdGlvbic6XG4gICAgICAgIGlmIChmZWF0dXJlSW5kZXggPCAwKSBmZWF0dXJlSW5kZXggPSBnZW9qc29uLmZlYXR1cmVzLmxlbmd0aCArIGZlYXR1cmVJbmRleDtcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLnByb3BlcnRpZXM7XG4gICAgICAgIGdlb21ldHJ5ID0gZ2VvanNvbi5mZWF0dXJlc1tmZWF0dXJlSW5kZXhdLmdlb21ldHJ5O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdGZWF0dXJlJzpcbiAgICAgICAgcHJvcGVydGllcyA9IHByb3BlcnRpZXMgfHwgZ2VvanNvbi5wcm9wZXJ0aWVzO1xuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZ2VvbWV0cnk7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ1BvaW50JzpcbiAgICBjYXNlICdNdWx0aVBvaW50JzpcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgY2FzZSAnTXVsdGlMaW5lU3RyaW5nJzpcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb247XG4gICAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignZ2VvanNvbiBpcyBpbnZhbGlkJyk7XG4gICAgfVxuXG4gICAgLy8gRmluZCBTZWdtZW50SW5kZXhcbiAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzLmxlbmd0aCArIHNlZ21lbnRJbmRleCAtIDE7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLmxpbmVTdHJpbmcoW2Nvb3Jkc1tzZWdtZW50SW5kZXhdLCBjb29yZHNbc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdQb2x5Z29uJzpcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzLmxlbmd0aCArIGdlb21ldHJ5SW5kZXg7XG4gICAgICAgIGlmIChzZWdtZW50SW5kZXggPCAwKSBzZWdtZW50SW5kZXggPSBjb29yZHNbZ2VvbWV0cnlJbmRleF0ubGVuZ3RoICsgc2VnbWVudEluZGV4IC0gMTtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMubGluZVN0cmluZyhbY29vcmRzW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1tnZW9tZXRyeUluZGV4XVtzZWdtZW50SW5kZXggKyAxXV0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgICByZXR1cm4gaGVscGVycy5saW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoc2VnbWVudEluZGV4IDwgMCkgc2VnbWVudEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XVtnZW9tZXRyeUluZGV4XS5sZW5ndGggLSBzZWdtZW50SW5kZXggLSAxO1xuICAgICAgICByZXR1cm4gaGVscGVycy5saW5lU3RyaW5nKFtjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdW3NlZ21lbnRJbmRleF0sIGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bc2VnbWVudEluZGV4ICsgMV1dLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdnZW9qc29uIGlzIGludmFsaWQnKTtcbn1cblxuLyoqXG4gKiBGaW5kcyBhIHBhcnRpY3VsYXIgUG9pbnQgZnJvbSBhIEdlb0pTT04gdXNpbmcgYEB0dXJmL21ldGFgIGluZGV4ZXMuXG4gKlxuICogTmVnYXRpdmUgaW5kZXhlcyBhcmUgcGVybWl0dGVkLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZXxHZW9tZXRyeX0gZ2VvanNvbiBBbnkgR2VvSlNPTiBGZWF0dXJlIG9yIEdlb21ldHJ5XG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIE9wdGlvbmFsIHBhcmFtZXRlcnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5mZWF0dXJlSW5kZXg9MF0gRmVhdHVyZSBJbmRleFxuICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLm11bHRpRmVhdHVyZUluZGV4PTBdIE11bHRpLUZlYXR1cmUgSW5kZXhcbiAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5nZW9tZXRyeUluZGV4PTBdIEdlb21ldHJ5IEluZGV4XG4gKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuY29vcmRJbmRleD0wXSBDb29yZCBJbmRleFxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zLnByb3BlcnRpZXM9e31dIFRyYW5zbGF0ZSBQcm9wZXJ0aWVzIHRvIG91dHB1dCBQb2ludFxuICogQHBhcmFtIHtCQm94fSBbb3B0aW9ucy5iYm94PXt9XSBUcmFuc2xhdGUgQkJveCB0byBvdXRwdXQgUG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfHN0cmluZ30gW29wdGlvbnMuaWQ9e31dIFRyYW5zbGF0ZSBJZCB0byBvdXRwdXQgUG9pbnRcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gMi12ZXJ0ZXggR2VvSlNPTiBGZWF0dXJlIFBvaW50XG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpTGluZSA9IHR1cmYubXVsdGlMaW5lU3RyaW5nKFtcbiAqICAgICBbWzEwLCAxMF0sIFs1MCwgMzBdLCBbMzAsIDQwXV0sXG4gKiAgICAgW1stMTAsIC0xMF0sIFstNTAsIC0zMF0sIFstMzAsIC00MF1dXG4gKiBdKTtcbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IChkZWZhdWx0cyBhcmUgMClcbiAqIHR1cmYuZmluZFBvaW50KG11bHRpTGluZSk7XG4gKiAvLyA9PiBGZWF0dXJlPFBvaW50PFsxMCwgMTBdPj5cbiAqXG4gKiAvLyBGaXJzdCBTZWdtZW50IG9mIHRoZSAybmQgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IDF9KTtcbiAqIC8vID0+IEZlYXR1cmU8UG9pbnQ8Wy0xMCwgLTEwXT4+XG4gKlxuICogLy8gTGFzdCBTZWdtZW50IG9mIGxhc3QgTXVsdGktRmVhdHVyZVxuICogdHVyZi5maW5kUG9pbnQobXVsdGlMaW5lLCB7bXVsdGlGZWF0dXJlSW5kZXg6IC0xLCBjb29yZEluZGV4OiAtMX0pO1xuICogLy8gPT4gRmVhdHVyZTxQb2ludDxbLTMwLCAtNDBdPj5cbiAqL1xuZnVuY3Rpb24gZmluZFBvaW50KGdlb2pzb24sIG9wdGlvbnMpIHtcbiAgICAvLyBPcHRpb25hbCBQYXJhbWV0ZXJzXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgaWYgKCFoZWxwZXJzLmlzT2JqZWN0KG9wdGlvbnMpKSB0aHJvdyBuZXcgRXJyb3IoJ29wdGlvbnMgaXMgaW52YWxpZCcpO1xuICAgIHZhciBmZWF0dXJlSW5kZXggPSBvcHRpb25zLmZlYXR1cmVJbmRleCB8fCAwO1xuICAgIHZhciBtdWx0aUZlYXR1cmVJbmRleCA9IG9wdGlvbnMubXVsdGlGZWF0dXJlSW5kZXggfHwgMDtcbiAgICB2YXIgZ2VvbWV0cnlJbmRleCA9IG9wdGlvbnMuZ2VvbWV0cnlJbmRleCB8fCAwO1xuICAgIHZhciBjb29yZEluZGV4ID0gb3B0aW9ucy5jb29yZEluZGV4IHx8IDA7XG5cbiAgICAvLyBGaW5kIEZlYXR1cmVJbmRleFxuICAgIHZhciBwcm9wZXJ0aWVzID0gb3B0aW9ucy5wcm9wZXJ0aWVzO1xuICAgIHZhciBnZW9tZXRyeTtcblxuICAgIHN3aXRjaCAoZ2VvanNvbi50eXBlKSB7XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICBpZiAoZmVhdHVyZUluZGV4IDwgMCkgZmVhdHVyZUluZGV4ID0gZ2VvanNvbi5mZWF0dXJlcy5sZW5ndGggKyBmZWF0dXJlSW5kZXg7XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5wcm9wZXJ0aWVzO1xuICAgICAgICBnZW9tZXRyeSA9IGdlb2pzb24uZmVhdHVyZXNbZmVhdHVyZUluZGV4XS5nZW9tZXRyeTtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnRmVhdHVyZSc6XG4gICAgICAgIHByb3BlcnRpZXMgPSBwcm9wZXJ0aWVzIHx8IGdlb2pzb24ucHJvcGVydGllcztcbiAgICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uLmdlb21ldHJ5O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdQb2ludCc6XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgIGNhc2UgJ011bHRpTGluZVN0cmluZyc6XG4gICAgY2FzZSAnTXVsdGlQb2x5Z29uJzpcbiAgICAgICAgZ2VvbWV0cnkgPSBnZW9qc29uO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gaXMgaW52YWxpZCcpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgQ29vcmQgSW5kZXhcbiAgICBpZiAoZ2VvbWV0cnkgPT09IG51bGwpIHJldHVybiBudWxsO1xuICAgIHZhciBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICBzd2l0Y2ggKGdlb21ldHJ5LnR5cGUpIHtcbiAgICBjYXNlICdQb2ludCc6XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3JkcywgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGlmIChtdWx0aUZlYXR1cmVJbmRleCA8IDApIG11bHRpRmVhdHVyZUluZGV4ID0gY29vcmRzLmxlbmd0aCArIG11bHRpRmVhdHVyZUluZGV4O1xuICAgICAgICByZXR1cm4gaGVscGVycy5wb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdMaW5lU3RyaW5nJzpcbiAgICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzLmxlbmd0aCArIGNvb3JkSW5kZXg7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3Jkc1tjb29yZEluZGV4XSwgcHJvcGVydGllcywgb3B0aW9ucyk7XG4gICAgY2FzZSAnUG9seWdvbic6XG4gICAgICAgIGlmIChnZW9tZXRyeUluZGV4IDwgMCkgZ2VvbWV0cnlJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbZ2VvbWV0cnlJbmRleF0ubGVuZ3RoICsgY29vcmRJbmRleDtcbiAgICAgICAgcmV0dXJuIGhlbHBlcnMucG9pbnQoY29vcmRzW2dlb21ldHJ5SW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGNvb3JkSW5kZXggPCAwKSBjb29yZEluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBjb29yZEluZGV4O1xuICAgICAgICByZXR1cm4gaGVscGVycy5wb2ludChjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2Nvb3JkSW5kZXhdLCBwcm9wZXJ0aWVzLCBvcHRpb25zKTtcbiAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICBpZiAobXVsdGlGZWF0dXJlSW5kZXggPCAwKSBtdWx0aUZlYXR1cmVJbmRleCA9IGNvb3Jkcy5sZW5ndGggKyBtdWx0aUZlYXR1cmVJbmRleDtcbiAgICAgICAgaWYgKGdlb21ldHJ5SW5kZXggPCAwKSBnZW9tZXRyeUluZGV4ID0gY29vcmRzW211bHRpRmVhdHVyZUluZGV4XS5sZW5ndGggKyBnZW9tZXRyeUluZGV4O1xuICAgICAgICBpZiAoY29vcmRJbmRleCA8IDApIGNvb3JkSW5kZXggPSBjb29yZHNbbXVsdGlGZWF0dXJlSW5kZXhdW2dlb21ldHJ5SW5kZXhdLmxlbmd0aCAtIGNvb3JkSW5kZXg7XG4gICAgICAgIHJldHVybiBoZWxwZXJzLnBvaW50KGNvb3Jkc1ttdWx0aUZlYXR1cmVJbmRleF1bZ2VvbWV0cnlJbmRleF1bY29vcmRJbmRleF0sIHByb3BlcnRpZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2dlb2pzb24gaXMgaW52YWxpZCcpO1xufVxuXG5leHBvcnRzLmNvb3JkRWFjaCA9IGNvb3JkRWFjaDtcbmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcbmV4cG9ydHMucHJvcEVhY2ggPSBwcm9wRWFjaDtcbmV4cG9ydHMucHJvcFJlZHVjZSA9IHByb3BSZWR1Y2U7XG5leHBvcnRzLmZlYXR1cmVFYWNoID0gZmVhdHVyZUVhY2g7XG5leHBvcnRzLmZlYXR1cmVSZWR1Y2UgPSBmZWF0dXJlUmVkdWNlO1xuZXhwb3J0cy5jb29yZEFsbCA9IGNvb3JkQWxsO1xuZXhwb3J0cy5nZW9tRWFjaCA9IGdlb21FYWNoO1xuZXhwb3J0cy5nZW9tUmVkdWNlID0gZ2VvbVJlZHVjZTtcbmV4cG9ydHMuZmxhdHRlbkVhY2ggPSBmbGF0dGVuRWFjaDtcbmV4cG9ydHMuZmxhdHRlblJlZHVjZSA9IGZsYXR0ZW5SZWR1Y2U7XG5leHBvcnRzLnNlZ21lbnRFYWNoID0gc2VnbWVudEVhY2g7XG5leHBvcnRzLnNlZ21lbnRSZWR1Y2UgPSBzZWdtZW50UmVkdWNlO1xuZXhwb3J0cy5saW5lRWFjaCA9IGxpbmVFYWNoO1xuZXhwb3J0cy5saW5lUmVkdWNlID0gbGluZVJlZHVjZTtcbmV4cG9ydHMuZmluZFNlZ21lbnQgPSBmaW5kU2VnbWVudDtcbmV4cG9ydHMuZmluZFBvaW50ID0gZmluZFBvaW50O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgYmVhcmluZ18xID0gcmVxdWlyZShcIkB0dXJmL2JlYXJpbmdcIik7XG52YXIgZGlzdGFuY2VfMSA9IHJlcXVpcmUoXCJAdHVyZi9kaXN0YW5jZVwiKTtcbnZhciBkZXN0aW5hdGlvbl8xID0gcmVxdWlyZShcIkB0dXJmL2Rlc3RpbmF0aW9uXCIpO1xudmFyIGxpbmVfaW50ZXJzZWN0XzEgPSByZXF1aXJlKFwiQHR1cmYvbGluZS1pbnRlcnNlY3RcIik7XG52YXIgbWV0YV8xID0gcmVxdWlyZShcIkB0dXJmL21ldGFcIik7XG52YXIgaGVscGVyc18xID0gcmVxdWlyZShcIkB0dXJmL2hlbHBlcnNcIik7XG52YXIgaW52YXJpYW50XzEgPSByZXF1aXJlKFwiQHR1cmYvaW52YXJpYW50XCIpO1xuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGEge0BsaW5rIExpbmVTdHJpbmd9IGFuZCBjYWxjdWxhdGVzIHRoZSBjbG9zZXN0IFBvaW50IG9uIHRoZSAoTXVsdGkpTGluZVN0cmluZy5cbiAqXG4gKiBAbmFtZSBuZWFyZXN0UG9pbnRPbkxpbmVcbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxMaW5lU3RyaW5nfE11bHRpTGluZVN0cmluZz59IGxpbmVzIGxpbmVzIHRvIHNuYXAgdG9cbiAqIEBwYXJhbSB7R2VvbWV0cnl8RmVhdHVyZTxQb2ludD58bnVtYmVyW119IHB0IHBvaW50IHRvIHNuYXAgZnJvbVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSBPcHRpb25hbCBwYXJhbWV0ZXJzXG4gKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudW5pdHM9J2tpbG9tZXRlcnMnXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gY2xvc2VzdCBwb2ludCBvbiB0aGUgYGxpbmVgIHRvIGBwb2ludGAuIFRoZSBwcm9wZXJ0aWVzIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhyZWUgdmFsdWVzOiBgaW5kZXhgOiBjbG9zZXN0IHBvaW50IHdhcyBmb3VuZCBvbiBudGggbGluZSBwYXJ0LCBgZGlzdGA6IGRpc3RhbmNlIGJldHdlZW4gcHQgYW5kIHRoZSBjbG9zZXN0IHBvaW50LCBgbG9jYXRpb25gOiBkaXN0YW5jZSBhbG9uZyB0aGUgbGluZSBiZXR3ZWVuIHN0YXJ0IGFuZCB0aGUgY2xvc2VzdCBwb2ludC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHR1cmYubGluZVN0cmluZyhbXG4gKiAgICAgWy03Ny4wMzE2NjksIDM4Ljg3ODYwNV0sXG4gKiAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgWy03Ny4wMjU2NjEsIDM4Ljg4NTgyMV0sXG4gKiAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqIF0pO1xuICogdmFyIHB0ID0gdHVyZi5wb2ludChbLTc3LjAzNzA3NiwgMzguODg0MDE3XSk7XG4gKlxuICogdmFyIHNuYXBwZWQgPSB0dXJmLm5lYXJlc3RQb2ludE9uTGluZShsaW5lLCBwdCwge3VuaXRzOiAnbWlsZXMnfSk7XG4gKlxuICogLy9hZGRUb01hcFxuICogdmFyIGFkZFRvTWFwID0gW2xpbmUsIHB0LCBzbmFwcGVkXTtcbiAqIHNuYXBwZWQucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnIzAwZic7XG4gKi9cbmZ1bmN0aW9uIG5lYXJlc3RQb2ludE9uTGluZShsaW5lcywgcHQsIG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxuICAgIHZhciBjbG9zZXN0UHQgPSBoZWxwZXJzXzEucG9pbnQoW0luZmluaXR5LCBJbmZpbml0eV0sIHtcbiAgICAgICAgZGlzdDogSW5maW5pdHlcbiAgICB9KTtcbiAgICB2YXIgbGVuZ3RoID0gMC4wO1xuICAgIG1ldGFfMS5mbGF0dGVuRWFjaChsaW5lcywgZnVuY3Rpb24gKGxpbmUpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IGludmFyaWFudF8xLmdldENvb3JkcyhsaW5lKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgICAgICAvL3N0YXJ0XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBoZWxwZXJzXzEucG9pbnQoY29vcmRzW2ldKTtcbiAgICAgICAgICAgIHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlXzEuZGVmYXVsdChwdCwgc3RhcnQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy9zdG9wXG4gICAgICAgICAgICB2YXIgc3RvcF8xID0gaGVscGVyc18xLnBvaW50KGNvb3Jkc1tpICsgMV0pO1xuICAgICAgICAgICAgc3RvcF8xLnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlXzEuZGVmYXVsdChwdCwgc3RvcF8xLCBvcHRpb25zKTtcbiAgICAgICAgICAgIC8vIHNlY3Rpb25MZW5ndGhcbiAgICAgICAgICAgIHZhciBzZWN0aW9uTGVuZ3RoID0gZGlzdGFuY2VfMS5kZWZhdWx0KHN0YXJ0LCBzdG9wXzEsIG9wdGlvbnMpO1xuICAgICAgICAgICAgLy9wZXJwZW5kaWN1bGFyXG4gICAgICAgICAgICB2YXIgaGVpZ2h0RGlzdGFuY2UgPSBNYXRoLm1heChzdGFydC5wcm9wZXJ0aWVzLmRpc3QsIHN0b3BfMS5wcm9wZXJ0aWVzLmRpc3QpO1xuICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGJlYXJpbmdfMS5kZWZhdWx0KHN0YXJ0LCBzdG9wXzEpO1xuICAgICAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJQdDEgPSBkZXN0aW5hdGlvbl8xLmRlZmF1bHQocHQsIGhlaWdodERpc3RhbmNlLCBkaXJlY3Rpb24gKyA5MCwgb3B0aW9ucyk7XG4gICAgICAgICAgICB2YXIgcGVycGVuZGljdWxhclB0MiA9IGRlc3RpbmF0aW9uXzEuZGVmYXVsdChwdCwgaGVpZ2h0RGlzdGFuY2UsIGRpcmVjdGlvbiAtIDkwLCBvcHRpb25zKTtcbiAgICAgICAgICAgIHZhciBpbnRlcnNlY3QgPSBsaW5lX2ludGVyc2VjdF8xLmRlZmF1bHQoaGVscGVyc18xLmxpbmVTdHJpbmcoW3BlcnBlbmRpY3VsYXJQdDEuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHBlcnBlbmRpY3VsYXJQdDIuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdKSwgaGVscGVyc18xLmxpbmVTdHJpbmcoW3N0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLCBzdG9wXzEuZ2VvbWV0cnkuY29vcmRpbmF0ZXNdKSk7XG4gICAgICAgICAgICB2YXIgaW50ZXJzZWN0UHQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKGludGVyc2VjdC5mZWF0dXJlcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQgPSBpbnRlcnNlY3QuZmVhdHVyZXNbMF07XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0ID0gZGlzdGFuY2VfMS5kZWZhdWx0KHB0LCBpbnRlcnNlY3RQdCwgb3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5sb2NhdGlvbiA9IGxlbmd0aCArIGRpc3RhbmNlXzEuZGVmYXVsdChzdGFydCwgaW50ZXJzZWN0UHQsIG9wdGlvbnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXJ0LnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQgPSBzdGFydDtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMubG9jYXRpb24gPSBsZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RvcF8xLnByb3BlcnRpZXMuZGlzdCA8IGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmRpc3QpIHtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQgPSBzdG9wXzE7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFB0LnByb3BlcnRpZXMuaW5kZXggPSBpICsgMTtcbiAgICAgICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5sb2NhdGlvbiA9IGxlbmd0aCArIHNlY3Rpb25MZW5ndGg7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaW50ZXJzZWN0UHQgJiYgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0IDwgY2xvc2VzdFB0LnByb3BlcnRpZXMuZGlzdCkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQdCA9IGludGVyc2VjdFB0O1xuICAgICAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmluZGV4ID0gaTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVwZGF0ZSBsZW5ndGhcbiAgICAgICAgICAgIGxlbmd0aCArPSBzZWN0aW9uTGVuZ3RoO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNsb3Nlc3RQdDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IG5lYXJlc3RQb2ludE9uTGluZTtcbiIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGFmZmluZUh1bGxcblxudmFyIG9yaWVudCA9IHJlcXVpcmUoJ3JvYnVzdC1vcmllbnRhdGlvbicpXG5cbmZ1bmN0aW9uIGxpbmVhcmx5SW5kZXBlbmRlbnQocG9pbnRzLCBkKSB7XG4gIHZhciBuaHVsbCA9IG5ldyBBcnJheShkKzEpXG4gIGZvcih2YXIgaT0wOyBpPHBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIG5odWxsW2ldID0gcG9pbnRzW2ldXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8PXBvaW50cy5sZW5ndGg7ICsraSkge1xuICAgIGZvcih2YXIgaj1wb2ludHMubGVuZ3RoOyBqPD1kOyArK2opIHtcbiAgICAgIHZhciB4ID0gbmV3IEFycmF5KGQpXG4gICAgICBmb3IodmFyIGs9MDsgazxkOyArK2spIHtcbiAgICAgICAgeFtrXSA9IE1hdGgucG93KGorMS1pLCBrKVxuICAgICAgfVxuICAgICAgbmh1bGxbal0gPSB4XG4gICAgfVxuICAgIHZhciBvID0gb3JpZW50LmFwcGx5KHZvaWQgMCwgbmh1bGwpXG4gICAgaWYobykge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFmZmluZUh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgaWYobiA9PT0gMSkge1xuICAgIHJldHVybiBbMF1cbiAgfVxuICB2YXIgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgdmFyIGZyYW1lID0gWyBwb2ludHNbMF0gXVxuICB2YXIgaW5kZXggPSBbIDAgXVxuICBmb3IodmFyIGk9MTsgaTxuOyArK2kpIHtcbiAgICBmcmFtZS5wdXNoKHBvaW50c1tpXSlcbiAgICBpZighbGluZWFybHlJbmRlcGVuZGVudChmcmFtZSwgZCkpIHtcbiAgICAgIGZyYW1lLnBvcCgpXG4gICAgICBjb250aW51ZVxuICAgIH1cbiAgICBpbmRleC5wdXNoKGkpXG4gICAgaWYoaW5kZXgubGVuZ3RoID09PSBkKzEpIHtcbiAgICAgIHJldHVybiBpbmRleFxuICAgIH1cbiAgfVxuICByZXR1cm4gaW5kZXhcbn0iLCIvKipcbiAqIEJpdCB0d2lkZGxpbmcgaGFja3MgZm9yIEphdmFTY3JpcHQuXG4gKlxuICogQXV0aG9yOiBNaWtvbGEgTHlzZW5rb1xuICpcbiAqIFBvcnRlZCBmcm9tIFN0YW5mb3JkIGJpdCB0d2lkZGxpbmcgaGFjayBsaWJyYXJ5OlxuICogICAgaHR0cDovL2dyYXBoaWNzLnN0YW5mb3JkLmVkdS9+c2VhbmRlci9iaXRoYWNrcy5odG1sXG4gKi9cblxuXCJ1c2Ugc3RyaWN0XCI7IFwidXNlIHJlc3RyaWN0XCI7XG5cbi8vTnVtYmVyIG9mIGJpdHMgaW4gYW4gaW50ZWdlclxudmFyIElOVF9CSVRTID0gMzI7XG5cbi8vQ29uc3RhbnRzXG5leHBvcnRzLklOVF9CSVRTICA9IElOVF9CSVRTO1xuZXhwb3J0cy5JTlRfTUFYICAgPSAgMHg3ZmZmZmZmZjtcbmV4cG9ydHMuSU5UX01JTiAgID0gLTE8PChJTlRfQklUUy0xKTtcblxuLy9SZXR1cm5zIC0xLCAwLCArMSBkZXBlbmRpbmcgb24gc2lnbiBvZiB4XG5leHBvcnRzLnNpZ24gPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAodiA+IDApIC0gKHYgPCAwKTtcbn1cblxuLy9Db21wdXRlcyBhYnNvbHV0ZSB2YWx1ZSBvZiBpbnRlZ2VyXG5leHBvcnRzLmFicyA9IGZ1bmN0aW9uKHYpIHtcbiAgdmFyIG1hc2sgPSB2ID4+IChJTlRfQklUUy0xKTtcbiAgcmV0dXJuICh2IF4gbWFzaykgLSBtYXNrO1xufVxuXG4vL0NvbXB1dGVzIG1pbmltdW0gb2YgaW50ZWdlcnMgeCBhbmQgeVxuZXhwb3J0cy5taW4gPSBmdW5jdGlvbih4LCB5KSB7XG4gIHJldHVybiB5IF4gKCh4IF4geSkgJiAtKHggPCB5KSk7XG59XG5cbi8vQ29tcHV0ZXMgbWF4aW11bSBvZiBpbnRlZ2VycyB4IGFuZCB5XG5leHBvcnRzLm1heCA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgcmV0dXJuIHggXiAoKHggXiB5KSAmIC0oeCA8IHkpKTtcbn1cblxuLy9DaGVja3MgaWYgYSBudW1iZXIgaXMgYSBwb3dlciBvZiB0d29cbmV4cG9ydHMuaXNQb3cyID0gZnVuY3Rpb24odikge1xuICByZXR1cm4gISh2ICYgKHYtMSkpICYmICghIXYpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDIgb2YgdlxuZXhwb3J0cy5sb2cyID0gZnVuY3Rpb24odikge1xuICB2YXIgciwgc2hpZnQ7XG4gIHIgPSAgICAgKHYgPiAweEZGRkYpIDw8IDQ7IHYgPj4+PSByO1xuICBzaGlmdCA9ICh2ID4gMHhGRiAgKSA8PCAzOyB2ID4+Pj0gc2hpZnQ7IHIgfD0gc2hpZnQ7XG4gIHNoaWZ0ID0gKHYgPiAweEYgICApIDw8IDI7IHYgPj4+PSBzaGlmdDsgciB8PSBzaGlmdDtcbiAgc2hpZnQgPSAodiA+IDB4MyAgICkgPDwgMTsgdiA+Pj49IHNoaWZ0OyByIHw9IHNoaWZ0O1xuICByZXR1cm4gciB8ICh2ID4+IDEpO1xufVxuXG4vL0NvbXB1dGVzIGxvZyBiYXNlIDEwIG9mIHZcbmV4cG9ydHMubG9nMTAgPSBmdW5jdGlvbih2KSB7XG4gIHJldHVybiAgKHYgPj0gMTAwMDAwMDAwMCkgPyA5IDogKHYgPj0gMTAwMDAwMDAwKSA/IDggOiAodiA+PSAxMDAwMDAwMCkgPyA3IDpcbiAgICAgICAgICAodiA+PSAxMDAwMDAwKSA/IDYgOiAodiA+PSAxMDAwMDApID8gNSA6ICh2ID49IDEwMDAwKSA/IDQgOlxuICAgICAgICAgICh2ID49IDEwMDApID8gMyA6ICh2ID49IDEwMCkgPyAyIDogKHYgPj0gMTApID8gMSA6IDA7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiBiaXRzXG5leHBvcnRzLnBvcENvdW50ID0gZnVuY3Rpb24odikge1xuICB2ID0gdiAtICgodiA+Pj4gMSkgJiAweDU1NTU1NTU1KTtcbiAgdiA9ICh2ICYgMHgzMzMzMzMzMykgKyAoKHYgPj4+IDIpICYgMHgzMzMzMzMzMyk7XG4gIHJldHVybiAoKHYgKyAodiA+Pj4gNCkgJiAweEYwRjBGMEYpICogMHgxMDEwMTAxKSA+Pj4gMjQ7XG59XG5cbi8vQ291bnRzIG51bWJlciBvZiB0cmFpbGluZyB6ZXJvc1xuZnVuY3Rpb24gY291bnRUcmFpbGluZ1plcm9zKHYpIHtcbiAgdmFyIGMgPSAzMjtcbiAgdiAmPSAtdjtcbiAgaWYgKHYpIGMtLTtcbiAgaWYgKHYgJiAweDAwMDBGRkZGKSBjIC09IDE2O1xuICBpZiAodiAmIDB4MDBGRjAwRkYpIGMgLT0gODtcbiAgaWYgKHYgJiAweDBGMEYwRjBGKSBjIC09IDQ7XG4gIGlmICh2ICYgMHgzMzMzMzMzMykgYyAtPSAyO1xuICBpZiAodiAmIDB4NTU1NTU1NTUpIGMgLT0gMTtcbiAgcmV0dXJuIGM7XG59XG5leHBvcnRzLmNvdW50VHJhaWxpbmdaZXJvcyA9IGNvdW50VHJhaWxpbmdaZXJvcztcblxuLy9Sb3VuZHMgdG8gbmV4dCBwb3dlciBvZiAyXG5leHBvcnRzLm5leHRQb3cyID0gZnVuY3Rpb24odikge1xuICB2ICs9IHYgPT09IDA7XG4gIC0tdjtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiArIDE7XG59XG5cbi8vUm91bmRzIGRvd24gdG8gcHJldmlvdXMgcG93ZXIgb2YgMlxuZXhwb3J0cy5wcmV2UG93MiA9IGZ1bmN0aW9uKHYpIHtcbiAgdiB8PSB2ID4+PiAxO1xuICB2IHw9IHYgPj4+IDI7XG4gIHYgfD0gdiA+Pj4gNDtcbiAgdiB8PSB2ID4+PiA4O1xuICB2IHw9IHYgPj4+IDE2O1xuICByZXR1cm4gdiAtICh2Pj4+MSk7XG59XG5cbi8vQ29tcHV0ZXMgcGFyaXR5IG9mIHdvcmRcbmV4cG9ydHMucGFyaXR5ID0gZnVuY3Rpb24odikge1xuICB2IF49IHYgPj4+IDE2O1xuICB2IF49IHYgPj4+IDg7XG4gIHYgXj0gdiA+Pj4gNDtcbiAgdiAmPSAweGY7XG4gIHJldHVybiAoMHg2OTk2ID4+PiB2KSAmIDE7XG59XG5cbnZhciBSRVZFUlNFX1RBQkxFID0gbmV3IEFycmF5KDI1Nik7XG5cbihmdW5jdGlvbih0YWIpIHtcbiAgZm9yKHZhciBpPTA7IGk8MjU2OyArK2kpIHtcbiAgICB2YXIgdiA9IGksIHIgPSBpLCBzID0gNztcbiAgICBmb3IgKHYgPj4+PSAxOyB2OyB2ID4+Pj0gMSkge1xuICAgICAgciA8PD0gMTtcbiAgICAgIHIgfD0gdiAmIDE7XG4gICAgICAtLXM7XG4gICAgfVxuICAgIHRhYltpXSA9IChyIDw8IHMpICYgMHhmZjtcbiAgfVxufSkoUkVWRVJTRV9UQUJMRSk7XG5cbi8vUmV2ZXJzZSBiaXRzIGluIGEgMzIgYml0IHdvcmRcbmV4cG9ydHMucmV2ZXJzZSA9IGZ1bmN0aW9uKHYpIHtcbiAgcmV0dXJuICAoUkVWRVJTRV9UQUJMRVsgdiAgICAgICAgICYgMHhmZl0gPDwgMjQpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gOCkgICYgMHhmZl0gPDwgMTYpIHxcbiAgICAgICAgICAoUkVWRVJTRV9UQUJMRVsodiA+Pj4gMTYpICYgMHhmZl0gPDwgOCkgIHxcbiAgICAgICAgICAgUkVWRVJTRV9UQUJMRVsodiA+Pj4gMjQpICYgMHhmZl07XG59XG5cbi8vSW50ZXJsZWF2ZSBiaXRzIG9mIDIgY29vcmRpbmF0ZXMgd2l0aCAxNiBiaXRzLiAgVXNlZnVsIGZvciBmYXN0IHF1YWR0cmVlIGNvZGVzXG5leHBvcnRzLmludGVybGVhdmUyID0gZnVuY3Rpb24oeCwgeSkge1xuICB4ICY9IDB4RkZGRjtcbiAgeCA9ICh4IHwgKHggPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeCA9ICh4IHwgKHggPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeCA9ICh4IHwgKHggPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICB5ICY9IDB4RkZGRjtcbiAgeSA9ICh5IHwgKHkgPDwgOCkpICYgMHgwMEZGMDBGRjtcbiAgeSA9ICh5IHwgKHkgPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgeSA9ICh5IHwgKHkgPDwgMSkpICYgMHg1NTU1NTU1NTtcblxuICByZXR1cm4geCB8ICh5IDw8IDEpO1xufVxuXG4vL0V4dHJhY3RzIHRoZSBudGggaW50ZXJsZWF2ZWQgY29tcG9uZW50XG5leHBvcnRzLmRlaW50ZXJsZWF2ZTIgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgJiAweDU1NTU1NTU1O1xuICB2ID0gKHYgfCAodiA+Pj4gMSkpICAmIDB4MzMzMzMzMzM7XG4gIHYgPSAodiB8ICh2ID4+PiAyKSkgICYgMHgwRjBGMEYwRjtcbiAgdiA9ICh2IHwgKHYgPj4+IDQpKSAgJiAweDAwRkYwMEZGO1xuICB2ID0gKHYgfCAodiA+Pj4gMTYpKSAmIDB4MDAwRkZGRjtcbiAgcmV0dXJuICh2IDw8IDE2KSA+PiAxNjtcbn1cblxuXG4vL0ludGVybGVhdmUgYml0cyBvZiAzIGNvb3JkaW5hdGVzLCBlYWNoIHdpdGggMTAgYml0cy4gIFVzZWZ1bCBmb3IgZmFzdCBvY3RyZWUgY29kZXNcbmV4cG9ydHMuaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih4LCB5LCB6KSB7XG4gIHggJj0gMHgzRkY7XG4gIHggID0gKHggfCAoeDw8MTYpKSAmIDQyNzgxOTAzMzU7XG4gIHggID0gKHggfCAoeDw8OCkpICAmIDI1MTcxOTY5NTtcbiAgeCAgPSAoeCB8ICh4PDw0KSkgICYgMzI3MjM1NjAzNTtcbiAgeCAgPSAoeCB8ICh4PDwyKSkgICYgMTIyNzEzMzUxMztcblxuICB5ICY9IDB4M0ZGO1xuICB5ICA9ICh5IHwgKHk8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB5ICA9ICh5IHwgKHk8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHkgID0gKHkgfCAoeTw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHkgID0gKHkgfCAoeTw8MikpICAmIDEyMjcxMzM1MTM7XG4gIHggfD0gKHkgPDwgMSk7XG4gIFxuICB6ICY9IDB4M0ZGO1xuICB6ICA9ICh6IHwgKHo8PDE2KSkgJiA0Mjc4MTkwMzM1O1xuICB6ICA9ICh6IHwgKHo8PDgpKSAgJiAyNTE3MTk2OTU7XG4gIHogID0gKHogfCAoejw8NCkpICAmIDMyNzIzNTYwMzU7XG4gIHogID0gKHogfCAoejw8MikpICAmIDEyMjcxMzM1MTM7XG4gIFxuICByZXR1cm4geCB8ICh6IDw8IDIpO1xufVxuXG4vL0V4dHJhY3RzIG50aCBpbnRlcmxlYXZlZCBjb21wb25lbnQgb2YgYSAzLXR1cGxlXG5leHBvcnRzLmRlaW50ZXJsZWF2ZTMgPSBmdW5jdGlvbih2LCBuKSB7XG4gIHYgPSAodiA+Pj4gbikgICAgICAgJiAxMjI3MTMzNTEzO1xuICB2ID0gKHYgfCAodj4+PjIpKSAgICYgMzI3MjM1NjAzNTtcbiAgdiA9ICh2IHwgKHY+Pj40KSkgICAmIDI1MTcxOTY5NTtcbiAgdiA9ICh2IHwgKHY+Pj44KSkgICAmIDQyNzgxOTAzMzU7XG4gIHYgPSAodiB8ICh2Pj4+MTYpKSAgJiAweDNGRjtcbiAgcmV0dXJuICh2PDwyMik+PjIyO1xufVxuXG4vL0NvbXB1dGVzIG5leHQgY29tYmluYXRpb24gaW4gY29sZXhpY29ncmFwaGljIG9yZGVyICh0aGlzIGlzIG1pc3Rha2VubHkgY2FsbGVkIG5leHRQZXJtdXRhdGlvbiBvbiB0aGUgYml0IHR3aWRkbGluZyBoYWNrcyBwYWdlKVxuZXhwb3J0cy5uZXh0Q29tYmluYXRpb24gPSBmdW5jdGlvbih2KSB7XG4gIHZhciB0ID0gdiB8ICh2IC0gMSk7XG4gIHJldHVybiAodCArIDEpIHwgKCgofnQgJiAtfnQpIC0gMSkgPj4+IChjb3VudFRyYWlsaW5nWmVyb3ModikgKyAxKSk7XG59XG5cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciBjb252ZXhIdWxsMWQgPSByZXF1aXJlKCcuL2xpYi9jaDFkJylcbnZhciBjb252ZXhIdWxsMmQgPSByZXF1aXJlKCcuL2xpYi9jaDJkJylcbnZhciBjb252ZXhIdWxsbmQgPSByZXF1aXJlKCcuL2xpYi9jaG5kJylcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsXG5cbmZ1bmN0aW9uIGNvbnZleEh1bGwocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH0gZWxzZSBpZihuID09PSAxKSB7XG4gICAgcmV0dXJuIFtbMF1dXG4gIH1cbiAgdmFyIGQgPSBwb2ludHNbMF0ubGVuZ3RoXG4gIGlmKGQgPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfSBlbHNlIGlmKGQgPT09IDEpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDFkKHBvaW50cylcbiAgfSBlbHNlIGlmKGQgPT09IDIpIHtcbiAgICByZXR1cm4gY29udmV4SHVsbDJkKHBvaW50cylcbiAgfVxuICByZXR1cm4gY29udmV4SHVsbG5kKHBvaW50cywgZClcbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwxZFxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMWQocG9pbnRzKSB7XG4gIHZhciBsbyA9IDBcbiAgdmFyIGhpID0gMFxuICBmb3IodmFyIGk9MTsgaTxwb2ludHMubGVuZ3RoOyArK2kpIHtcbiAgICBpZihwb2ludHNbaV1bMF0gPCBwb2ludHNbbG9dWzBdKSB7XG4gICAgICBsbyA9IGlcbiAgICB9XG4gICAgaWYocG9pbnRzW2ldWzBdID4gcG9pbnRzW2hpXVswXSkge1xuICAgICAgaGkgPSBpXG4gICAgfVxuICB9XG4gIGlmKGxvIDwgaGkpIHtcbiAgICByZXR1cm4gW1tsb10sIFtoaV1dXG4gIH0gZWxzZSBpZihsbyA+IGhpKSB7XG4gICAgcmV0dXJuIFtbaGldLCBbbG9dXVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBbW2xvXV1cbiAgfVxufSIsIid1c2Ugc3RyaWN0J1xuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbnZleEh1bGwyRFxuXG52YXIgbW9ub3RvbmVIdWxsID0gcmVxdWlyZSgnbW9ub3RvbmUtY29udmV4LWh1bGwtMmQnKVxuXG5mdW5jdGlvbiBjb252ZXhIdWxsMkQocG9pbnRzKSB7XG4gIHZhciBodWxsID0gbW9ub3RvbmVIdWxsKHBvaW50cylcbiAgdmFyIGggPSBodWxsLmxlbmd0aFxuICBpZihoIDw9IDIpIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgZWRnZXMgPSBuZXcgQXJyYXkoaClcbiAgdmFyIGEgPSBodWxsW2gtMV1cbiAgZm9yKHZhciBpPTA7IGk8aDsgKytpKSB7XG4gICAgdmFyIGIgPSBodWxsW2ldXG4gICAgZWRnZXNbaV0gPSBbYSxiXVxuICAgIGEgPSBiXG4gIH1cbiAgcmV0dXJuIGVkZ2VzXG59XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBjb252ZXhIdWxsbkRcblxudmFyIGljaCA9IHJlcXVpcmUoJ2luY3JlbWVudGFsLWNvbnZleC1odWxsJylcbnZhciBhZmYgPSByZXF1aXJlKCdhZmZpbmUtaHVsbCcpXG5cbmZ1bmN0aW9uIHBlcm11dGUocG9pbnRzLCBmcm9udCkge1xuICB2YXIgbiA9IHBvaW50cy5sZW5ndGhcbiAgdmFyIG5wb2ludHMgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8ZnJvbnQubGVuZ3RoOyArK2kpIHtcbiAgICBucG9pbnRzW2ldID0gcG9pbnRzW2Zyb250W2ldXVxuICB9XG4gIHZhciBwdHIgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoZnJvbnQuaW5kZXhPZihpKSA8IDApIHtcbiAgICAgIG5wb2ludHNbcHRyKytdID0gcG9pbnRzW2ldXG4gICAgfVxuICB9XG4gIHJldHVybiBucG9pbnRzXG59XG5cbmZ1bmN0aW9uIGludlBlcm11dGUoY2VsbHMsIGZyb250KSB7XG4gIHZhciBuYyA9IGNlbGxzLmxlbmd0aFxuICB2YXIgbmYgPSBmcm9udC5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICB2YXIgeCA9IGNbal1cbiAgICAgIGlmKHggPCBuZikge1xuICAgICAgICBjW2pdID0gZnJvbnRbeF1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHggPSB4IC0gbmZcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8bmY7ICsraykge1xuICAgICAgICAgIGlmKHggPj0gZnJvbnRba10pIHtcbiAgICAgICAgICAgIHggKz0gMVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjW2pdID0geFxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2VsbHNcbn1cblxuZnVuY3Rpb24gY29udmV4SHVsbG5EKHBvaW50cywgZCkge1xuICB0cnkge1xuICAgIHJldHVybiBpY2gocG9pbnRzLCB0cnVlKVxuICB9IGNhdGNoKGUpIHtcbiAgICAvL0lmIHBvaW50IHNldCBpcyBkZWdlbmVyYXRlLCB0cnkgdG8gZmluZCBhIGJhc2lzIGFuZCByZXJ1biBpdFxuICAgIHZhciBhaCA9IGFmZihwb2ludHMpXG4gICAgaWYoYWgubGVuZ3RoIDw9IGQpIHtcbiAgICAgIC8vTm8gYmFzaXMsIG5vIHRyeVxuICAgICAgcmV0dXJuIFtdXG4gICAgfVxuICAgIHZhciBucG9pbnRzID0gcGVybXV0ZShwb2ludHMsIGFoKVxuICAgIHZhciBuaHVsbCAgID0gaWNoKG5wb2ludHMsIHRydWUpXG4gICAgcmV0dXJuIGludlBlcm11dGUobmh1bGwsIGFoKVxuICB9XG59IiwidmFyIHBTbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZTtcbnZhciBvYmplY3RLZXlzID0gcmVxdWlyZSgnLi9saWIva2V5cy5qcycpO1xudmFyIGlzQXJndW1lbnRzID0gcmVxdWlyZSgnLi9saWIvaXNfYXJndW1lbnRzLmpzJyk7XG5cbnZhciBkZWVwRXF1YWwgPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKSB7XG4gIGlmICghb3B0cykgb3B0cyA9IHt9O1xuICAvLyA3LjEuIEFsbCBpZGVudGljYWwgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBhcyBkZXRlcm1pbmVkIGJ5ID09PS5cbiAgaWYgKGFjdHVhbCA9PT0gZXhwZWN0ZWQpIHtcbiAgICByZXR1cm4gdHJ1ZTtcblxuICB9IGVsc2UgaWYgKGFjdHVhbCBpbnN0YW5jZW9mIERhdGUgJiYgZXhwZWN0ZWQgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIGFjdHVhbC5nZXRUaW1lKCkgPT09IGV4cGVjdGVkLmdldFRpbWUoKTtcblxuICAvLyA3LjMuIE90aGVyIHBhaXJzIHRoYXQgZG8gbm90IGJvdGggcGFzcyB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcsXG4gIC8vIGVxdWl2YWxlbmNlIGlzIGRldGVybWluZWQgYnkgPT0uXG4gIH0gZWxzZSBpZiAoIWFjdHVhbCB8fCAhZXhwZWN0ZWQgfHwgdHlwZW9mIGFjdHVhbCAhPSAnb2JqZWN0JyAmJiB0eXBlb2YgZXhwZWN0ZWQgIT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gb3B0cy5zdHJpY3QgPyBhY3R1YWwgPT09IGV4cGVjdGVkIDogYWN0dWFsID09IGV4cGVjdGVkO1xuXG4gIC8vIDcuNC4gRm9yIGFsbCBvdGhlciBPYmplY3QgcGFpcnMsIGluY2x1ZGluZyBBcnJheSBvYmplY3RzLCBlcXVpdmFsZW5jZSBpc1xuICAvLyBkZXRlcm1pbmVkIGJ5IGhhdmluZyB0aGUgc2FtZSBudW1iZXIgb2Ygb3duZWQgcHJvcGVydGllcyAoYXMgdmVyaWZpZWRcbiAgLy8gd2l0aCBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwpLCB0aGUgc2FtZSBzZXQgb2Yga2V5c1xuICAvLyAoYWx0aG91Z2ggbm90IG5lY2Vzc2FyaWx5IHRoZSBzYW1lIG9yZGVyKSwgZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5XG4gIC8vIGNvcnJlc3BvbmRpbmcga2V5LCBhbmQgYW4gaWRlbnRpY2FsICdwcm90b3R5cGUnIHByb3BlcnR5LiBOb3RlOiB0aGlzXG4gIC8vIGFjY291bnRzIGZvciBib3RoIG5hbWVkIGFuZCBpbmRleGVkIHByb3BlcnRpZXMgb24gQXJyYXlzLlxuICB9IGVsc2Uge1xuICAgIHJldHVybiBvYmpFcXVpdihhY3R1YWwsIGV4cGVjdGVkLCBvcHRzKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpc1VuZGVmaW5lZE9yTnVsbCh2YWx1ZSkge1xuICByZXR1cm4gdmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKHgpIHtcbiAgaWYgKCF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0JyB8fCB0eXBlb2YgeC5sZW5ndGggIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIGlmICh0eXBlb2YgeC5jb3B5ICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiB4LnNsaWNlICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGlmICh4Lmxlbmd0aCA+IDAgJiYgdHlwZW9mIHhbMF0gIT09ICdudW1iZXInKSByZXR1cm4gZmFsc2U7XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBvYmpFcXVpdihhLCBiLCBvcHRzKSB7XG4gIHZhciBpLCBrZXk7XG4gIGlmIChpc1VuZGVmaW5lZE9yTnVsbChhKSB8fCBpc1VuZGVmaW5lZE9yTnVsbChiKSlcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vIGFuIGlkZW50aWNhbCAncHJvdG90eXBlJyBwcm9wZXJ0eS5cbiAgaWYgKGEucHJvdG90eXBlICE9PSBiLnByb3RvdHlwZSkgcmV0dXJuIGZhbHNlO1xuICAvL35+fkkndmUgbWFuYWdlZCB0byBicmVhayBPYmplY3Qua2V5cyB0aHJvdWdoIHNjcmV3eSBhcmd1bWVudHMgcGFzc2luZy5cbiAgLy8gICBDb252ZXJ0aW5nIHRvIGFycmF5IHNvbHZlcyB0aGUgcHJvYmxlbS5cbiAgaWYgKGlzQXJndW1lbnRzKGEpKSB7XG4gICAgaWYgKCFpc0FyZ3VtZW50cyhiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBhID0gcFNsaWNlLmNhbGwoYSk7XG4gICAgYiA9IHBTbGljZS5jYWxsKGIpO1xuICAgIHJldHVybiBkZWVwRXF1YWwoYSwgYiwgb3B0cyk7XG4gIH1cbiAgaWYgKGlzQnVmZmVyKGEpKSB7XG4gICAgaWYgKCFpc0J1ZmZlcihiKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoYS5sZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChpID0gMDsgaSA8IGEubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHRyeSB7XG4gICAgdmFyIGthID0gb2JqZWN0S2V5cyhhKSxcbiAgICAgICAga2IgPSBvYmplY3RLZXlzKGIpO1xuICB9IGNhdGNoIChlKSB7Ly9oYXBwZW5zIHdoZW4gb25lIGlzIGEgc3RyaW5nIGxpdGVyYWwgYW5kIHRoZSBvdGhlciBpc24ndFxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICAvLyBoYXZpbmcgdGhlIHNhbWUgbnVtYmVyIG9mIG93bmVkIHByb3BlcnRpZXMgKGtleXMgaW5jb3Jwb3JhdGVzXG4gIC8vIGhhc093blByb3BlcnR5KVxuICBpZiAoa2EubGVuZ3RoICE9IGtiLmxlbmd0aClcbiAgICByZXR1cm4gZmFsc2U7XG4gIC8vdGhlIHNhbWUgc2V0IG9mIGtleXMgKGFsdGhvdWdoIG5vdCBuZWNlc3NhcmlseSB0aGUgc2FtZSBvcmRlciksXG4gIGthLnNvcnQoKTtcbiAga2Iuc29ydCgpO1xuICAvL35+fmNoZWFwIGtleSB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgaWYgKGthW2ldICE9IGtiW2ldKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIC8vZXF1aXZhbGVudCB2YWx1ZXMgZm9yIGV2ZXJ5IGNvcnJlc3BvbmRpbmcga2V5LCBhbmRcbiAgLy9+fn5wb3NzaWJseSBleHBlbnNpdmUgZGVlcCB0ZXN0XG4gIGZvciAoaSA9IGthLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAga2V5ID0ga2FbaV07XG4gICAgaWYgKCFkZWVwRXF1YWwoYVtrZXldLCBiW2tleV0sIG9wdHMpKSByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHR5cGVvZiBhID09PSB0eXBlb2YgYjtcbn1cbiIsInZhciBzdXBwb3J0c0FyZ3VtZW50c0NsYXNzID0gKGZ1bmN0aW9uKCl7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJndW1lbnRzKVxufSkoKSA9PSAnW29iamVjdCBBcmd1bWVudHNdJztcblxuZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3VwcG9ydHNBcmd1bWVudHNDbGFzcyA/IHN1cHBvcnRlZCA6IHVuc3VwcG9ydGVkO1xuXG5leHBvcnRzLnN1cHBvcnRlZCA9IHN1cHBvcnRlZDtcbmZ1bmN0aW9uIHN1cHBvcnRlZChvYmplY3QpIHtcbiAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmplY3QpID09ICdbb2JqZWN0IEFyZ3VtZW50c10nO1xufTtcblxuZXhwb3J0cy51bnN1cHBvcnRlZCA9IHVuc3VwcG9ydGVkO1xuZnVuY3Rpb24gdW5zdXBwb3J0ZWQob2JqZWN0KXtcbiAgcmV0dXJuIG9iamVjdCAmJlxuICAgIHR5cGVvZiBvYmplY3QgPT0gJ29iamVjdCcgJiZcbiAgICB0eXBlb2Ygb2JqZWN0Lmxlbmd0aCA9PSAnbnVtYmVyJyAmJlxuICAgIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdjYWxsZWUnKSAmJlxuICAgICFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAnY2FsbGVlJykgfHxcbiAgICBmYWxzZTtcbn07XG4iLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgT2JqZWN0LmtleXMgPT09ICdmdW5jdGlvbidcbiAgPyBPYmplY3Qua2V5cyA6IHNoaW07XG5cbmV4cG9ydHMuc2hpbSA9IHNoaW07XG5mdW5jdGlvbiBzaGltIChvYmopIHtcbiAgdmFyIGtleXMgPSBbXTtcbiAgZm9yICh2YXIga2V5IGluIG9iaikga2V5cy5wdXNoKGtleSk7XG4gIHJldHVybiBrZXlzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVhcmN1dDtcbm1vZHVsZS5leHBvcnRzLmRlZmF1bHQgPSBlYXJjdXQ7XG5cbmZ1bmN0aW9uIGVhcmN1dChkYXRhLCBob2xlSW5kaWNlcywgZGltKSB7XG5cbiAgICBkaW0gPSBkaW0gfHwgMjtcblxuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aCxcbiAgICAgICAgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGgsXG4gICAgICAgIG91dGVyTm9kZSA9IGxpbmtlZExpc3QoZGF0YSwgMCwgb3V0ZXJMZW4sIGRpbSwgdHJ1ZSksXG4gICAgICAgIHRyaWFuZ2xlcyA9IFtdO1xuXG4gICAgaWYgKCFvdXRlck5vZGUgfHwgb3V0ZXJOb2RlLm5leHQgPT09IG91dGVyTm9kZS5wcmV2KSByZXR1cm4gdHJpYW5nbGVzO1xuXG4gICAgdmFyIG1pblgsIG1pblksIG1heFgsIG1heFksIHgsIHksIGludlNpemU7XG5cbiAgICBpZiAoaGFzSG9sZXMpIG91dGVyTm9kZSA9IGVsaW1pbmF0ZUhvbGVzKGRhdGEsIGhvbGVJbmRpY2VzLCBvdXRlck5vZGUsIGRpbSk7XG5cbiAgICAvLyBpZiB0aGUgc2hhcGUgaXMgbm90IHRvbyBzaW1wbGUsIHdlJ2xsIHVzZSB6LW9yZGVyIGN1cnZlIGhhc2ggbGF0ZXI7IGNhbGN1bGF0ZSBwb2x5Z29uIGJib3hcbiAgICBpZiAoZGF0YS5sZW5ndGggPiA4MCAqIGRpbSkge1xuICAgICAgICBtaW5YID0gbWF4WCA9IGRhdGFbMF07XG4gICAgICAgIG1pblkgPSBtYXhZID0gZGF0YVsxXTtcblxuICAgICAgICBmb3IgKHZhciBpID0gZGltOyBpIDwgb3V0ZXJMZW47IGkgKz0gZGltKSB7XG4gICAgICAgICAgICB4ID0gZGF0YVtpXTtcbiAgICAgICAgICAgIHkgPSBkYXRhW2kgKyAxXTtcbiAgICAgICAgICAgIGlmICh4IDwgbWluWCkgbWluWCA9IHg7XG4gICAgICAgICAgICBpZiAoeSA8IG1pblkpIG1pblkgPSB5O1xuICAgICAgICAgICAgaWYgKHggPiBtYXhYKSBtYXhYID0geDtcbiAgICAgICAgICAgIGlmICh5ID4gbWF4WSkgbWF4WSA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBtaW5YLCBtaW5ZIGFuZCBpbnZTaXplIGFyZSBsYXRlciB1c2VkIHRvIHRyYW5zZm9ybSBjb29yZHMgaW50byBpbnRlZ2VycyBmb3Igei1vcmRlciBjYWxjdWxhdGlvblxuICAgICAgICBpbnZTaXplID0gTWF0aC5tYXgobWF4WCAtIG1pblgsIG1heFkgLSBtaW5ZKTtcbiAgICAgICAgaW52U2l6ZSA9IGludlNpemUgIT09IDAgPyAxIC8gaW52U2l6ZSA6IDA7XG4gICAgfVxuXG4gICAgZWFyY3V0TGlua2VkKG91dGVyTm9kZSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgcmV0dXJuIHRyaWFuZ2xlcztcbn1cblxuLy8gY3JlYXRlIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0IGZyb20gcG9seWdvbiBwb2ludHMgaW4gdGhlIHNwZWNpZmllZCB3aW5kaW5nIG9yZGVyXG5mdW5jdGlvbiBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgY2xvY2t3aXNlKSB7XG4gICAgdmFyIGksIGxhc3Q7XG5cbiAgICBpZiAoY2xvY2t3aXNlID09PSAoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pID4gMCkpIHtcbiAgICAgICAgZm9yIChpID0gc3RhcnQ7IGkgPCBlbmQ7IGkgKz0gZGltKSBsYXN0ID0gaW5zZXJ0Tm9kZShpLCBkYXRhW2ldLCBkYXRhW2kgKyAxXSwgbGFzdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChpID0gZW5kIC0gZGltOyBpID49IHN0YXJ0OyBpIC09IGRpbSkgbGFzdCA9IGluc2VydE5vZGUoaSwgZGF0YVtpXSwgZGF0YVtpICsgMV0sIGxhc3QpO1xuICAgIH1cblxuICAgIGlmIChsYXN0ICYmIGVxdWFscyhsYXN0LCBsYXN0Lm5leHQpKSB7XG4gICAgICAgIHJlbW92ZU5vZGUobGFzdCk7XG4gICAgICAgIGxhc3QgPSBsYXN0Lm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGxhc3Q7XG59XG5cbi8vIGVsaW1pbmF0ZSBjb2xpbmVhciBvciBkdXBsaWNhdGUgcG9pbnRzXG5mdW5jdGlvbiBmaWx0ZXJQb2ludHMoc3RhcnQsIGVuZCkge1xuICAgIGlmICghc3RhcnQpIHJldHVybiBzdGFydDtcbiAgICBpZiAoIWVuZCkgZW5kID0gc3RhcnQ7XG5cbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBhZ2FpbjtcbiAgICBkbyB7XG4gICAgICAgIGFnYWluID0gZmFsc2U7XG5cbiAgICAgICAgaWYgKCFwLnN0ZWluZXIgJiYgKGVxdWFscyhwLCBwLm5leHQpIHx8IGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID09PSAwKSkge1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwKTtcbiAgICAgICAgICAgIHAgPSBlbmQgPSBwLnByZXY7XG4gICAgICAgICAgICBpZiAocCA9PT0gcC5uZXh0KSBicmVhaztcbiAgICAgICAgICAgIGFnYWluID0gdHJ1ZTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcCA9IHAubmV4dDtcbiAgICAgICAgfVxuICAgIH0gd2hpbGUgKGFnYWluIHx8IHAgIT09IGVuZCk7XG5cbiAgICByZXR1cm4gZW5kO1xufVxuXG4vLyBtYWluIGVhciBzbGljaW5nIGxvb3Agd2hpY2ggdHJpYW5ndWxhdGVzIGEgcG9seWdvbiAoZ2l2ZW4gYXMgYSBsaW5rZWQgbGlzdClcbmZ1bmN0aW9uIGVhcmN1dExpbmtlZChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplLCBwYXNzKSB7XG4gICAgaWYgKCFlYXIpIHJldHVybjtcblxuICAgIC8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbiAgICBpZiAoIXBhc3MgJiYgaW52U2l6ZSkgaW5kZXhDdXJ2ZShlYXIsIG1pblgsIG1pblksIGludlNpemUpO1xuXG4gICAgdmFyIHN0b3AgPSBlYXIsXG4gICAgICAgIHByZXYsIG5leHQ7XG5cbiAgICAvLyBpdGVyYXRlIHRocm91Z2ggZWFycywgc2xpY2luZyB0aGVtIG9uZSBieSBvbmVcbiAgICB3aGlsZSAoZWFyLnByZXYgIT09IGVhci5uZXh0KSB7XG4gICAgICAgIHByZXYgPSBlYXIucHJldjtcbiAgICAgICAgbmV4dCA9IGVhci5uZXh0O1xuXG4gICAgICAgIGlmIChpbnZTaXplID8gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSA6IGlzRWFyKGVhcikpIHtcbiAgICAgICAgICAgIC8vIGN1dCBvZmYgdGhlIHRyaWFuZ2xlXG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChwcmV2LmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goZWFyLmkgLyBkaW0pO1xuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2gobmV4dC5pIC8gZGltKTtcblxuICAgICAgICAgICAgcmVtb3ZlTm9kZShlYXIpO1xuXG4gICAgICAgICAgICAvLyBza2lwcGluZyB0aGUgbmV4dCB2ZXJ0ZXggbGVhZHMgdG8gbGVzcyBzbGl2ZXIgdHJpYW5nbGVzXG4gICAgICAgICAgICBlYXIgPSBuZXh0Lm5leHQ7XG4gICAgICAgICAgICBzdG9wID0gbmV4dC5uZXh0O1xuXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGVhciA9IG5leHQ7XG5cbiAgICAgICAgLy8gaWYgd2UgbG9vcGVkIHRocm91Z2ggdGhlIHdob2xlIHJlbWFpbmluZyBwb2x5Z29uIGFuZCBjYW4ndCBmaW5kIGFueSBtb3JlIGVhcnNcbiAgICAgICAgaWYgKGVhciA9PT0gc3RvcCkge1xuICAgICAgICAgICAgLy8gdHJ5IGZpbHRlcmluZyBwb2ludHMgYW5kIHNsaWNpbmcgYWdhaW5cbiAgICAgICAgICAgIGlmICghcGFzcykge1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChmaWx0ZXJQb2ludHMoZWFyKSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUsIDEpO1xuXG4gICAgICAgICAgICAvLyBpZiB0aGlzIGRpZG4ndCB3b3JrLCB0cnkgY3VyaW5nIGFsbCBzbWFsbCBzZWxmLWludGVyc2VjdGlvbnMgbG9jYWxseVxuICAgICAgICAgICAgfSBlbHNlIGlmIChwYXNzID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZWFyID0gY3VyZUxvY2FsSW50ZXJzZWN0aW9ucyhlYXIsIHRyaWFuZ2xlcywgZGltKTtcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoZWFyLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSwgMik7XG5cbiAgICAgICAgICAgIC8vIGFzIGEgbGFzdCByZXNvcnQsIHRyeSBzcGxpdHRpbmcgdGhlIHJlbWFpbmluZyBwb2x5Z29uIGludG8gdHdvXG4gICAgICAgICAgICB9IGVsc2UgaWYgKHBhc3MgPT09IDIpIHtcbiAgICAgICAgICAgICAgICBzcGxpdEVhcmN1dChlYXIsIHRyaWFuZ2xlcywgZGltLCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8vIGNoZWNrIHdoZXRoZXIgYSBwb2x5Z29uIG5vZGUgZm9ybXMgYSB2YWxpZCBlYXIgd2l0aCBhZGphY2VudCBub2Rlc1xuZnVuY3Rpb24gaXNFYXIoZWFyKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gbm93IG1ha2Ugc3VyZSB3ZSBkb24ndCBoYXZlIG90aGVyIHBvaW50cyBpbnNpZGUgdGhlIHBvdGVudGlhbCBlYXJcbiAgICB2YXIgcCA9IGVhci5uZXh0Lm5leHQ7XG5cbiAgICB3aGlsZSAocCAhPT0gZWFyLnByZXYpIHtcbiAgICAgICAgaWYgKHBvaW50SW5UcmlhbmdsZShhLngsIGEueSwgYi54LCBiLnksIGMueCwgYy55LCBwLngsIHAueSkgJiZcbiAgICAgICAgICAgIGFyZWEocC5wcmV2LCBwLCBwLm5leHQpID49IDApIHJldHVybiBmYWxzZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gaXNFYXJIYXNoZWQoZWFyLCBtaW5YLCBtaW5ZLCBpbnZTaXplKSB7XG4gICAgdmFyIGEgPSBlYXIucHJldixcbiAgICAgICAgYiA9IGVhcixcbiAgICAgICAgYyA9IGVhci5uZXh0O1xuXG4gICAgaWYgKGFyZWEoYSwgYiwgYykgPj0gMCkgcmV0dXJuIGZhbHNlOyAvLyByZWZsZXgsIGNhbid0IGJlIGFuIGVhclxuXG4gICAgLy8gdHJpYW5nbGUgYmJveDsgbWluICYgbWF4IGFyZSBjYWxjdWxhdGVkIGxpa2UgdGhpcyBmb3Igc3BlZWRcbiAgICB2YXIgbWluVFggPSBhLnggPCBiLnggPyAoYS54IDwgYy54ID8gYS54IDogYy54KSA6IChiLnggPCBjLnggPyBiLnggOiBjLngpLFxuICAgICAgICBtaW5UWSA9IGEueSA8IGIueSA/IChhLnkgPCBjLnkgPyBhLnkgOiBjLnkpIDogKGIueSA8IGMueSA/IGIueSA6IGMueSksXG4gICAgICAgIG1heFRYID0gYS54ID4gYi54ID8gKGEueCA+IGMueCA/IGEueCA6IGMueCkgOiAoYi54ID4gYy54ID8gYi54IDogYy54KSxcbiAgICAgICAgbWF4VFkgPSBhLnkgPiBiLnkgPyAoYS55ID4gYy55ID8gYS55IDogYy55KSA6IChiLnkgPiBjLnkgPyBiLnkgOiBjLnkpO1xuXG4gICAgLy8gei1vcmRlciByYW5nZSBmb3IgdGhlIGN1cnJlbnQgdHJpYW5nbGUgYmJveDtcbiAgICB2YXIgbWluWiA9IHpPcmRlcihtaW5UWCwgbWluVFksIG1pblgsIG1pblksIGludlNpemUpLFxuICAgICAgICBtYXhaID0gek9yZGVyKG1heFRYLCBtYXhUWSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG5cbiAgICB2YXIgcCA9IGVhci5wcmV2WixcbiAgICAgICAgbiA9IGVhci5uZXh0WjtcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIGluIGJvdGggZGlyZWN0aW9uc1xuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aICYmIG4gJiYgbi56IDw9IG1heFopIHtcbiAgICAgICAgaWYgKHAgIT09IGVhci5wcmV2ICYmIHAgIT09IGVhci5uZXh0ICYmXG4gICAgICAgICAgICBwb2ludEluVHJpYW5nbGUoYS54LCBhLnksIGIueCwgYi55LCBjLngsIGMueSwgcC54LCBwLnkpICYmXG4gICAgICAgICAgICBhcmVhKHAucHJldiwgcCwgcC5uZXh0KSA+PSAwKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHAgPSBwLnByZXZaO1xuXG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGRlY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChwICYmIHAueiA+PSBtaW5aKSB7XG4gICAgICAgIGlmIChwICE9PSBlYXIucHJldiAmJiBwICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIHAueCwgcC55KSAmJlxuICAgICAgICAgICAgYXJlYShwLnByZXYsIHAsIHAubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBwID0gcC5wcmV2WjtcbiAgICB9XG5cbiAgICAvLyBsb29rIGZvciByZW1haW5pbmcgcG9pbnRzIGluIGluY3JlYXNpbmcgei1vcmRlclxuICAgIHdoaWxlIChuICYmIG4ueiA8PSBtYXhaKSB7XG4gICAgICAgIGlmIChuICE9PSBlYXIucHJldiAmJiBuICE9PSBlYXIubmV4dCAmJlxuICAgICAgICAgICAgcG9pbnRJblRyaWFuZ2xlKGEueCwgYS55LCBiLngsIGIueSwgYy54LCBjLnksIG4ueCwgbi55KSAmJlxuICAgICAgICAgICAgYXJlYShuLnByZXYsIG4sIG4ubmV4dCkgPj0gMCkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBuID0gbi5uZXh0WjtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxuLy8gZ28gdGhyb3VnaCBhbGwgcG9seWdvbiBub2RlcyBhbmQgY3VyZSBzbWFsbCBsb2NhbCBzZWxmLWludGVyc2VjdGlvbnNcbmZ1bmN0aW9uIGN1cmVMb2NhbEludGVyc2VjdGlvbnMoc3RhcnQsIHRyaWFuZ2xlcywgZGltKSB7XG4gICAgdmFyIHAgPSBzdGFydDtcbiAgICBkbyB7XG4gICAgICAgIHZhciBhID0gcC5wcmV2LFxuICAgICAgICAgICAgYiA9IHAubmV4dC5uZXh0O1xuXG4gICAgICAgIGlmICghZXF1YWxzKGEsIGIpICYmIGludGVyc2VjdHMoYSwgcCwgcC5uZXh0LCBiKSAmJiBsb2NhbGx5SW5zaWRlKGEsIGIpICYmIGxvY2FsbHlJbnNpZGUoYiwgYSkpIHtcblxuICAgICAgICAgICAgdHJpYW5nbGVzLnB1c2goYS5pIC8gZGltKTtcbiAgICAgICAgICAgIHRyaWFuZ2xlcy5wdXNoKHAuaSAvIGRpbSk7XG4gICAgICAgICAgICB0cmlhbmdsZXMucHVzaChiLmkgLyBkaW0pO1xuXG4gICAgICAgICAgICAvLyByZW1vdmUgdHdvIG5vZGVzIGludm9sdmVkXG4gICAgICAgICAgICByZW1vdmVOb2RlKHApO1xuICAgICAgICAgICAgcmVtb3ZlTm9kZShwLm5leHQpO1xuXG4gICAgICAgICAgICBwID0gc3RhcnQgPSBiO1xuICAgICAgICB9XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gc3RhcnQpO1xuXG4gICAgcmV0dXJuIHA7XG59XG5cbi8vIHRyeSBzcGxpdHRpbmcgcG9seWdvbiBpbnRvIHR3byBhbmQgdHJpYW5ndWxhdGUgdGhlbSBpbmRlcGVuZGVudGx5XG5mdW5jdGlvbiBzcGxpdEVhcmN1dChzdGFydCwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICAvLyBsb29rIGZvciBhIHZhbGlkIGRpYWdvbmFsIHRoYXQgZGl2aWRlcyB0aGUgcG9seWdvbiBpbnRvIHR3b1xuICAgIHZhciBhID0gc3RhcnQ7XG4gICAgZG8ge1xuICAgICAgICB2YXIgYiA9IGEubmV4dC5uZXh0O1xuICAgICAgICB3aGlsZSAoYiAhPT0gYS5wcmV2KSB7XG4gICAgICAgICAgICBpZiAoYS5pICE9PSBiLmkgJiYgaXNWYWxpZERpYWdvbmFsKGEsIGIpKSB7XG4gICAgICAgICAgICAgICAgLy8gc3BsaXQgdGhlIHBvbHlnb24gaW4gdHdvIGJ5IHRoZSBkaWFnb25hbFxuICAgICAgICAgICAgICAgIHZhciBjID0gc3BsaXRQb2x5Z29uKGEsIGIpO1xuXG4gICAgICAgICAgICAgICAgLy8gZmlsdGVyIGNvbGluZWFyIHBvaW50cyBhcm91bmQgdGhlIGN1dHNcbiAgICAgICAgICAgICAgICBhID0gZmlsdGVyUG9pbnRzKGEsIGEubmV4dCk7XG4gICAgICAgICAgICAgICAgYyA9IGZpbHRlclBvaW50cyhjLCBjLm5leHQpO1xuXG4gICAgICAgICAgICAgICAgLy8gcnVuIGVhcmN1dCBvbiBlYWNoIGhhbGZcbiAgICAgICAgICAgICAgICBlYXJjdXRMaW5rZWQoYSwgdHJpYW5nbGVzLCBkaW0sIG1pblgsIG1pblksIGludlNpemUpO1xuICAgICAgICAgICAgICAgIGVhcmN1dExpbmtlZChjLCB0cmlhbmdsZXMsIGRpbSwgbWluWCwgbWluWSwgaW52U2l6ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYiA9IGIubmV4dDtcbiAgICAgICAgfVxuICAgICAgICBhID0gYS5uZXh0O1xuICAgIH0gd2hpbGUgKGEgIT09IHN0YXJ0KTtcbn1cblxuLy8gbGluayBldmVyeSBob2xlIGludG8gdGhlIG91dGVyIGxvb3AsIHByb2R1Y2luZyBhIHNpbmdsZS1yaW5nIHBvbHlnb24gd2l0aG91dCBob2xlc1xuZnVuY3Rpb24gZWxpbWluYXRlSG9sZXMoZGF0YSwgaG9sZUluZGljZXMsIG91dGVyTm9kZSwgZGltKSB7XG4gICAgdmFyIHF1ZXVlID0gW10sXG4gICAgICAgIGksIGxlbiwgc3RhcnQsIGVuZCwgbGlzdDtcblxuICAgIGZvciAoaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIHN0YXJ0ID0gaG9sZUluZGljZXNbaV0gKiBkaW07XG4gICAgICAgIGVuZCA9IGkgPCBsZW4gLSAxID8gaG9sZUluZGljZXNbaSArIDFdICogZGltIDogZGF0YS5sZW5ndGg7XG4gICAgICAgIGxpc3QgPSBsaW5rZWRMaXN0KGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSwgZmFsc2UpO1xuICAgICAgICBpZiAobGlzdCA9PT0gbGlzdC5uZXh0KSBsaXN0LnN0ZWluZXIgPSB0cnVlO1xuICAgICAgICBxdWV1ZS5wdXNoKGdldExlZnRtb3N0KGxpc3QpKTtcbiAgICB9XG5cbiAgICBxdWV1ZS5zb3J0KGNvbXBhcmVYKTtcblxuICAgIC8vIHByb2Nlc3MgaG9sZXMgZnJvbSBsZWZ0IHRvIHJpZ2h0XG4gICAgZm9yIChpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGVsaW1pbmF0ZUhvbGUocXVldWVbaV0sIG91dGVyTm9kZSk7XG4gICAgICAgIG91dGVyTm9kZSA9IGZpbHRlclBvaW50cyhvdXRlck5vZGUsIG91dGVyTm9kZS5uZXh0KTtcbiAgICB9XG5cbiAgICByZXR1cm4gb3V0ZXJOb2RlO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlWChhLCBiKSB7XG4gICAgcmV0dXJuIGEueCAtIGIueDtcbn1cblxuLy8gZmluZCBhIGJyaWRnZSBiZXR3ZWVuIHZlcnRpY2VzIHRoYXQgY29ubmVjdHMgaG9sZSB3aXRoIGFuIG91dGVyIHJpbmcgYW5kIGFuZCBsaW5rIGl0XG5mdW5jdGlvbiBlbGltaW5hdGVIb2xlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIG91dGVyTm9kZSA9IGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSk7XG4gICAgaWYgKG91dGVyTm9kZSkge1xuICAgICAgICB2YXIgYiA9IHNwbGl0UG9seWdvbihvdXRlck5vZGUsIGhvbGUpO1xuICAgICAgICBmaWx0ZXJQb2ludHMoYiwgYi5uZXh0KTtcbiAgICB9XG59XG5cbi8vIERhdmlkIEViZXJseSdzIGFsZ29yaXRobSBmb3IgZmluZGluZyBhIGJyaWRnZSBiZXR3ZWVuIGhvbGUgYW5kIG91dGVyIHBvbHlnb25cbmZ1bmN0aW9uIGZpbmRIb2xlQnJpZGdlKGhvbGUsIG91dGVyTm9kZSkge1xuICAgIHZhciBwID0gb3V0ZXJOb2RlLFxuICAgICAgICBoeCA9IGhvbGUueCxcbiAgICAgICAgaHkgPSBob2xlLnksXG4gICAgICAgIHF4ID0gLUluZmluaXR5LFxuICAgICAgICBtO1xuXG4gICAgLy8gZmluZCBhIHNlZ21lbnQgaW50ZXJzZWN0ZWQgYnkgYSByYXkgZnJvbSB0aGUgaG9sZSdzIGxlZnRtb3N0IHBvaW50IHRvIHRoZSBsZWZ0O1xuICAgIC8vIHNlZ21lbnQncyBlbmRwb2ludCB3aXRoIGxlc3NlciB4IHdpbGwgYmUgcG90ZW50aWFsIGNvbm5lY3Rpb24gcG9pbnRcbiAgICBkbyB7XG4gICAgICAgIGlmIChoeSA8PSBwLnkgJiYgaHkgPj0gcC5uZXh0LnkgJiYgcC5uZXh0LnkgIT09IHAueSkge1xuICAgICAgICAgICAgdmFyIHggPSBwLnggKyAoaHkgLSBwLnkpICogKHAubmV4dC54IC0gcC54KSAvIChwLm5leHQueSAtIHAueSk7XG4gICAgICAgICAgICBpZiAoeCA8PSBoeCAmJiB4ID4gcXgpIHtcbiAgICAgICAgICAgICAgICBxeCA9IHg7XG4gICAgICAgICAgICAgICAgaWYgKHggPT09IGh4KSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoeSA9PT0gcC55KSByZXR1cm4gcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGh5ID09PSBwLm5leHQueSkgcmV0dXJuIHAubmV4dDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbSA9IHAueCA8IHAubmV4dC54ID8gcCA6IHAubmV4dDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IG91dGVyTm9kZSk7XG5cbiAgICBpZiAoIW0pIHJldHVybiBudWxsO1xuXG4gICAgaWYgKGh4ID09PSBxeCkgcmV0dXJuIG0ucHJldjsgLy8gaG9sZSB0b3VjaGVzIG91dGVyIHNlZ21lbnQ7IHBpY2sgbG93ZXIgZW5kcG9pbnRcblxuICAgIC8vIGxvb2sgZm9yIHBvaW50cyBpbnNpZGUgdGhlIHRyaWFuZ2xlIG9mIGhvbGUgcG9pbnQsIHNlZ21lbnQgaW50ZXJzZWN0aW9uIGFuZCBlbmRwb2ludDtcbiAgICAvLyBpZiB0aGVyZSBhcmUgbm8gcG9pbnRzIGZvdW5kLCB3ZSBoYXZlIGEgdmFsaWQgY29ubmVjdGlvbjtcbiAgICAvLyBvdGhlcndpc2UgY2hvb3NlIHRoZSBwb2ludCBvZiB0aGUgbWluaW11bSBhbmdsZSB3aXRoIHRoZSByYXkgYXMgY29ubmVjdGlvbiBwb2ludFxuXG4gICAgdmFyIHN0b3AgPSBtLFxuICAgICAgICBteCA9IG0ueCxcbiAgICAgICAgbXkgPSBtLnksXG4gICAgICAgIHRhbk1pbiA9IEluZmluaXR5LFxuICAgICAgICB0YW47XG5cbiAgICBwID0gbS5uZXh0O1xuXG4gICAgd2hpbGUgKHAgIT09IHN0b3ApIHtcbiAgICAgICAgaWYgKGh4ID49IHAueCAmJiBwLnggPj0gbXggJiYgaHggIT09IHAueCAmJlxuICAgICAgICAgICAgICAgIHBvaW50SW5UcmlhbmdsZShoeSA8IG15ID8gaHggOiBxeCwgaHksIG14LCBteSwgaHkgPCBteSA/IHF4IDogaHgsIGh5LCBwLngsIHAueSkpIHtcblxuICAgICAgICAgICAgdGFuID0gTWF0aC5hYnMoaHkgLSBwLnkpIC8gKGh4IC0gcC54KTsgLy8gdGFuZ2VudGlhbFxuXG4gICAgICAgICAgICBpZiAoKHRhbiA8IHRhbk1pbiB8fCAodGFuID09PSB0YW5NaW4gJiYgcC54ID4gbS54KSkgJiYgbG9jYWxseUluc2lkZShwLCBob2xlKSkge1xuICAgICAgICAgICAgICAgIG0gPSBwO1xuICAgICAgICAgICAgICAgIHRhbk1pbiA9IHRhbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIG07XG59XG5cbi8vIGludGVybGluayBwb2x5Z29uIG5vZGVzIGluIHotb3JkZXJcbmZ1bmN0aW9uIGluZGV4Q3VydmUoc3RhcnQsIG1pblgsIG1pblksIGludlNpemUpIHtcbiAgICB2YXIgcCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueiA9PT0gbnVsbCkgcC56ID0gek9yZGVyKHAueCwgcC55LCBtaW5YLCBtaW5ZLCBpbnZTaXplKTtcbiAgICAgICAgcC5wcmV2WiA9IHAucHJldjtcbiAgICAgICAgcC5uZXh0WiA9IHAubmV4dDtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBzdGFydCk7XG5cbiAgICBwLnByZXZaLm5leHRaID0gbnVsbDtcbiAgICBwLnByZXZaID0gbnVsbDtcblxuICAgIHNvcnRMaW5rZWQocCk7XG59XG5cbi8vIFNpbW9uIFRhdGhhbSdzIGxpbmtlZCBsaXN0IG1lcmdlIHNvcnQgYWxnb3JpdGhtXG4vLyBodHRwOi8vd3d3LmNoaWFyay5ncmVlbmVuZC5vcmcudWsvfnNndGF0aGFtL2FsZ29yaXRobXMvbGlzdHNvcnQuaHRtbFxuZnVuY3Rpb24gc29ydExpbmtlZChsaXN0KSB7XG4gICAgdmFyIGksIHAsIHEsIGUsIHRhaWwsIG51bU1lcmdlcywgcFNpemUsIHFTaXplLFxuICAgICAgICBpblNpemUgPSAxO1xuXG4gICAgZG8ge1xuICAgICAgICBwID0gbGlzdDtcbiAgICAgICAgbGlzdCA9IG51bGw7XG4gICAgICAgIHRhaWwgPSBudWxsO1xuICAgICAgICBudW1NZXJnZXMgPSAwO1xuXG4gICAgICAgIHdoaWxlIChwKSB7XG4gICAgICAgICAgICBudW1NZXJnZXMrKztcbiAgICAgICAgICAgIHEgPSBwO1xuICAgICAgICAgICAgcFNpemUgPSAwO1xuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IGluU2l6ZTsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcFNpemUrKztcbiAgICAgICAgICAgICAgICBxID0gcS5uZXh0WjtcbiAgICAgICAgICAgICAgICBpZiAoIXEpIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcVNpemUgPSBpblNpemU7XG5cbiAgICAgICAgICAgIHdoaWxlIChwU2l6ZSA+IDAgfHwgKHFTaXplID4gMCAmJiBxKSkge1xuXG4gICAgICAgICAgICAgICAgaWYgKHBTaXplICE9PSAwICYmIChxU2l6ZSA9PT0gMCB8fCAhcSB8fCBwLnogPD0gcS56KSkge1xuICAgICAgICAgICAgICAgICAgICBlID0gcDtcbiAgICAgICAgICAgICAgICAgICAgcCA9IHAubmV4dFo7XG4gICAgICAgICAgICAgICAgICAgIHBTaXplLS07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZSA9IHE7XG4gICAgICAgICAgICAgICAgICAgIHEgPSBxLm5leHRaO1xuICAgICAgICAgICAgICAgICAgICBxU2l6ZS0tO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIGlmICh0YWlsKSB0YWlsLm5leHRaID0gZTtcbiAgICAgICAgICAgICAgICBlbHNlIGxpc3QgPSBlO1xuXG4gICAgICAgICAgICAgICAgZS5wcmV2WiA9IHRhaWw7XG4gICAgICAgICAgICAgICAgdGFpbCA9IGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIHAgPSBxO1xuICAgICAgICB9XG5cbiAgICAgICAgdGFpbC5uZXh0WiA9IG51bGw7XG4gICAgICAgIGluU2l6ZSAqPSAyO1xuXG4gICAgfSB3aGlsZSAobnVtTWVyZ2VzID4gMSk7XG5cbiAgICByZXR1cm4gbGlzdDtcbn1cblxuLy8gei1vcmRlciBvZiBhIHBvaW50IGdpdmVuIGNvb3JkcyBhbmQgaW52ZXJzZSBvZiB0aGUgbG9uZ2VyIHNpZGUgb2YgZGF0YSBiYm94XG5mdW5jdGlvbiB6T3JkZXIoeCwgeSwgbWluWCwgbWluWSwgaW52U2l6ZSkge1xuICAgIC8vIGNvb3JkcyBhcmUgdHJhbnNmb3JtZWQgaW50byBub24tbmVnYXRpdmUgMTUtYml0IGludGVnZXIgcmFuZ2VcbiAgICB4ID0gMzI3NjcgKiAoeCAtIG1pblgpICogaW52U2l6ZTtcbiAgICB5ID0gMzI3NjcgKiAoeSAtIG1pblkpICogaW52U2l6ZTtcblxuICAgIHggPSAoeCB8ICh4IDw8IDgpKSAmIDB4MDBGRjAwRkY7XG4gICAgeCA9ICh4IHwgKHggPDwgNCkpICYgMHgwRjBGMEYwRjtcbiAgICB4ID0gKHggfCAoeCA8PCAyKSkgJiAweDMzMzMzMzMzO1xuICAgIHggPSAoeCB8ICh4IDw8IDEpKSAmIDB4NTU1NTU1NTU7XG5cbiAgICB5ID0gKHkgfCAoeSA8PCA4KSkgJiAweDAwRkYwMEZGO1xuICAgIHkgPSAoeSB8ICh5IDw8IDQpKSAmIDB4MEYwRjBGMEY7XG4gICAgeSA9ICh5IHwgKHkgPDwgMikpICYgMHgzMzMzMzMzMztcbiAgICB5ID0gKHkgfCAoeSA8PCAxKSkgJiAweDU1NTU1NTU1O1xuXG4gICAgcmV0dXJuIHggfCAoeSA8PCAxKTtcbn1cblxuLy8gZmluZCB0aGUgbGVmdG1vc3Qgbm9kZSBvZiBhIHBvbHlnb24gcmluZ1xuZnVuY3Rpb24gZ2V0TGVmdG1vc3Qoc3RhcnQpIHtcbiAgICB2YXIgcCA9IHN0YXJ0LFxuICAgICAgICBsZWZ0bW9zdCA9IHN0YXJ0O1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAueCA8IGxlZnRtb3N0LnggfHwgKHAueCA9PT0gbGVmdG1vc3QueCAmJiBwLnkgPCBsZWZ0bW9zdC55KSkgbGVmdG1vc3QgPSBwO1xuICAgICAgICBwID0gcC5uZXh0O1xuICAgIH0gd2hpbGUgKHAgIT09IHN0YXJ0KTtcblxuICAgIHJldHVybiBsZWZ0bW9zdDtcbn1cblxuLy8gY2hlY2sgaWYgYSBwb2ludCBsaWVzIHdpdGhpbiBhIGNvbnZleCB0cmlhbmdsZVxuZnVuY3Rpb24gcG9pbnRJblRyaWFuZ2xlKGF4LCBheSwgYngsIGJ5LCBjeCwgY3ksIHB4LCBweSkge1xuICAgIHJldHVybiAoY3ggLSBweCkgKiAoYXkgLSBweSkgLSAoYXggLSBweCkgKiAoY3kgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYXggLSBweCkgKiAoYnkgLSBweSkgLSAoYnggLSBweCkgKiAoYXkgLSBweSkgPj0gMCAmJlxuICAgICAgICAgICAoYnggLSBweCkgKiAoY3kgLSBweSkgLSAoY3ggLSBweCkgKiAoYnkgLSBweSkgPj0gMDtcbn1cblxuLy8gY2hlY2sgaWYgYSBkaWFnb25hbCBiZXR3ZWVuIHR3byBwb2x5Z29uIG5vZGVzIGlzIHZhbGlkIChsaWVzIGluIHBvbHlnb24gaW50ZXJpb3IpXG5mdW5jdGlvbiBpc1ZhbGlkRGlhZ29uYWwoYSwgYikge1xuICAgIHJldHVybiBhLm5leHQuaSAhPT0gYi5pICYmIGEucHJldi5pICE9PSBiLmkgJiYgIWludGVyc2VjdHNQb2x5Z29uKGEsIGIpICYmXG4gICAgICAgICAgIGxvY2FsbHlJbnNpZGUoYSwgYikgJiYgbG9jYWxseUluc2lkZShiLCBhKSAmJiBtaWRkbGVJbnNpZGUoYSwgYik7XG59XG5cbi8vIHNpZ25lZCBhcmVhIG9mIGEgdHJpYW5nbGVcbmZ1bmN0aW9uIGFyZWEocCwgcSwgcikge1xuICAgIHJldHVybiAocS55IC0gcC55KSAqIChyLnggLSBxLngpIC0gKHEueCAtIHAueCkgKiAoci55IC0gcS55KTtcbn1cblxuLy8gY2hlY2sgaWYgdHdvIHBvaW50cyBhcmUgZXF1YWxcbmZ1bmN0aW9uIGVxdWFscyhwMSwgcDIpIHtcbiAgICByZXR1cm4gcDEueCA9PT0gcDIueCAmJiBwMS55ID09PSBwMi55O1xufVxuXG4vLyBjaGVjayBpZiB0d28gc2VnbWVudHMgaW50ZXJzZWN0XG5mdW5jdGlvbiBpbnRlcnNlY3RzKHAxLCBxMSwgcDIsIHEyKSB7XG4gICAgaWYgKChlcXVhbHMocDEsIHExKSAmJiBlcXVhbHMocDIsIHEyKSkgfHxcbiAgICAgICAgKGVxdWFscyhwMSwgcTIpICYmIGVxdWFscyhwMiwgcTEpKSkgcmV0dXJuIHRydWU7XG4gICAgcmV0dXJuIGFyZWEocDEsIHExLCBwMikgPiAwICE9PSBhcmVhKHAxLCBxMSwgcTIpID4gMCAmJlxuICAgICAgICAgICBhcmVhKHAyLCBxMiwgcDEpID4gMCAhPT0gYXJlYShwMiwgcTIsIHExKSA+IDA7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpbnRlcnNlY3RzIGFueSBwb2x5Z29uIHNlZ21lbnRzXG5mdW5jdGlvbiBpbnRlcnNlY3RzUG9seWdvbihhLCBiKSB7XG4gICAgdmFyIHAgPSBhO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKHAuaSAhPT0gYS5pICYmIHAubmV4dC5pICE9PSBhLmkgJiYgcC5pICE9PSBiLmkgJiYgcC5uZXh0LmkgIT09IGIuaSAmJlxuICAgICAgICAgICAgICAgIGludGVyc2VjdHMocCwgcC5uZXh0LCBhLCBiKSkgcmV0dXJuIHRydWU7XG4gICAgICAgIHAgPSBwLm5leHQ7XG4gICAgfSB3aGlsZSAocCAhPT0gYSk7XG5cbiAgICByZXR1cm4gZmFsc2U7XG59XG5cbi8vIGNoZWNrIGlmIGEgcG9seWdvbiBkaWFnb25hbCBpcyBsb2NhbGx5IGluc2lkZSB0aGUgcG9seWdvblxuZnVuY3Rpb24gbG9jYWxseUluc2lkZShhLCBiKSB7XG4gICAgcmV0dXJuIGFyZWEoYS5wcmV2LCBhLCBhLm5leHQpIDwgMCA/XG4gICAgICAgIGFyZWEoYSwgYiwgYS5uZXh0KSA+PSAwICYmIGFyZWEoYSwgYS5wcmV2LCBiKSA+PSAwIDpcbiAgICAgICAgYXJlYShhLCBiLCBhLnByZXYpIDwgMCB8fCBhcmVhKGEsIGEubmV4dCwgYikgPCAwO1xufVxuXG4vLyBjaGVjayBpZiB0aGUgbWlkZGxlIHBvaW50IG9mIGEgcG9seWdvbiBkaWFnb25hbCBpcyBpbnNpZGUgdGhlIHBvbHlnb25cbmZ1bmN0aW9uIG1pZGRsZUluc2lkZShhLCBiKSB7XG4gICAgdmFyIHAgPSBhLFxuICAgICAgICBpbnNpZGUgPSBmYWxzZSxcbiAgICAgICAgcHggPSAoYS54ICsgYi54KSAvIDIsXG4gICAgICAgIHB5ID0gKGEueSArIGIueSkgLyAyO1xuICAgIGRvIHtcbiAgICAgICAgaWYgKCgocC55ID4gcHkpICE9PSAocC5uZXh0LnkgPiBweSkpICYmIHAubmV4dC55ICE9PSBwLnkgJiZcbiAgICAgICAgICAgICAgICAocHggPCAocC5uZXh0LnggLSBwLngpICogKHB5IC0gcC55KSAvIChwLm5leHQueSAtIHAueSkgKyBwLngpKVxuICAgICAgICAgICAgaW5zaWRlID0gIWluc2lkZTtcbiAgICAgICAgcCA9IHAubmV4dDtcbiAgICB9IHdoaWxlIChwICE9PSBhKTtcblxuICAgIHJldHVybiBpbnNpZGU7XG59XG5cbi8vIGxpbmsgdHdvIHBvbHlnb24gdmVydGljZXMgd2l0aCBhIGJyaWRnZTsgaWYgdGhlIHZlcnRpY2VzIGJlbG9uZyB0byB0aGUgc2FtZSByaW5nLCBpdCBzcGxpdHMgcG9seWdvbiBpbnRvIHR3bztcbi8vIGlmIG9uZSBiZWxvbmdzIHRvIHRoZSBvdXRlciByaW5nIGFuZCBhbm90aGVyIHRvIGEgaG9sZSwgaXQgbWVyZ2VzIGl0IGludG8gYSBzaW5nbGUgcmluZ1xuZnVuY3Rpb24gc3BsaXRQb2x5Z29uKGEsIGIpIHtcbiAgICB2YXIgYTIgPSBuZXcgTm9kZShhLmksIGEueCwgYS55KSxcbiAgICAgICAgYjIgPSBuZXcgTm9kZShiLmksIGIueCwgYi55KSxcbiAgICAgICAgYW4gPSBhLm5leHQsXG4gICAgICAgIGJwID0gYi5wcmV2O1xuXG4gICAgYS5uZXh0ID0gYjtcbiAgICBiLnByZXYgPSBhO1xuXG4gICAgYTIubmV4dCA9IGFuO1xuICAgIGFuLnByZXYgPSBhMjtcblxuICAgIGIyLm5leHQgPSBhMjtcbiAgICBhMi5wcmV2ID0gYjI7XG5cbiAgICBicC5uZXh0ID0gYjI7XG4gICAgYjIucHJldiA9IGJwO1xuXG4gICAgcmV0dXJuIGIyO1xufVxuXG4vLyBjcmVhdGUgYSBub2RlIGFuZCBvcHRpb25hbGx5IGxpbmsgaXQgd2l0aCBwcmV2aW91cyBvbmUgKGluIGEgY2lyY3VsYXIgZG91Ymx5IGxpbmtlZCBsaXN0KVxuZnVuY3Rpb24gaW5zZXJ0Tm9kZShpLCB4LCB5LCBsYXN0KSB7XG4gICAgdmFyIHAgPSBuZXcgTm9kZShpLCB4LCB5KTtcblxuICAgIGlmICghbGFzdCkge1xuICAgICAgICBwLnByZXYgPSBwO1xuICAgICAgICBwLm5leHQgPSBwO1xuXG4gICAgfSBlbHNlIHtcbiAgICAgICAgcC5uZXh0ID0gbGFzdC5uZXh0O1xuICAgICAgICBwLnByZXYgPSBsYXN0O1xuICAgICAgICBsYXN0Lm5leHQucHJldiA9IHA7XG4gICAgICAgIGxhc3QubmV4dCA9IHA7XG4gICAgfVxuICAgIHJldHVybiBwO1xufVxuXG5mdW5jdGlvbiByZW1vdmVOb2RlKHApIHtcbiAgICBwLm5leHQucHJldiA9IHAucHJldjtcbiAgICBwLnByZXYubmV4dCA9IHAubmV4dDtcblxuICAgIGlmIChwLnByZXZaKSBwLnByZXZaLm5leHRaID0gcC5uZXh0WjtcbiAgICBpZiAocC5uZXh0WikgcC5uZXh0Wi5wcmV2WiA9IHAucHJldlo7XG59XG5cbmZ1bmN0aW9uIE5vZGUoaSwgeCwgeSkge1xuICAgIC8vIHZlcnRleCBpbmRleCBpbiBjb29yZGluYXRlcyBhcnJheVxuICAgIHRoaXMuaSA9IGk7XG5cbiAgICAvLyB2ZXJ0ZXggY29vcmRpbmF0ZXNcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG5cbiAgICAvLyBwcmV2aW91cyBhbmQgbmV4dCB2ZXJ0ZXggbm9kZXMgaW4gYSBwb2x5Z29uIHJpbmdcbiAgICB0aGlzLnByZXYgPSBudWxsO1xuICAgIHRoaXMubmV4dCA9IG51bGw7XG5cbiAgICAvLyB6LW9yZGVyIGN1cnZlIHZhbHVlXG4gICAgdGhpcy56ID0gbnVsbDtcblxuICAgIC8vIHByZXZpb3VzIGFuZCBuZXh0IG5vZGVzIGluIHotb3JkZXJcbiAgICB0aGlzLnByZXZaID0gbnVsbDtcbiAgICB0aGlzLm5leHRaID0gbnVsbDtcblxuICAgIC8vIGluZGljYXRlcyB3aGV0aGVyIHRoaXMgaXMgYSBzdGVpbmVyIHBvaW50XG4gICAgdGhpcy5zdGVpbmVyID0gZmFsc2U7XG59XG5cbi8vIHJldHVybiBhIHBlcmNlbnRhZ2UgZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBwb2x5Z29uIGFyZWEgYW5kIGl0cyB0cmlhbmd1bGF0aW9uIGFyZWE7XG4vLyB1c2VkIHRvIHZlcmlmeSBjb3JyZWN0bmVzcyBvZiB0cmlhbmd1bGF0aW9uXG5lYXJjdXQuZGV2aWF0aW9uID0gZnVuY3Rpb24gKGRhdGEsIGhvbGVJbmRpY2VzLCBkaW0sIHRyaWFuZ2xlcykge1xuICAgIHZhciBoYXNIb2xlcyA9IGhvbGVJbmRpY2VzICYmIGhvbGVJbmRpY2VzLmxlbmd0aDtcbiAgICB2YXIgb3V0ZXJMZW4gPSBoYXNIb2xlcyA/IGhvbGVJbmRpY2VzWzBdICogZGltIDogZGF0YS5sZW5ndGg7XG5cbiAgICB2YXIgcG9seWdvbkFyZWEgPSBNYXRoLmFicyhzaWduZWRBcmVhKGRhdGEsIDAsIG91dGVyTGVuLCBkaW0pKTtcbiAgICBpZiAoaGFzSG9sZXMpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGhvbGVJbmRpY2VzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgc3RhcnQgPSBob2xlSW5kaWNlc1tpXSAqIGRpbTtcbiAgICAgICAgICAgIHZhciBlbmQgPSBpIDwgbGVuIC0gMSA/IGhvbGVJbmRpY2VzW2kgKyAxXSAqIGRpbSA6IGRhdGEubGVuZ3RoO1xuICAgICAgICAgICAgcG9seWdvbkFyZWEgLT0gTWF0aC5hYnMoc2lnbmVkQXJlYShkYXRhLCBzdGFydCwgZW5kLCBkaW0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHZhciB0cmlhbmdsZXNBcmVhID0gMDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdHJpYW5nbGVzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgICAgIHZhciBhID0gdHJpYW5nbGVzW2ldICogZGltO1xuICAgICAgICB2YXIgYiA9IHRyaWFuZ2xlc1tpICsgMV0gKiBkaW07XG4gICAgICAgIHZhciBjID0gdHJpYW5nbGVzW2kgKyAyXSAqIGRpbTtcbiAgICAgICAgdHJpYW5nbGVzQXJlYSArPSBNYXRoLmFicyhcbiAgICAgICAgICAgIChkYXRhW2FdIC0gZGF0YVtjXSkgKiAoZGF0YVtiICsgMV0gLSBkYXRhW2EgKyAxXSkgLVxuICAgICAgICAgICAgKGRhdGFbYV0gLSBkYXRhW2JdKSAqIChkYXRhW2MgKyAxXSAtIGRhdGFbYSArIDFdKSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvbHlnb25BcmVhID09PSAwICYmIHRyaWFuZ2xlc0FyZWEgPT09IDAgPyAwIDpcbiAgICAgICAgTWF0aC5hYnMoKHRyaWFuZ2xlc0FyZWEgLSBwb2x5Z29uQXJlYSkgLyBwb2x5Z29uQXJlYSk7XG59O1xuXG5mdW5jdGlvbiBzaWduZWRBcmVhKGRhdGEsIHN0YXJ0LCBlbmQsIGRpbSkge1xuICAgIHZhciBzdW0gPSAwO1xuICAgIGZvciAodmFyIGkgPSBzdGFydCwgaiA9IGVuZCAtIGRpbTsgaSA8IGVuZDsgaSArPSBkaW0pIHtcbiAgICAgICAgc3VtICs9IChkYXRhW2pdIC0gZGF0YVtpXSkgKiAoZGF0YVtpICsgMV0gKyBkYXRhW2ogKyAxXSk7XG4gICAgICAgIGogPSBpO1xuICAgIH1cbiAgICByZXR1cm4gc3VtO1xufVxuXG4vLyB0dXJuIGEgcG9seWdvbiBpbiBhIG11bHRpLWRpbWVuc2lvbmFsIGFycmF5IGZvcm0gKGUuZy4gYXMgaW4gR2VvSlNPTikgaW50byBhIGZvcm0gRWFyY3V0IGFjY2VwdHNcbmVhcmN1dC5mbGF0dGVuID0gZnVuY3Rpb24gKGRhdGEpIHtcbiAgICB2YXIgZGltID0gZGF0YVswXVswXS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdCA9IHt2ZXJ0aWNlczogW10sIGhvbGVzOiBbXSwgZGltZW5zaW9uczogZGltfSxcbiAgICAgICAgaG9sZUluZGV4ID0gMDtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRhdGFbaV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGZvciAodmFyIGQgPSAwOyBkIDwgZGltOyBkKyspIHJlc3VsdC52ZXJ0aWNlcy5wdXNoKGRhdGFbaV1bal1bZF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpID4gMCkge1xuICAgICAgICAgICAgaG9sZUluZGV4ICs9IGRhdGFbaSAtIDFdLmxlbmd0aDtcbiAgICAgICAgICAgIHJlc3VsdC5ob2xlcy5wdXNoKGhvbGVJbmRleCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG4iLCJ2YXIgd2dzODQgPSByZXF1aXJlKCd3Z3M4NCcpO1xuXG5tb2R1bGUuZXhwb3J0cy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xubW9kdWxlLmV4cG9ydHMucmluZyA9IHJpbmdBcmVhO1xuXG5mdW5jdGlvbiBnZW9tZXRyeShfKSB7XG4gICAgdmFyIGFyZWEgPSAwLCBpO1xuICAgIHN3aXRjaCAoXy50eXBlKSB7XG4gICAgICAgIGNhc2UgJ1BvbHlnb24nOlxuICAgICAgICAgICAgcmV0dXJuIHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXMpO1xuICAgICAgICBjYXNlICdNdWx0aVBvbHlnb24nOlxuICAgICAgICAgICAgZm9yIChpID0gMDsgaSA8IF8uY29vcmRpbmF0ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBhcmVhICs9IHBvbHlnb25BcmVhKF8uY29vcmRpbmF0ZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgICAgIGNhc2UgJ1BvaW50JzpcbiAgICAgICAgY2FzZSAnTXVsdGlQb2ludCc6XG4gICAgICAgIGNhc2UgJ0xpbmVTdHJpbmcnOlxuICAgICAgICBjYXNlICdNdWx0aUxpbmVTdHJpbmcnOlxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIGNhc2UgJ0dlb21ldHJ5Q29sbGVjdGlvbic6XG4gICAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgXy5nZW9tZXRyaWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJlYSArPSBnZW9tZXRyeShfLmdlb21ldHJpZXNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZWE7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBwb2x5Z29uQXJlYShjb29yZHMpIHtcbiAgICB2YXIgYXJlYSA9IDA7XG4gICAgaWYgKGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoID4gMCkge1xuICAgICAgICBhcmVhICs9IE1hdGguYWJzKHJpbmdBcmVhKGNvb3Jkc1swXSkpO1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJlYSAtPSBNYXRoLmFicyhyaW5nQXJlYShjb29yZHNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJlYTtcbn1cblxuLyoqXG4gKiBDYWxjdWxhdGUgdGhlIGFwcHJveGltYXRlIGFyZWEgb2YgdGhlIHBvbHlnb24gd2VyZSBpdCBwcm9qZWN0ZWQgb250b1xuICogICAgIHRoZSBlYXJ0aC4gIE5vdGUgdGhhdCB0aGlzIGFyZWEgd2lsbCBiZSBwb3NpdGl2ZSBpZiByaW5nIGlzIG9yaWVudGVkXG4gKiAgICAgY2xvY2t3aXNlLCBvdGhlcndpc2UgaXQgd2lsbCBiZSBuZWdhdGl2ZS5cbiAqXG4gKiBSZWZlcmVuY2U6XG4gKiBSb2JlcnQuIEcuIENoYW1iZXJsYWluIGFuZCBXaWxsaWFtIEguIER1cXVldHRlLCBcIlNvbWUgQWxnb3JpdGhtcyBmb3JcbiAqICAgICBQb2x5Z29ucyBvbiBhIFNwaGVyZVwiLCBKUEwgUHVibGljYXRpb24gMDctMDMsIEpldCBQcm9wdWxzaW9uXG4gKiAgICAgTGFib3JhdG9yeSwgUGFzYWRlbmEsIENBLCBKdW5lIDIwMDcgaHR0cDovL3Rycy1uZXcuanBsLm5hc2EuZ292L2RzcGFjZS9oYW5kbGUvMjAxNC80MDQwOVxuICpcbiAqIFJldHVybnM6XG4gKiB7ZmxvYXR9IFRoZSBhcHByb3hpbWF0ZSBzaWduZWQgZ2VvZGVzaWMgYXJlYSBvZiB0aGUgcG9seWdvbiBpbiBzcXVhcmVcbiAqICAgICBtZXRlcnMuXG4gKi9cblxuZnVuY3Rpb24gcmluZ0FyZWEoY29vcmRzKSB7XG4gICAgdmFyIHAxLCBwMiwgcDMsIGxvd2VySW5kZXgsIG1pZGRsZUluZGV4LCB1cHBlckluZGV4LFxuICAgIGFyZWEgPSAwLFxuICAgIGNvb3Jkc0xlbmd0aCA9IGNvb3Jkcy5sZW5ndGg7XG5cbiAgICBpZiAoY29vcmRzTGVuZ3RoID4gMikge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgY29vcmRzTGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAyKSB7Ly8gaSA9IE4tMlxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAyO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gY29vcmRzTGVuZ3RoIC0xO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSAwO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChpID09PSBjb29yZHNMZW5ndGggLSAxKSB7Ly8gaSA9IE4tMVxuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBjb29yZHNMZW5ndGggLSAxO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gMDtcbiAgICAgICAgICAgICAgICB1cHBlckluZGV4ID0gMTtcbiAgICAgICAgICAgIH0gZWxzZSB7IC8vIGkgPSAwIHRvIE4tM1xuICAgICAgICAgICAgICAgIGxvd2VySW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIG1pZGRsZUluZGV4ID0gaSsxO1xuICAgICAgICAgICAgICAgIHVwcGVySW5kZXggPSBpKzI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBwMSA9IGNvb3Jkc1tsb3dlckluZGV4XTtcbiAgICAgICAgICAgIHAyID0gY29vcmRzW21pZGRsZUluZGV4XTtcbiAgICAgICAgICAgIHAzID0gY29vcmRzW3VwcGVySW5kZXhdO1xuICAgICAgICAgICAgYXJlYSArPSAoIHJhZChwM1swXSkgLSByYWQocDFbMF0pICkgKiBNYXRoLnNpbiggcmFkKHAyWzFdKSk7XG4gICAgICAgIH1cblxuICAgICAgICBhcmVhID0gYXJlYSAqIHdnczg0LlJBRElVUyAqIHdnczg0LlJBRElVUyAvIDI7XG4gICAgfVxuXG4gICAgcmV0dXJuIGFyZWE7XG59XG5cbmZ1bmN0aW9uIHJhZChfKSB7XG4gICAgcmV0dXJuIF8gKiBNYXRoLlBJIC8gMTgwO1xufSIsIi8vaW5kZXguanNcbnZhciBkZWVwRXF1YWwgPSByZXF1aXJlKCdkZWVwLWVxdWFsJyk7XG5cbnZhciBFcXVhbGl0eSA9IGZ1bmN0aW9uKG9wdCkge1xuICB0aGlzLnByZWNpc2lvbiA9IG9wdCAmJiBvcHQucHJlY2lzaW9uID8gb3B0LnByZWNpc2lvbiA6IDE3O1xuICB0aGlzLmRpcmVjdGlvbiA9IG9wdCAmJiBvcHQuZGlyZWN0aW9uID8gb3B0LmRpcmVjdGlvbiA6IGZhbHNlO1xuICB0aGlzLnBzZXVkb05vZGUgPSBvcHQgJiYgb3B0LnBzZXVkb05vZGUgPyBvcHQucHNldWRvTm9kZSA6IGZhbHNlO1xuICB0aGlzLm9iamVjdENvbXBhcmF0b3IgPSBvcHQgJiYgb3B0Lm9iamVjdENvbXBhcmF0b3IgPyBvcHQub2JqZWN0Q29tcGFyYXRvciA6IG9iamVjdENvbXBhcmF0b3I7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChnMS50eXBlICE9PSBnMi50eXBlIHx8ICFzYW1lTGVuZ3RoKGcxLGcyKSkgcmV0dXJuIGZhbHNlO1xuXG4gIHN3aXRjaChnMS50eXBlKSB7XG4gIGNhc2UgJ1BvaW50JzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlQ29vcmQoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzKTtcbiAgICBicmVhaztcbiAgY2FzZSAnTGluZVN0cmluZyc6XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZUxpbmUoZzEuY29vcmRpbmF0ZXMsIGcyLmNvb3JkaW5hdGVzLDAsZmFsc2UpO1xuICAgIGJyZWFrO1xuICBjYXNlICdQb2x5Z29uJzpcbiAgICByZXR1cm4gdGhpcy5jb21wYXJlUG9seWdvbihnMSxnMik7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ0ZlYXR1cmUnOlxuICAgIHJldHVybiB0aGlzLmNvbXBhcmVGZWF0dXJlKGcxLCBnMik7XG4gIGRlZmF1bHQ6XG4gICAgaWYgKGcxLnR5cGUuaW5kZXhPZignTXVsdGknKSA9PT0gMCkge1xuICAgICAgdmFyIGNvbnRleHQgPSB0aGlzO1xuICAgICAgdmFyIGcxcyA9IGV4cGxvZGUoZzEpO1xuICAgICAgdmFyIGcycyA9IGV4cGxvZGUoZzIpO1xuICAgICAgcmV0dXJuIGcxcy5ldmVyeShmdW5jdGlvbihnMXBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc29tZShmdW5jdGlvbihnMnBhcnQpIHtcbiAgICAgICAgICByZXR1cm4gY29udGV4dC5jb21wYXJlKGcxcGFydCxnMnBhcnQpO1xuICAgICAgICB9KTtcbiAgICAgIH0sZzJzKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuZnVuY3Rpb24gZXhwbG9kZShnKSB7XG4gIHJldHVybiBnLmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbihwYXJ0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IGcudHlwZS5yZXBsYWNlKCdNdWx0aScsICcnKSxcbiAgICAgIGNvb3JkaW5hdGVzOiBwYXJ0fVxuICB9KTtcbn1cbi8vY29tcGFyZSBsZW5ndGggb2YgY29vcmRpbmF0ZXMvYXJyYXlcbmZ1bmN0aW9uIHNhbWVMZW5ndGgoZzEsZzIpIHtcbiAgIHJldHVybiBnMS5oYXNPd25Qcm9wZXJ0eSgnY29vcmRpbmF0ZXMnKSA/XG4gICAgZzEuY29vcmRpbmF0ZXMubGVuZ3RoID09PSBnMi5jb29yZGluYXRlcy5sZW5ndGhcbiAgICA6IGcxLmxlbmd0aCA9PT0gZzIubGVuZ3RoO1xufVxuXG4vLyBjb21wYXJlIHRoZSB0d28gY29vcmRpbmF0ZXMgW3gseV1cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlQ29vcmQgPSBmdW5jdGlvbihjMSxjMikge1xuICBpZiAoYzEubGVuZ3RoICE9PSBjMi5sZW5ndGgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBpPTA7IGkgPCBjMS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChjMVtpXS50b0ZpeGVkKHRoaXMucHJlY2lzaW9uKSAhPT0gYzJbaV0udG9GaXhlZCh0aGlzLnByZWNpc2lvbikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUxpbmUgPSBmdW5jdGlvbihwYXRoMSxwYXRoMixpbmQsaXNQb2x5KSB7XG4gIGlmICghc2FtZUxlbmd0aChwYXRoMSxwYXRoMikpIHJldHVybiBmYWxzZTtcbiAgdmFyIHAxID0gdGhpcy5wc2V1ZG9Ob2RlID8gcGF0aDEgOiB0aGlzLnJlbW92ZVBzZXVkbyhwYXRoMSk7XG4gIHZhciBwMiA9IHRoaXMucHNldWRvTm9kZSA/IHBhdGgyIDogdGhpcy5yZW1vdmVQc2V1ZG8ocGF0aDIpO1xuICBpZiAoaXNQb2x5ICYmICF0aGlzLmNvbXBhcmVDb29yZChwMVswXSxwMlswXSkpIHtcbiAgICAvLyBmaXggc3RhcnQgaW5kZXggb2YgYm90aCB0byBzYW1lIHBvaW50XG4gICAgcDIgPSB0aGlzLmZpeFN0YXJ0SW5kZXgocDIscDEpO1xuICAgIGlmKCFwMikgcmV0dXJuO1xuICB9XG4gIC8vIGZvciBsaW5lc3RyaW5nIGluZCA9MCBhbmQgZm9yIHBvbHlnb24gaW5kID0xXG4gIHZhciBzYW1lRGlyZWN0aW9uID0gdGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltpbmRdKTtcbiAgaWYgKHRoaXMuZGlyZWN0aW9uIHx8IHNhbWVEaXJlY3Rpb25cbiAgKSB7XG4gICAgcmV0dXJuIHRoaXMuY29tcGFyZVBhdGgocDEsIHAyKTtcbiAgfSBlbHNlIHtcbiAgICBpZiAodGhpcy5jb21wYXJlQ29vcmQocDFbaW5kXSxwMltwMi5sZW5ndGggLSAoMStpbmQpXSlcbiAgICApIHtcbiAgICAgIHJldHVybiB0aGlzLmNvbXBhcmVQYXRoKHAxLnNsaWNlKCkucmV2ZXJzZSgpLCBwMik7XG4gICAgfVxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5maXhTdGFydEluZGV4ID0gZnVuY3Rpb24oc291cmNlUGF0aCx0YXJnZXRQYXRoKSB7XG4gIC8vbWFrZSBzb3VyY2VQYXRoIGZpcnN0IHBvaW50IHNhbWUgYXMgb2YgdGFyZ2V0UGF0aFxuICB2YXIgY29ycmVjdFBhdGgsaW5kID0gLTE7XG4gIGZvciAodmFyIGk9MDsgaTwgc291cmNlUGF0aC5sZW5ndGg7IGkrKykge1xuICAgIGlmKHRoaXMuY29tcGFyZUNvb3JkKHNvdXJjZVBhdGhbaV0sdGFyZ2V0UGF0aFswXSkpIHtcbiAgICAgIGluZCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgaWYgKGluZCA+PSAwKSB7XG4gICAgY29ycmVjdFBhdGggPSBbXS5jb25jYXQoXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKGluZCxzb3VyY2VQYXRoLmxlbmd0aCksXG4gICAgICBzb3VyY2VQYXRoLnNsaWNlKDEsaW5kKzEpKTtcbiAgfVxuICByZXR1cm4gY29ycmVjdFBhdGg7XG59O1xuRXF1YWxpdHkucHJvdG90eXBlLmNvbXBhcmVQYXRoID0gZnVuY3Rpb24gKHAxLHAyKSB7XG4gIHZhciBjb250ID0gdGhpcztcbiAgcmV0dXJuIHAxLmV2ZXJ5KGZ1bmN0aW9uKGMsaSkge1xuICAgIHJldHVybiBjb250LmNvbXBhcmVDb29yZChjLHRoaXNbaV0pO1xuICB9LHAyKTtcbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlUG9seWdvbiA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmICh0aGlzLmNvbXBhcmVMaW5lKGcxLmNvb3JkaW5hdGVzWzBdLGcyLmNvb3JkaW5hdGVzWzBdLDEsdHJ1ZSkpIHtcbiAgICB2YXIgaG9sZXMxID0gZzEuY29vcmRpbmF0ZXMuc2xpY2UoMSxnMS5jb29yZGluYXRlcy5sZW5ndGgpO1xuICAgIHZhciBob2xlczIgPSBnMi5jb29yZGluYXRlcy5zbGljZSgxLGcyLmNvb3JkaW5hdGVzLmxlbmd0aCk7XG4gICAgdmFyIGNvbnQgPSB0aGlzO1xuICAgIHJldHVybiBob2xlczEuZXZlcnkoZnVuY3Rpb24oaDEpIHtcbiAgICAgIHJldHVybiB0aGlzLnNvbWUoZnVuY3Rpb24oaDIpIHtcbiAgICAgICAgcmV0dXJuIGNvbnQuY29tcGFyZUxpbmUoaDEsaDIsMSx0cnVlKTtcbiAgICAgIH0pO1xuICAgIH0saG9sZXMyKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn07XG5cbkVxdWFsaXR5LnByb3RvdHlwZS5jb21wYXJlRmVhdHVyZSA9IGZ1bmN0aW9uKGcxLGcyKSB7XG4gIGlmIChcbiAgICBnMS5pZCAhPT0gZzIuaWQgfHxcbiAgICAhdGhpcy5vYmplY3RDb21wYXJhdG9yKGcxLnByb3BlcnRpZXMsIGcyLnByb3BlcnRpZXMpIHx8XG4gICAgIXRoaXMuY29tcGFyZUJCb3goZzEsZzIpXG4gICkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdGhpcy5jb21wYXJlKGcxLmdlb21ldHJ5LCBnMi5nZW9tZXRyeSk7XG59O1xuXG5FcXVhbGl0eS5wcm90b3R5cGUuY29tcGFyZUJCb3ggPSBmdW5jdGlvbihnMSxnMikge1xuICBpZiAoXG4gICAgKCFnMS5iYm94ICYmICFnMi5iYm94KSB8fCBcbiAgICAoXG4gICAgICBnMS5iYm94ICYmIGcyLmJib3ggJiZcbiAgICAgIHRoaXMuY29tcGFyZUNvb3JkKGcxLmJib3gsIGcyLmJib3gpXG4gICAgKVxuICApICB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcbkVxdWFsaXR5LnByb3RvdHlwZS5yZW1vdmVQc2V1ZG8gPSBmdW5jdGlvbihwYXRoKSB7XG4gIC8vVE9ETyB0byBiZSBpbXBsZW1lbnRcbiAgcmV0dXJuIHBhdGg7XG59O1xuXG5mdW5jdGlvbiBvYmplY3RDb21wYXJhdG9yKG9iajEsIG9iajIpIHtcbiAgcmV0dXJuIGRlZXBFcXVhbChvYmoxLCBvYmoyLCB7c3RyaWN0OiB0cnVlfSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gRXF1YWxpdHk7XG4iLCJtb2R1bGUuZXhwb3J0cyA9IG5vcm1hbGl6ZTtcblxudmFyIHR5cGVzID0ge1xuICAgIFBvaW50OiAnZ2VvbWV0cnknLFxuICAgIE11bHRpUG9pbnQ6ICdnZW9tZXRyeScsXG4gICAgTGluZVN0cmluZzogJ2dlb21ldHJ5JyxcbiAgICBNdWx0aUxpbmVTdHJpbmc6ICdnZW9tZXRyeScsXG4gICAgUG9seWdvbjogJ2dlb21ldHJ5JyxcbiAgICBNdWx0aVBvbHlnb246ICdnZW9tZXRyeScsXG4gICAgR2VvbWV0cnlDb2xsZWN0aW9uOiAnZ2VvbWV0cnknLFxuICAgIEZlYXR1cmU6ICdmZWF0dXJlJyxcbiAgICBGZWF0dXJlQ29sbGVjdGlvbjogJ2ZlYXR1cmVjb2xsZWN0aW9uJ1xufTtcblxuLyoqXG4gKiBOb3JtYWxpemUgYSBHZW9KU09OIGZlYXR1cmUgaW50byBhIEZlYXR1cmVDb2xsZWN0aW9uLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBnaiBnZW9qc29uIGRhdGFcbiAqIEByZXR1cm5zIHtvYmplY3R9IG5vcm1hbGl6ZWQgZ2VvanNvbiBkYXRhXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZShnaikge1xuICAgIGlmICghZ2ogfHwgIWdqLnR5cGUpIHJldHVybiBudWxsO1xuICAgIHZhciB0eXBlID0gdHlwZXNbZ2oudHlwZV07XG4gICAgaWYgKCF0eXBlKSByZXR1cm4gbnVsbDtcblxuICAgIGlmICh0eXBlID09PSAnZ2VvbWV0cnknKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICAgICAgZmVhdHVyZXM6IFt7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnalxuICAgICAgICAgICAgfV1cbiAgICAgICAgfTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09ICdmZWF0dXJlJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBbZ2pdXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSAnZmVhdHVyZWNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBnajtcbiAgICB9XG59XG4iLCJtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2FsbCAucG9pbnQoKSBvciAucG9seWdvbigpIGluc3RlYWQnKTtcbn07XG5cbmZ1bmN0aW9uIHBvc2l0aW9uKGJib3gpIHtcbiAgICBpZiAoYmJveCkgcmV0dXJuIGNvb3JkSW5CQkJPWChiYm94KTtcbiAgICBlbHNlIHJldHVybiBbbG9uKCksIGxhdCgpXTtcbn1cblxubW9kdWxlLmV4cG9ydHMucG9zaXRpb24gPSBwb3NpdGlvbjtcblxubW9kdWxlLmV4cG9ydHMucG9pbnQgPSBmdW5jdGlvbihjb3VudCwgYmJveCkge1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShiYm94ID8gcG9pbnQocG9zaXRpb24oYmJveCkpIDogcG9pbnQoKSkpO1xuICAgIH1cbiAgICByZXR1cm4gY29sbGVjdGlvbihmZWF0dXJlcyk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gZnVuY3Rpb24oY291bnQsIG51bV92ZXJ0aWNlcywgbWF4X3JhZGlhbF9sZW5ndGgsIGJib3gpIHtcbiAgICBpZiAodHlwZW9mIG51bV92ZXJ0aWNlcyAhPT0gJ251bWJlcicpIG51bV92ZXJ0aWNlcyA9IDEwO1xuICAgIGlmICh0eXBlb2YgbWF4X3JhZGlhbF9sZW5ndGggIT09ICdudW1iZXInKSBtYXhfcmFkaWFsX2xlbmd0aCA9IDEwO1xuICAgIHZhciBmZWF0dXJlcyA9IFtdO1xuICAgIGZvciAoaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNlcyA9IFtdLFxuICAgICAgICAgICAgY2lyY2xlX29mZnNldHMgPSBBcnJheS5hcHBseShudWxsLFxuICAgICAgICAgICAgICAgIG5ldyBBcnJheShudW1fdmVydGljZXMgKyAxKSkubWFwKE1hdGgucmFuZG9tKTtcblxuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHN1bU9mZnNldHMpO1xuICAgICAgICBjaXJjbGVfb2Zmc2V0cy5mb3JFYWNoKHNjYWxlT2Zmc2V0cyk7XG4gICAgICAgIHZlcnRpY2VzW3ZlcnRpY2VzLmxlbmd0aCAtIDFdID0gdmVydGljZXNbMF07IC8vIGNsb3NlIHRoZSByaW5nXG5cbiAgICAgICAgLy8gY2VudGVyIHRoZSBwb2x5Z29uIGFyb3VuZCBzb21ldGhpbmdcbiAgICAgICAgdmVydGljZXMgPSB2ZXJ0aWNlcy5tYXAodmVydGV4VG9Db29yZGluYXRlKHBvc2l0aW9uKGJib3gpKSk7XG4gICAgICAgIGZlYXR1cmVzLnB1c2goZmVhdHVyZShwb2x5Z29uKFt2ZXJ0aWNlc10pKSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc3VtT2Zmc2V0cyhjdXIsIGluZGV4LCBhcnIpIHtcbiAgICAgICAgYXJyW2luZGV4XSA9IChpbmRleCA+IDApID8gY3VyICsgYXJyW2luZGV4IC0gMV0gOiBjdXI7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2NhbGVPZmZzZXRzKGN1ciwgaW5kZXgpIHtcbiAgICAgICAgY3VyID0gY3VyICogMiAqIE1hdGguUEkgLyBjaXJjbGVfb2Zmc2V0c1tjaXJjbGVfb2Zmc2V0cy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIHJhZGlhbF9zY2FsZXIgPSBNYXRoLnJhbmRvbSgpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgIHJhZGlhbF9zY2FsZXIgKiBtYXhfcmFkaWFsX2xlbmd0aCAqIE1hdGguc2luKGN1ciksXG4gICAgICAgICAgICByYWRpYWxfc2NhbGVyICogbWF4X3JhZGlhbF9sZW5ndGggKiBNYXRoLmNvcyhjdXIpXG4gICAgICAgIF0pO1xuICAgIH1cblxuICAgIHJldHVybiBjb2xsZWN0aW9uKGZlYXR1cmVzKTtcbn07XG5cblxuZnVuY3Rpb24gdmVydGV4VG9Db29yZGluYXRlKGh1Yikge1xuICAgIHJldHVybiBmdW5jdGlvbihjdXIsIGluZGV4KSB7IHJldHVybiBbY3VyWzBdICsgaHViWzBdLCBjdXJbMV0gKyBodWJbMV1dOyB9O1xufVxuXG5mdW5jdGlvbiBybmQoKSB7IHJldHVybiBNYXRoLnJhbmRvbSgpIC0gMC41OyB9XG5mdW5jdGlvbiBsb24oKSB7IHJldHVybiBybmQoKSAqIDM2MDsgfVxuZnVuY3Rpb24gbGF0KCkgeyByZXR1cm4gcm5kKCkgKiAxODA7IH1cblxuZnVuY3Rpb24gcG9pbnQoY29vcmRpbmF0ZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXMgfHwgW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBjb29yZEluQkJCT1goYmJveCkge1xuICAgIHJldHVybiBbXG4gICAgICAgIChNYXRoLnJhbmRvbSgpICogKGJib3hbMl0gLSBiYm94WzBdKSkgKyBiYm94WzBdLFxuICAgICAgICAoTWF0aC5yYW5kb20oKSAqIChiYm94WzNdIC0gYmJveFsxXSkpICsgYmJveFsxXV07XG59XG5cbmZ1bmN0aW9uIHBvaW50SW5CQkJPWCgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnUG9pbnQnLFxuICAgICAgICBjb29yZGluYXRlczogW2xvbigpLCBsYXQoKV1cbiAgICB9O1xufVxuXG5mdW5jdGlvbiBwb2x5Z29uKGNvb3JkaW5hdGVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9O1xufVxuXG5mdW5jdGlvbiBmZWF0dXJlKGdlb20pIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgIH07XG59XG5cbmZ1bmN0aW9uIGNvbGxlY3Rpb24oZikge1xuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGZlYXR1cmVzOiBmXG4gICAgfTtcbn1cbiIsInZhciByYnVzaCA9IHJlcXVpcmUoJ3JidXNoJyk7XG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ0B0dXJmL2hlbHBlcnMnKTtcbnZhciBtZXRhID0gcmVxdWlyZSgnQHR1cmYvbWV0YScpO1xudmFyIHR1cmZCQm94ID0gcmVxdWlyZSgnQHR1cmYvYmJveCcpLmRlZmF1bHQ7XG52YXIgZmVhdHVyZUVhY2ggPSBtZXRhLmZlYXR1cmVFYWNoO1xudmFyIGNvb3JkRWFjaCA9IG1ldGEuY29vcmRFYWNoO1xudmFyIHBvbHlnb24gPSBoZWxwZXJzLnBvbHlnb247XG52YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSBoZWxwZXJzLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIEdlb0pTT04gaW1wbGVtZW50YXRpb24gb2YgW1JCdXNoXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyYnVzaCkgc3BhdGlhbCBpbmRleC5cbiAqXG4gKiBAbmFtZSByYnVzaFxuICogQHBhcmFtIHtudW1iZXJ9IFttYXhFbnRyaWVzPTldIGRlZmluZXMgdGhlIG1heGltdW0gbnVtYmVyIG9mIGVudHJpZXMgaW4gYSB0cmVlIG5vZGUuIDkgKHVzZWQgYnkgZGVmYXVsdCkgaXMgYVxuICogcmVhc29uYWJsZSBjaG9pY2UgZm9yIG1vc3QgYXBwbGljYXRpb25zLiBIaWdoZXIgdmFsdWUgbWVhbnMgZmFzdGVyIGluc2VydGlvbiBhbmQgc2xvd2VyIHNlYXJjaCwgYW5kIHZpY2UgdmVyc2EuXG4gKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAqIEBleGFtcGxlXG4gKiB2YXIgZ2VvanNvblJidXNoID0gcmVxdWlyZSgnZ2VvanNvbi1yYnVzaCcpLmRlZmF1bHQ7XG4gKiB2YXIgdHJlZSA9IGdlb2pzb25SYnVzaCgpO1xuICovXG5mdW5jdGlvbiBnZW9qc29uUmJ1c2gobWF4RW50cmllcykge1xuICAgIHZhciB0cmVlID0gcmJ1c2gobWF4RW50cmllcyk7XG4gICAgLyoqXG4gICAgICogW2luc2VydF0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjZGF0YS1mb3JtYXQpXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge0ZlYXR1cmV9IGZlYXR1cmUgaW5zZXJ0IHNpbmdsZSBHZW9KU09OIEZlYXR1cmVcbiAgICAgKiBAcmV0dXJucyB7UkJ1c2h9IEdlb0pTT04gUkJ1c2hcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSk7XG4gICAgICogdHJlZS5pbnNlcnQocG9seSlcbiAgICAgKi9cbiAgICB0cmVlLmluc2VydCA9IGZ1bmN0aW9uIChmZWF0dXJlKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZlYXR1cmUnKTtcbiAgICAgICAgZmVhdHVyZS5iYm94ID0gZmVhdHVyZS5iYm94ID8gZmVhdHVyZS5iYm94IDogdHVyZkJCb3goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUuaW5zZXJ0LmNhbGwodGhpcywgZmVhdHVyZSk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtsb2FkXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNidWxrLWluc2VydGluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbnxBcnJheTxGZWF0dXJlPn0gZmVhdHVyZXMgbG9hZCBlbnRpcmUgR2VvSlNPTiBGZWF0dXJlQ29sbGVjdGlvblxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIHBvbHlzID0gdHVyZi5wb2x5Z29ucyhbXG4gICAgICogICAgIFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSxcbiAgICAgKiAgICAgW1tbLTkzLCAzMl0sIFstODMsIDMyXSwgWy04MywgMzldLCBbLTkzLCAzOV0sIFstOTMsIDMyXV1dXG4gICAgICogXSk7XG4gICAgICogdHJlZS5sb2FkKHBvbHlzKTtcbiAgICAgKi9cbiAgICB0cmVlLmxvYWQgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICAgICAgdmFyIGxvYWQgPSBbXTtcbiAgICAgICAgLy8gTG9hZCBhbiBBcnJheSBvZiBGZWF0dXJlc1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmZWF0dXJlcykpIHtcbiAgICAgICAgICAgIGZlYXR1cmVzLmZvckVhY2goZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmZWF0dXJlcycpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuYmJveCA9IGZlYXR1cmUuYmJveCA/IGZlYXR1cmUuYmJveCA6IHR1cmZCQm94KGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGxvYWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gTG9hZCBhIEZlYXR1cmVDb2xsZWN0aW9uXG4gICAgICAgICAgICBmZWF0dXJlRWFjaChmZWF0dXJlcywgZnVuY3Rpb24gKGZlYXR1cmUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScpIHRocm93IG5ldyBFcnJvcignaW52YWxpZCBmZWF0dXJlcycpO1xuICAgICAgICAgICAgICAgIGZlYXR1cmUuYmJveCA9IGZlYXR1cmUuYmJveCA/IGZlYXR1cmUuYmJveCA6IHR1cmZCQm94KGZlYXR1cmUpO1xuICAgICAgICAgICAgICAgIGxvYWQucHVzaChmZWF0dXJlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUubG9hZC5jYWxsKHRoaXMsIGxvYWQpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbcmVtb3ZlXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyZW1vdmluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHBhcmFtIHtGZWF0dXJlfSBmZWF0dXJlIHJlbW92ZSBzaW5nbGUgR2VvSlNPTiBGZWF0dXJlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxzIFBhc3MgYSBjdXN0b20gZXF1YWxzIGZ1bmN0aW9uIHRvIGNvbXBhcmUgYnkgdmFsdWUgZm9yIHJlbW92YWwuXG4gICAgICogQHJldHVybnMge1JCdXNofSBHZW9KU09OIFJCdXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IHR1cmYucG9seWdvbihbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV0pO1xuICAgICAqXG4gICAgICogdHJlZS5yZW1vdmUocG9seSk7XG4gICAgICovXG4gICAgdHJlZS5yZW1vdmUgPSBmdW5jdGlvbiAoZmVhdHVyZSwgZXF1YWxzKSB7XG4gICAgICAgIGlmIChmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJykgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGZlYXR1cmUnKTtcbiAgICAgICAgZmVhdHVyZS5iYm94ID0gZmVhdHVyZS5iYm94ID8gZmVhdHVyZS5iYm94IDogdHVyZkJCb3goZmVhdHVyZSk7XG4gICAgICAgIHJldHVybiByYnVzaC5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcywgZmVhdHVyZSwgZXF1YWxzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2NsZWFyXShodHRwczovL2dpdGh1Yi5jb20vbW91cm5lci9yYnVzaCNyZW1vdmluZy1kYXRhKVxuICAgICAqXG4gICAgICogQHJldHVybnMge1JCdXNofSBHZW9KU09OIFJidXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cmVlLmNsZWFyKClcbiAgICAgKi9cbiAgICB0cmVlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmNsZWFyLmNhbGwodGhpcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtzZWFyY2hdKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI3NlYXJjaClcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QkJveHxGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIHNlYXJjaCB3aXRoIEdlb0pTT05cbiAgICAgKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb259IGFsbCBmZWF0dXJlcyB0aGF0IGludGVyc2VjdHMgd2l0aCB0aGUgZ2l2ZW4gR2VvSlNPTi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIHZhciBwb2x5ID0gdHVyZi5wb2x5Z29uKFtbWy03OCwgNDFdLCBbLTY3LCA0MV0sIFstNjcsIDQ4XSwgWy03OCwgNDhdLCBbLTc4LCA0MV1dXSk7XG4gICAgICpcbiAgICAgKiB0cmVlLnNlYXJjaChwb2x5KTtcbiAgICAgKi9cbiAgICB0cmVlLnNlYXJjaCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHJidXNoLnByb3RvdHlwZS5zZWFyY2guY2FsbCh0aGlzLCB0aGlzLnRvQkJveChnZW9qc29uKSk7XG4gICAgICAgIHJldHVybiBmZWF0dXJlQ29sbGVjdGlvbihmZWF0dXJlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFtjb2xsaWRlc10oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjY29sbGlzaW9ucylcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7QkJveHxGZWF0dXJlQ29sbGVjdGlvbnxGZWF0dXJlfSBnZW9qc29uIGNvbGxpZGVzIHdpdGggR2VvSlNPTlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSB0cnVlIGlmIHRoZXJlIGFyZSBhbnkgaXRlbXMgaW50ZXJzZWN0aW5nIHRoZSBnaXZlbiBHZW9KU09OLCBvdGhlcndpc2UgZmFsc2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB2YXIgcG9seSA9IHR1cmYucG9seWdvbihbW1stNzgsIDQxXSwgWy02NywgNDFdLCBbLTY3LCA0OF0sIFstNzgsIDQ4XSwgWy03OCwgNDFdXV0pO1xuICAgICAqXG4gICAgICogdHJlZS5jb2xsaWRlcyhwb2x5KTtcbiAgICAgKi9cbiAgICB0cmVlLmNvbGxpZGVzID0gZnVuY3Rpb24gKGdlb2pzb24pIHtcbiAgICAgICAgcmV0dXJuIHJidXNoLnByb3RvdHlwZS5jb2xsaWRlcy5jYWxsKHRoaXMsIHRoaXMudG9CQm94KGdlb2pzb24pKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW2FsbF0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjc2VhcmNoKVxuICAgICAqXG4gICAgICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhbGwgdGhlIGZlYXR1cmVzIGluIFJCdXNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiB0cmVlLmFsbCgpXG4gICAgICovXG4gICAgdHJlZS5hbGwgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBmZWF0dXJlcyA9IHJidXNoLnByb3RvdHlwZS5hbGwuY2FsbCh0aGlzKTtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKGZlYXR1cmVzKTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogW3RvSlNPTl0oaHR0cHM6Ly9naXRodWIuY29tL21vdXJuZXIvcmJ1c2gjZXhwb3J0LWFuZC1pbXBvcnQpXG4gICAgICpcbiAgICAgKiBAcmV0dXJucyB7YW55fSBleHBvcnQgZGF0YSBhcyBKU09OIG9iamVjdFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGV4cG9ydGVkID0gdHJlZS50b0pTT04oKVxuICAgICAqL1xuICAgIHRyZWUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLnRvSlNPTi5jYWxsKHRoaXMpO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBbZnJvbUpTT05dKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3VybmVyL3JidXNoI2V4cG9ydC1hbmQtaW1wb3J0KVxuICAgICAqXG4gICAgICogQHBhcmFtIHthbnl9IGpzb24gaW1wb3J0IHByZXZpb3VzbHkgZXhwb3J0ZWQgZGF0YVxuICAgICAqIEByZXR1cm5zIHtSQnVzaH0gR2VvSlNPTiBSQnVzaFxuICAgICAqIEBleGFtcGxlXG4gICAgICogdmFyIGV4cG9ydGVkID0ge1xuICAgICAqICAgXCJjaGlsZHJlblwiOiBbXG4gICAgICogICAgIHtcbiAgICAgKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gICAgICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gICAgICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICAgICAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTEwLCA1MF1cbiAgICAgKiAgICAgICB9LFxuICAgICAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAgICAgKiAgICAgICBcImJib3hcIjogWzExMCwgNTAsIDExMCwgNTBdXG4gICAgICogICAgIH1cbiAgICAgKiAgIF0sXG4gICAgICogICBcImhlaWdodFwiOiAxLFxuICAgICAqICAgXCJsZWFmXCI6IHRydWUsXG4gICAgICogICBcIm1pblhcIjogMTEwLFxuICAgICAqICAgXCJtaW5ZXCI6IDUwLFxuICAgICAqICAgXCJtYXhYXCI6IDExMCxcbiAgICAgKiAgIFwibWF4WVwiOiA1MFxuICAgICAqIH1cbiAgICAgKiB0cmVlLmZyb21KU09OKGV4cG9ydGVkKVxuICAgICAqL1xuICAgIHRyZWUuZnJvbUpTT04gPSBmdW5jdGlvbiAoanNvbikge1xuICAgICAgICByZXR1cm4gcmJ1c2gucHJvdG90eXBlLmZyb21KU09OLmNhbGwodGhpcywganNvbik7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIEdlb0pTT04gdG8ge21pblgsIG1pblksIG1heFgsIG1heFl9IHNjaGVtYVxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0JCb3h8RmVhdHVyZUNvbGxlY3Rpb258RmVhdHVyZX0gZ2VvanNvbiBmZWF0dXJlKHMpIHRvIHJldHJpZXZlIEJCb3ggZnJvbVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IGNvbnZlcnRlZCB0byB7bWluWCwgbWluWSwgbWF4WCwgbWF4WX1cbiAgICAgKi9cbiAgICB0cmVlLnRvQkJveCA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgICAgIHZhciBiYm94O1xuICAgICAgICBpZiAoZ2VvanNvbi5iYm94KSBiYm94ID0gZ2VvanNvbi5iYm94O1xuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGdlb2pzb24pICYmIGdlb2pzb24ubGVuZ3RoID09PSA0KSBiYm94ID0gZ2VvanNvbjtcbiAgICAgICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShnZW9qc29uKSAmJiBnZW9qc29uLmxlbmd0aCA9PT0gNikgYmJveCA9IFtnZW9qc29uWzBdLCBnZW9qc29uWzFdLCBnZW9qc29uWzNdLCBnZW9qc29uWzRdXTtcbiAgICAgICAgZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZScpIGJib3ggPSB0dXJmQkJveChnZW9qc29uKTtcbiAgICAgICAgZWxzZSBpZiAoZ2VvanNvbi50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSBiYm94ID0gdHVyZkJCb3goZ2VvanNvbik7XG4gICAgICAgIGVsc2UgdGhyb3cgbmV3IEVycm9yKCdpbnZhbGlkIGdlb2pzb24nKVxuXG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBtaW5YOiBiYm94WzBdLFxuICAgICAgICAgICAgbWluWTogYmJveFsxXSxcbiAgICAgICAgICAgIG1heFg6IGJib3hbMl0sXG4gICAgICAgICAgICBtYXhZOiBiYm94WzNdXG4gICAgICAgIH07XG4gICAgfTtcbiAgICByZXR1cm4gdHJlZTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBnZW9qc29uUmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gZ2VvanNvblJidXNoO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxuLy9IaWdoIGxldmVsIGlkZWE6XG4vLyAxLiBVc2UgQ2xhcmtzb24ncyBpbmNyZW1lbnRhbCBjb25zdHJ1Y3Rpb24gdG8gZmluZCBjb252ZXggaHVsbFxuLy8gMi4gUG9pbnQgbG9jYXRpb24gaW4gdHJpYW5ndWxhdGlvbiBieSBqdW1wIGFuZCB3YWxrXG5cbm1vZHVsZS5leHBvcnRzID0gaW5jcmVtZW50YWxDb252ZXhIdWxsXG5cbnZhciBvcmllbnQgPSByZXF1aXJlKFwicm9idXN0LW9yaWVudGF0aW9uXCIpXG52YXIgY29tcGFyZUNlbGwgPSByZXF1aXJlKFwic2ltcGxpY2lhbC1jb21wbGV4XCIpLmNvbXBhcmVDZWxsc1xuXG5mdW5jdGlvbiBjb21wYXJlSW50KGEsIGIpIHtcbiAgcmV0dXJuIGEgLSBiXG59XG5cbmZ1bmN0aW9uIFNpbXBsZXgodmVydGljZXMsIGFkamFjZW50LCBib3VuZGFyeSkge1xuICB0aGlzLnZlcnRpY2VzID0gdmVydGljZXNcbiAgdGhpcy5hZGphY2VudCA9IGFkamFjZW50XG4gIHRoaXMuYm91bmRhcnkgPSBib3VuZGFyeVxuICB0aGlzLmxhc3RWaXNpdGVkID0gLTFcbn1cblxuU2ltcGxleC5wcm90b3R5cGUuZmxpcCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgdCA9IHRoaXMudmVydGljZXNbMF1cbiAgdGhpcy52ZXJ0aWNlc1swXSA9IHRoaXMudmVydGljZXNbMV1cbiAgdGhpcy52ZXJ0aWNlc1sxXSA9IHRcbiAgdmFyIHUgPSB0aGlzLmFkamFjZW50WzBdXG4gIHRoaXMuYWRqYWNlbnRbMF0gPSB0aGlzLmFkamFjZW50WzFdXG4gIHRoaXMuYWRqYWNlbnRbMV0gPSB1XG59XG5cbmZ1bmN0aW9uIEdsdWVGYWNldCh2ZXJ0aWNlcywgY2VsbCwgaW5kZXgpIHtcbiAgdGhpcy52ZXJ0aWNlcyA9IHZlcnRpY2VzXG4gIHRoaXMuY2VsbCA9IGNlbGxcbiAgdGhpcy5pbmRleCA9IGluZGV4XG59XG5cbmZ1bmN0aW9uIGNvbXBhcmVHbHVlKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVDZWxsKGEudmVydGljZXMsIGIudmVydGljZXMpXG59XG5cbmZ1bmN0aW9uIGJha2VPcmllbnQoZCkge1xuICB2YXIgY29kZSA9IFtcImZ1bmN0aW9uIG9yaWVudCgpe3ZhciB0dXBsZT10aGlzLnR1cGxlO3JldHVybiB0ZXN0KFwiXVxuICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgaWYoaSA+IDApIHtcbiAgICAgIGNvZGUucHVzaChcIixcIilcbiAgICB9XG4gICAgY29kZS5wdXNoKFwidHVwbGVbXCIsIGksIFwiXVwiKVxuICB9XG4gIGNvZGUucHVzaChcIil9cmV0dXJuIG9yaWVudFwiKVxuICB2YXIgcHJvYyA9IG5ldyBGdW5jdGlvbihcInRlc3RcIiwgY29kZS5qb2luKFwiXCIpKVxuICB2YXIgdGVzdCA9IG9yaWVudFtkKzFdXG4gIGlmKCF0ZXN0KSB7XG4gICAgdGVzdCA9IG9yaWVudFxuICB9XG4gIHJldHVybiBwcm9jKHRlc3QpXG59XG5cbnZhciBCQUtFRCA9IFtdXG5cbmZ1bmN0aW9uIFRyaWFuZ3VsYXRpb24oZGltZW5zaW9uLCB2ZXJ0aWNlcywgc2ltcGxpY2VzKSB7XG4gIHRoaXMuZGltZW5zaW9uID0gZGltZW5zaW9uXG4gIHRoaXMudmVydGljZXMgPSB2ZXJ0aWNlc1xuICB0aGlzLnNpbXBsaWNlcyA9IHNpbXBsaWNlc1xuICB0aGlzLmludGVyaW9yID0gc2ltcGxpY2VzLmZpbHRlcihmdW5jdGlvbihjKSB7XG4gICAgcmV0dXJuICFjLmJvdW5kYXJ5XG4gIH0pXG5cbiAgdGhpcy50dXBsZSA9IG5ldyBBcnJheShkaW1lbnNpb24rMSlcbiAgZm9yKHZhciBpPTA7IGk8PWRpbWVuc2lvbjsgKytpKSB7XG4gICAgdGhpcy50dXBsZVtpXSA9IHRoaXMudmVydGljZXNbaV1cbiAgfVxuXG4gIHZhciBvID0gQkFLRURbZGltZW5zaW9uXVxuICBpZighbykge1xuICAgIG8gPSBCQUtFRFtkaW1lbnNpb25dID0gYmFrZU9yaWVudChkaW1lbnNpb24pXG4gIH1cbiAgdGhpcy5vcmllbnQgPSBvXG59XG5cbnZhciBwcm90byA9IFRyaWFuZ3VsYXRpb24ucHJvdG90eXBlXG5cbi8vRGVnZW5lcmF0ZSBzaXR1YXRpb24gd2hlcmUgd2UgYXJlIG9uIGJvdW5kYXJ5LCBidXQgY29wbGFuYXIgdG8gZmFjZVxucHJvdG8uaGFuZGxlQm91bmRhcnlEZWdlbmVyYWN5ID0gZnVuY3Rpb24oY2VsbCwgcG9pbnQpIHtcbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgbiA9IHRoaXMudmVydGljZXMubGVuZ3RoIC0gMVxuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG4gIHZhciB2ZXJ0cyA9IHRoaXMudmVydGljZXNcblxuICAvL0R1bWIgc29sdXRpb246IEp1c3QgZG8gZGZzIGZyb20gYm91bmRhcnkgY2VsbCB1bnRpbCB3ZSBmaW5kIGFueSBwZWFrLCBvciB0ZXJtaW5hdGVcbiAgdmFyIHRvVmlzaXQgPSBbIGNlbGwgXVxuICBjZWxsLmxhc3RWaXNpdGVkID0gLW5cbiAgd2hpbGUodG9WaXNpdC5sZW5ndGggPiAwKSB7XG4gICAgY2VsbCA9IHRvVmlzaXQucG9wKClcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKCFuZWlnaGJvci5ib3VuZGFyeSB8fCBuZWlnaGJvci5sYXN0VmlzaXRlZCA8PSAtbikge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgdmFyIG52ID0gbmVpZ2hib3IudmVydGljZXNcbiAgICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgICAgdmFyIHZ2ID0gbnZbal1cbiAgICAgICAgaWYodnYgPCAwKSB7XG4gICAgICAgICAgdHVwbGVbal0gPSBwb2ludFxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHR1cGxlW2pdID0gdmVydHNbdnZdXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHZhciBvID0gdGhpcy5vcmllbnQoKVxuICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgcmV0dXJuIG5laWdoYm9yXG4gICAgICB9XG4gICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IC1uXG4gICAgICBpZihvID09PSAwKSB7XG4gICAgICAgIHRvVmlzaXQucHVzaChuZWlnaGJvcilcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGxcbn1cblxucHJvdG8ud2FsayA9IGZ1bmN0aW9uKHBvaW50LCByYW5kb20pIHtcbiAgLy9BbGlhcyBsb2NhbCBwcm9wZXJ0aWVzXG4gIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlc1xuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG5cbiAgLy9Db21wdXRlIGluaXRpYWwganVtcCBjZWxsXG4gIHZhciBpbml0SW5kZXggPSByYW5kb20gPyAodGhpcy5pbnRlcmlvci5sZW5ndGggKiBNYXRoLnJhbmRvbSgpKXwwIDogKHRoaXMuaW50ZXJpb3IubGVuZ3RoLTEpXG4gIHZhciBjZWxsID0gdGhpcy5pbnRlcmlvclsgaW5pdEluZGV4IF1cblxuICAvL1N0YXJ0IHdhbGtpbmdcbm91dGVyTG9vcDpcbiAgd2hpbGUoIWNlbGwuYm91bmRhcnkpIHtcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuXG4gICAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgICAgdHVwbGVbaV0gPSB2ZXJ0c1tjZWxsVmVydHNbaV1dXG4gICAgfVxuICAgIGNlbGwubGFzdFZpc2l0ZWQgPSBuXG5cbiAgICAvL0ZpbmQgZmFydGhlc3QgYWRqYWNlbnQgY2VsbFxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKG5laWdoYm9yLmxhc3RWaXNpdGVkID49IG4pIHtcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIHZhciBwcmV2ID0gdHVwbGVbaV1cbiAgICAgIHR1cGxlW2ldID0gcG9pbnRcbiAgICAgIHZhciBvID0gdGhpcy5vcmllbnQoKVxuICAgICAgdHVwbGVbaV0gPSBwcmV2XG4gICAgICBpZihvIDwgMCkge1xuICAgICAgICBjZWxsID0gbmVpZ2hib3JcbiAgICAgICAgY29udGludWUgb3V0ZXJMb29wXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZighbmVpZ2hib3IuYm91bmRhcnkpIHtcbiAgICAgICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IG5cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBuZWlnaGJvci5sYXN0VmlzaXRlZCA9IC1uXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuXG4gIH1cblxuICByZXR1cm4gY2VsbFxufVxuXG5wcm90by5hZGRQZWFrcyA9IGZ1bmN0aW9uKHBvaW50LCBjZWxsKSB7XG4gIHZhciBuID0gdGhpcy52ZXJ0aWNlcy5sZW5ndGggLSAxXG4gIHZhciBkID0gdGhpcy5kaW1lbnNpb25cbiAgdmFyIHZlcnRzID0gdGhpcy52ZXJ0aWNlc1xuICB2YXIgdHVwbGUgPSB0aGlzLnR1cGxlXG4gIHZhciBpbnRlcmlvciA9IHRoaXMuaW50ZXJpb3JcbiAgdmFyIHNpbXBsaWNlcyA9IHRoaXMuc2ltcGxpY2VzXG5cbiAgLy9XYWxraW5nIGZpbmlzaGVkIGF0IGJvdW5kYXJ5LCB0aW1lIHRvIGFkZCBwZWFrc1xuICB2YXIgdG92aXNpdCA9IFsgY2VsbCBdXG5cbiAgLy9TdHJldGNoIGluaXRpYWwgYm91bmRhcnkgY2VsbCBpbnRvIGEgcGVha1xuICBjZWxsLmxhc3RWaXNpdGVkID0gblxuICBjZWxsLnZlcnRpY2VzW2NlbGwudmVydGljZXMuaW5kZXhPZigtMSldID0gblxuICBjZWxsLmJvdW5kYXJ5ID0gZmFsc2VcbiAgaW50ZXJpb3IucHVzaChjZWxsKVxuXG4gIC8vUmVjb3JkIGEgbGlzdCBvZiBhbGwgbmV3IGJvdW5kYXJpZXMgY3JlYXRlZCBieSBhZGRlZCBwZWFrcyBzbyB3ZSBjYW4gZ2x1ZSB0aGVtIHRvZ2V0aGVyIHdoZW4gd2UgYXJlIGFsbCBkb25lXG4gIHZhciBnbHVlRmFjZXRzID0gW11cblxuICAvL0RvIGEgdHJhdmVyc2FsIG9mIHRoZSBib3VuZGFyeSB3YWxraW5nIG91dHdhcmQgZnJvbSBzdGFydGluZyBwZWFrXG4gIHdoaWxlKHRvdmlzaXQubGVuZ3RoID4gMCkge1xuICAgIC8vUG9wIG9mZiBwZWFrIGFuZCB3YWxrIG92ZXIgYWRqYWNlbnQgY2VsbHNcbiAgICB2YXIgY2VsbCA9IHRvdmlzaXQucG9wKClcbiAgICB2YXIgY2VsbFZlcnRzID0gY2VsbC52ZXJ0aWNlc1xuICAgIHZhciBjZWxsQWRqID0gY2VsbC5hZGphY2VudFxuICAgIHZhciBpbmRleE9mTiA9IGNlbGxWZXJ0cy5pbmRleE9mKG4pXG4gICAgaWYoaW5kZXhPZk4gPCAwKSB7XG4gICAgICBjb250aW51ZVxuICAgIH1cblxuICAgIGZvcih2YXIgaT0wOyBpPD1kOyArK2kpIHtcbiAgICAgIGlmKGkgPT09IGluZGV4T2ZOKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIC8vRm9yIGVhY2ggYm91bmRhcnkgbmVpZ2hib3Igb2YgdGhlIGNlbGxcbiAgICAgIHZhciBuZWlnaGJvciA9IGNlbGxBZGpbaV1cbiAgICAgIGlmKCFuZWlnaGJvci5ib3VuZGFyeSB8fCBuZWlnaGJvci5sYXN0VmlzaXRlZCA+PSBuKSB7XG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG5cbiAgICAgIHZhciBudiA9IG5laWdoYm9yLnZlcnRpY2VzXG5cbiAgICAgIC8vVGVzdCBpZiBuZWlnaGJvciBpcyBhIHBlYWtcbiAgICAgIGlmKG5laWdoYm9yLmxhc3RWaXNpdGVkICE9PSAtbikgeyAgICAgIFxuICAgICAgICAvL0NvbXB1dGUgb3JpZW50YXRpb24gb2YgcCByZWxhdGl2ZSB0byBlYWNoIGJvdW5kYXJ5IHBlYWtcbiAgICAgICAgdmFyIGluZGV4T2ZOZWcxID0gMFxuICAgICAgICBmb3IodmFyIGo9MDsgajw9ZDsgKytqKSB7XG4gICAgICAgICAgaWYobnZbal0gPCAwKSB7XG4gICAgICAgICAgICBpbmRleE9mTmVnMSA9IGpcbiAgICAgICAgICAgIHR1cGxlW2pdID0gcG9pbnRcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHVwbGVbal0gPSB2ZXJ0c1tudltqXV1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG8gPSB0aGlzLm9yaWVudCgpXG5cbiAgICAgICAgLy9UZXN0IGlmIG5laWdoYm9yIGNlbGwgaXMgYWxzbyBhIHBlYWtcbiAgICAgICAgaWYobyA+IDApIHtcbiAgICAgICAgICBudltpbmRleE9mTmVnMV0gPSBuXG4gICAgICAgICAgbmVpZ2hib3IuYm91bmRhcnkgPSBmYWxzZVxuICAgICAgICAgIGludGVyaW9yLnB1c2gobmVpZ2hib3IpXG4gICAgICAgICAgdG92aXNpdC5wdXNoKG5laWdoYm9yKVxuICAgICAgICAgIG5laWdoYm9yLmxhc3RWaXNpdGVkID0gblxuICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbmVpZ2hib3IubGFzdFZpc2l0ZWQgPSAtblxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBuYSA9IG5laWdoYm9yLmFkamFjZW50XG5cbiAgICAgIC8vT3RoZXJ3aXNlLCByZXBsYWNlIG5laWdoYm9yIHdpdGggbmV3IGZhY2VcbiAgICAgIHZhciB2dmVydHMgPSBjZWxsVmVydHMuc2xpY2UoKVxuICAgICAgdmFyIHZhZGogPSBjZWxsQWRqLnNsaWNlKClcbiAgICAgIHZhciBuY2VsbCA9IG5ldyBTaW1wbGV4KHZ2ZXJ0cywgdmFkaiwgdHJ1ZSlcbiAgICAgIHNpbXBsaWNlcy5wdXNoKG5jZWxsKVxuXG4gICAgICAvL0Nvbm5lY3QgdG8gbmVpZ2hib3JcbiAgICAgIHZhciBvcHBvc2l0ZSA9IG5hLmluZGV4T2YoY2VsbClcbiAgICAgIGlmKG9wcG9zaXRlIDwgMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgbmFbb3Bwb3NpdGVdID0gbmNlbGxcbiAgICAgIHZhZGpbaW5kZXhPZk5dID0gbmVpZ2hib3JcblxuICAgICAgLy9Db25uZWN0IHRvIGNlbGxcbiAgICAgIHZ2ZXJ0c1tpXSA9IC0xXG4gICAgICB2YWRqW2ldID0gY2VsbFxuICAgICAgY2VsbEFkaltpXSA9IG5jZWxsXG5cbiAgICAgIC8vRmxpcCBmYWNldFxuICAgICAgbmNlbGwuZmxpcCgpXG5cbiAgICAgIC8vQWRkIHRvIGdsdWUgbGlzdFxuICAgICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgICB2YXIgdXUgPSB2dmVydHNbal1cbiAgICAgICAgaWYodXUgPCAwIHx8IHV1ID09PSBuKSB7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgICB2YXIgbmZhY2UgPSBuZXcgQXJyYXkoZC0xKVxuICAgICAgICB2YXIgbnB0ciA9IDBcbiAgICAgICAgZm9yKHZhciBrPTA7IGs8PWQ7ICsraykge1xuICAgICAgICAgIHZhciB2diA9IHZ2ZXJ0c1trXVxuICAgICAgICAgIGlmKHZ2IDwgMCB8fCBrID09PSBqKSB7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgICBuZmFjZVtucHRyKytdID0gdnZcbiAgICAgICAgfVxuICAgICAgICBnbHVlRmFjZXRzLnB1c2gobmV3IEdsdWVGYWNldChuZmFjZSwgbmNlbGwsIGopKVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vR2x1ZSBib3VuZGFyeSBmYWNldHMgdG9nZXRoZXJcbiAgZ2x1ZUZhY2V0cy5zb3J0KGNvbXBhcmVHbHVlKVxuXG4gIGZvcih2YXIgaT0wOyBpKzE8Z2x1ZUZhY2V0cy5sZW5ndGg7IGkrPTIpIHtcbiAgICB2YXIgYSA9IGdsdWVGYWNldHNbaV1cbiAgICB2YXIgYiA9IGdsdWVGYWNldHNbaSsxXVxuICAgIHZhciBhaSA9IGEuaW5kZXhcbiAgICB2YXIgYmkgPSBiLmluZGV4XG4gICAgaWYoYWkgPCAwIHx8IGJpIDwgMCkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgYS5jZWxsLmFkamFjZW50W2EuaW5kZXhdID0gYi5jZWxsXG4gICAgYi5jZWxsLmFkamFjZW50W2IuaW5kZXhdID0gYS5jZWxsXG4gIH1cbn1cblxucHJvdG8uaW5zZXJ0ID0gZnVuY3Rpb24ocG9pbnQsIHJhbmRvbSkge1xuICAvL0FkZCBwb2ludFxuICB2YXIgdmVydHMgPSB0aGlzLnZlcnRpY2VzXG4gIHZlcnRzLnB1c2gocG9pbnQpXG5cbiAgdmFyIGNlbGwgPSB0aGlzLndhbGsocG9pbnQsIHJhbmRvbSlcbiAgaWYoIWNlbGwpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vQWxpYXMgbG9jYWwgcHJvcGVydGllc1xuICB2YXIgZCA9IHRoaXMuZGltZW5zaW9uXG4gIHZhciB0dXBsZSA9IHRoaXMudHVwbGVcblxuICAvL0RlZ2VuZXJhdGUgY2FzZTogSWYgcG9pbnQgaXMgY29wbGFuYXIgdG8gY2VsbCwgdGhlbiB3YWxrIHVudGlsIHdlIGZpbmQgYSBub24tZGVnZW5lcmF0ZSBib3VuZGFyeVxuICBmb3IodmFyIGk9MDsgaTw9ZDsgKytpKSB7XG4gICAgdmFyIHZ2ID0gY2VsbC52ZXJ0aWNlc1tpXVxuICAgIGlmKHZ2IDwgMCkge1xuICAgICAgdHVwbGVbaV0gPSBwb2ludFxuICAgIH0gZWxzZSB7XG4gICAgICB0dXBsZVtpXSA9IHZlcnRzW3Z2XVxuICAgIH1cbiAgfVxuICB2YXIgbyA9IHRoaXMub3JpZW50KHR1cGxlKVxuICBpZihvIDwgMCkge1xuICAgIHJldHVyblxuICB9IGVsc2UgaWYobyA9PT0gMCkge1xuICAgIGNlbGwgPSB0aGlzLmhhbmRsZUJvdW5kYXJ5RGVnZW5lcmFjeShjZWxsLCBwb2ludClcbiAgICBpZighY2VsbCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9XG5cbiAgLy9BZGQgcGVha3NcbiAgdGhpcy5hZGRQZWFrcyhwb2ludCwgY2VsbClcbn1cblxuLy9FeHRyYWN0IGFsbCBib3VuZGFyeSBjZWxsc1xucHJvdG8uYm91bmRhcnkgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGQgPSB0aGlzLmRpbWVuc2lvblxuICB2YXIgYm91bmRhcnkgPSBbXVxuICB2YXIgY2VsbHMgPSB0aGlzLnNpbXBsaWNlc1xuICB2YXIgbmMgPSBjZWxscy5sZW5ndGhcbiAgZm9yKHZhciBpPTA7IGk8bmM7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBpZihjLmJvdW5kYXJ5KSB7XG4gICAgICB2YXIgYmNlbGwgPSBuZXcgQXJyYXkoZClcbiAgICAgIHZhciBjdiA9IGMudmVydGljZXNcbiAgICAgIHZhciBwdHIgPSAwXG4gICAgICB2YXIgcGFyaXR5ID0gMFxuICAgICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgICBpZihjdltqXSA+PSAwKSB7XG4gICAgICAgICAgYmNlbGxbcHRyKytdID0gY3Zbal1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBwYXJpdHkgPSBqJjFcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYocGFyaXR5ID09PSAoZCYxKSkge1xuICAgICAgICB2YXIgdCA9IGJjZWxsWzBdXG4gICAgICAgIGJjZWxsWzBdID0gYmNlbGxbMV1cbiAgICAgICAgYmNlbGxbMV0gPSB0XG4gICAgICB9XG4gICAgICBib3VuZGFyeS5wdXNoKGJjZWxsKVxuICAgIH1cbiAgfVxuICByZXR1cm4gYm91bmRhcnlcbn1cblxuZnVuY3Rpb24gaW5jcmVtZW50YWxDb252ZXhIdWxsKHBvaW50cywgcmFuZG9tU2VhcmNoKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuICBpZihuID09PSAwKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBoYXZlIGF0IGxlYXN0IGQrMSBwb2ludHNcIilcbiAgfVxuICB2YXIgZCA9IHBvaW50c1swXS5sZW5ndGhcbiAgaWYobiA8PSBkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiTXVzdCBpbnB1dCBhdCBsZWFzdCBkKzEgcG9pbnRzXCIpXG4gIH1cblxuICAvL0ZJWE1FOiBUaGlzIGNvdWxkIGJlIGRlZ2VuZXJhdGUsIGJ1dCBuZWVkIHRvIHNlbGVjdCBkKzEgbm9uLWNvcGxhbmFyIHBvaW50cyB0byBib290c3RyYXAgcHJvY2Vzc1xuICB2YXIgaW5pdGlhbFNpbXBsZXggPSBwb2ludHMuc2xpY2UoMCwgZCsxKVxuXG4gIC8vTWFrZSBzdXJlIGluaXRpYWwgc2ltcGxleCBpcyBwb3NpdGl2ZWx5IG9yaWVudGVkXG4gIHZhciBvID0gb3JpZW50LmFwcGx5KHZvaWQgMCwgaW5pdGlhbFNpbXBsZXgpXG4gIGlmKG8gPT09IDApIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnB1dCBub3QgaW4gZ2VuZXJhbCBwb3NpdGlvblwiKVxuICB9XG4gIHZhciBpbml0aWFsQ29vcmRzID0gbmV3IEFycmF5KGQrMSlcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIGluaXRpYWxDb29yZHNbaV0gPSBpXG4gIH1cbiAgaWYobyA8IDApIHtcbiAgICBpbml0aWFsQ29vcmRzWzBdID0gMVxuICAgIGluaXRpYWxDb29yZHNbMV0gPSAwXG4gIH1cblxuICAvL0NyZWF0ZSBpbml0aWFsIHRvcG9sb2dpY2FsIGluZGV4LCBnbHVlIHBvaW50ZXJzIHRvZ2V0aGVyIChraW5kIG9mIG1lc3N5KVxuICB2YXIgaW5pdGlhbENlbGwgPSBuZXcgU2ltcGxleChpbml0aWFsQ29vcmRzLCBuZXcgQXJyYXkoZCsxKSwgZmFsc2UpXG4gIHZhciBib3VuZGFyeSA9IGluaXRpYWxDZWxsLmFkamFjZW50XG4gIHZhciBsaXN0ID0gbmV3IEFycmF5KGQrMilcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIHZhciB2ZXJ0cyA9IGluaXRpYWxDb29yZHMuc2xpY2UoKVxuICAgIGZvcih2YXIgaj0wOyBqPD1kOyArK2opIHtcbiAgICAgIGlmKGogPT09IGkpIHtcbiAgICAgICAgdmVydHNbal0gPSAtMVxuICAgICAgfVxuICAgIH1cbiAgICB2YXIgdCA9IHZlcnRzWzBdXG4gICAgdmVydHNbMF0gPSB2ZXJ0c1sxXVxuICAgIHZlcnRzWzFdID0gdFxuICAgIHZhciBjZWxsID0gbmV3IFNpbXBsZXgodmVydHMsIG5ldyBBcnJheShkKzEpLCB0cnVlKVxuICAgIGJvdW5kYXJ5W2ldID0gY2VsbFxuICAgIGxpc3RbaV0gPSBjZWxsXG4gIH1cbiAgbGlzdFtkKzFdID0gaW5pdGlhbENlbGxcbiAgZm9yKHZhciBpPTA7IGk8PWQ7ICsraSkge1xuICAgIHZhciB2ZXJ0cyA9IGJvdW5kYXJ5W2ldLnZlcnRpY2VzXG4gICAgdmFyIGFkaiA9IGJvdW5kYXJ5W2ldLmFkamFjZW50XG4gICAgZm9yKHZhciBqPTA7IGo8PWQ7ICsraikge1xuICAgICAgdmFyIHYgPSB2ZXJ0c1tqXVxuICAgICAgaWYodiA8IDApIHtcbiAgICAgICAgYWRqW2pdID0gaW5pdGlhbENlbGxcbiAgICAgICAgY29udGludWVcbiAgICAgIH1cbiAgICAgIGZvcih2YXIgaz0wOyBrPD1kOyArK2spIHtcbiAgICAgICAgaWYoYm91bmRhcnlba10udmVydGljZXMuaW5kZXhPZih2KSA8IDApIHtcbiAgICAgICAgICBhZGpbal0gPSBib3VuZGFyeVtrXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy9Jbml0aWFsaXplIHRyaWFuZ2xlc1xuICB2YXIgdHJpYW5nbGVzID0gbmV3IFRyaWFuZ3VsYXRpb24oZCwgaW5pdGlhbFNpbXBsZXgsIGxpc3QpXG5cbiAgLy9JbnNlcnQgcmVtYWluaW5nIHBvaW50c1xuICB2YXIgdXNlUmFuZG9tID0gISFyYW5kb21TZWFyY2hcbiAgZm9yKHZhciBpPWQrMTsgaTxuOyArK2kpIHtcbiAgICB0cmlhbmdsZXMuaW5zZXJ0KHBvaW50c1tpXSwgdXNlUmFuZG9tKVxuICB9XG4gIFxuICAvL0V4dHJhY3QgYm91bmRhcnkgY2VsbHNcbiAgcmV0dXJuIHRyaWFuZ2xlcy5ib3VuZGFyeSgpXG59IiwiLyohXG4gKiBqUXVlcnkgSmF2YVNjcmlwdCBMaWJyYXJ5IHYzLjUuMVxuICogaHR0cHM6Ly9qcXVlcnkuY29tL1xuICpcbiAqIEluY2x1ZGVzIFNpenpsZS5qc1xuICogaHR0cHM6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IEpTIEZvdW5kYXRpb24gYW5kIG90aGVyIGNvbnRyaWJ1dG9yc1xuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlXG4gKiBodHRwczovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMjAtMDUtMDRUMjI6NDlaXG4gKi9cbiggZnVuY3Rpb24oIGdsb2JhbCwgZmFjdG9yeSApIHtcblxuXHRcInVzZSBzdHJpY3RcIjtcblxuXHRpZiAoIHR5cGVvZiBtb2R1bGUgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG1vZHVsZS5leHBvcnRzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gRm9yIENvbW1vbkpTIGFuZCBDb21tb25KUy1saWtlIGVudmlyb25tZW50cyB3aGVyZSBhIHByb3BlciBgd2luZG93YFxuXHRcdC8vIGlzIHByZXNlbnQsIGV4ZWN1dGUgdGhlIGZhY3RvcnkgYW5kIGdldCBqUXVlcnkuXG5cdFx0Ly8gRm9yIGVudmlyb25tZW50cyB0aGF0IGRvIG5vdCBoYXZlIGEgYHdpbmRvd2Agd2l0aCBhIGBkb2N1bWVudGBcblx0XHQvLyAoc3VjaCBhcyBOb2RlLmpzKSwgZXhwb3NlIGEgZmFjdG9yeSBhcyBtb2R1bGUuZXhwb3J0cy5cblx0XHQvLyBUaGlzIGFjY2VudHVhdGVzIHRoZSBuZWVkIGZvciB0aGUgY3JlYXRpb24gb2YgYSByZWFsIGB3aW5kb3dgLlxuXHRcdC8vIGUuZy4gdmFyIGpRdWVyeSA9IHJlcXVpcmUoXCJqcXVlcnlcIikod2luZG93KTtcblx0XHQvLyBTZWUgdGlja2V0ICMxNDU0OSBmb3IgbW9yZSBpbmZvLlxuXHRcdG1vZHVsZS5leHBvcnRzID0gZ2xvYmFsLmRvY3VtZW50ID9cblx0XHRcdGZhY3RvcnkoIGdsb2JhbCwgdHJ1ZSApIDpcblx0XHRcdGZ1bmN0aW9uKCB3ICkge1xuXHRcdFx0XHRpZiAoICF3LmRvY3VtZW50ICkge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvciggXCJqUXVlcnkgcmVxdWlyZXMgYSB3aW5kb3cgd2l0aCBhIGRvY3VtZW50XCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZmFjdG9yeSggdyApO1xuXHRcdFx0fTtcblx0fSBlbHNlIHtcblx0XHRmYWN0b3J5KCBnbG9iYWwgKTtcblx0fVxuXG4vLyBQYXNzIHRoaXMgaWYgd2luZG93IGlzIG5vdCBkZWZpbmVkIHlldFxufSApKCB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93IDogdGhpcywgZnVuY3Rpb24oIHdpbmRvdywgbm9HbG9iYWwgKSB7XG5cbi8vIEVkZ2UgPD0gMTIgLSAxMyssIEZpcmVmb3ggPD0xOCAtIDQ1KywgSUUgMTAgLSAxMSwgU2FmYXJpIDUuMSAtIDkrLCBpT1MgNiAtIDkuMVxuLy8gdGhyb3cgZXhjZXB0aW9ucyB3aGVuIG5vbi1zdHJpY3QgY29kZSAoZS5nLiwgQVNQLk5FVCA0LjUpIGFjY2Vzc2VzIHN0cmljdCBtb2RlXG4vLyBhcmd1bWVudHMuY2FsbGVlLmNhbGxlciAodHJhYy0xMzMzNSkuIEJ1dCBhcyBvZiBqUXVlcnkgMy4wICgyMDE2KSwgc3RyaWN0IG1vZGUgc2hvdWxkIGJlIGNvbW1vblxuLy8gZW5vdWdoIHRoYXQgYWxsIHN1Y2ggYXR0ZW1wdHMgYXJlIGd1YXJkZWQgaW4gYSB0cnkgYmxvY2suXG5cInVzZSBzdHJpY3RcIjtcblxudmFyIGFyciA9IFtdO1xuXG52YXIgZ2V0UHJvdG8gPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XG5cbnZhciBzbGljZSA9IGFyci5zbGljZTtcblxudmFyIGZsYXQgPSBhcnIuZmxhdCA/IGZ1bmN0aW9uKCBhcnJheSApIHtcblx0cmV0dXJuIGFyci5mbGF0LmNhbGwoIGFycmF5ICk7XG59IDogZnVuY3Rpb24oIGFycmF5ICkge1xuXHRyZXR1cm4gYXJyLmNvbmNhdC5hcHBseSggW10sIGFycmF5ICk7XG59O1xuXG5cbnZhciBwdXNoID0gYXJyLnB1c2g7XG5cbnZhciBpbmRleE9mID0gYXJyLmluZGV4T2Y7XG5cbnZhciBjbGFzczJ0eXBlID0ge307XG5cbnZhciB0b1N0cmluZyA9IGNsYXNzMnR5cGUudG9TdHJpbmc7XG5cbnZhciBoYXNPd24gPSBjbGFzczJ0eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgZm5Ub1N0cmluZyA9IGhhc093bi50b1N0cmluZztcblxudmFyIE9iamVjdEZ1bmN0aW9uU3RyaW5nID0gZm5Ub1N0cmluZy5jYWxsKCBPYmplY3QgKTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxudmFyIGlzRnVuY3Rpb24gPSBmdW5jdGlvbiBpc0Z1bmN0aW9uKCBvYmogKSB7XG5cbiAgICAgIC8vIFN1cHBvcnQ6IENocm9tZSA8PTU3LCBGaXJlZm94IDw9NTJcbiAgICAgIC8vIEluIHNvbWUgYnJvd3NlcnMsIHR5cGVvZiByZXR1cm5zIFwiZnVuY3Rpb25cIiBmb3IgSFRNTCA8b2JqZWN0PiBlbGVtZW50c1xuICAgICAgLy8gKGkuZS4sIGB0eXBlb2YgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvYmplY3RcIiApID09PSBcImZ1bmN0aW9uXCJgKS5cbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gY2xhc3NpZnkgKmFueSogRE9NIG5vZGUgYXMgYSBmdW5jdGlvbi5cbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIG9iai5ub2RlVHlwZSAhPT0gXCJudW1iZXJcIjtcbiAgfTtcblxuXG52YXIgaXNXaW5kb3cgPSBmdW5jdGlvbiBpc1dpbmRvdyggb2JqICkge1xuXHRcdHJldHVybiBvYmogIT0gbnVsbCAmJiBvYmogPT09IG9iai53aW5kb3c7XG5cdH07XG5cblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG5cblxuXHR2YXIgcHJlc2VydmVkU2NyaXB0QXR0cmlidXRlcyA9IHtcblx0XHR0eXBlOiB0cnVlLFxuXHRcdHNyYzogdHJ1ZSxcblx0XHRub25jZTogdHJ1ZSxcblx0XHRub01vZHVsZTogdHJ1ZVxuXHR9O1xuXG5cdGZ1bmN0aW9uIERPTUV2YWwoIGNvZGUsIG5vZGUsIGRvYyApIHtcblx0XHRkb2MgPSBkb2MgfHwgZG9jdW1lbnQ7XG5cblx0XHR2YXIgaSwgdmFsLFxuXHRcdFx0c2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoIFwic2NyaXB0XCIgKTtcblxuXHRcdHNjcmlwdC50ZXh0ID0gY29kZTtcblx0XHRpZiAoIG5vZGUgKSB7XG5cdFx0XHRmb3IgKCBpIGluIHByZXNlcnZlZFNjcmlwdEF0dHJpYnV0ZXMgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA2NCssIEVkZ2UgMTgrXG5cdFx0XHRcdC8vIFNvbWUgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgXCJub25jZVwiIHByb3BlcnR5IG9uIHNjcmlwdHMuXG5cdFx0XHRcdC8vIE9uIHRoZSBvdGhlciBoYW5kLCBqdXN0IHVzaW5nIGBnZXRBdHRyaWJ1dGVgIGlzIG5vdCBlbm91Z2ggYXNcblx0XHRcdFx0Ly8gdGhlIGBub25jZWAgYXR0cmlidXRlIGlzIHJlc2V0IHRvIGFuIGVtcHR5IHN0cmluZyB3aGVuZXZlciBpdFxuXHRcdFx0XHQvLyBiZWNvbWVzIGJyb3dzaW5nLWNvbnRleHQgY29ubmVjdGVkLlxuXHRcdFx0XHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3doYXR3Zy9odG1sL2lzc3Vlcy8yMzY5XG5cdFx0XHRcdC8vIFNlZSBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnLyNub25jZS1hdHRyaWJ1dGVzXG5cdFx0XHRcdC8vIFRoZSBgbm9kZS5nZXRBdHRyaWJ1dGVgIGNoZWNrIHdhcyBhZGRlZCBmb3IgdGhlIHNha2Ugb2Zcblx0XHRcdFx0Ly8gYGpRdWVyeS5nbG9iYWxFdmFsYCBzbyB0aGF0IGl0IGNhbiBmYWtlIGEgbm9uY2UtY29udGFpbmluZyBub2RlXG5cdFx0XHRcdC8vIHZpYSBhbiBvYmplY3QuXG5cdFx0XHRcdHZhbCA9IG5vZGVbIGkgXSB8fCBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSggaSApO1xuXHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCBpLCB2YWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRkb2MuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0ICkucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggc2NyaXB0ICk7XG5cdH1cblxuXG5mdW5jdGlvbiB0b1R5cGUoIG9iaiApIHtcblx0aWYgKCBvYmogPT0gbnVsbCApIHtcblx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seSAoZnVuY3Rpb25pc2ggUmVnRXhwKVxuXHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdGNsYXNzMnR5cGVbIHRvU3RyaW5nLmNhbGwoIG9iaiApIF0gfHwgXCJvYmplY3RcIiA6XG5cdFx0dHlwZW9mIG9iajtcbn1cbi8qIGdsb2JhbCBTeW1ib2wgKi9cbi8vIERlZmluaW5nIHRoaXMgZ2xvYmFsIGluIC5lc2xpbnRyYy5qc29uIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8gZGVmaW5lIGdsb2JhbCBvbmx5IGZvciB0aGlzIG1vZHVsZVxuXG5cblxudmFyXG5cdHZlcnNpb24gPSBcIjMuNS4xXCIsXG5cblx0Ly8gRGVmaW5lIGEgbG9jYWwgY29weSBvZiBqUXVlcnlcblx0alF1ZXJ5ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXG5cdFx0Ly8gVGhlIGpRdWVyeSBvYmplY3QgaXMgYWN0dWFsbHkganVzdCB0aGUgaW5pdCBjb25zdHJ1Y3RvciAnZW5oYW5jZWQnXG5cdFx0Ly8gTmVlZCBpbml0IGlmIGpRdWVyeSBpcyBjYWxsZWQgKGp1c3QgYWxsb3cgZXJyb3IgdG8gYmUgdGhyb3duIGlmIG5vdCBpbmNsdWRlZClcblx0XHRyZXR1cm4gbmV3IGpRdWVyeS5mbi5pbml0KCBzZWxlY3RvciwgY29udGV4dCApO1xuXHR9O1xuXG5qUXVlcnkuZm4gPSBqUXVlcnkucHJvdG90eXBlID0ge1xuXG5cdC8vIFRoZSBjdXJyZW50IHZlcnNpb24gb2YgalF1ZXJ5IGJlaW5nIHVzZWRcblx0anF1ZXJ5OiB2ZXJzaW9uLFxuXG5cdGNvbnN0cnVjdG9yOiBqUXVlcnksXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXG5cdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdGlmICggbnVtID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRyZXR1cm4gbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXTtcblx0fSxcblxuXHQvLyBUYWtlIGFuIGFycmF5IG9mIGVsZW1lbnRzIGFuZCBwdXNoIGl0IG9udG8gdGhlIHN0YWNrXG5cdC8vIChyZXR1cm5pbmcgdGhlIG5ldyBtYXRjaGVkIGVsZW1lbnQgc2V0KVxuXHRwdXNoU3RhY2s6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblxuXHRcdC8vIEJ1aWxkIGEgbmV3IGpRdWVyeSBtYXRjaGVkIGVsZW1lbnQgc2V0XG5cdFx0dmFyIHJldCA9IGpRdWVyeS5tZXJnZSggdGhpcy5jb25zdHJ1Y3RvcigpLCBlbGVtcyApO1xuXG5cdFx0Ly8gQWRkIHRoZSBvbGQgb2JqZWN0IG9udG8gdGhlIHN0YWNrIChhcyBhIHJlZmVyZW5jZSlcblx0XHRyZXQucHJldk9iamVjdCA9IHRoaXM7XG5cblx0XHQvLyBSZXR1cm4gdGhlIG5ld2x5LWZvcm1lZCBlbGVtZW50IHNldFxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0Ly8gRXhlY3V0ZSBhIGNhbGxiYWNrIGZvciBldmVyeSBlbGVtZW50IGluIHRoZSBtYXRjaGVkIHNldC5cblx0ZWFjaDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZWFjaCggdGhpcywgY2FsbGJhY2sgKTtcblx0fSxcblxuXHRtYXA6IGZ1bmN0aW9uKCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5tYXAoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuIGNhbGxiYWNrLmNhbGwoIGVsZW0sIGksIGVsZW0gKTtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRzbGljZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBzbGljZS5hcHBseSggdGhpcywgYXJndW1lbnRzICkgKTtcblx0fSxcblxuXHRmaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXEoIDAgKTtcblx0fSxcblxuXHRsYXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggLTEgKTtcblx0fSxcblxuXHRldmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeS5ncmVwKCB0aGlzLCBmdW5jdGlvbiggX2VsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gKCBpICsgMSApICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRvZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5LmdyZXAoIHRoaXMsIGZ1bmN0aW9uKCBfZWxlbSwgaSApIHtcblx0XHRcdHJldHVybiBpICUgMjtcblx0XHR9ICkgKTtcblx0fSxcblxuXHRlcTogZnVuY3Rpb24oIGkgKSB7XG5cdFx0dmFyIGxlbiA9IHRoaXMubGVuZ3RoLFxuXHRcdFx0aiA9ICtpICsgKCBpIDwgMCA/IGxlbiA6IDAgKTtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGogPj0gMCAmJiBqIDwgbGVuID8gWyB0aGlzWyBqIF0gXSA6IFtdICk7XG5cdH0sXG5cblx0ZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcmV2T2JqZWN0IHx8IHRoaXMuY29uc3RydWN0b3IoKTtcblx0fSxcblxuXHQvLyBGb3IgaW50ZXJuYWwgdXNlIG9ubHkuXG5cdC8vIEJlaGF2ZXMgbGlrZSBhbiBBcnJheSdzIG1ldGhvZCwgbm90IGxpa2UgYSBqUXVlcnkgbWV0aG9kLlxuXHRwdXNoOiBwdXNoLFxuXHRzb3J0OiBhcnIuc29ydCxcblx0c3BsaWNlOiBhcnIuc3BsaWNlXG59O1xuXG5qUXVlcnkuZXh0ZW5kID0galF1ZXJ5LmZuLmV4dGVuZCA9IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3B0aW9ucywgbmFtZSwgc3JjLCBjb3B5LCBjb3B5SXNBcnJheSwgY2xvbmUsXG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyAwIF0gfHwge30sXG5cdFx0aSA9IDEsXG5cdFx0bGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRkZWVwID0gZmFsc2U7XG5cblx0Ly8gSGFuZGxlIGEgZGVlcCBjb3B5IHNpdHVhdGlvblxuXHRpZiAoIHR5cGVvZiB0YXJnZXQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGRlZXAgPSB0YXJnZXQ7XG5cblx0XHQvLyBTa2lwIHRoZSBib29sZWFuIGFuZCB0aGUgdGFyZ2V0XG5cdFx0dGFyZ2V0ID0gYXJndW1lbnRzWyBpIF0gfHwge307XG5cdFx0aSsrO1xuXHR9XG5cblx0Ly8gSGFuZGxlIGNhc2Ugd2hlbiB0YXJnZXQgaXMgYSBzdHJpbmcgb3Igc29tZXRoaW5nIChwb3NzaWJsZSBpbiBkZWVwIGNvcHkpXG5cdGlmICggdHlwZW9mIHRhcmdldCAhPT0gXCJvYmplY3RcIiAmJiAhaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRjb3B5ID0gb3B0aW9uc1sgbmFtZSBdO1xuXG5cdFx0XHRcdC8vIFByZXZlbnQgT2JqZWN0LnByb3RvdHlwZSBwb2xsdXRpb25cblx0XHRcdFx0Ly8gUHJldmVudCBuZXZlci1lbmRpbmcgbG9vcFxuXHRcdFx0XHRpZiAoIG5hbWUgPT09IFwiX19wcm90b19fXCIgfHwgdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBBcnJheS5pc0FycmF5KCBjb3B5ICkgKSApICkge1xuXHRcdFx0XHRcdHNyYyA9IHRhcmdldFsgbmFtZSBdO1xuXG5cdFx0XHRcdFx0Ly8gRW5zdXJlIHByb3BlciB0eXBlIGZvciB0aGUgc291cmNlIHZhbHVlXG5cdFx0XHRcdFx0aWYgKCBjb3B5SXNBcnJheSAmJiAhQXJyYXkuaXNBcnJheSggc3JjICkgKSB7XG5cdFx0XHRcdFx0XHRjbG9uZSA9IFtdO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICFjb3B5SXNBcnJheSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApICkge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSB7fTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmM7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvcHlJc0FycmF5ID0gZmFsc2U7XG5cblx0XHRcdFx0XHQvLyBOZXZlciBtb3ZlIG9yaWdpbmFsIG9iamVjdHMsIGNsb25lIHRoZW1cblx0XHRcdFx0XHR0YXJnZXRbIG5hbWUgXSA9IGpRdWVyeS5leHRlbmQoIGRlZXAsIGNsb25lLCBjb3B5ICk7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgYnJpbmcgaW4gdW5kZWZpbmVkIHZhbHVlc1xuXHRcdFx0XHR9IGVsc2UgaWYgKCBjb3B5ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBjb3B5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmV0dXJuIHRoZSBtb2RpZmllZCBvYmplY3Rcblx0cmV0dXJuIHRhcmdldDtcbn07XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBVbmlxdWUgZm9yIGVhY2ggY29weSBvZiBqUXVlcnkgb24gdGhlIHBhZ2Vcblx0ZXhwYW5kbzogXCJqUXVlcnlcIiArICggdmVyc2lvbiArIE1hdGgucmFuZG9tKCkgKS5yZXBsYWNlKCAvXFxEL2csIFwiXCIgKSxcblxuXHQvLyBBc3N1bWUgalF1ZXJ5IGlzIHJlYWR5IHdpdGhvdXQgdGhlIHJlYWR5IG1vZHVsZVxuXHRpc1JlYWR5OiB0cnVlLFxuXG5cdGVycm9yOiBmdW5jdGlvbiggbXNnICkge1xuXHRcdHRocm93IG5ldyBFcnJvciggbXNnICk7XG5cdH0sXG5cblx0bm9vcDogZnVuY3Rpb24oKSB7fSxcblxuXHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBwcm90bywgQ3RvcjtcblxuXHRcdC8vIERldGVjdCBvYnZpb3VzIG5lZ2F0aXZlc1xuXHRcdC8vIFVzZSB0b1N0cmluZyBpbnN0ZWFkIG9mIGpRdWVyeS50eXBlIHRvIGNhdGNoIGhvc3Qgb2JqZWN0c1xuXHRcdGlmICggIW9iaiB8fCB0b1N0cmluZy5jYWxsKCBvYmogKSAhPT0gXCJbb2JqZWN0IE9iamVjdF1cIiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRwcm90byA9IGdldFByb3RvKCBvYmogKTtcblxuXHRcdC8vIE9iamVjdHMgd2l0aCBubyBwcm90b3R5cGUgKGUuZy4sIGBPYmplY3QuY3JlYXRlKCBudWxsIClgKSBhcmUgcGxhaW5cblx0XHRpZiAoICFwcm90byApIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdC8vIE9iamVjdHMgd2l0aCBwcm90b3R5cGUgYXJlIHBsYWluIGlmZiB0aGV5IHdlcmUgY29uc3RydWN0ZWQgYnkgYSBnbG9iYWwgT2JqZWN0IGZ1bmN0aW9uXG5cdFx0Q3RvciA9IGhhc093bi5jYWxsKCBwcm90bywgXCJjb25zdHJ1Y3RvclwiICkgJiYgcHJvdG8uY29uc3RydWN0b3I7XG5cdFx0cmV0dXJuIHR5cGVvZiBDdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgZm5Ub1N0cmluZy5jYWxsKCBDdG9yICkgPT09IE9iamVjdEZ1bmN0aW9uU3RyaW5nO1xuXHR9LFxuXG5cdGlzRW1wdHlPYmplY3Q6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0dmFyIG5hbWU7XG5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgcHJvdmlkZWQgY29udGV4dDsgZmFsbHMgYmFjayB0byB0aGUgZ2xvYmFsIG9uZVxuXHQvLyBpZiBub3Qgc3BlY2lmaWVkLlxuXHRnbG9iYWxFdmFsOiBmdW5jdGlvbiggY29kZSwgb3B0aW9ucywgZG9jICkge1xuXHRcdERPTUV2YWwoIGNvZGUsIHsgbm9uY2U6IG9wdGlvbnMgJiYgb3B0aW9ucy5ub25jZSB9LCBkb2MgKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIHJlc3VsdHMgaXMgZm9yIGludGVybmFsIHVzYWdlIG9ubHlcblx0bWFrZUFycmF5OiBmdW5jdGlvbiggYXJyLCByZXN1bHRzICkge1xuXHRcdHZhciByZXQgPSByZXN1bHRzIHx8IFtdO1xuXG5cdFx0aWYgKCBhcnIgIT0gbnVsbCApIHtcblx0XHRcdGlmICggaXNBcnJheUxpa2UoIE9iamVjdCggYXJyICkgKSApIHtcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCByZXQsXG5cdFx0XHRcdFx0dHlwZW9mIGFyciA9PT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0WyBhcnIgXSA6IGFyclxuXHRcdFx0XHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5jYWxsKCByZXQsIGFyciApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiByZXQ7XG5cdH0sXG5cblx0aW5BcnJheTogZnVuY3Rpb24oIGVsZW0sIGFyciwgaSApIHtcblx0XHRyZXR1cm4gYXJyID09IG51bGwgPyAtMSA6IGluZGV4T2YuY2FsbCggYXJyLCBlbGVtLCBpICk7XG5cdH0sXG5cblx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0bWVyZ2U6IGZ1bmN0aW9uKCBmaXJzdCwgc2Vjb25kICkge1xuXHRcdHZhciBsZW4gPSArc2Vjb25kLmxlbmd0aCxcblx0XHRcdGogPSAwLFxuXHRcdFx0aSA9IGZpcnN0Lmxlbmd0aDtcblxuXHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0Zmlyc3RbIGkrKyBdID0gc2Vjb25kWyBqIF07XG5cdFx0fVxuXG5cdFx0Zmlyc3QubGVuZ3RoID0gaTtcblxuXHRcdHJldHVybiBmaXJzdDtcblx0fSxcblxuXHRncmVwOiBmdW5jdGlvbiggZWxlbXMsIGNhbGxiYWNrLCBpbnZlcnQgKSB7XG5cdFx0dmFyIGNhbGxiYWNrSW52ZXJzZSxcblx0XHRcdG1hdGNoZXMgPSBbXSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0bGVuZ3RoID0gZWxlbXMubGVuZ3RoLFxuXHRcdFx0Y2FsbGJhY2tFeHBlY3QgPSAhaW52ZXJ0O1xuXG5cdFx0Ly8gR28gdGhyb3VnaCB0aGUgYXJyYXksIG9ubHkgc2F2aW5nIHRoZSBpdGVtc1xuXHRcdC8vIHRoYXQgcGFzcyB0aGUgdmFsaWRhdG9yIGZ1bmN0aW9uXG5cdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRjYWxsYmFja0ludmVyc2UgPSAhY2FsbGJhY2soIGVsZW1zWyBpIF0sIGkgKTtcblx0XHRcdGlmICggY2FsbGJhY2tJbnZlcnNlICE9PSBjYWxsYmFja0V4cGVjdCApIHtcblx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBlbGVtc1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1hdGNoZXM7XG5cdH0sXG5cblx0Ly8gYXJnIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1hcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgYXJnICkge1xuXHRcdHZhciBsZW5ndGgsIHZhbHVlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRyZXQgPSBbXTtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCB0cmFuc2xhdGluZyBlYWNoIG9mIHRoZSBpdGVtcyB0byB0aGVpciBuZXcgdmFsdWVzXG5cdFx0aWYgKCBpc0FycmF5TGlrZSggZWxlbXMgKSApIHtcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdC8vIEdvIHRocm91Z2ggZXZlcnkga2V5IG9uIHRoZSBvYmplY3QsXG5cdFx0fSBlbHNlIHtcblx0XHRcdGZvciAoIGkgaW4gZWxlbXMgKSB7XG5cdFx0XHRcdHZhbHVlID0gY2FsbGJhY2soIGVsZW1zWyBpIF0sIGksIGFyZyApO1xuXG5cdFx0XHRcdGlmICggdmFsdWUgIT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXQucHVzaCggdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0XHRyZXR1cm4gZmxhdCggcmV0ICk7XG5cdH0sXG5cblx0Ly8gQSBnbG9iYWwgR1VJRCBjb3VudGVyIGZvciBvYmplY3RzXG5cdGd1aWQ6IDEsXG5cblx0Ly8galF1ZXJ5LnN1cHBvcnQgaXMgbm90IHVzZWQgaW4gQ29yZSBidXQgb3RoZXIgcHJvamVjdHMgYXR0YWNoIHRoZWlyXG5cdC8vIHByb3BlcnRpZXMgdG8gaXQgc28gaXQgbmVlZHMgdG8gZXhpc3QuXG5cdHN1cHBvcnQ6IHN1cHBvcnRcbn0gKTtcblxuaWYgKCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgKSB7XG5cdGpRdWVyeS5mblsgU3ltYm9sLml0ZXJhdG9yIF0gPSBhcnJbIFN5bWJvbC5pdGVyYXRvciBdO1xufVxuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cdGNsYXNzMnR5cGVbIFwiW29iamVjdCBcIiArIG5hbWUgKyBcIl1cIiBdID0gbmFtZS50b0xvd2VyQ2FzZSgpO1xufSApO1xuXG5mdW5jdGlvbiBpc0FycmF5TGlrZSggb2JqICkge1xuXG5cdC8vIFN1cHBvcnQ6IHJlYWwgaU9TIDguMiBvbmx5IChub3QgcmVwcm9kdWNpYmxlIGluIHNpbXVsYXRvcilcblx0Ly8gYGluYCBjaGVjayB1c2VkIHRvIHByZXZlbnQgSklUIGVycm9yIChnaC0yMTQ1KVxuXHQvLyBoYXNPd24gaXNuJ3QgdXNlZCBoZXJlIGR1ZSB0byBmYWxzZSBuZWdhdGl2ZXNcblx0Ly8gcmVnYXJkaW5nIE5vZGVsaXN0IGxlbmd0aCBpbiBJRVxuXHR2YXIgbGVuZ3RoID0gISFvYmogJiYgXCJsZW5ndGhcIiBpbiBvYmogJiYgb2JqLmxlbmd0aCxcblx0XHR0eXBlID0gdG9UeXBlKCBvYmogKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIG9iaiApIHx8IGlzV2luZG93KCBvYmogKSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRyZXR1cm4gdHlwZSA9PT0gXCJhcnJheVwiIHx8IGxlbmd0aCA9PT0gMCB8fFxuXHRcdHR5cGVvZiBsZW5ndGggPT09IFwibnVtYmVyXCIgJiYgbGVuZ3RoID4gMCAmJiAoIGxlbmd0aCAtIDEgKSBpbiBvYmo7XG59XG52YXIgU2l6emxlID1cbi8qIVxuICogU2l6emxlIENTUyBTZWxlY3RvciBFbmdpbmUgdjIuMy41XG4gKiBodHRwczovL3NpenpsZWpzLmNvbS9cbiAqXG4gKiBDb3B5cmlnaHQgSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzXG4gKiBSZWxlYXNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2VcbiAqIGh0dHBzOi8vanMuZm91bmRhdGlvbi9cbiAqXG4gKiBEYXRlOiAyMDIwLTAzLTE0XG4gKi9cbiggZnVuY3Rpb24oIHdpbmRvdyApIHtcbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdG5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHRzb3J0T3JkZXIgPSBmdW5jdGlvbiggYSwgYiApIHtcblx0XHRpZiAoIGEgPT09IGIgKSB7XG5cdFx0XHRoYXNEdXBsaWNhdGUgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICgge30gKS5oYXNPd25Qcm9wZXJ0eSxcblx0YXJyID0gW10sXG5cdHBvcCA9IGFyci5wb3AsXG5cdHB1c2hOYXRpdmUgPSBhcnIucHVzaCxcblx0cHVzaCA9IGFyci5wdXNoLFxuXHRzbGljZSA9IGFyci5zbGljZSxcblxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cHM6Ly9qc3BlcmYuY29tL3Rob3ItaW5kZXhvZi12cy1mb3IvNVxuXHRpbmRleE9mID0gZnVuY3Rpb24oIGxpc3QsIGVsZW0gKSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0bGVuID0gbGlzdC5sZW5ndGg7XG5cdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRpZiAoIGxpc3RbIGkgXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufFwiICtcblx0XHRcImlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwczovL3d3dy53My5vcmcvVFIvY3NzLXN5bnRheC0zLyNpZGVudC10b2tlbi1kaWFncmFtXG5cdGlkZW50aWZpZXIgPSBcIig/OlxcXFxcXFxcW1xcXFxkYS1mQS1GXXsxLDZ9XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcIj98XFxcXFxcXFxbXlxcXFxyXFxcXG5cXFxcZl18W1xcXFx3LV18W15cXDAtXFxcXHg3Zl0pK1wiLFxuXG5cdC8vIEF0dHJpYnV0ZSBzZWxlY3RvcnM6IGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jYXR0cmlidXRlLXNlbGVjdG9yc1xuXHRhdHRyaWJ1dGVzID0gXCJcXFxcW1wiICsgd2hpdGVzcGFjZSArIFwiKihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXG5cdFx0Ly8gXCJBdHRyaWJ1dGUgdmFsdWVzIG11c3QgYmUgQ1NTIGlkZW50aWZpZXJzIFtjYXB0dXJlIDVdXG5cdFx0Ly8gb3Igc3RyaW5ncyBbY2FwdHVyZSAzIG9yIGNhcHR1cmUgNF1cIlxuXHRcdFwiKig/OicoKD86XFxcXFxcXFwufFteXFxcXFxcXFwnXSkqKSd8XFxcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXFxcXCJdKSopXFxcInwoXCIgKyBpZGVudGlmaWVyICsgXCIpKXwpXCIgK1xuXHRcdHdoaXRlc3BhY2UgKyBcIipcXFxcXVwiLFxuXG5cdHBzZXVkb3MgPSBcIjooXCIgKyBpZGVudGlmaWVyICsgXCIpKD86XFxcXCgoXCIgK1xuXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblxuXHRcdC8vIDIuIHNpbXBsZSAoY2FwdHVyZSA2KVxuXHRcdFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcKClbXFxcXF1dfFwiICsgYXR0cmlidXRlcyArIFwiKSopfFwiICtcblxuXHRcdC8vIDMuIGFueXRoaW5nIGVsc2UgKGNhcHR1cmUgMilcblx0XHRcIi4qXCIgK1xuXHRcdFwiKVxcXFwpfClcIixcblxuXHQvLyBMZWFkaW5nIGFuZCBub24tZXNjYXBlZCB0cmFpbGluZyB3aGl0ZXNwYWNlLCBjYXB0dXJpbmcgc29tZSBub24td2hpdGVzcGFjZSBjaGFyYWN0ZXJzIHByZWNlZGluZyB0aGUgbGF0dGVyXG5cdHJ3aGl0ZXNwYWNlID0gbmV3IFJlZ0V4cCggd2hpdGVzcGFjZSArIFwiK1wiLCBcImdcIiApLFxuXHRydHJpbSA9IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiK3woKD86XnxbXlxcXFxcXFxcXSkoPzpcXFxcXFxcXC4pKilcIiArXG5cdFx0d2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArXG5cdFx0XCIqXCIgKSxcblx0cmRlc2NlbmQgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCJ8PlwiICksXG5cblx0cnBzZXVkbyA9IG5ldyBSZWdFeHAoIHBzZXVkb3MgKSxcblx0cmlkZW50aWZpZXIgPSBuZXcgUmVnRXhwKCBcIl5cIiArIGlkZW50aWZpZXIgKyBcIiRcIiApLFxuXG5cdG1hdGNoRXhwciA9IHtcblx0XHRcIklEXCI6IG5ldyBSZWdFeHAoIFwiXiMoXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIkNMQVNTXCI6IG5ldyBSZWdFeHAoIFwiXlxcXFwuKFwiICsgaWRlbnRpZmllciArIFwiKVwiICksXG5cdFx0XCJUQUdcIjogbmV3IFJlZ0V4cCggXCJeKFwiICsgaWRlbnRpZmllciArIFwifFsqXSlcIiApLFxuXHRcdFwiQVRUUlwiOiBuZXcgUmVnRXhwKCBcIl5cIiArIGF0dHJpYnV0ZXMgKSxcblx0XHRcIlBTRVVET1wiOiBuZXcgUmVnRXhwKCBcIl5cIiArIHBzZXVkb3MgKSxcblx0XHRcIkNISUxEXCI6IG5ldyBSZWdFeHAoIFwiXjoob25seXxmaXJzdHxsYXN0fG50aHxudGgtbGFzdCktKGNoaWxkfG9mLXR5cGUpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKGV2ZW58b2RkfCgoWystXXwpKFxcXFxkKilufClcIiArIHdoaXRlc3BhY2UgKyBcIiooPzooWystXXwpXCIgK1xuXHRcdFx0d2hpdGVzcGFjZSArIFwiKihcXFxcZCspfCkpXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXCl8KVwiLCBcImlcIiApLFxuXHRcdFwiYm9vbFwiOiBuZXcgUmVnRXhwKCBcIl4oPzpcIiArIGJvb2xlYW5zICsgXCIpJFwiLCBcImlcIiApLFxuXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIipbPit+XXw6KGV2ZW58b2RkfGVxfGd0fGx0fG50aHxmaXJzdHxsYXN0KSg/OlxcXFwoXCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFwiKigoPzotXFxcXGQpP1xcXFxkKilcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpKD89W14tXXwkKVwiLCBcImlcIiApXG5cdH0sXG5cblx0cmh0bWwgPSAvSFRNTCQvaSxcblx0cmlucHV0cyA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGJ1dHRvbikkL2ksXG5cdHJoZWFkZXIgPSAvXmhcXGQkL2ksXG5cblx0cm5hdGl2ZSA9IC9eW157XStcXHtcXHMqXFxbbmF0aXZlIFxcdy8sXG5cblx0Ly8gRWFzaWx5LXBhcnNlYWJsZS9yZXRyaWV2YWJsZSBJRCBvciBUQUcgb3IgQ0xBU1Mgc2VsZWN0b3JzXG5cdHJxdWlja0V4cHIgPSAvXig/OiMoW1xcdy1dKyl8KFxcdyspfFxcLihbXFx3LV0rKSkkLyxcblxuXHRyc2libGluZyA9IC9bK35dLyxcblxuXHQvLyBDU1MgZXNjYXBlc1xuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjZXNjYXBlZC1jaGFyYWN0ZXJzXG5cdHJ1bmVzY2FwZSA9IG5ldyBSZWdFeHAoIFwiXFxcXFxcXFxbXFxcXGRhLWZBLUZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98XFxcXFxcXFwoW15cXFxcclxcXFxuXFxcXGZdKVwiLCBcImdcIiApLFxuXHRmdW5lc2NhcGUgPSBmdW5jdGlvbiggZXNjYXBlLCBub25IZXggKSB7XG5cdFx0dmFyIGhpZ2ggPSBcIjB4XCIgKyBlc2NhcGUuc2xpY2UoIDEgKSAtIDB4MTAwMDA7XG5cblx0XHRyZXR1cm4gbm9uSGV4ID9cblxuXHRcdFx0Ly8gU3RyaXAgdGhlIGJhY2tzbGFzaCBwcmVmaXggZnJvbSBhIG5vbi1oZXggZXNjYXBlIHNlcXVlbmNlXG5cdFx0XHRub25IZXggOlxuXG5cdFx0XHQvLyBSZXBsYWNlIGEgaGV4YWRlY2ltYWwgZXNjYXBlIHNlcXVlbmNlIHdpdGggdGhlIGVuY29kZWQgVW5pY29kZSBjb2RlIHBvaW50XG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTExK1xuXHRcdFx0Ly8gRm9yIHZhbHVlcyBvdXRzaWRlIHRoZSBCYXNpYyBNdWx0aWxpbmd1YWwgUGxhbmUgKEJNUCksIG1hbnVhbGx5IGNvbnN0cnVjdCBhXG5cdFx0XHQvLyBzdXJyb2dhdGUgcGFpclxuXHRcdFx0aGlnaCA8IDAgP1xuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoICsgMHgxMDAwMCApIDpcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCA+PiAxMCB8IDB4RDgwMCwgaGlnaCAmIDB4M0ZGIHwgMHhEQzAwICk7XG5cdH0sXG5cblx0Ly8gQ1NTIHN0cmluZy9pZGVudGlmaWVyIHNlcmlhbGl6YXRpb25cblx0Ly8gaHR0cHM6Ly9kcmFmdHMuY3Nzd2cub3JnL2Nzc29tLyNjb21tb24tc2VyaWFsaXppbmctaWRpb21zXG5cdHJjc3Nlc2NhcGUgPSAvKFtcXDAtXFx4MWZcXHg3Zl18Xi0/XFxkKXxeLSR8W15cXDAtXFx4MWZcXHg3Zi1cXHVGRkZGXFx3LV0vZyxcblx0ZmNzc2VzY2FwZSA9IGZ1bmN0aW9uKCBjaCwgYXNDb2RlUG9pbnQgKSB7XG5cdFx0aWYgKCBhc0NvZGVQb2ludCApIHtcblxuXHRcdFx0Ly8gVSswMDAwIE5VTEwgYmVjb21lcyBVK0ZGRkQgUkVQTEFDRU1FTlQgQ0hBUkFDVEVSXG5cdFx0XHRpZiAoIGNoID09PSBcIlxcMFwiICkge1xuXHRcdFx0XHRyZXR1cm4gXCJcXHVGRkZEXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnRyb2wgY2hhcmFjdGVycyBhbmQgKGRlcGVuZGVudCB1cG9uIHBvc2l0aW9uKSBudW1iZXJzIGdldCBlc2NhcGVkIGFzIGNvZGUgcG9pbnRzXG5cdFx0XHRyZXR1cm4gY2guc2xpY2UoIDAsIC0xICkgKyBcIlxcXFxcIiArXG5cdFx0XHRcdGNoLmNoYXJDb2RlQXQoIGNoLmxlbmd0aCAtIDEgKS50b1N0cmluZyggMTYgKSArIFwiIFwiO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyIHBvdGVudGlhbGx5LXNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBnZXQgYmFja3NsYXNoLWVzY2FwZWRcblx0XHRyZXR1cm4gXCJcXFxcXCIgKyBjaDtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fSxcblxuXHRpbkRpc2FibGVkRmllbGRzZXQgPSBhZGRDb21iaW5hdG9yKFxuXHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWUgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImZpZWxkc2V0XCI7XG5cdFx0fSxcblx0XHR7IGRpcjogXCJwYXJlbnROb2RlXCIsIG5leHQ6IFwibGVnZW5kXCIgfVxuXHQpO1xuXG4vLyBPcHRpbWl6ZSBmb3IgcHVzaC5hcHBseSggXywgTm9kZUxpc3QgKVxudHJ5IHtcblx0cHVzaC5hcHBseShcblx0XHQoIGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkgKSxcblx0XHRwcmVmZXJyZWREb2MuY2hpbGROb2Rlc1xuXHQpO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRhcnJbIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzLmxlbmd0aCBdLm5vZGVUeXBlO1xufSBjYXRjaCAoIGUgKSB7XG5cdHB1c2ggPSB7IGFwcGx5OiBhcnIubGVuZ3RoID9cblxuXHRcdC8vIExldmVyYWdlIHNsaWNlIGlmIHBvc3NpYmxlXG5cdFx0ZnVuY3Rpb24oIHRhcmdldCwgZWxzICkge1xuXHRcdFx0cHVzaE5hdGl2ZS5hcHBseSggdGFyZ2V0LCBzbGljZS5jYWxsKCBlbHMgKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXG5cdFx0XHQvLyBDYW4ndCB0cnVzdCBOb2RlTGlzdC5sZW5ndGhcblx0XHRcdHdoaWxlICggKCB0YXJnZXRbIGorKyBdID0gZWxzWyBpKysgXSApICkge31cblx0XHRcdHRhcmdldC5sZW5ndGggPSBqIC0gMTtcblx0XHR9XG5cdH07XG59XG5cbmZ1bmN0aW9uIFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBtLCBpLCBlbGVtLCBuaWQsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdGNvbnRleHQgPSBjb250ZXh0IHx8IGRvY3VtZW50O1xuXG5cdFx0aWYgKCBkb2N1bWVudElzSFRNTCApIHtcblxuXHRcdFx0Ly8gSWYgdGhlIHNlbGVjdG9yIGlzIHN1ZmZpY2llbnRseSBzaW1wbGUsIHRyeSB1c2luZyBhIFwiZ2V0KkJ5KlwiIERPTSBtZXRob2Rcblx0XHRcdC8vIChleGNlcHRpbmcgRG9jdW1lbnRGcmFnbWVudCBjb250ZXh0LCB3aGVyZSB0aGUgbWV0aG9kcyBkb24ndCBleGlzdClcblx0XHRcdGlmICggbm9kZVR5cGUgIT09IDExICYmICggbWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkgKSApIHtcblxuXHRcdFx0XHQvLyBJRCBzZWxlY3RvclxuXHRcdFx0XHRpZiAoICggbSA9IG1hdGNoWyAxIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIERvY3VtZW50IGNvbnRleHRcblx0XHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0XHQvLyBnZXRFbGVtZW50QnlJZCBjYW4gbWF0Y2ggZWxlbWVudHMgYnkgbmFtZSBpbnN0ZWFkIG9mIElEXG5cdFx0XHRcdFx0XHRcdGlmICggZWxlbS5pZCA9PT0gbSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXN1bHRzLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBFbGVtZW50IGNvbnRleHRcblx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSwgT3BlcmEsIFdlYmtpdFxuXHRcdFx0XHRcdFx0Ly8gVE9ETzogaWRlbnRpZnkgdmVyc2lvbnNcblx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdGlmICggbmV3Q29udGV4dCAmJiAoIGVsZW0gPSBuZXdDb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkgKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAyIF0gKSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggc2VsZWN0b3IgKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXG5cdFx0XHRcdC8vIENsYXNzIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoICggbSA9IG1hdGNoWyAzIF0gKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IW5vbm5hdGl2ZVNlbGVjdG9yQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoICFyYnVnZ3lRU0EgfHwgIXJidWdneVFTQS50ZXN0KCBzZWxlY3RvciApICkgJiZcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA4IG9ubHlcblx0XHRcdFx0Ly8gRXhjbHVkZSBvYmplY3QgZWxlbWVudHNcblx0XHRcdFx0KCBub2RlVHlwZSAhPT0gMSB8fCBjb250ZXh0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgIT09IFwib2JqZWN0XCIgKSApIHtcblxuXHRcdFx0XHRuZXdTZWxlY3RvciA9IHNlbGVjdG9yO1xuXHRcdFx0XHRuZXdDb250ZXh0ID0gY29udGV4dDtcblxuXHRcdFx0XHQvLyBxU0EgY29uc2lkZXJzIGVsZW1lbnRzIG91dHNpZGUgYSBzY29waW5nIHJvb3Qgd2hlbiBldmFsdWF0aW5nIGNoaWxkIG9yXG5cdFx0XHRcdC8vIGRlc2NlbmRhbnQgY29tYmluYXRvcnMsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnQuXG5cdFx0XHRcdC8vIEluIHN1Y2ggY2FzZXMsIHdlIHdvcmsgYXJvdW5kIHRoZSBiZWhhdmlvciBieSBwcmVmaXhpbmcgZXZlcnkgc2VsZWN0b3IgaW4gdGhlXG5cdFx0XHRcdC8vIGxpc3Qgd2l0aCBhbiBJRCBzZWxlY3RvciByZWZlcmVuY2luZyB0aGUgc2NvcGUgY29udGV4dC5cblx0XHRcdFx0Ly8gVGhlIHRlY2huaXF1ZSBoYXMgdG8gYmUgdXNlZCBhcyB3ZWxsIHdoZW4gYSBsZWFkaW5nIGNvbWJpbmF0b3IgaXMgdXNlZFxuXHRcdFx0XHQvLyBhcyBzdWNoIHNlbGVjdG9ycyBhcmUgbm90IHJlY29nbml6ZWQgYnkgcXVlcnlTZWxlY3RvckFsbC5cblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgdGVjaG5pcXVlLlxuXHRcdFx0XHRpZiAoIG5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCByZGVzY2VuZC50ZXN0KCBzZWxlY3RvciApIHx8IHJjb21iaW5hdG9ycy50ZXN0KCBzZWxlY3RvciApICkgKSB7XG5cblx0XHRcdFx0XHQvLyBFeHBhbmQgY29udGV4dCBmb3Igc2libGluZyBzZWxlY3RvcnNcblx0XHRcdFx0XHRuZXdDb250ZXh0ID0gcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHxcblx0XHRcdFx0XHRcdGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBXZSBjYW4gdXNlIDpzY29wZSBpbnN0ZWFkIG9mIHRoZSBJRCBoYWNrIGlmIHRoZSBicm93c2VyXG5cdFx0XHRcdFx0Ly8gc3VwcG9ydHMgaXQgJiBpZiB3ZSdyZSBub3QgY2hhbmdpbmcgdGhlIGNvbnRleHQuXG5cdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICE9PSBjb250ZXh0IHx8ICFzdXBwb3J0LnNjb3BlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBDYXB0dXJlIHRoZSBjb250ZXh0IElELCBzZXR0aW5nIGl0IGZpcnN0IGlmIG5lY2Vzc2FyeVxuXHRcdFx0XHRcdFx0aWYgKCAoIG5pZCA9IGNvbnRleHQuZ2V0QXR0cmlidXRlKCBcImlkXCIgKSApICkge1xuXHRcdFx0XHRcdFx0XHRuaWQgPSBuaWQucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5zZXRBdHRyaWJ1dGUoIFwiaWRcIiwgKCBuaWQgPSBleHBhbmRvICkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmVmaXggZXZlcnkgc2VsZWN0b3IgaW4gdGhlIGxpc3Rcblx0XHRcdFx0XHRncm91cHMgPSB0b2tlbml6ZSggc2VsZWN0b3IgKTtcblx0XHRcdFx0XHRpID0gZ3JvdXBzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGdyb3Vwc1sgaSBdID0gKCBuaWQgPyBcIiNcIiArIG5pZCA6IFwiOnNjb3BlXCIgKSArIFwiIFwiICtcblx0XHRcdFx0XHRcdFx0dG9TZWxlY3RvciggZ3JvdXBzWyBpIF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBncm91cHMuam9pbiggXCIsXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdG5ld0NvbnRleHQucXVlcnlTZWxlY3RvckFsbCggbmV3U2VsZWN0b3IgKVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdH0gY2F0Y2ggKCBxc2FFcnJvciApIHtcblx0XHRcdFx0XHRub25uYXRpdmVTZWxlY3RvckNhY2hlKCBzZWxlY3RvciwgdHJ1ZSApO1xuXHRcdFx0XHR9IGZpbmFsbHkge1xuXHRcdFx0XHRcdGlmICggbmlkID09PSBleHBhbmRvICkge1xuXHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXG5cdFx0Ly8gVXNlIChrZXkgKyBcIiBcIikgdG8gYXZvaWQgY29sbGlzaW9uIHdpdGggbmF0aXZlIHByb3RvdHlwZSBwcm9wZXJ0aWVzIChzZWUgSXNzdWUgIzE1Nylcblx0XHRpZiAoIGtleXMucHVzaCgga2V5ICsgXCIgXCIgKSA+IEV4cHIuY2FjaGVMZW5ndGggKSB7XG5cblx0XHRcdC8vIE9ubHkga2VlcCB0aGUgbW9zdCByZWNlbnQgZW50cmllc1xuXHRcdFx0ZGVsZXRlIGNhY2hlWyBrZXlzLnNoaWZ0KCkgXTtcblx0XHR9XG5cdFx0cmV0dXJuICggY2FjaGVbIGtleSArIFwiIFwiIF0gPSB2YWx1ZSApO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGVsZW1lbnQgYW5kIHJldHVybnMgYSBib29sZWFuIHJlc3VsdFxuICovXG5mdW5jdGlvbiBhc3NlcnQoIGZuICkge1xuXHR2YXIgZWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImZpZWxkc2V0XCIgKTtcblxuXHR0cnkge1xuXHRcdHJldHVybiAhIWZuKCBlbCApO1xuXHR9IGNhdGNoICggZSApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0gZmluYWxseSB7XG5cblx0XHQvLyBSZW1vdmUgZnJvbSBpdHMgcGFyZW50IGJ5IGRlZmF1bHRcblx0XHRpZiAoIGVsLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRlbC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBlbCApO1xuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZWwgPSBudWxsO1xuXHR9XG59XG5cbi8qKlxuICogQWRkcyB0aGUgc2FtZSBoYW5kbGVyIGZvciBhbGwgb2YgdGhlIHNwZWNpZmllZCBhdHRyc1xuICogQHBhcmFtIHtTdHJpbmd9IGF0dHJzIFBpcGUtc2VwYXJhdGVkIGxpc3Qgb2YgYXR0cmlidXRlc1xuICogQHBhcmFtIHtGdW5jdGlvbn0gaGFuZGxlciBUaGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBhcHBsaWVkXG4gKi9cbmZ1bmN0aW9uIGFkZEhhbmRsZSggYXR0cnMsIGhhbmRsZXIgKSB7XG5cdHZhciBhcnIgPSBhdHRycy5zcGxpdCggXCJ8XCIgKSxcblx0XHRpID0gYXJyLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRFeHByLmF0dHJIYW5kbGVbIGFyclsgaSBdIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdGEuc291cmNlSW5kZXggLSBiLnNvdXJjZUluZGV4O1xuXG5cdC8vIFVzZSBJRSBzb3VyY2VJbmRleCBpZiBhdmFpbGFibGUgb24gYm90aCBub2Rlc1xuXHRpZiAoIGRpZmYgKSB7XG5cdFx0cmV0dXJuIGRpZmY7XG5cdH1cblxuXHQvLyBDaGVjayBpZiBiIGZvbGxvd3MgYVxuXHRpZiAoIGN1ciApIHtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLm5leHRTaWJsaW5nICkgKSB7XG5cdFx0XHRpZiAoIGN1ciA9PT0gYiApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBhID8gMSA6IC0xO1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgaW5wdXQgdHlwZXNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUlucHV0UHNldWRvKCB0eXBlICkge1xuXHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0cmV0dXJuIG5hbWUgPT09IFwiaW5wdXRcIiAmJiBlbGVtLnR5cGUgPT09IHR5cGU7XG5cdH07XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBidXR0b25zXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICovXG5mdW5jdGlvbiBjcmVhdGVCdXR0b25Qc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gKCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJidXR0b25cIiApICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIDplbmFibGVkLzpkaXNhYmxlZFxuICogQHBhcmFtIHtCb29sZWFufSBkaXNhYmxlZCB0cnVlIGZvciA6ZGlzYWJsZWQ7IGZhbHNlIGZvciA6ZW5hYmxlZFxuICovXG5mdW5jdGlvbiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZGlzYWJsZWQgKSB7XG5cblx0Ly8gS25vd24gOmRpc2FibGVkIGZhbHNlIHBvc2l0aXZlczogZmllbGRzZXRbZGlzYWJsZWRdID4gbGVnZW5kOm50aC1vZi10eXBlKG4rMikgOmNhbi1kaXNhYmxlXG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE9ubHkgY2VydGFpbiBlbGVtZW50cyBjYW4gbWF0Y2ggOmVuYWJsZWQgb3IgOmRpc2FibGVkXG5cdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc2NyaXB0aW5nLmh0bWwjc2VsZWN0b3ItZW5hYmxlZFxuXHRcdC8vIGh0dHBzOi8vaHRtbC5zcGVjLndoYXR3Zy5vcmcvbXVsdGlwYWdlL3NjcmlwdGluZy5odG1sI3NlbGVjdG9yLWRpc2FibGVkXG5cdFx0aWYgKCBcImZvcm1cIiBpbiBlbGVtICkge1xuXG5cdFx0XHQvLyBDaGVjayBmb3IgaW5oZXJpdGVkIGRpc2FibGVkbmVzcyBvbiByZWxldmFudCBub24tZGlzYWJsZWQgZWxlbWVudHM6XG5cdFx0XHQvLyAqIGxpc3RlZCBmb3JtLWFzc29jaWF0ZWQgZWxlbWVudHMgaW4gYSBkaXNhYmxlZCBmaWVsZHNldFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NhdGVnb3J5LWxpc3RlZFxuXHRcdFx0Ly8gICBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9mb3Jtcy5odG1sI2NvbmNlcHQtZmUtZGlzYWJsZWRcblx0XHRcdC8vICogb3B0aW9uIGVsZW1lbnRzIGluIGEgZGlzYWJsZWQgb3B0Z3JvdXBcblx0XHRcdC8vICAgaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2UvZm9ybXMuaHRtbCNjb25jZXB0LW9wdGlvbi1kaXNhYmxlZFxuXHRcdFx0Ly8gQWxsIHN1Y2ggZWxlbWVudHMgaGF2ZSBhIFwiZm9ybVwiIHByb3BlcnR5LlxuXHRcdFx0aWYgKCBlbGVtLnBhcmVudE5vZGUgJiYgZWxlbS5kaXNhYmxlZCA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0Ly8gT3B0aW9uIGVsZW1lbnRzIGRlZmVyIHRvIGEgcGFyZW50IG9wdGdyb3VwIGlmIHByZXNlbnRcblx0XHRcdFx0aWYgKCBcImxhYmVsXCIgaW4gZWxlbSApIHtcblx0XHRcdFx0XHRpZiAoIFwibGFiZWxcIiBpbiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5wYXJlbnROb2RlLmRpc2FibGVkID09PSBkaXNhYmxlZDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDYgLSAxMVxuXHRcdFx0XHQvLyBVc2UgdGhlIGlzRGlzYWJsZWQgc2hvcnRjdXQgcHJvcGVydHkgdG8gY2hlY2sgZm9yIGRpc2FibGVkIGZpZWxkc2V0IGFuY2VzdG9yc1xuXHRcdFx0XHRyZXR1cm4gZWxlbS5pc0Rpc2FibGVkID09PSBkaXNhYmxlZCB8fFxuXG5cdFx0XHRcdFx0Ly8gV2hlcmUgdGhlcmUgaXMgbm8gaXNEaXNhYmxlZCwgY2hlY2sgbWFudWFsbHlcblx0XHRcdFx0XHQvKiBqc2hpbnQgLVcwMTggKi9cblx0XHRcdFx0XHRlbGVtLmlzRGlzYWJsZWQgIT09ICFkaXNhYmxlZCAmJlxuXHRcdFx0XHRcdGluRGlzYWJsZWRGaWVsZHNldCggZWxlbSApID09PSBkaXNhYmxlZDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXG5cdFx0Ly8gVHJ5IHRvIHdpbm5vdyBvdXQgZWxlbWVudHMgdGhhdCBjYW4ndCBiZSBkaXNhYmxlZCBiZWZvcmUgdHJ1c3RpbmcgdGhlIGRpc2FibGVkIHByb3BlcnR5LlxuXHRcdC8vIFNvbWUgdmljdGltcyBnZXQgY2F1Z2h0IGluIG91ciBuZXQgKGxhYmVsLCBsZWdlbmQsIG1lbnUsIHRyYWNrKSwgYnV0IGl0IHNob3VsZG4ndFxuXHRcdC8vIGV2ZW4gZXhpc3Qgb24gdGhlbSwgbGV0IGFsb25lIGhhdmUgYSBib29sZWFuIHZhbHVlLlxuXHRcdH0gZWxzZSBpZiAoIFwibGFiZWxcIiBpbiBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGRpc2FibGVkO1xuXHRcdH1cblxuXHRcdC8vIFJlbWFpbmluZyBlbGVtZW50cyBhcmUgbmVpdGhlciA6ZW5hYmxlZCBub3IgOmRpc2FibGVkXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9O1xufVxuXG4vKipcbiAqIFJldHVybnMgYSBmdW5jdGlvbiB0byB1c2UgaW4gcHNldWRvcyBmb3IgcG9zaXRpb25hbHNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZuICkge1xuXHRyZXR1cm4gbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIG1hdGNoZXMgKSB7XG5cdFx0XHR2YXIgaixcblx0XHRcdFx0bWF0Y2hJbmRleGVzID0gZm4oIFtdLCBzZWVkLmxlbmd0aCwgYXJndW1lbnQgKSxcblx0XHRcdFx0aSA9IG1hdGNoSW5kZXhlcy5sZW5ndGg7XG5cblx0XHRcdC8vIE1hdGNoIGVsZW1lbnRzIGZvdW5kIGF0IHRoZSBzcGVjaWZpZWQgaW5kZXhlc1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggc2VlZFsgKCBqID0gbWF0Y2hJbmRleGVzWyBpIF0gKSBdICkge1xuXHRcdFx0XHRcdHNlZWRbIGogXSA9ICEoIG1hdGNoZXNbIGogXSA9IHNlZWRbIGogXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9ICk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbmFtZXNwYWNlID0gZWxlbS5uYW1lc3BhY2VVUkksXG5cdFx0ZG9jRWxlbSA9ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0gKS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdC8vIEFzc3VtZSBIVE1MIHdoZW4gZG9jdW1lbnRFbGVtZW50IGRvZXNuJ3QgeWV0IGV4aXN0LCBzdWNoIGFzIGluc2lkZSBsb2FkaW5nIGlmcmFtZXNcblx0Ly8gaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzQ4MzNcblx0cmV0dXJuICFyaHRtbC50ZXN0KCBuYW1lc3BhY2UgfHwgZG9jRWxlbSAmJiBkb2NFbGVtLm5vZGVOYW1lIHx8IFwiSFRNTFwiICk7XG59O1xuXG4vKipcbiAqIFNldHMgZG9jdW1lbnQtcmVsYXRlZCB2YXJpYWJsZXMgb25jZSBiYXNlZCBvbiB0aGUgY3VycmVudCBkb2N1bWVudFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdH0gW2RvY10gQW4gZWxlbWVudCBvciBkb2N1bWVudCBvYmplY3QgdG8gdXNlIHRvIHNldCB0aGUgZG9jdW1lbnRcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGN1cnJlbnQgZG9jdW1lbnRcbiAqL1xuc2V0RG9jdW1lbnQgPSBTaXp6bGUuc2V0RG9jdW1lbnQgPSBmdW5jdGlvbiggbm9kZSApIHtcblx0dmFyIGhhc0NvbXBhcmUsIHN1YldpbmRvdyxcblx0XHRkb2MgPSBub2RlID8gbm9kZS5vd25lckRvY3VtZW50IHx8IG5vZGUgOiBwcmVmZXJyZWREb2M7XG5cblx0Ly8gUmV0dXJuIGVhcmx5IGlmIGRvYyBpcyBpbnZhbGlkIG9yIGFscmVhZHkgc2VsZWN0ZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBkb2MgPT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5IC0gMTErLCBFZGdlIDEyIC0gMTgrXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCBwcmVmZXJyZWREb2MgIT0gZG9jdW1lbnQgJiZcblx0XHQoIHN1YldpbmRvdyA9IGRvY3VtZW50LmRlZmF1bHRWaWV3ICkgJiYgc3ViV2luZG93LnRvcCAhPT0gc3ViV2luZG93ICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUUgMTEsIEVkZ2Vcblx0XHRpZiAoIHN1YldpbmRvdy5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0c3ViV2luZG93LmFkZEV2ZW50TGlzdGVuZXIoIFwidW5sb2FkXCIsIHVubG9hZEhhbmRsZXIsIGZhbHNlICk7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTAgb25seVxuXHRcdH0gZWxzZSBpZiAoIHN1YldpbmRvdy5hdHRhY2hFdmVudCApIHtcblx0XHRcdHN1YldpbmRvdy5hdHRhY2hFdmVudCggXCJvbnVubG9hZFwiLCB1bmxvYWRIYW5kbGVyICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUUgOCAtIDExKywgRWRnZSAxMiAtIDE4KywgQ2hyb21lIDw9MTYgLSAyNSBvbmx5LCBGaXJlZm94IDw9My42IC0gMzEgb25seSxcblx0Ly8gU2FmYXJpIDQgLSA1IG9ubHksIE9wZXJhIDw9MTEuNiAtIDEyLnggb25seVxuXHQvLyBJRS9FZGdlICYgb2xkZXIgYnJvd3NlcnMgZG9uJ3Qgc3VwcG9ydCB0aGUgOnNjb3BlIHBzZXVkby1jbGFzcy5cblx0Ly8gU3VwcG9ydDogU2FmYXJpIDYuMCBvbmx5XG5cdC8vIFNhZmFyaSA2LjAgc3VwcG9ydHMgOnNjb3BlIGJ1dCBpdCdzIGFuIGFsaWFzIG9mIDpyb290IHRoZXJlLlxuXHRzdXBwb3J0LnNjb3BlID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICk7XG5cdFx0cmV0dXJuIHR5cGVvZiBlbC5xdWVyeVNlbGVjdG9yQWxsICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHQhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6c2NvcGUgZmllbGRzZXQgZGl2XCIgKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZWwuY2xhc3NOYW1lID0gXCJpXCI7XG5cdFx0cmV0dXJuICFlbC5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NOYW1lXCIgKTtcblx0fSApO1xuXG5cdC8qIGdldEVsZW1lbnQocylCeSpcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIENoZWNrIGlmIGdldEVsZW1lbnRzQnlUYWdOYW1lKFwiKlwiKSByZXR1cm5zIG9ubHkgZWxlbWVudHNcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5VGFnTmFtZSA9IGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdGVsLmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KCBcIlwiICkgKTtcblx0XHRyZXR1cm4gIWVsLmdldEVsZW1lbnRzQnlUYWdOYW1lKCBcIipcIiApLmxlbmd0aDtcblx0fSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFPDlcblx0c3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICk7XG5cblx0Ly8gU3VwcG9ydDogSUU8MTBcblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudEJ5SWQgcmV0dXJucyBlbGVtZW50cyBieSBuYW1lXG5cdC8vIFRoZSBicm9rZW4gZ2V0RWxlbWVudEJ5SWQgbWV0aG9kcyBkb24ndCBwaWNrIHVwIHByb2dyYW1tYXRpY2FsbHktc2V0IG5hbWVzLFxuXHQvLyBzbyB1c2UgYSByb3VuZGFib3V0IGdldEVsZW1lbnRzQnlOYW1lIHRlc3Rcblx0c3VwcG9ydC5nZXRCeUlkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5pZCA9IGV4cGFuZG87XG5cdFx0cmV0dXJuICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSB8fCAhZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUoIGV4cGFuZG8gKS5sZW5ndGg7XG5cdH0gKTtcblxuXHQvLyBJRCBmaWx0ZXIgYW5kIGZpbmRcblx0aWYgKCBzdXBwb3J0LmdldEJ5SWQgKSB7XG5cdFx0RXhwci5maWx0ZXJbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSggXCJpZFwiICkgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0XHRFeHByLmZpbmRbIFwiSURcIiBdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gZWxlbSA/IFsgZWxlbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0fSBlbHNlIHtcblx0XHRFeHByLmZpbHRlclsgXCJJRFwiIF0gPSAgZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciBub2RlID0gdHlwZW9mIGVsZW0uZ2V0QXR0cmlidXRlTm9kZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggXCJpZFwiICk7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDYgLSA3IG9ubHlcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0RXhwci5maW5kWyBcIklEXCIgXSA9IGZ1bmN0aW9uKCBpZCwgY29udGV4dCApIHtcblx0XHRcdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudEJ5SWQgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRcdHZhciBub2RlLCBpLCBlbGVtcyxcblx0XHRcdFx0XHRlbGVtID0gY29udGV4dC5nZXRFbGVtZW50QnlJZCggaWQgKTtcblxuXHRcdFx0XHRpZiAoIGVsZW0gKSB7XG5cblx0XHRcdFx0XHQvLyBWZXJpZnkgdGhlIGlkIGF0dHJpYnV0ZVxuXHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdGlmICggbm9kZSAmJiBub2RlLnZhbHVlID09PSBpZCApIHtcblx0XHRcdFx0XHRcdHJldHVybiBbIGVsZW0gXTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBGYWxsIGJhY2sgb24gZ2V0RWxlbWVudHNCeU5hbWVcblx0XHRcdFx0XHRlbGVtcyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeU5hbWUoIGlkICk7XG5cdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRcdG5vZGUgPSBlbGVtLmdldEF0dHJpYnV0ZU5vZGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCBub2RlICYmIG5vZGUudmFsdWUgPT09IGlkICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gWyBlbGVtIF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fVxuXHRcdH07XG5cdH1cblxuXHQvLyBUYWdcblx0RXhwci5maW5kWyBcIlRBR1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXG5cdFx0XHRcdC8vIEJ5IGhhcHB5IGNvaW5jaWRlbmNlLCBhIChicm9rZW4pIGdFQlROIGFwcGVhcnMgb24gRG9jdW1lbnRGcmFnbWVudCBub2RlcyB0b29cblx0XHRcdFx0cmVzdWx0cyA9IGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBGaWx0ZXIgb3V0IHBvc3NpYmxlIGNvbW1lbnRzXG5cdFx0XHRpZiAoIHRhZyA9PT0gXCIqXCIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFsgXCJDTEFTU1wiIF0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiYgZnVuY3Rpb24oIGNsYXNzTmFtZSwgY29udGV4dCApIHtcblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgZG9jdW1lbnRJc0hUTUwgKSB7XG5cdFx0XHRyZXR1cm4gY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lKCBjbGFzc05hbWUgKTtcblx0XHR9XG5cdH07XG5cblx0LyogUVNBL21hdGNoZXNTZWxlY3RvclxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gUVNBIGFuZCBtYXRjaGVzU2VsZWN0b3Igc3VwcG9ydFxuXG5cdC8vIG1hdGNoZXNTZWxlY3Rvcig6YWN0aXZlKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoSUU5L09wZXJhIDExLjUpXG5cdHJidWdneU1hdGNoZXMgPSBbXTtcblxuXHQvLyBxU2EoOmZvY3VzKSByZXBvcnRzIGZhbHNlIHdoZW4gdHJ1ZSAoQ2hyb21lIDIxKVxuXHQvLyBXZSBhbGxvdyB0aGlzIGJlY2F1c2Ugb2YgYSBidWcgaW4gSUU4LzkgdGhhdCB0aHJvd3MgYW4gZXJyb3Jcblx0Ly8gd2hlbmV2ZXIgYGRvY3VtZW50LmFjdGl2ZUVsZW1lbnRgIGlzIGFjY2Vzc2VkIG9uIGFuIGlmcmFtZVxuXHQvLyBTbywgd2UgYWxsb3cgOmZvY3VzIHRvIHBhc3MgdGhyb3VnaCBRU0EgYWxsIHRoZSB0aW1lIHRvIGF2b2lkIHRoZSBJRSBlcnJvclxuXHQvLyBTZWUgaHR0cHM6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKCBzdXBwb3J0LnFzYSA9IHJuYXRpdmUudGVzdCggZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCApICkgKSB7XG5cblx0XHQvLyBCdWlsZCBRU0EgcmVnZXhcblx0XHQvLyBSZWdleCBzdHJhdGVneSBhZG9wdGVkIGZyb20gRGllZ28gUGVyaW5pXG5cdFx0YXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0XHRcdHZhciBpbnB1dDtcblxuXHRcdFx0Ly8gU2VsZWN0IGlzIHNldCB0byBlbXB0eSBzdHJpbmcgb24gcHVycG9zZVxuXHRcdFx0Ly8gVGhpcyBpcyB0byB0ZXN0IElFJ3MgdHJlYXRtZW50IG9mIG5vdCBleHBsaWNpdGx5XG5cdFx0XHQvLyBzZXR0aW5nIGEgYm9vbGVhbiBjb250ZW50IGF0dHJpYnV0ZSxcblx0XHRcdC8vIHNpbmNlIGl0cyBwcmVzZW5jZSBzaG91bGQgYmUgZW5vdWdoXG5cdFx0XHQvLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGVsICkuaW5uZXJIVE1MID0gXCI8YSBpZD0nXCIgKyBleHBhbmRvICsgXCInPjwvYT5cIiArXG5cdFx0XHRcdFwiPHNlbGVjdCBpZD0nXCIgKyBleHBhbmRvICsgXCItXFxyXFxcXCcgbXNhbGxvd2NhcHR1cmU9Jyc+XCIgK1xuXHRcdFx0XHRcIjxvcHRpb24gc2VsZWN0ZWQ9Jyc+PC9vcHRpb24+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOCwgT3BlcmEgMTEtMTIuMTZcblx0XHRcdC8vIE5vdGhpbmcgc2hvdWxkIGJlIHNlbGVjdGVkIHdoZW4gZW1wdHkgc3RyaW5ncyBmb2xsb3cgXj0gb3IgJD0gb3IgKj1cblx0XHRcdC8vIFRoZSB0ZXN0IGF0dHJpYnV0ZSBtdXN0IGJlIHVua25vd24gaW4gT3BlcmEgYnV0IFwic2FmZVwiIGZvciBXaW5SVFxuXHRcdFx0Ly8gaHR0cHM6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiWypeJF09XCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogSUU4XG5cdFx0XHQvLyBCb29sZWFuIGF0dHJpYnV0ZXMgYW5kIFwidmFsdWVcIiBhcmUgbm90IHRyZWF0ZWQgY29ycmVjdGx5XG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltzZWxlY3RlZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIiooPzp2YWx1ZXxcIiArIGJvb2xlYW5zICsgXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lPDI5LCBBbmRyb2lkPDQuNCwgU2FmYXJpPDcuMCssIGlPUzw3LjArLCBQaGFudG9tSlM8MS45LjgrXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIltpZH49XCIgKyBleHBhbmRvICsgXCItXVwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJ+PVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdFx0Ly8gSUUgMTEvRWRnZSBkb24ndCBmaW5kIGVsZW1lbnRzIG9uIGEgYFtuYW1lPScnXWAgcXVlcnkgaW4gc29tZSBjYXNlcy5cblx0XHRcdC8vIEFkZGluZyBhIHRlbXBvcmFyeSBhdHRyaWJ1dGUgdG8gdGhlIGRvY3VtZW50IGJlZm9yZSB0aGUgc2VsZWN0aW9uIHdvcmtzXG5cdFx0XHQvLyBhcm91bmQgdGhlIGlzc3VlLlxuXHRcdFx0Ly8gSW50ZXJlc3RpbmdseSwgSUUgMTAgJiBvbGRlciBkb24ndCBzZWVtIHRvIGhhdmUgdGhlIGlzc3VlLlxuXHRcdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCJbbmFtZT0nJ11cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiXFxcXFtcIiArIHdoaXRlc3BhY2UgKyBcIipuYW1lXCIgKyB3aGl0ZXNwYWNlICsgXCIqPVwiICtcblx0XHRcdFx0XHR3aGl0ZXNwYWNlICsgXCIqKD86Jyd8XFxcIlxcXCIpXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gV2Via2l0L09wZXJhIC0gOmNoZWNrZWQgc2hvdWxkIHJldHVybiBzZWxlY3RlZCBvcHRpb24gZWxlbWVudHNcblx0XHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSLzIwMTEvUkVDLWNzczMtc2VsZWN0b3JzLTIwMTEwOTI5LyNjaGVja2VkXG5cdFx0XHQvLyBJRTggdGhyb3dzIGVycm9yIGhlcmUgYW5kIHdpbGwgbm90IHNlZSBsYXRlciB0ZXN0c1xuXHRcdFx0aWYgKCAhZWwucXVlcnlTZWxlY3RvckFsbCggXCI6Y2hlY2tlZFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6Y2hlY2tlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFNhZmFyaSA4KywgaU9TIDgrXG5cdFx0XHQvLyBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTM2ODUxXG5cdFx0XHQvLyBJbi1wYWdlIGBzZWxlY3RvciNpZCBzaWJsaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFlbC5xdWVyeVNlbGVjdG9yQWxsKCBcImEjXCIgKyBleHBhbmRvICsgXCIrKlwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCIuIy4rWyt+XVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD0zLjYgLSA1IG9ubHlcblx0XHRcdC8vIE9sZCBGaXJlZm94IGRvZXNuJ3QgdGhyb3cgb24gYSBiYWRseS1lc2NhcGVkIGlkZW50aWZpZXIuXG5cdFx0XHRlbC5xdWVyeVNlbGVjdG9yQWxsKCBcIlxcXFxcXGZcIiApO1xuXHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwiW1xcXFxyXFxcXG5cXFxcZl1cIiApO1xuXHRcdH0gKTtcblxuXHRcdGFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRcdFx0ZWwuaW5uZXJIVE1MID0gXCI8YSBocmVmPScnIGRpc2FibGVkPSdkaXNhYmxlZCc+PC9hPlwiICtcblx0XHRcdFx0XCI8c2VsZWN0IGRpc2FibGVkPSdkaXNhYmxlZCc+PG9wdGlvbi8+PC9zZWxlY3Q+XCI7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFdpbmRvd3MgOCBOYXRpdmUgQXBwc1xuXHRcdFx0Ly8gVGhlIHR5cGUgYW5kIG5hbWUgYXR0cmlidXRlcyBhcmUgcmVzdHJpY3RlZCBkdXJpbmcgLmlubmVySFRNTCBhc3NpZ25tZW50XG5cdFx0XHR2YXIgaW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGVsLmFwcGVuZENoaWxkKCBpbnB1dCApLnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwiRFwiICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOFxuXHRcdFx0Ly8gRW5mb3JjZSBjYXNlLXNlbnNpdGl2aXR5IG9mIG5hbWUgYXR0cmlidXRlXG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW25hbWU9ZF1cIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggZWwucXVlcnlTZWxlY3RvckFsbCggXCI6ZW5hYmxlZFwiICkubGVuZ3RoICE9PSAyICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0XHRcdC8vIElFJ3MgOmRpc2FibGVkIHNlbGVjdG9yIGRvZXMgbm90IHBpY2sgdXAgdGhlIGNoaWxkcmVuIG9mIGRpc2FibGVkIGZpZWxkc2V0c1xuXHRcdFx0ZG9jRWxlbS5hcHBlbmRDaGlsZCggZWwgKS5kaXNhYmxlZCA9IHRydWU7XG5cdFx0XHRpZiAoIGVsLnF1ZXJ5U2VsZWN0b3JBbGwoIFwiOmRpc2FibGVkXCIgKS5sZW5ndGggIT09IDIgKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIjplbmFibGVkXCIsIFwiOmRpc2FibGVkXCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU3VwcG9ydDogT3BlcmEgMTAgLSAxMSBvbmx5XG5cdFx0XHQvLyBPcGVyYSAxMC0xMSBkb2VzIG5vdCB0aHJvdyBvbiBwb3N0LWNvbW1hIGludmFsaWQgcHNldWRvc1xuXHRcdFx0ZWwucXVlcnlTZWxlY3RvckFsbCggXCIqLDp4XCIgKTtcblx0XHRcdHJidWdneVFTQS5wdXNoKCBcIiwuKjpcIiApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKCBtYXRjaGVzID0gZG9jRWxlbS5tYXRjaGVzIHx8XG5cdFx0ZG9jRWxlbS53ZWJraXRNYXRjaGVzU2VsZWN0b3IgfHxcblx0XHRkb2NFbGVtLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ub01hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubXNNYXRjaGVzU2VsZWN0b3IgKSApICkgKSB7XG5cblx0XHRhc3NlcnQoIGZ1bmN0aW9uKCBlbCApIHtcblxuXHRcdFx0Ly8gQ2hlY2sgdG8gc2VlIGlmIGl0J3MgcG9zc2libGUgdG8gZG8gbWF0Y2hlc1NlbGVjdG9yXG5cdFx0XHQvLyBvbiBhIGRpc2Nvbm5lY3RlZCBub2RlIChJRSA5KVxuXHRcdFx0c3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCA9IG1hdGNoZXMuY2FsbCggZWwsIFwiKlwiICk7XG5cblx0XHRcdC8vIFRoaXMgc2hvdWxkIGZhaWwgd2l0aCBhbiBleGNlcHRpb25cblx0XHRcdC8vIEdlY2tvIGRvZXMgbm90IGVycm9yLCByZXR1cm5zIGZhbHNlIGluc3RlYWRcblx0XHRcdG1hdGNoZXMuY2FsbCggZWwsIFwiW3MhPScnXTp4XCIgKTtcblx0XHRcdHJidWdneU1hdGNoZXMucHVzaCggXCIhPVwiLCBwc2V1ZG9zICk7XG5cdFx0fSApO1xuXHR9XG5cblx0cmJ1Z2d5UVNBID0gcmJ1Z2d5UVNBLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lRU0Euam9pbiggXCJ8XCIgKSApO1xuXHRyYnVnZ3lNYXRjaGVzID0gcmJ1Z2d5TWF0Y2hlcy5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5TWF0Y2hlcy5qb2luKCBcInxcIiApICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpICk7XG5cdFx0fSA6XG5cdFx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cdFx0XHRpZiAoIGIgKSB7XG5cdFx0XHRcdHdoaWxlICggKCBiID0gYi5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0Y29tcGFyZSA9ICggYS5vd25lckRvY3VtZW50IHx8IGEgKSA9PSAoIGIub3duZXJEb2N1bWVudCB8fCBiICkgP1xuXHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYiApIDpcblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIHdlIGtub3cgdGhleSBhcmUgZGlzY29ubmVjdGVkXG5cdFx0XHQxO1xuXG5cdFx0Ly8gRGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0aWYgKCBjb21wYXJlICYgMSB8fFxuXHRcdFx0KCAhc3VwcG9ydC5zb3J0RGV0YWNoZWQgJiYgYi5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggYSApID09PSBjb21wYXJlICkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdGlmICggYSA9PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT0gcHJlZmVycmVkRG9jICYmXG5cdFx0XHRcdGNvbnRhaW5zKCBwcmVmZXJyZWREb2MsIGEgKSApIHtcblx0XHRcdFx0cmV0dXJuIC0xO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMSssIEVkZ2UgMTcgLSAxOCtcblx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGVxZXFlcVxuXHRcdFx0aWYgKCBiID09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PSBwcmVmZXJyZWREb2MgJiZcblx0XHRcdFx0Y29udGFpbnMoIHByZWZlcnJlZERvYywgYiApICkge1xuXHRcdFx0XHRyZXR1cm4gMTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWFpbnRhaW4gb3JpZ2luYWwgb3JkZXJcblx0XHRcdHJldHVybiBzb3J0SW5wdXQgP1xuXHRcdFx0XHQoIGluZGV4T2YoIHNvcnRJbnB1dCwgYSApIC0gaW5kZXhPZiggc29ydElucHV0LCBiICkgKSA6XG5cdFx0XHRcdDA7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGNvbXBhcmUgJiA0ID8gLTEgOiAxO1xuXHR9IDpcblx0ZnVuY3Rpb24oIGEsIGIgKSB7XG5cblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0cmV0dXJuIGEgPT0gZG9jdW1lbnQgPyAtMSA6XG5cdFx0XHRcdGIgPT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGN1ci5wYXJlbnROb2RlICkgKSB7XG5cdFx0XHRhcC51bnNoaWZ0KCBjdXIgKTtcblx0XHR9XG5cdFx0Y3VyID0gYjtcblx0XHR3aGlsZSAoICggY3VyID0gY3VyLnBhcmVudE5vZGUgKSApIHtcblx0XHRcdGJwLnVuc2hpZnQoIGN1ciApO1xuXHRcdH1cblxuXHRcdC8vIFdhbGsgZG93biB0aGUgdHJlZSBsb29raW5nIGZvciBhIGRpc2NyZXBhbmN5XG5cdFx0d2hpbGUgKCBhcFsgaSBdID09PSBicFsgaSBdICkge1xuXHRcdFx0aSsrO1xuXHRcdH1cblxuXHRcdHJldHVybiBpID9cblxuXHRcdFx0Ly8gRG8gYSBzaWJsaW5nIGNoZWNrIGlmIHRoZSBub2RlcyBoYXZlIGEgY29tbW9uIGFuY2VzdG9yXG5cdFx0XHRzaWJsaW5nQ2hlY2soIGFwWyBpIF0sIGJwWyBpIF0gKSA6XG5cblx0XHRcdC8vIE90aGVyd2lzZSBub2RlcyBpbiBvdXIgZG9jdW1lbnQgc29ydCBmaXJzdFxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIGVxZXFlcSAqL1xuXHRcdFx0YXBbIGkgXSA9PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFsgaSBdID09IHByZWZlcnJlZERvYyA/IDEgOlxuXHRcdFx0LyogZXNsaW50LWVuYWJsZSBlcWVxZXEgKi9cblx0XHRcdDA7XG5cdH07XG5cblx0cmV0dXJuIGRvY3VtZW50O1xufTtcblxuU2l6emxlLm1hdGNoZXMgPSBmdW5jdGlvbiggZXhwciwgZWxlbWVudHMgKSB7XG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIG51bGwsIG51bGwsIGVsZW1lbnRzICk7XG59O1xuXG5TaXp6bGUubWF0Y2hlc1NlbGVjdG9yID0gZnVuY3Rpb24oIGVsZW0sIGV4cHIgKSB7XG5cdHNldERvY3VtZW50KCBlbGVtICk7XG5cblx0aWYgKCBzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciAmJiBkb2N1bWVudElzSFRNTCAmJlxuXHRcdCFub25uYXRpdmVTZWxlY3RvckNhY2hlWyBleHByICsgXCIgXCIgXSAmJlxuXHRcdCggIXJidWdneU1hdGNoZXMgfHwgIXJidWdneU1hdGNoZXMudGVzdCggZXhwciApICkgJiZcblx0XHQoICFyYnVnZ3lRU0EgICAgIHx8ICFyYnVnZ3lRU0EudGVzdCggZXhwciApICkgKSB7XG5cblx0XHR0cnkge1xuXHRcdFx0dmFyIHJldCA9IG1hdGNoZXMuY2FsbCggZWxlbSwgZXhwciApO1xuXG5cdFx0XHQvLyBJRSA5J3MgbWF0Y2hlc1NlbGVjdG9yIHJldHVybnMgZmFsc2Ugb24gZGlzY29ubmVjdGVkIG5vZGVzXG5cdFx0XHRpZiAoIHJldCB8fCBzdXBwb3J0LmRpc2Nvbm5lY3RlZE1hdGNoIHx8XG5cblx0XHRcdFx0Ly8gQXMgd2VsbCwgZGlzY29ubmVjdGVkIG5vZGVzIGFyZSBzYWlkIHRvIGJlIGluIGEgZG9jdW1lbnRcblx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRlbGVtLmRvY3VtZW50ICYmIGVsZW0uZG9jdW1lbnQubm9kZVR5cGUgIT09IDExICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0bm9ubmF0aXZlU2VsZWN0b3JDYWNoZSggZXhwciwgdHJ1ZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblxuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0aWYgKCAoIGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0ICkgIT0gZG9jdW1lbnQgKSB7XG5cdFx0c2V0RG9jdW1lbnQoIGNvbnRleHQgKTtcblx0fVxuXHRyZXR1cm4gY29udGFpbnMoIGNvbnRleHQsIGVsZW0gKTtcbn07XG5cblNpenpsZS5hdHRyID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUgKSB7XG5cblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHQvLyBJRS9FZGdlIHNvbWV0aW1lcyB0aHJvdyBhIFwiUGVybWlzc2lvbiBkZW5pZWRcIiBlcnJvciB3aGVuIHN0cmljdC1jb21wYXJpbmdcblx0Ly8gdHdvIGRvY3VtZW50czsgc2hhbGxvdyBjb21wYXJpc29ucyB3b3JrLlxuXHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHR2YXIgZm4gPSBFeHByLmF0dHJIYW5kbGVbIG5hbWUudG9Mb3dlckNhc2UoKSBdLFxuXG5cdFx0Ly8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBPYmplY3QucHJvdG90eXBlIHByb3BlcnRpZXMgKGpRdWVyeSAjMTM4MDcpXG5cdFx0dmFsID0gZm4gJiYgaGFzT3duLmNhbGwoIEV4cHIuYXR0ckhhbmRsZSwgbmFtZS50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0Zm4oIGVsZW0sIG5hbWUsICFkb2N1bWVudElzSFRNTCApIDpcblx0XHRcdHVuZGVmaW5lZDtcblxuXHRyZXR1cm4gdmFsICE9PSB1bmRlZmluZWQgP1xuXHRcdHZhbCA6XG5cdFx0c3VwcG9ydC5hdHRyaWJ1dGVzIHx8ICFkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApIDpcblx0XHRcdCggdmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkgKSAmJiB2YWwuc3BlY2lmaWVkID9cblx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0bnVsbDtcbn07XG5cblNpenpsZS5lc2NhcGUgPSBmdW5jdGlvbiggc2VsICkge1xuXHRyZXR1cm4gKCBzZWwgKyBcIlwiICkucmVwbGFjZSggcmNzc2VzY2FwZSwgZmNzc2VzY2FwZSApO1xufTtcblxuU2l6emxlLmVycm9yID0gZnVuY3Rpb24oIG1zZyApIHtcblx0dGhyb3cgbmV3IEVycm9yKCBcIlN5bnRheCBlcnJvciwgdW5yZWNvZ25pemVkIGV4cHJlc3Npb246IFwiICsgbXNnICk7XG59O1xuXG4vKipcbiAqIERvY3VtZW50IHNvcnRpbmcgYW5kIHJlbW92aW5nIGR1cGxpY2F0ZXNcbiAqIEBwYXJhbSB7QXJyYXlMaWtlfSByZXN1bHRzXG4gKi9cblNpenpsZS51bmlxdWVTb3J0ID0gZnVuY3Rpb24oIHJlc3VsdHMgKSB7XG5cdHZhciBlbGVtLFxuXHRcdGR1cGxpY2F0ZXMgPSBbXSxcblx0XHRqID0gMCxcblx0XHRpID0gMDtcblxuXHQvLyBVbmxlc3Mgd2UgKmtub3cqIHdlIGNhbiBkZXRlY3QgZHVwbGljYXRlcywgYXNzdW1lIHRoZWlyIHByZXNlbmNlXG5cdGhhc0R1cGxpY2F0ZSA9ICFzdXBwb3J0LmRldGVjdER1cGxpY2F0ZXM7XG5cdHNvcnRJbnB1dCA9ICFzdXBwb3J0LnNvcnRTdGFibGUgJiYgcmVzdWx0cy5zbGljZSggMCApO1xuXHRyZXN1bHRzLnNvcnQoIHNvcnRPcmRlciApO1xuXG5cdGlmICggaGFzRHVwbGljYXRlICkge1xuXHRcdHdoaWxlICggKCBlbGVtID0gcmVzdWx0c1sgaSsrIF0gKSApIHtcblx0XHRcdGlmICggZWxlbSA9PT0gcmVzdWx0c1sgaSBdICkge1xuXHRcdFx0XHRqID0gZHVwbGljYXRlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0cmVzdWx0cy5zcGxpY2UoIGR1cGxpY2F0ZXNbIGogXSwgMSApO1xuXHRcdH1cblx0fVxuXG5cdC8vIENsZWFyIGlucHV0IGFmdGVyIHNvcnRpbmcgdG8gcmVsZWFzZSBvYmplY3RzXG5cdC8vIFNlZSBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L3NpenpsZS9wdWxsLzIyNVxuXHRzb3J0SW5wdXQgPSBudWxsO1xuXG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLyoqXG4gKiBVdGlsaXR5IGZ1bmN0aW9uIGZvciByZXRyaWV2aW5nIHRoZSB0ZXh0IHZhbHVlIG9mIGFuIGFycmF5IG9mIERPTSBub2Rlc1xuICogQHBhcmFtIHtBcnJheXxFbGVtZW50fSBlbGVtXG4gKi9cbmdldFRleHQgPSBTaXp6bGUuZ2V0VGV4dCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHR2YXIgbm9kZSxcblx0XHRyZXQgPSBcIlwiLFxuXHRcdGkgPSAwLFxuXHRcdG5vZGVUeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRpZiAoICFub2RlVHlwZSApIHtcblxuXHRcdC8vIElmIG5vIG5vZGVUeXBlLCB0aGlzIGlzIGV4cGVjdGVkIHRvIGJlIGFuIGFycmF5XG5cdFx0d2hpbGUgKCAoIG5vZGUgPSBlbGVtWyBpKysgXSApICkge1xuXG5cdFx0XHQvLyBEbyBub3QgdHJhdmVyc2UgY29tbWVudCBub2Rlc1xuXHRcdFx0cmV0ICs9IGdldFRleHQoIG5vZGUgKTtcblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAxIHx8IG5vZGVUeXBlID09PSA5IHx8IG5vZGVUeXBlID09PSAxMSApIHtcblxuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBUcmF2ZXJzZSBpdHMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRyZXQgKz0gZ2V0VGV4dCggZWxlbSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDMgfHwgbm9kZVR5cGUgPT09IDQgKSB7XG5cdFx0cmV0dXJuIGVsZW0ubm9kZVZhbHVlO1xuXHR9XG5cblx0Ly8gRG8gbm90IGluY2x1ZGUgY29tbWVudCBvciBwcm9jZXNzaW5nIGluc3RydWN0aW9uIG5vZGVzXG5cblx0cmV0dXJuIHJldDtcbn07XG5cbkV4cHIgPSBTaXp6bGUuc2VsZWN0b3JzID0ge1xuXG5cdC8vIENhbiBiZSBhZGp1c3RlZCBieSB0aGUgdXNlclxuXHRjYWNoZUxlbmd0aDogNTAsXG5cblx0Y3JlYXRlUHNldWRvOiBtYXJrRnVuY3Rpb24sXG5cblx0bWF0Y2g6IG1hdGNoRXhwcixcblxuXHRhdHRySGFuZGxlOiB7fSxcblxuXHRmaW5kOiB7fSxcblxuXHRyZWxhdGl2ZToge1xuXHRcdFwiPlwiOiB7IGRpcjogXCJwYXJlbnROb2RlXCIsIGZpcnN0OiB0cnVlIH0sXG5cdFx0XCIgXCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiB9LFxuXHRcdFwiK1wiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIn5cIjogeyBkaXI6IFwicHJldmlvdXNTaWJsaW5nXCIgfVxuXHR9LFxuXG5cdHByZUZpbHRlcjoge1xuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaFsgMSBdID0gbWF0Y2hbIDEgXS5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXG5cdFx0XHQvLyBNb3ZlIHRoZSBnaXZlbiB2YWx1ZSB0byBtYXRjaFszXSB3aGV0aGVyIHF1b3RlZCBvciB1bnF1b3RlZFxuXHRcdFx0bWF0Y2hbIDMgXSA9ICggbWF0Y2hbIDMgXSB8fCBtYXRjaFsgNCBdIHx8XG5cdFx0XHRcdG1hdGNoWyA1IF0gfHwgXCJcIiApLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDIgXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFsgMyBdID0gXCIgXCIgKyBtYXRjaFsgMyBdICsgXCIgXCI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBtYXRjaC5zbGljZSggMCwgNCApO1xuXHRcdH0sXG5cblx0XHRcIkNISUxEXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblxuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWyAxIF0gPSBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRcdGlmICggbWF0Y2hbIDEgXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXG5cdFx0XHRcdC8vIG50aC0qIHJlcXVpcmVzIGFyZ3VtZW50XG5cdFx0XHRcdGlmICggIW1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBtYXRjaFsgMCBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFsgNCBdID0gKyggbWF0Y2hbIDQgXSA/XG5cdFx0XHRcdFx0bWF0Y2hbIDUgXSArICggbWF0Y2hbIDYgXSB8fCAxICkgOlxuXHRcdFx0XHRcdDIgKiAoIG1hdGNoWyAzIF0gPT09IFwiZXZlblwiIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFsgNSBdID0gKyggKCBtYXRjaFsgNyBdICsgbWF0Y2hbIDggXSApIHx8IG1hdGNoWyAzIF0gPT09IFwib2RkXCIgKTtcblxuXHRcdFx0XHQvLyBvdGhlciB0eXBlcyBwcm9oaWJpdCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gbWF0Y2g7XG5cdFx0fSxcblxuXHRcdFwiUFNFVURPXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdHZhciBleGNlc3MsXG5cdFx0XHRcdHVucXVvdGVkID0gIW1hdGNoWyA2IF0gJiYgbWF0Y2hbIDIgXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbIFwiQ0hJTERcIiBdLnRlc3QoIG1hdGNoWyAwIF0gKSApIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFjY2VwdCBxdW90ZWQgYXJndW1lbnRzIGFzLWlzXG5cdFx0XHRpZiAoIG1hdGNoWyAzIF0gKSB7XG5cdFx0XHRcdG1hdGNoWyAyIF0gPSBtYXRjaFsgNCBdIHx8IG1hdGNoWyA1IF0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXG5cdFx0XHRcdC8vIEdldCBleGNlc3MgZnJvbSB0b2tlbml6ZSAocmVjdXJzaXZlbHkpXG5cdFx0XHRcdCggZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkgKSAmJlxuXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoIGV4Y2VzcyA9IHVucXVvdGVkLmluZGV4T2YoIFwiKVwiLCB1bnF1b3RlZC5sZW5ndGggLSBleGNlc3MgKSAtIHVucXVvdGVkLmxlbmd0aCApICkge1xuXG5cdFx0XHRcdC8vIGV4Y2VzcyBpcyBhIG5lZ2F0aXZlIGluZGV4XG5cdFx0XHRcdG1hdGNoWyAwIF0gPSBtYXRjaFsgMCBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbIDIgXSA9IHVucXVvdGVkLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV0dXJuIG9ubHkgY2FwdHVyZXMgbmVlZGVkIGJ5IHRoZSBwc2V1ZG8gZmlsdGVyIG1ldGhvZCAodHlwZSBhbmQgYXJndW1lbnQpXG5cdFx0XHRyZXR1cm4gbWF0Y2guc2xpY2UoIDAsIDMgKTtcblx0XHR9XG5cdH0sXG5cblx0ZmlsdGVyOiB7XG5cblx0XHRcIlRBR1wiOiBmdW5jdGlvbiggbm9kZU5hbWVTZWxlY3RvciApIHtcblx0XHRcdHZhciBub2RlTmFtZSA9IG5vZGVOYW1lU2VsZWN0b3IucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIG5vZGVOYW1lU2VsZWN0b3IgPT09IFwiKlwiID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5vZGVOYW1lO1xuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIkNMQVNTXCI6IGZ1bmN0aW9uKCBjbGFzc05hbWUgKSB7XG5cdFx0XHR2YXIgcGF0dGVybiA9IGNsYXNzQ2FjaGVbIGNsYXNzTmFtZSArIFwiIFwiIF07XG5cblx0XHRcdHJldHVybiBwYXR0ZXJuIHx8XG5cdFx0XHRcdCggcGF0dGVybiA9IG5ldyBSZWdFeHAoIFwiKF58XCIgKyB3aGl0ZXNwYWNlICtcblx0XHRcdFx0XHRcIilcIiArIGNsYXNzTmFtZSArIFwiKFwiICsgd2hpdGVzcGFjZSArIFwifCQpXCIgKSApICYmIGNsYXNzQ2FjaGUoXG5cdFx0XHRcdFx0XHRjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcGF0dGVybi50ZXN0KFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fFxuXHRcdFx0XHRcdFx0XHRcdHR5cGVvZiBlbGVtLmdldEF0dHJpYnV0ZSAhPT0gXCJ1bmRlZmluZWRcIiAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8XG5cdFx0XHRcdFx0XHRcdFx0XCJcIlxuXHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHR9ICk7XG5cdFx0fSxcblxuXHRcdFwiQVRUUlwiOiBmdW5jdGlvbiggbmFtZSwgb3BlcmF0b3IsIGNoZWNrICkge1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgcmVzdWx0ID0gU2l6emxlLmF0dHIoIGVsZW0sIG5hbWUgKTtcblxuXHRcdFx0XHRpZiAoIHJlc3VsdCA9PSBudWxsICkge1xuXHRcdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCIhPVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggIW9wZXJhdG9yICkge1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmVzdWx0ICs9IFwiXCI7XG5cblx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbWF4LWxlbiAqL1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG1heC1sZW4gKi9cblxuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgX2FyZ3VtZW50LCBmaXJzdCwgbGFzdCApIHtcblx0XHRcdHZhciBzaW1wbGUgPSB0eXBlLnNsaWNlKCAwLCAzICkgIT09IFwibnRoXCIsXG5cdFx0XHRcdGZvcndhcmQgPSB0eXBlLnNsaWNlKCAtNCApICE9PSBcImxhc3RcIixcblx0XHRcdFx0b2ZUeXBlID0gd2hhdCA9PT0gXCJvZi10eXBlXCI7XG5cblx0XHRcdHJldHVybiBmaXJzdCA9PT0gMSAmJiBsYXN0ID09PSAwID9cblxuXHRcdFx0XHQvLyBTaG9ydGN1dCBmb3IgOm50aC0qKG4pXG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiAhIWVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdFx0fSA6XG5cblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIF9jb250ZXh0LCB4bWwgKSB7XG5cdFx0XHRcdFx0dmFyIGNhY2hlLCB1bmlxdWVDYWNoZSwgb3V0ZXJDYWNoZSwgbm9kZSwgbm9kZUluZGV4LCBzdGFydCxcblx0XHRcdFx0XHRcdGRpciA9IHNpbXBsZSAhPT0gZm9yd2FyZCA/IFwibmV4dFNpYmxpbmdcIiA6IFwicHJldmlvdXNTaWJsaW5nXCIsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGUsXG5cdFx0XHRcdFx0XHRuYW1lID0gb2ZUeXBlICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0XHRcdHVzZUNhY2hlID0gIXhtbCAmJiAhb2ZUeXBlLFxuXHRcdFx0XHRcdFx0ZGlmZiA9IGZhbHNlO1xuXG5cdFx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIDooZmlyc3R8bGFzdHxvbmx5KS0oY2hpbGR8b2YtdHlwZSlcblx0XHRcdFx0XHRcdGlmICggc2ltcGxlICkge1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoIGRpciApIHtcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbm9kZSA9IG5vZGVbIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKCBub2RlWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdGNhY2hlID0gdW5pcXVlQ2FjaGVbIHR5cGUgXSB8fCBbXTtcblx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4ICYmIGNhY2hlWyAyIF07XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBub2RlSW5kZXggJiYgcGFyZW50LmNoaWxkTm9kZXNbIG5vZGVJbmRleCBdO1xuXG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gRmFsbGJhY2sgdG8gc2Vla2luZyBgZWxlbWAgZnJvbSB0aGUgc3RhcnRcblx0XHRcdFx0XHRcdFx0XHQoIGRpZmYgPSBub2RlSW5kZXggPSAwICkgfHwgc3RhcnQucG9wKCkgKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFdoZW4gZm91bmQsIGNhY2hlIGluZGV4ZXMgb24gYHBhcmVudGAgYW5kIGJyZWFrXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBub2RlLm5vZGVUeXBlID09PSAxICYmICsrZGlmZiAmJiBub2RlID09PSBlbGVtICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGVbIHR5cGUgXSA9IFsgZGlycnVucywgbm9kZUluZGV4LCBkaWZmIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBVc2UgcHJldmlvdXNseS1jYWNoZWQgZWxlbWVudCBpbmRleCBpZiBhdmFpbGFibGVcblx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8ICggbm9kZVsgZXhwYW5kbyBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRcdG5vZGVJbmRleCA9IGNhY2hlWyAwIF0gPT09IGRpcnJ1bnMgJiYgY2FjaGVbIDEgXTtcblx0XHRcdFx0XHRcdFx0XHRkaWZmID0gbm9kZUluZGV4O1xuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8geG1sIDpudGgtY2hpbGQoLi4uKVxuXHRcdFx0XHRcdFx0XHQvLyBvciA6bnRoLWxhc3QtY2hpbGQoLi4uKSBvciA6bnRoKC1sYXN0KT8tb2YtdHlwZSguLi4pXG5cdFx0XHRcdFx0XHRcdGlmICggZGlmZiA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKCBub2RlID0gKytub2RlSW5kZXggJiYgbm9kZSAmJiBub2RlWyBkaXIgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0KCBkaWZmID0gbm9kZUluZGV4ID0gMCApIHx8IHN0YXJ0LnBvcCgpICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGlmICggKCBvZlR5cGUgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUgOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHRub2RlLm5vZGVUeXBlID09PSAxICkgJiZcblx0XHRcdFx0XHRcdFx0XHRcdFx0KytkaWZmICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIENhY2hlIHRoZSBpbmRleCBvZiBlYWNoIGVuY291bnRlcmVkIGVsZW1lbnRcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB1c2VDYWNoZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQoIG5vZGVbIGV4cGFuZG8gXSA9IHt9ICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgbm9kZS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblxuXHRcdFx0Ly8gcHNldWRvLWNsYXNzIG5hbWVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI3BzZXVkby1jbGFzc2VzXG5cdFx0XHQvLyBQcmlvcml0aXplIGJ5IGNhc2Ugc2Vuc2l0aXZpdHkgaW4gY2FzZSBjdXN0b20gcHNldWRvcyBhcmUgYWRkZWQgd2l0aCB1cHBlcmNhc2UgbGV0dGVyc1xuXHRcdFx0Ly8gUmVtZW1iZXIgdGhhdCBzZXRGaWx0ZXJzIGluaGVyaXRzIGZyb20gcHNldWRvc1xuXHRcdFx0dmFyIGFyZ3MsXG5cdFx0XHRcdGZuID0gRXhwci5wc2V1ZG9zWyBwc2V1ZG8gXSB8fCBFeHByLnNldEZpbHRlcnNbIHBzZXVkby50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIFwidW5zdXBwb3J0ZWQgcHNldWRvOiBcIiArIHBzZXVkbyApO1xuXG5cdFx0XHQvLyBUaGUgdXNlciBtYXkgdXNlIGNyZWF0ZVBzZXVkbyB0byBpbmRpY2F0ZSB0aGF0XG5cdFx0XHQvLyBhcmd1bWVudHMgYXJlIG5lZWRlZCB0byBjcmVhdGUgdGhlIGZpbHRlciBmdW5jdGlvblxuXHRcdFx0Ly8ganVzdCBhcyBTaXp6bGUgZG9lc1xuXHRcdFx0aWYgKCBmblsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRyZXR1cm4gZm4oIGFyZ3VtZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEJ1dCBtYWludGFpbiBzdXBwb3J0IGZvciBvbGQgc2lnbmF0dXJlc1xuXHRcdFx0aWYgKCBmbi5sZW5ndGggPiAxICkge1xuXHRcdFx0XHRhcmdzID0gWyBwc2V1ZG8sIHBzZXVkbywgXCJcIiwgYXJndW1lbnQgXTtcblx0XHRcdFx0cmV0dXJuIEV4cHIuc2V0RmlsdGVycy5oYXNPd25Qcm9wZXJ0eSggcHNldWRvLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRcdFx0bWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbIGkgXSApO1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpZHggXSA9ICEoIG1hdGNoZXNbIGlkeCBdID0gbWF0Y2hlZFsgaSBdICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0XHRcdHJldHVybiBmbiggZWxlbSwgMCwgYXJncyApO1xuXHRcdFx0XHRcdH07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBmbjtcblx0XHR9XG5cdH0sXG5cblx0cHNldWRvczoge1xuXG5cdFx0Ly8gUG90ZW50aWFsbHkgY29tcGxleCBwc2V1ZG9zXG5cdFx0XCJub3RcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cblx0XHRcdC8vIFRyaW0gdGhlIHNlbGVjdG9yIHBhc3NlZCB0byBjb21waWxlXG5cdFx0XHQvLyB0byBhdm9pZCB0cmVhdGluZyBsZWFkaW5nIGFuZCB0cmFpbGluZ1xuXHRcdFx0Ly8gc3BhY2VzIGFzIGNvbWJpbmF0b3JzXG5cdFx0XHR2YXIgaW5wdXQgPSBbXSxcblx0XHRcdFx0cmVzdWx0cyA9IFtdLFxuXHRcdFx0XHRtYXRjaGVyID0gY29tcGlsZSggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApICk7XG5cblx0XHRcdHJldHVybiBtYXRjaGVyWyBleHBhbmRvIF0gP1xuXHRcdFx0XHRtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWVkLCBtYXRjaGVzLCBfY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSB1bm1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRzZWVkWyBpIF0gPSAhKCBtYXRjaGVzWyBpIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICkgOlxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgX2NvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFsgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRtYXRjaGVyKCBpbnB1dCwgbnVsbCwgeG1sLCByZXN1bHRzICk7XG5cblx0XHRcdFx0XHQvLyBEb24ndCBrZWVwIHRoZSBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0XHRcdGlucHV0WyAwIF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImhhc1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIFNpenpsZSggc2VsZWN0b3IsIGVsZW0gKS5sZW5ndGggPiAwO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHRleHQgKSB7XG5cdFx0XHR0ZXh0ID0gdGV4dC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRyZXR1cm4gKCBlbGVtLnRleHRDb250ZW50IHx8IGdldFRleHQoIGVsZW0gKSApLmluZGV4T2YoIHRleHQgKSA+IC0xO1xuXHRcdFx0fTtcblx0XHR9ICksXG5cblx0XHQvLyBcIldoZXRoZXIgYW4gZWxlbWVudCBpcyByZXByZXNlbnRlZCBieSBhIDpsYW5nKCkgc2VsZWN0b3Jcblx0XHQvLyBpcyBiYXNlZCBzb2xlbHkgb24gdGhlIGVsZW1lbnQncyBsYW5ndWFnZSB2YWx1ZVxuXHRcdC8vIGJlaW5nIGVxdWFsIHRvIHRoZSBpZGVudGlmaWVyIEMsXG5cdFx0Ly8gb3IgYmVnaW5uaW5nIHdpdGggdGhlIGlkZW50aWZpZXIgQyBpbW1lZGlhdGVseSBmb2xsb3dlZCBieSBcIi1cIi5cblx0XHQvLyBUaGUgbWF0Y2hpbmcgb2YgQyBhZ2FpbnN0IHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWUgaXMgcGVyZm9ybWVkIGNhc2UtaW5zZW5zaXRpdmVseS5cblx0XHQvLyBUaGUgaWRlbnRpZmllciBDIGRvZXMgbm90IGhhdmUgdG8gYmUgYSB2YWxpZCBsYW5ndWFnZSBuYW1lLlwiXG5cdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNsYW5nLXBzZXVkb1xuXHRcdFwibGFuZ1wiOiBtYXJrRnVuY3Rpb24oIGZ1bmN0aW9uKCBsYW5nICkge1xuXG5cdFx0XHQvLyBsYW5nIHZhbHVlIG11c3QgYmUgYSB2YWxpZCBpZGVudGlmaWVyXG5cdFx0XHRpZiAoICFyaWRlbnRpZmllci50ZXN0KCBsYW5nIHx8IFwiXCIgKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbUxhbmcgPSBkb2N1bWVudElzSFRNTCA/XG5cdFx0XHRcdFx0XHRlbGVtLmxhbmcgOlxuXHRcdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGUoIFwieG1sOmxhbmdcIiApIHx8IGVsZW0uZ2V0QXR0cmlidXRlKCBcImxhbmdcIiApICkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoIGVsZW0gPSBlbGVtLnBhcmVudE5vZGUgKSAmJiBlbGVtLm5vZGVUeXBlID09PSAxICk7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH07XG5cdFx0fSApLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiZcblx0XHRcdFx0KCAhZG9jdW1lbnQuaGFzRm9jdXMgfHwgZG9jdW1lbnQuaGFzRm9jdXMoKSApICYmXG5cdFx0XHRcdCEhKCBlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4ICk7XG5cdFx0fSxcblxuXHRcdC8vIEJvb2xlYW4gcHJvcGVydGllc1xuXHRcdFwiZW5hYmxlZFwiOiBjcmVhdGVEaXNhYmxlZFBzZXVkbyggZmFsc2UgKSxcblx0XHRcImRpc2FibGVkXCI6IGNyZWF0ZURpc2FibGVkUHNldWRvKCB0cnVlICksXG5cblx0XHRcImNoZWNrZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgISFlbGVtLmNoZWNrZWQgKSB8fFxuXHRcdFx0XHQoIG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCApO1xuXHRcdH0sXG5cblx0XHRcInNlbGVjdGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC1leHByZXNzaW9uc1xuXHRcdFx0XHRlbGVtLnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGVsZW0uc2VsZWN0ZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdC8vIENvbnRlbnRzXG5cdFx0XCJlbXB0eVwiOiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNlbXB0eS1wc2V1ZG9cblx0XHRcdC8vIDplbXB0eSBpcyBuZWdhdGVkIGJ5IGVsZW1lbnQgKDEpIG9yIGNvbnRlbnQgbm9kZXMgKHRleHQ6IDM7IGNkYXRhOiA0OyBlbnRpdHkgcmVmOiA1KSxcblx0XHRcdC8vICAgYnV0IG5vdCBieSBvdGhlcnMgKGNvbW1lbnQ6IDg7IHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb246IDc7IGV0Yy4pXG5cdFx0XHQvLyBub2RlVHlwZSA8IDYgd29ya3MgYmVjYXVzZSBhdHRyaWJ1dGVzICgyKSBkbyBub3QgYXBwZWFyIGFzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlIDwgNiApIHtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRcInBhcmVudFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAhRXhwci5wc2V1ZG9zWyBcImVtcHR5XCIgXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoICggYXR0ciA9IGVsZW0uZ2V0QXR0cmlidXRlKCBcInR5cGVcIiApICkgPT0gbnVsbCB8fFxuXHRcdFx0XHRcdGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gWyAwIF07XG5cdFx0fSApLFxuXG5cdFx0XCJsYXN0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBfbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gWyBsZW5ndGggLSAxIF07XG5cdFx0fSApLFxuXG5cdFx0XCJlcVwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggX21hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHJldHVybiBbIGFyZ3VtZW50IDwgMCA/IGFyZ3VtZW50ICsgbGVuZ3RoIDogYXJndW1lbnQgXTtcblx0XHR9ICksXG5cblx0XHRcImV2ZW5cIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyggZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0gKSxcblxuXHRcdFwib2RkXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHZhciBpID0gMTtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSArPSAyICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9ICksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oIGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCwgYXJndW1lbnQgKSB7XG5cdFx0XHR2YXIgaSA9IGFyZ3VtZW50IDwgMCA/XG5cdFx0XHRcdGFyZ3VtZW50ICsgbGVuZ3RoIDpcblx0XHRcdFx0YXJndW1lbnQgPiBsZW5ndGggP1xuXHRcdFx0XHRcdGxlbmd0aCA6XG5cdFx0XHRcdFx0YXJndW1lbnQ7XG5cdFx0XHRmb3IgKCA7IC0taSA+PSAwOyApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSApLFxuXG5cdFx0XCJndFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9IClcblx0fVxufTtcblxuRXhwci5wc2V1ZG9zWyBcIm50aFwiIF0gPSBFeHByLnBzZXVkb3NbIFwiZXFcIiBdO1xuXG4vLyBBZGQgYnV0dG9uL2lucHV0IHR5cGUgcHNldWRvc1xuZm9yICggaSBpbiB7IHJhZGlvOiB0cnVlLCBjaGVja2JveDogdHJ1ZSwgZmlsZTogdHJ1ZSwgcGFzc3dvcmQ6IHRydWUsIGltYWdlOiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlSW5wdXRQc2V1ZG8oIGkgKTtcbn1cbmZvciAoIGkgaW4geyBzdWJtaXQ6IHRydWUsIHJlc2V0OiB0cnVlIH0gKSB7XG5cdEV4cHIucHNldWRvc1sgaSBdID0gY3JlYXRlQnV0dG9uUHNldWRvKCBpICk7XG59XG5cbi8vIEVhc3kgQVBJIGZvciBjcmVhdGluZyBuZXcgc2V0RmlsdGVyc1xuZnVuY3Rpb24gc2V0RmlsdGVycygpIHt9XG5zZXRGaWx0ZXJzLnByb3RvdHlwZSA9IEV4cHIuZmlsdGVycyA9IEV4cHIucHNldWRvcztcbkV4cHIuc2V0RmlsdGVycyA9IG5ldyBzZXRGaWx0ZXJzKCk7XG5cbnRva2VuaXplID0gU2l6emxlLnRva2VuaXplID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBwYXJzZU9ubHkgKSB7XG5cdHZhciBtYXRjaGVkLCBtYXRjaCwgdG9rZW5zLCB0eXBlLFxuXHRcdHNvRmFyLCBncm91cHMsIHByZUZpbHRlcnMsXG5cdFx0Y2FjaGVkID0gdG9rZW5DYWNoZVsgc2VsZWN0b3IgKyBcIiBcIiBdO1xuXG5cdGlmICggY2FjaGVkICkge1xuXHRcdHJldHVybiBwYXJzZU9ubHkgPyAwIDogY2FjaGVkLnNsaWNlKCAwICk7XG5cdH1cblxuXHRzb0ZhciA9IHNlbGVjdG9yO1xuXHRncm91cHMgPSBbXTtcblx0cHJlRmlsdGVycyA9IEV4cHIucHJlRmlsdGVyO1xuXG5cdHdoaWxlICggc29GYXIgKSB7XG5cblx0XHQvLyBDb21tYSBhbmQgZmlyc3QgcnVuXG5cdFx0aWYgKCAhbWF0Y2hlZCB8fCAoIG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkgKSApIHtcblx0XHRcdGlmICggbWF0Y2ggKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbIDAgXS5sZW5ndGggKSB8fCBzb0Zhcjtcblx0XHRcdH1cblx0XHRcdGdyb3Vwcy5wdXNoKCAoIHRva2VucyA9IFtdICkgKTtcblx0XHR9XG5cblx0XHRtYXRjaGVkID0gZmFsc2U7XG5cblx0XHQvLyBDb21iaW5hdG9yc1xuXHRcdGlmICggKCBtYXRjaCA9IHJjb21iaW5hdG9ycy5leGVjKCBzb0ZhciApICkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdHZhbHVlOiBtYXRjaGVkLFxuXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFsgMCBdLnJlcGxhY2UoIHJ0cmltLCBcIiBcIiApXG5cdFx0XHR9ICk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAoIG1hdGNoID0gbWF0Y2hFeHByWyB0eXBlIF0uZXhlYyggc29GYXIgKSApICYmICggIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQoIG1hdGNoID0gcHJlRmlsdGVyc1sgdHlwZSBdKCBtYXRjaCApICkgKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKCB7XG5cdFx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0XHRtYXRjaGVzOiBtYXRjaFxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHNvRmFyID0gc29GYXIuc2xpY2UoIG1hdGNoZWQubGVuZ3RoICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCAhbWF0Y2hlZCApIHtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbGVuZ3RoIG9mIHRoZSBpbnZhbGlkIGV4Y2Vzc1xuXHQvLyBpZiB3ZSdyZSBqdXN0IHBhcnNpbmdcblx0Ly8gT3RoZXJ3aXNlLCB0aHJvdyBhbiBlcnJvciBvciByZXR1cm4gdG9rZW5zXG5cdHJldHVybiBwYXJzZU9ubHkgP1xuXHRcdHNvRmFyLmxlbmd0aCA6XG5cdFx0c29GYXIgP1xuXHRcdFx0U2l6emxlLmVycm9yKCBzZWxlY3RvciApIDpcblxuXHRcdFx0Ly8gQ2FjaGUgdGhlIHRva2Vuc1xuXHRcdFx0dG9rZW5DYWNoZSggc2VsZWN0b3IsIGdyb3VwcyApLnNsaWNlKCAwICk7XG59O1xuXG5mdW5jdGlvbiB0b1NlbGVjdG9yKCB0b2tlbnMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSB0b2tlbnMubGVuZ3RoLFxuXHRcdHNlbGVjdG9yID0gXCJcIjtcblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0c2VsZWN0b3IgKz0gdG9rZW5zWyBpIF0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0c2tpcCA9IGNvbWJpbmF0b3IubmV4dCxcblx0XHRrZXkgPSBza2lwIHx8IGRpcixcblx0XHRjaGVja05vbkVsZW1lbnRzID0gYmFzZSAmJiBrZXkgPT09IFwicGFyZW50Tm9kZVwiLFxuXHRcdGRvbmVOYW1lID0gZG9uZSsrO1xuXG5cdHJldHVybiBjb21iaW5hdG9yLmZpcnN0ID9cblxuXHRcdC8vIENoZWNrIGFnYWluc3QgY2xvc2VzdCBhbmNlc3Rvci9wcmVjZWRpbmcgZWxlbWVudFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoICggZWxlbSA9IGVsZW1bIGRpciBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxIHx8IGNoZWNrTm9uRWxlbWVudHMgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgfHwgY2hlY2tOb25FbGVtZW50cyApIHtcblx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBlbGVtWyBleHBhbmRvIF0gfHwgKCBlbGVtWyBleHBhbmRvIF0gPSB7fSApO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8XG5cdFx0XHRcdFx0XHRcdCggb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdID0ge30gKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBza2lwICYmIHNraXAgPT09IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0ZWxlbSA9IGVsZW1bIGRpciBdIHx8IGVsZW07XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCAoIG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGtleSBdICkgJiZcblx0XHRcdFx0XHRcdFx0b2xkQ2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBvbGRDYWNoZVsgMSBdID09PSBkb25lTmFtZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBBc3NpZ24gdG8gbmV3Q2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gKCBuZXdDYWNoZVsgMiBdID0gb2xkQ2FjaGVbIDIgXSApO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBSZXVzZSBuZXdjYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyBrZXkgXSA9IG5ld0NhY2hlO1xuXG5cdFx0XHRcdFx0XHRcdC8vIEEgbWF0Y2ggbWVhbnMgd2UncmUgZG9uZTsgYSBmYWlsIG1lYW5zIHdlIGhhdmUgdG8ga2VlcCBjaGVja2luZ1xuXHRcdFx0XHRcdFx0XHRpZiAoICggbmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9O1xufVxuXG5mdW5jdGlvbiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSB7XG5cdHJldHVybiBtYXRjaGVycy5sZW5ndGggPiAxID9cblx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0dmFyIGkgPSBtYXRjaGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCAhbWF0Y2hlcnNbIGkgXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1sgMCBdO1xufVxuXG5mdW5jdGlvbiBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciwgY29udGV4dHMsIHJlc3VsdHMgKSB7XG5cdHZhciBpID0gMCxcblx0XHRsZW4gPSBjb250ZXh0cy5sZW5ndGg7XG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFNpenpsZSggc2VsZWN0b3IsIGNvbnRleHRzWyBpIF0sIHJlc3VsdHMgKTtcblx0fVxuXHRyZXR1cm4gcmVzdWx0cztcbn1cblxuZnVuY3Rpb24gY29uZGVuc2UoIHVubWF0Y2hlZCwgbWFwLCBmaWx0ZXIsIGNvbnRleHQsIHhtbCApIHtcblx0dmFyIGVsZW0sXG5cdFx0bmV3VW5tYXRjaGVkID0gW10sXG5cdFx0aSA9IDAsXG5cdFx0bGVuID0gdW5tYXRjaGVkLmxlbmd0aCxcblx0XHRtYXBwZWQgPSBtYXAgIT0gbnVsbDtcblxuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRpZiAoICggZWxlbSA9IHVubWF0Y2hlZFsgaSBdICkgKSB7XG5cdFx0XHRpZiAoICFmaWx0ZXIgfHwgZmlsdGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0bmV3VW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0aWYgKCBtYXBwZWQgKSB7XG5cdFx0XHRcdFx0bWFwLnB1c2goIGkgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiBuZXdVbm1hdGNoZWQ7XG59XG5cbmZ1bmN0aW9uIHNldE1hdGNoZXIoIHByZUZpbHRlciwgc2VsZWN0b3IsIG1hdGNoZXIsIHBvc3RGaWx0ZXIsIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApIHtcblx0aWYgKCBwb3N0RmlsdGVyICYmICFwb3N0RmlsdGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbHRlciA9IHNldE1hdGNoZXIoIHBvc3RGaWx0ZXIgKTtcblx0fVxuXHRpZiAoIHBvc3RGaW5kZXIgJiYgIXBvc3RGaW5kZXJbIGV4cGFuZG8gXSApIHtcblx0XHRwb3N0RmluZGVyID0gc2V0TWF0Y2hlciggcG9zdEZpbmRlciwgcG9zdFNlbGVjdG9yICk7XG5cdH1cblx0cmV0dXJuIG1hcmtGdW5jdGlvbiggZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKFxuXHRcdFx0XHRzZWxlY3RvciB8fCBcIipcIixcblx0XHRcdFx0Y29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCxcblx0XHRcdFx0W11cblx0XHRcdCksXG5cblx0XHRcdC8vIFByZWZpbHRlciB0byBnZXQgbWF0Y2hlciBpbnB1dCwgcHJlc2VydmluZyBhIG1hcCBmb3Igc2VlZC1yZXN1bHRzIHN5bmNocm9uaXphdGlvblxuXHRcdFx0bWF0Y2hlckluID0gcHJlRmlsdGVyICYmICggc2VlZCB8fCAhc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGNvbmRlbnNlKCBlbGVtcywgcHJlTWFwLCBwcmVGaWx0ZXIsIGNvbnRleHQsIHhtbCApIDpcblx0XHRcdFx0ZWxlbXMsXG5cblx0XHRcdG1hdGNoZXJPdXQgPSBtYXRjaGVyID9cblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKCBlbGVtID0gdGVtcFsgaSBdICkgKSB7XG5cdFx0XHRcdFx0bWF0Y2hlck91dFsgcG9zdE1hcFsgaSBdIF0gPSAhKCBtYXRjaGVySW5bIHBvc3RNYXBbIGkgXSBdID0gZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyIHx8IHByZUZpbHRlciApIHtcblx0XHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKCBlbGVtID0gbWF0Y2hlck91dFsgaSBdICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAoIG1hdGNoZXJJblsgaSBdID0gZWxlbSApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsICggbWF0Y2hlck91dCA9IFtdICksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoICggZWxlbSA9IG1hdGNoZXJPdXRbIGkgXSApICYmXG5cdFx0XHRcdFx0XHQoIHRlbXAgPSBwb3N0RmluZGVyID8gaW5kZXhPZiggc2VlZCwgZWxlbSApIDogcHJlTWFwWyBpIF0gKSA+IC0xICkge1xuXG5cdFx0XHRcdFx0XHRzZWVkWyB0ZW1wIF0gPSAhKCByZXN1bHRzWyB0ZW1wIF0gPSBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBBZGQgZWxlbWVudHMgdG8gcmVzdWx0cywgdGhyb3VnaCBwb3N0RmluZGVyIGlmIGRlZmluZWRcblx0XHR9IGVsc2Uge1xuXHRcdFx0bWF0Y2hlck91dCA9IGNvbmRlbnNlKFxuXHRcdFx0XHRtYXRjaGVyT3V0ID09PSByZXN1bHRzID9cblx0XHRcdFx0XHRtYXRjaGVyT3V0LnNwbGljZSggcHJlZXhpc3RpbmcsIG1hdGNoZXJPdXQubGVuZ3RoICkgOlxuXHRcdFx0XHRcdG1hdGNoZXJPdXRcblx0XHRcdCk7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdHBvc3RGaW5kZXIoIG51bGwsIHJlc3VsdHMsIG1hdGNoZXJPdXQsIHhtbCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cywgbWF0Y2hlck91dCApO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWyAwIF0udHlwZSBdLFxuXHRcdGltcGxpY2l0UmVsYXRpdmUgPSBsZWFkaW5nUmVsYXRpdmUgfHwgRXhwci5yZWxhdGl2ZVsgXCIgXCIgXSxcblx0XHRpID0gbGVhZGluZ1JlbGF0aXZlID8gMSA6IDAsXG5cblx0XHQvLyBUaGUgZm91bmRhdGlvbmFsIG1hdGNoZXIgZW5zdXJlcyB0aGF0IGVsZW1lbnRzIGFyZSByZWFjaGFibGUgZnJvbSB0b3AtbGV2ZWwgY29udGV4dChzKVxuXHRcdG1hdGNoQ29udGV4dCA9IGFkZENvbWJpbmF0b3IoIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGNoZWNrQ29udGV4dDtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hBbnlDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZiggY2hlY2tDb250ZXh0LCBlbGVtICkgPiAtMTtcblx0XHR9LCBpbXBsaWNpdFJlbGF0aXZlLCB0cnVlICksXG5cdFx0bWF0Y2hlcnMgPSBbIGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgcmV0ID0gKCAhbGVhZGluZ1JlbGF0aXZlICYmICggeG1sIHx8IGNvbnRleHQgIT09IG91dGVybW9zdENvbnRleHQgKSApIHx8IChcblx0XHRcdFx0KCBjaGVja0NvbnRleHQgPSBjb250ZXh0ICkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblxuXHRcdFx0Ly8gQXZvaWQgaGFuZ2luZyBvbnRvIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRjaGVja0NvbnRleHQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9IF07XG5cblx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0aWYgKCAoIG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGkgXS50eXBlIF0gKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKCBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSwgbWF0Y2hlciApIF07XG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXIgPSBFeHByLmZpbHRlclsgdG9rZW5zWyBpIF0udHlwZSBdLmFwcGx5KCBudWxsLCB0b2tlbnNbIGkgXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblxuXHRcdFx0XHQvLyBGaW5kIHRoZSBuZXh0IHJlbGF0aXZlIG9wZXJhdG9yIChpZiBhbnkpIGZvciBwcm9wZXIgaGFuZGxpbmdcblx0XHRcdFx0aiA9ICsraTtcblx0XHRcdFx0Zm9yICggOyBqIDwgbGVuOyBqKysgKSB7XG5cdFx0XHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyB0b2tlbnNbIGogXS50eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHNldE1hdGNoZXIoXG5cdFx0XHRcdFx0aSA+IDEgJiYgZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICksXG5cdFx0XHRcdFx0aSA+IDEgJiYgdG9TZWxlY3RvcihcblxuXHRcdFx0XHRcdC8vIElmIHRoZSBwcmVjZWRpbmcgdG9rZW4gd2FzIGEgZGVzY2VuZGFudCBjb21iaW5hdG9yLCBpbnNlcnQgYW4gaW1wbGljaXQgYW55LWVsZW1lbnQgYCpgXG5cdFx0XHRcdFx0dG9rZW5zXG5cdFx0XHRcdFx0XHQuc2xpY2UoIDAsIGkgLSAxIClcblx0XHRcdFx0XHRcdC5jb25jYXQoIHsgdmFsdWU6IHRva2Vuc1sgaSAtIDIgXS50eXBlID09PSBcIiBcIiA/IFwiKlwiIDogXCJcIiB9IClcblx0XHRcdFx0XHQpLnJlcGxhY2UoIHJ0cmltLCBcIiQxXCIgKSxcblx0XHRcdFx0XHRtYXRjaGVyLFxuXHRcdFx0XHRcdGkgPCBqICYmIG1hdGNoZXJGcm9tVG9rZW5zKCB0b2tlbnMuc2xpY2UoIGksIGogKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgbWF0Y2hlckZyb21Ub2tlbnMoICggdG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkgKSApLFxuXHRcdFx0XHRcdGogPCBsZW4gJiYgdG9TZWxlY3RvciggdG9rZW5zIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHRcdG1hdGNoZXJzLnB1c2goIG1hdGNoZXIgKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudE1hdGNoZXIoIG1hdGNoZXJzICk7XG59XG5cbmZ1bmN0aW9uIG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApIHtcblx0dmFyIGJ5U2V0ID0gc2V0TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRieUVsZW1lbnQgPSBlbGVtZW50TWF0Y2hlcnMubGVuZ3RoID4gMCxcblx0XHRzdXBlck1hdGNoZXIgPSBmdW5jdGlvbiggc2VlZCwgY29udGV4dCwgeG1sLCByZXN1bHRzLCBvdXRlcm1vc3QgKSB7XG5cdFx0XHR2YXIgZWxlbSwgaiwgbWF0Y2hlcixcblx0XHRcdFx0bWF0Y2hlZENvdW50ID0gMCxcblx0XHRcdFx0aSA9IFwiMFwiLFxuXHRcdFx0XHR1bm1hdGNoZWQgPSBzZWVkICYmIFtdLFxuXHRcdFx0XHRzZXRNYXRjaGVkID0gW10sXG5cdFx0XHRcdGNvbnRleHRCYWNrdXAgPSBvdXRlcm1vc3RDb250ZXh0LFxuXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbIFwiVEFHXCIgXSggXCIqXCIsIG91dGVybW9zdCApLFxuXG5cdFx0XHRcdC8vIFVzZSBpbnRlZ2VyIGRpcnJ1bnMgaWZmIHRoaXMgaXMgdGhlIG91dGVybW9zdCBtYXRjaGVyXG5cdFx0XHRcdGRpcnJ1bnNVbmlxdWUgPSAoIGRpcnJ1bnMgKz0gY29udGV4dEJhY2t1cCA9PSBudWxsID8gMSA6IE1hdGgucmFuZG9tKCkgfHwgMC4xICksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTErLCBFZGdlIDE3IC0gMTgrXG5cdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHQvLyB0d28gZG9jdW1lbnRzOyBzaGFsbG93IGNvbXBhcmlzb25zIHdvcmsuXG5cdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBlcWVxZXFcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHQgPT0gZG9jdW1lbnQgfHwgY29udGV4dCB8fCBvdXRlcm1vc3Q7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEFkZCBlbGVtZW50cyBwYXNzaW5nIGVsZW1lbnRNYXRjaGVycyBkaXJlY3RseSB0byByZXN1bHRzXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTw5LCBTYWZhcmlcblx0XHRcdC8vIFRvbGVyYXRlIE5vZGVMaXN0IHByb3BlcnRpZXMgKElFOiBcImxlbmd0aFwiOyBTYWZhcmk6IDxudW1iZXI+KSBtYXRjaGluZyBlbGVtZW50cyBieSBpZFxuXHRcdFx0Zm9yICggOyBpICE9PSBsZW4gJiYgKCBlbGVtID0gZWxlbXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdFx0aWYgKCBieUVsZW1lbnQgJiYgZWxlbSApIHtcblx0XHRcdFx0XHRqID0gMDtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDExKywgRWRnZSAxNyAtIDE4K1xuXHRcdFx0XHRcdC8vIElFL0VkZ2Ugc29tZXRpbWVzIHRocm93IGEgXCJQZXJtaXNzaW9uIGRlbmllZFwiIGVycm9yIHdoZW4gc3RyaWN0LWNvbXBhcmluZ1xuXHRcdFx0XHRcdC8vIHR3byBkb2N1bWVudHM7IHNoYWxsb3cgY29tcGFyaXNvbnMgd29yay5cblx0XHRcdFx0XHQvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZXFlcWVxXG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHRcdFx0XHRcdFx0eG1sID0gIWRvY3VtZW50SXNIVE1MO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUcmFjayB1bm1hdGNoZWQgZWxlbWVudHMgZm9yIHNldCBmaWx0ZXJzXG5cdFx0XHRcdGlmICggYnlTZXQgKSB7XG5cblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoIGVsZW0gPSAhbWF0Y2hlciAmJiBlbGVtICkgKSB7XG5cdFx0XHRcdFx0XHRtYXRjaGVkQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBMZW5ndGhlbiB0aGUgYXJyYXkgZm9yIGV2ZXJ5IGVsZW1lbnQsIG1hdGNoZWQgb3Igbm90XG5cdFx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdFx0dW5tYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gYGlgIGlzIG5vdyB0aGUgY291bnQgb2YgZWxlbWVudHMgdmlzaXRlZCBhYm92ZSwgYW5kIGFkZGluZyBpdCB0byBgbWF0Y2hlZENvdW50YFxuXHRcdFx0Ly8gbWFrZXMgdGhlIGxhdHRlciBub25uZWdhdGl2ZS5cblx0XHRcdG1hdGNoZWRDb3VudCArPSBpO1xuXG5cdFx0XHQvLyBBcHBseSBzZXQgZmlsdGVycyB0byB1bm1hdGNoZWQgZWxlbWVudHNcblx0XHRcdC8vIE5PVEU6IFRoaXMgY2FuIGJlIHNraXBwZWQgaWYgdGhlcmUgYXJlIG5vIHVubWF0Y2hlZCBlbGVtZW50cyAoaS5lLiwgYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIGVxdWFscyBgaWApLCB1bmxlc3Mgd2UgZGlkbid0IHZpc2l0IF9hbnlfIGVsZW1lbnRzIGluIHRoZSBhYm92ZSBsb29wIGJlY2F1c2Ugd2UgaGF2ZVxuXHRcdFx0Ly8gbm8gZWxlbWVudCBtYXRjaGVycyBhbmQgbm8gc2VlZC5cblx0XHRcdC8vIEluY3JlbWVudGluZyBhbiBpbml0aWFsbHktc3RyaW5nIFwiMFwiIGBpYCBhbGxvd3MgYGlgIHRvIHJlbWFpbiBhIHN0cmluZyBvbmx5IGluIHRoYXRcblx0XHRcdC8vIGNhc2UsIHdoaWNoIHdpbGwgcmVzdWx0IGluIGEgXCIwMFwiIGBtYXRjaGVkQ291bnRgIHRoYXQgZGlmZmVycyBmcm9tIGBpYCBidXQgaXMgYWxzb1xuXHRcdFx0Ly8gbnVtZXJpY2FsbHkgemVyby5cblx0XHRcdGlmICggYnlTZXQgJiYgaSAhPT0gbWF0Y2hlZENvdW50ICkge1xuXHRcdFx0XHRqID0gMDtcblx0XHRcdFx0d2hpbGUgKCAoIG1hdGNoZXIgPSBzZXRNYXRjaGVyc1sgaisrIF0gKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXG5cdFx0XHRcdFx0Ly8gUmVpbnRlZ3JhdGUgZWxlbWVudCBtYXRjaGVzIHRvIGVsaW1pbmF0ZSB0aGUgbmVlZCBmb3Igc29ydGluZ1xuXHRcdFx0XHRcdGlmICggbWF0Y2hlZENvdW50ID4gMCApIHtcblx0XHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0XHRpZiAoICEoIHVubWF0Y2hlZFsgaSBdIHx8IHNldE1hdGNoZWRbIGkgXSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHNldE1hdGNoZWRbIGkgXSA9IHBvcC5jYWxsKCByZXN1bHRzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBEaXNjYXJkIGluZGV4IHBsYWNlaG9sZGVyIHZhbHVlcyB0byBnZXQgb25seSBhY3R1YWwgbWF0Y2hlc1xuXHRcdFx0XHRcdHNldE1hdGNoZWQgPSBjb25kZW5zZSggc2V0TWF0Y2hlZCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQWRkIG1hdGNoZXMgdG8gcmVzdWx0c1xuXHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZXRNYXRjaGVkICk7XG5cblx0XHRcdFx0Ly8gU2VlZGxlc3Mgc2V0IG1hdGNoZXMgc3VjY2VlZGluZyBtdWx0aXBsZSBzdWNjZXNzZnVsIG1hdGNoZXJzIHN0aXB1bGF0ZSBzb3J0aW5nXG5cdFx0XHRcdGlmICggb3V0ZXJtb3N0ICYmICFzZWVkICYmIHNldE1hdGNoZWQubGVuZ3RoID4gMCAmJlxuXHRcdFx0XHRcdCggbWF0Y2hlZENvdW50ICsgc2V0TWF0Y2hlcnMubGVuZ3RoICkgPiAxICkge1xuXG5cdFx0XHRcdFx0U2l6emxlLnVuaXF1ZVNvcnQoIHJlc3VsdHMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBPdmVycmlkZSBtYW5pcHVsYXRpb24gb2YgZ2xvYmFscyBieSBuZXN0ZWQgbWF0Y2hlcnNcblx0XHRcdGlmICggb3V0ZXJtb3N0ICkge1xuXHRcdFx0XHRkaXJydW5zID0gZGlycnVuc1VuaXF1ZTtcblx0XHRcdFx0b3V0ZXJtb3N0Q29udGV4dCA9IGNvbnRleHRCYWNrdXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB1bm1hdGNoZWQ7XG5cdFx0fTtcblxuXHRyZXR1cm4gYnlTZXQgP1xuXHRcdG1hcmtGdW5jdGlvbiggc3VwZXJNYXRjaGVyICkgOlxuXHRcdHN1cGVyTWF0Y2hlcjtcbn1cblxuY29tcGlsZSA9IFNpenpsZS5jb21waWxlID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBtYXRjaCAvKiBJbnRlcm5hbCBVc2UgT25seSAqLyApIHtcblx0dmFyIGksXG5cdFx0c2V0TWF0Y2hlcnMgPSBbXSxcblx0XHRlbGVtZW50TWF0Y2hlcnMgPSBbXSxcblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlWyBzZWxlY3RvciArIFwiIFwiIF07XG5cblx0aWYgKCAhY2FjaGVkICkge1xuXG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoWyBpIF0gKTtcblx0XHRcdGlmICggY2FjaGVkWyBleHBhbmRvIF0gKSB7XG5cdFx0XHRcdHNldE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZWxlbWVudE1hdGNoZXJzLnB1c2goIGNhY2hlZCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIENhY2hlIHRoZSBjb21waWxlZCBmdW5jdGlvblxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGUoXG5cdFx0XHRzZWxlY3Rvcixcblx0XHRcdG1hdGNoZXJGcm9tR3JvdXBNYXRjaGVycyggZWxlbWVudE1hdGNoZXJzLCBzZXRNYXRjaGVycyApXG5cdFx0KTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKCBzZWxlY3RvciA9IGNvbXBpbGVkLnNlbGVjdG9yIHx8IHNlbGVjdG9yICkgKTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBUcnkgdG8gbWluaW1pemUgb3BlcmF0aW9ucyBpZiB0aGVyZSBpcyBvbmx5IG9uZSBzZWxlY3RvciBpbiB0aGUgbGlzdCBhbmQgbm8gc2VlZFxuXHQvLyAodGhlIGxhdHRlciBvZiB3aGljaCBndWFyYW50ZWVzIHVzIGNvbnRleHQpXG5cdGlmICggbWF0Y2gubGVuZ3RoID09PSAxICkge1xuXG5cdFx0Ly8gUmVkdWNlIGNvbnRleHQgaWYgdGhlIGxlYWRpbmcgY29tcG91bmQgc2VsZWN0b3IgaXMgYW4gSURcblx0XHR0b2tlbnMgPSBtYXRjaFsgMCBdID0gbWF0Y2hbIDAgXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKCB0b2tlbiA9IHRva2Vuc1sgMCBdICkudHlwZSA9PT0gXCJJRFwiICYmXG5cdFx0XHRjb250ZXh0Lm5vZGVUeXBlID09PSA5ICYmIGRvY3VtZW50SXNIVE1MICYmIEV4cHIucmVsYXRpdmVbIHRva2Vuc1sgMSBdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kWyBcIklEXCIgXSggdG9rZW4ubWF0Y2hlc1sgMCBdXG5cdFx0XHRcdC5yZXBsYWNlKCBydW5lc2NhcGUsIGZ1bmVzY2FwZSApLCBjb250ZXh0ICkgfHwgW10gKVsgMCBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwclsgXCJuZWVkc0NvbnRleHRcIiBdLnRlc3QoIHNlbGVjdG9yICkgPyAwIDogdG9rZW5zLmxlbmd0aDtcblx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdHRva2VuID0gdG9rZW5zWyBpIF07XG5cblx0XHRcdC8vIEFib3J0IGlmIHdlIGhpdCBhIGNvbWJpbmF0b3Jcblx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgKCB0eXBlID0gdG9rZW4udHlwZSApIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoIGZpbmQgPSBFeHByLmZpbmRbIHR5cGUgXSApICkge1xuXG5cdFx0XHRcdC8vIFNlYXJjaCwgZXhwYW5kaW5nIGNvbnRleHQgZm9yIGxlYWRpbmcgc2libGluZyBjb21iaW5hdG9yc1xuXHRcdFx0XHRpZiAoICggc2VlZCA9IGZpbmQoXG5cdFx0XHRcdFx0dG9rZW4ubWF0Y2hlc1sgMCBdLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICksXG5cdFx0XHRcdFx0cnNpYmxpbmcudGVzdCggdG9rZW5zWyAwIF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fFxuXHRcdFx0XHRcdFx0Y29udGV4dFxuXHRcdFx0XHQpICkgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiBzZWVkIGlzIGVtcHR5IG9yIG5vIHRva2VucyByZW1haW4sIHdlIGNhbiByZXR1cm4gZWFybHlcblx0XHRcdFx0XHR0b2tlbnMuc3BsaWNlKCBpLCAxICk7XG5cdFx0XHRcdFx0c2VsZWN0b3IgPSBzZWVkLmxlbmd0aCAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKTtcblx0XHRcdFx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNlZWQgKTtcblx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ29tcGlsZSBhbmQgZXhlY3V0ZSBhIGZpbHRlcmluZyBmdW5jdGlvbiBpZiBvbmUgaXMgbm90IHByb3ZpZGVkXG5cdC8vIFByb3ZpZGUgYG1hdGNoYCB0byBhdm9pZCByZXRva2VuaXphdGlvbiBpZiB3ZSBtb2RpZmllZCB0aGUgc2VsZWN0b3IgYWJvdmVcblx0KCBjb21waWxlZCB8fCBjb21waWxlKCBzZWxlY3RvciwgbWF0Y2ggKSApKFxuXHRcdHNlZWQsXG5cdFx0Y29udGV4dCxcblx0XHQhZG9jdW1lbnRJc0hUTUwsXG5cdFx0cmVzdWx0cyxcblx0XHQhY29udGV4dCB8fCByc2libGluZy50ZXN0KCBzZWxlY3RvciApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdCk7XG5cdHJldHVybiByZXN1bHRzO1xufTtcblxuLy8gT25lLXRpbWUgYXNzaWdubWVudHNcblxuLy8gU29ydCBzdGFiaWxpdHlcbnN1cHBvcnQuc29ydFN0YWJsZSA9IGV4cGFuZG8uc3BsaXQoIFwiXCIgKS5zb3J0KCBzb3J0T3JkZXIgKS5qb2luKCBcIlwiICkgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cblx0Ly8gU2hvdWxkIHJldHVybiAxLCBidXQgcmV0dXJucyA0IChmb2xsb3dpbmcpXG5cdHJldHVybiBlbC5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJmaWVsZHNldFwiICkgKSAmIDE7XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFPDhcbi8vIFByZXZlbnQgYXR0cmlidXRlL3Byb3BlcnR5IFwiaW50ZXJwb2xhdGlvblwiXG4vLyBodHRwczovL21zZG4ubWljcm9zb2Z0LmNvbS9lbi11cy9saWJyYXJ5L21zNTM2NDI5JTI4VlMuODUlMjkuYXNweFxuaWYgKCAhYXNzZXJ0KCBmdW5jdGlvbiggZWwgKSB7XG5cdGVsLmlubmVySFRNTCA9IFwiPGEgaHJlZj0nIyc+PC9hPlwiO1xuXHRyZXR1cm4gZWwuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoIFwiaHJlZlwiICkgPT09IFwiI1wiO1xufSApICkge1xuXHRhZGRIYW5kbGUoIFwidHlwZXxocmVmfGhlaWdodHx3aWR0aFwiLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUsIG5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJ0eXBlXCIgPyAxIDogMiApO1xuXHRcdH1cblx0fSApO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRlbC5pbm5lckhUTUwgPSBcIjxpbnB1dC8+XCI7XG5cdGVsLmZpcnN0Q2hpbGQuc2V0QXR0cmlidXRlKCBcInZhbHVlXCIsIFwiXCIgKTtcblx0cmV0dXJuIGVsLmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0gKSApIHtcblx0YWRkSGFuZGxlKCBcInZhbHVlXCIsIGZ1bmN0aW9uKCBlbGVtLCBfbmFtZSwgaXNYTUwgKSB7XG5cdFx0aWYgKCAhaXNYTUwgJiYgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBcImlucHV0XCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5kZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9ICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydCggZnVuY3Rpb24oIGVsICkge1xuXHRyZXR1cm4gZWwuZ2V0QXR0cmlidXRlKCBcImRpc2FibGVkXCIgKSA9PSBudWxsO1xufSApICkge1xuXHRhZGRIYW5kbGUoIGJvb2xlYW5zLCBmdW5jdGlvbiggZWxlbSwgbmFtZSwgaXNYTUwgKSB7XG5cdFx0dmFyIHZhbDtcblx0XHRpZiAoICFpc1hNTCApIHtcblx0XHRcdHJldHVybiBlbGVtWyBuYW1lIF0gPT09IHRydWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOlxuXHRcdFx0XHQoIHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZSggbmFtZSApICkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdFx0dmFsLnZhbHVlIDpcblx0XHRcdFx0XHRudWxsO1xuXHRcdH1cblx0fSApO1xufVxuXG5yZXR1cm4gU2l6emxlO1xuXG59ICkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5cbi8vIERlcHJlY2F0ZWRcbmpRdWVyeS5leHByWyBcIjpcIiBdID0galF1ZXJ5LmV4cHIucHNldWRvcztcbmpRdWVyeS51bmlxdWVTb3J0ID0galF1ZXJ5LnVuaXF1ZSA9IFNpenpsZS51bmlxdWVTb3J0O1xualF1ZXJ5LnRleHQgPSBTaXp6bGUuZ2V0VGV4dDtcbmpRdWVyeS5pc1hNTERvYyA9IFNpenpsZS5pc1hNTDtcbmpRdWVyeS5jb250YWlucyA9IFNpenpsZS5jb250YWlucztcbmpRdWVyeS5lc2NhcGVTZWxlY3RvciA9IFNpenpsZS5lc2NhcGU7XG5cblxuXG5cbnZhciBkaXIgPSBmdW5jdGlvbiggZWxlbSwgZGlyLCB1bnRpbCApIHtcblx0dmFyIG1hdGNoZWQgPSBbXSxcblx0XHR0cnVuY2F0ZSA9IHVudGlsICE9PSB1bmRlZmluZWQ7XG5cblx0d2hpbGUgKCAoIGVsZW0gPSBlbGVtWyBkaXIgXSApICYmIGVsZW0ubm9kZVR5cGUgIT09IDkgKSB7XG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0aWYgKCB0cnVuY2F0ZSAmJiBqUXVlcnkoIGVsZW0gKS5pcyggdW50aWwgKSApIHtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRtYXRjaGVkLnB1c2goIGVsZW0gKTtcblx0XHR9XG5cdH1cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBzaWJsaW5ncyA9IGZ1bmN0aW9uKCBuLCBlbGVtICkge1xuXHR2YXIgbWF0Y2hlZCA9IFtdO1xuXG5cdGZvciAoIDsgbjsgbiA9IG4ubmV4dFNpYmxpbmcgKSB7XG5cdFx0aWYgKCBuLm5vZGVUeXBlID09PSAxICYmIG4gIT09IGVsZW0gKSB7XG5cdFx0XHRtYXRjaGVkLnB1c2goIG4gKTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbWF0Y2hlZDtcbn07XG5cblxudmFyIHJuZWVkc0NvbnRleHQgPSBqUXVlcnkuZXhwci5tYXRjaC5uZWVkc0NvbnRleHQ7XG5cblxuXG5mdW5jdGlvbiBub2RlTmFtZSggZWxlbSwgbmFtZSApIHtcblxuICByZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblxufTtcbnZhciByc2luZ2xlVGFnID0gKCAvXjwoW2Etel1bXlxcL1xcMD46XFx4MjBcXHRcXHJcXG5cXGZdKilbXFx4MjBcXHRcXHJcXG5cXGZdKlxcLz8+KD86PFxcL1xcMT58KSQvaSApO1xuXG5cblxuLy8gSW1wbGVtZW50IHRoZSBpZGVudGljYWwgZnVuY3Rpb25hbGl0eSBmb3IgZmlsdGVyIGFuZCBub3RcbmZ1bmN0aW9uIHdpbm5vdyggZWxlbWVudHMsIHF1YWxpZmllciwgbm90ICkge1xuXHRpZiAoIGlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0cmV0dXJuICEhcXVhbGlmaWVyLmNhbGwoIGVsZW0sIGksIGVsZW0gKSAhPT0gbm90O1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIFNpbmdsZSBlbGVtZW50XG5cdGlmICggcXVhbGlmaWVyLm5vZGVUeXBlICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggZWxlbSA9PT0gcXVhbGlmaWVyICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBBcnJheWxpa2Ugb2YgZWxlbWVudHMgKGpRdWVyeSwgYXJndW1lbnRzLCBBcnJheSlcblx0aWYgKCB0eXBlb2YgcXVhbGlmaWVyICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBGaWx0ZXJlZCBkaXJlY3RseSBmb3IgYm90aCBzaW1wbGUgYW5kIGNvbXBsZXggc2VsZWN0b3JzXG5cdHJldHVybiBqUXVlcnkuZmlsdGVyKCBxdWFsaWZpZXIsIGVsZW1lbnRzLCBub3QgKTtcbn1cblxualF1ZXJ5LmZpbHRlciA9IGZ1bmN0aW9uKCBleHByLCBlbGVtcywgbm90ICkge1xuXHR2YXIgZWxlbSA9IGVsZW1zWyAwIF07XG5cblx0aWYgKCBub3QgKSB7XG5cdFx0ZXhwciA9IFwiOm5vdChcIiArIGV4cHIgKyBcIilcIjtcblx0fVxuXG5cdGlmICggZWxlbXMubGVuZ3RoID09PSAxICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZWxlbSwgZXhwciApID8gWyBlbGVtIF0gOiBbXTtcblx0fVxuXG5cdHJldHVybiBqUXVlcnkuZmluZC5tYXRjaGVzKCBleHByLCBqUXVlcnkuZ3JlcCggZWxlbXMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVUeXBlID09PSAxO1xuXHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLCByZXQsXG5cdFx0XHRsZW4gPSB0aGlzLmxlbmd0aCxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0cmV0ID0gdGhpcy5wdXNoU3RhY2soIFtdICk7XG5cblx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0alF1ZXJ5LmZpbmQoIHNlbGVjdG9yLCBzZWxmWyBpIF0sIHJldCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBsZW4gPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIHJldCApIDogcmV0O1xuXHR9LFxuXHRmaWx0ZXI6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHdpbm5vdyggdGhpcywgc2VsZWN0b3IgfHwgW10sIGZhbHNlICkgKTtcblx0fSxcblx0bm90OiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCB0cnVlICkgKTtcblx0fSxcblx0aXM6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gISF3aW5ub3coXG5cdFx0XHR0aGlzLFxuXG5cdFx0XHQvLyBJZiB0aGlzIGlzIGEgcG9zaXRpb25hbC9yZWxhdGl2ZSBzZWxlY3RvciwgY2hlY2sgbWVtYmVyc2hpcCBpbiB0aGUgcmV0dXJuZWQgc2V0XG5cdFx0XHQvLyBzbyAkKFwicDpmaXJzdFwiKS5pcyhcInA6bGFzdFwiKSB3b24ndCByZXR1cm4gdHJ1ZSBmb3IgYSBkb2Mgd2l0aCB0d28gXCJwXCIuXG5cdFx0XHR0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgJiYgcm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApID9cblx0XHRcdFx0alF1ZXJ5KCBzZWxlY3RvciApIDpcblx0XHRcdFx0c2VsZWN0b3IgfHwgW10sXG5cdFx0XHRmYWxzZVxuXHRcdCkubGVuZ3RoO1xuXHR9XG59ICk7XG5cblxuLy8gSW5pdGlhbGl6ZSBhIGpRdWVyeSBvYmplY3RcblxuXG4vLyBBIGNlbnRyYWwgcmVmZXJlbmNlIHRvIHRoZSByb290IGpRdWVyeShkb2N1bWVudClcbnZhciByb290alF1ZXJ5LFxuXG5cdC8vIEEgc2ltcGxlIHdheSB0byBjaGVjayBmb3IgSFRNTCBzdHJpbmdzXG5cdC8vIFByaW9yaXRpemUgI2lkIG92ZXIgPHRhZz4gdG8gYXZvaWQgWFNTIHZpYSBsb2NhdGlvbi5oYXNoICgjOTUyMSlcblx0Ly8gU3RyaWN0IEhUTUwgcmVjb2duaXRpb24gKCMxMTI5MDogbXVzdCBzdGFydCB3aXRoIDwpXG5cdC8vIFNob3J0Y3V0IHNpbXBsZSAjaWQgY2FzZSBmb3Igc3BlZWRcblx0cnF1aWNrRXhwciA9IC9eKD86XFxzKig8W1xcd1xcV10rPilbXj5dKnwjKFtcXHctXSspKSQvLFxuXG5cdGluaXQgPSBqUXVlcnkuZm4uaW5pdCA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCwgcm9vdCApIHtcblx0XHR2YXIgbWF0Y2gsIGVsZW07XG5cblx0XHQvLyBIQU5ETEU6ICQoXCJcIiksICQobnVsbCksICQodW5kZWZpbmVkKSwgJChmYWxzZSlcblx0XHRpZiAoICFzZWxlY3RvciApIHtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblxuXHRcdC8vIE1ldGhvZCBpbml0KCkgYWNjZXB0cyBhbiBhbHRlcm5hdGUgcm9vdGpRdWVyeVxuXHRcdC8vIHNvIG1pZ3JhdGUgY2FuIHN1cHBvcnQgalF1ZXJ5LnN1YiAoZ2gtMjEwMSlcblx0XHRyb290ID0gcm9vdCB8fCByb290alF1ZXJ5O1xuXG5cdFx0Ly8gSGFuZGxlIEhUTUwgc3RyaW5nc1xuXHRcdGlmICggdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0aWYgKCBzZWxlY3RvclsgMCBdID09PSBcIjxcIiAmJlxuXHRcdFx0XHRzZWxlY3Rvclsgc2VsZWN0b3IubGVuZ3RoIC0gMSBdID09PSBcIj5cIiAmJlxuXHRcdFx0XHRzZWxlY3Rvci5sZW5ndGggPj0gMyApIHtcblxuXHRcdFx0XHQvLyBBc3N1bWUgdGhhdCBzdHJpbmdzIHRoYXQgc3RhcnQgYW5kIGVuZCB3aXRoIDw+IGFyZSBIVE1MIGFuZCBza2lwIHRoZSByZWdleCBjaGVja1xuXHRcdFx0XHRtYXRjaCA9IFsgbnVsbCwgc2VsZWN0b3IsIG51bGwgXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1hdGNoIGh0bWwgb3IgbWFrZSBzdXJlIG5vIGNvbnRleHQgaXMgc3BlY2lmaWVkIGZvciAjaWRcblx0XHRcdGlmICggbWF0Y2ggJiYgKCBtYXRjaFsgMSBdIHx8ICFjb250ZXh0ICkgKSB7XG5cblx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwpIC0+ICQoYXJyYXkpXG5cdFx0XHRcdGlmICggbWF0Y2hbIDEgXSApIHtcblx0XHRcdFx0XHRjb250ZXh0ID0gY29udGV4dCBpbnN0YW5jZW9mIGpRdWVyeSA/IGNvbnRleHRbIDAgXSA6IGNvbnRleHQ7XG5cblx0XHRcdFx0XHQvLyBPcHRpb24gdG8gcnVuIHNjcmlwdHMgaXMgdHJ1ZSBmb3IgYmFjay1jb21wYXRcblx0XHRcdFx0XHQvLyBJbnRlbnRpb25hbGx5IGxldCB0aGUgZXJyb3IgYmUgdGhyb3duIGlmIHBhcnNlSFRNTCBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcywgalF1ZXJ5LnBhcnNlSFRNTChcblx0XHRcdFx0XHRcdG1hdGNoWyAxIF0sXG5cdFx0XHRcdFx0XHRjb250ZXh0ICYmIGNvbnRleHQubm9kZVR5cGUgPyBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCA6IGRvY3VtZW50LFxuXHRcdFx0XHRcdFx0dHJ1ZVxuXHRcdFx0XHRcdCkgKTtcblxuXHRcdFx0XHRcdC8vIEhBTkRMRTogJChodG1sLCBwcm9wcylcblx0XHRcdFx0XHRpZiAoIHJzaW5nbGVUYWcudGVzdCggbWF0Y2hbIDEgXSApICYmIGpRdWVyeS5pc1BsYWluT2JqZWN0KCBjb250ZXh0ICkgKSB7XG5cdFx0XHRcdFx0XHRmb3IgKCBtYXRjaCBpbiBjb250ZXh0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFByb3BlcnRpZXMgb2YgY29udGV4dCBhcmUgY2FsbGVkIGFzIG1ldGhvZHMgaWYgcG9zc2libGVcblx0XHRcdFx0XHRcdFx0aWYgKCBpc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJbmplY3QgdGhlIGVsZW1lbnQgZGlyZWN0bHkgaW50byB0aGUgalF1ZXJ5IG9iamVjdFxuXHRcdFx0XHRcdFx0dGhpc1sgMCBdID0gZWxlbTtcblx0XHRcdFx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSEFORExFOiAkKGV4cHIsICQoLi4uKSlcblx0XHRcdH0gZWxzZSBpZiAoICFjb250ZXh0IHx8IGNvbnRleHQuanF1ZXJ5ICkge1xuXHRcdFx0XHRyZXR1cm4gKCBjb250ZXh0IHx8IHJvb3QgKS5maW5kKCBzZWxlY3RvciApO1xuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgY29udGV4dClcblx0XHRcdC8vICh3aGljaCBpcyBqdXN0IGVxdWl2YWxlbnQgdG86ICQoY29udGV4dCkuZmluZChleHByKVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuY29uc3RydWN0b3IoIGNvbnRleHQgKS5maW5kKCBzZWxlY3RvciApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSEFORExFOiAkKERPTUVsZW1lbnQpXG5cdFx0fSBlbHNlIGlmICggc2VsZWN0b3Iubm9kZVR5cGUgKSB7XG5cdFx0XHR0aGlzWyAwIF0gPSBzZWxlY3Rvcjtcblx0XHRcdHRoaXMubGVuZ3RoID0gMTtcblx0XHRcdHJldHVybiB0aGlzO1xuXG5cdFx0Ly8gSEFORExFOiAkKGZ1bmN0aW9uKVxuXHRcdC8vIFNob3J0Y3V0IGZvciBkb2N1bWVudCByZWFkeVxuXHRcdH0gZWxzZSBpZiAoIGlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGpRdWVyeS5tYWtlQXJyYXkoIHNlbGVjdG9yLCB0aGlzICk7XG5cdH07XG5cbi8vIEdpdmUgdGhlIGluaXQgZnVuY3Rpb24gdGhlIGpRdWVyeSBwcm90b3R5cGUgZm9yIGxhdGVyIGluc3RhbnRpYXRpb25cbmluaXQucHJvdG90eXBlID0galF1ZXJ5LmZuO1xuXG4vLyBJbml0aWFsaXplIGNlbnRyYWwgcmVmZXJlbmNlXG5yb290alF1ZXJ5ID0galF1ZXJ5KCBkb2N1bWVudCApO1xuXG5cbnZhciBycGFyZW50c3ByZXYgPSAvXig/OnBhcmVudHN8cHJldig/OlVudGlsfEFsbCkpLyxcblxuXHQvLyBNZXRob2RzIGd1YXJhbnRlZWQgdG8gcHJvZHVjZSBhIHVuaXF1ZSBzZXQgd2hlbiBzdGFydGluZyBmcm9tIGEgdW5pcXVlIHNldFxuXHRndWFyYW50ZWVkVW5pcXVlID0ge1xuXHRcdGNoaWxkcmVuOiB0cnVlLFxuXHRcdGNvbnRlbnRzOiB0cnVlLFxuXHRcdG5leHQ6IHRydWUsXG5cdFx0cHJldjogdHJ1ZVxuXHR9O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGhhczogZnVuY3Rpb24oIHRhcmdldCApIHtcblx0XHR2YXIgdGFyZ2V0cyA9IGpRdWVyeSggdGFyZ2V0LCB0aGlzICksXG5cdFx0XHRsID0gdGFyZ2V0cy5sZW5ndGg7XG5cblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGpRdWVyeS5jb250YWlucyggdGhpcywgdGFyZ2V0c1sgaSBdICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0Y2xvc2VzdDogZnVuY3Rpb24oIHNlbGVjdG9ycywgY29udGV4dCApIHtcblx0XHR2YXIgY3VyLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRsID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRtYXRjaGVkID0gW10sXG5cdFx0XHR0YXJnZXRzID0gdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiAmJiBqUXVlcnkoIHNlbGVjdG9ycyApO1xuXG5cdFx0Ly8gUG9zaXRpb25hbCBzZWxlY3RvcnMgbmV2ZXIgbWF0Y2gsIHNpbmNlIHRoZXJlJ3Mgbm8gX3NlbGVjdGlvbl8gY29udGV4dFxuXHRcdGlmICggIXJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgKSB7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHQvLyBBbHdheXMgc2tpcCBkb2N1bWVudCBmcmFnbWVudHNcblx0XHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA8IDExICYmICggdGFyZ2V0cyA/XG5cdFx0XHRcdFx0XHR0YXJnZXRzLmluZGV4KCBjdXIgKSA+IC0xIDpcblxuXHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcGFzcyBub24tZWxlbWVudHMgdG8gU2l6emxlXG5cdFx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmZpbmQubWF0Y2hlc1NlbGVjdG9yKCBjdXIsIHNlbGVjdG9ycyApICkgKSB7XG5cblx0XHRcdFx0XHRcdG1hdGNoZWQucHVzaCggY3VyICk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIG1hdGNoZWQubGVuZ3RoID4gMSA/IGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICkgOiBtYXRjaGVkICk7XG5cdH0sXG5cblx0Ly8gRGV0ZXJtaW5lIHRoZSBwb3NpdGlvbiBvZiBhbiBlbGVtZW50IHdpdGhpbiB0aGUgc2V0XG5cdGluZGV4OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIE5vIGFyZ3VtZW50LCByZXR1cm4gaW5kZXggaW4gcGFyZW50XG5cdFx0aWYgKCAhZWxlbSApIHtcblx0XHRcdHJldHVybiAoIHRoaXNbIDAgXSAmJiB0aGlzWyAwIF0ucGFyZW50Tm9kZSApID8gdGhpcy5maXJzdCgpLnByZXZBbGwoKS5sZW5ndGggOiAtMTtcblx0XHR9XG5cblx0XHQvLyBJbmRleCBpbiBzZWxlY3RvclxuXHRcdGlmICggdHlwZW9mIGVsZW0gPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdGhpc1sgMCBdICk7XG5cdFx0fVxuXG5cdFx0Ly8gTG9jYXRlIHRoZSBwb3NpdGlvbiBvZiB0aGUgZGVzaXJlZCBlbGVtZW50XG5cdFx0cmV0dXJuIGluZGV4T2YuY2FsbCggdGhpcyxcblxuXHRcdFx0Ly8gSWYgaXQgcmVjZWl2ZXMgYSBqUXVlcnkgb2JqZWN0LCB0aGUgZmlyc3QgZWxlbWVudCBpcyB1c2VkXG5cdFx0XHRlbGVtLmpxdWVyeSA/IGVsZW1bIDAgXSA6IGVsZW1cblx0XHQpO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0ICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayhcblx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIHRoaXMuZ2V0KCksIGpRdWVyeSggc2VsZWN0b3IsIGNvbnRleHQgKSApXG5cdFx0XHQpXG5cdFx0KTtcblx0fSxcblxuXHRhZGRCYWNrOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYWRkKCBzZWxlY3RvciA9PSBudWxsID9cblx0XHRcdHRoaXMucHJldk9iamVjdCA6IHRoaXMucHJldk9iamVjdC5maWx0ZXIoIHNlbGVjdG9yIClcblx0XHQpO1xuXHR9XG59ICk7XG5cbmZ1bmN0aW9uIHNpYmxpbmcoIGN1ciwgZGlyICkge1xuXHR3aGlsZSAoICggY3VyID0gY3VyWyBkaXIgXSApICYmIGN1ci5ub2RlVHlwZSAhPT0gMSApIHt9XG5cdHJldHVybiBjdXI7XG59XG5cbmpRdWVyeS5lYWNoKCB7XG5cdHBhcmVudDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRyZXR1cm4gcGFyZW50ICYmIHBhcmVudC5ub2RlVHlwZSAhPT0gMTEgPyBwYXJlbnQgOiBudWxsO1xuXHR9LFxuXHRwYXJlbnRzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInBhcmVudE5vZGVcIiApO1xuXHR9LFxuXHRwYXJlbnRzVW50aWw6IGZ1bmN0aW9uKCBlbGVtLCBfaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwYXJlbnROb2RlXCIsIHVudGlsICk7XG5cdH0sXG5cdG5leHQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcIm5leHRTaWJsaW5nXCIgKTtcblx0fSxcblx0cHJldjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmcoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dEFsbDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXZBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIgKTtcblx0fSxcblx0bmV4dFVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgX2ksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicHJldmlvdXNTaWJsaW5nXCIsIHVudGlsICk7XG5cdH0sXG5cdHNpYmxpbmdzOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoICggZWxlbS5wYXJlbnROb2RlIHx8IHt9ICkuZmlyc3RDaGlsZCwgZWxlbSApO1xuXHR9LFxuXHRjaGlsZHJlbjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIHNpYmxpbmdzKCBlbGVtLmZpcnN0Q2hpbGQgKTtcblx0fSxcblx0Y29udGVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdGlmICggZWxlbS5jb250ZW50RG9jdW1lbnQgIT0gbnVsbCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSAxMStcblx0XHRcdC8vIDxvYmplY3Q+IGVsZW1lbnRzIHdpdGggbm8gYGRhdGFgIGF0dHJpYnV0ZSBoYXMgYW4gb2JqZWN0XG5cdFx0XHQvLyBgY29udGVudERvY3VtZW50YCB3aXRoIGEgYG51bGxgIHByb3RvdHlwZS5cblx0XHRcdGdldFByb3RvKCBlbGVtLmNvbnRlbnREb2N1bWVudCApICkge1xuXG5cdFx0XHRyZXR1cm4gZWxlbS5jb250ZW50RG9jdW1lbnQ7XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExIG9ubHksIGlPUyA3IG9ubHksIEFuZHJvaWQgQnJvd3NlciA8PTQuMyBvbmx5XG5cdFx0Ly8gVHJlYXQgdGhlIHRlbXBsYXRlIGVsZW1lbnQgYXMgYSByZWd1bGFyIG9uZSBpbiBicm93c2VycyB0aGF0XG5cdFx0Ly8gZG9uJ3Qgc3VwcG9ydCBpdC5cblx0XHRpZiAoIG5vZGVOYW1lKCBlbGVtLCBcInRlbXBsYXRlXCIgKSApIHtcblx0XHRcdGVsZW0gPSBlbGVtLmNvbnRlbnQgfHwgZWxlbTtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgZWxlbS5jaGlsZE5vZGVzICk7XG5cdH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBmbiApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggdW50aWwsIHNlbGVjdG9yICkge1xuXHRcdHZhciBtYXRjaGVkID0galF1ZXJ5Lm1hcCggdGhpcywgZm4sIHVudGlsICk7XG5cblx0XHRpZiAoIG5hbWUuc2xpY2UoIC01ICkgIT09IFwiVW50aWxcIiApIHtcblx0XHRcdHNlbGVjdG9yID0gdW50aWw7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3RvciAmJiB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRtYXRjaGVkID0galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIG1hdGNoZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXMubGVuZ3RoID4gMSApIHtcblxuXHRcdFx0Ly8gUmVtb3ZlIGR1cGxpY2F0ZXNcblx0XHRcdGlmICggIWd1YXJhbnRlZWRVbmlxdWVbIG5hbWUgXSApIHtcblx0XHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmV2ZXJzZSBvcmRlciBmb3IgcGFyZW50cyogYW5kIHByZXYtZGVyaXZhdGl2ZXNcblx0XHRcdGlmICggcnBhcmVudHNwcmV2LnRlc3QoIG5hbWUgKSApIHtcblx0XHRcdFx0bWF0Y2hlZC5yZXZlcnNlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCBtYXRjaGVkICk7XG5cdH07XG59ICk7XG52YXIgcm5vdGh0bWx3aGl0ZSA9ICggL1teXFx4MjBcXHRcXHJcXG5cXGZdKy9nICk7XG5cblxuXG4vLyBDb252ZXJ0IFN0cmluZy1mb3JtYXR0ZWQgb3B0aW9ucyBpbnRvIE9iamVjdC1mb3JtYXR0ZWQgb25lc1xuZnVuY3Rpb24gY3JlYXRlT3B0aW9ucyggb3B0aW9ucyApIHtcblx0dmFyIG9iamVjdCA9IHt9O1xuXHRqUXVlcnkuZWFjaCggb3B0aW9ucy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gbG9ja2VkIHx8IG9wdGlvbnMub25jZTtcblxuXHRcdFx0Ly8gRXhlY3V0ZSBjYWxsYmFja3MgZm9yIGFsbCBwZW5kaW5nIGV4ZWN1dGlvbnMsXG5cdFx0XHQvLyByZXNwZWN0aW5nIGZpcmluZ0luZGV4IG92ZXJyaWRlcyBhbmQgcnVudGltZSBjaGFuZ2VzXG5cdFx0XHRmaXJlZCA9IGZpcmluZyA9IHRydWU7XG5cdFx0XHRmb3IgKCA7IHF1ZXVlLmxlbmd0aDsgZmlyaW5nSW5kZXggPSAtMSApIHtcblx0XHRcdFx0bWVtb3J5ID0gcXVldWUuc2hpZnQoKTtcblx0XHRcdFx0d2hpbGUgKCArK2ZpcmluZ0luZGV4IDwgbGlzdC5sZW5ndGggKSB7XG5cblx0XHRcdFx0XHQvLyBSdW4gY2FsbGJhY2sgYW5kIGNoZWNrIGZvciBlYXJseSB0ZXJtaW5hdGlvblxuXHRcdFx0XHRcdGlmICggbGlzdFsgZmlyaW5nSW5kZXggXS5hcHBseSggbWVtb3J5WyAwIF0sIG1lbW9yeVsgMSBdICkgPT09IGZhbHNlICYmXG5cdFx0XHRcdFx0XHRvcHRpb25zLnN0b3BPbkZhbHNlICkge1xuXG5cdFx0XHRcdFx0XHQvLyBKdW1wIHRvIGVuZCBhbmQgZm9yZ2V0IHRoZSBkYXRhIHNvIC5hZGQgZG9lc24ndCByZS1maXJlXG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoO1xuXHRcdFx0XHRcdFx0bWVtb3J5ID0gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvcmdldCB0aGUgZGF0YSBpZiB3ZSdyZSBkb25lIHdpdGggaXRcblx0XHRcdGlmICggIW9wdGlvbnMubWVtb3J5ICkge1xuXHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdH1cblxuXHRcdFx0ZmlyaW5nID0gZmFsc2U7XG5cblx0XHRcdC8vIENsZWFuIHVwIGlmIHdlJ3JlIGRvbmUgZmlyaW5nIGZvciBnb29kXG5cdFx0XHRpZiAoIGxvY2tlZCApIHtcblxuXHRcdFx0XHQvLyBLZWVwIGFuIGVtcHR5IGxpc3QgaWYgd2UgaGF2ZSBkYXRhIGZvciBmdXR1cmUgYWRkIGNhbGxzXG5cdFx0XHRcdGlmICggbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBbXTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIHRoaXMgb2JqZWN0IGlzIHNwZW50XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0bGlzdCA9IFwiXCI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Ly8gQWN0dWFsIENhbGxiYWNrcyBvYmplY3Rcblx0XHRzZWxmID0ge1xuXG5cdFx0XHQvLyBBZGQgYSBjYWxsYmFjayBvciBhIGNvbGxlY3Rpb24gb2YgY2FsbGJhY2tzIHRvIHRoZSBsaXN0XG5cdFx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cblx0XHRcdFx0XHQvLyBJZiB3ZSBoYXZlIG1lbW9yeSBmcm9tIGEgcGFzdCBydW4sIHdlIHNob3VsZCBmaXJlIGFmdGVyIGFkZGluZ1xuXHRcdFx0XHRcdGlmICggbWVtb3J5ICYmICFmaXJpbmcgKSB7XG5cdFx0XHRcdFx0XHRmaXJpbmdJbmRleCA9IGxpc3QubGVuZ3RoIC0gMTtcblx0XHRcdFx0XHRcdHF1ZXVlLnB1c2goIG1lbW9yeSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdCggZnVuY3Rpb24gYWRkKCBhcmdzICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIGFyZ3MsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiB0b1R5cGUoIGFyZyApICE9PSBcInN0cmluZ1wiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gSW5zcGVjdCByZWN1cnNpdmVseVxuXHRcdFx0XHRcdFx0XHRcdGFkZCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0XHR9ICkoIGFyZ3VtZW50cyApO1xuXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYSBjYWxsYmFjayBmcm9tIHRoZSBsaXN0XG5cdFx0XHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRqUXVlcnkuZWFjaCggYXJndW1lbnRzLCBmdW5jdGlvbiggXywgYXJnICkge1xuXHRcdFx0XHRcdHZhciBpbmRleDtcblx0XHRcdFx0XHR3aGlsZSAoICggaW5kZXggPSBqUXVlcnkuaW5BcnJheSggYXJnLCBsaXN0LCBpbmRleCApICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdGxpc3Quc3BsaWNlKCBpbmRleCwgMSApO1xuXG5cdFx0XHRcdFx0XHQvLyBIYW5kbGUgZmlyaW5nIGluZGV4ZXNcblx0XHRcdFx0XHRcdGlmICggaW5kZXggPD0gZmlyaW5nSW5kZXggKSB7XG5cdFx0XHRcdFx0XHRcdGZpcmluZ0luZGV4LS07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9ICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gQ2hlY2sgaWYgYSBnaXZlbiBjYWxsYmFjayBpcyBpbiB0aGUgbGlzdC5cblx0XHRcdC8vIElmIG5vIGFyZ3VtZW50IGlzIGdpdmVuLCByZXR1cm4gd2hldGhlciBvciBub3QgbGlzdCBoYXMgY2FsbGJhY2tzIGF0dGFjaGVkLlxuXHRcdFx0aGFzOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdHJldHVybiBmbiA/XG5cdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGZuLCBsaXN0ICkgPiAtMSA6XG5cdFx0XHRcdFx0bGlzdC5sZW5ndGggPiAwO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gUmVtb3ZlIGFsbCBjYWxsYmFja3MgZnJvbSB0aGUgbGlzdFxuXHRcdFx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGxpc3QgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblxuXHRcdFx0Ly8gRGlzYWJsZSAuZmlyZSBhbmQgLmFkZFxuXHRcdFx0Ly8gQWJvcnQgYW55IGN1cnJlbnQvcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHQvLyBDbGVhciBhbGwgY2FsbGJhY2tzIGFuZCB2YWx1ZXNcblx0XHRcdGRpc2FibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRsb2NrZWQgPSBxdWV1ZSA9IFtdO1xuXHRcdFx0XHRsaXN0ID0gbWVtb3J5ID0gXCJcIjtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXHRcdFx0ZGlzYWJsZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gIWxpc3Q7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlXG5cdFx0XHQvLyBBbHNvIGRpc2FibGUgLmFkZCB1bmxlc3Mgd2UgaGF2ZSBtZW1vcnkgKHNpbmNlIGl0IHdvdWxkIGhhdmUgbm8gZWZmZWN0KVxuXHRcdFx0Ly8gQWJvcnQgYW55IHBlbmRpbmcgZXhlY3V0aW9uc1xuXHRcdFx0bG9jazogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGlmICggIW1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5mdW5jdGlvbiBJZGVudGl0eSggdiApIHtcblx0cmV0dXJuIHY7XG59XG5mdW5jdGlvbiBUaHJvd2VyKCBleCApIHtcblx0dGhyb3cgZXg7XG59XG5cbmZ1bmN0aW9uIGFkb3B0VmFsdWUoIHZhbHVlLCByZXNvbHZlLCByZWplY3QsIG5vVmFsdWUgKSB7XG5cdHZhciBtZXRob2Q7XG5cblx0dHJ5IHtcblxuXHRcdC8vIENoZWNrIGZvciBwcm9taXNlIGFzcGVjdCBmaXJzdCB0byBwcml2aWxlZ2Ugc3luY2hyb25vdXMgYmVoYXZpb3Jcblx0XHRpZiAoIHZhbHVlICYmIGlzRnVuY3Rpb24oICggbWV0aG9kID0gdmFsdWUucHJvbWlzZSApICkgKSB7XG5cdFx0XHRtZXRob2QuY2FsbCggdmFsdWUgKS5kb25lKCByZXNvbHZlICkuZmFpbCggcmVqZWN0ICk7XG5cblx0XHQvLyBPdGhlciB0aGVuYWJsZXNcblx0XHR9IGVsc2UgaWYgKCB2YWx1ZSAmJiBpc0Z1bmN0aW9uKCAoIG1ldGhvZCA9IHZhbHVlLnRoZW4gKSApICkge1xuXHRcdFx0bWV0aG9kLmNhbGwoIHZhbHVlLCByZXNvbHZlLCByZWplY3QgKTtcblxuXHRcdC8vIE90aGVyIG5vbi10aGVuYWJsZXNcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBDb250cm9sIGByZXNvbHZlYCBhcmd1bWVudHMgYnkgbGV0dGluZyBBcnJheSNzbGljZSBjYXN0IGJvb2xlYW4gYG5vVmFsdWVgIHRvIGludGVnZXI6XG5cdFx0XHQvLyAqIGZhbHNlOiBbIHZhbHVlIF0uc2xpY2UoIDAgKSA9PiByZXNvbHZlKCB2YWx1ZSApXG5cdFx0XHQvLyAqIHRydWU6IFsgdmFsdWUgXS5zbGljZSggMSApID0+IHJlc29sdmUoKVxuXHRcdFx0cmVzb2x2ZS5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0uc2xpY2UoIG5vVmFsdWUgKSApO1xuXHRcdH1cblxuXHQvLyBGb3IgUHJvbWlzZXMvQSssIGNvbnZlcnQgZXhjZXB0aW9ucyBpbnRvIHJlamVjdGlvbnNcblx0Ly8gU2luY2UgalF1ZXJ5LndoZW4gZG9lc24ndCB1bndyYXAgdGhlbmFibGVzLCB3ZSBjYW4gc2tpcCB0aGUgZXh0cmEgY2hlY2tzIGFwcGVhcmluZyBpblxuXHQvLyBEZWZlcnJlZCN0aGVuIHRvIGNvbmRpdGlvbmFsbHkgc3VwcHJlc3MgcmVqZWN0aW9uLlxuXHR9IGNhdGNoICggdmFsdWUgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCBvbmx5XG5cdFx0Ly8gU3RyaWN0IG1vZGUgZnVuY3Rpb25zIGludm9rZWQgd2l0aG91dCAuY2FsbC8uYXBwbHkgZ2V0IGdsb2JhbC1vYmplY3QgY29udGV4dFxuXHRcdHJlamVjdC5hcHBseSggdW5kZWZpbmVkLCBbIHZhbHVlIF0gKTtcblx0fVxufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGNhbGxiYWNrcyxcblx0XHRcdFx0Ly8gLi4uIC50aGVuIGhhbmRsZXJzLCBhcmd1bWVudCBpbmRleCwgW2ZpbmFsIHN0YXRlXVxuXHRcdFx0XHRbIFwibm90aWZ5XCIsIFwicHJvZ3Jlc3NcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJtZW1vcnlcIiApLFxuXHRcdFx0XHRcdGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSwgMiBdLFxuXHRcdFx0XHRbIFwicmVzb2x2ZVwiLCBcImRvbmVcIiwgalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksXG5cdFx0XHRcdFx0alF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICksIDAsIFwicmVzb2x2ZWRcIiBdLFxuXHRcdFx0XHRbIFwicmVqZWN0XCIsIFwiZmFpbFwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblx0XHRcdFx0XHRqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgMSwgXCJyZWplY3RlZFwiIF1cblx0XHRcdF0sXG5cdFx0XHRzdGF0ZSA9IFwicGVuZGluZ1wiLFxuXHRcdFx0cHJvbWlzZSA9IHtcblx0XHRcdFx0c3RhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZTtcblx0XHRcdFx0fSxcblx0XHRcdFx0YWx3YXlzOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5kb25lKCBhcmd1bWVudHMgKS5mYWlsKCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblx0XHRcdFx0XCJjYXRjaFwiOiBmdW5jdGlvbiggZm4gKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHByb21pc2UudGhlbiggbnVsbCwgZm4gKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBLZWVwIHBpcGUgZm9yIGJhY2stY29tcGF0XG5cdFx0XHRcdHBpcGU6IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIF9pLCB0dXBsZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBNYXAgdHVwbGVzIChwcm9ncmVzcywgZG9uZSwgZmFpbCkgdG8gYXJndW1lbnRzIChkb25lLCBmYWlsLCBwcm9ncmVzcylcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0gaXNGdW5jdGlvbiggZm5zWyB0dXBsZVsgNCBdIF0gKSAmJiBmbnNbIHR1cGxlWyA0IF0gXTtcblxuXHRcdFx0XHRcdFx0XHQvLyBkZWZlcnJlZC5wcm9ncmVzcyhmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5ub3RpZnkgfSlcblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWQuZG9uZShmdW5jdGlvbigpIHsgYmluZCB0byBuZXdEZWZlciBvciBuZXdEZWZlci5yZXNvbHZlIH0pXG5cdFx0XHRcdFx0XHRcdC8vIGRlZmVycmVkLmZhaWwoZnVuY3Rpb24oKSB7IGJpbmQgdG8gbmV3RGVmZXIgb3IgbmV3RGVmZXIucmVqZWN0IH0pXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGlzRnVuY3Rpb24oIHJldHVybmVkLnByb21pc2UgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnByb21pc2UoKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQucHJvZ3Jlc3MoIG5ld0RlZmVyLm5vdGlmeSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5kb25lKCBuZXdEZWZlci5yZXNvbHZlIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmZhaWwoIG5ld0RlZmVyLnJlamVjdCApO1xuXHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRuZXdEZWZlclsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHRoaXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGZuID8gWyByZXR1cm5lZCBdIDogYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0Zm5zID0gbnVsbDtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHR0aGVuOiBmdW5jdGlvbiggb25GdWxmaWxsZWQsIG9uUmVqZWN0ZWQsIG9uUHJvZ3Jlc3MgKSB7XG5cdFx0XHRcdFx0dmFyIG1heERlcHRoID0gMDtcblx0XHRcdFx0XHRmdW5jdGlvbiByZXNvbHZlKCBkZXB0aCwgZGVmZXJyZWQsIGhhbmRsZXIsIHNwZWNpYWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRhcmdzID0gYXJndW1lbnRzLFxuXHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3cgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCwgdGhlbjtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMy4zLjNcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJZ25vcmUgZG91YmxlLXJlc29sdXRpb24gYXR0ZW1wdHNcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggPCBtYXhEZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCA9IGhhbmRsZXIuYXBwbHkoIHRoYXQsIGFyZ3MgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuMVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gaHR0cHM6Ly9wcm9taXNlc2FwbHVzLmNvbS8jcG9pbnQtNDhcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggcmV0dXJuZWQgPT09IGRlZmVycmVkLnByb21pc2UoKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0dGhyb3cgbmV3IFR5cGVFcnJvciggXCJUaGVuYWJsZSBzZWxmLXJlc29sdXRpb25cIiApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBQcm9taXNlcy9BKyBzZWN0aW9ucyAyLjMuMy4xLCAzLjVcblx0XHRcdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU0XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC03NVxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gUmV0cmlldmUgYHRoZW5gIG9ubHkgb25jZVxuXHRcdFx0XHRcdFx0XHRcdFx0dGhlbiA9IHJldHVybmVkICYmXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogUHJvbWlzZXMvQSsgc2VjdGlvbiAyLjMuNFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02NFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IGNoZWNrIG9iamVjdHMgYW5kIGZ1bmN0aW9ucyBmb3IgdGhlbmFiaWxpdHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0KCB0eXBlb2YgcmV0dXJuZWQgPT09IFwib2JqZWN0XCIgfHxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgcmV0dXJuZWQgPT09IFwiZnVuY3Rpb25cIiApICYmXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHJldHVybmVkLnRoZW47XG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIEhhbmRsZSBhIHJldHVybmVkIHRoZW5hYmxlXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGlzRnVuY3Rpb24oIHRoZW4gKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBTcGVjaWFsIHByb2Nlc3NvcnMgKG5vdGlmeSkganVzdCB3YWl0IGZvciByZXNvbHV0aW9uXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbCApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGVuLmNhbGwoXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZCxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgVGhyb3dlciwgc3BlY2lhbCApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBOb3JtYWwgcHJvY2Vzc29ycyAocmVzb2x2ZSkgYWxzbyBob29rIGludG8gcHJvZ3Jlc3Ncblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBkaXNyZWdhcmQgb2xkZXIgcmVzb2x1dGlvbiB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRtYXhEZXB0aCsrO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhlbi5jYWxsKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuZWQsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIElkZW50aXR5LCBzcGVjaWFsICksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRyZXNvbHZlKCBtYXhEZXB0aCwgZGVmZXJyZWQsIFRocm93ZXIsIHNwZWNpYWwgKSxcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHJlc29sdmUoIG1heERlcHRoLCBkZWZlcnJlZCwgSWRlbnRpdHksXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGggKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gSGFuZGxlIGFsbCBvdGhlciByZXR1cm5lZCB2YWx1ZXNcblx0XHRcdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gT25seSBzdWJzdGl0dXRlIGhhbmRsZXJzIHBhc3Mgb24gY29udGV4dFxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCBoYW5kbGVyICE9PSBJZGVudGl0eSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0aGF0ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGFyZ3MgPSBbIHJldHVybmVkIF07XG5cdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBQcm9jZXNzIHRoZSB2YWx1ZShzKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZhdWx0IHByb2Nlc3MgaXMgcmVzb2x2ZVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQoIHNwZWNpYWwgfHwgZGVmZXJyZWQucmVzb2x2ZVdpdGggKSggdGhhdCwgYXJncyApO1xuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IG5vcm1hbCBwcm9jZXNzb3JzIChyZXNvbHZlKSBjYXRjaCBhbmQgcmVqZWN0IGV4Y2VwdGlvbnNcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzID0gc3BlY2lhbCA/XG5cdFx0XHRcdFx0XHRcdFx0XHRtaWdodFRocm93IDpcblx0XHRcdFx0XHRcdFx0XHRcdGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG1pZ2h0VGhyb3coKTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5leGNlcHRpb25Ib29rICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2soIGUsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdHByb2Nlc3Muc3RhY2tUcmFjZSApO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy40LjFcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBodHRwczovL3Byb21pc2VzYXBsdXMuY29tLyNwb2ludC02MVxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIElnbm9yZSBwb3N0LXJlc29sdXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggZGVwdGggKyAxID49IG1heERlcHRoICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBPbmx5IHN1YnN0aXR1dGUgaGFuZGxlcnMgcGFzcyBvbiBjb250ZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBhbmQgbXVsdGlwbGUgdmFsdWVzIChub24tc3BlYyBiZWhhdmlvcilcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggaGFuZGxlciAhPT0gVGhyb3dlciApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0dGhhdCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0YXJncyA9IFsgZSBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCB0aGF0LCBhcmdzICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IFByb21pc2VzL0ErIHNlY3Rpb24gMi4zLjMuMy4xXG5cdFx0XHRcdFx0XHRcdC8vIGh0dHBzOi8vcHJvbWlzZXNhcGx1cy5jb20vI3BvaW50LTU3XG5cdFx0XHRcdFx0XHRcdC8vIFJlLXJlc29sdmUgcHJvbWlzZXMgaW1tZWRpYXRlbHkgdG8gZG9kZ2UgZmFsc2UgcmVqZWN0aW9uIGZyb21cblx0XHRcdFx0XHRcdFx0Ly8gc3Vic2VxdWVudCBlcnJvcnNcblx0XHRcdFx0XHRcdFx0aWYgKCBkZXB0aCApIHtcblx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDYWxsIGFuIG9wdGlvbmFsIGhvb2sgdG8gcmVjb3JkIHRoZSBzdGFjaywgaW4gY2FzZSBvZiBleGNlcHRpb25cblx0XHRcdFx0XHRcdFx0XHQvLyBzaW5jZSBpdCdzIG90aGVyd2lzZSBsb3N0IHdoZW4gZXhlY3V0aW9uIGdvZXMgYXN5bmNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5EZWZlcnJlZC5nZXRTdGFja0hvb2sgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRwcm9jZXNzLnN0YWNrVHJhY2UgPSBqUXVlcnkuRGVmZXJyZWQuZ2V0U3RhY2tIb29rKCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBwcm9jZXNzICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIGpRdWVyeS5EZWZlcnJlZCggZnVuY3Rpb24oIG5ld0RlZmVyICkge1xuXG5cdFx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUHJvZ3Jlc3MgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblByb2dyZXNzIDpcblx0XHRcdFx0XHRcdFx0XHRcdElkZW50aXR5LFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLm5vdGlmeVdpdGhcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmFkZCggLi4uIClcblx0XHRcdFx0XHRcdHR1cGxlc1sgMSBdWyAzIF0uYWRkKFxuXHRcdFx0XHRcdFx0XHRyZXNvbHZlKFxuXHRcdFx0XHRcdFx0XHRcdDAsXG5cdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXIsXG5cdFx0XHRcdFx0XHRcdFx0aXNGdW5jdGlvbiggb25GdWxmaWxsZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvbkZ1bGZpbGxlZCA6XG5cdFx0XHRcdFx0XHRcdFx0XHRJZGVudGl0eVxuXHRcdFx0XHRcdFx0XHQpXG5cdFx0XHRcdFx0XHQpO1xuXG5cdFx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5hZGQoIC4uLiApXG5cdFx0XHRcdFx0XHR0dXBsZXNbIDIgXVsgMyBdLmFkZChcblx0XHRcdFx0XHRcdFx0cmVzb2x2ZShcblx0XHRcdFx0XHRcdFx0XHQwLFxuXHRcdFx0XHRcdFx0XHRcdG5ld0RlZmVyLFxuXHRcdFx0XHRcdFx0XHRcdGlzRnVuY3Rpb24oIG9uUmVqZWN0ZWQgKSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRvblJlamVjdGVkIDpcblx0XHRcdFx0XHRcdFx0XHRcdFRocm93ZXJcblx0XHRcdFx0XHRcdFx0KVxuXHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHR9ICkucHJvbWlzZSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIEdldCBhIHByb21pc2UgZm9yIHRoaXMgZGVmZXJyZWRcblx0XHRcdFx0Ly8gSWYgb2JqIGlzIHByb3ZpZGVkLCB0aGUgcHJvbWlzZSBhc3BlY3QgaXMgYWRkZWQgdG8gdGhlIG9iamVjdFxuXHRcdFx0XHRwcm9taXNlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdFx0XHRcdHJldHVybiBvYmogIT0gbnVsbCA/IGpRdWVyeS5leHRlbmQoIG9iaiwgcHJvbWlzZSApIDogcHJvbWlzZTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblx0XHRcdGRlZmVycmVkID0ge307XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyA1IF07XG5cblx0XHRcdC8vIHByb21pc2UucHJvZ3Jlc3MgPSBsaXN0LmFkZFxuXHRcdFx0Ly8gcHJvbWlzZS5kb25lID0gbGlzdC5hZGRcblx0XHRcdC8vIHByb21pc2UuZmFpbCA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZChcblx0XHRcdFx0XHRmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gc3RhdGUgPSBcInJlc29sdmVkXCIgKGkuZS4sIGZ1bGZpbGxlZClcblx0XHRcdFx0XHRcdC8vIHN0YXRlID0gXCJyZWplY3RlZFwiXG5cdFx0XHRcdFx0XHRzdGF0ZSA9IHN0YXRlU3RyaW5nO1xuXHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdC8vIGZ1bGZpbGxlZF9jYWxsYmFja3MuZGlzYWJsZVxuXHRcdFx0XHRcdHR1cGxlc1sgMyAtIGkgXVsgMiBdLmRpc2FibGUsXG5cblx0XHRcdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5kaXNhYmxlXG5cdFx0XHRcdFx0Ly8gZnVsZmlsbGVkX2hhbmRsZXJzLmRpc2FibGVcblx0XHRcdFx0XHR0dXBsZXNbIDMgLSBpIF1bIDMgXS5kaXNhYmxlLFxuXG5cdFx0XHRcdFx0Ly8gcHJvZ3Jlc3NfY2FsbGJhY2tzLmxvY2tcblx0XHRcdFx0XHR0dXBsZXNbIDAgXVsgMiBdLmxvY2ssXG5cblx0XHRcdFx0XHQvLyBwcm9ncmVzc19oYW5kbGVycy5sb2NrXG5cdFx0XHRcdFx0dHVwbGVzWyAwIF1bIDMgXS5sb2NrXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIHByb2dyZXNzX2hhbmRsZXJzLmZpcmVcblx0XHRcdC8vIGZ1bGZpbGxlZF9oYW5kbGVycy5maXJlXG5cdFx0XHQvLyByZWplY3RlZF9oYW5kbGVycy5maXJlXG5cdFx0XHRsaXN0LmFkZCggdHVwbGVbIDMgXS5maXJlICk7XG5cblx0XHRcdC8vIGRlZmVycmVkLm5vdGlmeSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5ub3RpZnlXaXRoKC4uLikgfVxuXHRcdFx0Ly8gZGVmZXJyZWQucmVzb2x2ZSA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZXNvbHZlV2l0aCguLi4pIH1cblx0XHRcdC8vIGRlZmVycmVkLnJlamVjdCA9IGZ1bmN0aW9uKCkgeyBkZWZlcnJlZC5yZWplY3RXaXRoKC4uLikgfVxuXHRcdFx0ZGVmZXJyZWRbIHR1cGxlWyAwIF0gXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSArIFwiV2l0aFwiIF0oIHRoaXMgPT09IGRlZmVycmVkID8gdW5kZWZpbmVkIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblxuXHRcdFx0Ly8gZGVmZXJyZWQubm90aWZ5V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdC8vIGRlZmVycmVkLnJlc29sdmVXaXRoID0gbGlzdC5maXJlV2l0aFxuXHRcdFx0Ly8gZGVmZXJyZWQucmVqZWN0V2l0aCA9IGxpc3QuZmlyZVdpdGhcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc2luZ2xlVmFsdWUgKSB7XG5cdFx0dmFyXG5cblx0XHRcdC8vIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gYXJndW1lbnRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gY291bnQgb2YgdW5wcm9jZXNzZWQgYXJndW1lbnRzXG5cdFx0XHRpID0gcmVtYWluaW5nLFxuXG5cdFx0XHQvLyBzdWJvcmRpbmF0ZSBmdWxmaWxsbWVudCBkYXRhXG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBBcnJheSggaSApLFxuXHRcdFx0cmVzb2x2ZVZhbHVlcyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXG5cdFx0XHQvLyB0aGUgbWFzdGVyIERlZmVycmVkXG5cdFx0XHRtYXN0ZXIgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblxuXHRcdFx0Ly8gc3Vib3JkaW5hdGUgY2FsbGJhY2sgZmFjdG9yeVxuXHRcdFx0dXBkYXRlRnVuYyA9IGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJlc29sdmVDb250ZXh0c1sgaSBdID0gdGhpcztcblx0XHRcdFx0XHRyZXNvbHZlVmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCAhKCAtLXJlbWFpbmluZyApICkge1xuXHRcdFx0XHRcdFx0bWFzdGVyLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH07XG5cdFx0XHR9O1xuXG5cdFx0Ly8gU2luZ2xlLSBhbmQgZW1wdHkgYXJndW1lbnRzIGFyZSBhZG9wdGVkIGxpa2UgUHJvbWlzZS5yZXNvbHZlXG5cdFx0aWYgKCByZW1haW5pbmcgPD0gMSApIHtcblx0XHRcdGFkb3B0VmFsdWUoIHNpbmdsZVZhbHVlLCBtYXN0ZXIuZG9uZSggdXBkYXRlRnVuYyggaSApICkucmVzb2x2ZSwgbWFzdGVyLnJlamVjdCxcblx0XHRcdFx0IXJlbWFpbmluZyApO1xuXG5cdFx0XHQvLyBVc2UgLnRoZW4oKSB0byB1bndyYXAgc2Vjb25kYXJ5IHRoZW5hYmxlcyAoY2YuIGdoLTMwMDApXG5cdFx0XHRpZiAoIG1hc3Rlci5zdGF0ZSgpID09PSBcInBlbmRpbmdcIiB8fFxuXHRcdFx0XHRpc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0gJiYgcmVzb2x2ZVZhbHVlc1sgaSBdLnRoZW4gKSApIHtcblxuXHRcdFx0XHRyZXR1cm4gbWFzdGVyLnRoZW4oKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBNdWx0aXBsZSBhcmd1bWVudHMgYXJlIGFnZ3JlZ2F0ZWQgbGlrZSBQcm9taXNlLmFsbCBhcnJheSBlbGVtZW50c1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0YWRvcHRWYWx1ZSggcmVzb2x2ZVZhbHVlc1sgaSBdLCB1cGRhdGVGdW5jKCBpICksIG1hc3Rlci5yZWplY3QgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gbWFzdGVyLnByb21pc2UoKTtcblx0fVxufSApO1xuXG5cbi8vIFRoZXNlIHVzdWFsbHkgaW5kaWNhdGUgYSBwcm9ncmFtbWVyIG1pc3Rha2UgZHVyaW5nIGRldmVsb3BtZW50LFxuLy8gd2FybiBhYm91dCB0aGVtIEFTQVAgcmF0aGVyIHRoYW4gc3dhbGxvd2luZyB0aGVtIGJ5IGRlZmF1bHQuXG52YXIgcmVycm9yTmFtZXMgPSAvXihFdmFsfEludGVybmFsfFJhbmdlfFJlZmVyZW5jZXxTeW50YXh8VHlwZXxVUkkpRXJyb3IkLztcblxualF1ZXJ5LkRlZmVycmVkLmV4Y2VwdGlvbkhvb2sgPSBmdW5jdGlvbiggZXJyb3IsIHN0YWNrICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDggLSA5IG9ubHlcblx0Ly8gQ29uc29sZSBleGlzdHMgd2hlbiBkZXYgdG9vbHMgYXJlIG9wZW4sIHdoaWNoIGNhbiBoYXBwZW4gYXQgYW55IHRpbWVcblx0aWYgKCB3aW5kb3cuY29uc29sZSAmJiB3aW5kb3cuY29uc29sZS53YXJuICYmIGVycm9yICYmIHJlcnJvck5hbWVzLnRlc3QoIGVycm9yLm5hbWUgKSApIHtcblx0XHR3aW5kb3cuY29uc29sZS53YXJuKCBcImpRdWVyeS5EZWZlcnJlZCBleGNlcHRpb246IFwiICsgZXJyb3IubWVzc2FnZSwgZXJyb3Iuc3RhY2ssIHN0YWNrICk7XG5cdH1cbn07XG5cblxuXG5cbmpRdWVyeS5yZWFkeUV4Y2VwdGlvbiA9IGZ1bmN0aW9uKCBlcnJvciApIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdHRocm93IGVycm9yO1xuXHR9ICk7XG59O1xuXG5cblxuXG4vLyBUaGUgZGVmZXJyZWQgdXNlZCBvbiBET00gcmVhZHlcbnZhciByZWFkeUxpc3QgPSBqUXVlcnkuRGVmZXJyZWQoKTtcblxualF1ZXJ5LmZuLnJlYWR5ID0gZnVuY3Rpb24oIGZuICkge1xuXG5cdHJlYWR5TGlzdFxuXHRcdC50aGVuKCBmbiApXG5cblx0XHQvLyBXcmFwIGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiBpbiBhIGZ1bmN0aW9uIHNvIHRoYXQgdGhlIGxvb2t1cFxuXHRcdC8vIGhhcHBlbnMgYXQgdGhlIHRpbWUgb2YgZXJyb3IgaGFuZGxpbmcgaW5zdGVhZCBvZiBjYWxsYmFja1xuXHRcdC8vIHJlZ2lzdHJhdGlvbi5cblx0XHQuY2F0Y2goIGZ1bmN0aW9uKCBlcnJvciApIHtcblx0XHRcdGpRdWVyeS5yZWFkeUV4Y2VwdGlvbiggZXJyb3IgKTtcblx0XHR9ICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5yZWFkeS50aGVuID0gcmVhZHlMaXN0LnRoZW47XG5cbi8vIFRoZSByZWFkeSBldmVudCBoYW5kbGVyIGFuZCBzZWxmIGNsZWFudXAgbWV0aG9kXG5mdW5jdGlvbiBjb21wbGV0ZWQoKSB7XG5cdGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblx0d2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoIFwibG9hZFwiLCBjb21wbGV0ZWQgKTtcblx0alF1ZXJ5LnJlYWR5KCk7XG59XG5cbi8vIENhdGNoIGNhc2VzIHdoZXJlICQoZG9jdW1lbnQpLnJlYWR5KCkgaXMgY2FsbGVkXG4vLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cbi8vIFN1cHBvcnQ6IElFIDw9OSAtIDEwIG9ubHlcbi8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuaWYgKCBkb2N1bWVudC5yZWFkeVN0YXRlID09PSBcImNvbXBsZXRlXCIgfHxcblx0KCBkb2N1bWVudC5yZWFkeVN0YXRlICE9PSBcImxvYWRpbmdcIiAmJiAhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LmRvU2Nyb2xsICkgKSB7XG5cblx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBqUXVlcnkucmVhZHkgKTtcblxufSBlbHNlIHtcblxuXHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoIFwiRE9NQ29udGVudExvYWRlZFwiLCBjb21wbGV0ZWQgKTtcblxuXHQvLyBBIGZhbGxiYWNrIHRvIHdpbmRvdy5vbmxvYWQsIHRoYXQgd2lsbCBhbHdheXMgd29ya1xuXHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xufVxuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIHRvVHlwZSgga2V5ICkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblx0XHRmb3IgKCBpIGluIGtleSApIHtcblx0XHRcdGFjY2VzcyggZWxlbXMsIGZuLCBpLCBrZXlbIGkgXSwgdHJ1ZSwgZW1wdHlHZXQsIHJhdyApO1xuXHRcdH1cblxuXHQvLyBTZXRzIG9uZSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdGNoYWluYWJsZSA9IHRydWU7XG5cblx0XHRpZiAoICFpc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwgX2tleSwgdmFsdWUgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGJ1bGsuY2FsbCggalF1ZXJ5KCBlbGVtICksIHZhbHVlICk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCBmbiApIHtcblx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRmbihcblx0XHRcdFx0XHRlbGVtc1sgaSBdLCBrZXksIHJhdyA/XG5cdFx0XHRcdFx0dmFsdWUgOlxuXHRcdFx0XHRcdHZhbHVlLmNhbGwoIGVsZW1zWyBpIF0sIGksIGZuKCBlbGVtc1sgaSBdLCBrZXkgKSApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0aWYgKCBjaGFpbmFibGUgKSB7XG5cdFx0cmV0dXJuIGVsZW1zO1xuXHR9XG5cblx0Ly8gR2V0c1xuXHRpZiAoIGJ1bGsgKSB7XG5cdFx0cmV0dXJuIGZuLmNhbGwoIGVsZW1zICk7XG5cdH1cblxuXHRyZXR1cm4gbGVuID8gZm4oIGVsZW1zWyAwIF0sIGtleSApIDogZW1wdHlHZXQ7XG59O1xuXG5cbi8vIE1hdGNoZXMgZGFzaGVkIHN0cmluZyBmb3IgY2FtZWxpemluZ1xudmFyIHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbYS16XSkvZztcblxuLy8gVXNlZCBieSBjYW1lbENhc2UgYXMgY2FsbGJhY2sgdG8gcmVwbGFjZSgpXG5mdW5jdGlvbiBmY2FtZWxDYXNlKCBfYWxsLCBsZXR0ZXIgKSB7XG5cdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcbn1cblxuLy8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuLy8gU3VwcG9ydDogSUUgPD05IC0gMTEsIEVkZ2UgMTIgLSAxNVxuLy8gTWljcm9zb2Z0IGZvcmdvdCB0byBodW1wIHRoZWlyIHZlbmRvciBwcmVmaXggKCM5NTcyKVxuZnVuY3Rpb24gY2FtZWxDYXNlKCBzdHJpbmcgKSB7XG5cdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xufVxudmFyIGFjY2VwdERhdGEgPSBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0Ly8gQWNjZXB0cyBvbmx5OlxuXHQvLyAgLSBOb2RlXG5cdC8vICAgIC0gTm9kZS5FTEVNRU5UX05PREVcblx0Ly8gICAgLSBOb2RlLkRPQ1VNRU5UX05PREVcblx0Ly8gIC0gT2JqZWN0XG5cdC8vICAgIC0gQW55XG5cdHJldHVybiBvd25lci5ub2RlVHlwZSA9PT0gMSB8fCBvd25lci5ub2RlVHlwZSA9PT0gOSB8fCAhKCArb3duZXIubm9kZVR5cGUgKTtcbn07XG5cblxuXG5cbmZ1bmN0aW9uIERhdGEoKSB7XG5cdHRoaXMuZXhwYW5kbyA9IGpRdWVyeS5leHBhbmRvICsgRGF0YS51aWQrKztcbn1cblxuRGF0YS51aWQgPSAxO1xuXG5EYXRhLnByb3RvdHlwZSA9IHtcblxuXHRjYWNoZTogZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRpZiAoIHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggZGF0YSApIF0gPSB2YWx1ZTtcblxuXHRcdC8vIEhhbmRsZTogWyBvd25lciwgeyBwcm9wZXJ0aWVzIH0gXSBhcmdzXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQ29weSB0aGUgcHJvcGVydGllcyBvbmUtYnktb25lIHRvIHRoZSBjYWNoZSBvYmplY3Rcblx0XHRcdGZvciAoIHByb3AgaW4gZGF0YSApIHtcblx0XHRcdFx0Y2FjaGVbIGNhbWVsQ2FzZSggcHJvcCApIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cblx0XHRcdC8vIEFsd2F5cyB1c2UgY2FtZWxDYXNlIGtleSAoZ2gtMjI1Nylcblx0XHRcdG93bmVyWyB0aGlzLmV4cGFuZG8gXSAmJiBvd25lclsgdGhpcy5leHBhbmRvIF1bIGNhbWVsQ2FzZSgga2V5ICkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cblx0XHQvLyBJbiBjYXNlcyB3aGVyZSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIE5vIGtleSB3YXMgc3BlY2lmaWVkXG5cdFx0Ly8gICAyLiBBIHN0cmluZyBrZXkgd2FzIHNwZWNpZmllZCwgYnV0IG5vIHZhbHVlIHByb3ZpZGVkXG5cdFx0Ly9cblx0XHQvLyBUYWtlIHRoZSBcInJlYWRcIiBwYXRoIGFuZCBhbGxvdyB0aGUgZ2V0IG1ldGhvZCB0byBkZXRlcm1pbmVcblx0XHQvLyB3aGljaCB2YWx1ZSB0byByZXR1cm4sIHJlc3BlY3RpdmVseSBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIFRoZSBlbnRpcmUgY2FjaGUgb2JqZWN0XG5cdFx0Ly8gICAyLiBUaGUgZGF0YSBzdG9yZWQgYXQgdGhlIGtleVxuXHRcdC8vXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fFxuXHRcdFx0XHQoICgga2V5ICYmIHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgKSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkgKSB7XG5cblx0XHRcdHJldHVybiB0aGlzLmdldCggb3duZXIsIGtleSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSxcblx0XHRcdGNhY2hlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0aWYgKCBjYWNoZSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICgga2V5ICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIGtleSApICkge1xuXG5cdFx0XHRcdC8vIElmIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdlIGFsd2F5cyBzZXQgY2FtZWxDYXNlIGtleXMsIHNvIHJlbW92ZSB0aGF0LlxuXHRcdFx0XHRrZXkgPSBrZXkubWFwKCBjYW1lbENhc2UgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGtleSA9IGNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gSWYgYSBrZXkgd2l0aCB0aGUgc3BhY2VzIGV4aXN0cywgdXNlIGl0LlxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRrZXkgPSBrZXkgaW4gY2FjaGUgP1xuXHRcdFx0XHRcdFsga2V5IF0gOlxuXHRcdFx0XHRcdCgga2V5Lm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW10gKTtcblx0XHRcdH1cblxuXHRcdFx0aSA9IGtleS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIGtleVsgaSBdIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIHRoZSBleHBhbmRvIGlmIHRoZXJlJ3Mgbm8gbW9yZSBkYXRhXG5cdFx0aWYgKCBrZXkgPT09IHVuZGVmaW5lZCB8fCBqUXVlcnkuaXNFbXB0eU9iamVjdCggY2FjaGUgKSApIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NVxuXHRcdFx0Ly8gV2Via2l0ICYgQmxpbmsgcGVyZm9ybWFuY2Ugc3VmZmVycyB3aGVuIGRlbGV0aW5nIHByb3BlcnRpZXNcblx0XHRcdC8vIGZyb20gRE9NIG5vZGVzLCBzbyBzZXQgdG8gdW5kZWZpbmVkIGluc3RlYWRcblx0XHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTM3ODYwNyAoYnVnIHJlc3RyaWN0ZWQpXG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGdldERhdGEoIGRhdGEgKSB7XG5cdGlmICggZGF0YSA9PT0gXCJ0cnVlXCIgKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwiZmFsc2VcIiApIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHRpZiAoIGRhdGEgPT09IFwibnVsbFwiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gT25seSBjb252ZXJ0IHRvIGEgbnVtYmVyIGlmIGl0IGRvZXNuJ3QgY2hhbmdlIHRoZSBzdHJpbmdcblx0aWYgKCBkYXRhID09PSArZGF0YSArIFwiXCIgKSB7XG5cdFx0cmV0dXJuICtkYXRhO1xuXHR9XG5cblx0aWYgKCByYnJhY2UudGVzdCggZGF0YSApICkge1xuXHRcdHJldHVybiBKU09OLnBhcnNlKCBkYXRhICk7XG5cdH1cblxuXHRyZXR1cm4gZGF0YTtcbn1cblxuZnVuY3Rpb24gZGF0YUF0dHIoIGVsZW0sIGtleSwgZGF0YSApIHtcblx0dmFyIG5hbWU7XG5cblx0Ly8gSWYgbm90aGluZyB3YXMgZm91bmQgaW50ZXJuYWxseSwgdHJ5IHRvIGZldGNoIGFueVxuXHQvLyBkYXRhIGZyb20gdGhlIEhUTUw1IGRhdGEtKiBhdHRyaWJ1dGVcblx0aWYgKCBkYXRhID09PSB1bmRlZmluZWQgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRuYW1lID0gXCJkYXRhLVwiICsga2V5LnJlcGxhY2UoIHJtdWx0aURhc2gsIFwiLSQmXCIgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdGRhdGEgPSBlbGVtLmdldEF0dHJpYnV0ZSggbmFtZSApO1xuXG5cdFx0aWYgKCB0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGRhdGEgPSBnZXREYXRhKCBkYXRhICk7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0XHRcdFx0Ly8gVGhlIGF0dHJzIGVsZW1lbnRzIGNhbiBiZSBudWxsICgjMTQ4OTQpXG5cdFx0XHRcdFx0XHRpZiAoIGF0dHJzWyBpIF0gKSB7XG5cdFx0XHRcdFx0XHRcdG5hbWUgPSBhdHRyc1sgaSBdLm5hbWU7XG5cdFx0XHRcdFx0XHRcdGlmICggbmFtZS5pbmRleE9mKCBcImRhdGEtXCIgKSA9PT0gMCApIHtcblx0XHRcdFx0XHRcdFx0XHRuYW1lID0gY2FtZWxDYXNlKCBuYW1lLnNsaWNlKCA1ICkgKTtcblx0XHRcdFx0XHRcdFx0XHRkYXRhQXR0ciggZWxlbSwgbmFtZSwgZGF0YVsgbmFtZSBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0fVxuXG5cdFx0Ly8gU2V0cyBtdWx0aXBsZSB2YWx1ZXNcblx0XHRpZiAoIHR5cGVvZiBrZXkgPT09IFwib2JqZWN0XCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVVzZXIuc2V0KCB0aGlzLCBrZXkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZGF0YTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gVGhlIGtleSB3aWxsIGFsd2F5cyBiZSBjYW1lbENhc2VkIGluIERhdGFcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSwga2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGtleSApO1xuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFdlIHRyaWVkIHJlYWxseSBoYXJkLCBidXQgdGhlIGRhdGEgZG9lc24ndCBleGlzdC5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgdGhlIGRhdGEuLi5cblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gV2UgYWx3YXlzIHN0b3JlIHRoZSBjYW1lbENhc2VkIGtleVxuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdH0gKTtcblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEsIG51bGwsIHRydWUgKTtcblx0fSxcblxuXHRyZW1vdmVEYXRhOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0ZGF0YVVzZXIucmVtb3ZlKCB0aGlzLCBrZXkgKTtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdHF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSwgZGF0YSApIHtcblx0XHR2YXIgcXVldWU7XG5cblx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHR0eXBlID0gKCB0eXBlIHx8IFwiZnhcIiApICsgXCJxdWV1ZVwiO1xuXHRcdFx0cXVldWUgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0Ly8gU3BlZWQgdXAgZGVxdWV1ZSBieSBnZXR0aW5nIG91dCBxdWlja2x5IGlmIHRoaXMgaXMganVzdCBhIGxvb2t1cFxuXHRcdFx0aWYgKCBkYXRhICkge1xuXHRcdFx0XHRpZiAoICFxdWV1ZSB8fCBBcnJheS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBkb2N1bWVudEVsZW1lbnQgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG5cblxuXG5cdHZhciBpc0F0dGFjaGVkID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0XHR9LFxuXHRcdGNvbXBvc2VkID0geyBjb21wb3NlZDogdHJ1ZSB9O1xuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSssIEVkZ2UgMTIgLSAxOCssIGlPUyAxMC4wIC0gMTAuMiBvbmx5XG5cdC8vIENoZWNrIGF0dGFjaG1lbnQgYWNyb3NzIHNoYWRvdyBET00gYm91bmRhcmllcyB3aGVuIHBvc3NpYmxlIChnaC0zNTA0KVxuXHQvLyBTdXBwb3J0OiBpT1MgMTAuMC0xMC4yIG9ubHlcblx0Ly8gRWFybHkgaU9TIDEwIHZlcnNpb25zIHN1cHBvcnQgYGF0dGFjaFNoYWRvd2AgYnV0IG5vdCBgZ2V0Um9vdE5vZGVgLFxuXHQvLyBsZWFkaW5nIHRvIGVycm9ycy4gV2UgbmVlZCB0byBjaGVjayBmb3IgYGdldFJvb3ROb2RlYC5cblx0aWYgKCBkb2N1bWVudEVsZW1lbnQuZ2V0Um9vdE5vZGUgKSB7XG5cdFx0aXNBdHRhY2hlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRSb290Tm9kZSggY29tcG9zZWQgKSA9PT0gZWxlbS5vd25lckRvY3VtZW50O1xuXHRcdH07XG5cdH1cbnZhciBpc0hpZGRlbldpdGhpblRyZWUgPSBmdW5jdGlvbiggZWxlbSwgZWwgKSB7XG5cblx0XHQvLyBpc0hpZGRlbldpdGhpblRyZWUgbWlnaHQgYmUgY2FsbGVkIGZyb20galF1ZXJ5I2ZpbHRlciBmdW5jdGlvbjtcblx0XHQvLyBpbiB0aGF0IGNhc2UsIGVsZW1lbnQgd2lsbCBiZSBzZWNvbmQgYXJndW1lbnRcblx0XHRlbGVtID0gZWwgfHwgZWxlbTtcblxuXHRcdC8vIElubGluZSBzdHlsZSB0cnVtcHMgYWxsXG5cdFx0cmV0dXJuIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJub25lXCIgfHxcblx0XHRcdGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJlxuXG5cdFx0XHQvLyBPdGhlcndpc2UsIGNoZWNrIGNvbXB1dGVkIHN0eWxlXG5cdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NDMgLSA0NVxuXHRcdFx0Ly8gRGlzY29ubmVjdGVkIGVsZW1lbnRzIGNhbiBoYXZlIGNvbXB1dGVkIGRpc3BsYXk6IG5vbmUsIHNvIGZpcnN0IGNvbmZpcm0gdGhhdCBlbGVtIGlzXG5cdFx0XHQvLyBpbiB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpc0F0dGFjaGVkKCBlbGVtICkgJiZcblxuXHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJkaXNwbGF5XCIgKSA9PT0gXCJub25lXCI7XG5cdH07XG5cblxuXG5mdW5jdGlvbiBhZGp1c3RDU1MoIGVsZW0sIHByb3AsIHZhbHVlUGFydHMsIHR3ZWVuICkge1xuXHR2YXIgYWRqdXN0ZWQsIHNjYWxlLFxuXHRcdG1heEl0ZXJhdGlvbnMgPSAyMCxcblx0XHRjdXJyZW50VmFsdWUgPSB0d2VlbiA/XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuLmN1cigpO1xuXHRcdFx0fSA6XG5cdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AsIFwiXCIgKTtcblx0XHRcdH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9IGVsZW0ubm9kZVR5cGUgJiZcblx0XHRcdCggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0XHQvLyBIYWx2ZSB0aGUgaXRlcmF0aW9uIHRhcmdldCB2YWx1ZSB0byBwcmV2ZW50IGludGVyZmVyZW5jZSBmcm9tIENTUyB1cHBlciBib3VuZHMgKGdoLTIxNDQpXG5cdFx0aW5pdGlhbCA9IGluaXRpYWwgLyAyO1xuXG5cdFx0Ly8gVHJ1c3QgdW5pdHMgcmVwb3J0ZWQgYnkgalF1ZXJ5LmNzc1xuXHRcdHVuaXQgPSB1bml0IHx8IGluaXRpYWxJblVuaXRbIDMgXTtcblxuXHRcdC8vIEl0ZXJhdGl2ZWx5IGFwcHJveGltYXRlIGZyb20gYSBub256ZXJvIHN0YXJ0aW5nIHBvaW50XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsIHx8IDE7XG5cblx0XHR3aGlsZSAoIG1heEl0ZXJhdGlvbnMtLSApIHtcblxuXHRcdFx0Ly8gRXZhbHVhdGUgYW5kIHVwZGF0ZSBvdXIgYmVzdCBndWVzcyAoZG91YmxpbmcgZ3Vlc3NlcyB0aGF0IHplcm8gb3V0KS5cblx0XHRcdC8vIEZpbmlzaCBpZiB0aGUgc2NhbGUgZXF1YWxzIG9yIGNyb3NzZXMgMSAobWFraW5nIHRoZSBvbGQqbmV3IHByb2R1Y3Qgbm9uLXBvc2l0aXZlKS5cblx0XHRcdGpRdWVyeS5zdHlsZSggZWxlbSwgcHJvcCwgaW5pdGlhbEluVW5pdCArIHVuaXQgKTtcblx0XHRcdGlmICggKCAxIC0gc2NhbGUgKSAqICggMSAtICggc2NhbGUgPSBjdXJyZW50VmFsdWUoKSAvIGluaXRpYWwgfHwgMC41ICkgKSA8PSAwICkge1xuXHRcdFx0XHRtYXhJdGVyYXRpb25zID0gMDtcblx0XHRcdH1cblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cblx0XHR9XG5cblx0XHRpbml0aWFsSW5Vbml0ID0gaW5pdGlhbEluVW5pdCAqIDI7XG5cdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBpbml0aWFsSW5Vbml0ICsgdW5pdCApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXHR9XG5cblx0aWYgKCB2YWx1ZVBhcnRzICkge1xuXHRcdGluaXRpYWxJblVuaXQgPSAraW5pdGlhbEluVW5pdCB8fCAraW5pdGlhbCB8fCAwO1xuXG5cdFx0Ly8gQXBwbHkgcmVsYXRpdmUgb2Zmc2V0ICgrPS8tPSkgaWYgc3BlY2lmaWVkXG5cdFx0YWRqdXN0ZWQgPSB2YWx1ZVBhcnRzWyAxIF0gP1xuXHRcdFx0aW5pdGlhbEluVW5pdCArICggdmFsdWVQYXJ0c1sgMSBdICsgMSApICogdmFsdWVQYXJ0c1sgMiBdIDpcblx0XHRcdCt2YWx1ZVBhcnRzWyAyIF07XG5cdFx0aWYgKCB0d2VlbiApIHtcblx0XHRcdHR3ZWVuLnVuaXQgPSB1bml0O1xuXHRcdFx0dHdlZW4uc3RhcnQgPSBpbml0aWFsSW5Vbml0O1xuXHRcdFx0dHdlZW4uZW5kID0gYWRqdXN0ZWQ7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBhZGp1c3RlZDtcbn1cblxuXG52YXIgZGVmYXVsdERpc3BsYXlNYXAgPSB7fTtcblxuZnVuY3Rpb24gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKSB7XG5cdHZhciB0ZW1wLFxuXHRcdGRvYyA9IGVsZW0ub3duZXJEb2N1bWVudCxcblx0XHRub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUsXG5cdFx0ZGlzcGxheSA9IGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdO1xuXG5cdGlmICggZGlzcGxheSApIHtcblx0XHRyZXR1cm4gZGlzcGxheTtcblx0fVxuXG5cdHRlbXAgPSBkb2MuYm9keS5hcHBlbmRDaGlsZCggZG9jLmNyZWF0ZUVsZW1lbnQoIG5vZGVOYW1lICkgKTtcblx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIHRlbXAsIFwiZGlzcGxheVwiICk7XG5cblx0dGVtcC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCB0ZW1wICk7XG5cblx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRkaXNwbGF5ID0gXCJibG9ja1wiO1xuXHR9XG5cdGRlZmF1bHREaXNwbGF5TWFwWyBub2RlTmFtZSBdID0gZGlzcGxheTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSxcblx0XHR2YWx1ZXMgPSBbXSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gZWxlbWVudHMubGVuZ3RoO1xuXG5cdC8vIERldGVybWluZSBuZXcgZGlzcGxheSB2YWx1ZSBmb3IgZWxlbWVudHMgdGhhdCBuZWVkIHRvIGNoYW5nZVxuXHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXG5cdFx0ZGlzcGxheSA9IGVsZW0uc3R5bGUuZGlzcGxheTtcblx0XHRpZiAoIHNob3cgKSB7XG5cblx0XHRcdC8vIFNpbmNlIHdlIGZvcmNlIHZpc2liaWxpdHkgdXBvbiBjYXNjYWRlLWhpZGRlbiBlbGVtZW50cywgYW4gaW1tZWRpYXRlIChhbmQgc2xvdylcblx0XHRcdC8vIGNoZWNrIGlzIHJlcXVpcmVkIGluIHRoaXMgZmlyc3QgbG9vcCB1bmxlc3Mgd2UgaGF2ZSBhIG5vbmVtcHR5IGRpc3BsYXkgdmFsdWUgKGVpdGhlclxuXHRcdFx0Ly8gaW5saW5lIG9yIGFib3V0LXRvLWJlLXJlc3RvcmVkKVxuXHRcdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuZ2V0KCBlbGVtLCBcImRpc3BsYXlcIiApIHx8IG51bGw7XG5cdFx0XHRcdGlmICggIXZhbHVlc1sgaW5kZXggXSApIHtcblx0XHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGVsZW0uc3R5bGUuZGlzcGxheSA9PT0gXCJcIiAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZ2V0RGVmYXVsdERpc3BsYXkoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKCBkaXNwbGF5ICE9PSBcIm5vbmVcIiApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gXCJub25lXCI7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgd2hhdCB3ZSdyZSBvdmVyd3JpdGluZ1xuXHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiZGlzcGxheVwiLCBkaXNwbGF5ICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIHRoZSBlbGVtZW50cyBpbiBhIHNlY29uZCBsb29wIHRvIGF2b2lkIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGlmICggdmFsdWVzWyBpbmRleCBdICE9IG51bGwgKSB7XG5cdFx0XHRlbGVtZW50c1sgaW5kZXggXS5zdHlsZS5kaXNwbGF5ID0gdmFsdWVzWyBpbmRleCBdO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50cztcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuV2l0aGluVHJlZSggdGhpcyApICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5zaG93KCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5oaWRlKCk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG52YXIgcmNoZWNrYWJsZVR5cGUgPSAoIC9eKD86Y2hlY2tib3h8cmFkaW8pJC9pICk7XG5cbnZhciBydGFnTmFtZSA9ICggLzwoW2Etel1bXlxcL1xcMD5cXHgyMFxcdFxcclxcblxcZl0qKS9pICk7XG5cbnZhciByc2NyaXB0VHlwZSA9ICggL14kfF5tb2R1bGUkfFxcLyg/OmphdmF8ZWNtYSlzY3JpcHQvaSApO1xuXG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGZyYWdtZW50ID0gZG9jdW1lbnQuY3JlYXRlRG9jdW1lbnRGcmFnbWVudCgpLFxuXHRcdGRpdiA9IGZyYWdtZW50LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKSxcblx0XHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wIC0gNC4zIG9ubHlcblx0Ly8gQ2hlY2sgc3RhdGUgbG9zdCBpZiB0aGUgbmFtZSBpcyBzZXQgKCMxMTIxNylcblx0Ly8gU3VwcG9ydDogV2luZG93cyBXZWIgQXBwcyAoV1dBKVxuXHQvLyBgbmFtZWAgYW5kIGB0eXBlYCBtdXN0IHVzZSAuc2V0QXR0cmlidXRlIGZvciBXV0EgKCMxNDkwMSlcblx0aW5wdXQuc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgXCJyYWRpb1wiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJjaGVja2VkXCIsIFwiY2hlY2tlZFwiICk7XG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJuYW1lXCIsIFwidFwiICk7XG5cblx0ZGl2LmFwcGVuZENoaWxkKCBpbnB1dCApO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgb25seVxuXHQvLyBPbGRlciBXZWJLaXQgZG9lc24ndCBjbG9uZSBjaGVja2VkIHN0YXRlIGNvcnJlY3RseSBpbiBmcmFnbWVudHNcblx0c3VwcG9ydC5jaGVja0Nsb25lID0gZGl2LmNsb25lTm9kZSggdHJ1ZSApLmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5jaGVja2VkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNYWtlIHN1cmUgdGV4dGFyZWEgKGFuZCBjaGVja2JveCkgZGVmYXVsdFZhbHVlIGlzIHByb3Blcmx5IGNsb25lZFxuXHRkaXYuaW5uZXJIVE1MID0gXCI8dGV4dGFyZWE+eDwvdGV4dGFyZWE+XCI7XG5cdHN1cHBvcnQubm9DbG9uZUNoZWNrZWQgPSAhIWRpdi5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuZGVmYXVsdFZhbHVlO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdC8vIElFIDw9OSByZXBsYWNlcyA8b3B0aW9uPiB0YWdzIHdpdGggdGhlaXIgY29udGVudHMgd2hlbiBpbnNlcnRlZCBvdXRzaWRlIG9mXG5cdC8vIHRoZSBzZWxlY3QgZWxlbWVudC5cblx0ZGl2LmlubmVySFRNTCA9IFwiPG9wdGlvbj48L29wdGlvbj5cIjtcblx0c3VwcG9ydC5vcHRpb24gPSAhIWRpdi5sYXN0Q2hpbGQ7XG59ICkoKTtcblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gWEhUTUwgcGFyc2VycyBkbyBub3QgbWFnaWNhbGx5IGluc2VydCBlbGVtZW50cyBpbiB0aGVcblx0Ly8gc2FtZSB3YXkgdGhhdCB0YWcgc291cCBwYXJzZXJzIGRvLiBTbyB3ZSBjYW5ub3Qgc2hvcnRlblxuXHQvLyB0aGlzIGJ5IG9taXR0aW5nIDx0Ym9keT4gb3Igb3RoZXIgcmVxdWlyZWQgZWxlbWVudHMuXG5cdHRoZWFkOiBbIDEsIFwiPHRhYmxlPlwiLCBcIjwvdGFibGU+XCIgXSxcblx0Y29sOiBbIDIsIFwiPHRhYmxlPjxjb2xncm91cD5cIiwgXCI8L2NvbGdyb3VwPjwvdGFibGU+XCIgXSxcblx0dHI6IFsgMiwgXCI8dGFibGU+PHRib2R5PlwiLCBcIjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXHR0ZDogWyAzLCBcIjx0YWJsZT48dGJvZHk+PHRyPlwiLCBcIjwvdHI+PC90Ym9keT48L3RhYmxlPlwiIF0sXG5cblx0X2RlZmF1bHQ6IFsgMCwgXCJcIiwgXCJcIiBdXG59O1xuXG53cmFwTWFwLnRib2R5ID0gd3JhcE1hcC50Zm9vdCA9IHdyYXBNYXAuY29sZ3JvdXAgPSB3cmFwTWFwLmNhcHRpb24gPSB3cmFwTWFwLnRoZWFkO1xud3JhcE1hcC50aCA9IHdyYXBNYXAudGQ7XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5pZiAoICFzdXBwb3J0Lm9wdGlvbiApIHtcblx0d3JhcE1hcC5vcHRncm91cCA9IHdyYXBNYXAub3B0aW9uID0gWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdO1xufVxuXG5cbmZ1bmN0aW9uIGdldEFsbCggY29udGV4dCwgdGFnICkge1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gVXNlIHR5cGVvZiB0byBhdm9pZCB6ZXJvLWFyZ3VtZW50IG1ldGhvZCBpbnZvY2F0aW9uIG9uIGhvc3Qgb2JqZWN0cyAoIzE1MTUxKVxuXHR2YXIgcmV0O1xuXG5cdGlmICggdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0cmV0ID0gY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSggdGFnIHx8IFwiKlwiICk7XG5cblx0fSBlbHNlIGlmICggdHlwZW9mIGNvbnRleHQucXVlcnlTZWxlY3RvckFsbCAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRyZXQgPSBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApO1xuXG5cdH0gZWxzZSB7XG5cdFx0cmV0ID0gW107XG5cdH1cblxuXHRpZiAoIHRhZyA9PT0gdW5kZWZpbmVkIHx8IHRhZyAmJiBub2RlTmFtZSggY29udGV4dCwgdGFnICkgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5tZXJnZSggWyBjb250ZXh0IF0sIHJldCApO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGF0dGFjaGVkLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggdG9UeXBlKCBlbGVtICkgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5LCBQaGFudG9tSlMgMSBvbmx5XG5cdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBub2RlcywgZWxlbS5ub2RlVHlwZSA/IFsgZWxlbSBdIDogZWxlbSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IG5vbi1odG1sIGludG8gYSB0ZXh0IG5vZGVcblx0XHRcdH0gZWxzZSBpZiAoICFyaHRtbC50ZXN0KCBlbGVtICkgKSB7XG5cdFx0XHRcdG5vZGVzLnB1c2goIGNvbnRleHQuY3JlYXRlVGV4dE5vZGUoIGVsZW0gKSApO1xuXG5cdFx0XHQvLyBDb252ZXJ0IGh0bWwgaW50byBET00gbm9kZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRtcCA9IHRtcCB8fCBmcmFnbWVudC5hcHBlbmRDaGlsZCggY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICkgKTtcblxuXHRcdFx0XHQvLyBEZXNlcmlhbGl6ZSBhIHN0YW5kYXJkIHJlcHJlc2VudGF0aW9uXG5cdFx0XHRcdHRhZyA9ICggcnRhZ05hbWUuZXhlYyggZWxlbSApIHx8IFsgXCJcIiwgXCJcIiBdIClbIDEgXS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0XHR3cmFwID0gd3JhcE1hcFsgdGFnIF0gfHwgd3JhcE1hcC5fZGVmYXVsdDtcblx0XHRcdFx0dG1wLmlubmVySFRNTCA9IHdyYXBbIDEgXSArIGpRdWVyeS5odG1sUHJlZmlsdGVyKCBlbGVtICkgKyB3cmFwWyAyIF07XG5cblx0XHRcdFx0Ly8gRGVzY2VuZCB0aHJvdWdoIHdyYXBwZXJzIHRvIHRoZSByaWdodCBjb250ZW50XG5cdFx0XHRcdGogPSB3cmFwWyAwIF07XG5cdFx0XHRcdHdoaWxlICggai0tICkge1xuXHRcdFx0XHRcdHRtcCA9IHRtcC5sYXN0Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCB0bXAuY2hpbGROb2RlcyApO1xuXG5cdFx0XHRcdC8vIFJlbWVtYmVyIHRoZSB0b3AtbGV2ZWwgY29udGFpbmVyXG5cdFx0XHRcdHRtcCA9IGZyYWdtZW50LmZpcnN0Q2hpbGQ7XG5cblx0XHRcdFx0Ly8gRW5zdXJlIHRoZSBjcmVhdGVkIG5vZGVzIGFyZSBvcnBoYW5lZCAoIzEyMzkyKVxuXHRcdFx0XHR0bXAudGV4dENvbnRlbnQgPSBcIlwiO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJlbW92ZSB3cmFwcGVyIGZyb20gZnJhZ21lbnRcblx0ZnJhZ21lbnQudGV4dENvbnRlbnQgPSBcIlwiO1xuXG5cdGkgPSAwO1xuXHR3aGlsZSAoICggZWxlbSA9IG5vZGVzWyBpKysgXSApICkge1xuXG5cdFx0Ly8gU2tpcCBlbGVtZW50cyBhbHJlYWR5IGluIHRoZSBjb250ZXh0IGNvbGxlY3Rpb24gKHRyYWMtNDA4Nylcblx0XHRpZiAoIHNlbGVjdGlvbiAmJiBqUXVlcnkuaW5BcnJheSggZWxlbSwgc2VsZWN0aW9uICkgPiAtMSApIHtcblx0XHRcdGlmICggaWdub3JlZCApIHtcblx0XHRcdFx0aWdub3JlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHR9XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cblx0XHRhdHRhY2hlZCA9IGlzQXR0YWNoZWQoIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggYXR0YWNoZWQgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbnZhclxuXHRya2V5RXZlbnQgPSAvXmtleS8sXG5cdHJtb3VzZUV2ZW50ID0gL14oPzptb3VzZXxwb2ludGVyfGNvbnRleHRtZW51fGRyYWd8ZHJvcCl8Y2xpY2svLFxuXHRydHlwZW5hbWVzcGFjZSA9IC9eKFteLl0qKSg/OlxcLiguKyl8KS87XG5cbmZ1bmN0aW9uIHJldHVyblRydWUoKSB7XG5cdHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiByZXR1cm5GYWxzZSgpIHtcblx0cmV0dXJuIGZhbHNlO1xufVxuXG4vLyBTdXBwb3J0OiBJRSA8PTkgLSAxMStcbi8vIGZvY3VzKCkgYW5kIGJsdXIoKSBhcmUgYXN5bmNocm9ub3VzLCBleGNlcHQgd2hlbiB0aGV5IGFyZSBuby1vcC5cbi8vIFNvIGV4cGVjdCBmb2N1cyB0byBiZSBzeW5jaHJvbm91cyB3aGVuIHRoZSBlbGVtZW50IGlzIGFscmVhZHkgYWN0aXZlLFxuLy8gYW5kIGJsdXIgdG8gYmUgc3luY2hyb25vdXMgd2hlbiB0aGUgZWxlbWVudCBpcyBub3QgYWxyZWFkeSBhY3RpdmUuXG4vLyAoZm9jdXMgYW5kIGJsdXIgYXJlIGFsd2F5cyBzeW5jaHJvbm91cyBpbiBvdGhlciBzdXBwb3J0ZWQgYnJvd3NlcnMsXG4vLyB0aGlzIGp1c3QgZGVmaW5lcyB3aGVuIHdlIGNhbiBjb3VudCBvbiBpdCkuXG5mdW5jdGlvbiBleHBlY3RTeW5jKCBlbGVtLCB0eXBlICkge1xuXHRyZXR1cm4gKCBlbGVtID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICkgPT09ICggdHlwZSA9PT0gXCJmb2N1c1wiICk7XG59XG5cbi8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG4vLyBBY2Nlc3NpbmcgZG9jdW1lbnQuYWN0aXZlRWxlbWVudCBjYW4gdGhyb3cgdW5leHBlY3RlZGx5XG4vLyBodHRwczovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTMzOTNcbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gZWxlbTtcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gT25seSBhdHRhY2ggZXZlbnRzIHRvIG9iamVjdHMgdGhhdCBhY2NlcHQgZGF0YVxuXHRcdGlmICggIWFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBFbnN1cmUgdGhhdCBpbnZhbGlkIHNlbGVjdG9ycyB0aHJvdyBleGNlcHRpb25zIGF0IGF0dGFjaCB0aW1lXG5cdFx0Ly8gRXZhbHVhdGUgYWdhaW5zdCBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBlbGVtIGlzIGEgbm9uLWVsZW1lbnQgbm9kZSAoZS5nLiwgZG9jdW1lbnQpXG5cdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggZG9jdW1lbnRFbGVtZW50LCBzZWxlY3RvciApO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHRoZSBoYW5kbGVyIGhhcyBhIHVuaXF1ZSBJRCwgdXNlZCB0byBmaW5kL3JlbW92ZSBpdCBsYXRlclxuXHRcdGlmICggIWhhbmRsZXIuZ3VpZCApIHtcblx0XHRcdGhhbmRsZXIuZ3VpZCA9IGpRdWVyeS5ndWlkKys7XG5cdFx0fVxuXG5cdFx0Ly8gSW5pdCB0aGUgZWxlbWVudCdzIGV2ZW50IHN0cnVjdHVyZSBhbmQgbWFpbiBoYW5kbGVyLCBpZiB0aGlzIGlzIHRoZSBmaXJzdFxuXHRcdGlmICggISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRldmVudHMgPSBlbGVtRGF0YS5ldmVudHMgPSBPYmplY3QuY3JlYXRlKCBudWxsICk7XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVGhlcmUgKm11c3QqIGJlIGEgdHlwZSwgbm8gYXR0YWNoaW5nIG5hbWVzcGFjZS1vbmx5IGhhbmRsZXJzXG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgZXZlbnQgY2hhbmdlcyBpdHMgdHlwZSwgdXNlIHRoZSBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzIGZvciB0aGUgY2hhbmdlZCB0eXBlXG5cdFx0XHRzcGVjaWFsID0galF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSB8fCB7fTtcblxuXHRcdFx0Ly8gSWYgc2VsZWN0b3IgZGVmaW5lZCwgZGV0ZXJtaW5lIHNwZWNpYWwgZXZlbnQgYXBpIHR5cGUsIG90aGVyd2lzZSBnaXZlbiB0eXBlXG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cblx0XHRcdC8vIFVwZGF0ZSBzcGVjaWFsIGJhc2VkIG9uIG5ld2x5IHJlc2V0IHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBoYW5kbGVPYmogaXMgcGFzc2VkIHRvIGFsbCBldmVudCBoYW5kbGVyc1xuXHRcdFx0aGFuZGxlT2JqID0galF1ZXJ5LmV4dGVuZCgge1xuXHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRvcmlnVHlwZTogb3JpZ1R5cGUsXG5cdFx0XHRcdGRhdGE6IGRhdGEsXG5cdFx0XHRcdGhhbmRsZXI6IGhhbmRsZXIsXG5cdFx0XHRcdGd1aWQ6IGhhbmRsZXIuZ3VpZCxcblx0XHRcdFx0c2VsZWN0b3I6IHNlbGVjdG9yLFxuXHRcdFx0XHRuZWVkc0NvbnRleHQ6IHNlbGVjdG9yICYmIGpRdWVyeS5leHByLm1hdGNoLm5lZWRzQ29udGV4dC50ZXN0KCBzZWxlY3RvciApLFxuXHRcdFx0XHRuYW1lc3BhY2U6IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKVxuXHRcdFx0fSwgaGFuZGxlT2JqSW4gKTtcblxuXHRcdFx0Ly8gSW5pdCB0aGUgZXZlbnQgaGFuZGxlciBxdWV1ZSBpZiB3ZSdyZSB0aGUgZmlyc3Rcblx0XHRcdGlmICggISggaGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSApICkge1xuXHRcdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdID0gW107XG5cdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQgPSAwO1xuXG5cdFx0XHRcdC8vIE9ubHkgdXNlIGFkZEV2ZW50TGlzdGVuZXIgaWYgdGhlIHNwZWNpYWwgZXZlbnRzIGhhbmRsZXIgcmV0dXJucyBmYWxzZVxuXHRcdFx0XHRpZiAoICFzcGVjaWFsLnNldHVwIHx8XG5cdFx0XHRcdFx0c3BlY2lhbC5zZXR1cC5jYWxsKCBlbGVtLCBkYXRhLCBuYW1lc3BhY2VzLCBldmVudEhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGlmICggZWxlbS5hZGRFdmVudExpc3RlbmVyICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5hZGRFdmVudExpc3RlbmVyKCB0eXBlLCBldmVudEhhbmRsZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHNwZWNpYWwuYWRkICkge1xuXHRcdFx0XHRzcGVjaWFsLmFkZC5jYWxsKCBlbGVtLCBoYW5kbGVPYmogKTtcblxuXHRcdFx0XHRpZiAoICFoYW5kbGVPYmouaGFuZGxlci5ndWlkICkge1xuXHRcdFx0XHRcdGhhbmRsZU9iai5oYW5kbGVyLmd1aWQgPSBoYW5kbGVyLmd1aWQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHRvIHRoZSBlbGVtZW50J3MgaGFuZGxlciBsaXN0LCBkZWxlZ2F0ZXMgaW4gZnJvbnRcblx0XHRcdGlmICggc2VsZWN0b3IgKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZSggaGFuZGxlcnMuZGVsZWdhdGVDb3VudCsrLCAwLCBoYW5kbGVPYmogKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goIGhhbmRsZU9iaiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBLZWVwIHRyYWNrIG9mIHdoaWNoIGV2ZW50cyBoYXZlIGV2ZXIgYmVlbiB1c2VkLCBmb3IgZXZlbnQgb3B0aW1pemF0aW9uXG5cdFx0XHRqUXVlcnkuZXZlbnQuZ2xvYmFsWyB0eXBlIF0gPSB0cnVlO1xuXHRcdH1cblxuXHR9LFxuXG5cdC8vIERldGFjaCBhbiBldmVudCBvciBzZXQgb2YgZXZlbnRzIGZyb20gYW4gZWxlbWVudFxuXHRyZW1vdmU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlcywgaGFuZGxlciwgc2VsZWN0b3IsIG1hcHBlZFR5cGVzICkge1xuXG5cdFx0dmFyIGosIG9yaWdDb3VudCwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2Lmhhc0RhdGEoIGVsZW0gKSAmJiBkYXRhUHJpdi5nZXQoIGVsZW0gKTtcblxuXHRcdGlmICggIWVsZW1EYXRhIHx8ICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE9uY2UgZm9yIGVhY2ggdHlwZS5uYW1lc3BhY2UgaW4gdHlwZXM7IHR5cGUgbWF5IGJlIG9taXR0ZWRcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgWyBcIlwiIF07XG5cdFx0dCA9IHR5cGVzLmxlbmd0aDtcblx0XHR3aGlsZSAoIHQtLSApIHtcblx0XHRcdHRtcCA9IHJ0eXBlbmFtZXNwYWNlLmV4ZWMoIHR5cGVzWyB0IF0gKSB8fCBbXTtcblx0XHRcdHR5cGUgPSBvcmlnVHlwZSA9IHRtcFsgMSBdO1xuXHRcdFx0bmFtZXNwYWNlcyA9ICggdG1wWyAyIF0gfHwgXCJcIiApLnNwbGl0KCBcIi5cIiApLnNvcnQoKTtcblxuXHRcdFx0Ly8gVW5iaW5kIGFsbCBldmVudHMgKG9uIHRoaXMgbmFtZXNwYWNlLCBpZiBwcm92aWRlZCkgZm9yIHRoZSBlbGVtZW50XG5cdFx0XHRpZiAoICF0eXBlICkge1xuXHRcdFx0XHRmb3IgKCB0eXBlIGluIGV2ZW50cyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCBlbGVtLCB0eXBlICsgdHlwZXNbIHQgXSwgaGFuZGxlciwgc2VsZWN0b3IsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0XHR0eXBlID0gKCBzZWxlY3RvciA/IHNwZWNpYWwuZGVsZWdhdGVUeXBlIDogc3BlY2lhbC5iaW5kVHlwZSApIHx8IHR5cGU7XG5cdFx0XHRoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdIHx8IFtdO1xuXHRcdFx0dG1wID0gdG1wWyAyIF0gJiZcblx0XHRcdFx0bmV3IFJlZ0V4cCggXCIoXnxcXFxcLilcIiArIG5hbWVzcGFjZXMuam9pbiggXCJcXFxcLig/Oi4qXFxcXC58KVwiICkgKyBcIihcXFxcLnwkKVwiICk7XG5cblx0XHRcdC8vIFJlbW92ZSBtYXRjaGluZyBldmVudHNcblx0XHRcdG9yaWdDb3VudCA9IGogPSBoYW5kbGVycy5sZW5ndGg7XG5cdFx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdFx0aGFuZGxlT2JqID0gaGFuZGxlcnNbIGogXTtcblxuXHRcdFx0XHRpZiAoICggbWFwcGVkVHlwZXMgfHwgb3JpZ1R5cGUgPT09IGhhbmRsZU9iai5vcmlnVHlwZSApICYmXG5cdFx0XHRcdFx0KCAhaGFuZGxlciB8fCBoYW5kbGVyLmd1aWQgPT09IGhhbmRsZU9iai5ndWlkICkgJiZcblx0XHRcdFx0XHQoICF0bXAgfHwgdG1wLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApICYmXG5cdFx0XHRcdFx0KCAhc2VsZWN0b3IgfHwgc2VsZWN0b3IgPT09IGhhbmRsZU9iai5zZWxlY3RvciB8fFxuXHRcdFx0XHRcdFx0c2VsZWN0b3IgPT09IFwiKipcIiAmJiBoYW5kbGVPYmouc2VsZWN0b3IgKSApIHtcblx0XHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoIGosIDEgKTtcblxuXHRcdFx0XHRcdGlmICggaGFuZGxlT2JqLnNlbGVjdG9yICkge1xuXHRcdFx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudC0tO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNwZWNpYWwucmVtb3ZlICkge1xuXHRcdFx0XHRcdFx0c3BlY2lhbC5yZW1vdmUuY2FsbCggZWxlbSwgaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJlbW92ZSBnZW5lcmljIGV2ZW50IGhhbmRsZXIgaWYgd2UgcmVtb3ZlZCBzb21ldGhpbmcgYW5kIG5vIG1vcmUgaGFuZGxlcnMgZXhpc3Rcblx0XHRcdC8vIChhdm9pZHMgcG90ZW50aWFsIGZvciBlbmRsZXNzIHJlY3Vyc2lvbiBkdXJpbmcgcmVtb3ZhbCBvZiBzcGVjaWFsIGV2ZW50IGhhbmRsZXJzKVxuXHRcdFx0aWYgKCBvcmlnQ291bnQgJiYgIWhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0aWYgKCAhc3BlY2lhbC50ZWFyZG93biB8fFxuXHRcdFx0XHRcdHNwZWNpYWwudGVhcmRvd24uY2FsbCggZWxlbSwgbmFtZXNwYWNlcywgZWxlbURhdGEuaGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBlbGVtRGF0YS5oYW5kbGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGRlbGV0ZSBldmVudHNbIHR5cGUgXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBSZW1vdmUgZGF0YSBhbmQgdGhlIGV4cGFuZG8gaWYgaXQncyBubyBsb25nZXIgdXNlZFxuXHRcdGlmICggalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGV2ZW50cyApICkge1xuXHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImhhbmRsZSBldmVudHNcIiApO1xuXHRcdH1cblx0fSxcblxuXHRkaXNwYXRjaDogZnVuY3Rpb24oIG5hdGl2ZUV2ZW50ICkge1xuXG5cdFx0dmFyIGksIGosIHJldCwgbWF0Y2hlZCwgaGFuZGxlT2JqLCBoYW5kbGVyUXVldWUsXG5cdFx0XHRhcmdzID0gbmV3IEFycmF5KCBhcmd1bWVudHMubGVuZ3RoICksXG5cblx0XHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdFx0ZXZlbnQgPSBqUXVlcnkuZXZlbnQuZml4KCBuYXRpdmVFdmVudCApLFxuXG5cdFx0XHRoYW5kbGVycyA9IChcblx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0KVsgZXZlbnQudHlwZSBdIHx8IFtdLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyBldmVudC50eXBlIF0gfHwge307XG5cblx0XHQvLyBVc2UgdGhlIGZpeC1lZCBqUXVlcnkuRXZlbnQgcmF0aGVyIHRoYW4gdGhlIChyZWFkLW9ubHkpIG5hdGl2ZSBldmVudFxuXHRcdGFyZ3NbIDAgXSA9IGV2ZW50O1xuXG5cdFx0Zm9yICggaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRhcmdzWyBpIF0gPSBhcmd1bWVudHNbIGkgXTtcblx0XHR9XG5cblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gSWYgdGhlIGV2ZW50IGlzIG5hbWVzcGFjZWQsIHRoZW4gZWFjaCBoYW5kbGVyIGlzIG9ubHkgaW52b2tlZCBpZiBpdCBpc1xuXHRcdFx0XHQvLyBzcGVjaWFsbHkgdW5pdmVyc2FsIG9yIGl0cyBuYW1lc3BhY2VzIGFyZSBhIHN1cGVyc2V0IG9mIHRoZSBldmVudCdzLlxuXHRcdFx0XHRpZiAoICFldmVudC5ybmFtZXNwYWNlIHx8IGhhbmRsZU9iai5uYW1lc3BhY2UgPT09IGZhbHNlIHx8XG5cdFx0XHRcdFx0ZXZlbnQucm5hbWVzcGFjZS50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSB7XG5cblx0XHRcdFx0XHRldmVudC5oYW5kbGVPYmogPSBoYW5kbGVPYmo7XG5cdFx0XHRcdFx0ZXZlbnQuZGF0YSA9IGhhbmRsZU9iai5kYXRhO1xuXG5cdFx0XHRcdFx0cmV0ID0gKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyBoYW5kbGVPYmoub3JpZ1R5cGUgXSB8fCB7fSApLmhhbmRsZSB8fFxuXHRcdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIgKS5hcHBseSggbWF0Y2hlZC5lbGVtLCBhcmdzICk7XG5cblx0XHRcdFx0XHRpZiAoIHJldCAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoIGV2ZW50LnJlc3VsdCA9IHJldCApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbCB0aGUgcG9zdERpc3BhdGNoIGhvb2sgZm9yIHRoZSBtYXBwZWQgdHlwZVxuXHRcdGlmICggc3BlY2lhbC5wb3N0RGlzcGF0Y2ggKSB7XG5cdFx0XHRzcGVjaWFsLnBvc3REaXNwYXRjaC5jYWxsKCB0aGlzLCBldmVudCApO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0aGFuZGxlcnM6IGZ1bmN0aW9uKCBldmVudCwgaGFuZGxlcnMgKSB7XG5cdFx0dmFyIGksIGhhbmRsZU9iaiwgc2VsLCBtYXRjaGVkSGFuZGxlcnMsIG1hdGNoZWRTZWxlY3RvcnMsXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gRmluZCBkZWxlZ2F0ZSBoYW5kbGVyc1xuXHRcdGlmICggZGVsZWdhdGVDb3VudCAmJlxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRSA8PTlcblx0XHRcdC8vIEJsYWNrLWhvbGUgU1ZHIDx1c2U+IGluc3RhbmNlIHRyZWVzICh0cmFjLTEzMTgwKVxuXHRcdFx0Y3VyLm5vZGVUeXBlICYmXG5cblx0XHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3ggPD00MlxuXHRcdFx0Ly8gU3VwcHJlc3Mgc3BlYy12aW9sYXRpbmcgY2xpY2tzIGluZGljYXRpbmcgYSBub24tcHJpbWFyeSBwb2ludGVyIGJ1dHRvbiAodHJhYy0zODYxKVxuXHRcdFx0Ly8gaHR0cHM6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnQtdHlwZS1jbGlja1xuXHRcdFx0Ly8gU3VwcG9ydDogSUUgMTEgb25seVxuXHRcdFx0Ly8gLi4uYnV0IG5vdCBhcnJvdyBrZXkgXCJjbGlja3NcIiBvZiByYWRpbyBpbnB1dHMsIHdoaWNoIGNhbiBoYXZlIGBidXR0b25gIC0xIChnaC0yMzQzKVxuXHRcdFx0ISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGV2ZW50LmJ1dHRvbiA+PSAxICkgKSB7XG5cblx0XHRcdGZvciAoIDsgY3VyICE9PSB0aGlzOyBjdXIgPSBjdXIucGFyZW50Tm9kZSB8fCB0aGlzICkge1xuXG5cdFx0XHRcdC8vIERvbid0IGNoZWNrIG5vbi1lbGVtZW50cyAoIzEzMjA4KVxuXHRcdFx0XHQvLyBEb24ndCBwcm9jZXNzIGNsaWNrcyBvbiBkaXNhYmxlZCBlbGVtZW50cyAoIzY5MTEsICM4MTY1LCAjMTEzODIsICMxMTc2NClcblx0XHRcdFx0aWYgKCBjdXIubm9kZVR5cGUgPT09IDEgJiYgISggZXZlbnQudHlwZSA9PT0gXCJjbGlja1wiICYmIGN1ci5kaXNhYmxlZCA9PT0gdHJ1ZSApICkge1xuXHRcdFx0XHRcdG1hdGNoZWRIYW5kbGVycyA9IFtdO1xuXHRcdFx0XHRcdG1hdGNoZWRTZWxlY3RvcnMgPSB7fTtcblx0XHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGRlbGVnYXRlQ291bnQ7IGkrKyApIHtcblx0XHRcdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBpIF07XG5cblx0XHRcdFx0XHRcdC8vIERvbid0IGNvbmZsaWN0IHdpdGggT2JqZWN0LnByb3RvdHlwZSBwcm9wZXJ0aWVzICgjMTMyMDMpXG5cdFx0XHRcdFx0XHRzZWwgPSBoYW5kbGVPYmouc2VsZWN0b3IgKyBcIiBcIjtcblxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkU2VsZWN0b3JzWyBzZWwgXSA9IGhhbmRsZU9iai5uZWVkc0NvbnRleHQgP1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeSggc2VsLCB0aGlzICkuaW5kZXgoIGN1ciApID4gLTEgOlxuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5maW5kKCBzZWwsIHRoaXMsIG51bGwsIFsgY3VyIF0gKS5sZW5ndGg7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoIG1hdGNoZWRTZWxlY3RvcnNbIHNlbCBdICkge1xuXHRcdFx0XHRcdFx0XHRtYXRjaGVkSGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGlmICggbWF0Y2hlZEhhbmRsZXJzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZWRIYW5kbGVycyB9ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHRoZSByZW1haW5pbmcgKGRpcmVjdGx5LWJvdW5kKSBoYW5kbGVyc1xuXHRcdGN1ciA9IHRoaXM7XG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50IDwgaGFuZGxlcnMubGVuZ3RoICkge1xuXHRcdFx0aGFuZGxlclF1ZXVlLnB1c2goIHsgZWxlbTogY3VyLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHRhZGRQcm9wOiBmdW5jdGlvbiggbmFtZSwgaG9vayApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIGpRdWVyeS5FdmVudC5wcm90b3R5cGUsIG5hbWUsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cblx0XHRcdGdldDogaXNGdW5jdGlvbiggaG9vayApID9cblx0XHRcdFx0ZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0aWYgKCB0aGlzLm9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBob29rKCB0aGlzLm9yaWdpbmFsRXZlbnQgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gOlxuXHRcdFx0XHRmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRpZiAoIHRoaXMub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRoaXMub3JpZ2luYWxFdmVudFsgbmFtZSBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSxcblxuXHRcdFx0c2V0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eSggdGhpcywgbmFtZSwge1xuXHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHdyaXRhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdHZhbHVlOiB2YWx1ZVxuXHRcdFx0XHR9ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXG5cdGZpeDogZnVuY3Rpb24oIG9yaWdpbmFsRXZlbnQgKSB7XG5cdFx0cmV0dXJuIG9yaWdpbmFsRXZlbnRbIGpRdWVyeS5leHBhbmRvIF0gP1xuXHRcdFx0b3JpZ2luYWxFdmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCBvcmlnaW5hbEV2ZW50ICk7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGNsaWNrOiB7XG5cblx0XHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IHRvIGVuc3VyZSBjb3JyZWN0IHN0YXRlIGZvciBjaGVja2FibGUgaW5wdXRzXG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oIGRhdGEgKSB7XG5cblx0XHRcdFx0Ly8gRm9yIG11dHVhbCBjb21wcmVzc2liaWxpdHkgd2l0aCBfZGVmYXVsdCwgcmVwbGFjZSBgdGhpc2AgYWNjZXNzIHdpdGggYSBsb2NhbCB2YXIuXG5cdFx0XHRcdC8vIGB8fCBkYXRhYCBpcyBkZWFkIGNvZGUgbWVhbnQgb25seSB0byBwcmVzZXJ2ZSB0aGUgdmFyaWFibGUgdGhyb3VnaCBtaW5pZmljYXRpb24uXG5cdFx0XHRcdHZhciBlbCA9IHRoaXMgfHwgZGF0YTtcblxuXHRcdFx0XHQvLyBDbGFpbSB0aGUgZmlyc3QgaGFuZGxlclxuXHRcdFx0XHRpZiAoIHJjaGVja2FibGVUeXBlLnRlc3QoIGVsLnR5cGUgKSAmJlxuXHRcdFx0XHRcdGVsLmNsaWNrICYmIG5vZGVOYW1lKCBlbCwgXCJpbnB1dFwiICkgKSB7XG5cblx0XHRcdFx0XHQvLyBkYXRhUHJpdi5zZXQoIGVsLCBcImNsaWNrXCIsIC4uLiApXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIsIHJldHVyblRydWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0sXG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbiggZGF0YSApIHtcblxuXHRcdFx0XHQvLyBGb3IgbXV0dWFsIGNvbXByZXNzaWJpbGl0eSB3aXRoIF9kZWZhdWx0LCByZXBsYWNlIGB0aGlzYCBhY2Nlc3Mgd2l0aCBhIGxvY2FsIHZhci5cblx0XHRcdFx0Ly8gYHx8IGRhdGFgIGlzIGRlYWQgY29kZSBtZWFudCBvbmx5IHRvIHByZXNlcnZlIHRoZSB2YXJpYWJsZSB0aHJvdWdoIG1pbmlmaWNhdGlvbi5cblx0XHRcdFx0dmFyIGVsID0gdGhpcyB8fCBkYXRhO1xuXG5cdFx0XHRcdC8vIEZvcmNlIHNldHVwIGJlZm9yZSB0cmlnZ2VyaW5nIGEgY2xpY2tcblx0XHRcdFx0aWYgKCByY2hlY2thYmxlVHlwZS50ZXN0KCBlbC50eXBlICkgJiZcblx0XHRcdFx0XHRlbC5jbGljayAmJiBub2RlTmFtZSggZWwsIFwiaW5wdXRcIiApICkge1xuXG5cdFx0XHRcdFx0bGV2ZXJhZ2VOYXRpdmUoIGVsLCBcImNsaWNrXCIgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgc3VwcHJlc3MgbmF0aXZlIC5jbGljaygpIG9uIGxpbmtzXG5cdFx0XHQvLyBBbHNvIHByZXZlbnQgaXQgaWYgd2UncmUgY3VycmVudGx5IGluc2lkZSBhIGxldmVyYWdlZCBuYXRpdmUtZXZlbnQgc3RhY2tcblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG5cdFx0XHRcdHJldHVybiByY2hlY2thYmxlVHlwZS50ZXN0KCB0YXJnZXQudHlwZSApICYmXG5cdFx0XHRcdFx0dGFyZ2V0LmNsaWNrICYmIG5vZGVOYW1lKCB0YXJnZXQsIFwiaW5wdXRcIiApICYmXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCB0YXJnZXQsIFwiY2xpY2tcIiApIHx8XG5cdFx0XHRcdFx0bm9kZU5hbWUoIHRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG4vLyBFbnN1cmUgdGhlIHByZXNlbmNlIG9mIGFuIGV2ZW50IGxpc3RlbmVyIHRoYXQgaGFuZGxlcyBtYW51YWxseS10cmlnZ2VyZWRcbi8vIHN5bnRoZXRpYyBldmVudHMgYnkgaW50ZXJydXB0aW5nIHByb2dyZXNzIHVudGlsIHJlaW52b2tlZCBpbiByZXNwb25zZSB0b1xuLy8gKm5hdGl2ZSogZXZlbnRzIHRoYXQgaXQgZmlyZXMgZGlyZWN0bHksIGVuc3VyaW5nIHRoYXQgc3RhdGUgY2hhbmdlcyBoYXZlXG4vLyBhbHJlYWR5IG9jY3VycmVkIGJlZm9yZSBvdGhlciBsaXN0ZW5lcnMgYXJlIGludm9rZWQuXG5mdW5jdGlvbiBsZXZlcmFnZU5hdGl2ZSggZWwsIHR5cGUsIGV4cGVjdFN5bmMgKSB7XG5cblx0Ly8gTWlzc2luZyBleHBlY3RTeW5jIGluZGljYXRlcyBhIHRyaWdnZXIgY2FsbCwgd2hpY2ggbXVzdCBmb3JjZSBzZXR1cCB0aHJvdWdoIGpRdWVyeS5ldmVudC5hZGRcblx0aWYgKCAhZXhwZWN0U3luYyApIHtcblx0XHRpZiAoIGRhdGFQcml2LmdldCggZWwsIHR5cGUgKSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LmFkZCggZWwsIHR5cGUsIHJldHVyblRydWUgKTtcblx0XHR9XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gUmVnaXN0ZXIgdGhlIGNvbnRyb2xsZXIgYXMgYSBzcGVjaWFsIHVuaXZlcnNhbCBoYW5kbGVyIGZvciBhbGwgZXZlbnQgbmFtZXNwYWNlc1xuXHRkYXRhUHJpdi5zZXQoIGVsLCB0eXBlLCBmYWxzZSApO1xuXHRqUXVlcnkuZXZlbnQuYWRkKCBlbCwgdHlwZSwge1xuXHRcdG5hbWVzcGFjZTogZmFsc2UsXG5cdFx0aGFuZGxlcjogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIG5vdEFzeW5jLCByZXN1bHQsXG5cdFx0XHRcdHNhdmVkID0gZGF0YVByaXYuZ2V0KCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdGlmICggKCBldmVudC5pc1RyaWdnZXIgJiAxICkgJiYgdGhpc1sgdHlwZSBdICkge1xuXG5cdFx0XHRcdC8vIEludGVycnVwdCBwcm9jZXNzaW5nIG9mIHRoZSBvdXRlciBzeW50aGV0aWMgLnRyaWdnZXIoKWVkIGV2ZW50XG5cdFx0XHRcdC8vIFNhdmVkIGRhdGEgc2hvdWxkIGJlIGZhbHNlIGluIHN1Y2ggY2FzZXMsIGJ1dCBtaWdodCBiZSBhIGxlZnRvdmVyIGNhcHR1cmUgb2JqZWN0XG5cdFx0XHRcdC8vIGZyb20gYW4gYXN5bmMgbmF0aXZlIGhhbmRsZXIgKGdoLTQzNTApXG5cdFx0XHRcdGlmICggIXNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGFyZ3VtZW50cyBmb3IgdXNlIHdoZW4gaGFuZGxpbmcgdGhlIGlubmVyIG5hdGl2ZSBldmVudFxuXHRcdFx0XHRcdC8vIFRoZXJlIHdpbGwgYWx3YXlzIGJlIGF0IGxlYXN0IG9uZSBhcmd1bWVudCAoYW4gZXZlbnQgb2JqZWN0KSwgc28gdGhpcyBhcnJheVxuXHRcdFx0XHRcdC8vIHdpbGwgbm90IGJlIGNvbmZ1c2VkIHdpdGggYSBsZWZ0b3ZlciBjYXB0dXJlIG9iamVjdC5cblx0XHRcdFx0XHRzYXZlZCA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwgc2F2ZWQgKTtcblxuXHRcdFx0XHRcdC8vIFRyaWdnZXIgdGhlIG5hdGl2ZSBldmVudCBhbmQgY2FwdHVyZSBpdHMgcmVzdWx0XG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0Ly8gZm9jdXMoKSBhbmQgYmx1cigpIGFyZSBhc3luY2hyb25vdXNcblx0XHRcdFx0XHRub3RBc3luYyA9IGV4cGVjdFN5bmMoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHR0aGlzWyB0eXBlIF0oKTtcblx0XHRcdFx0XHRyZXN1bHQgPSBkYXRhUHJpdi5nZXQoIHRoaXMsIHR5cGUgKTtcblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgfHwgbm90QXN5bmMgKSB7XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIHR5cGUsIGZhbHNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlc3VsdCA9IHt9O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIHNhdmVkICE9PSByZXN1bHQgKSB7XG5cblx0XHRcdFx0XHRcdC8vIENhbmNlbCB0aGUgb3V0ZXIgc3ludGhldGljIGV2ZW50XG5cdFx0XHRcdFx0XHRldmVudC5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0LnZhbHVlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGlzIGlzIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCBmb3IgYW4gZXZlbnQgd2l0aCBhIGJ1YmJsaW5nIHN1cnJvZ2F0ZVxuXHRcdFx0XHQvLyAoZm9jdXMgb3IgYmx1ciksIGFzc3VtZSB0aGF0IHRoZSBzdXJyb2dhdGUgYWxyZWFkeSBwcm9wYWdhdGVkIGZyb20gdHJpZ2dlcmluZyB0aGVcblx0XHRcdFx0Ly8gbmF0aXZlIGV2ZW50IGFuZCBwcmV2ZW50IHRoYXQgZnJvbSBoYXBwZW5pbmcgYWdhaW4gaGVyZS5cblx0XHRcdFx0Ly8gVGhpcyB0ZWNobmljYWxseSBnZXRzIHRoZSBvcmRlcmluZyB3cm9uZyB3LnIudC4gdG8gYC50cmlnZ2VyKClgIChpbiB3aGljaCB0aGVcblx0XHRcdFx0Ly8gYnViYmxpbmcgc3Vycm9nYXRlIHByb3BhZ2F0ZXMgKmFmdGVyKiB0aGUgbm9uLWJ1YmJsaW5nIGJhc2UpLCBidXQgdGhhdCBzZWVtc1xuXHRcdFx0XHQvLyBsZXNzIGJhZCB0aGFuIGR1cGxpY2F0aW9uLlxuXHRcdFx0XHR9IGVsc2UgaWYgKCAoIGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge30gKS5kZWxlZ2F0ZVR5cGUgKSB7XG5cdFx0XHRcdFx0ZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIG5hdGl2ZSBldmVudCB0cmlnZ2VyZWQgYWJvdmUsIGV2ZXJ5dGhpbmcgaXMgbm93IGluIG9yZGVyXG5cdFx0XHQvLyBGaXJlIGFuIGlubmVyIHN5bnRoZXRpYyBldmVudCB3aXRoIHRoZSBvcmlnaW5hbCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHNhdmVkLmxlbmd0aCApIHtcblxuXHRcdFx0XHQvLyAuLi5hbmQgY2FwdHVyZSB0aGUgcmVzdWx0XG5cdFx0XHRcdGRhdGFQcml2LnNldCggdGhpcywgdHlwZSwge1xuXHRcdFx0XHRcdHZhbHVlOiBqUXVlcnkuZXZlbnQudHJpZ2dlcihcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTErXG5cdFx0XHRcdFx0XHQvLyBFeHRlbmQgd2l0aCB0aGUgcHJvdG90eXBlIHRvIHJlc2V0IHRoZSBhYm92ZSBzdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKVxuXHRcdFx0XHRcdFx0alF1ZXJ5LmV4dGVuZCggc2F2ZWRbIDAgXSwgalF1ZXJ5LkV2ZW50LnByb3RvdHlwZSApLFxuXHRcdFx0XHRcdFx0c2F2ZWQuc2xpY2UoIDEgKSxcblx0XHRcdFx0XHRcdHRoaXNcblx0XHRcdFx0XHQpXG5cdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBBYm9ydCBoYW5kbGluZyBvZiB0aGUgbmF0aXZlIGV2ZW50XG5cdFx0XHRcdGV2ZW50LnN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbigpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSApO1xufVxuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD0yLjMgb25seVxuXHRcdFx0XHRzcmMucmV0dXJuVmFsdWUgPT09IGZhbHNlID9cblx0XHRcdHJldHVyblRydWUgOlxuXHRcdFx0cmV0dXJuRmFsc2U7XG5cblx0XHQvLyBDcmVhdGUgdGFyZ2V0IHByb3BlcnRpZXNcblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgPD02IC0gNyBvbmx5XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHR0aGlzLnRhcmdldCA9ICggc3JjLnRhcmdldCAmJiBzcmMudGFyZ2V0Lm5vZGVUeXBlID09PSAzICkgP1xuXHRcdFx0c3JjLnRhcmdldC5wYXJlbnROb2RlIDpcblx0XHRcdHNyYy50YXJnZXQ7XG5cblx0XHR0aGlzLmN1cnJlbnRUYXJnZXQgPSBzcmMuY3VycmVudFRhcmdldDtcblx0XHR0aGlzLnJlbGF0ZWRUYXJnZXQgPSBzcmMucmVsYXRlZFRhcmdldDtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBEYXRlLm5vdygpO1xuXG5cdC8vIE1hcmsgaXQgYXMgZml4ZWRcblx0dGhpc1sgalF1ZXJ5LmV4cGFuZG8gXSA9IHRydWU7XG59O1xuXG4vLyBqUXVlcnkuRXZlbnQgaXMgYmFzZWQgb24gRE9NMyBFdmVudHMgYXMgc3BlY2lmaWVkIGJ5IHRoZSBFQ01BU2NyaXB0IExhbmd1YWdlIEJpbmRpbmdcbi8vIGh0dHBzOi8vd3d3LnczLm9yZy9UUi8yMDAzL1dELURPTS1MZXZlbC0zLUV2ZW50cy0yMDAzMDMzMS9lY21hLXNjcmlwdC1iaW5kaW5nLmh0bWxcbmpRdWVyeS5FdmVudC5wcm90b3R5cGUgPSB7XG5cdGNvbnN0cnVjdG9yOiBqUXVlcnkuRXZlbnQsXG5cdGlzRGVmYXVsdFByZXZlbnRlZDogcmV0dXJuRmFsc2UsXG5cdGlzUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblx0aXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQ6IHJldHVybkZhbHNlLFxuXHRpc1NpbXVsYXRlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc0RlZmF1bHRQcmV2ZW50ZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fSxcblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICYmICF0aGlzLmlzU2ltdWxhdGVkICkge1xuXHRcdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cdH0sXG5cdHN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkID0gcmV0dXJuVHJ1ZTtcblxuXHRcdGlmICggZSAmJiAhdGhpcy5pc1NpbXVsYXRlZCApIHtcblx0XHRcdGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5zdG9wUHJvcGFnYXRpb24oKTtcblx0fVxufTtcblxuLy8gSW5jbHVkZXMgYWxsIGNvbW1vbiBldmVudCBwcm9wcyBpbmNsdWRpbmcgS2V5RXZlbnQgYW5kIE1vdXNlRXZlbnQgc3BlY2lmaWMgcHJvcHNcbmpRdWVyeS5lYWNoKCB7XG5cdGFsdEtleTogdHJ1ZSxcblx0YnViYmxlczogdHJ1ZSxcblx0Y2FuY2VsYWJsZTogdHJ1ZSxcblx0Y2hhbmdlZFRvdWNoZXM6IHRydWUsXG5cdGN0cmxLZXk6IHRydWUsXG5cdGRldGFpbDogdHJ1ZSxcblx0ZXZlbnRQaGFzZTogdHJ1ZSxcblx0bWV0YUtleTogdHJ1ZSxcblx0cGFnZVg6IHRydWUsXG5cdHBhZ2VZOiB0cnVlLFxuXHRzaGlmdEtleTogdHJ1ZSxcblx0dmlldzogdHJ1ZSxcblx0XCJjaGFyXCI6IHRydWUsXG5cdGNvZGU6IHRydWUsXG5cdGNoYXJDb2RlOiB0cnVlLFxuXHRrZXk6IHRydWUsXG5cdGtleUNvZGU6IHRydWUsXG5cdGJ1dHRvbjogdHJ1ZSxcblx0YnV0dG9uczogdHJ1ZSxcblx0Y2xpZW50WDogdHJ1ZSxcblx0Y2xpZW50WTogdHJ1ZSxcblx0b2Zmc2V0WDogdHJ1ZSxcblx0b2Zmc2V0WTogdHJ1ZSxcblx0cG9pbnRlcklkOiB0cnVlLFxuXHRwb2ludGVyVHlwZTogdHJ1ZSxcblx0c2NyZWVuWDogdHJ1ZSxcblx0c2NyZWVuWTogdHJ1ZSxcblx0dGFyZ2V0VG91Y2hlczogdHJ1ZSxcblx0dG9FbGVtZW50OiB0cnVlLFxuXHR0b3VjaGVzOiB0cnVlLFxuXG5cdHdoaWNoOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0dmFyIGJ1dHRvbiA9IGV2ZW50LmJ1dHRvbjtcblxuXHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdGlmICggZXZlbnQud2hpY2ggPT0gbnVsbCAmJiBya2V5RXZlbnQudGVzdCggZXZlbnQudHlwZSApICkge1xuXHRcdFx0cmV0dXJuIGV2ZW50LmNoYXJDb2RlICE9IG51bGwgPyBldmVudC5jaGFyQ29kZSA6IGV2ZW50LmtleUNvZGU7XG5cdFx0fVxuXG5cdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICYmIHJtb3VzZUV2ZW50LnRlc3QoIGV2ZW50LnR5cGUgKSApIHtcblx0XHRcdGlmICggYnV0dG9uICYgMSApIHtcblx0XHRcdFx0cmV0dXJuIDE7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgMiApIHtcblx0XHRcdFx0cmV0dXJuIDM7XG5cdFx0XHR9XG5cblx0XHRcdGlmICggYnV0dG9uICYgNCApIHtcblx0XHRcdFx0cmV0dXJuIDI7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC53aGljaDtcblx0fVxufSwgalF1ZXJ5LmV2ZW50LmFkZFByb3AgKTtcblxualF1ZXJ5LmVhY2goIHsgZm9jdXM6IFwiZm9jdXNpblwiLCBibHVyOiBcImZvY3Vzb3V0XCIgfSwgZnVuY3Rpb24oIHR5cGUsIGRlbGVnYXRlVHlwZSApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIHR5cGUgXSA9IHtcblxuXHRcdC8vIFV0aWxpemUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdHNldHVwOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2xhaW0gdGhlIGZpcnN0IGhhbmRsZXJcblx0XHRcdC8vIGRhdGFQcml2LnNldCggdGhpcywgXCJmb2N1c1wiLCAuLi4gKVxuXHRcdFx0Ly8gZGF0YVByaXYuc2V0KCB0aGlzLCBcImJsdXJcIiwgLi4uIClcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlLCBleHBlY3RTeW5jICk7XG5cblx0XHRcdC8vIFJldHVybiBmYWxzZSB0byBhbGxvdyBub3JtYWwgcHJvY2Vzc2luZyBpbiB0aGUgY2FsbGVyXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRm9yY2Ugc2V0dXAgYmVmb3JlIHRyaWdnZXJcblx0XHRcdGxldmVyYWdlTmF0aXZlKCB0aGlzLCB0eXBlICk7XG5cblx0XHRcdC8vIFJldHVybiBub24tZmFsc2UgdG8gYWxsb3cgbm9ybWFsIGV2ZW50LXBhdGggcHJvcGFnYXRpb25cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0sXG5cblx0XHRkZWxlZ2F0ZVR5cGU6IGRlbGVnYXRlVHlwZVxuXHR9O1xufSApO1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDcwMjU4XG4vLyBmb3IgdGhlIGRlc2NyaXB0aW9uIG9mIHRoZSBidWcgKGl0IGV4aXN0ZWQgaW4gb2xkZXIgQ2hyb21lIHZlcnNpb25zIGFzIHdlbGwpLlxualF1ZXJ5LmVhY2goIHtcblx0bW91c2VlbnRlcjogXCJtb3VzZW92ZXJcIixcblx0bW91c2VsZWF2ZTogXCJtb3VzZW91dFwiLFxuXHRwb2ludGVyZW50ZXI6IFwicG9pbnRlcm92ZXJcIixcblx0cG9pbnRlcmxlYXZlOiBcInBvaW50ZXJvdXRcIlxufSwgZnVuY3Rpb24oIG9yaWcsIGZpeCApIHtcblx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIG9yaWcgXSA9IHtcblx0XHRkZWxlZ2F0ZVR5cGU6IGZpeCxcblx0XHRiaW5kVHlwZTogZml4LFxuXG5cdFx0aGFuZGxlOiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHR0YXJnZXQgPSB0aGlzLFxuXHRcdFx0XHRyZWxhdGVkID0gZXZlbnQucmVsYXRlZFRhcmdldCxcblx0XHRcdFx0aGFuZGxlT2JqID0gZXZlbnQuaGFuZGxlT2JqO1xuXG5cdFx0XHQvLyBGb3IgbW91c2VlbnRlci9sZWF2ZSBjYWxsIHRoZSBoYW5kbGVyIGlmIHJlbGF0ZWQgaXMgb3V0c2lkZSB0aGUgdGFyZ2V0LlxuXHRcdFx0Ly8gTkI6IE5vIHJlbGF0ZWRUYXJnZXQgaWYgdGhlIG1vdXNlIGxlZnQvZW50ZXJlZCB0aGUgYnJvd3NlciB3aW5kb3dcblx0XHRcdGlmICggIXJlbGF0ZWQgfHwgKCByZWxhdGVkICE9PSB0YXJnZXQgJiYgIWpRdWVyeS5jb250YWlucyggdGFyZ2V0LCByZWxhdGVkICkgKSApIHtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGhhbmRsZU9iai5vcmlnVHlwZTtcblx0XHRcdFx0cmV0ID0gaGFuZGxlT2JqLmhhbmRsZXIuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRldmVudC50eXBlID0gZml4O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRvbjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdG9uZTogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIG9uKCB0aGlzLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCAxICk7XG5cdH0sXG5cdG9mZjogZnVuY3Rpb24oIHR5cGVzLCBzZWxlY3RvciwgZm4gKSB7XG5cdFx0dmFyIGhhbmRsZU9iaiwgdHlwZTtcblx0XHRpZiAoIHR5cGVzICYmIHR5cGVzLnByZXZlbnREZWZhdWx0ICYmIHR5cGVzLmhhbmRsZU9iaiApIHtcblxuXHRcdFx0Ly8gKCBldmVudCApICBkaXNwYXRjaGVkIGpRdWVyeS5FdmVudFxuXHRcdFx0aGFuZGxlT2JqID0gdHlwZXMuaGFuZGxlT2JqO1xuXHRcdFx0alF1ZXJ5KCB0eXBlcy5kZWxlZ2F0ZVRhcmdldCApLm9mZihcblx0XHRcdFx0aGFuZGxlT2JqLm5hbWVzcGFjZSA/XG5cdFx0XHRcdFx0aGFuZGxlT2JqLm9yaWdUeXBlICsgXCIuXCIgKyBoYW5kbGVPYmoubmFtZXNwYWNlIDpcblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUsXG5cdFx0XHRcdGhhbmRsZU9iai5zZWxlY3Rvcixcblx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXJcblx0XHRcdCk7XG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHR9XG5cdFx0aWYgKCB0eXBlb2YgdHlwZXMgPT09IFwib2JqZWN0XCIgKSB7XG5cblx0XHRcdC8vICggdHlwZXMtb2JqZWN0IFssIHNlbGVjdG9yXSApXG5cdFx0XHRmb3IgKCB0eXBlIGluIHR5cGVzICkge1xuXHRcdFx0XHR0aGlzLm9mZiggdHlwZSwgc2VsZWN0b3IsIHR5cGVzWyB0eXBlIF0gKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHNlbGVjdG9yID09PSBmYWxzZSB8fCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwiZnVuY3Rpb25cIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcyBbLCBmbl0gKVxuXHRcdFx0Zm4gPSBzZWxlY3Rvcjtcblx0XHRcdHNlbGVjdG9yID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGZuID09PSBmYWxzZSApIHtcblx0XHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggdGhpcywgdHlwZXMsIGZuLCBzZWxlY3RvciApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbnZhclxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSwgRWRnZSAxMiAtIDEzIG9ubHlcblx0Ly8gSW4gSUUvRWRnZSB1c2luZyByZWdleCBncm91cHMgaGVyZSBjYXVzZXMgc2V2ZXJlIHNsb3dkb3ducy5cblx0Ly8gU2VlIGh0dHBzOi8vY29ubmVjdC5taWNyb3NvZnQuY29tL0lFL2ZlZWRiYWNrL2RldGFpbHMvMTczNjUxMi9cblx0cm5vSW5uZXJodG1sID0gLzxzY3JpcHR8PHN0eWxlfDxsaW5rL2ksXG5cblx0Ly8gY2hlY2tlZD1cImNoZWNrZWRcIiBvciBjaGVja2VkXG5cdHJjaGVja2VkID0gL2NoZWNrZWRcXHMqKD86W149XXw9XFxzKi5jaGVja2VkLikvaSxcblx0cmNsZWFuU2NyaXB0ID0gL15cXHMqPCEoPzpcXFtDREFUQVxcW3wtLSl8KD86XFxdXFxdfC0tKT5cXHMqJC9nO1xuXG4vLyBQcmVmZXIgYSB0Ym9keSBvdmVyIGl0cyBwYXJlbnQgdGFibGUgZm9yIGNvbnRhaW5pbmcgbmV3IHJvd3NcbmZ1bmN0aW9uIG1hbmlwdWxhdGlvblRhcmdldCggZWxlbSwgY29udGVudCApIHtcblx0aWYgKCBub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRub2RlTmFtZSggY29udGVudC5ub2RlVHlwZSAhPT0gMTEgPyBjb250ZW50IDogY29udGVudC5maXJzdENoaWxkLCBcInRyXCIgKSApIHtcblxuXHRcdHJldHVybiBqUXVlcnkoIGVsZW0gKS5jaGlsZHJlbiggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdGlmICggKCBlbGVtLnR5cGUgfHwgXCJcIiApLnNsaWNlKCAwLCA1ICkgPT09IFwidHJ1ZS9cIiApIHtcblx0XHRlbGVtLnR5cGUgPSBlbGVtLnR5cGUuc2xpY2UoIDUgKTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHVkYXRhT2xkLCB1ZGF0YUN1ciwgZXZlbnRzO1xuXG5cdGlmICggZGVzdC5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRyZXR1cm47XG5cdH1cblxuXHQvLyAxLiBDb3B5IHByaXZhdGUgZGF0YTogZXZlbnRzLCBoYW5kbGVycywgZXRjLlxuXHRpZiAoIGRhdGFQcml2Lmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHBkYXRhT2xkID0gZGF0YVByaXYuZ2V0KCBzcmMgKTtcblx0XHRldmVudHMgPSBwZGF0YU9sZC5ldmVudHM7XG5cblx0XHRpZiAoIGV2ZW50cyApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZGVzdCwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblxuXHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdGZvciAoIGkgPSAwLCBsID0gZXZlbnRzWyB0eXBlIF0ubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5hZGQoIGRlc3QsIHR5cGUsIGV2ZW50c1sgdHlwZSBdWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIDIuIENvcHkgdXNlciBkYXRhXG5cdGlmICggZGF0YVVzZXIuaGFzRGF0YSggc3JjICkgKSB7XG5cdFx0dWRhdGFPbGQgPSBkYXRhVXNlci5hY2Nlc3MoIHNyYyApO1xuXHRcdHVkYXRhQ3VyID0galF1ZXJ5LmV4dGVuZCgge30sIHVkYXRhT2xkICk7XG5cblx0XHRkYXRhVXNlci5zZXQoIGRlc3QsIHVkYXRhQ3VyICk7XG5cdH1cbn1cblxuLy8gRml4IElFIGJ1Z3MsIHNlZSBzdXBwb3J0IHRlc3RzXG5mdW5jdGlvbiBmaXhJbnB1dCggc3JjLCBkZXN0ICkge1xuXHR2YXIgbm9kZU5hbWUgPSBkZXN0Lm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0Ly8gRmFpbHMgdG8gcGVyc2lzdCB0aGUgY2hlY2tlZCBzdGF0ZSBvZiBhIGNsb25lZCBjaGVja2JveCBvciByYWRpbyBidXR0b24uXG5cdGlmICggbm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiByY2hlY2thYmxlVHlwZS50ZXN0KCBzcmMudHlwZSApICkge1xuXHRcdGRlc3QuY2hlY2tlZCA9IHNyYy5jaGVja2VkO1xuXG5cdC8vIEZhaWxzIHRvIHJldHVybiB0aGUgc2VsZWN0ZWQgb3B0aW9uIHRvIHRoZSBkZWZhdWx0IHNlbGVjdGVkIHN0YXRlIHdoZW4gY2xvbmluZyBvcHRpb25zXG5cdH0gZWxzZSBpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgfHwgbm9kZU5hbWUgPT09IFwidGV4dGFyZWFcIiApIHtcblx0XHRkZXN0LmRlZmF1bHRWYWx1ZSA9IHNyYy5kZWZhdWx0VmFsdWU7XG5cdH1cbn1cblxuZnVuY3Rpb24gZG9tTWFuaXAoIGNvbGxlY3Rpb24sIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICkge1xuXG5cdC8vIEZsYXR0ZW4gYW55IG5lc3RlZCBhcnJheXNcblx0YXJncyA9IGZsYXQoIGFyZ3MgKTtcblxuXHR2YXIgZnJhZ21lbnQsIGZpcnN0LCBzY3JpcHRzLCBoYXNTY3JpcHRzLCBub2RlLCBkb2MsXG5cdFx0aSA9IDAsXG5cdFx0bCA9IGNvbGxlY3Rpb24ubGVuZ3RoLFxuXHRcdGlOb0Nsb25lID0gbCAtIDEsXG5cdFx0dmFsdWUgPSBhcmdzWyAwIF0sXG5cdFx0dmFsdWVJc0Z1bmN0aW9uID0gaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCB2YWx1ZUlzRnVuY3Rpb24gfHxcblx0XHRcdCggbCA+IDEgJiYgdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzdXBwb3J0LmNoZWNrQ2xvbmUgJiYgcmNoZWNrZWQudGVzdCggdmFsdWUgKSApICkge1xuXHRcdHJldHVybiBjb2xsZWN0aW9uLmVhY2goIGZ1bmN0aW9uKCBpbmRleCApIHtcblx0XHRcdHZhciBzZWxmID0gY29sbGVjdGlvbi5lcSggaW5kZXggKTtcblx0XHRcdGlmICggdmFsdWVJc0Z1bmN0aW9uICkge1xuXHRcdFx0XHRhcmdzWyAwIF0gPSB2YWx1ZS5jYWxsKCB0aGlzLCBpbmRleCwgc2VsZi5odG1sKCkgKTtcblx0XHRcdH1cblx0XHRcdGRvbU1hbmlwKCBzZWxmLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApO1xuXHRcdH0gKTtcblx0fVxuXG5cdGlmICggbCApIHtcblx0XHRmcmFnbWVudCA9IGJ1aWxkRnJhZ21lbnQoIGFyZ3MsIGNvbGxlY3Rpb25bIDAgXS5vd25lckRvY3VtZW50LCBmYWxzZSwgY29sbGVjdGlvbiwgaWdub3JlZCApO1xuXHRcdGZpcnN0ID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdGlmICggZnJhZ21lbnQuY2hpbGROb2Rlcy5sZW5ndGggPT09IDEgKSB7XG5cdFx0XHRmcmFnbWVudCA9IGZpcnN0O1xuXHRcdH1cblxuXHRcdC8vIFJlcXVpcmUgZWl0aGVyIG5ldyBjb250ZW50IG9yIGFuIGludGVyZXN0IGluIGlnbm9yZWQgZWxlbWVudHMgdG8gaW52b2tlIHRoZSBjYWxsYmFja1xuXHRcdGlmICggZmlyc3QgfHwgaWdub3JlZCApIHtcblx0XHRcdHNjcmlwdHMgPSBqUXVlcnkubWFwKCBnZXRBbGwoIGZyYWdtZW50LCBcInNjcmlwdFwiICksIGRpc2FibGVTY3JpcHQgKTtcblx0XHRcdGhhc1NjcmlwdHMgPSBzY3JpcHRzLmxlbmd0aDtcblxuXHRcdFx0Ly8gVXNlIHRoZSBvcmlnaW5hbCBmcmFnbWVudCBmb3IgdGhlIGxhc3QgaXRlbVxuXHRcdFx0Ly8gaW5zdGVhZCBvZiB0aGUgZmlyc3QgYmVjYXVzZSBpdCBjYW4gZW5kIHVwXG5cdFx0XHQvLyBiZWluZyBlbXB0aWVkIGluY29ycmVjdGx5IGluIGNlcnRhaW4gc2l0dWF0aW9ucyAoIzgwNzApLlxuXHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRub2RlID0gZnJhZ21lbnQ7XG5cblx0XHRcdFx0aWYgKCBpICE9PSBpTm9DbG9uZSApIHtcblx0XHRcdFx0XHRub2RlID0galF1ZXJ5LmNsb25lKCBub2RlLCB0cnVlLCB0cnVlICk7XG5cblx0XHRcdFx0XHQvLyBLZWVwIHJlZmVyZW5jZXMgdG8gY2xvbmVkIHNjcmlwdHMgZm9yIGxhdGVyIHJlc3RvcmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4wIG9ubHksIFBoYW50b21KUyAxIG9ubHlcblx0XHRcdFx0XHRcdC8vIHB1c2guYXBwbHkoXywgYXJyYXlsaWtlKSB0aHJvd3Mgb24gYW5jaWVudCBXZWJLaXRcblx0XHRcdFx0XHRcdGpRdWVyeS5tZXJnZSggc2NyaXB0cywgZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjYWxsYmFjay5jYWxsKCBjb2xsZWN0aW9uWyBpIF0sIG5vZGUsIGkgKTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCBoYXNTY3JpcHRzICkge1xuXHRcdFx0XHRkb2MgPSBzY3JpcHRzWyBzY3JpcHRzLmxlbmd0aCAtIDEgXS5vd25lckRvY3VtZW50O1xuXG5cdFx0XHRcdC8vIFJlZW5hYmxlIHNjcmlwdHNcblx0XHRcdFx0alF1ZXJ5Lm1hcCggc2NyaXB0cywgcmVzdG9yZVNjcmlwdCApO1xuXG5cdFx0XHRcdC8vIEV2YWx1YXRlIGV4ZWN1dGFibGUgc2NyaXB0cyBvbiBmaXJzdCBkb2N1bWVudCBpbnNlcnRpb25cblx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBoYXNTY3JpcHRzOyBpKysgKSB7XG5cdFx0XHRcdFx0bm9kZSA9IHNjcmlwdHNbIGkgXTtcblx0XHRcdFx0XHRpZiAoIHJzY3JpcHRUeXBlLnRlc3QoIG5vZGUudHlwZSB8fCBcIlwiICkgJiZcblx0XHRcdFx0XHRcdCFkYXRhUHJpdi5hY2Nlc3MoIG5vZGUsIFwiZ2xvYmFsRXZhbFwiICkgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5jb250YWlucyggZG9jLCBub2RlICkgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbm9kZS5zcmMgJiYgKCBub2RlLnR5cGUgfHwgXCJcIiApLnRvTG93ZXJDYXNlKCkgICE9PSBcIm1vZHVsZVwiICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIE9wdGlvbmFsIEFKQVggZGVwZW5kZW5jeSwgYnV0IHdvbid0IHJ1biBzY3JpcHRzIGlmIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0XHRcdGlmICggalF1ZXJ5Ll9ldmFsVXJsICYmICFub2RlLm5vTW9kdWxlICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5fZXZhbFVybCggbm9kZS5zcmMsIHtcblx0XHRcdFx0XHRcdFx0XHRcdG5vbmNlOiBub2RlLm5vbmNlIHx8IG5vZGUuZ2V0QXR0cmlidXRlKCBcIm5vbmNlXCIgKVxuXHRcdFx0XHRcdFx0XHRcdH0sIGRvYyApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRET01FdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApLCBub2RlLCBkb2MgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY29sbGVjdGlvbjtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlKCBlbGVtLCBzZWxlY3Rvciwga2VlcERhdGEgKSB7XG5cdHZhciBub2RlLFxuXHRcdG5vZGVzID0gc2VsZWN0b3IgPyBqUXVlcnkuZmlsdGVyKCBzZWxlY3RvciwgZWxlbSApIDogZWxlbSxcblx0XHRpID0gMDtcblxuXHRmb3IgKCA7ICggbm9kZSA9IG5vZGVzWyBpIF0gKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0aWYgKCAha2VlcERhdGEgJiYgbm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggbm9kZSApICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBub2RlLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRpZiAoIGtlZXBEYXRhICYmIGlzQXR0YWNoZWQoIG5vZGUgKSApIHtcblx0XHRcdFx0c2V0R2xvYmFsRXZhbCggZ2V0QWxsKCBub2RlLCBcInNjcmlwdFwiICkgKTtcblx0XHRcdH1cblx0XHRcdG5vZGUucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggbm9kZSApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGh0bWxQcmVmaWx0ZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHJldHVybiBodG1sO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbiggZWxlbSwgZGF0YUFuZEV2ZW50cywgZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0dmFyIGksIGwsIHNyY0VsZW1lbnRzLCBkZXN0RWxlbWVudHMsXG5cdFx0XHRjbG9uZSA9IGVsZW0uY2xvbmVOb2RlKCB0cnVlICksXG5cdFx0XHRpblBhZ2UgPSBpc0F0dGFjaGVkKCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwczovL2pzcGVyZi5jb20vZ2V0YWxsLXZzLXNpenpsZS8yXG5cdFx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lICk7XG5cdFx0XHRzcmNFbGVtZW50cyA9IGdldEFsbCggZWxlbSApO1xuXG5cdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0Zml4SW5wdXQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ29weSB0aGUgZXZlbnRzIGZyb20gdGhlIG9yaWdpbmFsIHRvIHRoZSBjbG9uZVxuXHRcdGlmICggZGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdGlmICggZGVlcERhdGFBbmRFdmVudHMgKSB7XG5cdFx0XHRcdHNyY0VsZW1lbnRzID0gc3JjRWxlbWVudHMgfHwgZ2V0QWxsKCBlbGVtICk7XG5cdFx0XHRcdGRlc3RFbGVtZW50cyA9IGRlc3RFbGVtZW50cyB8fCBnZXRBbGwoIGNsb25lICk7XG5cblx0XHRcdFx0Zm9yICggaSA9IDAsIGwgPSBzcmNFbGVtZW50cy5sZW5ndGg7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIHNyY0VsZW1lbnRzWyBpIF0sIGRlc3RFbGVtZW50c1sgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGNsb25lQ29weUV2ZW50KCBlbGVtLCBjbG9uZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFByZXNlcnZlIHNjcmlwdCBldmFsdWF0aW9uIGhpc3Rvcnlcblx0XHRkZXN0RWxlbWVudHMgPSBnZXRBbGwoIGNsb25lLCBcInNjcmlwdFwiICk7XG5cdFx0aWYgKCBkZXN0RWxlbWVudHMubGVuZ3RoID4gMCApIHtcblx0XHRcdHNldEdsb2JhbEV2YWwoIGRlc3RFbGVtZW50cywgIWluUGFnZSAmJiBnZXRBbGwoIGVsZW0sIFwic2NyaXB0XCIgKSApO1xuXHRcdH1cblxuXHRcdC8vIFJldHVybiB0aGUgY2xvbmVkIHNldFxuXHRcdHJldHVybiBjbG9uZTtcblx0fSxcblxuXHRjbGVhbkRhdGE6IGZ1bmN0aW9uKCBlbGVtcyApIHtcblx0XHR2YXIgZGF0YSwgZWxlbSwgdHlwZSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbCxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyAoIGVsZW0gPSBlbGVtc1sgaSBdICkgIT09IHVuZGVmaW5lZDsgaSsrICkge1xuXHRcdFx0aWYgKCBhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cdFx0XHRcdGlmICggKCBkYXRhID0gZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdICkgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdGZvciAoIHR5cGUgaW4gZGF0YS5ldmVudHMgKSB7XG5cdFx0XHRcdFx0XHRcdGlmICggc3BlY2lhbFsgdHlwZSBdICkge1xuXHRcdFx0XHRcdFx0XHRcdGpRdWVyeS5ldmVudC5yZW1vdmUoIGVsZW0sIHR5cGUgKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBUaGlzIGlzIGEgc2hvcnRjdXQgdG8gYXZvaWQgalF1ZXJ5LmV2ZW50LnJlbW92ZSdzIG92ZXJoZWFkXG5cdFx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LnJlbW92ZUV2ZW50KCBlbGVtLCB0eXBlLCBkYXRhLmhhbmRsZSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9MzUgLSA0NStcblx0XHRcdFx0XHQvLyBBc3NpZ24gdW5kZWZpbmVkIGluc3RlYWQgb2YgdXNpbmcgZGVsZXRlLCBzZWUgRGF0YSNyZW1vdmVcblx0XHRcdFx0XHRlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCBlbGVtWyBkYXRhVXNlci5leHBhbmRvIF0gKSB7XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0zNSAtIDQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjAgb25seSwgUGhhbnRvbUpTIDEgb25seVxuXHRcdFx0Ly8gLmdldCgpIGJlY2F1c2UgcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0cHVzaC5hcHBseSggcmV0LCBlbGVtcy5nZXQoKSApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggcmV0ICk7XG5cdH07XG59ICk7XG52YXIgcm51bW5vbnB4ID0gbmV3IFJlZ0V4cCggXCJeKFwiICsgcG51bSArIFwiKSg/IXB4KVthLXolXSskXCIsIFwiaVwiICk7XG5cbnZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seSwgRmlyZWZveCA8PTMwICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcgfHwgIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suY2FsbCggZWxlbSApO1xuXG5cdC8vIFJldmVydCB0aGUgb2xkIHZhbHVlc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb2xkWyBuYW1lIF07XG5cdH1cblxuXHRyZXR1cm4gcmV0O1xufTtcblxuXG52YXIgcmJveFN0eWxlID0gbmV3IFJlZ0V4cCggY3NzRXhwYW5kLmpvaW4oIFwifFwiICksIFwiaVwiICk7XG5cblxuXG4oIGZ1bmN0aW9uKCkge1xuXG5cdC8vIEV4ZWN1dGluZyBib3RoIHBpeGVsUG9zaXRpb24gJiBib3hTaXppbmdSZWxpYWJsZSB0ZXN0cyByZXF1aXJlIG9ubHkgb25lIGxheW91dFxuXHQvLyBzbyB0aGV5J3JlIGV4ZWN1dGVkIGF0IHRoZSBzYW1lIHRpbWUgdG8gc2F2ZSB0aGUgc2Vjb25kIGNvbXB1dGF0aW9uLlxuXHRmdW5jdGlvbiBjb21wdXRlU3R5bGVUZXN0cygpIHtcblxuXHRcdC8vIFRoaXMgaXMgYSBzaW5nbGV0b24sIHdlIG5lZWQgdG8gZXhlY3V0ZSBpdCBvbmx5IG9uY2Vcblx0XHRpZiAoICFkaXYgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcInBvc2l0aW9uOmFic29sdXRlO2xlZnQ6LTExMTExcHg7d2lkdGg6NjBweDtcIiArXG5cdFx0XHRcIm1hcmdpbi10b3A6MXB4O3BhZGRpbmc6MDtib3JkZXI6MFwiO1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblx0XHRcdFwicG9zaXRpb246cmVsYXRpdmU7ZGlzcGxheTpibG9jaztib3gtc2l6aW5nOmJvcmRlci1ib3g7b3ZlcmZsb3c6c2Nyb2xsO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcIndpZHRoOjYwJTt0b3A6MSVcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApLmFwcGVuZENoaWxkKCBkaXYgKTtcblxuXHRcdHZhciBkaXZTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCBkaXYgKTtcblx0XHRwaXhlbFBvc2l0aW9uVmFsID0gZGl2U3R5bGUudG9wICE9PSBcIjElXCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5LCBGaXJlZm94IDw9MyAtIDQ0XG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0VmFsID0gcm91bmRQaXhlbE1lYXN1cmVzKCBkaXZTdHlsZS5tYXJnaW5MZWZ0ICkgPT09IDEyO1xuXG5cdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCA0LjAgLSA0LjMgb25seSwgU2FmYXJpIDw9OS4xIC0gMTAuMSwgaU9TIDw9Ny4wIC0gOS4zXG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLnJpZ2h0ID0gXCI2MCVcIjtcblx0XHRwaXhlbEJveFN0eWxlc1ZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUucmlnaHQgKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IC0gMTEgb25seVxuXHRcdC8vIERldGVjdCBtaXNyZXBvcnRpbmcgb2YgY29udGVudCBkaW1lbnNpb25zIGZvciBib3gtc2l6aW5nOmJvcmRlci1ib3ggZWxlbWVudHNcblx0XHRib3hTaXppbmdSZWxpYWJsZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2U3R5bGUud2lkdGggKSA9PT0gMzY7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHQvLyBEZXRlY3Qgb3ZlcmZsb3c6c2Nyb2xsIHNjcmV3aW5lc3MgKGdoLTM2OTkpXG5cdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9NjRcblx0XHQvLyBEb24ndCBnZXQgdHJpY2tlZCB3aGVuIHpvb20gYWZmZWN0cyBvZmZzZXRXaWR0aCAoZ2gtNDAyOSlcblx0XHRkaXYuc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG5cdFx0c2Nyb2xsYm94U2l6ZVZhbCA9IHJvdW5kUGl4ZWxNZWFzdXJlcyggZGl2Lm9mZnNldFdpZHRoIC8gMyApID09PSAxMjtcblxuXHRcdGRvY3VtZW50RWxlbWVudC5yZW1vdmVDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHQvLyBOdWxsaWZ5IHRoZSBkaXYgc28gaXQgd291bGRuJ3QgYmUgc3RvcmVkIGluIHRoZSBtZW1vcnkgYW5kXG5cdFx0Ly8gaXQgd2lsbCBhbHNvIGJlIGEgc2lnbiB0aGF0IGNoZWNrcyBhbHJlYWR5IHBlcmZvcm1lZFxuXHRcdGRpdiA9IG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiByb3VuZFBpeGVsTWVhc3VyZXMoIG1lYXN1cmUgKSB7XG5cdFx0cmV0dXJuIE1hdGgucm91bmQoIHBhcnNlRmxvYXQoIG1lYXN1cmUgKSApO1xuXHR9XG5cblx0dmFyIHBpeGVsUG9zaXRpb25WYWwsIGJveFNpemluZ1JlbGlhYmxlVmFsLCBzY3JvbGxib3hTaXplVmFsLCBwaXhlbEJveFN0eWxlc1ZhbCxcblx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdGJveFNpemluZ1JlbGlhYmxlOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gYm94U2l6aW5nUmVsaWFibGVWYWw7XG5cdFx0fSxcblx0XHRwaXhlbEJveFN0eWxlczogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsQm94U3R5bGVzVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0cmV0dXJuIHBpeGVsUG9zaXRpb25WYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRzY3JvbGxib3hTaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdGNvbXB1dGVTdHlsZVRlc3RzKCk7XG5cdFx0XHRyZXR1cm4gc2Nyb2xsYm94U2l6ZVZhbDtcblx0XHR9LFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgOSAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gQmVoYXZpb3IgaW4gSUUgOSBpcyBtb3JlIHN1YnRsZSB0aGFuIGluIG5ld2VyIHZlcnNpb25zICYgaXQgcGFzc2VzXG5cdFx0Ly8gc29tZSB2ZXJzaW9ucyBvZiB0aGlzIHRlc3Q7IG1ha2Ugc3VyZSBub3QgdG8gbWFrZSBpdCBwYXNzIHRoZXJlIVxuXHRcdHJlbGlhYmxlVHJEaW1lbnNpb25zOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0YWJsZSwgdHIsIHRyQ2hpbGQsIHRyU3R5bGU7XG5cdFx0XHRpZiAoIHJlbGlhYmxlVHJEaW1lbnNpb25zVmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHRhYmxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0YWJsZVwiICk7XG5cdFx0XHRcdHRyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJ0clwiICk7XG5cdFx0XHRcdHRyQ2hpbGQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0XHRcdFx0dGFibGUuc3R5bGUuY3NzVGV4dCA9IFwicG9zaXRpb246YWJzb2x1dGU7bGVmdDotMTExMTFweFwiO1xuXHRcdFx0XHR0ci5zdHlsZS5oZWlnaHQgPSBcIjFweFwiO1xuXHRcdFx0XHR0ckNoaWxkLnN0eWxlLmhlaWdodCA9IFwiOXB4XCI7XG5cblx0XHRcdFx0ZG9jdW1lbnRFbGVtZW50XG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0YWJsZSApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ciApXG5cdFx0XHRcdFx0LmFwcGVuZENoaWxkKCB0ckNoaWxkICk7XG5cblx0XHRcdFx0dHJTdHlsZSA9IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKCB0ciApO1xuXHRcdFx0XHRyZWxpYWJsZVRyRGltZW5zaW9uc1ZhbCA9IHBhcnNlSW50KCB0clN0eWxlLmhlaWdodCApID4gMztcblxuXHRcdFx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIHRhYmxlICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVsaWFibGVUckRpbWVuc2lvbnNWYWw7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveCA1MStcblx0XHQvLyBSZXRyaWV2aW5nIHN0eWxlIGJlZm9yZSBjb21wdXRlZCBzb21laG93XG5cdFx0Ly8gZml4ZXMgYW4gaXNzdWUgd2l0aCBnZXR0aW5nIHdyb25nIHZhbHVlc1xuXHRcdC8vIG9uIGRldGFjaGVkIGVsZW1lbnRzXG5cdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdGNvbXB1dGVkID0gY29tcHV0ZWQgfHwgZ2V0U3R5bGVzKCBlbGVtICk7XG5cblx0Ly8gZ2V0UHJvcGVydHlWYWx1ZSBpcyBuZWVkZWQgZm9yOlxuXHQvLyAgIC5jc3MoJ2ZpbHRlcicpIChJRSA5IG9ubHksICMxMjUzNylcblx0Ly8gICAuY3NzKCctLWN1c3RvbVByb3BlcnR5KSAoIzMxNDQpXG5cdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0cmV0ID0gY29tcHV0ZWQuZ2V0UHJvcGVydHlWYWx1ZSggbmFtZSApIHx8IGNvbXB1dGVkWyBuYW1lIF07XG5cblx0XHRpZiAoIHJldCA9PT0gXCJcIiAmJiAhaXNBdHRhY2hlZCggZWxlbSApICkge1xuXHRcdFx0cmV0ID0galF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gQSB0cmlidXRlIHRvIHRoZSBcImF3ZXNvbWUgaGFjayBieSBEZWFuIEVkd2FyZHNcIlxuXHRcdC8vIEFuZHJvaWQgQnJvd3NlciByZXR1cm5zIHBlcmNlbnRhZ2UgZm9yIHNvbWUgdmFsdWVzLFxuXHRcdC8vIGJ1dCB3aWR0aCBzZWVtcyB0byBiZSByZWxpYWJseSBwaXhlbHMuXG5cdFx0Ly8gVGhpcyBpcyBhZ2FpbnN0IHRoZSBDU1NPTSBkcmFmdCBzcGVjOlxuXHRcdC8vIGh0dHBzOi8vZHJhZnRzLmNzc3dnLm9yZy9jc3NvbS8jcmVzb2x2ZWQtdmFsdWVzXG5cdFx0aWYgKCAhc3VwcG9ydC5waXhlbEJveFN0eWxlcygpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiByYm94U3R5bGUudGVzdCggbmFtZSApICkge1xuXG5cdFx0XHQvLyBSZW1lbWJlciB0aGUgb3JpZ2luYWwgdmFsdWVzXG5cdFx0XHR3aWR0aCA9IHN0eWxlLndpZHRoO1xuXHRcdFx0bWluV2lkdGggPSBzdHlsZS5taW5XaWR0aDtcblx0XHRcdG1heFdpZHRoID0gc3R5bGUubWF4V2lkdGg7XG5cblx0XHRcdC8vIFB1dCBpbiB0aGUgbmV3IHZhbHVlcyB0byBnZXQgYSBjb21wdXRlZCB2YWx1ZSBvdXRcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gc3R5bGUubWF4V2lkdGggPSBzdHlsZS53aWR0aCA9IHJldDtcblx0XHRcdHJldCA9IGNvbXB1dGVkLndpZHRoO1xuXG5cdFx0XHQvLyBSZXZlcnQgdGhlIGNoYW5nZWQgdmFsdWVzXG5cdFx0XHRzdHlsZS53aWR0aCA9IHdpZHRoO1xuXHRcdFx0c3R5bGUubWluV2lkdGggPSBtaW5XaWR0aDtcblx0XHRcdHN0eWxlLm1heFdpZHRoID0gbWF4V2lkdGg7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHJldCAhPT0gdW5kZWZpbmVkID9cblxuXHRcdC8vIFN1cHBvcnQ6IElFIDw9OSAtIDExIG9ubHlcblx0XHQvLyBJRSByZXR1cm5zIHpJbmRleCB2YWx1ZSBhcyBhbiBpbnRlZ2VyLlxuXHRcdHJldCArIFwiXCIgOlxuXHRcdHJldDtcbn1cblxuXG5mdW5jdGlvbiBhZGRHZXRIb29rSWYoIGNvbmRpdGlvbkZuLCBob29rRm4gKSB7XG5cblx0Ly8gRGVmaW5lIHRoZSBob29rLCB3ZSdsbCBjaGVjayBvbiB0aGUgZmlyc3QgcnVuIGlmIGl0J3MgcmVhbGx5IG5lZWRlZC5cblx0cmV0dXJuIHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBjb25kaXRpb25GbigpICkge1xuXG5cdFx0XHRcdC8vIEhvb2sgbm90IG5lZWRlZCAob3IgaXQncyBub3QgcG9zc2libGUgdG8gdXNlIGl0IGR1ZVxuXHRcdFx0XHQvLyB0byBtaXNzaW5nIGRlcGVuZGVuY3kpLCByZW1vdmUgaXQuXG5cdFx0XHRcdGRlbGV0ZSB0aGlzLmdldDtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBIb29rIG5lZWRlZDsgcmVkZWZpbmUgaXQgc28gdGhhdCB0aGUgc3VwcG9ydCB0ZXN0IGlzIG5vdCBleGVjdXRlZCBhZ2Fpbi5cblx0XHRcdHJldHVybiAoIHRoaXMuZ2V0ID0gaG9va0ZuICkuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH1cblx0fTtcbn1cblxuXG52YXIgY3NzUHJlZml4ZXMgPSBbIFwiV2Via2l0XCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlLFxuXHR2ZW5kb3JQcm9wcyA9IHt9O1xuXG4vLyBSZXR1cm4gYSB2ZW5kb3ItcHJlZml4ZWQgcHJvcGVydHkgb3IgdW5kZWZpbmVkXG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBDaGVjayBmb3IgdmVuZG9yIHByZWZpeGVkIG5hbWVzXG5cdHZhciBjYXBOYW1lID0gbmFtZVsgMCBdLnRvVXBwZXJDYXNlKCkgKyBuYW1lLnNsaWNlKCAxICksXG5cdFx0aSA9IGNzc1ByZWZpeGVzLmxlbmd0aDtcblxuXHR3aGlsZSAoIGktLSApIHtcblx0XHRuYW1lID0gY3NzUHJlZml4ZXNbIGkgXSArIGNhcE5hbWU7XG5cdFx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0XHRyZXR1cm4gbmFtZTtcblx0XHR9XG5cdH1cbn1cblxuLy8gUmV0dXJuIGEgcG90ZW50aWFsbHktbWFwcGVkIGpRdWVyeS5jc3NQcm9wcyBvciB2ZW5kb3IgcHJlZml4ZWQgcHJvcGVydHlcbmZ1bmN0aW9uIGZpbmFsUHJvcE5hbWUoIG5hbWUgKSB7XG5cdHZhciBmaW5hbCA9IGpRdWVyeS5jc3NQcm9wc1sgbmFtZSBdIHx8IHZlbmRvclByb3BzWyBuYW1lIF07XG5cblx0aWYgKCBmaW5hbCApIHtcblx0XHRyZXR1cm4gZmluYWw7XG5cdH1cblx0aWYgKCBuYW1lIGluIGVtcHR5U3R5bGUgKSB7XG5cdFx0cmV0dXJuIG5hbWU7XG5cdH1cblx0cmV0dXJuIHZlbmRvclByb3BzWyBuYW1lIF0gPSB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHx8IG5hbWU7XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblx0cmN1c3RvbVByb3AgPSAvXi0tLyxcblx0Y3NzU2hvdyA9IHsgcG9zaXRpb246IFwiYWJzb2x1dGVcIiwgdmlzaWJpbGl0eTogXCJoaWRkZW5cIiwgZGlzcGxheTogXCJibG9ja1wiIH0sXG5cdGNzc05vcm1hbFRyYW5zZm9ybSA9IHtcblx0XHRsZXR0ZXJTcGFjaW5nOiBcIjBcIixcblx0XHRmb250V2VpZ2h0OiBcIjQwMFwiXG5cdH07XG5cbmZ1bmN0aW9uIHNldFBvc2l0aXZlTnVtYmVyKCBfZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBib3hNb2RlbEFkanVzdG1lbnQoIGVsZW0sIGRpbWVuc2lvbiwgYm94LCBpc0JvcmRlckJveCwgc3R5bGVzLCBjb21wdXRlZFZhbCApIHtcblx0dmFyIGkgPSBkaW1lbnNpb24gPT09IFwid2lkdGhcIiA/IDEgOiAwLFxuXHRcdGV4dHJhID0gMCxcblx0XHRkZWx0YSA9IDA7XG5cblx0Ly8gQWRqdXN0bWVudCBtYXkgbm90IGJlIG5lY2Vzc2FyeVxuXHRpZiAoIGJveCA9PT0gKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApICkge1xuXHRcdHJldHVybiAwO1xuXHR9XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luXG5cdFx0aWYgKCBib3ggPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHRkZWx0YSArPSBqUXVlcnkuY3NzKCBlbGVtLCBib3ggKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGNvbnRlbnQtYm94LCB3ZSdyZSBzZWVraW5nIFwicGFkZGluZ1wiIG9yIFwiYm9yZGVyXCIgb3IgXCJtYXJnaW5cIlxuXHRcdGlmICggIWlzQm9yZGVyQm94ICkge1xuXG5cdFx0XHQvLyBBZGQgcGFkZGluZ1xuXHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cblx0XHRcdC8vIEZvciBcImJvcmRlclwiIG9yIFwibWFyZ2luXCIsIGFkZCBib3JkZXJcblx0XHRcdGlmICggYm94ICE9PSBcInBhZGRpbmdcIiApIHtcblx0XHRcdFx0ZGVsdGEgKz0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQnV0IHN0aWxsIGtlZXAgdHJhY2sgb2YgaXQgb3RoZXJ3aXNlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleHRyYSArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0Ly8gSWYgd2UgZ2V0IGhlcmUgd2l0aCBhIGJvcmRlci1ib3ggKGNvbnRlbnQgKyBwYWRkaW5nICsgYm9yZGVyKSwgd2UncmUgc2Vla2luZyBcImNvbnRlbnRcIiBvclxuXHRcdC8vIFwicGFkZGluZ1wiIG9yIFwibWFyZ2luXCJcblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBGb3IgXCJjb250ZW50XCIsIHN1YnRyYWN0IHBhZGRpbmdcblx0XHRcdGlmICggYm94ID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJwYWRkaW5nXCIgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEZvciBcImNvbnRlbnRcIiBvciBcInBhZGRpbmdcIiwgc3VidHJhY3QgYm9yZGVyXG5cdFx0XHRpZiAoIGJveCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0ZGVsdGEgLT0galF1ZXJ5LmNzcyggZWxlbSwgXCJib3JkZXJcIiArIGNzc0V4cGFuZFsgaSBdICsgXCJXaWR0aFwiLCB0cnVlLCBzdHlsZXMgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBBY2NvdW50IGZvciBwb3NpdGl2ZSBjb250ZW50LWJveCBzY3JvbGwgZ3V0dGVyIHdoZW4gcmVxdWVzdGVkIGJ5IHByb3ZpZGluZyBjb21wdXRlZFZhbFxuXHRpZiAoICFpc0JvcmRlckJveCAmJiBjb21wdXRlZFZhbCA+PSAwICkge1xuXG5cdFx0Ly8gb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIGEgcm91bmRlZCBzdW0gb2YgY29udGVudCwgcGFkZGluZywgc2Nyb2xsIGd1dHRlciwgYW5kIGJvcmRlclxuXHRcdC8vIEFzc3VtaW5nIGludGVnZXIgc2Nyb2xsIGd1dHRlciwgc3VidHJhY3QgdGhlIHJlc3QgYW5kIHJvdW5kIGRvd25cblx0XHRkZWx0YSArPSBNYXRoLm1heCggMCwgTWF0aC5jZWlsKFxuXHRcdFx0ZWxlbVsgXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKSBdIC1cblx0XHRcdGNvbXB1dGVkVmFsIC1cblx0XHRcdGRlbHRhIC1cblx0XHRcdGV4dHJhIC1cblx0XHRcdDAuNVxuXG5cdFx0Ly8gSWYgb2Zmc2V0V2lkdGgvb2Zmc2V0SGVpZ2h0IGlzIHVua25vd24sIHRoZW4gd2UgY2FuJ3QgZGV0ZXJtaW5lIGNvbnRlbnQtYm94IHNjcm9sbCBndXR0ZXJcblx0XHQvLyBVc2UgYW4gZXhwbGljaXQgemVybyB0byBhdm9pZCBOYU4gKGdoLTM5NjQpXG5cdFx0KSApIHx8IDA7XG5cdH1cblxuXHRyZXR1cm4gZGVsdGE7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKSB7XG5cblx0Ly8gU3RhcnQgd2l0aCBjb21wdXRlZCBzdHlsZVxuXHR2YXIgc3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cblx0XHQvLyBUbyBhdm9pZCBmb3JjaW5nIGEgcmVmbG93LCBvbmx5IGZldGNoIGJveFNpemluZyBpZiB3ZSBuZWVkIGl0IChnaC00MzIyKS5cblx0XHQvLyBGYWtlIGNvbnRlbnQtYm94IHVudGlsIHdlIGtub3cgaXQncyBuZWVkZWQgdG8ga25vdyB0aGUgdHJ1ZSB2YWx1ZS5cblx0XHRib3hTaXppbmdOZWVkZWQgPSAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpIHx8IGV4dHJhLFxuXHRcdGlzQm9yZGVyQm94ID0gYm94U2l6aW5nTmVlZGVkICYmXG5cdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiLFxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCxcblxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgZGltZW5zaW9uLCBzdHlsZXMgKSxcblx0XHRvZmZzZXRQcm9wID0gXCJvZmZzZXRcIiArIGRpbWVuc2lvblsgMCBdLnRvVXBwZXJDYXNlKCkgKyBkaW1lbnNpb24uc2xpY2UoIDEgKTtcblxuXHQvLyBTdXBwb3J0OiBGaXJlZm94IDw9NTRcblx0Ly8gUmV0dXJuIGEgY29uZm91bmRpbmcgbm9uLXBpeGVsIHZhbHVlIG9yIGZlaWduIGlnbm9yYW5jZSwgYXMgYXBwcm9wcmlhdGUuXG5cdGlmICggcm51bW5vbnB4LnRlc3QoIHZhbCApICkge1xuXHRcdGlmICggIWV4dHJhICkge1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cdFx0dmFsID0gXCJhdXRvXCI7XG5cdH1cblxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIFVzZSBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgZm9yIHdoZW4gYm94IHNpemluZyBpcyB1bnJlbGlhYmxlLlxuXHQvLyBJbiB0aG9zZSBjYXNlcywgdGhlIGNvbXB1dGVkIHZhbHVlIGNhbiBiZSB0cnVzdGVkIHRvIGJlIGJvcmRlci1ib3guXG5cdGlmICggKCAhc3VwcG9ydC5ib3hTaXppbmdSZWxpYWJsZSgpICYmIGlzQm9yZGVyQm94IHx8XG5cblx0XHQvLyBTdXBwb3J0OiBJRSAxMCAtIDExKywgRWRnZSAxNSAtIDE4K1xuXHRcdC8vIElFL0VkZ2UgbWlzcmVwb3J0IGBnZXRDb21wdXRlZFN0eWxlYCBvZiB0YWJsZSByb3dzIHdpdGggd2lkdGgvaGVpZ2h0XG5cdFx0Ly8gc2V0IGluIENTUyB3aGlsZSBgb2Zmc2V0KmAgcHJvcGVydGllcyByZXBvcnQgY29ycmVjdCB2YWx1ZXMuXG5cdFx0Ly8gSW50ZXJlc3RpbmdseSwgaW4gc29tZSBjYXNlcyBJRSA5IGRvZXNuJ3Qgc3VmZmVyIGZyb20gdGhpcyBpc3N1ZS5cblx0XHQhc3VwcG9ydC5yZWxpYWJsZVRyRGltZW5zaW9ucygpICYmIG5vZGVOYW1lKCBlbGVtLCBcInRyXCIgKSB8fFxuXG5cdFx0Ly8gRmFsbCBiYWNrIHRvIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCB3aGVuIHZhbHVlIGlzIFwiYXV0b1wiXG5cdFx0Ly8gVGhpcyBoYXBwZW5zIGZvciBpbmxpbmUgZWxlbWVudHMgd2l0aCBubyBleHBsaWNpdCBzZXR0aW5nIChnaC0zNTcxKVxuXHRcdHZhbCA9PT0gXCJhdXRvXCIgfHxcblxuXHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgPD00LjEgLSA0LjMgb25seVxuXHRcdC8vIEFsc28gdXNlIG9mZnNldFdpZHRoL29mZnNldEhlaWdodCBmb3IgbWlzcmVwb3J0ZWQgaW5saW5lIGRpbWVuc2lvbnMgKGdoLTM2MDIpXG5cdFx0IXBhcnNlRmxvYXQoIHZhbCApICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiaW5saW5lXCIgKSAmJlxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoZSBlbGVtZW50IGlzIHZpc2libGUgJiBjb25uZWN0ZWRcblx0XHRlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdFx0Ly8gV2hlcmUgYXZhaWxhYmxlLCBvZmZzZXRXaWR0aC9vZmZzZXRIZWlnaHQgYXBwcm94aW1hdGUgYm9yZGVyIGJveCBkaW1lbnNpb25zLlxuXHRcdC8vIFdoZXJlIG5vdCBhdmFpbGFibGUgKGUuZy4sIFNWRyksIGFzc3VtZSB1bnJlbGlhYmxlIGJveC1zaXppbmcgYW5kIGludGVycHJldCB0aGVcblx0XHQvLyByZXRyaWV2ZWQgdmFsdWUgYXMgYSBjb250ZW50IGJveCBkaW1lbnNpb24uXG5cdFx0dmFsdWVJc0JvcmRlckJveCA9IG9mZnNldFByb3AgaW4gZWxlbTtcblx0XHRpZiAoIHZhbHVlSXNCb3JkZXJCb3ggKSB7XG5cdFx0XHR2YWwgPSBlbGVtWyBvZmZzZXRQcm9wIF07XG5cdFx0fVxuXHR9XG5cblx0Ly8gTm9ybWFsaXplIFwiXCIgYW5kIGF1dG9cblx0dmFsID0gcGFyc2VGbG9hdCggdmFsICkgfHwgMDtcblxuXHQvLyBBZGp1c3QgZm9yIHRoZSBlbGVtZW50J3MgYm94IG1vZGVsXG5cdHJldHVybiAoIHZhbCArXG5cdFx0Ym94TW9kZWxBZGp1c3RtZW50KFxuXHRcdFx0ZWxlbSxcblx0XHRcdGRpbWVuc2lvbixcblx0XHRcdGV4dHJhIHx8ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSxcblx0XHRcdHZhbHVlSXNCb3JkZXJCb3gsXG5cdFx0XHRzdHlsZXMsXG5cblx0XHRcdC8vIFByb3ZpZGUgdGhlIGN1cnJlbnQgY29tcHV0ZWQgc2l6ZSB0byByZXF1ZXN0IHNjcm9sbCBndXR0ZXIgY2FsY3VsYXRpb24gKGdoLTM1ODkpXG5cdFx0XHR2YWxcblx0XHQpXG5cdCkgKyBcInB4XCI7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImdyaWRBcmVhXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uRW5kXCI6IHRydWUsXG5cdFx0XCJncmlkQ29sdW1uU3RhcnRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dFbmRcIjogdHJ1ZSxcblx0XHRcImdyaWRSb3dTdGFydFwiOiB0cnVlLFxuXHRcdFwibGluZUhlaWdodFwiOiB0cnVlLFxuXHRcdFwib3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwib3JkZXJcIjogdHJ1ZSxcblx0XHRcIm9ycGhhbnNcIjogdHJ1ZSxcblx0XHRcIndpZG93c1wiOiB0cnVlLFxuXHRcdFwiekluZGV4XCI6IHRydWUsXG5cdFx0XCJ6b29tXCI6IHRydWVcblx0fSxcblxuXHQvLyBBZGQgaW4gcHJvcGVydGllcyB3aG9zZSBuYW1lcyB5b3Ugd2lzaCB0byBmaXggYmVmb3JlXG5cdC8vIHNldHRpbmcgb3IgZ2V0dGluZyB0aGUgdmFsdWVcblx0Y3NzUHJvcHM6IHt9LFxuXG5cdC8vIEdldCBhbmQgc2V0IHRoZSBzdHlsZSBwcm9wZXJ0eSBvbiBhIERPTSBOb2RlXG5cdHN0eWxlOiBmdW5jdGlvbiggZWxlbSwgbmFtZSwgdmFsdWUsIGV4dHJhICkge1xuXG5cdFx0Ly8gRG9uJ3Qgc2V0IHN0eWxlcyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCAhZWxlbSB8fCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggfHwgIWVsZW0uc3R5bGUgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lXG5cdFx0dmFyIHJldCwgdHlwZSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApLFxuXHRcdFx0c3R5bGUgPSBlbGVtLnN0eWxlO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gcXVlcnkgdGhlIHZhbHVlIGlmIGl0IGlzIGEgQ1NTIGN1c3RvbSBwcm9wZXJ0eVxuXHRcdC8vIHNpbmNlIHRoZXkgYXJlIHVzZXItZGVmaW5lZC5cblx0XHRpZiAoICFpc0N1c3RvbVByb3AgKSB7XG5cdFx0XHRuYW1lID0gZmluYWxQcm9wTmFtZSggb3JpZ05hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0Ly8gVGhlIGlzQ3VzdG9tUHJvcCBjaGVjayBjYW4gYmUgcmVtb3ZlZCBpbiBqUXVlcnkgNC4wIHdoZW4gd2Ugb25seSBhdXRvLWFwcGVuZFxuXHRcdFx0Ly8gXCJweFwiIHRvIGEgZmV3IGhhcmRjb2RlZCB2YWx1ZXMuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwibnVtYmVyXCIgJiYgIWlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0dmFsdWUgKz0gcmV0ICYmIHJldFsgMyBdIHx8ICggalF1ZXJ5LmNzc051bWJlclsgb3JpZ05hbWUgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gYmFja2dyb3VuZC0qIHByb3BzIGFmZmVjdCBvcmlnaW5hbCBjbG9uZSdzIHZhbHVlc1xuXHRcdFx0aWYgKCAhc3VwcG9ydC5jbGVhckNsb25lU3R5bGUgJiYgdmFsdWUgPT09IFwiXCIgJiYgbmFtZS5pbmRleE9mKCBcImJhY2tncm91bmRcIiApID09PSAwICkge1xuXHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gXCJpbmhlcml0XCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQsIHVzZSB0aGF0IHZhbHVlLCBvdGhlcndpc2UganVzdCBzZXQgdGhlIHNwZWNpZmllZCB2YWx1ZVxuXHRcdFx0aWYgKCAhaG9va3MgfHwgISggXCJzZXRcIiBpbiBob29rcyApIHx8XG5cdFx0XHRcdCggdmFsdWUgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBleHRyYSApICkgIT09IHVuZGVmaW5lZCApIHtcblxuXHRcdFx0XHRpZiAoIGlzQ3VzdG9tUHJvcCApIHtcblx0XHRcdFx0XHRzdHlsZS5zZXRQcm9wZXJ0eSggbmFtZSwgdmFsdWUgKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdHlsZVsgbmFtZSBdID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGNhbWVsQ2FzZSggbmFtZSApLFxuXHRcdFx0aXNDdXN0b21Qcm9wID0gcmN1c3RvbVByb3AudGVzdCggbmFtZSApO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHRoYXQgd2UncmUgd29ya2luZyB3aXRoIHRoZSByaWdodCBuYW1lLiBXZSBkb24ndFxuXHRcdC8vIHdhbnQgdG8gbW9kaWZ5IHRoZSB2YWx1ZSBpZiBpdCBpcyBhIENTUyBjdXN0b20gcHJvcGVydHlcblx0XHQvLyBzaW5jZSB0aGV5IGFyZSB1c2VyLWRlZmluZWQuXG5cdFx0aWYgKCAhaXNDdXN0b21Qcm9wICkge1xuXHRcdFx0bmFtZSA9IGZpbmFsUHJvcE5hbWUoIG9yaWdOYW1lICk7XG5cdFx0fVxuXG5cdFx0Ly8gVHJ5IHByZWZpeGVkIG5hbWUgZm9sbG93ZWQgYnkgdGhlIHVucHJlZml4ZWQgbmFtZVxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGZyb20gdGhlcmVcblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgKSB7XG5cdFx0XHR2YWwgPSBob29rcy5nZXQoIGVsZW0sIHRydWUsIGV4dHJhICk7XG5cdFx0fVxuXG5cdFx0Ly8gT3RoZXJ3aXNlLCBpZiBhIHdheSB0byBnZXQgdGhlIGNvbXB1dGVkIHZhbHVlIGV4aXN0cywgdXNlIHRoYXRcblx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dmFsID0gY3VyQ1NTKCBlbGVtLCBuYW1lLCBzdHlsZXMgKTtcblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IFwibm9ybWFsXCIgdG8gY29tcHV0ZWQgdmFsdWVcblx0XHRpZiAoIHZhbCA9PT0gXCJub3JtYWxcIiAmJiBuYW1lIGluIGNzc05vcm1hbFRyYW5zZm9ybSApIHtcblx0XHRcdHZhbCA9IGNzc05vcm1hbFRyYW5zZm9ybVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIE1ha2UgbnVtZXJpYyBpZiBmb3JjZWQgb3IgYSBxdWFsaWZpZXIgd2FzIHByb3ZpZGVkIGFuZCB2YWwgbG9va3MgbnVtZXJpY1xuXHRcdGlmICggZXh0cmEgPT09IFwiXCIgfHwgZXh0cmEgKSB7XG5cdFx0XHRudW0gPSBwYXJzZUZsb2F0KCB2YWwgKTtcblx0XHRcdHJldHVybiBleHRyYSA9PT0gdHJ1ZSB8fCBpc0Zpbml0ZSggbnVtICkgPyBudW0gfHwgMCA6IHZhbDtcblx0XHR9XG5cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCBbIFwiaGVpZ2h0XCIsIFwid2lkdGhcIiBdLCBmdW5jdGlvbiggX2ksIGRpbWVuc2lvbiApIHtcblx0alF1ZXJ5LmNzc0hvb2tzWyBkaW1lbnNpb24gXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogU2FmYXJpIDgrXG5cdFx0XHRcdFx0Ly8gVGFibGUgY29sdW1ucyBpbiBTYWZhcmkgaGF2ZSBub24temVybyBvZmZzZXRXaWR0aCAmIHplcm9cblx0XHRcdFx0XHQvLyBnZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCB1bmxlc3MgZGlzcGxheSBpcyBjaGFuZ2VkLlxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHRcdFx0XHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHRcdFx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0XHRcdFx0KCAhZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCB8fCAhZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS53aWR0aCApID9cblx0XHRcdFx0XHRcdHN3YXAoIGVsZW0sIGNzc1Nob3csIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZ2V0V2lkdGhPckhlaWdodCggZWxlbSwgZGltZW5zaW9uLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIGRpbWVuc2lvbiwgZXh0cmEgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIGV4dHJhICkge1xuXHRcdFx0dmFyIG1hdGNoZXMsXG5cdFx0XHRcdHN0eWxlcyA9IGdldFN0eWxlcyggZWxlbSApLFxuXG5cdFx0XHRcdC8vIE9ubHkgcmVhZCBzdHlsZXMucG9zaXRpb24gaWYgdGhlIHRlc3QgaGFzIGEgY2hhbmNlIHRvIGZhaWxcblx0XHRcdFx0Ly8gdG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdy5cblx0XHRcdFx0c2Nyb2xsYm94U2l6ZUJ1Z2d5ID0gIXN1cHBvcnQuc2Nyb2xsYm94U2l6ZSgpICYmXG5cdFx0XHRcdFx0c3R5bGVzLnBvc2l0aW9uID09PSBcImFic29sdXRlXCIsXG5cblx0XHRcdFx0Ly8gVG8gYXZvaWQgZm9yY2luZyBhIHJlZmxvdywgb25seSBmZXRjaCBib3hTaXppbmcgaWYgd2UgbmVlZCBpdCAoZ2gtMzk5MSlcblx0XHRcdFx0Ym94U2l6aW5nTmVlZGVkID0gc2Nyb2xsYm94U2l6ZUJ1Z2d5IHx8IGV4dHJhLFxuXHRcdFx0XHRpc0JvcmRlckJveCA9IGJveFNpemluZ05lZWRlZCAmJlxuXHRcdFx0XHRcdGpRdWVyeS5jc3MoIGVsZW0sIFwiYm94U2l6aW5nXCIsIGZhbHNlLCBzdHlsZXMgKSA9PT0gXCJib3JkZXItYm94XCIsXG5cdFx0XHRcdHN1YnRyYWN0ID0gZXh0cmEgP1xuXHRcdFx0XHRcdGJveE1vZGVsQWRqdXN0bWVudChcblx0XHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XHRkaW1lbnNpb24sXG5cdFx0XHRcdFx0XHRleHRyYSxcblx0XHRcdFx0XHRcdGlzQm9yZGVyQm94LFxuXHRcdFx0XHRcdFx0c3R5bGVzXG5cdFx0XHRcdFx0KSA6XG5cdFx0XHRcdFx0MDtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdW5yZWxpYWJsZSBib3JkZXItYm94IGRpbWVuc2lvbnMgYnkgY29tcGFyaW5nIG9mZnNldCogdG8gY29tcHV0ZWQgYW5kXG5cdFx0XHQvLyBmYWtpbmcgYSBjb250ZW50LWJveCB0byBnZXQgYm9yZGVyIGFuZCBwYWRkaW5nIChnaC0zNjk5KVxuXHRcdFx0aWYgKCBpc0JvcmRlckJveCAmJiBzY3JvbGxib3hTaXplQnVnZ3kgKSB7XG5cdFx0XHRcdHN1YnRyYWN0IC09IE1hdGguY2VpbChcblx0XHRcdFx0XHRlbGVtWyBcIm9mZnNldFwiICsgZGltZW5zaW9uWyAwIF0udG9VcHBlckNhc2UoKSArIGRpbWVuc2lvbi5zbGljZSggMSApIF0gLVxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoIHN0eWxlc1sgZGltZW5zaW9uIF0gKSAtXG5cdFx0XHRcdFx0Ym94TW9kZWxBZGp1c3RtZW50KCBlbGVtLCBkaW1lbnNpb24sIFwiYm9yZGVyXCIsIGZhbHNlLCBzdHlsZXMgKSAtXG5cdFx0XHRcdFx0MC41XG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgdG8gcGl4ZWxzIGlmIHZhbHVlIGFkanVzdG1lbnQgaXMgbmVlZGVkXG5cdFx0XHRpZiAoIHN1YnRyYWN0ICYmICggbWF0Y2hlcyA9IHJjc3NOdW0uZXhlYyggdmFsdWUgKSApICYmXG5cdFx0XHRcdCggbWF0Y2hlc1sgMyBdIHx8IFwicHhcIiApICE9PSBcInB4XCIgKSB7XG5cblx0XHRcdFx0ZWxlbS5zdHlsZVsgZGltZW5zaW9uIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBkaW1lbnNpb24gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHNldFBvc2l0aXZlTnVtYmVyKCBlbGVtLCB2YWx1ZSwgc3VidHJhY3QgKTtcblx0XHR9XG5cdH07XG59ICk7XG5cbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5MZWZ0ID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnJlbGlhYmxlTWFyZ2luTGVmdCxcblx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4gKCBwYXJzZUZsb2F0KCBjdXJDU1MoIGVsZW0sIFwibWFyZ2luTGVmdFwiICkgKSB8fFxuXHRcdFx0XHRlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQgLVxuXHRcdFx0XHRcdHN3YXAoIGVsZW0sIHsgbWFyZ2luTGVmdDogMCB9LCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLmxlZnQ7XG5cdFx0XHRcdFx0fSApXG5cdFx0XHRcdCkgKyBcInB4XCI7XG5cdFx0fVxuXHR9XG4pO1xuXG4vLyBUaGVzZSBob29rcyBhcmUgdXNlZCBieSBhbmltYXRlIHRvIGV4cGFuZCBwcm9wZXJ0aWVzXG5qUXVlcnkuZWFjaCgge1xuXHRtYXJnaW46IFwiXCIsXG5cdHBhZGRpbmc6IFwiXCIsXG5cdGJvcmRlcjogXCJXaWR0aFwiXG59LCBmdW5jdGlvbiggcHJlZml4LCBzdWZmaXggKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJlZml4ICsgc3VmZml4IF0gPSB7XG5cdFx0ZXhwYW5kOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgaSA9IDAsXG5cdFx0XHRcdGV4cGFuZGVkID0ge30sXG5cblx0XHRcdFx0Ly8gQXNzdW1lcyBhIHNpbmdsZSBudW1iZXIgaWYgbm90IGEgc3RyaW5nXG5cdFx0XHRcdHBhcnRzID0gdHlwZW9mIHZhbHVlID09PSBcInN0cmluZ1wiID8gdmFsdWUuc3BsaXQoIFwiIFwiICkgOiBbIHZhbHVlIF07XG5cblx0XHRcdGZvciAoIDsgaSA8IDQ7IGkrKyApIHtcblx0XHRcdFx0ZXhwYW5kZWRbIHByZWZpeCArIGNzc0V4cGFuZFsgaSBdICsgc3VmZml4IF0gPVxuXHRcdFx0XHRcdHBhcnRzWyBpIF0gfHwgcGFydHNbIGkgLSAyIF0gfHwgcGFydHNbIDAgXTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGV4cGFuZGVkO1xuXHRcdH1cblx0fTtcblxuXHRpZiAoIHByZWZpeCAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggQXJyYXkuaXNBcnJheSggbmFtZSApICkge1xuXHRcdFx0XHRzdHlsZXMgPSBnZXRTdHlsZXMoIGVsZW0gKTtcblx0XHRcdFx0bGVuID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdFx0bWFwWyBuYW1lWyBpIF0gXSA9IGpRdWVyeS5jc3MoIGVsZW0sIG5hbWVbIGkgXSwgZmFsc2UsIHN0eWxlcyApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIG1hcDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUsIHZhbHVlICkgOlxuXHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0fSwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoXG5cdFx0XHRcdFx0alF1ZXJ5LmNzc0hvb2tzWyB0d2Vlbi5wcm9wIF0gfHxcblx0XHRcdFx0XHR0d2Vlbi5lbGVtLnN0eWxlWyBmaW5hbFByb3BOYW1lKCB0d2Vlbi5wcm9wICkgXSAhPSBudWxsICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUUgPD05IG9ubHlcbi8vIFBhbmljIGJhc2VkIGFwcHJvYWNoIHRvIHNldHRpbmcgdGhpbmdzIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuVHdlZW4ucHJvcEhvb2tzLnNjcm9sbFRvcCA9IFR3ZWVuLnByb3BIb29rcy5zY3JvbGxMZWZ0ID0ge1xuXHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRpZiAoIHR3ZWVuLmVsZW0ubm9kZVR5cGUgJiYgdHdlZW4uZWxlbS5wYXJlbnROb2RlICkge1xuXHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmVhc2luZyA9IHtcblx0bGluZWFyOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gcDtcblx0fSxcblx0c3dpbmc6IGZ1bmN0aW9uKCBwICkge1xuXHRcdHJldHVybiAwLjUgLSBNYXRoLmNvcyggcCAqIE1hdGguUEkgKSAvIDI7XG5cdH0sXG5cdF9kZWZhdWx0OiBcInN3aW5nXCJcbn07XG5cbmpRdWVyeS5meCA9IFR3ZWVuLnByb3RvdHlwZS5pbml0O1xuXG4vLyBCYWNrIGNvbXBhdCA8MS44IGV4dGVuc2lvbiBwb2ludFxualF1ZXJ5LmZ4LnN0ZXAgPSB7fTtcblxuXG5cblxudmFyXG5cdGZ4Tm93LCBpblByb2dyZXNzLFxuXHRyZnh0eXBlcyA9IC9eKD86dG9nZ2xlfHNob3d8aGlkZSkkLyxcblx0cnJ1biA9IC9xdWV1ZUhvb2tzJC87XG5cbmZ1bmN0aW9uIHNjaGVkdWxlKCkge1xuXHRpZiAoIGluUHJvZ3Jlc3MgKSB7XG5cdFx0aWYgKCBkb2N1bWVudC5oaWRkZW4gPT09IGZhbHNlICYmIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgKSB7XG5cdFx0XHR3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCBzY2hlZHVsZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggc2NoZWR1bGUsIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHRcdH1cblxuXHRcdGpRdWVyeS5meC50aWNrKCk7XG5cdH1cbn1cblxuLy8gQW5pbWF0aW9ucyBjcmVhdGVkIHN5bmNocm9ub3VzbHkgd2lsbCBydW4gc3luY2hyb25vdXNseVxuZnVuY3Rpb24gY3JlYXRlRnhOb3coKSB7XG5cdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRmeE5vdyA9IHVuZGVmaW5lZDtcblx0fSApO1xuXHRyZXR1cm4gKCBmeE5vdyA9IERhdGUubm93KCkgKTtcbn1cblxuLy8gR2VuZXJhdGUgcGFyYW1ldGVycyB0byBjcmVhdGUgYSBzdGFuZGFyZCBhbmltYXRpb25cbmZ1bmN0aW9uIGdlbkZ4KCB0eXBlLCBpbmNsdWRlV2lkdGggKSB7XG5cdHZhciB3aGljaCxcblx0XHRpID0gMCxcblx0XHRhdHRycyA9IHsgaGVpZ2h0OiB0eXBlIH07XG5cblx0Ly8gSWYgd2UgaW5jbHVkZSB3aWR0aCwgc3RlcCB2YWx1ZSBpcyAxIHRvIGRvIGFsbCBjc3NFeHBhbmQgdmFsdWVzLFxuXHQvLyBvdGhlcndpc2Ugc3RlcCB2YWx1ZSBpcyAyIHRvIHNraXAgb3ZlciBMZWZ0IGFuZCBSaWdodFxuXHRpbmNsdWRlV2lkdGggPSBpbmNsdWRlV2lkdGggPyAxIDogMDtcblx0Zm9yICggOyBpIDwgNDsgaSArPSAyIC0gaW5jbHVkZVdpZHRoICkge1xuXHRcdHdoaWNoID0gY3NzRXhwYW5kWyBpIF07XG5cdFx0YXR0cnNbIFwibWFyZ2luXCIgKyB3aGljaCBdID0gYXR0cnNbIFwicGFkZGluZ1wiICsgd2hpY2ggXSA9IHR5cGU7XG5cdH1cblxuXHRpZiAoIGluY2x1ZGVXaWR0aCApIHtcblx0XHRhdHRycy5vcGFjaXR5ID0gYXR0cnMud2lkdGggPSB0eXBlO1xuXHR9XG5cblx0cmV0dXJuIGF0dHJzO1xufVxuXG5mdW5jdGlvbiBjcmVhdGVUd2VlbiggdmFsdWUsIHByb3AsIGFuaW1hdGlvbiApIHtcblx0dmFyIHR3ZWVuLFxuXHRcdGNvbGxlY3Rpb24gPSAoIEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdIHx8IFtdICkuY29uY2F0KCBBbmltYXRpb24udHdlZW5lcnNbIFwiKlwiIF0gKSxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGg7XG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0aWYgKCAoIHR3ZWVuID0gY29sbGVjdGlvblsgaW5kZXggXS5jYWxsKCBhbmltYXRpb24sIHByb3AsIHZhbHVlICkgKSApIHtcblxuXHRcdFx0Ly8gV2UncmUgZG9uZSB3aXRoIHRoaXMgcHJvcGVydHlcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gZGVmYXVsdFByZWZpbHRlciggZWxlbSwgcHJvcHMsIG9wdHMgKSB7XG5cdHZhciBwcm9wLCB2YWx1ZSwgdG9nZ2xlLCBob29rcywgb2xkZmlyZSwgcHJvcFR3ZWVuLCByZXN0b3JlRGlzcGxheSwgZGlzcGxheSxcblx0XHRpc0JveCA9IFwid2lkdGhcIiBpbiBwcm9wcyB8fCBcImhlaWdodFwiIGluIHByb3BzLFxuXHRcdGFuaW0gPSB0aGlzLFxuXHRcdG9yaWcgPSB7fSxcblx0XHRzdHlsZSA9IGVsZW0uc3R5bGUsXG5cdFx0aGlkZGVuID0gZWxlbS5ub2RlVHlwZSAmJiBpc0hpZGRlbldpdGhpblRyZWUoIGVsZW0gKSxcblx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJmeHNob3dcIiApO1xuXG5cdC8vIFF1ZXVlLXNraXBwaW5nIGFuaW1hdGlvbnMgaGlqYWNrIHRoZSBmeCBob29rc1xuXHRpZiAoICFvcHRzLnF1ZXVlICkge1xuXHRcdGhvb2tzID0galF1ZXJ5Ll9xdWV1ZUhvb2tzKCBlbGVtLCBcImZ4XCIgKTtcblx0XHRpZiAoIGhvb2tzLnVucXVldWVkID09IG51bGwgKSB7XG5cdFx0XHRob29rcy51bnF1ZXVlZCA9IDA7XG5cdFx0XHRvbGRmaXJlID0gaG9va3MuZW1wdHkuZmlyZTtcblx0XHRcdGhvb2tzLmVtcHR5LmZpcmUgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCAhaG9va3MudW5xdWV1ZWQgKSB7XG5cdFx0XHRcdFx0b2xkZmlyZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH1cblx0XHRob29rcy51bnF1ZXVlZCsrO1xuXG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBFbnN1cmUgdGhlIGNvbXBsZXRlIGhhbmRsZXIgaXMgY2FsbGVkIGJlZm9yZSB0aGlzIGNvbXBsZXRlc1xuXHRcdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRob29rcy51bnF1ZXVlZC0tO1xuXHRcdFx0XHRpZiAoICFqUXVlcnkucXVldWUoIGVsZW0sIFwiZnhcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHQvLyBEZXRlY3Qgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy50ZXN0KCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBQcmV0ZW5kIHRvIGJlIGhpZGRlbiBpZiB0aGlzIGlzIGEgXCJzaG93XCIgYW5kXG5cdFx0XHRcdC8vIHRoZXJlIGlzIHN0aWxsIGRhdGEgZnJvbSBhIHN0b3BwZWQgc2hvdy9oaWRlXG5cdFx0XHRcdGlmICggdmFsdWUgPT09IFwic2hvd1wiICYmIGRhdGFTaG93ICYmIGRhdGFTaG93WyBwcm9wIF0gIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRoaWRkZW4gPSB0cnVlO1xuXG5cdFx0XHRcdC8vIElnbm9yZSBhbGwgb3RoZXIgbm8tb3Agc2hvdy9oaWRlIGRhdGFcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBCYWlsIG91dCBpZiB0aGlzIGlzIGEgbm8tb3AgbGlrZSAuaGlkZSgpLmhpZGUoKVxuXHRwcm9wVHdlZW4gPSAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3BzICk7XG5cdGlmICggIXByb3BUd2VlbiAmJiBqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFJlc3RyaWN0IFwib3ZlcmZsb3dcIiBhbmQgXCJkaXNwbGF5XCIgc3R5bGVzIGR1cmluZyBib3ggYW5pbWF0aW9uc1xuXHRpZiAoIGlzQm94ICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cblx0XHQvLyBTdXBwb3J0OiBJRSA8PTkgLSAxMSwgRWRnZSAxMiAtIDE1XG5cdFx0Ly8gUmVjb3JkIGFsbCAzIG92ZXJmbG93IGF0dHJpYnV0ZXMgYmVjYXVzZSBJRSBkb2VzIG5vdCBpbmZlciB0aGUgc2hvcnRoYW5kXG5cdFx0Ly8gZnJvbSBpZGVudGljYWxseS12YWx1ZWQgb3ZlcmZsb3dYIGFuZCBvdmVyZmxvd1kgYW5kIEVkZ2UganVzdCBtaXJyb3JzXG5cdFx0Ly8gdGhlIG92ZXJmbG93WCB2YWx1ZSB0aGVyZS5cblx0XHRvcHRzLm92ZXJmbG93ID0gWyBzdHlsZS5vdmVyZmxvdywgc3R5bGUub3ZlcmZsb3dYLCBzdHlsZS5vdmVyZmxvd1kgXTtcblxuXHRcdC8vIElkZW50aWZ5IGEgZGlzcGxheSB0eXBlLCBwcmVmZXJyaW5nIG9sZCBzaG93L2hpZGUgZGF0YSBvdmVyIHRoZSBDU1MgY2FzY2FkZVxuXHRcdHJlc3RvcmVEaXNwbGF5ID0gZGF0YVNob3cgJiYgZGF0YVNob3cuZGlzcGxheTtcblx0XHRpZiAoIHJlc3RvcmVEaXNwbGF5ID09IG51bGwgKSB7XG5cdFx0XHRyZXN0b3JlRGlzcGxheSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJkaXNwbGF5XCIgKTtcblx0XHR9XG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cdFx0aWYgKCBkaXNwbGF5ID09PSBcIm5vbmVcIiApIHtcblx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgKSB7XG5cdFx0XHRcdGRpc3BsYXkgPSByZXN0b3JlRGlzcGxheTtcblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gR2V0IG5vbmVtcHR5IHZhbHVlKHMpIGJ5IHRlbXBvcmFyaWx5IGZvcmNpbmcgdmlzaWJpbGl0eVxuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0sIHRydWUgKTtcblx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBlbGVtLnN0eWxlLmRpc3BsYXkgfHwgcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdGRpc3BsYXkgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApO1xuXHRcdFx0XHRzaG93SGlkZSggWyBlbGVtIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBBbmltYXRlIGlubGluZSBlbGVtZW50cyBhcyBpbmxpbmUtYmxvY2tcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwiaW5saW5lXCIgfHwgZGlzcGxheSA9PT0gXCJpbmxpbmUtYmxvY2tcIiAmJiByZXN0b3JlRGlzcGxheSAhPSBudWxsICkge1xuXHRcdFx0aWYgKCBqUXVlcnkuY3NzKCBlbGVtLCBcImZsb2F0XCIgKSA9PT0gXCJub25lXCIgKSB7XG5cblx0XHRcdFx0Ly8gUmVzdG9yZSB0aGUgb3JpZ2luYWwgZGlzcGxheSB2YWx1ZSBhdCB0aGUgZW5kIG9mIHB1cmUgc2hvdy9oaWRlIGFuaW1hdGlvbnNcblx0XHRcdFx0aWYgKCAhcHJvcFR3ZWVuICkge1xuXHRcdFx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gcmVzdG9yZURpc3BsYXk7XG5cdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdGlmICggcmVzdG9yZURpc3BsYXkgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRcdGRpc3BsYXkgPSBzdHlsZS5kaXNwbGF5O1xuXHRcdFx0XHRcdFx0cmVzdG9yZURpc3BsYXkgPSBkaXNwbGF5ID09PSBcIm5vbmVcIiA/IFwiXCIgOiBkaXNwbGF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRzdHlsZS5kaXNwbGF5ID0gXCJpbmxpbmUtYmxvY2tcIjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRpZiAoIG9wdHMub3ZlcmZsb3cgKSB7XG5cdFx0c3R5bGUub3ZlcmZsb3cgPSBcImhpZGRlblwiO1xuXHRcdGFuaW0uYWx3YXlzKCBmdW5jdGlvbigpIHtcblx0XHRcdHN0eWxlLm92ZXJmbG93ID0gb3B0cy5vdmVyZmxvd1sgMCBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dYID0gb3B0cy5vdmVyZmxvd1sgMSBdO1xuXHRcdFx0c3R5bGUub3ZlcmZsb3dZID0gb3B0cy5vdmVyZmxvd1sgMiBdO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEltcGxlbWVudCBzaG93L2hpZGUgYW5pbWF0aW9uc1xuXHRwcm9wVHdlZW4gPSBmYWxzZTtcblx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXG5cdFx0Ly8gR2VuZXJhbCBzaG93L2hpZGUgc2V0dXAgZm9yIHRoaXMgZWxlbWVudCBhbmltYXRpb25cblx0XHRpZiAoICFwcm9wVHdlZW4gKSB7XG5cdFx0XHRpZiAoIGRhdGFTaG93ICkge1xuXHRcdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gZGF0YVNob3cuaGlkZGVuO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkYXRhU2hvdyA9IGRhdGFQcml2LmFjY2VzcyggZWxlbSwgXCJmeHNob3dcIiwgeyBkaXNwbGF5OiByZXN0b3JlRGlzcGxheSB9ICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0b3JlIGhpZGRlbi92aXNpYmxlIGZvciB0b2dnbGUgc28gYC5zdG9wKCkudG9nZ2xlKClgIFwicmV2ZXJzZXNcIlxuXHRcdFx0aWYgKCB0b2dnbGUgKSB7XG5cdFx0XHRcdGRhdGFTaG93LmhpZGRlbiA9ICFoaWRkZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNob3cgZWxlbWVudHMgYmVmb3JlIGFuaW1hdGluZyB0aGVtXG5cdFx0XHRpZiAoIGhpZGRlbiApIHtcblx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRhbmltLmRvbmUoIGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWxvb3AtZnVuYyAqL1xuXG5cdFx0XHRcdC8vIFRoZSBmaW5hbCBzdGVwIG9mIGEgXCJoaWRlXCIgYW5pbWF0aW9uIGlzIGFjdHVhbGx5IGhpZGluZyB0aGUgZWxlbWVudFxuXHRcdFx0XHRpZiAoICFoaWRkZW4gKSB7XG5cdFx0XHRcdFx0c2hvd0hpZGUoIFsgZWxlbSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBcImZ4c2hvd1wiICk7XG5cdFx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIG9yaWdbIHByb3AgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gUGVyLXByb3BlcnR5IHNldHVwXG5cdFx0cHJvcFR3ZWVuID0gY3JlYXRlVHdlZW4oIGhpZGRlbiA/IGRhdGFTaG93WyBwcm9wIF0gOiAwLCBwcm9wLCBhbmltICk7XG5cdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRkYXRhU2hvd1sgcHJvcCBdID0gcHJvcFR3ZWVuLnN0YXJ0O1xuXHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdHByb3BUd2Vlbi5lbmQgPSBwcm9wVHdlZW4uc3RhcnQ7XG5cdFx0XHRcdHByb3BUd2Vlbi5zdGFydCA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59XG5cbmZ1bmN0aW9uIHByb3BGaWx0ZXIoIHByb3BzLCBzcGVjaWFsRWFzaW5nICkge1xuXHR2YXIgaW5kZXgsIG5hbWUsIGVhc2luZywgdmFsdWUsIGhvb2tzO1xuXG5cdC8vIGNhbWVsQ2FzZSwgc3BlY2lhbEVhc2luZyBhbmQgZXhwYW5kIGNzc0hvb2sgcGFzc1xuXHRmb3IgKCBpbmRleCBpbiBwcm9wcyApIHtcblx0XHRuYW1lID0gY2FtZWxDYXNlKCBpbmRleCApO1xuXHRcdGVhc2luZyA9IHNwZWNpYWxFYXNpbmdbIG5hbWUgXTtcblx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdO1xuXHRcdGlmICggQXJyYXkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuMyBvbmx5XG5cdFx0XHRcdC8vIEFyY2hhaWMgY3Jhc2ggYnVnIHdvbid0IGFsbG93IHVzIHRvIHVzZSBgMSAtICggMC41IHx8IDAgKWAgKCMxMjQ5Nylcblx0XHRcdFx0dGVtcCA9IHJlbWFpbmluZyAvIGFuaW1hdGlvbi5kdXJhdGlvbiB8fCAwLFxuXHRcdFx0XHRwZXJjZW50ID0gMSAtIHRlbXAsXG5cdFx0XHRcdGluZGV4ID0gMCxcblx0XHRcdFx0bGVuZ3RoID0gYW5pbWF0aW9uLnR3ZWVucy5sZW5ndGg7XG5cblx0XHRcdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCBwZXJjZW50ICk7XG5cdFx0XHR9XG5cblx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBwZXJjZW50LCByZW1haW5pbmcgXSApO1xuXG5cdFx0XHQvLyBJZiB0aGVyZSdzIG1vcmUgdG8gZG8sIHlpZWxkXG5cdFx0XHRpZiAoIHBlcmNlbnQgPCAxICYmIGxlbmd0aCApIHtcblx0XHRcdFx0cmV0dXJuIHJlbWFpbmluZztcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgdGhpcyB3YXMgYW4gZW1wdHkgYW5pbWF0aW9uLCBzeW50aGVzaXplIGEgZmluYWwgcHJvZ3Jlc3Mgbm90aWZpY2F0aW9uXG5cdFx0XHRpZiAoICFsZW5ndGggKSB7XG5cdFx0XHRcdGRlZmVycmVkLm5vdGlmeVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCAxLCAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUmVzb2x2ZSB0aGUgYW5pbWF0aW9uIGFuZCByZXBvcnQgaXRzIGNvbmNsdXNpb25cblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiBdICk7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblx0XHRhbmltYXRpb24gPSBkZWZlcnJlZC5wcm9taXNlKCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0cHJvcHM6IGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wZXJ0aWVzICksXG5cdFx0XHRvcHRzOiBqUXVlcnkuZXh0ZW5kKCB0cnVlLCB7XG5cdFx0XHRcdHNwZWNpYWxFYXNpbmc6IHt9LFxuXHRcdFx0XHRlYXNpbmc6IGpRdWVyeS5lYXNpbmcuX2RlZmF1bHRcblx0XHRcdH0sIG9wdGlvbnMgKSxcblx0XHRcdG9yaWdpbmFsUHJvcGVydGllczogcHJvcGVydGllcyxcblx0XHRcdG9yaWdpbmFsT3B0aW9uczogb3B0aW9ucyxcblx0XHRcdHN0YXJ0VGltZTogZnhOb3cgfHwgY3JlYXRlRnhOb3coKSxcblx0XHRcdGR1cmF0aW9uOiBvcHRpb25zLmR1cmF0aW9uLFxuXHRcdFx0dHdlZW5zOiBbXSxcblx0XHRcdGNyZWF0ZVR3ZWVuOiBmdW5jdGlvbiggcHJvcCwgZW5kICkge1xuXHRcdFx0XHR2YXIgdHdlZW4gPSBqUXVlcnkuVHdlZW4oIGVsZW0sIGFuaW1hdGlvbi5vcHRzLCBwcm9wLCBlbmQsXG5cdFx0XHRcdFx0XHRhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nWyBwcm9wIF0gfHwgYW5pbWF0aW9uLm9wdHMuZWFzaW5nICk7XG5cdFx0XHRcdGFuaW1hdGlvbi50d2VlbnMucHVzaCggdHdlZW4gKTtcblx0XHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdFx0fSxcblx0XHRcdHN0b3A6IGZ1bmN0aW9uKCBnb3RvRW5kICkge1xuXHRcdFx0XHR2YXIgaW5kZXggPSAwLFxuXG5cdFx0XHRcdFx0Ly8gSWYgd2UgYXJlIGdvaW5nIHRvIHRoZSBlbmQsIHdlIHdhbnQgdG8gcnVuIGFsbCB0aGUgdHdlZW5zXG5cdFx0XHRcdFx0Ly8gb3RoZXJ3aXNlIHdlIHNraXAgdGhpcyBwYXJ0XG5cdFx0XHRcdFx0bGVuZ3RoID0gZ290b0VuZCA/IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoIDogMDtcblx0XHRcdFx0aWYgKCBzdG9wcGVkICkge1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHN0b3BwZWQgPSB0cnVlO1xuXHRcdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdFx0XHRcdGFuaW1hdGlvbi50d2VlbnNbIGluZGV4IF0ucnVuKCAxICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBSZXNvbHZlIHdoZW4gd2UgcGxheWVkIHRoZSBsYXN0IGZyYW1lOyBvdGhlcndpc2UsIHJlamVjdFxuXHRcdFx0XHRpZiAoIGdvdG9FbmQgKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIDEsIDAgXSApO1xuXHRcdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIGdvdG9FbmQgXSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fVxuXHRcdH0gKSxcblx0XHRwcm9wcyA9IGFuaW1hdGlvbi5wcm9wcztcblxuXHRwcm9wRmlsdGVyKCBwcm9wcywgYW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZyApO1xuXG5cdGZvciAoIDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggaXNGdW5jdGlvbiggcmVzdWx0LnN0b3AgKSApIHtcblx0XHRcdFx0alF1ZXJ5Ll9xdWV1ZUhvb2tzKCBhbmltYXRpb24uZWxlbSwgYW5pbWF0aW9uLm9wdHMucXVldWUgKS5zdG9wID1cblx0XHRcdFx0XHRyZXN1bHQuc3RvcC5iaW5kKCByZXN1bHQgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXN1bHQ7XG5cdFx0fVxuXHR9XG5cblx0alF1ZXJ5Lm1hcCggcHJvcHMsIGNyZWF0ZVR3ZWVuLCBhbmltYXRpb24gKTtcblxuXHRpZiAoIGlzRnVuY3Rpb24oIGFuaW1hdGlvbi5vcHRzLnN0YXJ0ICkgKSB7XG5cdFx0YW5pbWF0aW9uLm9wdHMuc3RhcnQuY2FsbCggZWxlbSwgYW5pbWF0aW9uICk7XG5cdH1cblxuXHQvLyBBdHRhY2ggY2FsbGJhY2tzIGZyb20gb3B0aW9uc1xuXHRhbmltYXRpb25cblx0XHQucHJvZ3Jlc3MoIGFuaW1hdGlvbi5vcHRzLnByb2dyZXNzIClcblx0XHQuZG9uZSggYW5pbWF0aW9uLm9wdHMuZG9uZSwgYW5pbWF0aW9uLm9wdHMuY29tcGxldGUgKVxuXHRcdC5mYWlsKCBhbmltYXRpb24ub3B0cy5mYWlsIClcblx0XHQuYWx3YXlzKCBhbmltYXRpb24ub3B0cy5hbHdheXMgKTtcblxuXHRqUXVlcnkuZngudGltZXIoXG5cdFx0alF1ZXJ5LmV4dGVuZCggdGljaywge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdGFuaW06IGFuaW1hdGlvbixcblx0XHRcdHF1ZXVlOiBhbmltYXRpb24ub3B0cy5xdWV1ZVxuXHRcdH0gKVxuXHQpO1xuXG5cdHJldHVybiBhbmltYXRpb247XG59XG5cbmpRdWVyeS5BbmltYXRpb24gPSBqUXVlcnkuZXh0ZW5kKCBBbmltYXRpb24sIHtcblxuXHR0d2VlbmVyczoge1xuXHRcdFwiKlwiOiBbIGZ1bmN0aW9uKCBwcm9wLCB2YWx1ZSApIHtcblx0XHRcdHZhciB0d2VlbiA9IHRoaXMuY3JlYXRlVHdlZW4oIHByb3AsIHZhbHVlICk7XG5cdFx0XHRhZGp1c3RDU1MoIHR3ZWVuLmVsZW0sIHByb3AsIHJjc3NOdW0uZXhlYyggdmFsdWUgKSwgdHdlZW4gKTtcblx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHR9IF1cblx0fSxcblxuXHR0d2VlbmVyOiBmdW5jdGlvbiggcHJvcHMsIGNhbGxiYWNrICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXHRcdH1cblxuXHRcdHZhciBwcm9wLFxuXHRcdFx0aW5kZXggPSAwLFxuXHRcdFx0bGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuXG5cdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0aXNGdW5jdGlvbiggc3BlZWQgKSAmJiBzcGVlZCxcblx0XHRkdXJhdGlvbjogc3BlZWQsXG5cdFx0ZWFzaW5nOiBmbiAmJiBlYXNpbmcgfHwgZWFzaW5nICYmICFpc0Z1bmN0aW9uKCBlYXNpbmcgKSAmJiBlYXNpbmdcblx0fTtcblxuXHQvLyBHbyB0byB0aGUgZW5kIHN0YXRlIGlmIGZ4IGFyZSBvZmZcblx0aWYgKCBqUXVlcnkuZngub2ZmICkge1xuXHRcdG9wdC5kdXJhdGlvbiA9IDA7XG5cblx0fSBlbHNlIHtcblx0XHRpZiAoIHR5cGVvZiBvcHQuZHVyYXRpb24gIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRpZiAoIG9wdC5kdXJhdGlvbiBpbiBqUXVlcnkuZnguc3BlZWRzICkge1xuXHRcdFx0XHRvcHQuZHVyYXRpb24gPSBqUXVlcnkuZnguc3BlZWRzWyBvcHQuZHVyYXRpb24gXTtcblxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b3B0LmR1cmF0aW9uID0galF1ZXJ5LmZ4LnNwZWVkcy5fZGVmYXVsdDtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyBOb3JtYWxpemUgb3B0LnF1ZXVlIC0gdHJ1ZS91bmRlZmluZWQvbnVsbCAtPiBcImZ4XCJcblx0aWYgKCBvcHQucXVldWUgPT0gbnVsbCB8fCBvcHQucXVldWUgPT09IHRydWUgKSB7XG5cdFx0b3B0LnF1ZXVlID0gXCJmeFwiO1xuXHR9XG5cblx0Ly8gUXVldWVpbmdcblx0b3B0Lm9sZCA9IG9wdC5jb21wbGV0ZTtcblxuXHRvcHQuY29tcGxldGUgPSBmdW5jdGlvbigpIHtcblx0XHRpZiAoIGlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuV2l0aGluVHJlZSApLmNzcyggXCJvcGFjaXR5XCIsIDAgKS5zaG93KClcblxuXHRcdFx0Ly8gQW5pbWF0ZSB0byB0aGUgdmFsdWUgc3BlY2lmaWVkXG5cdFx0XHQuZW5kKCkuYW5pbWF0ZSggeyBvcGFjaXR5OiB0byB9LCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApO1xuXHR9LFxuXHRhbmltYXRlOiBmdW5jdGlvbiggcHJvcCwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0dmFyIGVtcHR5ID0galF1ZXJ5LmlzRW1wdHlPYmplY3QoIHByb3AgKSxcblx0XHRcdG9wdGFsbCA9IGpRdWVyeS5zcGVlZCggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSxcblx0XHRcdGRvQW5pbWF0aW9uID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gT3BlcmF0ZSBvbiBhIGNvcHkgb2YgcHJvcCBzbyBwZXItcHJvcGVydHkgZWFzaW5nIHdvbid0IGJlIGxvc3Rcblx0XHRcdFx0dmFyIGFuaW0gPSBBbmltYXRpb24oIHRoaXMsIGpRdWVyeS5leHRlbmQoIHt9LCBwcm9wICksIG9wdGFsbCApO1xuXG5cdFx0XHRcdC8vIEVtcHR5IGFuaW1hdGlvbnMsIG9yIGZpbmlzaGluZyByZXNvbHZlcyBpbW1lZGlhdGVseVxuXHRcdFx0XHRpZiAoIGVtcHR5IHx8IGRhdGFQcml2LmdldCggdGhpcywgXCJmaW5pc2hcIiApICkge1xuXHRcdFx0XHRcdGFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdFx0ZG9BbmltYXRpb24uZmluaXNoID0gZG9BbmltYXRpb247XG5cblx0XHRyZXR1cm4gZW1wdHkgfHwgb3B0YWxsLnF1ZXVlID09PSBmYWxzZSA/XG5cdFx0XHR0aGlzLmVhY2goIGRvQW5pbWF0aW9uICkgOlxuXHRcdFx0dGhpcy5xdWV1ZSggb3B0YWxsLnF1ZXVlLCBkb0FuaW1hdGlvbiApO1xuXHR9LFxuXHRzdG9wOiBmdW5jdGlvbiggdHlwZSwgY2xlYXJRdWV1ZSwgZ290b0VuZCApIHtcblx0XHR2YXIgc3RvcFF1ZXVlID0gZnVuY3Rpb24oIGhvb2tzICkge1xuXHRcdFx0dmFyIHN0b3AgPSBob29rcy5zdG9wO1xuXHRcdFx0ZGVsZXRlIGhvb2tzLnN0b3A7XG5cdFx0XHRzdG9wKCBnb3RvRW5kICk7XG5cdFx0fTtcblxuXHRcdGlmICggdHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRnb3RvRW5kID0gY2xlYXJRdWV1ZTtcblx0XHRcdGNsZWFyUXVldWUgPSB0eXBlO1xuXHRcdFx0dHlwZSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKCBjbGVhclF1ZXVlICkge1xuXHRcdFx0dGhpcy5xdWV1ZSggdHlwZSB8fCBcImZ4XCIsIFtdICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZGVxdWV1ZSA9IHRydWUsXG5cdFx0XHRcdGluZGV4ID0gdHlwZSAhPSBudWxsICYmIHR5cGUgKyBcInF1ZXVlSG9va3NcIixcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApO1xuXG5cdFx0XHRpZiAoIGluZGV4ICkge1xuXHRcdFx0XHRpZiAoIGRhdGFbIGluZGV4IF0gJiYgZGF0YVsgaW5kZXggXS5zdG9wICkge1xuXHRcdFx0XHRcdHN0b3BRdWV1ZSggZGF0YVsgaW5kZXggXSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRmb3IgKCBpbmRleCBpbiBkYXRhICkge1xuXHRcdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgJiYgcnJ1bi50ZXN0KCBpbmRleCApICkge1xuXHRcdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGZvciAoIGluZGV4ID0gdGltZXJzLmxlbmd0aDsgaW5kZXgtLTsgKSB7XG5cdFx0XHRcdGlmICggdGltZXJzWyBpbmRleCBdLmVsZW0gPT09IHRoaXMgJiZcblx0XHRcdFx0XHQoIHR5cGUgPT0gbnVsbCB8fCB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSApIHtcblxuXHRcdFx0XHRcdHRpbWVyc1sgaW5kZXggXS5hbmltLnN0b3AoIGdvdG9FbmQgKTtcblx0XHRcdFx0XHRkZXF1ZXVlID0gZmFsc2U7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGFydCB0aGUgbmV4dCBpbiB0aGUgcXVldWUgaWYgdGhlIGxhc3Qgc3RlcCB3YXNuJ3QgZm9yY2VkLlxuXHRcdFx0Ly8gVGltZXJzIGN1cnJlbnRseSB3aWxsIGNhbGwgdGhlaXIgY29tcGxldGUgY2FsbGJhY2tzLCB3aGljaFxuXHRcdFx0Ly8gd2lsbCBkZXF1ZXVlIGJ1dCBvbmx5IGlmIHRoZXkgd2VyZSBnb3RvRW5kLlxuXHRcdFx0aWYgKCBkZXF1ZXVlIHx8ICFnb3RvRW5kICkge1xuXHRcdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblx0ZmluaXNoOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRpZiAoIHR5cGUgIT09IGZhbHNlICkge1xuXHRcdFx0dHlwZSA9IHR5cGUgfHwgXCJmeFwiO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBpbmRleCxcblx0XHRcdFx0ZGF0YSA9IGRhdGFQcml2LmdldCggdGhpcyApLFxuXHRcdFx0XHRxdWV1ZSA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlXCIgXSxcblx0XHRcdFx0aG9va3MgPSBkYXRhWyB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgXSxcblx0XHRcdFx0dGltZXJzID0galF1ZXJ5LnRpbWVycyxcblx0XHRcdFx0bGVuZ3RoID0gcXVldWUgPyBxdWV1ZS5sZW5ndGggOiAwO1xuXG5cdFx0XHQvLyBFbmFibGUgZmluaXNoaW5nIGZsYWcgb24gcHJpdmF0ZSBkYXRhXG5cdFx0XHRkYXRhLmZpbmlzaCA9IHRydWU7XG5cblx0XHRcdC8vIEVtcHR5IHRoZSBxdWV1ZSBmaXJzdFxuXHRcdFx0alF1ZXJ5LnF1ZXVlKCB0aGlzLCB0eXBlLCBbXSApO1xuXG5cdFx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnN0b3AgKSB7XG5cdFx0XHRcdGhvb2tzLnN0b3AuY2FsbCggdGhpcywgdHJ1ZSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYWN0aXZlIGFuaW1hdGlvbnMsIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJiB0aW1lcnNbIGluZGV4IF0ucXVldWUgPT09IHR5cGUgKSB7XG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggdHJ1ZSApO1xuXHRcdFx0XHRcdHRpbWVycy5zcGxpY2UoIGluZGV4LCAxICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gTG9vayBmb3IgYW55IGFuaW1hdGlvbnMgaW4gdGhlIG9sZCBxdWV1ZSBhbmQgZmluaXNoIHRoZW1cblx0XHRcdGZvciAoIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KysgKSB7XG5cdFx0XHRcdGlmICggcXVldWVbIGluZGV4IF0gJiYgcXVldWVbIGluZGV4IF0uZmluaXNoICkge1xuXHRcdFx0XHRcdHF1ZXVlWyBpbmRleCBdLmZpbmlzaC5jYWxsKCB0aGlzICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gVHVybiBvZmYgZmluaXNoaW5nIGZsYWdcblx0XHRcdGRlbGV0ZSBkYXRhLmZpbmlzaDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJ0b2dnbGVcIiwgXCJzaG93XCIsIFwiaGlkZVwiIF0sIGZ1bmN0aW9uKCBfaSwgbmFtZSApIHtcblx0dmFyIGNzc0ZuID0galF1ZXJ5LmZuWyBuYW1lIF07XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBzcGVlZCA9PSBudWxsIHx8IHR5cGVvZiBzcGVlZCA9PT0gXCJib29sZWFuXCIgP1xuXHRcdFx0Y3NzRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApIDpcblx0XHRcdHRoaXMuYW5pbWF0ZSggZ2VuRngoIG5hbWUsIHRydWUgKSwgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxuLy8gR2VuZXJhdGUgc2hvcnRjdXRzIGZvciBjdXN0b20gYW5pbWF0aW9uc1xualF1ZXJ5LmVhY2goIHtcblx0c2xpZGVEb3duOiBnZW5GeCggXCJzaG93XCIgKSxcblx0c2xpZGVVcDogZ2VuRngoIFwiaGlkZVwiICksXG5cdHNsaWRlVG9nZ2xlOiBnZW5GeCggXCJ0b2dnbGVcIiApLFxuXHRmYWRlSW46IHsgb3BhY2l0eTogXCJzaG93XCIgfSxcblx0ZmFkZU91dDogeyBvcGFjaXR5OiBcImhpZGVcIiB9LFxuXHRmYWRlVG9nZ2xlOiB7IG9wYWNpdHk6IFwidG9nZ2xlXCIgfVxufSwgZnVuY3Rpb24oIG5hbWUsIHByb3BzICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gdGhpcy5hbmltYXRlKCBwcm9wcywgc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LnRpbWVycyA9IFtdO1xualF1ZXJ5LmZ4LnRpY2sgPSBmdW5jdGlvbigpIHtcblx0dmFyIHRpbWVyLFxuXHRcdGkgPSAwLFxuXHRcdHRpbWVycyA9IGpRdWVyeS50aW1lcnM7XG5cblx0ZnhOb3cgPSBEYXRlLm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gUnVuIHRoZSB0aW1lciBhbmQgc2FmZWx5IHJlbW92ZSBpdCB3aGVuIGRvbmUgKGFsbG93aW5nIGZvciBleHRlcm5hbCByZW1vdmFsKVxuXHRcdGlmICggIXRpbWVyKCkgJiYgdGltZXJzWyBpIF0gPT09IHRpbWVyICkge1xuXHRcdFx0dGltZXJzLnNwbGljZSggaS0tLCAxICk7XG5cdFx0fVxuXHR9XG5cblx0aWYgKCAhdGltZXJzLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZnguc3RvcCgpO1xuXHR9XG5cdGZ4Tm93ID0gdW5kZWZpbmVkO1xufTtcblxualF1ZXJ5LmZ4LnRpbWVyID0gZnVuY3Rpb24oIHRpbWVyICkge1xuXHRqUXVlcnkudGltZXJzLnB1c2goIHRpbWVyICk7XG5cdGpRdWVyeS5meC5zdGFydCgpO1xufTtcblxualF1ZXJ5LmZ4LmludGVydmFsID0gMTM7XG5qUXVlcnkuZnguc3RhcnQgPSBmdW5jdGlvbigpIHtcblx0aWYgKCBpblByb2dyZXNzICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGluUHJvZ3Jlc3MgPSB0cnVlO1xuXHRzY2hlZHVsZSgpO1xufTtcblxualF1ZXJ5LmZ4LnN0b3AgPSBmdW5jdGlvbigpIHtcblx0aW5Qcm9ncmVzcyA9IG51bGw7XG59O1xuXG5qUXVlcnkuZnguc3BlZWRzID0ge1xuXHRzbG93OiA2MDAsXG5cdGZhc3Q6IDIwMCxcblxuXHQvLyBEZWZhdWx0IHNwZWVkXG5cdF9kZWZhdWx0OiA0MDBcbn07XG5cblxuLy8gQmFzZWQgb2ZmIG9mIHRoZSBwbHVnaW4gYnkgQ2xpbnQgSGVsZmVycywgd2l0aCBwZXJtaXNzaW9uLlxuLy8gaHR0cHM6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDw9NC4zIG9ubHlcblx0Ly8gRGVmYXVsdCB2YWx1ZSBmb3IgYSBjaGVja2JveCBzaG91bGQgYmUgXCJvblwiXG5cdHN1cHBvcnQuY2hlY2tPbiA9IGlucHV0LnZhbHVlICE9PSBcIlwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQXR0cmlidXRlIGhvb2tzIGFyZSBkZXRlcm1pbmVkIGJ5IHRoZSBsb3dlcmNhc2UgdmVyc2lvblxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdGhvb2tzID0galF1ZXJ5LmF0dHJIb29rc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gfHxcblx0XHRcdFx0KCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSA/IGJvb2xIb29rIDogdW5kZWZpbmVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gbnVsbCApIHtcblx0XHRcdFx0alF1ZXJ5LnJlbW92ZUF0dHIoIGVsZW0sIG5hbWUgKTtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgdmFsdWUgKyBcIlwiICk7XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fVxuXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmICggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBuYW1lICkgKSAhPT0gbnVsbCApIHtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXG5cdFx0cmV0ID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgbmFtZSApO1xuXG5cdFx0Ly8gTm9uLWV4aXN0ZW50IGF0dHJpYnV0ZXMgcmV0dXJuIG51bGwsIHdlIG5vcm1hbGl6ZSB0byB1bmRlZmluZWRcblx0XHRyZXR1cm4gcmV0ID09IG51bGwgPyB1bmRlZmluZWQgOiByZXQ7XG5cdH0sXG5cblx0YXR0ckhvb2tzOiB7XG5cdFx0dHlwZToge1xuXHRcdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggIXN1cHBvcnQucmFkaW9WYWx1ZSAmJiB2YWx1ZSA9PT0gXCJyYWRpb1wiICYmXG5cdFx0XHRcdFx0bm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsXG5cdFx0XHRpID0gMCxcblxuXHRcdFx0Ly8gQXR0cmlidXRlIG5hbWVzIGNhbiBjb250YWluIG5vbi1IVE1MIHdoaXRlc3BhY2UgY2hhcmFjdGVyc1xuXHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy9tdWx0aXBhZ2Uvc3ludGF4Lmh0bWwjYXR0cmlidXRlcy0yXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApO1xuXG5cdFx0aWYgKCBhdHRyTmFtZXMgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdHdoaWxlICggKCBuYW1lID0gYXR0ck5hbWVzWyBpKysgXSApICkge1xuXHRcdFx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggbmFtZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG4vLyBIb29rcyBmb3IgYm9vbGVhbiBhdHRyaWJ1dGVzXG5ib29sSG9vayA9IHtcblx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUsIG5hbWUgKSB7XG5cdFx0aWYgKCB2YWx1ZSA9PT0gZmFsc2UgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBib29sZWFuIGF0dHJpYnV0ZXMgd2hlbiBzZXQgdG8gZmFsc2Vcblx0XHRcdGpRdWVyeS5yZW1vdmVBdHRyKCBlbGVtLCBuYW1lICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lICk7XG5cdFx0fVxuXHRcdHJldHVybiBuYW1lO1xuXHR9XG59O1xuXG5qUXVlcnkuZWFjaCggalF1ZXJ5LmV4cHIubWF0Y2guYm9vbC5zb3VyY2UubWF0Y2goIC9cXHcrL2cgKSwgZnVuY3Rpb24oIF9pLCBuYW1lICkge1xuXHR2YXIgZ2V0dGVyID0gYXR0ckhhbmRsZVsgbmFtZSBdIHx8IGpRdWVyeS5maW5kLmF0dHI7XG5cblx0YXR0ckhhbmRsZVsgbmFtZSBdID0gZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciByZXQsIGhhbmRsZSxcblx0XHRcdGxvd2VyY2FzZU5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cblx0XHRpZiAoICFpc1hNTCApIHtcblxuXHRcdFx0Ly8gQXZvaWQgYW4gaW5maW5pdGUgbG9vcCBieSB0ZW1wb3JhcmlseSByZW1vdmluZyB0aGlzIGZ1bmN0aW9uIGZyb20gdGhlIGdldHRlclxuXHRcdFx0aGFuZGxlID0gYXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdO1xuXHRcdFx0YXR0ckhhbmRsZVsgbG93ZXJjYXNlTmFtZSBdID0gcmV0O1xuXHRcdFx0cmV0ID0gZ2V0dGVyKCBlbGVtLCBuYW1lLCBpc1hNTCApICE9IG51bGwgP1xuXHRcdFx0XHRsb3dlcmNhc2VOYW1lIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIGxvd2VyY2FzZU5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IC0gMTEgb25seVxuXHRcdFx0XHQvLyBlbGVtLnRhYkluZGV4IGRvZXNuJ3QgYWx3YXlzIHJldHVybiB0aGVcblx0XHRcdFx0Ly8gY29ycmVjdCB2YWx1ZSB3aGVuIGl0IGhhc24ndCBiZWVuIGV4cGxpY2l0bHkgc2V0XG5cdFx0XHRcdC8vIGh0dHBzOi8vd2ViLmFyY2hpdmUub3JnL3dlYi8yMDE0MTExNjIzMzM0Ny9odHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRpZiAoIHRhYmluZGV4ICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXJzZUludCggdGFiaW5kZXgsIDEwICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoXG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRyY2xpY2thYmxlLnRlc3QoIGVsZW0ubm9kZU5hbWUgKSAmJlxuXHRcdFx0XHRcdGVsZW0uaHJlZlxuXHRcdFx0XHQpIHtcblx0XHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiAtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbi8vIFN1cHBvcnQ6IElFIDw9MTEgb25seVxuLy8gQWNjZXNzaW5nIHRoZSBzZWxlY3RlZEluZGV4IHByb3BlcnR5XG4vLyBmb3JjZXMgdGhlIGJyb3dzZXIgdG8gcmVzcGVjdCBzZXR0aW5nIHNlbGVjdGVkXG4vLyBvbiB0aGUgb3B0aW9uXG4vLyBUaGUgZ2V0dGVyIGVuc3VyZXMgYSBkZWZhdWx0IG9wdGlvbiBpcyBzZWxlY3RlZFxuLy8gd2hlbiBpbiBhbiBvcHRncm91cFxuLy8gZXNsaW50IHJ1bGUgXCJuby11bnVzZWQtZXhwcmVzc2lvbnNcIiBpcyBkaXNhYmxlZCBmb3IgdGhpcyBjb2RlXG4vLyBzaW5jZSBpdCBjb25zaWRlcnMgc3VjaCBhY2Nlc3Npb25zIG5vb3BcbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0LyogZXNsaW50IG5vLXVudXNlZC1leHByZXNzaW9uczogXCJvZmZcIiAqL1xuXG5cdFx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0aWYgKCBwYXJlbnQgJiYgcGFyZW50LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9LFxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdC8qIGVzbGludCBuby11bnVzZWQtZXhwcmVzc2lvbnM6IFwib2ZmXCIgKi9cblxuXHRcdFx0dmFyIHBhcmVudCA9IGVsZW0ucGFyZW50Tm9kZTtcblx0XHRcdGlmICggcGFyZW50ICkge1xuXHRcdFx0XHRwYXJlbnQuc2VsZWN0ZWRJbmRleDtcblxuXHRcdFx0XHRpZiAoIHBhcmVudC5wYXJlbnROb2RlICkge1xuXHRcdFx0XHRcdHBhcmVudC5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbmpRdWVyeS5lYWNoKCBbXG5cdFwidGFiSW5kZXhcIixcblx0XCJyZWFkT25seVwiLFxuXHRcIm1heExlbmd0aFwiLFxuXHRcImNlbGxTcGFjaW5nXCIsXG5cdFwiY2VsbFBhZGRpbmdcIixcblx0XCJyb3dTcGFuXCIsXG5cdFwiY29sU3BhblwiLFxuXHRcInVzZU1hcFwiLFxuXHRcImZyYW1lQm9yZGVyXCIsXG5cdFwiY29udGVudEVkaXRhYmxlXCJcbl0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkucHJvcEZpeFsgdGhpcy50b0xvd2VyQ2FzZSgpIF0gPSB0aGlzO1xufSApO1xuXG5cblxuXG5cdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlIGFjY29yZGluZyB0byBIVE1MIHNwZWNcblx0Ly8gaHR0cHM6Ly9pbmZyYS5zcGVjLndoYXR3Zy5vcmcvI3N0cmlwLWFuZC1jb2xsYXBzZS1hc2NpaS13aGl0ZXNwYWNlXG5cdGZ1bmN0aW9uIHN0cmlwQW5kQ29sbGFwc2UoIHZhbHVlICkge1xuXHRcdHZhciB0b2tlbnMgPSB2YWx1ZS5tYXRjaCggcm5vdGh0bWx3aGl0ZSApIHx8IFtdO1xuXHRcdHJldHVybiB0b2tlbnMuam9pbiggXCIgXCIgKTtcblx0fVxuXG5cbmZ1bmN0aW9uIGdldENsYXNzKCBlbGVtICkge1xuXHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiApIHx8IFwiXCI7XG59XG5cbmZ1bmN0aW9uIGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApIHtcblx0aWYgKCBBcnJheS5pc0FycmF5KCB2YWx1ZSApICkge1xuXHRcdHJldHVybiB2YWx1ZTtcblx0fVxuXHRpZiAoIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gdmFsdWUubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbXTtcblx0fVxuXHRyZXR1cm4gW107XG59XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0YWRkQ2xhc3M6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHR2YXIgY2xhc3NlcywgZWxlbSwgY3VyLCBjdXJWYWx1ZSwgY2xhenosIGosIGZpbmFsVmFsdWUsXG5cdFx0XHRpID0gMDtcblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0Y2xhc3NlcyA9IGNsYXNzZXNUb0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCBjbGFzc2VzLmxlbmd0aCApIHtcblx0XHRcdHdoaWxlICggKCBlbGVtID0gdGhpc1sgaSsrIF0gKSApIHtcblx0XHRcdFx0Y3VyVmFsdWUgPSBnZXRDbGFzcyggZWxlbSApO1xuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmICggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBjdXJWYWx1ZSApICsgXCIgXCIgKTtcblxuXHRcdFx0XHRpZiAoIGN1ciApIHtcblx0XHRcdFx0XHRqID0gMDtcblx0XHRcdFx0XHR3aGlsZSAoICggY2xhenogPSBjbGFzc2VzWyBqKysgXSApICkge1xuXHRcdFx0XHRcdFx0aWYgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPCAwICkge1xuXHRcdFx0XHRcdFx0XHRjdXIgKz0gY2xhenogKyBcIiBcIjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIHZhbHVlICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaiApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVtb3ZlQ2xhc3MoIHZhbHVlLmNhbGwoIHRoaXMsIGosIGdldENsYXNzKCB0aGlzICkgKSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5hdHRyKCBcImNsYXNzXCIsIFwiXCIgKTtcblx0XHR9XG5cblx0XHRjbGFzc2VzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRpZiAoIGNsYXNzZXMubGVuZ3RoICkge1xuXHRcdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0XHRjdXJWYWx1ZSA9IGdldENsYXNzKCBlbGVtICk7XG5cblx0XHRcdFx0Ly8gVGhpcyBleHByZXNzaW9uIGlzIGhlcmUgZm9yIGJldHRlciBjb21wcmVzc2liaWxpdHkgKHNlZSBhZGRDbGFzcylcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiIFwiICsgc3RyaXBBbmRDb2xsYXBzZSggY3VyVmFsdWUgKSArIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBzdHJpcEFuZENvbGxhcHNlKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHRvZ2dsZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUsIHN0YXRlVmFsICkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLFxuXHRcdFx0aXNWYWxpZFZhbHVlID0gdHlwZSA9PT0gXCJzdHJpbmdcIiB8fCBBcnJheS5pc0FycmF5KCB2YWx1ZSApO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc3RhdGVWYWwgPT09IFwiYm9vbGVhblwiICYmIGlzVmFsaWRWYWx1ZSApIHtcblx0XHRcdHJldHVybiBzdGF0ZVZhbCA/IHRoaXMuYWRkQ2xhc3MoIHZhbHVlICkgOiB0aGlzLnJlbW92ZUNsYXNzKCB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIGlzVmFsaWRWYWx1ZSApIHtcblxuXHRcdFx0XHQvLyBUb2dnbGUgaW5kaXZpZHVhbCBjbGFzcyBuYW1lc1xuXHRcdFx0XHRpID0gMDtcblx0XHRcdFx0c2VsZiA9IGpRdWVyeSggdGhpcyApO1xuXHRcdFx0XHRjbGFzc05hbWVzID0gY2xhc3Nlc1RvQXJyYXkoIHZhbHVlICk7XG5cblx0XHRcdFx0d2hpbGUgKCAoIGNsYXNzTmFtZSA9IGNsYXNzTmFtZXNbIGkrKyBdICkgKSB7XG5cblx0XHRcdFx0XHQvLyBDaGVjayBlYWNoIGNsYXNzTmFtZSBnaXZlbiwgc3BhY2Ugc2VwYXJhdGVkIGxpc3Rcblx0XHRcdFx0XHRpZiAoIHNlbGYuaGFzQ2xhc3MoIGNsYXNzTmFtZSApICkge1xuXHRcdFx0XHRcdFx0c2VsZi5yZW1vdmVDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHNlbGYuYWRkQ2xhc3MoIGNsYXNzTmFtZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBUb2dnbGUgd2hvbGUgY2xhc3MgbmFtZVxuXHRcdFx0fSBlbHNlIGlmICggdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB0eXBlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdFx0Y2xhc3NOYW1lID0gZ2V0Q2xhc3MoIHRoaXMgKTtcblx0XHRcdFx0aWYgKCBjbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHQvLyBTdG9yZSBjbGFzc05hbWUgaWYgc2V0XG5cdFx0XHRcdFx0ZGF0YVByaXYuc2V0KCB0aGlzLCBcIl9fY2xhc3NOYW1lX19cIiwgY2xhc3NOYW1lICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBJZiB0aGUgZWxlbWVudCBoYXMgYSBjbGFzcyBuYW1lIG9yIGlmIHdlJ3JlIHBhc3NlZCBgZmFsc2VgLFxuXHRcdFx0XHQvLyB0aGVuIHJlbW92ZSB0aGUgd2hvbGUgY2xhc3NuYW1lIChpZiB0aGVyZSB3YXMgb25lLCB0aGUgYWJvdmUgc2F2ZWQgaXQpLlxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYnJpbmcgYmFjayB3aGF0ZXZlciB3YXMgcHJldmlvdXNseSBzYXZlZCAoaWYgYW55dGhpbmcpLFxuXHRcdFx0XHQvLyBmYWxsaW5nIGJhY2sgdG8gdGhlIGVtcHR5IHN0cmluZyBpZiBub3RoaW5nIHdhcyBzdG9yZWQuXG5cdFx0XHRcdGlmICggdGhpcy5zZXRBdHRyaWJ1dGUgKSB7XG5cdFx0XHRcdFx0dGhpcy5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIixcblx0XHRcdFx0XHRcdGNsYXNzTmFtZSB8fCB2YWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0XHRcdFx0XCJcIiA6XG5cdFx0XHRcdFx0XHRkYXRhUHJpdi5nZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiICkgfHwgXCJcIlxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0aGFzQ2xhc3M6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgY2xhc3NOYW1lLCBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRjbGFzc05hbWUgPSBcIiBcIiArIHNlbGVjdG9yICsgXCIgXCI7XG5cdFx0d2hpbGUgKCAoIGVsZW0gPSB0aGlzWyBpKysgXSApICkge1xuXHRcdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdCggXCIgXCIgKyBzdHJpcEFuZENvbGxhcHNlKCBnZXRDbGFzcyggZWxlbSApICkgKyBcIiBcIiApLmluZGV4T2YoIGNsYXNzTmFtZSApID4gLTEgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCB2YWx1ZUlzRnVuY3Rpb24sXG5cdFx0XHRlbGVtID0gdGhpc1sgMCBdO1xuXG5cdFx0aWYgKCAhYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIGVsZW0udHlwZSBdIHx8XG5cdFx0XHRcdFx0alF1ZXJ5LnZhbEhvb2tzWyBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0XHRpZiAoIGhvb2tzICYmXG5cdFx0XHRcdFx0XCJnZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBcInZhbHVlXCIgKSApICE9PSB1bmRlZmluZWRcblx0XHRcdFx0KSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldCA9IGVsZW0udmFsdWU7XG5cblx0XHRcdFx0Ly8gSGFuZGxlIG1vc3QgY29tbW9uIHN0cmluZyBjYXNlc1xuXHRcdFx0XHRpZiAoIHR5cGVvZiByZXQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHJldC5yZXBsYWNlKCBycmV0dXJuLCBcIlwiICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBIYW5kbGUgY2FzZXMgd2hlcmUgdmFsdWUgaXMgbnVsbC91bmRlZiBvciBudW1iZXJcblx0XHRcdFx0cmV0dXJuIHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhbHVlSXNGdW5jdGlvbiA9IGlzRnVuY3Rpb24oIHZhbHVlICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdHZhciB2YWw7XG5cblx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSAhPT0gMSApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbHVlSXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggQXJyYXkuaXNBcnJheSggdmFsICkgKSB7XG5cdFx0XHRcdHZhbCA9IGpRdWVyeS5tYXAoIHZhbCwgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICsgXCJcIjtcblx0XHRcdFx0fSApO1xuXHRcdFx0fVxuXG5cdFx0XHRob29rcyA9IGpRdWVyeS52YWxIb29rc1sgdGhpcy50eXBlIF0gfHwgalF1ZXJ5LnZhbEhvb2tzWyB0aGlzLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgXTtcblxuXHRcdFx0Ly8gSWYgc2V0IHJldHVybnMgdW5kZWZpbmVkLCBmYWxsIGJhY2sgdG8gbm9ybWFsIHNldHRpbmdcblx0XHRcdGlmICggIWhvb2tzIHx8ICEoIFwic2V0XCIgaW4gaG9va3MgKSB8fCBob29rcy5zZXQoIHRoaXMsIHZhbCwgXCJ2YWx1ZVwiICkgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0dGhpcy52YWx1ZSA9IHZhbDtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmV4dGVuZCgge1xuXHR2YWxIb29rczoge1xuXHRcdG9wdGlvbjoge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblxuXHRcdFx0XHR2YXIgdmFsID0galF1ZXJ5LmZpbmQuYXR0ciggZWxlbSwgXCJ2YWx1ZVwiICk7XG5cdFx0XHRcdHJldHVybiB2YWwgIT0gbnVsbCA/XG5cdFx0XHRcdFx0dmFsIDpcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9MTAgLSAxMSBvbmx5XG5cdFx0XHRcdFx0Ly8gb3B0aW9uLnRleHQgdGhyb3dzIGV4Y2VwdGlvbnMgKCMxNDY4NiwgIzE0ODU4KVxuXHRcdFx0XHRcdC8vIFN0cmlwIGFuZCBjb2xsYXBzZSB3aGl0ZXNwYWNlXG5cdFx0XHRcdFx0Ly8gaHR0cHM6Ly9odG1sLnNwZWMud2hhdHdnLm9yZy8jc3RyaXAtYW5kLWNvbGxhcHNlLXdoaXRlc3BhY2Vcblx0XHRcdFx0XHRzdHJpcEFuZENvbGxhcHNlKCBqUXVlcnkudGV4dCggZWxlbSApICk7XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRzZWxlY3Q6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSwgb3B0aW9uLCBpLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0aW5kZXggPSBlbGVtLnNlbGVjdGVkSW5kZXgsXG5cdFx0XHRcdFx0b25lID0gZWxlbS50eXBlID09PSBcInNlbGVjdC1vbmVcIixcblx0XHRcdFx0XHR2YWx1ZXMgPSBvbmUgPyBudWxsIDogW10sXG5cdFx0XHRcdFx0bWF4ID0gb25lID8gaW5kZXggKyAxIDogb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0aWYgKCBpbmRleCA8IDAgKSB7XG5cdFx0XHRcdFx0aSA9IG1heDtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGkgPSBvbmUgPyBpbmRleCA6IDA7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBMb29wIHRocm91Z2ggYWxsIHRoZSBzZWxlY3RlZCBvcHRpb25zXG5cdFx0XHRcdGZvciAoIDsgaSA8IG1heDsgaSsrICkge1xuXHRcdFx0XHRcdG9wdGlvbiA9IG9wdGlvbnNbIGkgXTtcblxuXHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw9OSBvbmx5XG5cdFx0XHRcdFx0Ly8gSUU4LTkgZG9lc24ndCB1cGRhdGUgc2VsZWN0ZWQgYWZ0ZXIgZm9ybSByZXNldCAoIzI1NTEpXG5cdFx0XHRcdFx0aWYgKCAoIG9wdGlvbi5zZWxlY3RlZCB8fCBpID09PSBpbmRleCApICYmXG5cblx0XHRcdFx0XHRcdFx0Ly8gRG9uJ3QgcmV0dXJuIG9wdGlvbnMgdGhhdCBhcmUgZGlzYWJsZWQgb3IgaW4gYSBkaXNhYmxlZCBvcHRncm91cFxuXHRcdFx0XHRcdFx0XHQhb3B0aW9uLmRpc2FibGVkICYmXG5cdFx0XHRcdFx0XHRcdCggIW9wdGlvbi5wYXJlbnROb2RlLmRpc2FibGVkIHx8XG5cdFx0XHRcdFx0XHRcdFx0IW5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXG5cdFx0XHRcdFx0LyogZXNsaW50LWRpc2FibGUgbm8tY29uZC1hc3NpZ24gKi9cblxuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdGpRdWVyeS5pbkFycmF5KCBqUXVlcnkudmFsSG9va3Mub3B0aW9uLmdldCggb3B0aW9uICksIHZhbHVlcyApID4gLTFcblx0XHRcdFx0XHQpIHtcblx0XHRcdFx0XHRcdG9wdGlvblNldCA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25kLWFzc2lnbiAqL1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gRm9yY2UgYnJvd3NlcnMgdG8gYmVoYXZlIGNvbnNpc3RlbnRseSB3aGVuIG5vbi1tYXRjaGluZyB2YWx1ZSBpcyBzZXRcblx0XHRcdFx0aWYgKCAhb3B0aW9uU2V0ICkge1xuXHRcdFx0XHRcdGVsZW0uc2VsZWN0ZWRJbmRleCA9IC0xO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8vIFJhZGlvcyBhbmQgY2hlY2tib3hlcyBnZXR0ZXIvc2V0dGVyXG5qUXVlcnkuZWFjaCggWyBcInJhZGlvXCIsIFwiY2hlY2tib3hcIiBdLCBmdW5jdGlvbigpIHtcblx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0gPSB7XG5cdFx0c2V0OiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG5zdXBwb3J0LmZvY3VzaW4gPSBcIm9uZm9jdXNpblwiIGluIHdpbmRvdztcblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC8sXG5cdHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrID0gZnVuY3Rpb24oIGUgKSB7XG5cdFx0ZS5zdG9wUHJvcGFnYXRpb24oKTtcblx0fTtcblxualF1ZXJ5LmV4dGVuZCggalF1ZXJ5LmV2ZW50LCB7XG5cblx0dHJpZ2dlcjogZnVuY3Rpb24oIGV2ZW50LCBkYXRhLCBlbGVtLCBvbmx5SGFuZGxlcnMgKSB7XG5cblx0XHR2YXIgaSwgY3VyLCB0bXAsIGJ1YmJsZVR5cGUsIG9udHlwZSwgaGFuZGxlLCBzcGVjaWFsLCBsYXN0RWxlbWVudCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gbGFzdEVsZW1lbnQgPSB0bXAgPSBlbGVtID0gZWxlbSB8fCBkb2N1bWVudDtcblxuXHRcdC8vIERvbid0IGRvIGV2ZW50cyBvbiB0ZXh0IGFuZCBjb21tZW50IG5vZGVzXG5cdFx0aWYgKCBlbGVtLm5vZGVUeXBlID09PSAzIHx8IGVsZW0ubm9kZVR5cGUgPT09IDggKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gZm9jdXMvYmx1ciBtb3JwaHMgdG8gZm9jdXNpbi9vdXQ7IGVuc3VyZSB3ZSdyZSBub3QgZmlyaW5nIHRoZW0gcmlnaHQgbm93XG5cdFx0aWYgKCByZm9jdXNNb3JwaC50ZXN0KCB0eXBlICsgalF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCApICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlmICggdHlwZS5pbmRleE9mKCBcIi5cIiApID4gLTEgKSB7XG5cblx0XHRcdC8vIE5hbWVzcGFjZWQgdHJpZ2dlcjsgY3JlYXRlIGEgcmVnZXhwIHRvIG1hdGNoIGV2ZW50IHR5cGUgaW4gaGFuZGxlKClcblx0XHRcdG5hbWVzcGFjZXMgPSB0eXBlLnNwbGl0KCBcIi5cIiApO1xuXHRcdFx0dHlwZSA9IG5hbWVzcGFjZXMuc2hpZnQoKTtcblx0XHRcdG5hbWVzcGFjZXMuc29ydCgpO1xuXHRcdH1cblx0XHRvbnR5cGUgPSB0eXBlLmluZGV4T2YoIFwiOlwiICkgPCAwICYmIFwib25cIiArIHR5cGU7XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYSBqUXVlcnkuRXZlbnQgb2JqZWN0LCBPYmplY3QsIG9yIGp1c3QgYW4gZXZlbnQgdHlwZSBzdHJpbmdcblx0XHRldmVudCA9IGV2ZW50WyBqUXVlcnkuZXhwYW5kbyBdID9cblx0XHRcdGV2ZW50IDpcblx0XHRcdG5ldyBqUXVlcnkuRXZlbnQoIHR5cGUsIHR5cGVvZiBldmVudCA9PT0gXCJvYmplY3RcIiAmJiBldmVudCApO1xuXG5cdFx0Ly8gVHJpZ2dlciBiaXRtYXNrOiAmIDEgZm9yIG5hdGl2ZSBoYW5kbGVyczsgJiAyIGZvciBqUXVlcnkgKGFsd2F5cyB0cnVlKVxuXHRcdGV2ZW50LmlzVHJpZ2dlciA9IG9ubHlIYW5kbGVycyA/IDIgOiAzO1xuXHRcdGV2ZW50Lm5hbWVzcGFjZSA9IG5hbWVzcGFjZXMuam9pbiggXCIuXCIgKTtcblx0XHRldmVudC5ybmFtZXNwYWNlID0gZXZlbnQubmFtZXNwYWNlID9cblx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApIDpcblx0XHRcdG51bGw7XG5cblx0XHQvLyBDbGVhbiB1cCB0aGUgZXZlbnQgaW4gY2FzZSBpdCBpcyBiZWluZyByZXVzZWRcblx0XHRldmVudC5yZXN1bHQgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKCAhZXZlbnQudGFyZ2V0ICkge1xuXHRcdFx0ZXZlbnQudGFyZ2V0ID0gZWxlbTtcblx0XHR9XG5cblx0XHQvLyBDbG9uZSBhbnkgaW5jb21pbmcgZGF0YSBhbmQgcHJlcGVuZCB0aGUgZXZlbnQsIGNyZWF0aW5nIHRoZSBoYW5kbGVyIGFyZyBsaXN0XG5cdFx0ZGF0YSA9IGRhdGEgPT0gbnVsbCA/XG5cdFx0XHRbIGV2ZW50IF0gOlxuXHRcdFx0alF1ZXJ5Lm1ha2VBcnJheSggZGF0YSwgWyBldmVudCBdICk7XG5cblx0XHQvLyBBbGxvdyBzcGVjaWFsIGV2ZW50cyB0byBkcmF3IG91dHNpZGUgdGhlIGxpbmVzXG5cdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmIHNwZWNpYWwudHJpZ2dlciAmJiBzcGVjaWFsLnRyaWdnZXIuYXBwbHkoIGVsZW0sIGRhdGEgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGV2ZW50IHByb3BhZ2F0aW9uIHBhdGggaW4gYWR2YW5jZSwgcGVyIFczQyBldmVudHMgc3BlYyAoIzk5NTEpXG5cdFx0Ly8gQnViYmxlIHVwIHRvIGRvY3VtZW50LCB0aGVuIHRvIHdpbmRvdzsgd2F0Y2ggZm9yIGEgZ2xvYmFsIG93bmVyRG9jdW1lbnQgdmFyICgjOTcyNClcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIXNwZWNpYWwubm9CdWJibGUgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdGJ1YmJsZVR5cGUgPSBzcGVjaWFsLmRlbGVnYXRlVHlwZSB8fCB0eXBlO1xuXHRcdFx0aWYgKCAhcmZvY3VzTW9ycGgudGVzdCggYnViYmxlVHlwZSArIHR5cGUgKSApIHtcblx0XHRcdFx0Y3VyID0gY3VyLnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKCA7IGN1cjsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0dG1wID0gY3VyO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBPbmx5IGFkZCB3aW5kb3cgaWYgd2UgZ290IHRvIGRvY3VtZW50IChlLmcuLCBub3QgcGxhaW4gb2JqIG9yIGRldGFjaGVkIERPTSlcblx0XHRcdGlmICggdG1wID09PSAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBkb2N1bWVudCApICkge1xuXHRcdFx0XHRldmVudFBhdGgucHVzaCggdG1wLmRlZmF1bHRWaWV3IHx8IHRtcC5wYXJlbnRXaW5kb3cgfHwgd2luZG93ICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gRmlyZSBoYW5kbGVycyBvbiB0aGUgZXZlbnQgcGF0aFxuXHRcdGkgPSAwO1xuXHRcdHdoaWxlICggKCBjdXIgPSBldmVudFBhdGhbIGkrKyBdICkgJiYgIWV2ZW50LmlzUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cdFx0XHRsYXN0RWxlbWVudCA9IGN1cjtcblx0XHRcdGV2ZW50LnR5cGUgPSBpID4gMSA/XG5cdFx0XHRcdGJ1YmJsZVR5cGUgOlxuXHRcdFx0XHRzcGVjaWFsLmJpbmRUeXBlIHx8IHR5cGU7XG5cblx0XHRcdC8vIGpRdWVyeSBoYW5kbGVyXG5cdFx0XHRoYW5kbGUgPSAoXG5cdFx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCBPYmplY3QuY3JlYXRlKCBudWxsIClcblx0XHRcdFx0KVsgZXZlbnQudHlwZSBdICYmXG5cdFx0XHRcdGRhdGFQcml2LmdldCggY3VyLCBcImhhbmRsZVwiICk7XG5cdFx0XHRpZiAoIGhhbmRsZSApIHtcblx0XHRcdFx0aGFuZGxlLmFwcGx5KCBjdXIsIGRhdGEgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTmF0aXZlIGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9IG9udHlwZSAmJiBjdXJbIG9udHlwZSBdO1xuXHRcdFx0aWYgKCBoYW5kbGUgJiYgaGFuZGxlLmFwcGx5ICYmIGFjY2VwdERhdGEoIGN1ciApICkge1xuXHRcdFx0XHRldmVudC5yZXN1bHQgPSBoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0XHRpZiAoIGV2ZW50LnJlc3VsdCA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0ZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRldmVudC50eXBlID0gdHlwZTtcblxuXHRcdC8vIElmIG5vYm9keSBwcmV2ZW50ZWQgdGhlIGRlZmF1bHQgYWN0aW9uLCBkbyBpdCBub3dcblx0XHRpZiAoICFvbmx5SGFuZGxlcnMgJiYgIWV2ZW50LmlzRGVmYXVsdFByZXZlbnRlZCgpICkge1xuXG5cdFx0XHRpZiAoICggIXNwZWNpYWwuX2RlZmF1bHQgfHxcblx0XHRcdFx0c3BlY2lhbC5fZGVmYXVsdC5hcHBseSggZXZlbnRQYXRoLnBvcCgpLCBkYXRhICkgPT09IGZhbHNlICkgJiZcblx0XHRcdFx0YWNjZXB0RGF0YSggZWxlbSApICkge1xuXG5cdFx0XHRcdC8vIENhbGwgYSBuYXRpdmUgRE9NIG1ldGhvZCBvbiB0aGUgdGFyZ2V0IHdpdGggdGhlIHNhbWUgbmFtZSBhcyB0aGUgZXZlbnQuXG5cdFx0XHRcdC8vIERvbid0IGRvIGRlZmF1bHQgYWN0aW9ucyBvbiB3aW5kb3csIHRoYXQncyB3aGVyZSBnbG9iYWwgdmFyaWFibGVzIGJlICgjNjE3MClcblx0XHRcdFx0aWYgKCBvbnR5cGUgJiYgaXNGdW5jdGlvbiggZWxlbVsgdHlwZSBdICkgJiYgIWlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXG5cdFx0XHRcdFx0aWYgKCBldmVudC5pc1Byb3BhZ2F0aW9uU3RvcHBlZCgpICkge1xuXHRcdFx0XHRcdFx0bGFzdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lciggdHlwZSwgc3RvcFByb3BhZ2F0aW9uQ2FsbGJhY2sgKTtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRlbGVtWyB0eXBlIF0oKTtcblxuXHRcdFx0XHRcdGlmICggZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdFx0XHRcdGxhc3RFbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIHN0b3BQcm9wYWdhdGlvbkNhbGxiYWNrICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXJlZCA9IHVuZGVmaW5lZDtcblxuXHRcdFx0XHRcdGlmICggdG1wICkge1xuXHRcdFx0XHRcdFx0ZWxlbVsgb250eXBlIF0gPSB0bXA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHQvLyBQaWdneWJhY2sgb24gYSBkb25vciBldmVudCB0byBzaW11bGF0ZSBhIGRpZmZlcmVudCBvbmVcblx0Ly8gVXNlZCBvbmx5IGZvciBgZm9jdXMoaW4gfCBvdXQpYCBldmVudHNcblx0c2ltdWxhdGU6IGZ1bmN0aW9uKCB0eXBlLCBlbGVtLCBldmVudCApIHtcblx0XHR2YXIgZSA9IGpRdWVyeS5leHRlbmQoXG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCksXG5cdFx0XHRldmVudCxcblx0XHRcdHtcblx0XHRcdFx0dHlwZTogdHlwZSxcblx0XHRcdFx0aXNTaW11bGF0ZWQ6IHRydWVcblx0XHRcdH1cblx0XHQpO1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIGUsIG51bGwsIGVsZW0gKTtcblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveCA8PTQ0XG4vLyBGaXJlZm94IGRvZXNuJ3QgaGF2ZSBmb2N1cyhpbiB8IG91dCkgZXZlbnRzXG4vLyBSZWxhdGVkIHRpY2tldCAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY4Nzc4N1xuLy9cbi8vIFN1cHBvcnQ6IENocm9tZSA8PTQ4IC0gNDksIFNhZmFyaSA8PTkuMCAtIDkuMVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9idWdzLmNocm9taXVtLm9yZy9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9NDQ5ODU3XG5pZiAoICFzdXBwb3J0LmZvY3VzaW4gKSB7XG5cdGpRdWVyeS5lYWNoKCB7IGZvY3VzOiBcImZvY3VzaW5cIiwgYmx1cjogXCJmb2N1c291dFwiIH0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cblx0XHQvLyBBdHRhY2ggYSBzaW5nbGUgY2FwdHVyaW5nIGhhbmRsZXIgb24gdGhlIGRvY3VtZW50IHdoaWxlIHNvbWVvbmUgd2FudHMgZm9jdXNpbi9mb2N1c291dFxuXHRcdHZhciBoYW5kbGVyID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnNpbXVsYXRlKCBmaXgsIGV2ZW50LnRhcmdldCwgalF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKSApO1xuXHRcdH07XG5cblx0XHRqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZml4IF0gPSB7XG5cdFx0XHRzZXR1cDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0Ly8gSGFuZGxlOiByZWd1bGFyIG5vZGVzICh2aWEgYHRoaXMub3duZXJEb2N1bWVudGApLCB3aW5kb3dcblx0XHRcdFx0Ly8gKHZpYSBgdGhpcy5kb2N1bWVudGApICYgZG9jdW1lbnQgKHZpYSBgdGhpc2ApLlxuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMuZG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKTtcblxuXHRcdFx0XHRpZiAoICFhdHRhY2hlcyApIHtcblx0XHRcdFx0XHRkb2MuYWRkRXZlbnRMaXN0ZW5lciggb3JpZywgaGFuZGxlciwgdHJ1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXgsICggYXR0YWNoZXMgfHwgMCApICsgMSApO1xuXHRcdFx0fSxcblx0XHRcdHRlYXJkb3duOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGRvYyA9IHRoaXMub3duZXJEb2N1bWVudCB8fCB0aGlzLmRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICkgLSAxO1xuXG5cdFx0XHRcdGlmICggIWF0dGFjaGVzICkge1xuXHRcdFx0XHRcdGRvYy5yZW1vdmVFdmVudExpc3RlbmVyKCBvcmlnLCBoYW5kbGVyLCB0cnVlICk7XG5cdFx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBkb2MsIGZpeCApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZGF0YVByaXYuYWNjZXNzKCBkb2MsIGZpeCwgYXR0YWNoZXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH0gKTtcbn1cbnZhciBsb2NhdGlvbiA9IHdpbmRvdy5sb2NhdGlvbjtcblxudmFyIG5vbmNlID0geyBndWlkOiBEYXRlLm5vdygpIH07XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBDcm9zcy1icm93c2VyIHhtbCBwYXJzaW5nXG5qUXVlcnkucGFyc2VYTUwgPSBmdW5jdGlvbiggZGF0YSApIHtcblx0dmFyIHhtbDtcblx0aWYgKCAhZGF0YSB8fCB0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFIDkgLSAxMSBvbmx5XG5cdC8vIElFIHRocm93cyBvbiBwYXJzZUZyb21TdHJpbmcgd2l0aCBpbnZhbGlkIGlucHV0LlxuXHR0cnkge1xuXHRcdHhtbCA9ICggbmV3IHdpbmRvdy5ET01QYXJzZXIoKSApLnBhcnNlRnJvbVN0cmluZyggZGF0YSwgXCJ0ZXh0L3htbFwiICk7XG5cdH0gY2F0Y2ggKCBlICkge1xuXHRcdHhtbCA9IHVuZGVmaW5lZDtcblx0fVxuXG5cdGlmICggIXhtbCB8fCB4bWwuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIFwicGFyc2VyZXJyb3JcIiApLmxlbmd0aCApIHtcblx0XHRqUXVlcnkuZXJyb3IoIFwiSW52YWxpZCBYTUw6IFwiICsgZGF0YSApO1xuXHR9XG5cdHJldHVybiB4bWw7XG59O1xuXG5cbnZhclxuXHRyYnJhY2tldCA9IC9cXFtcXF0kLyxcblx0ckNSTEYgPSAvXFxyP1xcbi9nLFxuXHRyc3VibWl0dGVyVHlwZXMgPSAvXig/OnN1Ym1pdHxidXR0b258aW1hZ2V8cmVzZXR8ZmlsZSkkL2ksXG5cdHJzdWJtaXR0YWJsZSA9IC9eKD86aW5wdXR8c2VsZWN0fHRleHRhcmVhfGtleWdlbikvaTtcblxuZnVuY3Rpb24gYnVpbGRQYXJhbXMoIHByZWZpeCwgb2JqLCB0cmFkaXRpb25hbCwgYWRkICkge1xuXHR2YXIgbmFtZTtcblxuXHRpZiAoIEFycmF5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgdG9UeXBlKCBvYmogKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBvYmplY3QgaXRlbS5cblx0XHRmb3IgKCBuYW1lIGluIG9iaiApIHtcblx0XHRcdGJ1aWxkUGFyYW1zKCBwcmVmaXggKyBcIltcIiArIG5hbWUgKyBcIl1cIiwgb2JqWyBuYW1lIF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSBzY2FsYXIgaXRlbS5cblx0XHRhZGQoIHByZWZpeCwgb2JqICk7XG5cdH1cbn1cblxuLy8gU2VyaWFsaXplIGFuIGFycmF5IG9mIGZvcm0gZWxlbWVudHMgb3IgYSBzZXQgb2Zcbi8vIGtleS92YWx1ZXMgaW50byBhIHF1ZXJ5IHN0cmluZ1xualF1ZXJ5LnBhcmFtID0gZnVuY3Rpb24oIGEsIHRyYWRpdGlvbmFsICkge1xuXHR2YXIgcHJlZml4LFxuXHRcdHMgPSBbXSxcblx0XHRhZGQgPSBmdW5jdGlvbigga2V5LCB2YWx1ZU9yRnVuY3Rpb24gKSB7XG5cblx0XHRcdC8vIElmIHZhbHVlIGlzIGEgZnVuY3Rpb24sIGludm9rZSBpdCBhbmQgdXNlIGl0cyByZXR1cm4gdmFsdWVcblx0XHRcdHZhciB2YWx1ZSA9IGlzRnVuY3Rpb24oIHZhbHVlT3JGdW5jdGlvbiApID9cblx0XHRcdFx0dmFsdWVPckZ1bmN0aW9uKCkgOlxuXHRcdFx0XHR2YWx1ZU9yRnVuY3Rpb247XG5cblx0XHRcdHNbIHMubGVuZ3RoIF0gPSBlbmNvZGVVUklDb21wb25lbnQoIGtleSApICsgXCI9XCIgK1xuXHRcdFx0XHRlbmNvZGVVUklDb21wb25lbnQoIHZhbHVlID09IG51bGwgPyBcIlwiIDogdmFsdWUgKTtcblx0XHR9O1xuXG5cdGlmICggYSA9PSBudWxsICkge1xuXHRcdHJldHVybiBcIlwiO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBBcnJheS5pc0FycmF5KCBhICkgfHwgKCBhLmpxdWVyeSAmJiAhalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGEgKSApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHRoZSBmb3JtIGVsZW1lbnRzXG5cdFx0alF1ZXJ5LmVhY2goIGEsIGZ1bmN0aW9uKCkge1xuXHRcdFx0YWRkKCB0aGlzLm5hbWUsIHRoaXMudmFsdWUgKTtcblx0XHR9ICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIElmIHRyYWRpdGlvbmFsLCBlbmNvZGUgdGhlIFwib2xkXCIgd2F5ICh0aGUgd2F5IDEuMy4yIG9yIG9sZGVyXG5cdFx0Ly8gZGlkIGl0KSwgb3RoZXJ3aXNlIGVuY29kZSBwYXJhbXMgcmVjdXJzaXZlbHkuXG5cdFx0Zm9yICggcHJlZml4IGluIGEgKSB7XG5cdFx0XHRidWlsZFBhcmFtcyggcHJlZml4LCBhWyBwcmVmaXggXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgcmVzdWx0aW5nIHNlcmlhbGl6YXRpb25cblx0cmV0dXJuIHMuam9pbiggXCImXCIgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0c2VyaWFsaXplOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5LnBhcmFtKCB0aGlzLnNlcmlhbGl6ZUFycmF5KCkgKTtcblx0fSxcblx0c2VyaWFsaXplQXJyYXk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLm1hcCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIENhbiBhZGQgcHJvcEhvb2sgZm9yIFwiZWxlbWVudHNcIiB0byBmaWx0ZXIgb3IgYWRkIGZvcm0gZWxlbWVudHNcblx0XHRcdHZhciBlbGVtZW50cyA9IGpRdWVyeS5wcm9wKCB0aGlzLCBcImVsZW1lbnRzXCIgKTtcblx0XHRcdHJldHVybiBlbGVtZW50cyA/IGpRdWVyeS5tYWtlQXJyYXkoIGVsZW1lbnRzICkgOiB0aGlzO1xuXHRcdH0gKVxuXHRcdC5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLnR5cGU7XG5cblx0XHRcdC8vIFVzZSAuaXMoIFwiOmRpc2FibGVkXCIgKSBzbyB0aGF0IGZpZWxkc2V0W2Rpc2FibGVkXSB3b3Jrc1xuXHRcdFx0cmV0dXJuIHRoaXMubmFtZSAmJiAhalF1ZXJ5KCB0aGlzICkuaXMoIFwiOmRpc2FibGVkXCIgKSAmJlxuXHRcdFx0XHRyc3VibWl0dGFibGUudGVzdCggdGhpcy5ub2RlTmFtZSApICYmICFyc3VibWl0dGVyVHlwZXMudGVzdCggdHlwZSApICYmXG5cdFx0XHRcdCggdGhpcy5jaGVja2VkIHx8ICFyY2hlY2thYmxlVHlwZS50ZXN0KCB0eXBlICkgKTtcblx0XHR9IClcblx0XHQubWFwKCBmdW5jdGlvbiggX2ksIGVsZW0gKSB7XG5cdFx0XHR2YXIgdmFsID0galF1ZXJ5KCB0aGlzICkudmFsKCk7XG5cblx0XHRcdGlmICggdmFsID09IG51bGwgKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIEFycmF5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHRyZXR1cm4galF1ZXJ5Lm1hcCggdmFsLCBmdW5jdGlvbiggdmFsICkge1xuXHRcdFx0XHRcdHJldHVybiB7IG5hbWU6IGVsZW0ubmFtZSwgdmFsdWU6IHZhbC5yZXBsYWNlKCByQ1JMRiwgXCJcXHJcXG5cIiApIH07XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHsgbmFtZTogZWxlbS5uYW1lLCB2YWx1ZTogdmFsLnJlcGxhY2UoIHJDUkxGLCBcIlxcclxcblwiICkgfTtcblx0XHR9ICkuZ2V0KCk7XG5cdH1cbn0gKTtcblxuXG52YXJcblx0cjIwID0gLyUyMC9nLFxuXHRyaGFzaCA9IC8jLiokLyxcblx0cmFudGlDYWNoZSA9IC8oWz8mXSlfPVteJl0qLyxcblx0cmhlYWRlcnMgPSAvXiguKj8pOlsgXFx0XSooW15cXHJcXG5dKikkL21nLFxuXG5cdC8vICM3NjUzLCAjODEyNSwgIzgxNTI6IGxvY2FsIHByb3RvY29sIGRldGVjdGlvblxuXHRybG9jYWxQcm90b2NvbCA9IC9eKD86YWJvdXR8YXBwfGFwcC1zdG9yYWdlfC4rLWV4dGVuc2lvbnxmaWxlfHJlc3x3aWRnZXQpOiQvLFxuXHRybm9Db250ZW50ID0gL14oPzpHRVR8SEVBRCkkLyxcblx0cnByb3RvY29sID0gL15cXC9cXC8vLFxuXG5cdC8qIFByZWZpbHRlcnNcblx0ICogMSkgVGhleSBhcmUgdXNlZnVsIHRvIGludHJvZHVjZSBjdXN0b20gZGF0YVR5cGVzIChzZWUgYWpheC9qc29ucC5qcyBmb3IgYW4gZXhhbXBsZSlcblx0ICogMikgVGhlc2UgYXJlIGNhbGxlZDpcblx0ICogICAgLSBCRUZPUkUgYXNraW5nIGZvciBhIHRyYW5zcG9ydFxuXHQgKiAgICAtIEFGVEVSIHBhcmFtIHNlcmlhbGl6YXRpb24gKHMuZGF0YSBpcyBhIHN0cmluZyBpZiBzLnByb2Nlc3NEYXRhIGlzIHRydWUpXG5cdCAqIDMpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogNCkgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiA1KSBleGVjdXRpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBjb250aW51ZSBkb3duIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0cHJlZmlsdGVycyA9IHt9LFxuXG5cdC8qIFRyYW5zcG9ydHMgYmluZGluZ3Ncblx0ICogMSkga2V5IGlzIHRoZSBkYXRhVHlwZVxuXHQgKiAyKSB0aGUgY2F0Y2hhbGwgc3ltYm9sIFwiKlwiIGNhbiBiZSB1c2VkXG5cdCAqIDMpIHNlbGVjdGlvbiB3aWxsIHN0YXJ0IHdpdGggdHJhbnNwb3J0IGRhdGFUeXBlIGFuZCBUSEVOIGdvIHRvIFwiKlwiIGlmIG5lZWRlZFxuXHQgKi9cblx0dHJhbnNwb3J0cyA9IHt9LFxuXG5cdC8vIEF2b2lkIGNvbW1lbnQtcHJvbG9nIGNoYXIgc2VxdWVuY2UgKCMxMDA5OCk7IG11c3QgYXBwZWFzZSBsaW50IGFuZCBldmFkZSBjb21wcmVzc2lvblxuXHRhbGxUeXBlcyA9IFwiKi9cIi5jb25jYXQoIFwiKlwiICksXG5cblx0Ly8gQW5jaG9yIHRhZyBmb3IgcGFyc2luZyB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9yaWdpbkFuY2hvciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiYVwiICk7XG5cdG9yaWdpbkFuY2hvci5ocmVmID0gbG9jYXRpb24uaHJlZjtcblxuLy8gQmFzZSBcImNvbnN0cnVjdG9yXCIgZm9yIGpRdWVyeS5hamF4UHJlZmlsdGVyIGFuZCBqUXVlcnkuYWpheFRyYW5zcG9ydFxuZnVuY3Rpb24gYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBzdHJ1Y3R1cmUgKSB7XG5cblx0Ly8gZGF0YVR5cGVFeHByZXNzaW9uIGlzIG9wdGlvbmFsIGFuZCBkZWZhdWx0cyB0byBcIipcIlxuXHRyZXR1cm4gZnVuY3Rpb24oIGRhdGFUeXBlRXhwcmVzc2lvbiwgZnVuYyApIHtcblxuXHRcdGlmICggdHlwZW9mIGRhdGFUeXBlRXhwcmVzc2lvbiAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGZ1bmMgPSBkYXRhVHlwZUV4cHJlc3Npb247XG5cdFx0XHRkYXRhVHlwZUV4cHJlc3Npb24gPSBcIipcIjtcblx0XHR9XG5cblx0XHR2YXIgZGF0YVR5cGUsXG5cdFx0XHRpID0gMCxcblx0XHRcdGRhdGFUeXBlcyA9IGRhdGFUeXBlRXhwcmVzc2lvbi50b0xvd2VyQ2FzZSgpLm1hdGNoKCBybm90aHRtbHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGlzRnVuY3Rpb24oIGZ1bmMgKSApIHtcblxuXHRcdFx0Ly8gRm9yIGVhY2ggZGF0YVR5cGUgaW4gdGhlIGRhdGFUeXBlRXhwcmVzc2lvblxuXHRcdFx0d2hpbGUgKCAoIGRhdGFUeXBlID0gZGF0YVR5cGVzWyBpKysgXSApICkge1xuXG5cdFx0XHRcdC8vIFByZXBlbmQgaWYgcmVxdWVzdGVkXG5cdFx0XHRcdGlmICggZGF0YVR5cGVbIDAgXSA9PT0gXCIrXCIgKSB7XG5cdFx0XHRcdFx0ZGF0YVR5cGUgPSBkYXRhVHlwZS5zbGljZSggMSApIHx8IFwiKlwiO1xuXHRcdFx0XHRcdCggc3RydWN0dXJlWyBkYXRhVHlwZSBdID0gc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdICkudW5zaGlmdCggZnVuYyApO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBhcHBlbmRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnB1c2goIGZ1bmMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn1cblxuLy8gQmFzZSBpbnNwZWN0aW9uIGZ1bmN0aW9uIGZvciBwcmVmaWx0ZXJzIGFuZCB0cmFuc3BvcnRzXG5mdW5jdGlvbiBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlLCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICkge1xuXG5cdHZhciBpbnNwZWN0ZWQgPSB7fSxcblx0XHRzZWVraW5nVHJhbnNwb3J0ID0gKCBzdHJ1Y3R1cmUgPT09IHRyYW5zcG9ydHMgKTtcblxuXHRmdW5jdGlvbiBpbnNwZWN0KCBkYXRhVHlwZSApIHtcblx0XHR2YXIgc2VsZWN0ZWQ7XG5cdFx0aW5zcGVjdGVkWyBkYXRhVHlwZSBdID0gdHJ1ZTtcblx0XHRqUXVlcnkuZWFjaCggc3RydWN0dXJlWyBkYXRhVHlwZSBdIHx8IFtdLCBmdW5jdGlvbiggXywgcHJlZmlsdGVyT3JGYWN0b3J5ICkge1xuXHRcdFx0dmFyIGRhdGFUeXBlT3JUcmFuc3BvcnQgPSBwcmVmaWx0ZXJPckZhY3RvcnkoIG9wdGlvbnMsIG9yaWdpbmFsT3B0aW9ucywganFYSFIgKTtcblx0XHRcdGlmICggdHlwZW9mIGRhdGFUeXBlT3JUcmFuc3BvcnQgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0IXNlZWtpbmdUcmFuc3BvcnQgJiYgIWluc3BlY3RlZFsgZGF0YVR5cGVPclRyYW5zcG9ydCBdICkge1xuXG5cdFx0XHRcdG9wdGlvbnMuZGF0YVR5cGVzLnVuc2hpZnQoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0aW5zcGVjdCggZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCBzZWVraW5nVHJhbnNwb3J0ICkge1xuXHRcdFx0XHRyZXR1cm4gISggc2VsZWN0ZWQgPSBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHRcdHJldHVybiBzZWxlY3RlZDtcblx0fVxuXG5cdHJldHVybiBpbnNwZWN0KCBvcHRpb25zLmRhdGFUeXBlc1sgMCBdICkgfHwgIWluc3BlY3RlZFsgXCIqXCIgXSAmJiBpbnNwZWN0KCBcIipcIiApO1xufVxuXG4vLyBBIHNwZWNpYWwgZXh0ZW5kIGZvciBhamF4IG9wdGlvbnNcbi8vIHRoYXQgdGFrZXMgXCJmbGF0XCIgb3B0aW9ucyAobm90IHRvIGJlIGRlZXAgZXh0ZW5kZWQpXG4vLyBGaXhlcyAjOTg4N1xuZnVuY3Rpb24gYWpheEV4dGVuZCggdGFyZ2V0LCBzcmMgKSB7XG5cdHZhciBrZXksIGRlZXAsXG5cdFx0ZmxhdE9wdGlvbnMgPSBqUXVlcnkuYWpheFNldHRpbmdzLmZsYXRPcHRpb25zIHx8IHt9O1xuXG5cdGZvciAoIGtleSBpbiBzcmMgKSB7XG5cdFx0aWYgKCBzcmNbIGtleSBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHQoIGZsYXRPcHRpb25zWyBrZXkgXSA/IHRhcmdldCA6ICggZGVlcCB8fCAoIGRlZXAgPSB7fSApICkgKVsga2V5IF0gPSBzcmNbIGtleSBdO1xuXHRcdH1cblx0fVxuXHRpZiAoIGRlZXAgKSB7XG5cdFx0alF1ZXJ5LmV4dGVuZCggdHJ1ZSwgdGFyZ2V0LCBkZWVwICk7XG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0O1xufVxuXG4vKiBIYW5kbGVzIHJlc3BvbnNlcyB0byBhbiBhamF4IHJlcXVlc3Q6XG4gKiAtIGZpbmRzIHRoZSByaWdodCBkYXRhVHlwZSAobWVkaWF0ZXMgYmV0d2VlbiBjb250ZW50LXR5cGUgYW5kIGV4cGVjdGVkIGRhdGFUeXBlKVxuICogLSByZXR1cm5zIHRoZSBjb3JyZXNwb25kaW5nIHJlc3BvbnNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKSB7XG5cblx0dmFyIGN0LCB0eXBlLCBmaW5hbERhdGFUeXBlLCBmaXJzdERhdGFUeXBlLFxuXHRcdGNvbnRlbnRzID0gcy5jb250ZW50cyxcblx0XHRkYXRhVHlwZXMgPSBzLmRhdGFUeXBlcztcblxuXHQvLyBSZW1vdmUgYXV0byBkYXRhVHlwZSBhbmQgZ2V0IGNvbnRlbnQtdHlwZSBpbiB0aGUgcHJvY2Vzc1xuXHR3aGlsZSAoIGRhdGFUeXBlc1sgMCBdID09PSBcIipcIiApIHtcblx0XHRkYXRhVHlwZXMuc2hpZnQoKTtcblx0XHRpZiAoIGN0ID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRjdCA9IHMubWltZVR5cGUgfHwganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiQ29udGVudC1UeXBlXCIgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDaGVjayBpZiB3ZSdyZSBkZWFsaW5nIHdpdGggYSBrbm93biBjb250ZW50LXR5cGVcblx0aWYgKCBjdCApIHtcblx0XHRmb3IgKCB0eXBlIGluIGNvbnRlbnRzICkge1xuXHRcdFx0aWYgKCBjb250ZW50c1sgdHlwZSBdICYmIGNvbnRlbnRzWyB0eXBlIF0udGVzdCggY3QgKSApIHtcblx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHR5cGUgKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgdG8gc2VlIGlmIHdlIGhhdmUgYSByZXNwb25zZSBmb3IgdGhlIGV4cGVjdGVkIGRhdGFUeXBlXG5cdGlmICggZGF0YVR5cGVzWyAwIF0gaW4gcmVzcG9uc2VzICkge1xuXHRcdGZpbmFsRGF0YVR5cGUgPSBkYXRhVHlwZXNbIDAgXTtcblx0fSBlbHNlIHtcblxuXHRcdC8vIFRyeSBjb252ZXJ0aWJsZSBkYXRhVHlwZXNcblx0XHRmb3IgKCB0eXBlIGluIHJlc3BvbnNlcyApIHtcblx0XHRcdGlmICggIWRhdGFUeXBlc1sgMCBdIHx8IHMuY29udmVydGVyc1sgdHlwZSArIFwiIFwiICsgZGF0YVR5cGVzWyAwIF0gXSApIHtcblx0XHRcdFx0ZmluYWxEYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAhZmlyc3REYXRhVHlwZSApIHtcblx0XHRcdFx0Zmlyc3REYXRhVHlwZSA9IHR5cGU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gT3IganVzdCB1c2UgZmlyc3Qgb25lXG5cdFx0ZmluYWxEYXRhVHlwZSA9IGZpbmFsRGF0YVR5cGUgfHwgZmlyc3REYXRhVHlwZTtcblx0fVxuXG5cdC8vIElmIHdlIGZvdW5kIGEgZGF0YVR5cGVcblx0Ly8gV2UgYWRkIHRoZSBkYXRhVHlwZSB0byB0aGUgbGlzdCBpZiBuZWVkZWRcblx0Ly8gYW5kIHJldHVybiB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuXHRpZiAoIGZpbmFsRGF0YVR5cGUgKSB7XG5cdFx0aWYgKCBmaW5hbERhdGFUeXBlICE9PSBkYXRhVHlwZXNbIDAgXSApIHtcblx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCBmaW5hbERhdGFUeXBlICk7XG5cdFx0fVxuXHRcdHJldHVybiByZXNwb25zZXNbIGZpbmFsRGF0YVR5cGUgXTtcblx0fVxufVxuXG4vKiBDaGFpbiBjb252ZXJzaW9ucyBnaXZlbiB0aGUgcmVxdWVzdCBhbmQgdGhlIG9yaWdpbmFsIHJlc3BvbnNlXG4gKiBBbHNvIHNldHMgdGhlIHJlc3BvbnNlWFhYIGZpZWxkcyBvbiB0aGUganFYSFIgaW5zdGFuY2VcbiAqL1xuZnVuY3Rpb24gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICkge1xuXHR2YXIgY29udjIsIGN1cnJlbnQsIGNvbnYsIHRtcCwgcHJldixcblx0XHRjb252ZXJ0ZXJzID0ge30sXG5cblx0XHQvLyBXb3JrIHdpdGggYSBjb3B5IG9mIGRhdGFUeXBlcyBpbiBjYXNlIHdlIG5lZWQgdG8gbW9kaWZ5IGl0IGZvciBjb252ZXJzaW9uXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXMuc2xpY2UoKTtcblxuXHQvLyBDcmVhdGUgY29udmVydGVycyBtYXAgd2l0aCBsb3dlcmNhc2VkIGtleXNcblx0aWYgKCBkYXRhVHlwZXNbIDEgXSApIHtcblx0XHRmb3IgKCBjb252IGluIHMuY29udmVydGVycyApIHtcblx0XHRcdGNvbnZlcnRlcnNbIGNvbnYudG9Mb3dlckNhc2UoKSBdID0gcy5jb252ZXJ0ZXJzWyBjb252IF07XG5cdFx0fVxuXHR9XG5cblx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdC8vIENvbnZlcnQgdG8gZWFjaCBzZXF1ZW50aWFsIGRhdGFUeXBlXG5cdHdoaWxlICggY3VycmVudCApIHtcblxuXHRcdGlmICggcy5yZXNwb25zZUZpZWxkc1sgY3VycmVudCBdICkge1xuXHRcdFx0anFYSFJbIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSBdID0gcmVzcG9uc2U7XG5cdFx0fVxuXG5cdFx0Ly8gQXBwbHkgdGhlIGRhdGFGaWx0ZXIgaWYgcHJvdmlkZWRcblx0XHRpZiAoICFwcmV2ICYmIGlzU3VjY2VzcyAmJiBzLmRhdGFGaWx0ZXIgKSB7XG5cdFx0XHRyZXNwb25zZSA9IHMuZGF0YUZpbHRlciggcmVzcG9uc2UsIHMuZGF0YVR5cGUgKTtcblx0XHR9XG5cblx0XHRwcmV2ID0gY3VycmVudDtcblx0XHRjdXJyZW50ID0gZGF0YVR5cGVzLnNoaWZ0KCk7XG5cblx0XHRpZiAoIGN1cnJlbnQgKSB7XG5cblx0XHRcdC8vIFRoZXJlJ3Mgb25seSB3b3JrIHRvIGRvIGlmIGN1cnJlbnQgZGF0YVR5cGUgaXMgbm9uLWF1dG9cblx0XHRcdGlmICggY3VycmVudCA9PT0gXCIqXCIgKSB7XG5cblx0XHRcdFx0Y3VycmVudCA9IHByZXY7XG5cblx0XHRcdC8vIENvbnZlcnQgcmVzcG9uc2UgaWYgcHJldiBkYXRhVHlwZSBpcyBub24tYXV0byBhbmQgZGlmZmVycyBmcm9tIGN1cnJlbnRcblx0XHRcdH0gZWxzZSBpZiAoIHByZXYgIT09IFwiKlwiICYmIHByZXYgIT09IGN1cnJlbnQgKSB7XG5cblx0XHRcdFx0Ly8gU2VlayBhIGRpcmVjdCBjb252ZXJ0ZXJcblx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIGN1cnJlbnQgXSB8fCBjb252ZXJ0ZXJzWyBcIiogXCIgKyBjdXJyZW50IF07XG5cblx0XHRcdFx0Ly8gSWYgbm9uZSBmb3VuZCwgc2VlayBhIHBhaXJcblx0XHRcdFx0aWYgKCAhY29udiApIHtcblx0XHRcdFx0XHRmb3IgKCBjb252MiBpbiBjb252ZXJ0ZXJzICkge1xuXG5cdFx0XHRcdFx0XHQvLyBJZiBjb252MiBvdXRwdXRzIGN1cnJlbnRcblx0XHRcdFx0XHRcdHRtcCA9IGNvbnYyLnNwbGl0KCBcIiBcIiApO1xuXHRcdFx0XHRcdFx0aWYgKCB0bXBbIDEgXSA9PT0gY3VycmVudCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBwcmV2IGNhbiBiZSBjb252ZXJ0ZWQgdG8gYWNjZXB0ZWQgaW5wdXRcblx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIHByZXYgKyBcIiBcIiArIHRtcFsgMCBdIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRjb252ZXJ0ZXJzWyBcIiogXCIgKyB0bXBbIDAgXSBdO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBDb25kZW5zZSBlcXVpdmFsZW5jZSBjb252ZXJ0ZXJzXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCBjb252ID09PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29udiA9IGNvbnZlcnRlcnNbIGNvbnYyIF07XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGluc2VydCB0aGUgaW50ZXJtZWRpYXRlIGRhdGFUeXBlXG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggY29udmVydGVyc1sgY29udjIgXSAhPT0gdHJ1ZSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSB0bXBbIDAgXTtcblx0XHRcdFx0XHRcdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0bXBbIDEgXSApO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEFwcGx5IGNvbnZlcnRlciAoaWYgbm90IGFuIGVxdWl2YWxlbmNlKVxuXHRcdFx0XHRpZiAoIGNvbnYgIT09IHRydWUgKSB7XG5cblx0XHRcdFx0XHQvLyBVbmxlc3MgZXJyb3JzIGFyZSBhbGxvd2VkIHRvIGJ1YmJsZSwgY2F0Y2ggYW5kIHJldHVybiB0aGVtXG5cdFx0XHRcdFx0aWYgKCBjb252ICYmIHMudGhyb3dzICkge1xuXHRcdFx0XHRcdFx0cmVzcG9uc2UgPSBjb252KCByZXNwb25zZSApO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0XHR9IGNhdGNoICggZSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0XHRcdFx0XHRzdGF0ZTogXCJwYXJzZXJlcnJvclwiLFxuXHRcdFx0XHRcdFx0XHRcdGVycm9yOiBjb252ID8gZSA6IFwiTm8gY29udmVyc2lvbiBmcm9tIFwiICsgcHJldiArIFwiIHRvIFwiICsgY3VycmVudFxuXHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB7IHN0YXRlOiBcInN1Y2Nlc3NcIiwgZGF0YTogcmVzcG9uc2UgfTtcbn1cblxualF1ZXJ5LmV4dGVuZCgge1xuXG5cdC8vIENvdW50ZXIgZm9yIGhvbGRpbmcgdGhlIG51bWJlciBvZiBhY3RpdmUgcXVlcmllc1xuXHRhY3RpdmU6IDAsXG5cblx0Ly8gTGFzdC1Nb2RpZmllZCBoZWFkZXIgY2FjaGUgZm9yIG5leHQgcmVxdWVzdFxuXHRsYXN0TW9kaWZpZWQ6IHt9LFxuXHRldGFnOiB7fSxcblxuXHRhamF4U2V0dGluZ3M6IHtcblx0XHR1cmw6IGxvY2F0aW9uLmhyZWYsXG5cdFx0dHlwZTogXCJHRVRcIixcblx0XHRpc0xvY2FsOiBybG9jYWxQcm90b2NvbC50ZXN0KCBsb2NhdGlvbi5wcm90b2NvbCApLFxuXHRcdGdsb2JhbDogdHJ1ZSxcblx0XHRwcm9jZXNzRGF0YTogdHJ1ZSxcblx0XHRhc3luYzogdHJ1ZSxcblx0XHRjb250ZW50VHlwZTogXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7IGNoYXJzZXQ9VVRGLThcIixcblxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBKU09OLnBhcnNlLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBSZXF1ZXN0IHN0YXRlIChiZWNvbWVzIGZhbHNlIHVwb24gc2VuZCBhbmQgdHJ1ZSB1cG9uIGNvbXBsZXRpb24pXG5cdFx0XHRjb21wbGV0ZWQsXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgZ2xvYmFsIGV2ZW50cyBhcmUgdG8gYmUgZGlzcGF0Y2hlZFxuXHRcdFx0ZmlyZUdsb2JhbHMsXG5cblx0XHRcdC8vIExvb3AgdmFyaWFibGVcblx0XHRcdGksXG5cblx0XHRcdC8vIHVuY2FjaGVkIHBhcnQgb2YgdGhlIHVybFxuXHRcdFx0dW5jYWNoZWQsXG5cblx0XHRcdC8vIENyZWF0ZSB0aGUgZmluYWwgb3B0aW9ucyBvYmplY3Rcblx0XHRcdHMgPSBqUXVlcnkuYWpheFNldHVwKCB7fSwgb3B0aW9ucyApLFxuXG5cdFx0XHQvLyBDYWxsYmFja3MgY29udGV4dFxuXHRcdFx0Y2FsbGJhY2tDb250ZXh0ID0gcy5jb250ZXh0IHx8IHMsXG5cblx0XHRcdC8vIENvbnRleHQgZm9yIGdsb2JhbCBldmVudHMgaXMgY2FsbGJhY2tDb250ZXh0IGlmIGl0IGlzIGEgRE9NIG5vZGUgb3IgalF1ZXJ5IGNvbGxlY3Rpb25cblx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dCA9IHMuY29udGV4dCAmJlxuXHRcdFx0XHQoIGNhbGxiYWNrQ29udGV4dC5ub2RlVHlwZSB8fCBjYWxsYmFja0NvbnRleHQuanF1ZXJ5ICkgP1xuXHRcdFx0XHRcdGpRdWVyeSggY2FsbGJhY2tDb250ZXh0ICkgOlxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudCxcblxuXHRcdFx0Ly8gRGVmZXJyZWRzXG5cdFx0XHRkZWZlcnJlZCA9IGpRdWVyeS5EZWZlcnJlZCgpLFxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZCA9IGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLFxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0c3RhdHVzQ29kZSA9IHMuc3RhdHVzQ29kZSB8fCB7fSxcblxuXHRcdFx0Ly8gSGVhZGVycyAodGhleSBhcmUgc2VudCBhbGwgYXQgb25jZSlcblx0XHRcdHJlcXVlc3RIZWFkZXJzID0ge30sXG5cdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzID0ge30sXG5cblx0XHRcdC8vIERlZmF1bHQgYWJvcnQgbWVzc2FnZVxuXHRcdFx0c3RyQWJvcnQgPSBcImNhbmNlbGVkXCIsXG5cblx0XHRcdC8vIEZha2UgeGhyXG5cdFx0XHRqcVhIUiA9IHtcblx0XHRcdFx0cmVhZHlTdGF0ZTogMCxcblxuXHRcdFx0XHQvLyBCdWlsZHMgaGVhZGVycyBoYXNodGFibGUgaWYgbmVlZGVkXG5cdFx0XHRcdGdldFJlc3BvbnNlSGVhZGVyOiBmdW5jdGlvbigga2V5ICkge1xuXHRcdFx0XHRcdHZhciBtYXRjaDtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHRcdGlmICggIXJlc3BvbnNlSGVhZGVycyApIHtcblx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzID0ge307XG5cdFx0XHRcdFx0XHRcdHdoaWxlICggKCBtYXRjaCA9IHJoZWFkZXJzLmV4ZWMoIHJlc3BvbnNlSGVhZGVyc1N0cmluZyApICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0cmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdID1cblx0XHRcdFx0XHRcdFx0XHRcdCggcmVzcG9uc2VIZWFkZXJzWyBtYXRjaFsgMSBdLnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdIHx8IFtdIClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LmNvbmNhdCggbWF0Y2hbIDIgXSApO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgKyBcIiBcIiBdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbWF0Y2ggPT0gbnVsbCA/IG51bGwgOiBtYXRjaC5qb2luKCBcIiwgXCIgKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBSYXcgc3RyaW5nXG5cdFx0XHRcdGdldEFsbFJlc3BvbnNlSGVhZGVyczogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGNvbXBsZXRlZCA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdGlmICggY29tcGxldGVkID09IG51bGwgKSB7XG5cdFx0XHRcdFx0XHRuYW1lID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbmFtZS50b0xvd2VyQ2FzZSgpIF0gPVxuXHRcdFx0XHRcdFx0XHRyZXF1ZXN0SGVhZGVyc05hbWVzWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCA9PSBudWxsICkge1xuXHRcdFx0XHRcdFx0cy5taW1lVHlwZSA9IHR5cGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRcdHN0YXR1c0NvZGU6IGZ1bmN0aW9uKCBtYXAgKSB7XG5cdFx0XHRcdFx0dmFyIGNvZGU7XG5cdFx0XHRcdFx0aWYgKCBtYXAgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBFeGVjdXRlIHRoZSBhcHByb3ByaWF0ZSBjYWxsYmFja3Ncblx0XHRcdFx0XHRcdFx0anFYSFIuYWx3YXlzKCBtYXBbIGpxWEhSLnN0YXR1cyBdICk7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIExhenktYWRkIHRoZSBuZXcgY2FsbGJhY2tzIGluIGEgd2F5IHRoYXQgcHJlc2VydmVzIG9sZCBvbmVzXG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdC8vIENhbmNlbCB0aGUgcmVxdWVzdFxuXHRcdFx0XHRhYm9ydDogZnVuY3Rpb24oIHN0YXR1c1RleHQgKSB7XG5cdFx0XHRcdFx0dmFyIGZpbmFsVGV4dCA9IHN0YXR1c1RleHQgfHwgc3RyQWJvcnQ7XG5cdFx0XHRcdFx0aWYgKCB0cmFuc3BvcnQgKSB7XG5cdFx0XHRcdFx0XHR0cmFuc3BvcnQuYWJvcnQoIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkb25lKCAwLCBmaW5hbFRleHQgKTtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0fTtcblxuXHRcdC8vIEF0dGFjaCBkZWZlcnJlZHNcblx0XHRkZWZlcnJlZC5wcm9taXNlKCBqcVhIUiApO1xuXG5cdFx0Ly8gQWRkIHByb3RvY29sIGlmIG5vdCBwcm92aWRlZCAocHJlZmlsdGVycyBtaWdodCBleHBlY3QgaXQpXG5cdFx0Ly8gSGFuZGxlIGZhbHN5IHVybCBpbiB0aGUgc2V0dGluZ3Mgb2JqZWN0ICgjMTAwOTM6IGNvbnNpc3RlbmN5IHdpdGggb2xkIHNpZ25hdHVyZSlcblx0XHQvLyBXZSBhbHNvIHVzZSB0aGUgdXJsIHBhcmFtZXRlciBpZiBhdmFpbGFibGVcblx0XHRzLnVybCA9ICggKCB1cmwgfHwgcy51cmwgfHwgbG9jYXRpb24uaHJlZiApICsgXCJcIiApXG5cdFx0XHQucmVwbGFjZSggcnByb3RvY29sLCBsb2NhdGlvbi5wcm90b2NvbCArIFwiLy9cIiApO1xuXG5cdFx0Ly8gQWxpYXMgbWV0aG9kIG9wdGlvbiB0byB0eXBlIGFzIHBlciB0aWNrZXQgIzEyMDA0XG5cdFx0cy50eXBlID0gb3B0aW9ucy5tZXRob2QgfHwgb3B0aW9ucy50eXBlIHx8IHMubWV0aG9kIHx8IHMudHlwZTtcblxuXHRcdC8vIEV4dHJhY3QgZGF0YVR5cGVzIGxpc3Rcblx0XHRzLmRhdGFUeXBlcyA9ICggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3RodG1sd2hpdGUgKSB8fCBbIFwiXCIgXTtcblxuXHRcdC8vIEEgY3Jvc3MtZG9tYWluIHJlcXVlc3QgaXMgaW4gb3JkZXIgd2hlbiB0aGUgb3JpZ2luIGRvZXNuJ3QgbWF0Y2ggdGhlIGN1cnJlbnQgb3JpZ2luLlxuXHRcdGlmICggcy5jcm9zc0RvbWFpbiA9PSBudWxsICkge1xuXHRcdFx0dXJsQW5jaG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJhXCIgKTtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEsIEVkZ2UgMTIgLSAxNVxuXHRcdFx0Ly8gSUUgdGhyb3dzIGV4Y2VwdGlvbiBvbiBhY2Nlc3NpbmcgdGhlIGhyZWYgcHJvcGVydHkgaWYgdXJsIGlzIG1hbGZvcm1lZCxcblx0XHRcdC8vIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IC0gMTEgb25seVxuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0fVxuXG5cdFx0Ly8gV2UgY2FuIGZpcmUgZ2xvYmFsIGV2ZW50cyBhcyBvZiBub3cgaWYgYXNrZWQgdG9cblx0XHQvLyBEb24ndCBmaXJlIGV2ZW50cyBpZiBqUXVlcnkuZXZlbnQgaXMgdW5kZWZpbmVkIGluIGFuIEFNRC11c2FnZSBzY2VuYXJpbyAoIzE1MTE4KVxuXHRcdGZpcmVHbG9iYWxzID0galF1ZXJ5LmV2ZW50ICYmIHMuZ2xvYmFsO1xuXG5cdFx0Ly8gV2F0Y2ggZm9yIGEgbmV3IHNldCBvZiByZXF1ZXN0c1xuXHRcdGlmICggZmlyZUdsb2JhbHMgJiYgalF1ZXJ5LmFjdGl2ZSsrID09PSAwICkge1xuXHRcdFx0alF1ZXJ5LmV2ZW50LnRyaWdnZXIoIFwiYWpheFN0YXJ0XCIgKTtcblx0XHR9XG5cblx0XHQvLyBVcHBlcmNhc2UgdGhlIHR5cGVcblx0XHRzLnR5cGUgPSBzLnR5cGUudG9VcHBlckNhc2UoKTtcblxuXHRcdC8vIERldGVybWluZSBpZiByZXF1ZXN0IGhhcyBjb250ZW50XG5cdFx0cy5oYXNDb250ZW50ID0gIXJub0NvbnRlbnQudGVzdCggcy50eXBlICk7XG5cblx0XHQvLyBTYXZlIHRoZSBVUkwgaW4gY2FzZSB3ZSdyZSB0b3lpbmcgd2l0aCB0aGUgSWYtTW9kaWZpZWQtU2luY2Vcblx0XHQvLyBhbmQvb3IgSWYtTm9uZS1NYXRjaCBoZWFkZXIgbGF0ZXIgb25cblx0XHQvLyBSZW1vdmUgaGFzaCB0byBzaW1wbGlmeSB1cmwgbWFuaXB1bGF0aW9uXG5cdFx0Y2FjaGVVUkwgPSBzLnVybC5yZXBsYWNlKCByaGFzaCwgXCJcIiApO1xuXG5cdFx0Ly8gTW9yZSBvcHRpb25zIGhhbmRsaW5nIGZvciByZXF1ZXN0cyB3aXRoIG5vIGNvbnRlbnRcblx0XHRpZiAoICFzLmhhc0NvbnRlbnQgKSB7XG5cblx0XHRcdC8vIFJlbWVtYmVyIHRoZSBoYXNoIHNvIHdlIGNhbiBwdXQgaXQgYmFja1xuXHRcdFx0dW5jYWNoZWQgPSBzLnVybC5zbGljZSggY2FjaGVVUkwubGVuZ3RoICk7XG5cblx0XHRcdC8vIElmIGRhdGEgaXMgYXZhaWxhYmxlIGFuZCBzaG91bGQgYmUgcHJvY2Vzc2VkLCBhcHBlbmQgZGF0YSB0byB1cmxcblx0XHRcdGlmICggcy5kYXRhICYmICggcy5wcm9jZXNzRGF0YSB8fCB0eXBlb2Ygcy5kYXRhID09PSBcInN0cmluZ1wiICkgKSB7XG5cdFx0XHRcdGNhY2hlVVJMICs9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmRhdGE7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb3IgdXBkYXRlIGFudGktY2FjaGUgcGFyYW0gaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRjYWNoZVVSTCA9IGNhY2hlVVJMLnJlcGxhY2UoIHJhbnRpQ2FjaGUsIFwiJDFcIiApO1xuXHRcdFx0XHR1bmNhY2hlZCA9ICggcnF1ZXJ5LnRlc3QoIGNhY2hlVVJMICkgPyBcIiZcIiA6IFwiP1wiICkgKyBcIl89XCIgKyAoIG5vbmNlLmd1aWQrKyApICtcblx0XHRcdFx0XHR1bmNhY2hlZDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gUHV0IGhhc2ggYW5kIGFudGktY2FjaGUgb24gdGhlIFVSTCB0aGF0IHdpbGwgYmUgcmVxdWVzdGVkIChnaC0xNzMyKVxuXHRcdFx0cy51cmwgPSBjYWNoZVVSTCArIHVuY2FjaGVkO1xuXG5cdFx0Ly8gQ2hhbmdlICclMjAnIHRvICcrJyBpZiB0aGlzIGlzIGVuY29kZWQgZm9ybSBib2R5IGNvbnRlbnQgKGdoLTI2NTgpXG5cdFx0fSBlbHNlIGlmICggcy5kYXRhICYmIHMucHJvY2Vzc0RhdGEgJiZcblx0XHRcdCggcy5jb250ZW50VHlwZSB8fCBcIlwiICkuaW5kZXhPZiggXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIiApID09PSAwICkge1xuXHRcdFx0cy5kYXRhID0gcy5kYXRhLnJlcGxhY2UoIHIyMCwgXCIrXCIgKTtcblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgY29tcGxldGVkICkgKSB7XG5cblx0XHRcdC8vIEFib3J0IGlmIG5vdCBkb25lIGFscmVhZHkgYW5kIHJldHVyblxuXHRcdFx0cmV0dXJuIGpxWEhSLmFib3J0KCk7XG5cdFx0fVxuXG5cdFx0Ly8gQWJvcnRpbmcgaXMgbm8gbG9uZ2VyIGEgY2FuY2VsbGF0aW9uXG5cdFx0c3RyQWJvcnQgPSBcImFib3J0XCI7XG5cblx0XHQvLyBJbnN0YWxsIGNhbGxiYWNrcyBvbiBkZWZlcnJlZHNcblx0XHRjb21wbGV0ZURlZmVycmVkLmFkZCggcy5jb21wbGV0ZSApO1xuXHRcdGpxWEhSLmRvbmUoIHMuc3VjY2VzcyApO1xuXHRcdGpxWEhSLmZhaWwoIHMuZXJyb3IgKTtcblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0cmV0dXJuIGpxWEhSO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUaW1lb3V0XG5cdFx0XHRpZiAoIHMuYXN5bmMgJiYgcy50aW1lb3V0ID4gMCApIHtcblx0XHRcdFx0dGltZW91dFRpbWVyID0gd2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGpxWEhSLmFib3J0KCBcInRpbWVvdXRcIiApO1xuXHRcdFx0XHR9LCBzLnRpbWVvdXQgKTtcblx0XHRcdH1cblxuXHRcdFx0dHJ5IHtcblx0XHRcdFx0Y29tcGxldGVkID0gZmFsc2U7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUmV0aHJvdyBwb3N0LWNvbXBsZXRpb24gZXhjZXB0aW9uc1xuXHRcdFx0XHRpZiAoIGNvbXBsZXRlZCApIHtcblx0XHRcdFx0XHR0aHJvdyBlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIG90aGVycyBhcyByZXN1bHRzXG5cdFx0XHRcdGRvbmUoIC0xLCBlICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsbGJhY2sgZm9yIHdoZW4gZXZlcnl0aGluZyBpcyBkb25lXG5cdFx0ZnVuY3Rpb24gZG9uZSggc3RhdHVzLCBuYXRpdmVTdGF0dXNUZXh0LCByZXNwb25zZXMsIGhlYWRlcnMgKSB7XG5cdFx0XHR2YXIgaXNTdWNjZXNzLCBzdWNjZXNzLCBlcnJvciwgcmVzcG9uc2UsIG1vZGlmaWVkLFxuXHRcdFx0XHRzdGF0dXNUZXh0ID0gbmF0aXZlU3RhdHVzVGV4dDtcblxuXHRcdFx0Ly8gSWdub3JlIHJlcGVhdCBpbnZvY2F0aW9uc1xuXHRcdFx0aWYgKCBjb21wbGV0ZWQgKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29tcGxldGVkID0gdHJ1ZTtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gVXNlIGEgbm9vcCBjb252ZXJ0ZXIgZm9yIG1pc3Npbmcgc2NyaXB0XG5cdFx0XHRpZiAoICFpc1N1Y2Nlc3MgJiYgalF1ZXJ5LmluQXJyYXkoIFwic2NyaXB0XCIsIHMuZGF0YVR5cGVzICkgPiAtMSApIHtcblx0XHRcdFx0cy5jb252ZXJ0ZXJzWyBcInRleHQgc2NyaXB0XCIgXSA9IGZ1bmN0aW9uKCkge307XG5cdFx0XHR9XG5cblx0XHRcdC8vIENvbnZlcnQgbm8gbWF0dGVyIHdoYXQgKHRoYXQgd2F5IHJlc3BvbnNlWFhYIGZpZWxkcyBhcmUgYWx3YXlzIHNldClcblx0XHRcdHJlc3BvbnNlID0gYWpheENvbnZlcnQoIHMsIHJlc3BvbnNlLCBqcVhIUiwgaXNTdWNjZXNzICk7XG5cblx0XHRcdC8vIElmIHN1Y2Nlc3NmdWwsIGhhbmRsZSB0eXBlIGNoYWluaW5nXG5cdFx0XHRpZiAoIGlzU3VjY2VzcyApIHtcblxuXHRcdFx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdFx0XHRpZiAoIHMuaWZNb2RpZmllZCApIHtcblx0XHRcdFx0XHRtb2RpZmllZCA9IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkxhc3QtTW9kaWZpZWRcIiApO1xuXHRcdFx0XHRcdGlmICggbW9kaWZpZWQgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiZXRhZ1wiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5ldGFnWyBjYWNoZVVSTCBdID0gbW9kaWZpZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gaWYgbm8gY29udGVudFxuXHRcdFx0XHRpZiAoIHN0YXR1cyA9PT0gMjA0IHx8IHMudHlwZSA9PT0gXCJIRUFEXCIgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm9jb250ZW50XCI7XG5cblx0XHRcdFx0Ly8gaWYgbm90IG1vZGlmaWVkXG5cdFx0XHRcdH0gZWxzZSBpZiAoIHN0YXR1cyA9PT0gMzA0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcIm5vdG1vZGlmaWVkXCI7XG5cblx0XHRcdFx0Ly8gSWYgd2UgaGF2ZSBkYXRhLCBsZXQncyBjb252ZXJ0IGl0XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IHJlc3BvbnNlLnN0YXRlO1xuXHRcdFx0XHRcdHN1Y2Nlc3MgPSByZXNwb25zZS5kYXRhO1xuXHRcdFx0XHRcdGVycm9yID0gcmVzcG9uc2UuZXJyb3I7XG5cdFx0XHRcdFx0aXNTdWNjZXNzID0gIWVycm9yO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdC8vIEV4dHJhY3QgZXJyb3IgZnJvbSBzdGF0dXNUZXh0IGFuZCBub3JtYWxpemUgZm9yIG5vbi1hYm9ydHNcblx0XHRcdFx0ZXJyb3IgPSBzdGF0dXNUZXh0O1xuXHRcdFx0XHRpZiAoIHN0YXR1cyB8fCAhc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJlcnJvclwiO1xuXHRcdFx0XHRcdGlmICggc3RhdHVzIDwgMCApIHtcblx0XHRcdFx0XHRcdHN0YXR1cyA9IDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNldCBkYXRhIGZvciB0aGUgZmFrZSB4aHIgb2JqZWN0XG5cdFx0XHRqcVhIUi5zdGF0dXMgPSBzdGF0dXM7XG5cdFx0XHRqcVhIUi5zdGF0dXNUZXh0ID0gKCBuYXRpdmVTdGF0dXNUZXh0IHx8IHN0YXR1c1RleHQgKSArIFwiXCI7XG5cblx0XHRcdC8vIFN1Y2Nlc3MvRXJyb3Jcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIHN1Y2Nlc3MsIHN0YXR1c1RleHQsIGpxWEhSIF0gKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlamVjdFdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCwgZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0anFYSFIuc3RhdHVzQ29kZSggc3RhdHVzQ29kZSApO1xuXHRcdFx0c3RhdHVzQ29kZSA9IHVuZGVmaW5lZDtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIGlzU3VjY2VzcyA/IFwiYWpheFN1Y2Nlc3NcIiA6IFwiYWpheEVycm9yXCIsXG5cdFx0XHRcdFx0WyBqcVhIUiwgcywgaXNTdWNjZXNzID8gc3VjY2VzcyA6IGVycm9yIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29tcGxldGVcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQuZmlyZVdpdGgoIGNhbGxiYWNrQ29udGV4dCwgWyBqcVhIUiwgc3RhdHVzVGV4dCBdICk7XG5cblx0XHRcdGlmICggZmlyZUdsb2JhbHMgKSB7XG5cdFx0XHRcdGdsb2JhbEV2ZW50Q29udGV4dC50cmlnZ2VyKCBcImFqYXhDb21wbGV0ZVwiLCBbIGpxWEhSLCBzIF0gKTtcblxuXHRcdFx0XHQvLyBIYW5kbGUgdGhlIGdsb2JhbCBBSkFYIGNvdW50ZXJcblx0XHRcdFx0aWYgKCAhKCAtLWpRdWVyeS5hY3RpdmUgKSApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RvcFwiICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4ganFYSFI7XG5cdH0sXG5cblx0Z2V0SlNPTjogZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5nZXQoIHVybCwgZGF0YSwgY2FsbGJhY2ssIFwianNvblwiICk7XG5cdH0sXG5cblx0Z2V0U2NyaXB0OiBmdW5jdGlvbiggdXJsLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCB1bmRlZmluZWQsIGNhbGxiYWNrLCBcInNjcmlwdFwiICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJnZXRcIiwgXCJwb3N0XCIgXSwgZnVuY3Rpb24oIF9pLCBtZXRob2QgKSB7XG5cdGpRdWVyeVsgbWV0aG9kIF0gPSBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjaywgdHlwZSApIHtcblxuXHRcdC8vIFNoaWZ0IGFyZ3VtZW50cyBpZiBkYXRhIGFyZ3VtZW50IHdhcyBvbWl0dGVkXG5cdFx0aWYgKCBpc0Z1bmN0aW9uKCBkYXRhICkgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBjYWxsYmFjaztcblx0XHRcdGNhbGxiYWNrID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gVGhlIHVybCBjYW4gYmUgYW4gb3B0aW9ucyBvYmplY3QgKHdoaWNoIHRoZW4gbXVzdCBoYXZlIC51cmwpXG5cdFx0cmV0dXJuIGpRdWVyeS5hamF4KCBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHR1cmw6IHVybCxcblx0XHRcdHR5cGU6IG1ldGhvZCxcblx0XHRcdGRhdGFUeXBlOiB0eXBlLFxuXHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdHN1Y2Nlc3M6IGNhbGxiYWNrXG5cdFx0fSwgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHVybCApICYmIHVybCApICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0dmFyIGk7XG5cdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdGlmICggaS50b0xvd2VyQ2FzZSgpID09PSBcImNvbnRlbnQtdHlwZVwiICkge1xuXHRcdFx0cy5jb250ZW50VHlwZSA9IHMuaGVhZGVyc1sgaSBdIHx8IFwiXCI7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5Ll9ldmFsVXJsID0gZnVuY3Rpb24oIHVybCwgb3B0aW9ucywgZG9jICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0Y2FjaGU6IHRydWUsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cblx0XHQvLyBPbmx5IGV2YWx1YXRlIHRoZSByZXNwb25zZSBpZiBpdCBpcyBzdWNjZXNzZnVsIChnaC00MTI2KVxuXHRcdC8vIGRhdGFGaWx0ZXIgaXMgbm90IGludm9rZWQgZm9yIGZhaWx1cmUgcmVzcG9uc2VzLCBzbyB1c2luZyBpdCBpbnN0ZWFkXG5cdFx0Ly8gb2YgdGhlIGRlZmF1bHQgY29udmVydGVyIGlzIGtsdWRneSBidXQgaXQgd29ya3MuXG5cdFx0Y29udmVydGVyczoge1xuXHRcdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbigpIHt9XG5cdFx0fSxcblx0XHRkYXRhRmlsdGVyOiBmdW5jdGlvbiggcmVzcG9uc2UgKSB7XG5cdFx0XHRqUXVlcnkuZ2xvYmFsRXZhbCggcmVzcG9uc2UsIG9wdGlvbnMsIGRvYyApO1xuXHRcdH1cblx0fSApO1xufTtcblxuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHdyYXBBbGw6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdHZhciB3cmFwO1xuXG5cdFx0aWYgKCB0aGlzWyAwIF0gKSB7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24oIGh0bWwgKSApIHtcblx0XHRcdFx0aHRtbCA9IGh0bWwuY2FsbCggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRoZSBlbGVtZW50cyB0byB3cmFwIHRoZSB0YXJnZXQgYXJvdW5kXG5cdFx0XHR3cmFwID0galF1ZXJ5KCBodG1sLCB0aGlzWyAwIF0ub3duZXJEb2N1bWVudCApLmVxKCAwICkuY2xvbmUoIHRydWUgKTtcblxuXHRcdFx0aWYgKCB0aGlzWyAwIF0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0d3JhcC5pbnNlcnRCZWZvcmUoIHRoaXNbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHR3cmFwLm1hcCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBlbGVtID0gdGhpcztcblxuXHRcdFx0XHR3aGlsZSAoIGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQgKSB7XG5cdFx0XHRcdFx0ZWxlbSA9IGVsZW0uZmlyc3RFbGVtZW50Q2hpbGQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gZWxlbTtcblx0XHRcdH0gKS5hcHBlbmQoIHRoaXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR3cmFwSW5uZXI6IGZ1bmN0aW9uKCBodG1sICkge1xuXHRcdGlmICggaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaHRtbElzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGh0bWxJc0Z1bmN0aW9uID8gaHRtbC5jYWxsKCB0aGlzLCBpICkgOiBodG1sICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdHVud3JhcDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHRoaXMucGFyZW50KCBzZWxlY3RvciApLm5vdCggXCJib2R5XCIgKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLnJlcGxhY2VXaXRoKCB0aGlzLmNoaWxkTm9kZXMgKTtcblx0XHR9ICk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0gKTtcblxuXG5qUXVlcnkuZXhwci5wc2V1ZG9zLmhpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gIWpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSggZWxlbSApO1xufTtcbmpRdWVyeS5leHByLnBzZXVkb3MudmlzaWJsZSA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4gISEoIGVsZW0ub2Zmc2V0V2lkdGggfHwgZWxlbS5vZmZzZXRIZWlnaHQgfHwgZWxlbS5nZXRDbGllbnRSZWN0cygpLmxlbmd0aCApO1xufTtcblxuXG5cblxualF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIgPSBmdW5jdGlvbigpIHtcblx0dHJ5IHtcblx0XHRyZXR1cm4gbmV3IHdpbmRvdy5YTUxIdHRwUmVxdWVzdCgpO1xuXHR9IGNhdGNoICggZSApIHt9XG59O1xuXG52YXIgeGhyU3VjY2Vzc1N0YXR1cyA9IHtcblxuXHRcdC8vIEZpbGUgcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgY29kZSAwLCBhc3N1bWUgMjAwXG5cdFx0MDogMjAwLFxuXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHQvLyAjMTQ1MDogc29tZXRpbWVzIElFIHJldHVybnMgMTIyMyB3aGVuIGl0IHNob3VsZCBiZSAyMDRcblx0XHQxMjIzOiAyMDRcblx0fSxcblx0eGhyU3VwcG9ydGVkID0galF1ZXJ5LmFqYXhTZXR0aW5ncy54aHIoKTtcblxuc3VwcG9ydC5jb3JzID0gISF4aHJTdXBwb3J0ZWQgJiYgKCBcIndpdGhDcmVkZW50aWFsc1wiIGluIHhoclN1cHBvcnRlZCApO1xuc3VwcG9ydC5hamF4ID0geGhyU3VwcG9ydGVkID0gISF4aHJTdXBwb3J0ZWQ7XG5cbmpRdWVyeS5hamF4VHJhbnNwb3J0KCBmdW5jdGlvbiggb3B0aW9ucyApIHtcblx0dmFyIGNhbGxiYWNrLCBlcnJvckNhbGxiYWNrO1xuXG5cdC8vIENyb3NzIGRvbWFpbiBvbmx5IGFsbG93ZWQgaWYgc3VwcG9ydGVkIHRocm91Z2ggWE1MSHR0cFJlcXVlc3Rcblx0aWYgKCBzdXBwb3J0LmNvcnMgfHwgeGhyU3VwcG9ydGVkICYmICFvcHRpb25zLmNyb3NzRG9tYWluICkge1xuXHRcdHJldHVybiB7XG5cdFx0XHRzZW5kOiBmdW5jdGlvbiggaGVhZGVycywgY29tcGxldGUgKSB7XG5cdFx0XHRcdHZhciBpLFxuXHRcdFx0XHRcdHhociA9IG9wdGlvbnMueGhyKCk7XG5cblx0XHRcdFx0eGhyLm9wZW4oXG5cdFx0XHRcdFx0b3B0aW9ucy50eXBlLFxuXHRcdFx0XHRcdG9wdGlvbnMudXJsLFxuXHRcdFx0XHRcdG9wdGlvbnMuYXN5bmMsXG5cdFx0XHRcdFx0b3B0aW9ucy51c2VybmFtZSxcblx0XHRcdFx0XHRvcHRpb25zLnBhc3N3b3JkXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gQXBwbHkgY3VzdG9tIGZpZWxkcyBpZiBwcm92aWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMueGhyRmllbGRzICkge1xuXHRcdFx0XHRcdGZvciAoIGkgaW4gb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0XHR4aHJbIGkgXSA9IG9wdGlvbnMueGhyRmllbGRzWyBpIF07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gT3ZlcnJpZGUgbWltZSB0eXBlIGlmIG5lZWRlZFxuXHRcdFx0XHRpZiAoIG9wdGlvbnMubWltZVR5cGUgJiYgeGhyLm92ZXJyaWRlTWltZVR5cGUgKSB7XG5cdFx0XHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoIG9wdGlvbnMubWltZVR5cGUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFgtUmVxdWVzdGVkLVdpdGggaGVhZGVyXG5cdFx0XHRcdC8vIEZvciBjcm9zcy1kb21haW4gcmVxdWVzdHMsIHNlZWluZyBhcyBjb25kaXRpb25zIGZvciBhIHByZWZsaWdodCBhcmVcblx0XHRcdFx0Ly8gYWtpbiB0byBhIGppZ3NhdyBwdXp6bGUsIHdlIHNpbXBseSBuZXZlciBzZXQgaXQgdG8gYmUgc3VyZS5cblx0XHRcdFx0Ly8gKGl0IGNhbiBhbHdheXMgYmUgc2V0IG9uIGEgcGVyLXJlcXVlc3QgYmFzaXMgb3IgZXZlbiB1c2luZyBhamF4U2V0dXApXG5cdFx0XHRcdC8vIEZvciBzYW1lLWRvbWFpbiByZXF1ZXN0cywgd29uJ3QgY2hhbmdlIGhlYWRlciBpZiBhbHJlYWR5IHByb3ZpZGVkLlxuXHRcdFx0XHRpZiAoICFvcHRpb25zLmNyb3NzRG9tYWluICYmICFoZWFkZXJzWyBcIlgtUmVxdWVzdGVkLVdpdGhcIiBdICkge1xuXHRcdFx0XHRcdGhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gPSBcIlhNTEh0dHBSZXF1ZXN0XCI7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBTZXQgaGVhZGVyc1xuXHRcdFx0XHRmb3IgKCBpIGluIGhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0eGhyLnNldFJlcXVlc3RIZWFkZXIoIGksIGhlYWRlcnNbIGkgXSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQ2FsbGJhY2tcblx0XHRcdFx0Y2FsbGJhY2sgPSBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRjYWxsYmFjayA9IGVycm9yQ2FsbGJhY2sgPSB4aHIub25sb2FkID1cblx0XHRcdFx0XHRcdFx0XHR4aHIub25lcnJvciA9IHhoci5vbmFib3J0ID0geGhyLm9udGltZW91dCA9XG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHQvLyBPbiBhIG1hbnVhbCBuYXRpdmUgYWJvcnQsIElFOSB0aHJvd3Ncblx0XHRcdFx0XHRcdFx0XHQvLyBlcnJvcnMgb24gYW55IHByb3BlcnR5IGFjY2VzcyB0aGF0IGlzIG5vdCByZWFkeVN0YXRlXG5cdFx0XHRcdFx0XHRcdFx0aWYgKCB0eXBlb2YgeGhyLnN0YXR1cyAhPT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCAwLCBcImVycm9yXCIgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y29tcGxldGUoXG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gRmlsZTogcHJvdG9jb2wgYWx3YXlzIHlpZWxkcyBzdGF0dXMgMDsgc2VlICM4NjA1LCAjMTQyMDdcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1cyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHRcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyU3VjY2Vzc1N0YXR1c1sgeGhyLnN0YXR1cyBdIHx8IHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHR4aHIuc3RhdHVzVGV4dCxcblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD05IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdC8vIElFOSBoYXMgbm8gWEhSMiBidXQgdGhyb3dzIG9uIGJpbmFyeSAodHJhYy0xMTQyNilcblx0XHRcdFx0XHRcdFx0XHRcdC8vIEZvciBYSFIyIG5vbi10ZXh0LCBsZXQgdGhlIGNhbGxlciBoYW5kbGUgaXQgKGdoLTI0OTgpXG5cdFx0XHRcdFx0XHRcdFx0XHQoIHhoci5yZXNwb25zZVR5cGUgfHwgXCJ0ZXh0XCIgKSAhPT0gXCJ0ZXh0XCIgIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHR0eXBlb2YgeGhyLnJlc3BvbnNlVGV4dCAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgYmluYXJ5OiB4aHIucmVzcG9uc2UgfSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHsgdGV4dDogeGhyLnJlc3BvbnNlVGV4dCB9LFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpXG5cdFx0XHRcdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH07XG5cblx0XHRcdFx0Ly8gTGlzdGVuIHRvIGV2ZW50c1xuXHRcdFx0XHR4aHIub25sb2FkID0gY2FsbGJhY2soKTtcblx0XHRcdFx0ZXJyb3JDYWxsYmFjayA9IHhoci5vbmVycm9yID0geGhyLm9udGltZW91dCA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA5IG9ubHlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gUHJldmVudCBhdXRvLWV4ZWN1dGlvbiBvZiBzY3JpcHRzIHdoZW4gbm8gZXhwbGljaXQgZGF0YVR5cGUgd2FzIHByb3ZpZGVkIChTZWUgZ2gtMjQzMilcbmpRdWVyeS5hamF4UHJlZmlsdGVyKCBmdW5jdGlvbiggcyApIHtcblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMuY29udGVudHMuc2NyaXB0ID0gZmFsc2U7XG5cdH1cbn0gKTtcblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiBvciBmb3JjZWQtYnktYXR0cnMgcmVxdWVzdHNcblx0aWYgKCBzLmNyb3NzRG9tYWluIHx8IHMuc2NyaXB0QXR0cnMgKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKVxuXHRcdFx0XHRcdC5hdHRyKCBzLnNjcmlwdEF0dHJzIHx8IHt9IClcblx0XHRcdFx0XHQucHJvcCggeyBjaGFyc2V0OiBzLnNjcmlwdENoYXJzZXQsIHNyYzogcy51cmwgfSApXG5cdFx0XHRcdFx0Lm9uKCBcImxvYWQgZXJyb3JcIiwgY2FsbGJhY2sgPSBmdW5jdGlvbiggZXZ0ICkge1xuXHRcdFx0XHRcdFx0c2NyaXB0LnJlbW92ZSgpO1xuXHRcdFx0XHRcdFx0Y2FsbGJhY2sgPSBudWxsO1xuXHRcdFx0XHRcdFx0aWYgKCBldnQgKSB7XG5cdFx0XHRcdFx0XHRcdGNvbXBsZXRlKCBldnQudHlwZSA9PT0gXCJlcnJvclwiID8gNDA0IDogMjAwLCBldnQudHlwZSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gKTtcblxuXHRcdFx0XHQvLyBVc2UgbmF0aXZlIERPTSBtYW5pcHVsYXRpb24gdG8gYXZvaWQgb3VyIGRvbU1hbmlwIEFKQVggdHJpY2tlcnlcblx0XHRcdFx0ZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZCggc2NyaXB0WyAwIF0gKTtcblx0XHRcdH0sXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxudmFyIG9sZENhbGxiYWNrcyA9IFtdLFxuXHRyanNvbnAgPSAvKD0pXFw/KD89JnwkKXxcXD9cXD8vO1xuXG4vLyBEZWZhdWx0IGpzb25wIHNldHRpbmdzXG5qUXVlcnkuYWpheFNldHVwKCB7XG5cdGpzb25wOiBcImNhbGxiYWNrXCIsXG5cdGpzb25wQ2FsbGJhY2s6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjYWxsYmFjayA9IG9sZENhbGxiYWNrcy5wb3AoKSB8fCAoIGpRdWVyeS5leHBhbmRvICsgXCJfXCIgKyAoIG5vbmNlLmd1aWQrKyApICk7XG5cdFx0dGhpc1sgY2FsbGJhY2sgXSA9IHRydWU7XG5cdFx0cmV0dXJuIGNhbGxiYWNrO1xuXHR9XG59ICk7XG5cbi8vIERldGVjdCwgbm9ybWFsaXplIG9wdGlvbnMgYW5kIGluc3RhbGwgY2FsbGJhY2tzIGZvciBqc29ucCByZXF1ZXN0c1xualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwianNvbiBqc29ucFwiLCBmdW5jdGlvbiggcywgb3JpZ2luYWxTZXR0aW5ncywganFYSFIgKSB7XG5cblx0dmFyIGNhbGxiYWNrTmFtZSwgb3ZlcndyaXR0ZW4sIHJlc3BvbnNlQ29udGFpbmVyLFxuXHRcdGpzb25Qcm9wID0gcy5qc29ucCAhPT0gZmFsc2UgJiYgKCByanNvbnAudGVzdCggcy51cmwgKSA/XG5cdFx0XHRcInVybFwiIDpcblx0XHRcdHR5cGVvZiBzLmRhdGEgPT09IFwic3RyaW5nXCIgJiZcblx0XHRcdFx0KCBzLmNvbnRlbnRUeXBlIHx8IFwiXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiICkgPT09IDAgJiZcblx0XHRcdFx0cmpzb25wLnRlc3QoIHMuZGF0YSApICYmIFwiZGF0YVwiXG5cdFx0KTtcblxuXHQvLyBIYW5kbGUgaWZmIHRoZSBleHBlY3RlZCBkYXRhIHR5cGUgaXMgXCJqc29ucFwiIG9yIHdlIGhhdmUgYSBwYXJhbWV0ZXIgdG8gc2V0XG5cdGlmICgganNvblByb3AgfHwgcy5kYXRhVHlwZXNbIDAgXSA9PT0gXCJqc29ucFwiICkge1xuXG5cdFx0Ly8gR2V0IGNhbGxiYWNrIG5hbWUsIHJlbWVtYmVyaW5nIHByZWV4aXN0aW5nIHZhbHVlIGFzc29jaWF0ZWQgd2l0aCBpdFxuXHRcdGNhbGxiYWNrTmFtZSA9IHMuanNvbnBDYWxsYmFjayA9IGlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBpc0Z1bmN0aW9uKCBvdmVyd3JpdHRlbiApICkge1xuXHRcdFx0XHRvdmVyd3JpdHRlbiggcmVzcG9uc2VDb250YWluZXJbIDAgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IG92ZXJ3cml0dGVuID0gdW5kZWZpbmVkO1xuXHRcdH0gKTtcblxuXHRcdC8vIERlbGVnYXRlIHRvIHNjcmlwdFxuXHRcdHJldHVybiBcInNjcmlwdFwiO1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFN1cHBvcnQ6IFNhZmFyaSA4IG9ubHlcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIFtdO1xuXHR9XG5cdGlmICggdHlwZW9mIGNvbnRleHQgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdGtlZXBTY3JpcHRzID0gY29udGV4dDtcblx0XHRjb250ZXh0ID0gZmFsc2U7XG5cdH1cblxuXHR2YXIgYmFzZSwgcGFyc2VkLCBzY3JpcHRzO1xuXG5cdGlmICggIWNvbnRleHQgKSB7XG5cblx0XHQvLyBTdG9wIHNjcmlwdHMgb3IgaW5saW5lIGV2ZW50IGhhbmRsZXJzIGZyb20gYmVpbmcgZXhlY3V0ZWQgaW1tZWRpYXRlbHlcblx0XHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRcdGlmICggc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgKSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQuaW1wbGVtZW50YXRpb24uY3JlYXRlSFRNTERvY3VtZW50KCBcIlwiICk7XG5cblx0XHRcdC8vIFNldCB0aGUgYmFzZSBocmVmIGZvciB0aGUgY3JlYXRlZCBkb2N1bWVudFxuXHRcdFx0Ly8gc28gYW55IHBhcnNlZCBlbGVtZW50cyB3aXRoIFVSTHNcblx0XHRcdC8vIGFyZSBiYXNlZCBvbiB0aGUgZG9jdW1lbnQncyBVUkwgKGdoLTI5NjUpXG5cdFx0XHRiYXNlID0gY29udGV4dC5jcmVhdGVFbGVtZW50KCBcImJhc2VcIiApO1xuXHRcdFx0YmFzZS5ocmVmID0gZG9jdW1lbnQubG9jYXRpb24uaHJlZjtcblx0XHRcdGNvbnRleHQuaGVhZC5hcHBlbmRDaGlsZCggYmFzZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb250ZXh0ID0gZG9jdW1lbnQ7XG5cdFx0fVxuXHR9XG5cblx0cGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICk7XG5cdHNjcmlwdHMgPSAha2VlcFNjcmlwdHMgJiYgW107XG5cblx0Ly8gU2luZ2xlIHRhZ1xuXHRpZiAoIHBhcnNlZCApIHtcblx0XHRyZXR1cm4gWyBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIHBhcnNlZFsgMSBdICkgXTtcblx0fVxuXG5cdHBhcnNlZCA9IGJ1aWxkRnJhZ21lbnQoIFsgZGF0YSBdLCBjb250ZXh0LCBzY3JpcHRzICk7XG5cblx0aWYgKCBzY3JpcHRzICYmIHNjcmlwdHMubGVuZ3RoICkge1xuXHRcdGpRdWVyeSggc2NyaXB0cyApLnJlbW92ZSgpO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5tZXJnZSggW10sIHBhcnNlZC5jaGlsZE5vZGVzICk7XG59O1xuXG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdHZhciBzZWxlY3RvciwgdHlwZSwgcmVzcG9uc2UsXG5cdFx0c2VsZiA9IHRoaXMsXG5cdFx0b2ZmID0gdXJsLmluZGV4T2YoIFwiIFwiICk7XG5cblx0aWYgKCBvZmYgPiAtMSApIHtcblx0XHRzZWxlY3RvciA9IHN0cmlwQW5kQ29sbGFwc2UoIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggaXNGdW5jdGlvbiggcGFyYW1zICkgKSB7XG5cblx0XHQvLyBXZSBhc3N1bWUgdGhhdCBpdCdzIHRoZSBjYWxsYmFja1xuXHRcdGNhbGxiYWNrID0gcGFyYW1zO1xuXHRcdHBhcmFtcyA9IHVuZGVmaW5lZDtcblxuXHQvLyBPdGhlcndpc2UsIGJ1aWxkIGEgcGFyYW0gc3RyaW5nXG5cdH0gZWxzZSBpZiAoIHBhcmFtcyAmJiB0eXBlb2YgcGFyYW1zID09PSBcIm9iamVjdFwiICkge1xuXHRcdHR5cGUgPSBcIlBPU1RcIjtcblx0fVxuXG5cdC8vIElmIHdlIGhhdmUgZWxlbWVudHMgdG8gbW9kaWZ5LCBtYWtlIHRoZSByZXF1ZXN0XG5cdGlmICggc2VsZi5sZW5ndGggPiAwICkge1xuXHRcdGpRdWVyeS5hamF4KCB7XG5cdFx0XHR1cmw6IHVybCxcblxuXHRcdFx0Ly8gSWYgXCJ0eXBlXCIgdmFyaWFibGUgaXMgdW5kZWZpbmVkLCB0aGVuIFwiR0VUXCIgbWV0aG9kIHdpbGwgYmUgdXNlZC5cblx0XHRcdC8vIE1ha2UgdmFsdWUgb2YgdGhpcyBmaWVsZCBleHBsaWNpdCBzaW5jZVxuXHRcdFx0Ly8gdXNlciBjYW4gb3ZlcnJpZGUgaXQgdGhyb3VnaCBhamF4U2V0dXAgbWV0aG9kXG5cdFx0XHR0eXBlOiB0eXBlIHx8IFwiR0VUXCIsXG5cdFx0XHRkYXRhVHlwZTogXCJodG1sXCIsXG5cdFx0XHRkYXRhOiBwYXJhbXNcblx0XHR9ICkuZG9uZSggZnVuY3Rpb24oIHJlc3BvbnNlVGV4dCApIHtcblxuXHRcdFx0Ly8gU2F2ZSByZXNwb25zZSBmb3IgdXNlIGluIGNvbXBsZXRlIGNhbGxiYWNrXG5cdFx0XHRyZXNwb25zZSA9IGFyZ3VtZW50cztcblxuXHRcdFx0c2VsZi5odG1sKCBzZWxlY3RvciA/XG5cblx0XHRcdFx0Ly8gSWYgYSBzZWxlY3RvciB3YXMgc3BlY2lmaWVkLCBsb2NhdGUgdGhlIHJpZ2h0IGVsZW1lbnRzIGluIGEgZHVtbXkgZGl2XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgc2NyaXB0cyB0byBhdm9pZCBJRSAnUGVybWlzc2lvbiBEZW5pZWQnIGVycm9yc1xuXHRcdFx0XHRqUXVlcnkoIFwiPGRpdj5cIiApLmFwcGVuZCggalF1ZXJ5LnBhcnNlSFRNTCggcmVzcG9uc2VUZXh0ICkgKS5maW5kKCBzZWxlY3RvciApIDpcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgdXNlIHRoZSBmdWxsIHJlc3VsdFxuXHRcdFx0XHRyZXNwb25zZVRleHQgKTtcblxuXHRcdC8vIElmIHRoZSByZXF1ZXN0IHN1Y2NlZWRzLCB0aGlzIGZ1bmN0aW9uIGdldHMgXCJkYXRhXCIsIFwic3RhdHVzXCIsIFwianFYSFJcIlxuXHRcdC8vIGJ1dCB0aGV5IGFyZSBpZ25vcmVkIGJlY2F1c2UgcmVzcG9uc2Ugd2FzIHNldCBhYm92ZS5cblx0XHQvLyBJZiBpdCBmYWlscywgdGhpcyBmdW5jdGlvbiBnZXRzIFwianFYSFJcIiwgXCJzdGF0dXNcIiwgXCJlcnJvclwiXG5cdFx0fSApLmFsd2F5cyggY2FsbGJhY2sgJiYgZnVuY3Rpb24oIGpxWEhSLCBzdGF0dXMgKSB7XG5cdFx0XHRzZWxmLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRjYWxsYmFjay5hcHBseSggdGhpcywgcmVzcG9uc2UgfHwgWyBqcVhIUi5yZXNwb25zZVRleHQsIHN0YXR1cywganFYSFIgXSApO1xuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdHJldHVybiB0aGlzO1xufTtcblxuXG5cblxualF1ZXJ5LmV4cHIucHNldWRvcy5hbmltYXRlZCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRyZXR1cm4galF1ZXJ5LmdyZXAoIGpRdWVyeS50aW1lcnMsIGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gZWxlbSA9PT0gZm4uZWxlbTtcblx0fSApLmxlbmd0aDtcbn07XG5cblxuXG5cbmpRdWVyeS5vZmZzZXQgPSB7XG5cdHNldE9mZnNldDogZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGkgKSB7XG5cdFx0dmFyIGN1clBvc2l0aW9uLCBjdXJMZWZ0LCBjdXJDU1NUb3AsIGN1clRvcCwgY3VyT2Zmc2V0LCBjdXJDU1NMZWZ0LCBjYWxjdWxhdGVQb3NpdGlvbixcblx0XHRcdHBvc2l0aW9uID0galF1ZXJ5LmNzcyggZWxlbSwgXCJwb3NpdGlvblwiICksXG5cdFx0XHRjdXJFbGVtID0galF1ZXJ5KCBlbGVtICksXG5cdFx0XHRwcm9wcyA9IHt9O1xuXG5cdFx0Ly8gU2V0IHBvc2l0aW9uIGZpcnN0LCBpbi1jYXNlIHRvcC9sZWZ0IGFyZSBzZXQgZXZlbiBvbiBzdGF0aWMgZWxlbVxuXHRcdGlmICggcG9zaXRpb24gPT09IFwic3RhdGljXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLnBvc2l0aW9uID0gXCJyZWxhdGl2ZVwiO1xuXHRcdH1cblxuXHRcdGN1ck9mZnNldCA9IGN1ckVsZW0ub2Zmc2V0KCk7XG5cdFx0Y3VyQ1NTVG9wID0galF1ZXJ5LmNzcyggZWxlbSwgXCJ0b3BcIiApO1xuXHRcdGN1ckNTU0xlZnQgPSBqUXVlcnkuY3NzKCBlbGVtLCBcImxlZnRcIiApO1xuXHRcdGNhbGN1bGF0ZVBvc2l0aW9uID0gKCBwb3NpdGlvbiA9PT0gXCJhYnNvbHV0ZVwiIHx8IHBvc2l0aW9uID09PSBcImZpeGVkXCIgKSAmJlxuXHRcdFx0KCBjdXJDU1NUb3AgKyBjdXJDU1NMZWZ0ICkuaW5kZXhPZiggXCJhdXRvXCIgKSA+IC0xO1xuXG5cdFx0Ly8gTmVlZCB0byBiZSBhYmxlIHRvIGNhbGN1bGF0ZSBwb3NpdGlvbiBpZiBlaXRoZXJcblx0XHQvLyB0b3Agb3IgbGVmdCBpcyBhdXRvIGFuZCBwb3NpdGlvbiBpcyBlaXRoZXIgYWJzb2x1dGUgb3IgZml4ZWRcblx0XHRpZiAoIGNhbGN1bGF0ZVBvc2l0aW9uICkge1xuXHRcdFx0Y3VyUG9zaXRpb24gPSBjdXJFbGVtLnBvc2l0aW9uKCk7XG5cdFx0XHRjdXJUb3AgPSBjdXJQb3NpdGlvbi50b3A7XG5cdFx0XHRjdXJMZWZ0ID0gY3VyUG9zaXRpb24ubGVmdDtcblxuXHRcdH0gZWxzZSB7XG5cdFx0XHRjdXJUb3AgPSBwYXJzZUZsb2F0KCBjdXJDU1NUb3AgKSB8fCAwO1xuXHRcdFx0Y3VyTGVmdCA9IHBhcnNlRmxvYXQoIGN1ckNTU0xlZnQgKSB8fCAwO1xuXHRcdH1cblxuXHRcdGlmICggaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmICggdHlwZW9mIHByb3BzLnRvcCA9PT0gXCJudW1iZXJcIiApIHtcblx0XHRcdFx0cHJvcHMudG9wICs9IFwicHhcIjtcblx0XHRcdH1cblx0XHRcdGlmICggdHlwZW9mIHByb3BzLmxlZnQgPT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdHByb3BzLmxlZnQgKz0gXCJweFwiO1xuXHRcdFx0fVxuXHRcdFx0Y3VyRWxlbS5jc3MoIHByb3BzICk7XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gb2Zmc2V0KCkgcmVsYXRlcyBhbiBlbGVtZW50J3MgYm9yZGVyIGJveCB0byB0aGUgZG9jdW1lbnQgb3JpZ2luXG5cdG9mZnNldDogZnVuY3Rpb24oIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBQcmVzZXJ2ZSBjaGFpbmluZyBmb3Igc2V0dGVyXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHRcdHRoaXMgOlxuXHRcdFx0XHR0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRcdGpRdWVyeS5vZmZzZXQuc2V0T2Zmc2V0KCB0aGlzLCBvcHRpb25zLCBpICk7XG5cdFx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHR2YXIgcmVjdCwgd2luLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWVsZW0gKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHplcm9zIGZvciBkaXNjb25uZWN0ZWQgYW5kIGhpZGRlbiAoZGlzcGxheTogbm9uZSkgZWxlbWVudHMgKGdoLTIzMTApXG5cdFx0Ly8gU3VwcG9ydDogSUUgPD0xMSBvbmx5XG5cdFx0Ly8gUnVubmluZyBnZXRCb3VuZGluZ0NsaWVudFJlY3Qgb24gYVxuXHRcdC8vIGRpc2Nvbm5lY3RlZCBub2RlIGluIElFIHRocm93cyBhbiBlcnJvclxuXHRcdGlmICggIWVsZW0uZ2V0Q2xpZW50UmVjdHMoKS5sZW5ndGggKSB7XG5cdFx0XHRyZXR1cm4geyB0b3A6IDAsIGxlZnQ6IDAgfTtcblx0XHR9XG5cblx0XHQvLyBHZXQgZG9jdW1lbnQtcmVsYXRpdmUgcG9zaXRpb24gYnkgYWRkaW5nIHZpZXdwb3J0IHNjcm9sbCB0byB2aWV3cG9ydC1yZWxhdGl2ZSBnQkNSXG5cdFx0cmVjdCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cdFx0d2luID0gZWxlbS5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3O1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IHJlY3QudG9wICsgd2luLnBhZ2VZT2Zmc2V0LFxuXHRcdFx0bGVmdDogcmVjdC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0XG5cdFx0fTtcblx0fSxcblxuXHQvLyBwb3NpdGlvbigpIHJlbGF0ZXMgYW4gZWxlbWVudCdzIG1hcmdpbiBib3ggdG8gaXRzIG9mZnNldCBwYXJlbnQncyBwYWRkaW5nIGJveFxuXHQvLyBUaGlzIGNvcnJlc3BvbmRzIHRvIHRoZSBiZWhhdmlvciBvZiBDU1MgYWJzb2x1dGUgcG9zaXRpb25pbmdcblx0cG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggIXRoaXNbIDAgXSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR2YXIgb2Zmc2V0UGFyZW50LCBvZmZzZXQsIGRvYyxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gcG9zaXRpb246Zml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHRoZSB2aWV3cG9ydCwgd2hpY2ggaXRzZWxmIGFsd2F5cyBoYXMgemVybyBvZmZzZXRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBwb3NpdGlvbjpmaXhlZCBpbXBsaWVzIGF2YWlsYWJpbGl0eSBvZiBnZXRCb3VuZGluZ0NsaWVudFJlY3Rcblx0XHRcdG9mZnNldCA9IGVsZW0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG5cblx0XHR9IGVsc2Uge1xuXHRcdFx0b2Zmc2V0ID0gdGhpcy5vZmZzZXQoKTtcblxuXHRcdFx0Ly8gQWNjb3VudCBmb3IgdGhlICpyZWFsKiBvZmZzZXQgcGFyZW50LCB3aGljaCBjYW4gYmUgdGhlIGRvY3VtZW50IG9yIGl0cyByb290IGVsZW1lbnRcblx0XHRcdC8vIHdoZW4gYSBzdGF0aWNhbGx5IHBvc2l0aW9uZWQgZWxlbWVudCBpcyBpZGVudGlmaWVkXG5cdFx0XHRkb2MgPSBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSBlbGVtLm9mZnNldFBhcmVudCB8fCBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0d2hpbGUgKCBvZmZzZXRQYXJlbnQgJiZcblx0XHRcdFx0KCBvZmZzZXRQYXJlbnQgPT09IGRvYy5ib2R5IHx8IG9mZnNldFBhcmVudCA9PT0gZG9jLmRvY3VtZW50RWxlbWVudCApICYmXG5cdFx0XHRcdGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJwb3NpdGlvblwiICkgPT09IFwic3RhdGljXCIgKSB7XG5cblx0XHRcdFx0b2Zmc2V0UGFyZW50ID0gb2Zmc2V0UGFyZW50LnBhcmVudE5vZGU7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQgIT09IGVsZW0gJiYgb2Zmc2V0UGFyZW50Lm5vZGVUeXBlID09PSAxICkge1xuXG5cdFx0XHRcdC8vIEluY29ycG9yYXRlIGJvcmRlcnMgaW50byBpdHMgb2Zmc2V0LCBzaW5jZSB0aGV5IGFyZSBvdXRzaWRlIGl0cyBjb250ZW50IG9yaWdpblxuXHRcdFx0XHRwYXJlbnRPZmZzZXQgPSBqUXVlcnkoIG9mZnNldFBhcmVudCApLm9mZnNldCgpO1xuXHRcdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJUb3BXaWR0aFwiLCB0cnVlICk7XG5cdFx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudCwgXCJib3JkZXJMZWZ0V2lkdGhcIiwgdHJ1ZSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXG5cdFx0XHQvLyBDb2FsZXNjZSBkb2N1bWVudHMgYW5kIHdpbmRvd3Ncblx0XHRcdHZhciB3aW47XG5cdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cdFx0XHRcdHdpbiA9IGVsZW07XG5cdFx0XHR9IGVsc2UgaWYgKCBlbGVtLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHR3aW4gPSBlbGVtLmRlZmF1bHRWaWV3O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmkgPD03IC0gOS4xLCBDaHJvbWUgPD0zNyAtIDQ5XG4vLyBBZGQgdGhlIHRvcC9sZWZ0IGNzc0hvb2tzIHVzaW5nIGpRdWVyeS5mbi5wb3NpdGlvblxuLy8gV2Via2l0IGJ1ZzogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTI5MDg0XG4vLyBCbGluayBidWc6IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTU4OTM0N1xuLy8gZ2V0Q29tcHV0ZWRTdHlsZSByZXR1cm5zIHBlcmNlbnQgd2hlbiBzcGVjaWZpZWQgZm9yIHRvcC9sZWZ0L2JvdHRvbS9yaWdodDtcbi8vIHJhdGhlciB0aGFuIG1ha2UgdGhlIGNzcyBtb2R1bGUgZGVwZW5kIG9uIHRoZSBvZmZzZXQgbW9kdWxlLCBqdXN0IGNoZWNrIGZvciBpdCBoZXJlXG5qUXVlcnkuZWFjaCggWyBcInRvcFwiLCBcImxlZnRcIiBdLCBmdW5jdGlvbiggX2ksIHByb3AgKSB7XG5cdGpRdWVyeS5jc3NIb29rc1sgcHJvcCBdID0gYWRkR2V0SG9va0lmKCBzdXBwb3J0LnBpeGVsUG9zaXRpb24sXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbXB1dGVkICkge1xuXHRcdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdFx0Y29tcHV0ZWQgPSBjdXJDU1MoIGVsZW0sIHByb3AgKTtcblxuXHRcdFx0XHQvLyBJZiBjdXJDU1MgcmV0dXJucyBwZXJjZW50YWdlLCBmYWxsYmFjayB0byBvZmZzZXRcblx0XHRcdFx0cmV0dXJuIHJudW1ub25weC50ZXN0KCBjb21wdXRlZCApID9cblx0XHRcdFx0XHRqUXVlcnkoIGVsZW0gKS5wb3NpdGlvbigpWyBwcm9wIF0gKyBcInB4XCIgOlxuXHRcdFx0XHRcdGNvbXB1dGVkO1xuXHRcdFx0fVxuXHRcdH1cblx0KTtcbn0gKTtcblxuXG4vLyBDcmVhdGUgaW5uZXJIZWlnaHQsIGlubmVyV2lkdGgsIGhlaWdodCwgd2lkdGgsIG91dGVySGVpZ2h0IGFuZCBvdXRlcldpZHRoIG1ldGhvZHNcbmpRdWVyeS5lYWNoKCB7IEhlaWdodDogXCJoZWlnaHRcIiwgV2lkdGg6IFwid2lkdGhcIiB9LCBmdW5jdGlvbiggbmFtZSwgdHlwZSApIHtcblx0alF1ZXJ5LmVhY2goIHsgcGFkZGluZzogXCJpbm5lclwiICsgbmFtZSwgY29udGVudDogdHlwZSwgXCJcIjogXCJvdXRlclwiICsgbmFtZSB9LFxuXHRcdGZ1bmN0aW9uKCBkZWZhdWx0RXh0cmEsIGZ1bmNOYW1lICkge1xuXG5cdFx0Ly8gTWFyZ2luIGlzIG9ubHkgZm9yIG91dGVySGVpZ2h0LCBvdXRlcldpZHRoXG5cdFx0alF1ZXJ5LmZuWyBmdW5jTmFtZSBdID0gZnVuY3Rpb24oIG1hcmdpbiwgdmFsdWUgKSB7XG5cdFx0XHR2YXIgY2hhaW5hYmxlID0gYXJndW1lbnRzLmxlbmd0aCAmJiAoIGRlZmF1bHRFeHRyYSB8fCB0eXBlb2YgbWFyZ2luICE9PSBcImJvb2xlYW5cIiApLFxuXHRcdFx0XHRleHRyYSA9IGRlZmF1bHRFeHRyYSB8fCAoIG1hcmdpbiA9PT0gdHJ1ZSB8fCB2YWx1ZSA9PT0gdHJ1ZSA/IFwibWFyZ2luXCIgOiBcImJvcmRlclwiICk7XG5cblx0XHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIGRvYztcblxuXHRcdFx0XHRpZiAoIGlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyAkKCB3aW5kb3cgKS5vdXRlcldpZHRoL0hlaWdodCByZXR1cm4gdy9oIGluY2x1ZGluZyBzY3JvbGxiYXJzIChnaC0xNzI5KVxuXHRcdFx0XHRcdHJldHVybiBmdW5jTmFtZS5pbmRleE9mKCBcIm91dGVyXCIgKSA9PT0gMCA/XG5cdFx0XHRcdFx0XHRlbGVtWyBcImlubmVyXCIgKyBuYW1lIF0gOlxuXHRcdFx0XHRcdFx0ZWxlbS5kb2N1bWVudC5kb2N1bWVudEVsZW1lbnRbIFwiY2xpZW50XCIgKyBuYW1lIF07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBHZXQgZG9jdW1lbnQgd2lkdGggb3IgaGVpZ2h0XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRkb2MgPSBlbGVtLmRvY3VtZW50RWxlbWVudDtcblxuXHRcdFx0XHRcdC8vIEVpdGhlciBzY3JvbGxbV2lkdGgvSGVpZ2h0XSBvciBvZmZzZXRbV2lkdGgvSGVpZ2h0XSBvciBjbGllbnRbV2lkdGgvSGVpZ2h0XSxcblx0XHRcdFx0XHQvLyB3aGljaGV2ZXIgaXMgZ3JlYXRlc3Rcblx0XHRcdFx0XHRyZXR1cm4gTWF0aC5tYXgoXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwic2Nyb2xsXCIgKyBuYW1lIF0sIGRvY1sgXCJzY3JvbGxcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGVsZW0uYm9keVsgXCJvZmZzZXRcIiArIG5hbWUgXSwgZG9jWyBcIm9mZnNldFwiICsgbmFtZSBdLFxuXHRcdFx0XHRcdFx0ZG9jWyBcImNsaWVudFwiICsgbmFtZSBdXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID9cblxuXHRcdFx0XHRcdC8vIEdldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnQsIHJlcXVlc3RpbmcgYnV0IG5vdCBmb3JjaW5nIHBhcnNlRmxvYXRcblx0XHRcdFx0XHRqUXVlcnkuY3NzKCBlbGVtLCB0eXBlLCBleHRyYSApIDpcblxuXHRcdFx0XHRcdC8vIFNldCB3aWR0aCBvciBoZWlnaHQgb24gdGhlIGVsZW1lbnRcblx0XHRcdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHR5cGUsIHZhbHVlLCBleHRyYSApO1xuXHRcdFx0fSwgdHlwZSwgY2hhaW5hYmxlID8gbWFyZ2luIDogdW5kZWZpbmVkLCBjaGFpbmFibGUgKTtcblx0XHR9O1xuXHR9ICk7XG59ICk7XG5cblxualF1ZXJ5LmVhY2goIFtcblx0XCJhamF4U3RhcnRcIixcblx0XCJhamF4U3RvcFwiLFxuXHRcImFqYXhDb21wbGV0ZVwiLFxuXHRcImFqYXhFcnJvclwiLFxuXHRcImFqYXhTdWNjZXNzXCIsXG5cdFwiYWpheFNlbmRcIlxuXSwgZnVuY3Rpb24oIF9pLCB0eXBlICkge1xuXHRqUXVlcnkuZm5bIHR5cGUgXSA9IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRyZXR1cm4gdGhpcy5vbiggdHlwZSwgZm4gKTtcblx0fTtcbn0gKTtcblxuXG5cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXG5cdGJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBudWxsLCBkYXRhLCBmbiApO1xuXHR9LFxuXHR1bmJpbmQ6IGZ1bmN0aW9uKCB0eXBlcywgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub2ZmKCB0eXBlcywgbnVsbCwgZm4gKTtcblx0fSxcblxuXHRkZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZGF0YSwgZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5kZWxlZ2F0ZTogZnVuY3Rpb24oIHNlbGVjdG9yLCB0eXBlcywgZm4gKSB7XG5cblx0XHQvLyAoIG5hbWVzcGFjZSApIG9yICggc2VsZWN0b3IsIHR5cGVzIFssIGZuXSApXG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPT09IDEgP1xuXHRcdFx0dGhpcy5vZmYoIHNlbGVjdG9yLCBcIioqXCIgKSA6XG5cdFx0XHR0aGlzLm9mZiggdHlwZXMsIHNlbGVjdG9yIHx8IFwiKipcIiwgZm4gKTtcblx0fSxcblxuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgcmVzaXplIHNjcm9sbCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggX2ksIG5hbWUgKSB7XG5cblx0XHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRcdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIGRhdGEsIGZuICkge1xuXHRcdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAwID9cblx0XHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHRcdHRoaXMudHJpZ2dlciggbmFtZSApO1xuXHRcdH07XG5cdH0gKTtcblxuXG5cblxuLy8gU3VwcG9ydDogQW5kcm9pZCA8PTQuMCBvbmx5XG4vLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1BcbnZhciBydHJpbSA9IC9eW1xcc1xcdUZFRkZcXHhBMF0rfFtcXHNcXHVGRUZGXFx4QTBdKyQvZztcblxuLy8gQmluZCBhIGZ1bmN0aW9uIHRvIGEgY29udGV4dCwgb3B0aW9uYWxseSBwYXJ0aWFsbHkgYXBwbHlpbmcgYW55XG4vLyBhcmd1bWVudHMuXG4vLyBqUXVlcnkucHJveHkgaXMgZGVwcmVjYXRlZCB0byBwcm9tb3RlIHN0YW5kYXJkcyAoc3BlY2lmaWNhbGx5IEZ1bmN0aW9uI2JpbmQpXG4vLyBIb3dldmVyLCBpdCBpcyBub3Qgc2xhdGVkIGZvciByZW1vdmFsIGFueSB0aW1lIHNvb25cbmpRdWVyeS5wcm94eSA9IGZ1bmN0aW9uKCBmbiwgY29udGV4dCApIHtcblx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHR0bXAgPSBmblsgY29udGV4dCBdO1xuXHRcdGNvbnRleHQgPSBmbjtcblx0XHRmbiA9IHRtcDtcblx0fVxuXG5cdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdC8vIHRoaXMgdGhyb3dzIGEgVHlwZUVycm9yLCBidXQgd2Ugd2lsbCBqdXN0IHJldHVybiB1bmRlZmluZWQuXG5cdGlmICggIWlzRnVuY3Rpb24oIGZuICkgKSB7XG5cdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0fVxuXG5cdC8vIFNpbXVsYXRlZCBiaW5kXG5cdGFyZ3MgPSBzbGljZS5jYWxsKCBhcmd1bWVudHMsIDIgKTtcblx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZm4uYXBwbHkoIGNvbnRleHQgfHwgdGhpcywgYXJncy5jb25jYXQoIHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApICkgKTtcblx0fTtcblxuXHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0cHJveHkuZ3VpZCA9IGZuLmd1aWQgPSBmbi5ndWlkIHx8IGpRdWVyeS5ndWlkKys7XG5cblx0cmV0dXJuIHByb3h5O1xufTtcblxualF1ZXJ5LmhvbGRSZWFkeSA9IGZ1bmN0aW9uKCBob2xkICkge1xuXHRpZiAoIGhvbGQgKSB7XG5cdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS5yZWFkeSggdHJ1ZSApO1xuXHR9XG59O1xualF1ZXJ5LmlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xualF1ZXJ5LnBhcnNlSlNPTiA9IEpTT04ucGFyc2U7XG5qUXVlcnkubm9kZU5hbWUgPSBub2RlTmFtZTtcbmpRdWVyeS5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbmpRdWVyeS5pc1dpbmRvdyA9IGlzV2luZG93O1xualF1ZXJ5LmNhbWVsQ2FzZSA9IGNhbWVsQ2FzZTtcbmpRdWVyeS50eXBlID0gdG9UeXBlO1xuXG5qUXVlcnkubm93ID0gRGF0ZS5ub3c7XG5cbmpRdWVyeS5pc051bWVyaWMgPSBmdW5jdGlvbiggb2JqICkge1xuXG5cdC8vIEFzIG9mIGpRdWVyeSAzLjAsIGlzTnVtZXJpYyBpcyBsaW1pdGVkIHRvXG5cdC8vIHN0cmluZ3MgYW5kIG51bWJlcnMgKHByaW1pdGl2ZXMgb3Igb2JqZWN0cylcblx0Ly8gdGhhdCBjYW4gYmUgY29lcmNlZCB0byBmaW5pdGUgbnVtYmVycyAoZ2gtMjY2Milcblx0dmFyIHR5cGUgPSBqUXVlcnkudHlwZSggb2JqICk7XG5cdHJldHVybiAoIHR5cGUgPT09IFwibnVtYmVyXCIgfHwgdHlwZSA9PT0gXCJzdHJpbmdcIiApICYmXG5cblx0XHQvLyBwYXJzZUZsb2F0IE5hTnMgbnVtZXJpYy1jYXN0IGZhbHNlIHBvc2l0aXZlcyAoXCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0IWlzTmFOKCBvYmogLSBwYXJzZUZsb2F0KCBvYmogKSApO1xufTtcblxualF1ZXJ5LnRyaW0gPSBmdW5jdGlvbiggdGV4dCApIHtcblx0cmV0dXJuIHRleHQgPT0gbnVsbCA/XG5cdFx0XCJcIiA6XG5cdFx0KCB0ZXh0ICsgXCJcIiApLnJlcGxhY2UoIHJ0cmltLCBcIlwiICk7XG59O1xuXG5cblxuLy8gUmVnaXN0ZXIgYXMgYSBuYW1lZCBBTUQgbW9kdWxlLCBzaW5jZSBqUXVlcnkgY2FuIGJlIGNvbmNhdGVuYXRlZCB3aXRoIG90aGVyXG4vLyBmaWxlcyB0aGF0IG1heSB1c2UgZGVmaW5lLCBidXQgbm90IHZpYSBhIHByb3BlciBjb25jYXRlbmF0aW9uIHNjcmlwdCB0aGF0XG4vLyB1bmRlcnN0YW5kcyBhbm9ueW1vdXMgQU1EIG1vZHVsZXMuIEEgbmFtZWQgQU1EIGlzIHNhZmVzdCBhbmQgbW9zdCByb2J1c3Rcbi8vIHdheSB0byByZWdpc3Rlci4gTG93ZXJjYXNlIGpxdWVyeSBpcyB1c2VkIGJlY2F1c2UgQU1EIG1vZHVsZSBuYW1lcyBhcmVcbi8vIGRlcml2ZWQgZnJvbSBmaWxlIG5hbWVzLCBhbmQgalF1ZXJ5IGlzIG5vcm1hbGx5IGRlbGl2ZXJlZCBpbiBhIGxvd2VyY2FzZVxuLy8gZmlsZSBuYW1lLiBEbyB0aGlzIGFmdGVyIGNyZWF0aW5nIHRoZSBnbG9iYWwgc28gdGhhdCBpZiBhbiBBTUQgbW9kdWxlIHdhbnRzXG4vLyB0byBjYWxsIG5vQ29uZmxpY3QgdG8gaGlkZSB0aGlzIHZlcnNpb24gb2YgalF1ZXJ5LCBpdCB3aWxsIHdvcmsuXG5cbi8vIE5vdGUgdGhhdCBmb3IgbWF4aW11bSBwb3J0YWJpbGl0eSwgbGlicmFyaWVzIHRoYXQgYXJlIG5vdCBqUXVlcnkgc2hvdWxkXG4vLyBkZWNsYXJlIHRoZW1zZWx2ZXMgYXMgYW5vbnltb3VzIG1vZHVsZXMsIGFuZCBhdm9pZCBzZXR0aW5nIGEgZ2xvYmFsIGlmIGFuXG4vLyBBTUQgbG9hZGVyIGlzIHByZXNlbnQuIGpRdWVyeSBpcyBhIHNwZWNpYWwgY2FzZS4gRm9yIG1vcmUgaW5mb3JtYXRpb24sIHNlZVxuLy8gaHR0cHM6Ly9naXRodWIuY29tL2pyYnVya2UvcmVxdWlyZWpzL3dpa2kvVXBkYXRpbmctZXhpc3RpbmctbGlicmFyaWVzI3dpa2ktYW5vblxuXG5pZiAoIHR5cGVvZiBkZWZpbmUgPT09IFwiZnVuY3Rpb25cIiAmJiBkZWZpbmUuYW1kICkge1xuXHRkZWZpbmUoIFwianF1ZXJ5XCIsIFtdLCBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4galF1ZXJ5O1xuXHR9ICk7XG59XG5cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggdHlwZW9mIG5vR2xvYmFsID09PSBcInVuZGVmaW5lZFwiICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cblxuXG5cbnJldHVybiBqUXVlcnk7XG59ICk7XG4iLCIvLyBKU1RTLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0c1xuLy8gTGljZW5zZXM6XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRURMdjEudHh0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfRVBMdjEudHh0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL0xJQ0VOU0VfTElDRU5TRV9FUzZfQ09MTEVDVElPTlMudHh0XG4hZnVuY3Rpb24odCxlKXtcIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJ1bmRlZmluZWRcIiE9dHlwZW9mIG1vZHVsZT9lKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxlKTplKHQuanN0cz10LmpzdHN8fHt9KX0odGhpcyxmdW5jdGlvbih0KXtcInVzZSBzdHJpY3RcIjtmdW5jdGlvbiBlKHQsZSl7Zm9yKHZhciBuIGluIGUpZS5oYXNPd25Qcm9wZXJ0eShuKSYmKHRbbl09ZVtuXSl9ZnVuY3Rpb24gbigpe31mdW5jdGlvbiBpKCl7fWZ1bmN0aW9uIHIoKXt9ZnVuY3Rpb24gcygpe31mdW5jdGlvbiBvKCl7fWZ1bmN0aW9uIGEoKXt9ZnVuY3Rpb24gdSgpe31mdW5jdGlvbiBsKHQpe3RoaXMubWVzc2FnZT10fWZ1bmN0aW9uIGgodCxlKXt0LnByb3RvdHlwZT1PYmplY3QuY3JlYXRlKGUucHJvdG90eXBlKSx0LnByb3RvdHlwZS5jb25zdHJ1Y3Rvcj10fWZ1bmN0aW9uIGMoKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClsLmNhbGwodGhpcyk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBmKCl7fWZ1bmN0aW9uIGcoKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLno9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClnLmNhbGwodGhpcywwLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtnLmNhbGwodGhpcyx0LngsdC55LHQueil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2cuY2FsbCh0aGlzLGUsbixnLk5VTExfT1JESU5BVEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLng9aSx0aGlzLnk9cix0aGlzLno9c319ZnVuY3Rpb24gZCgpe2lmKHRoaXMuZGltZW5zaW9uc1RvVGVzdD0yLDA9PT1hcmd1bWVudHMubGVuZ3RoKWQuY2FsbCh0aGlzLDIpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtpZigyIT09dCYmMyE9PXQpdGhyb3cgbmV3IGkoXCJvbmx5IDIgb3IgMyBkaW1lbnNpb25zIG1heSBiZSBzcGVjaWZpZWRcIik7dGhpcy5kaW1lbnNpb25zVG9UZXN0PXR9fWZ1bmN0aW9uIHAoKXt9ZnVuY3Rpb24gdigpe31mdW5jdGlvbiBtKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIHkoKXt9ZnVuY3Rpb24geCh0KXt0aGlzLm1lc3NhZ2U9dHx8XCJcIn1mdW5jdGlvbiBFKHQpe3RoaXMubWVzc2FnZT10fHxcIlwifWZ1bmN0aW9uIEkoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gTigpe2lmKEkuYXBwbHkodGhpcyksMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVuc3VyZUNhcGFjaXR5KHQubGVuZ3RoKSx0aGlzLmFkZCh0LCEwKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5lbnN1cmVDYXBhY2l0eShlLmxlbmd0aCksdGhpcy5hZGQoZSxuKX19ZnVuY3Rpb24gQygpe2lmKHRoaXMubWlueD1udWxsLHRoaXMubWF4eD1udWxsLHRoaXMubWlueT1udWxsLHRoaXMubWF4eT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0LngsdC54LHQueSx0LnkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5pbml0KG4ueCxpLngsbi55LGkueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdO3RoaXMuaW5pdChyLHMsbyxhKX19ZnVuY3Rpb24gUygpe31mdW5jdGlvbiB3KCl7Uy5jYWxsKHRoaXMsXCJQcm9qZWN0aXZlIHBvaW50IG5vdCByZXByZXNlbnRhYmxlIG9uIHRoZSBDYXJ0ZXNpYW4gcGxhbmUuXCIpfWZ1bmN0aW9uIEwoKXt9ZnVuY3Rpb24gUih0LGUpe3JldHVybiB0LmludGVyZmFjZXNfJiZ0LmludGVyZmFjZXNfKCkuaW5kZXhPZihlKT4tMX1mdW5jdGlvbiBUKCl7fWZ1bmN0aW9uIFAodCl7dGhpcy5zdHI9dH1mdW5jdGlvbiBiKHQpe3RoaXMudmFsdWU9dH1mdW5jdGlvbiBPKCl7fWZ1bmN0aW9uIF8oKXtpZih0aGlzLmhpPTAsdGhpcy5sbz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuaW5pdCgwKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgZT1hcmd1bWVudHNbMF07dGhpcy5pbml0KGUpfWVsc2UgaWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIG49YXJndW1lbnRzWzBdO18uY2FsbCh0aGlzLF8ucGFyc2UobikpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy5pbml0KGkscil9fWZ1bmN0aW9uIE0oKXt9ZnVuY3Rpb24gRCgpe31mdW5jdGlvbiBBKCl7fWZ1bmN0aW9uIEYoKXtpZih0aGlzLng9bnVsbCx0aGlzLnk9bnVsbCx0aGlzLnc9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLng9MCx0aGlzLnk9MCx0aGlzLnc9MTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy54PXQueCx0aGlzLnk9dC55LHRoaXMudz0xfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLng9ZSx0aGlzLnk9bix0aGlzLnc9MX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgRiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBGKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07dGhpcy54PWkueSpyLnctci55Kmkudyx0aGlzLnk9ci54Kmkudy1pLngqci53LHRoaXMudz1pLngqci55LXIueCppLnl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdO3RoaXMueD1zLnktby55LHRoaXMueT1vLngtcy54LHRoaXMudz1zLngqby55LW8ueCpzLnl9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXSxsPWFyZ3VtZW50c1syXTt0aGlzLng9YSx0aGlzLnk9dSx0aGlzLnc9bH1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaD1hcmd1bWVudHNbMF0sYz1hcmd1bWVudHNbMV0sZj1hcmd1bWVudHNbMl0sZD1hcmd1bWVudHNbM10scD1oLnktYy55LHY9Yy54LWgueCxtPWgueCpjLnktYy54KmgueSx5PWYueS1kLnkseD1kLngtZi54LEU9Zi54KmQueS1kLngqZi55O3RoaXMueD12KkUteCptLHRoaXMueT15Km0tcCpFLHRoaXMudz1wKngteSp2fX1mdW5jdGlvbiBHKCl7fWZ1bmN0aW9uIHEoKXt9ZnVuY3Rpb24gQigpe3RoaXMuZW52ZWxvcGU9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLlNSSUQ9bnVsbCx0aGlzLnVzZXJEYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10LHRoaXMuU1JJRD10LmdldFNSSUQoKX1mdW5jdGlvbiB6KCl7fWZ1bmN0aW9uIFYoKXt9ZnVuY3Rpb24gaygpe31mdW5jdGlvbiBZKCl7fWZ1bmN0aW9uIFUoKXt9ZnVuY3Rpb24gWCgpe31mdW5jdGlvbiBIKCl7fWZ1bmN0aW9uIFcoKXt9ZnVuY3Rpb24gaigpe31mdW5jdGlvbiBLKCl7fWZ1bmN0aW9uIFooKXt9ZnVuY3Rpb24gUSgpe31mdW5jdGlvbiBKKCl7dGhpcy5hcnJheV89W10sYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB2JiZ0aGlzLmFkZEFsbChhcmd1bWVudHNbMF0pfWZ1bmN0aW9uICQodCl7cmV0dXJuIG51bGw9PXQ/JHM6dC5jb2xvcn1mdW5jdGlvbiB0dCh0KXtyZXR1cm4gbnVsbD09dD9udWxsOnQucGFyZW50fWZ1bmN0aW9uIGV0KHQsZSl7bnVsbCE9PXQmJih0LmNvbG9yPWUpfWZ1bmN0aW9uIG50KHQpe3JldHVybiBudWxsPT10P251bGw6dC5sZWZ0fWZ1bmN0aW9uIGl0KHQpe3JldHVybiBudWxsPT10P251bGw6dC5yaWdodH1mdW5jdGlvbiBydCgpe3RoaXMucm9vdF89bnVsbCx0aGlzLnNpemVfPTB9ZnVuY3Rpb24gc3QoKXt9ZnVuY3Rpb24gb3QoKXt9ZnVuY3Rpb24gYXQoKXt0aGlzLmFycmF5Xz1bXSxhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHYmJnRoaXMuYWRkQWxsKGFyZ3VtZW50c1swXSl9ZnVuY3Rpb24gdXQoKXt9ZnVuY3Rpb24gbHQoKXt9ZnVuY3Rpb24gaHQoKXt9ZnVuY3Rpb24gY3QoKXt9ZnVuY3Rpb24gZnQoKXt0aGlzLmdlb21ldHJpZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoQi5jYWxsKHRoaXMsZSksbnVsbD09PXQmJih0PVtdKSxCLmhhc051bGxFbGVtZW50cyh0KSl0aHJvdyBuZXcgaShcImdlb21ldHJpZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO3RoaXMuZ2VvbWV0cmllcz10fWZ1bmN0aW9uIGd0KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIGR0KCl7aWYodGhpcy5nZW9tPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsLHRoaXMuYm5SdWxlPW51bGwsdGhpcy5lbmRwb2ludE1hcD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07ZHQuY2FsbCh0aGlzLHQsVi5NT0QyX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmdlb209ZSx0aGlzLmdlb21GYWN0PWUuZ2V0RmFjdG9yeSgpLHRoaXMuYm5SdWxlPW59fWZ1bmN0aW9uIHB0KCl7dGhpcy5jb3VudD1udWxsfWZ1bmN0aW9uIHZ0KCl7fWZ1bmN0aW9uIG10KCl7fWZ1bmN0aW9uIHl0KCl7fWZ1bmN0aW9uIHh0KCl7fWZ1bmN0aW9uIEV0KCl7fWZ1bmN0aW9uIEl0KCl7fWZ1bmN0aW9uIE50KCl7fWZ1bmN0aW9uIEN0KCl7fWZ1bmN0aW9uIFN0KCl7dGhpcy5wb2ludHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Qi5jYWxsKHRoaXMsZSksdGhpcy5pbml0KHQpfWZ1bmN0aW9uIHd0KCl7fWZ1bmN0aW9uIEx0KCl7dGhpcy5jb29yZGluYXRlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtCLmNhbGwodGhpcyxlKSx0aGlzLmluaXQodCl9ZnVuY3Rpb24gUnQoKXt9ZnVuY3Rpb24gVHQoKXt0aGlzLnNoZWxsPW51bGwsdGhpcy5ob2xlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZihCLmNhbGwodGhpcyxuKSxudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZygpKSxudWxsPT09ZSYmKGU9W10pLEIuaGFzTnVsbEVsZW1lbnRzKGUpKXRocm93IG5ldyBpKFwiaG9sZXMgbXVzdCBub3QgY29udGFpbiBudWxsIGVsZW1lbnRzXCIpO2lmKHQuaXNFbXB0eSgpJiZCLmhhc05vbkVtcHR5RWxlbWVudHMoZSkpdGhyb3cgbmV3IGkoXCJzaGVsbCBpcyBlbXB0eSBidXQgaG9sZXMgYXJlIG5vdFwiKTt0aGlzLnNoZWxsPXQsdGhpcy5ob2xlcz1lfWZ1bmN0aW9uIFB0KCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2Z0LmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIGJ0KCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGllKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07YnQuY2FsbCh0aGlzLGUuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KSxlKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGllKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07U3QuY2FsbCh0aGlzLG4saSksdGhpcy52YWxpZGF0ZUNvbnN0cnVjdGlvbigpfX1mdW5jdGlvbiBPdCgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtmdC5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBfdCgpe2lmKHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuaXNVc2VyRGF0YUNvcGllZD0hMSwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZmFjdG9yeT10fX1mdW5jdGlvbiBNdCgpe31mdW5jdGlvbiBEdCgpe31mdW5jdGlvbiBBdCgpe31mdW5jdGlvbiBGdCgpe31mdW5jdGlvbiBHdCgpe2lmKHRoaXMuZGltZW5zaW9uPTMsdGhpcy5jb29yZGluYXRlcz1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07R3QuY2FsbCh0aGlzLHQsMyl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShlKS5maWxsKG51bGwpO2Zvcih2YXIgbj0wO2U+bjtuKyspdGhpcy5jb29yZGluYXRlc1tuXT1uZXcgZ31lbHNlIGlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgaT1hcmd1bWVudHNbMF07aWYobnVsbD09PWkpcmV0dXJuIHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDt0aGlzLmRpbWVuc2lvbj1pLmdldERpbWVuc2lvbigpLHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KGkuc2l6ZSgpKS5maWxsKG51bGwpO2Zvcih2YXIgbj0wO248dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7bisrKXRoaXMuY29vcmRpbmF0ZXNbbl09aS5nZXRDb29yZGluYXRlQ29weShuKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5JiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkaW5hdGVzPXIsdGhpcy5kaW1lbnNpb249cyxudWxsPT09ciYmKHRoaXMuY29vcmRpbmF0ZXM9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpfWVsc2UgaWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1sxXSkpe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXTt0aGlzLmNvb3JkaW5hdGVzPW5ldyBBcnJheShvKS5maWxsKG51bGwpLHRoaXMuZGltZW5zaW9uPWE7Zm9yKHZhciBuPTA7bz5uO24rKyl0aGlzLmNvb3JkaW5hdGVzW25dPW5ldyBnfX1mdW5jdGlvbiBxdCgpe31mdW5jdGlvbiBCdCh0LGUpe3JldHVybiB0PT09ZXx8dCE9PXQmJmUhPT1lfWZ1bmN0aW9uIHp0KHQsZSl7ZnVuY3Rpb24gbih0KXtyZXR1cm4gdGhpcyYmdGhpcy5jb25zdHJ1Y3Rvcj09PW4/KHRoaXMuX2tleXM9W10sdGhpcy5fdmFsdWVzPVtdLHRoaXMuX2l0cD1bXSx0aGlzLm9iamVjdE9ubHk9ZSx2b2lkKHQmJlZ0LmNhbGwodGhpcyx0KSkpOm5ldyBuKHQpfXJldHVybiBlfHxpbyh0LFwic2l6ZVwiLHtnZXQ6SnR9KSx0LmNvbnN0cnVjdG9yPW4sbi5wcm90b3R5cGU9dCxufWZ1bmN0aW9uIFZ0KHQpe3RoaXMuYWRkP3QuZm9yRWFjaCh0aGlzLmFkZCx0aGlzKTp0LmZvckVhY2goZnVuY3Rpb24odCl7dGhpcy5zZXQodFswXSx0WzFdKX0sdGhpcyl9ZnVuY3Rpb24ga3QodCl7cmV0dXJuIHRoaXMuaGFzKHQpJiYodGhpcy5fa2V5cy5zcGxpY2Uobm8sMSksdGhpcy5fdmFsdWVzLnNwbGljZShubywxKSx0aGlzLl9pdHAuZm9yRWFjaChmdW5jdGlvbih0KXtubzx0WzBdJiZ0WzBdLS19KSksbm8+LTF9ZnVuY3Rpb24gWXQodCl7cmV0dXJuIHRoaXMuaGFzKHQpP3RoaXMuX3ZhbHVlc1tub106dm9pZCAwfWZ1bmN0aW9uIFV0KHQsZSl7aWYodGhpcy5vYmplY3RPbmx5JiZlIT09T2JqZWN0KGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIHZhbHVlIHVzZWQgYXMgd2VhayBjb2xsZWN0aW9uIGtleVwiKTtpZihlIT09ZXx8MD09PWUpZm9yKG5vPXQubGVuZ3RoO25vLS0mJiFCdCh0W25vXSxlKTspO2Vsc2Ugbm89dC5pbmRleE9mKGUpO3JldHVybiBubz4tMX1mdW5jdGlvbiBYdCh0KXtyZXR1cm4gVXQuY2FsbCh0aGlzLHRoaXMuX2tleXMsdCl9ZnVuY3Rpb24gSHQodCxlKXtyZXR1cm4gdGhpcy5oYXModCk/dGhpcy5fdmFsdWVzW25vXT1lOnRoaXMuX3ZhbHVlc1t0aGlzLl9rZXlzLnB1c2godCktMV09ZSx0aGlzfWZ1bmN0aW9uIFd0KCl7KHRoaXMuX2tleXN8fDApLmxlbmd0aD10aGlzLl92YWx1ZXMubGVuZ3RoPTB9ZnVuY3Rpb24ganQoKXtyZXR1cm4gUXQodGhpcy5faXRwLHRoaXMuX2tleXMpfWZ1bmN0aW9uIEt0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl92YWx1ZXMpfWZ1bmN0aW9uIFp0KCl7cmV0dXJuIFF0KHRoaXMuX2l0cCx0aGlzLl9rZXlzLHRoaXMuX3ZhbHVlcyl9ZnVuY3Rpb24gUXQodCxlLG4pe3ZhciBpPVswXSxyPSExO3JldHVybiB0LnB1c2goaSkse25leHQ6ZnVuY3Rpb24oKXt2YXIgcyxvPWlbMF07cmV0dXJuIXImJm88ZS5sZW5ndGg/KHM9bj9bZVtvXSxuW29dXTplW29dLGlbMF0rKyk6KHI9ITAsdC5zcGxpY2UodC5pbmRleE9mKGkpLDEpKSx7ZG9uZTpyLHZhbHVlOnN9fX19ZnVuY3Rpb24gSnQoKXtyZXR1cm4gdGhpcy5fdmFsdWVzLmxlbmd0aH1mdW5jdGlvbiAkdCh0LGUpe2Zvcih2YXIgbj10aGlzLmVudHJpZXMoKTs7KXt2YXIgaT1uLm5leHQoKTtpZihpLmRvbmUpYnJlYWs7dC5jYWxsKGUsaS52YWx1ZVsxXSxpLnZhbHVlWzBdLHRoaXMpfX1mdW5jdGlvbiB0ZSgpe3RoaXMubWFwXz1uZXcgc299ZnVuY3Rpb24gZWUoKXtpZih0aGlzLm1vZGVsVHlwZT1udWxsLHRoaXMuc2NhbGU9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm1vZGVsVHlwZT1lZS5GTE9BVElORztlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbmUpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT10LHQ9PT1lZS5GSVhFRCYmdGhpcy5zZXRTY2FsZSgxKX1lbHNlIGlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1vZGVsVHlwZT1lZS5GSVhFRCx0aGlzLnNldFNjYWxlKGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7dmFyIG49YXJndW1lbnRzWzBdO3RoaXMubW9kZWxUeXBlPW4ubW9kZWxUeXBlLHRoaXMuc2NhbGU9bi5zY2FsZX19ZnVuY3Rpb24gbmUoKXt0aGlzLm5hbWU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5uYW1lPXQsbmUubmFtZVRvVHlwZU1hcC5wdXQodCx0aGlzKX1mdW5jdGlvbiBpZSgpe2lmKHRoaXMucHJlY2lzaW9uTW9kZWw9bnVsbCx0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9bnVsbCx0aGlzLlNSSUQ9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClpZS5jYWxsKHRoaXMsbmV3IGVlLDApO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLEcpKXt2YXIgdD1hcmd1bWVudHNbMF07aWUuY2FsbCh0aGlzLG5ldyBlZSwwLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBlZSl7dmFyIGU9YXJndW1lbnRzWzBdO2llLmNhbGwodGhpcyxlLDAsaWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtpZS5jYWxsKHRoaXMsbixpLGllLmdldERlZmF1bHRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLnByZWNpc2lvbk1vZGVsPXIsdGhpcy5jb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5PW8sdGhpcy5TUklEPXN9fWZ1bmN0aW9uIHJlKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZX1mdW5jdGlvbiBzZSh0KXt0aGlzLnBhcnNlcj1uZXcgcmUodCl9ZnVuY3Rpb24gb2UoKXt0aGlzLnJlc3VsdD1udWxsLHRoaXMuaW5wdXRMaW5lcz1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDIpfSksdGhpcy5pbnRQdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmludExpbmVJbmRleD1udWxsLHRoaXMuX2lzUHJvcGVyPW51bGwsdGhpcy5wYT1udWxsLHRoaXMucGI9bnVsbCx0aGlzLnByZWNpc2lvbk1vZGVsPW51bGwsdGhpcy5pbnRQdFswXT1uZXcgZyx0aGlzLmludFB0WzFdPW5ldyBnLHRoaXMucGE9dGhpcy5pbnRQdFswXSx0aGlzLnBiPXRoaXMuaW50UHRbMV0sdGhpcy5yZXN1bHQ9MH1mdW5jdGlvbiBhZSgpe29lLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIHVlKCl7fWZ1bmN0aW9uIGxlKCl7dGhpcy5wPW51bGwsdGhpcy5jcm9zc2luZ0NvdW50PTAsdGhpcy5pc1BvaW50T25TZWdtZW50PSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnA9dH1mdW5jdGlvbiBoZSgpe31mdW5jdGlvbiBjZSgpe2lmKHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpY2UuY2FsbCh0aGlzLG5ldyBnLG5ldyBnKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Y2UuY2FsbCh0aGlzLHQucDAsdC5wMSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucDA9ZSx0aGlzLnAxPW59ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdO2NlLmNhbGwodGhpcyxuZXcgZyhpLHIpLG5ldyBnKHMsbykpfX1mdW5jdGlvbiBmZSgpe2lmKHRoaXMubWF0cml4PW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpdGhpcy5tYXRyaXg9QXJyYXkoMykuZmlsbCgpLm1hcChmdW5jdGlvbigpe3JldHVybiBBcnJheSgzKX0pLHRoaXMuc2V0QWxsKGx0LkZBTFNFKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciB0PWFyZ3VtZW50c1swXTtmZS5jYWxsKHRoaXMpLHRoaXMuc2V0KHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBmZSl7dmFyIGU9YXJndW1lbnRzWzBdO2ZlLmNhbGwodGhpcyksdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5CT1VOREFSWV1bTC5FWFRFUklPUl0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV0sdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5FWFRFUklPUl09ZS5tYXRyaXhbTC5FWFRFUklPUl1bTC5FWFRFUklPUl19fWZ1bmN0aW9uIGdlKCl7dGhpcy5hcmVhQmFzZVB0PW51bGwsdGhpcy50cmlhbmdsZUNlbnQzPW5ldyBnLHRoaXMuYXJlYXN1bTI9MCx0aGlzLmNnMz1uZXcgZyx0aGlzLmxpbmVDZW50U3VtPW5ldyBnLHRoaXMudG90YWxMZW5ndGg9MCx0aGlzLnB0Q291bnQ9MCx0aGlzLnB0Q2VudFN1bT1uZXcgZzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hcmVhQmFzZVB0PW51bGwsdGhpcy5hZGQodCl9ZnVuY3Rpb24gZGUodCl7dGhpcy5tZXNzYWdlPXR8fFwiXCJ9ZnVuY3Rpb24gcGUoKXt0aGlzLmFycmF5Xz1bXX1mdW5jdGlvbiB2ZSgpe3RoaXMudHJlZVNldD1uZXcgYXQsdGhpcy5saXN0PW5ldyBJfWZ1bmN0aW9uIG1lKCl7aWYodGhpcy5nZW9tRmFjdG9yeT1udWxsLHRoaXMuaW5wdXRQdHM9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO21lLmNhbGwodGhpcyxtZS5leHRyYWN0Q29vcmRpbmF0ZXModCksdC5nZXRGYWN0b3J5KCkpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0UHRzPXZlLmZpbHRlckNvb3JkaW5hdGVzKGUpLHRoaXMuZ2VvbUZhY3Rvcnk9bn19ZnVuY3Rpb24geWUoKXt0aGlzLm9yaWdpbj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm9yaWdpbj10fWZ1bmN0aW9uIHhlKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLnBydW5lRW1wdHlHZW9tZXRyeT0hMCx0aGlzLnByZXNlcnZlR2VvbWV0cnlDb2xsZWN0aW9uVHlwZT0hMCx0aGlzLnByZXNlcnZlQ29sbGVjdGlvbnM9ITEsdGhpcy5wcmVzZXJ2ZVR5cGU9ITF9ZnVuY3Rpb24gRWUoKXtpZih0aGlzLnNuYXBUb2xlcmFuY2U9MCx0aGlzLnNyY1B0cz1udWxsLHRoaXMuc2VnPW5ldyBjZSx0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPSExLHRoaXMuX2lzQ2xvc2VkPSExLGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3QmJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtFZS5jYWxsKHRoaXMsdC5nZXRDb29yZGluYXRlcygpLGUpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuc3JjUHRzPW4sdGhpcy5faXNDbG9zZWQ9RWUuaXNDbG9zZWQobiksdGhpcy5zbmFwVG9sZXJhbmNlPWl9fWZ1bmN0aW9uIEllKCl7dGhpcy5zcmNHZW9tPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3JjR2VvbT10fWZ1bmN0aW9uIE5lKCl7aWYoeGUuYXBwbHkodGhpcyksdGhpcy5zbmFwVG9sZXJhbmNlPW51bGwsdGhpcy5zbmFwUHRzPW51bGwsdGhpcy5pc1NlbGZTbmFwPSExLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zbmFwVG9sZXJhbmNlPXQsdGhpcy5zbmFwUHRzPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuc25hcFRvbGVyYW5jZT1uLHRoaXMuc25hcFB0cz1pLHRoaXMuaXNTZWxmU25hcD1yfX1mdW5jdGlvbiBDZSgpe3RoaXMuaXNGaXJzdD0hMCx0aGlzLmNvbW1vbk1hbnRpc3NhQml0c0NvdW50PTUzLHRoaXMuY29tbW9uQml0cz0wLHRoaXMuY29tbW9uU2lnbkV4cD1udWxsfWZ1bmN0aW9uIFNlKCl7dGhpcy5jb21tb25Db29yZD1udWxsLHRoaXMuY2NGaWx0ZXI9bmV3IHdlfWZ1bmN0aW9uIHdlKCl7dGhpcy5jb21tb25CaXRzWD1uZXcgQ2UsdGhpcy5jb21tb25CaXRzWT1uZXcgQ2V9ZnVuY3Rpb24gTGUoKXt0aGlzLnRyYW5zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudHJhbnM9dH1mdW5jdGlvbiBSZSgpe3RoaXMucGFyZW50PW51bGwsdGhpcy5hdFN0YXJ0PW51bGwsdGhpcy5tYXg9bnVsbCx0aGlzLmluZGV4PW51bGwsdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wYXJlbnQ9dCx0aGlzLmF0U3RhcnQ9ITAsdGhpcy5pbmRleD0wLHRoaXMubWF4PXQuZ2V0TnVtR2VvbWV0cmllcygpfWZ1bmN0aW9uIFRlKCl7aWYodGhpcy5ib3VuZGFyeVJ1bGU9Vi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUsdGhpcy5pc0luPW51bGwsdGhpcy5udW1Cb3VuZGFyaWVzPW51bGwsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtpZihudWxsPT09dCl0aHJvdyBuZXcgaShcIlJ1bGUgbXVzdCBiZSBub24tbnVsbFwiKTt0aGlzLmJvdW5kYXJ5UnVsZT10fX1mdW5jdGlvbiBQZSgpe31mdW5jdGlvbiBiZSgpe31mdW5jdGlvbiBPZSgpe3RoaXMucHRzPW51bGwsdGhpcy5kYXRhPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHRzPXQsdGhpcy5kYXRhPWV9ZnVuY3Rpb24gX2UoKXt9ZnVuY3Rpb24gTWUoKXt0aGlzLmJvdW5kcz1udWxsLHRoaXMuaXRlbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmJvdW5kcz10LHRoaXMuaXRlbT1lfWZ1bmN0aW9uIERlKCl7dGhpcy5fc2l6ZT1udWxsLHRoaXMuaXRlbXM9bnVsbCx0aGlzLl9zaXplPTAsdGhpcy5pdGVtcz1uZXcgSSx0aGlzLml0ZW1zLmFkZChudWxsKX1mdW5jdGlvbiBBZSgpe31mdW5jdGlvbiBGZSgpe31mdW5jdGlvbiBHZSgpe2lmKHRoaXMuY2hpbGRCb3VuZGFibGVzPW5ldyBJLHRoaXMuYm91bmRzPW51bGwsdGhpcy5sZXZlbD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5sZXZlbD10fX1mdW5jdGlvbiBxZSgpe3RoaXMuYm91bmRhYmxlMT1udWxsLHRoaXMuYm91bmRhYmxlMj1udWxsLHRoaXMuX2Rpc3RhbmNlPW51bGwsdGhpcy5pdGVtRGlzdGFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5ib3VuZGFibGUxPXQsdGhpcy5ib3VuZGFibGUyPWUsdGhpcy5pdGVtRGlzdGFuY2U9bix0aGlzLl9kaXN0YW5jZT10aGlzLmRpc3RhbmNlKCl9ZnVuY3Rpb24gQmUoKXtpZih0aGlzLnJvb3Q9bnVsbCx0aGlzLmJ1aWx0PSExLHRoaXMuaXRlbUJvdW5kYWJsZXM9bmV3IEksdGhpcy5ub2RlQ2FwYWNpdHk9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClCZS5jYWxsKHRoaXMsQmUuREVGQVVMVF9OT0RFX0NBUEFDSVRZKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zi5pc1RydWUodD4xLFwiTm9kZSBjYXBhY2l0eSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxXCIpLHRoaXMubm9kZUNhcGFjaXR5PXR9fWZ1bmN0aW9uIHplKCl7fWZ1bmN0aW9uIFZlKCl7fWZ1bmN0aW9uIGtlKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpa2UuY2FsbCh0aGlzLGtlLkRFRkFVTFRfTk9ERV9DQVBBQ0lUWSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0JlLmNhbGwodGhpcyx0KX19ZnVuY3Rpb24gWWUoKXt2YXIgdD1hcmd1bWVudHNbMF07R2UuY2FsbCh0aGlzLHQpfWZ1bmN0aW9uIFVlKCl7fWZ1bmN0aW9uIFhlKCl7dGhpcy5zZWdTdHJpbmc9bnVsbCx0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLnNlZ21lbnRPY3RhbnQ9bnVsbCx0aGlzLl9pc0ludGVyaW9yPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMuc2VnU3RyaW5nPXQsdGhpcy5jb29yZD1uZXcgZyhlKSx0aGlzLnNlZ21lbnRJbmRleD1uLHRoaXMuc2VnbWVudE9jdGFudD1pLHRoaXMuX2lzSW50ZXJpb3I9IWUuZXF1YWxzMkQodC5nZXRDb29yZGluYXRlKG4pKX1mdW5jdGlvbiBIZSgpe3RoaXMubm9kZU1hcD1uZXcgcnQsdGhpcy5lZGdlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZWRnZT10fWZ1bmN0aW9uIFdlKCl7dGhpcy5ub2RlTGlzdD1udWxsLHRoaXMuZWRnZT1udWxsLHRoaXMubm9kZUl0PW51bGwsdGhpcy5jdXJyTm9kZT1udWxsLHRoaXMubmV4dE5vZGU9bnVsbCx0aGlzLmN1cnJTZWdJbmRleD0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVMaXN0PXQsdGhpcy5lZGdlPXQuZ2V0RWRnZSgpLHRoaXMubm9kZUl0PXQuaXRlcmF0b3IoKSx0aGlzLnJlYWROZXh0Tm9kZSgpfWZ1bmN0aW9uIGplKCl7fWZ1bmN0aW9uIEtlKCl7dGhpcy5ub2RlTGlzdD1uZXcgSGUodGhpcyksdGhpcy5wdHM9bnVsbCx0aGlzLmRhdGE9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wdHM9dCx0aGlzLmRhdGE9ZX1mdW5jdGlvbiBaZSgpe3RoaXMudGVtcEVudjE9bmV3IEMsdGhpcy50ZW1wRW52Mj1uZXcgQyx0aGlzLm92ZXJsYXBTZWcxPW5ldyBjZSx0aGlzLm92ZXJsYXBTZWcyPW5ldyBjZX1mdW5jdGlvbiBRZSgpe3RoaXMucHRzPW51bGwsdGhpcy5zdGFydD1udWxsLHRoaXMuZW5kPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmNvbnRleHQ9bnVsbCx0aGlzLmlkPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdO3RoaXMucHRzPXQsdGhpcy5zdGFydD1lLHRoaXMuZW5kPW4sdGhpcy5jb250ZXh0PWl9ZnVuY3Rpb24gSmUoKXt9ZnVuY3Rpb24gJGUoKXt9ZnVuY3Rpb24gdG4oKXt9ZnVuY3Rpb24gZW4oKXtpZih0aGlzLnNlZ0ludD1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRTZWdtZW50SW50ZXJzZWN0b3IodCl9fWZ1bmN0aW9uIG5uKCl7aWYodGhpcy5tb25vQ2hhaW5zPW5ldyBJLHRoaXMuaW5kZXg9bmV3IGtlLHRoaXMuaWRDb3VudGVyPTAsdGhpcy5ub2RlZFNlZ1N0cmluZ3M9bnVsbCx0aGlzLm5PdmVybGFwcz0wLDA9PT1hcmd1bWVudHMubGVuZ3RoKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07ZW4uY2FsbCh0aGlzLHQpfX1mdW5jdGlvbiBybigpe1plLmFwcGx5KHRoaXMpLHRoaXMuc2k9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zaT10fWZ1bmN0aW9uIHNuKCl7aWYodGhpcy5wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07bC5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO2wuY2FsbCh0aGlzLHNuLm1zZ1dpdGhDb29yZChlLG4pKSx0aGlzLnB0PW5ldyBnKG4pfX1mdW5jdGlvbiBvbigpe31mdW5jdGlvbiBhbigpe3RoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5pc0NoZWNrRW5kU2VnbWVudHNPbmx5PSExLHRoaXMubGk9bnVsbCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uPW51bGwsdGhpcy5pbnRTZWdtZW50cz1udWxsLHRoaXMuaW50ZXJzZWN0aW9ucz1uZXcgSSx0aGlzLmludGVyc2VjdGlvbkNvdW50PTAsdGhpcy5rZWVwSW50ZXJzZWN0aW9ucz0hMDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saT10LHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb249bnVsbH1mdW5jdGlvbiB1bigpe3RoaXMubGk9bmV3IGFlLHRoaXMuc2VnU3RyaW5ncz1udWxsLHRoaXMuZmluZEFsbEludGVyc2VjdGlvbnM9ITEsdGhpcy5zZWdJbnQ9bnVsbCx0aGlzLl9pc1ZhbGlkPSEwO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNlZ1N0cmluZ3M9dH1mdW5jdGlvbiBsbigpe3RoaXMubnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5udj1uZXcgdW4obG4udG9TZWdtZW50U3RyaW5ncyh0KSl9ZnVuY3Rpb24gaG4oKXt0aGlzLm1hcE9wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWFwT3A9dH1mdW5jdGlvbiBjbigpe31mdW5jdGlvbiBmbigpe2lmKHRoaXMubG9jYXRpb249bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lmxlbmd0aCl9ZWxzZSBpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmluaXQoMSksdGhpcy5sb2NhdGlvbltjbi5PTl09ZX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZm4pe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmluaXQobi5sb2NhdGlvbi5sZW5ndGgpLG51bGwhPT1uKWZvcih2YXIgaT0wO2k8dGhpcy5sb2NhdGlvbi5sZW5ndGg7aSsrKXRoaXMubG9jYXRpb25baV09bi5sb2NhdGlvbltpXX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdO3RoaXMuaW5pdCgzKSx0aGlzLmxvY2F0aW9uW2NuLk9OXT1yLHRoaXMubG9jYXRpb25bY24uTEVGVF09cyx0aGlzLmxvY2F0aW9uW2NuLlJJR0hUXT1vfX1mdW5jdGlvbiBnbigpe2lmKHRoaXMuZWx0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpLDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVsdFswXT1uZXcgZm4odCksdGhpcy5lbHRbMV09bmV3IGZuKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnbil7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuZWx0WzBdPW5ldyBmbihlLmVsdFswXSksdGhpcy5lbHRbMV09bmV3IGZuKGUuZWx0WzFdKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuZWx0WzBdPW5ldyBmbihMLk5PTkUpLHRoaXMuZWx0WzFdPW5ldyBmbihMLk5PTkUpLHRoaXMuZWx0W25dLnNldExvY2F0aW9uKGkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLmVsdFswXT1uZXcgZm4ocixzLG8pLHRoaXMuZWx0WzFdPW5ldyBmbihyLHMsbyl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGE9YXJndW1lbnRzWzBdLHU9YXJndW1lbnRzWzFdLGw9YXJndW1lbnRzWzJdLGg9YXJndW1lbnRzWzNdO3RoaXMuZWx0WzBdPW5ldyBmbihMLk5PTkUsTC5OT05FLEwuTk9ORSksdGhpcy5lbHRbMV09bmV3IGZuKEwuTk9ORSxMLk5PTkUsTC5OT05FKSx0aGlzLmVsdFthXS5zZXRMb2NhdGlvbnModSxsLGgpfX1mdW5jdGlvbiBkbigpe3RoaXMuc3RhcnREZT1udWxsLHRoaXMubWF4Tm9kZURlZ3JlZT0tMSx0aGlzLmVkZ2VzPW5ldyBJLHRoaXMucHRzPW5ldyBJLHRoaXMubGFiZWw9bmV3IGduKEwuTk9ORSksdGhpcy5yaW5nPW51bGwsdGhpcy5faXNIb2xlPW51bGwsdGhpcy5zaGVsbD1udWxsLHRoaXMuaG9sZXM9bmV3IEksdGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLmNvbXB1dGVQb2ludHModCksdGhpcy5jb21wdXRlUmluZygpfWZ1bmN0aW9uIHBuKCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2RuLmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIHZuKCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2RuLmNhbGwodGhpcyx0LGUpfWZ1bmN0aW9uIG1uKCl7aWYodGhpcy5sYWJlbD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNDb3ZlcmVkPSExLHRoaXMuX2lzQ292ZXJlZFNldD0hMSx0aGlzLl9pc1Zpc2l0ZWQ9ITEsMD09PWFyZ3VtZW50cy5sZW5ndGgpO2Vsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxhYmVsPXR9fWZ1bmN0aW9uIHluKCl7bW4uYXBwbHkodGhpcyksdGhpcy5jb29yZD1udWxsLHRoaXMuZWRnZXM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5jb29yZD10LHRoaXMuZWRnZXM9ZSx0aGlzLmxhYmVsPW5ldyBnbigwLEwuTk9ORSl9ZnVuY3Rpb24geG4oKXt0aGlzLm5vZGVNYXA9bmV3IHJ0LHRoaXMubm9kZUZhY3Q9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5ub2RlRmFjdD10fWZ1bmN0aW9uIEVuKCl7aWYodGhpcy5lZGdlPW51bGwsdGhpcy5sYWJlbD1udWxsLHRoaXMubm9kZT1udWxsLHRoaXMucDA9bnVsbCx0aGlzLnAxPW51bGwsdGhpcy5keD1udWxsLHRoaXMuZHk9bnVsbCx0aGlzLnF1YWRyYW50PW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmVkZ2U9dH1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl07RW4uY2FsbCh0aGlzLGUsbixpLG51bGwpfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXTtFbi5jYWxsKHRoaXMsciksdGhpcy5pbml0KHMsbyksdGhpcy5sYWJlbD1hfX1mdW5jdGlvbiBJbigpe3RoaXMuX2lzRm9yd2FyZD1udWxsLHRoaXMuX2lzSW5SZXN1bHQ9ITEsdGhpcy5faXNWaXNpdGVkPSExLHRoaXMuc3ltPW51bGwsdGhpcy5uZXh0PW51bGwsdGhpcy5uZXh0TWluPW51bGwsdGhpcy5lZGdlUmluZz1udWxsLHRoaXMubWluRWRnZVJpbmc9bnVsbCx0aGlzLmRlcHRoPVswLC05OTksLTk5OV07dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKEVuLmNhbGwodGhpcyx0KSx0aGlzLl9pc0ZvcndhcmQ9ZSxlKXRoaXMuaW5pdCh0LmdldENvb3JkaW5hdGUoMCksdC5nZXRDb29yZGluYXRlKDEpKTtlbHNle3ZhciBuPXQuZ2V0TnVtUG9pbnRzKCktMTt0aGlzLmluaXQodC5nZXRDb29yZGluYXRlKG4pLHQuZ2V0Q29vcmRpbmF0ZShuLTEpKX10aGlzLmNvbXB1dGVEaXJlY3RlZExhYmVsKCl9ZnVuY3Rpb24gTm4oKXt9ZnVuY3Rpb24gQ24oKXtpZih0aGlzLmVkZ2VzPW5ldyBJLHRoaXMubm9kZXM9bnVsbCx0aGlzLmVkZ2VFbmRMaXN0PW5ldyBJLDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMubm9kZXM9bmV3IHhuKG5ldyBObik7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubm9kZXM9bmV3IHhuKHQpfX1mdW5jdGlvbiBTbigpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5zaGVsbExpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR9ZnVuY3Rpb24gd24oKXt0aGlzLm9wPW51bGwsdGhpcy5nZW9tZXRyeUZhY3Rvcnk9bnVsbCx0aGlzLnB0TG9jYXRvcj1udWxsLHRoaXMubGluZUVkZ2VzTGlzdD1uZXcgSSx0aGlzLnJlc3VsdExpbmVMaXN0PW5ldyBJO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLm9wPXQsdGhpcy5nZW9tZXRyeUZhY3Rvcnk9ZSx0aGlzLnB0TG9jYXRvcj1ufWZ1bmN0aW9uIExuKCl7dGhpcy5vcD1udWxsLHRoaXMuZ2VvbWV0cnlGYWN0b3J5PW51bGwsdGhpcy5yZXN1bHRQb2ludExpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2FyZ3VtZW50c1syXTt0aGlzLm9wPXQsdGhpcy5nZW9tZXRyeUZhY3Rvcnk9ZX1mdW5jdGlvbiBSbigpe31mdW5jdGlvbiBUbigpe3RoaXMuZ2VvbT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmdlb209dH1mdW5jdGlvbiBQbigpe3RoaXMuZWRnZU1hcD1uZXcgcnQsdGhpcy5lZGdlTGlzdD1udWxsLHRoaXMucHRJbkFyZWFMb2NhdGlvbj1bTC5OT05FLEwuTk9ORV19ZnVuY3Rpb24gYm4oKXtQbi5hcHBseSh0aGlzKSx0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdD1udWxsLHRoaXMubGFiZWw9bnVsbCx0aGlzLlNDQU5OSU5HX0ZPUl9JTkNPTUlORz0xLHRoaXMuTElOS0lOR19UT19PVVRHT0lORz0yfWZ1bmN0aW9uIE9uKCl7Tm4uYXBwbHkodGhpcyl9ZnVuY3Rpb24gX24oKXt0aGlzLm1jZT1udWxsLHRoaXMuY2hhaW5JbmRleD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jZT10LHRoaXMuY2hhaW5JbmRleD1lfWZ1bmN0aW9uIE1uKCl7aWYodGhpcy5sYWJlbD1udWxsLHRoaXMueFZhbHVlPW51bGwsdGhpcy5ldmVudFR5cGU9bnVsbCx0aGlzLmluc2VydEV2ZW50PW51bGwsdGhpcy5kZWxldGVFdmVudEluZGV4PW51bGwsdGhpcy5vYmo9bnVsbCwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZXZlbnRUeXBlPU1uLkRFTEVURSx0aGlzLnhWYWx1ZT10LHRoaXMuaW5zZXJ0RXZlbnQ9ZX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5ldmVudFR5cGU9TW4uSU5TRVJULHRoaXMubGFiZWw9bix0aGlzLnhWYWx1ZT1pLHRoaXMub2JqPXJ9fWZ1bmN0aW9uIERuKCl7fWZ1bmN0aW9uIEFuKCl7dGhpcy5faGFzSW50ZXJzZWN0aW9uPSExLHRoaXMuaGFzUHJvcGVyPSExLHRoaXMuaGFzUHJvcGVySW50ZXJpb3I9ITEsdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludD1udWxsLHRoaXMubGk9bnVsbCx0aGlzLmluY2x1ZGVQcm9wZXI9bnVsbCx0aGlzLnJlY29yZElzb2xhdGVkPW51bGwsdGhpcy5pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLm51bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bVRlc3RzPTAsdGhpcy5iZHlOb2Rlcz1udWxsLHRoaXMuX2lzRG9uZT0hMSx0aGlzLmlzRG9uZVdoZW5Qcm9wZXJJbnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMubGk9dCx0aGlzLmluY2x1ZGVQcm9wZXI9ZSx0aGlzLnJlY29yZElzb2xhdGVkPW59ZnVuY3Rpb24gRm4oKXtEbi5hcHBseSh0aGlzKSx0aGlzLmV2ZW50cz1uZXcgSSx0aGlzLm5PdmVybGFwcz1udWxsfWZ1bmN0aW9uIEduKCl7dGhpcy5taW49ci5QT1NJVElWRV9JTkZJTklUWSx0aGlzLm1heD1yLk5FR0FUSVZFX0lORklOSVRZfWZ1bmN0aW9uIHFuKCl7fWZ1bmN0aW9uIEJuKCl7R24uYXBwbHkodGhpcyksdGhpcy5pdGVtPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMubWluPXQsdGhpcy5tYXg9ZSx0aGlzLml0ZW09bn1mdW5jdGlvbiB6bigpe0duLmFwcGx5KHRoaXMpLHRoaXMubm9kZTE9bnVsbCx0aGlzLm5vZGUyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMubm9kZTE9dCx0aGlzLm5vZGUyPWUsdGhpcy5idWlsZEV4dGVudCh0aGlzLm5vZGUxLHRoaXMubm9kZTIpfWZ1bmN0aW9uIFZuKCl7dGhpcy5sZWF2ZXM9bmV3IEksdGhpcy5yb290PW51bGwsdGhpcy5sZXZlbD0wfWZ1bmN0aW9uIGtuKCl7aWYodGhpcy5saW5lcz1udWxsLHRoaXMuaXNGb3JjZWRUb0xpbmVTdHJpbmc9ITEsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmVzPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMubGluZXM9ZSx0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nPW59fWZ1bmN0aW9uIFluKCl7dGhpcy5pdGVtcz1uZXcgSX1mdW5jdGlvbiBVbigpe3RoaXMuaW5kZXg9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07aWYoIVIodCxSdCkpdGhyb3cgbmV3IGkoXCJBcmd1bWVudCBtdXN0IGJlIFBvbHlnb25hbFwiKTt0aGlzLmluZGV4PW5ldyBIbih0KX1mdW5jdGlvbiBYbigpe3RoaXMuY291bnRlcj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvdW50ZXI9dH1mdW5jdGlvbiBIbigpe3RoaXMuaW5kZXg9bmV3IFZuO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluaXQodCl9ZnVuY3Rpb24gV24oKXt0aGlzLmNvb3JkPW51bGwsdGhpcy5zZWdtZW50SW5kZXg9bnVsbCx0aGlzLmRpc3Q9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07dGhpcy5jb29yZD1uZXcgZyh0KSx0aGlzLnNlZ21lbnRJbmRleD1lLHRoaXMuZGlzdD1ufWZ1bmN0aW9uIGpuKCl7dGhpcy5ub2RlTWFwPW5ldyBydCx0aGlzLmVkZ2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5lZGdlPXR9ZnVuY3Rpb24gS24oKXt9ZnVuY3Rpb24gWm4oKXt0aGlzLmU9bnVsbCx0aGlzLnB0cz1udWxsLHRoaXMuc3RhcnRJbmRleD1udWxsLHRoaXMuZW52MT1uZXcgQyx0aGlzLmVudjI9bmV3IEM7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZT10LHRoaXMucHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKTt2YXIgZT1uZXcgS247dGhpcy5zdGFydEluZGV4PWUuZ2V0Q2hhaW5TdGFydEluZGljZXModGhpcy5wdHMpfWZ1bmN0aW9uIFFuKCl7dGhpcy5kZXB0aD1BcnJheSgyKS5maWxsKCkubWFwKGZ1bmN0aW9uKCl7cmV0dXJuIEFycmF5KDMpfSk7Zm9yKHZhciB0PTA7Mj50O3QrKylmb3IodmFyIGU9MDszPmU7ZSsrKXRoaXMuZGVwdGhbdF1bZV09UW4uTlVMTF9WQUxVRX1mdW5jdGlvbiBKbigpe2lmKG1uLmFwcGx5KHRoaXMpLHRoaXMucHRzPW51bGwsdGhpcy5lbnY9bnVsbCx0aGlzLmVpTGlzdD1uZXcgam4odGhpcyksdGhpcy5uYW1lPW51bGwsdGhpcy5tY2U9bnVsbCx0aGlzLl9pc0lzb2xhdGVkPSEwLHRoaXMuZGVwdGg9bmV3IFFuLHRoaXMuZGVwdGhEZWx0YT0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Sm4uY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucHRzPWUsdGhpcy5sYWJlbD1ufX1mdW5jdGlvbiAkbigpe2lmKENuLmFwcGx5KHRoaXMpLHRoaXMucGFyZW50R2VvbT1udWxsLHRoaXMubGluZUVkZ2VNYXA9bmV3IHRlLHRoaXMuYm91bmRhcnlOb2RlUnVsZT1udWxsLHRoaXMudXNlQm91bmRhcnlEZXRlcm1pbmF0aW9uUnVsZT0hMCx0aGlzLmFyZ0luZGV4PW51bGwsdGhpcy5ib3VuZGFyeU5vZGVzPW51bGwsdGhpcy5faGFzVG9vRmV3UG9pbnRzPSExLHRoaXMuaW52YWxpZFBvaW50PW51bGwsdGhpcy5hcmVhUHRMb2NhdG9yPW51bGwsdGhpcy5wdExvY2F0b3I9bmV3IFRlLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07JG4uY2FsbCh0aGlzLHQsZSxWLk9HQ19TRlNfQk9VTkRBUllfUlVMRSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMuYXJnSW5kZXg9bix0aGlzLnBhcmVudEdlb209aSx0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGU9cixudWxsIT09aSYmdGhpcy5hZGQoaSl9fWZ1bmN0aW9uIHRpKCl7aWYodGhpcy5saT1uZXcgYWUsdGhpcy5yZXN1bHRQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuYXJnPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldENvbXB1dGF0aW9uUHJlY2lzaW9uKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKSksdGhpcy5hcmc9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdGhpcy5hcmdbMF09bmV3ICRuKDAsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RpLmNhbGwodGhpcyxlLG4sVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEUpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtpLmdldFByZWNpc2lvbk1vZGVsKCkuY29tcGFyZVRvKHIuZ2V0UHJlY2lzaW9uTW9kZWwoKSk+PTA/dGhpcy5zZXRDb21wdXRhdGlvblByZWNpc2lvbihpLmdldFByZWNpc2lvbk1vZGVsKCkpOnRoaXMuc2V0Q29tcHV0YXRpb25QcmVjaXNpb24oci5nZXRQcmVjaXNpb25Nb2RlbCgpKSx0aGlzLmFyZz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmFyZ1swXT1uZXcgJG4oMCxpLHMpLHRoaXMuYXJnWzFdPW5ldyAkbigxLHIscyl9fWZ1bmN0aW9uIGVpKCl7dGhpcy5wdHM9bnVsbCx0aGlzLl9vcmllbnRhdGlvbj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnB0cz10LHRoaXMuX29yaWVudGF0aW9uPWVpLm9yaWVudGF0aW9uKHQpfWZ1bmN0aW9uIG5pKCl7dGhpcy5lZGdlcz1uZXcgSSx0aGlzLm9jYU1hcD1uZXcgcnR9ZnVuY3Rpb24gaWkoKXt0aGlzLnB0TG9jYXRvcj1uZXcgVGUsdGhpcy5nZW9tRmFjdD1udWxsLHRoaXMucmVzdWx0R2VvbT1udWxsLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmVkZ2VMaXN0PW5ldyBuaSx0aGlzLnJlc3VsdFBvbHlMaXN0PW5ldyBJLHRoaXMucmVzdWx0TGluZUxpc3Q9bmV3IEksdGhpcy5yZXN1bHRQb2ludExpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RpLmNhbGwodGhpcyx0LGUpLHRoaXMuZ3JhcGg9bmV3IENuKG5ldyBPbiksdGhpcy5nZW9tRmFjdD10LmdldEZhY3RvcnkoKX1mdW5jdGlvbiByaSgpe3RoaXMuZ2VvbT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLnNuYXBUb2xlcmFuY2U9bnVsbCx0aGlzLmNicj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21bMF09dCx0aGlzLmdlb21bMV09ZSx0aGlzLmNvbXB1dGVTbmFwVG9sZXJhbmNlKCl9ZnVuY3Rpb24gc2koKXt0aGlzLmdlb209bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuZ2VvbVswXT10LHRoaXMuZ2VvbVsxXT1lfWZ1bmN0aW9uIG9pKCl7dGhpcy5mYWN0b3J5PW51bGwsdGhpcy5pbnRlcmlvclBvaW50PW51bGwsdGhpcy5tYXhXaWR0aD0wO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdGhpcy5hZGQodCl9ZnVuY3Rpb24gYWkoKXt0aGlzLnBvbHk9bnVsbCx0aGlzLmNlbnRyZVk9bnVsbCx0aGlzLmhpWT1yLk1BWF9WQUxVRSx0aGlzLmxvWT0tci5NQVhfVkFMVUU7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucG9seT10LHRoaXMuaGlZPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldE1heFkoKSx0aGlzLmxvWT10LmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRNaW5ZKCksdGhpcy5jZW50cmVZPW9pLmF2Zyh0aGlzLmxvWSx0aGlzLmhpWSl9ZnVuY3Rpb24gdWkoKXt0aGlzLmNlbnRyb2lkPW51bGwsdGhpcy5taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSx0aGlzLmludGVyaW9yUG9pbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jZW50cm9pZD10LmdldENlbnRyb2lkKCkuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYWRkSW50ZXJpb3IodCksbnVsbD09PXRoaXMuaW50ZXJpb3JQb2ludCYmdGhpcy5hZGRFbmRwb2ludHModCl9ZnVuY3Rpb24gbGkoKXt0aGlzLmNlbnRyb2lkPW51bGwsdGhpcy5taW5EaXN0YW5jZT1yLk1BWF9WQUxVRSx0aGlzLmludGVyaW9yUG9pbnQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jZW50cm9pZD10LmdldENlbnRyb2lkKCkuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYWRkKHQpfWZ1bmN0aW9uIGhpKCl7fWZ1bmN0aW9uIGNpKCl7dGhpcy5wMD1udWxsLHRoaXMucDE9bnVsbCx0aGlzLnAyPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMucDA9dCx0aGlzLnAxPWUsdGhpcy5wMj1ufWZ1bmN0aW9uIGZpKCl7dGhpcy5pbnB1dD1udWxsLHRoaXMuZXh0cmVtYWxQdHM9bnVsbCx0aGlzLmNlbnRyZT1udWxsLHRoaXMucmFkaXVzPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXQ9dH1mdW5jdGlvbiBnaSgpe2lmKHRoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5pc0NvbnZleD1udWxsLHRoaXMuY29udmV4SHVsbFB0cz1udWxsLHRoaXMubWluQmFzZVNlZz1uZXcgY2UsdGhpcy5taW5XaWR0aFB0PW51bGwsdGhpcy5taW5QdEluZGV4PW51bGwsdGhpcy5taW5XaWR0aD0wLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Z2kuY2FsbCh0aGlzLHQsITEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0R2VvbT1lLHRoaXMuaXNDb252ZXg9bn19ZnVuY3Rpb24gZGkoKXt0aGlzLmlucHV0R2VvbT1udWxsLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBwaSgpe3hlLmFwcGx5KHRoaXMpLHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fWZ1bmN0aW9uIHZpKCl7dGhpcy5fb3JpZz1udWxsLHRoaXMuX3N5bT1udWxsLHRoaXMuX25leHQ9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5fb3JpZz10fWZ1bmN0aW9uIG1pKCl7dGhpcy5faXNNYXJrZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3ZpLmNhbGwodGhpcyx0KX1mdW5jdGlvbiB5aSgpe3RoaXMudmVydGV4TWFwPW5ldyB0ZX1mdW5jdGlvbiB4aSgpe3RoaXMuX2lzU3RhcnQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO21pLmNhbGwodGhpcyx0KX1mdW5jdGlvbiBFaSgpe3lpLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIElpKCl7dGhpcy5yZXN1bHQ9bnVsbCx0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmdyYXBoPW51bGwsdGhpcy5saW5lcz1uZXcgSSx0aGlzLm5vZGVFZGdlU3RhY2s9bmV3IHBlLHRoaXMucmluZ1N0YXJ0RWRnZT1udWxsLHRoaXMuZ3JhcGg9bmV3IEVpfWZ1bmN0aW9uIE5pKCl7dGhpcy5pdGVtcz1uZXcgSSx0aGlzLnN1Ym5vZGU9bmV3IEFycmF5KDQpLmZpbGwobnVsbCl9ZnVuY3Rpb24gQ2koKXt9ZnVuY3Rpb24gU2kodCxlKXt2YXIgbixpLHIscyxvPXszMjp7ZDoxMjcsYzoxMjgsYjowLGE6MH0sNjQ6e2Q6MzI3NTIsYzowLGI6MCxhOjB9fSxhPXszMjo4LDY0OjExfVt0XTtpZihzfHwobj0wPmV8fDA+MS9lLGlzRmluaXRlKGUpfHwocz1vW3RdLG4mJihzLmQrPTE8PHQvNC0xKSxpPU1hdGgucG93KDIsYSktMSxyPTApKSwhcyl7Zm9yKGk9ezMyOjEyNyw2NDoxMDIzfVt0XSxyPU1hdGguYWJzKGUpO3I+PTI7KWkrKyxyLz0yO2Zvcig7MT5yJiZpPjA7KWktLSxyKj0yOzA+PWkmJihyLz0yKSwzMj09PXQmJmk+MjU0JiYocz17ZDpuPzI1NToxMjcsYzoxMjgsYjowLGE6MH0saT1NYXRoLnBvdygyLGEpLTEscj0wKX1yZXR1cm4gaX1mdW5jdGlvbiB3aSgpe3RoaXMucHQ9bmV3IGcsdGhpcy5sZXZlbD0wLHRoaXMuZW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuY29tcHV0ZUtleSh0KX1mdW5jdGlvbiBMaSgpe05pLmFwcGx5KHRoaXMpLHRoaXMuZW52PW51bGwsdGhpcy5jZW50cmV4PW51bGwsdGhpcy5jZW50cmV5PW51bGwsdGhpcy5sZXZlbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVudj10LHRoaXMubGV2ZWw9ZSx0aGlzLmNlbnRyZXg9KHQuZ2V0TWluWCgpK3QuZ2V0TWF4WCgpKS8yLHRoaXMuY2VudHJleT0odC5nZXRNaW5ZKCkrdC5nZXRNYXhZKCkpLzJ9ZnVuY3Rpb24gUmkoKXt9ZnVuY3Rpb24gVGkoKXtOaS5hcHBseSh0aGlzKX1mdW5jdGlvbiBQaSgpe3RoaXMucm9vdD1udWxsLHRoaXMubWluRXh0ZW50PTEsdGhpcy5yb290PW5ldyBUaX1mdW5jdGlvbiBiaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWV9ZnVuY3Rpb24gT2kodCl7dGhpcy5nZW9tZXRyeUZhY3Rvcnk9dHx8bmV3IGllLHRoaXMucHJlY2lzaW9uTW9kZWw9dGhpcy5nZW9tZXRyeUZhY3RvcnkuZ2V0UHJlY2lzaW9uTW9kZWwoKSx0aGlzLnBhcnNlcj1uZXcgYmkodGhpcy5nZW9tZXRyeUZhY3RvcnkpfWZ1bmN0aW9uIF9pKCl7dGhpcy5wYXJzZXI9bmV3IGJpKHRoaXMuZ2VvbWV0cnlGYWN0b3J5KX1mdW5jdGlvbiBNaSh0KXt0aGlzLmdlb21ldHJ5RmFjdG9yeT10fHxuZXcgaWUsdGhpcy5wcmVjaXNpb25Nb2RlbD10aGlzLmdlb21ldHJ5RmFjdG9yeS5nZXRQcmVjaXNpb25Nb2RlbCgpLHRoaXMucGFyc2VyPW5ldyByZSh0aGlzLmdlb21ldHJ5RmFjdG9yeSl9ZnVuY3Rpb24gRGkodCl7cmV0dXJuW3QueCx0LnldfWZ1bmN0aW9uIEFpKHQpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PXR8fG5ldyBpZX1mdW5jdGlvbiBGaSgpe2lmKHRoaXMubm9kZXI9bnVsbCx0aGlzLnNjYWxlRmFjdG9yPW51bGwsdGhpcy5vZmZzZXRYPW51bGwsdGhpcy5vZmZzZXRZPW51bGwsdGhpcy5pc1NjYWxlZD0hMSwyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO0ZpLmNhbGwodGhpcyx0LGUsMCwwKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07YXJndW1lbnRzWzJdLGFyZ3VtZW50c1szXTt0aGlzLm5vZGVyPW4sdGhpcy5zY2FsZUZhY3Rvcj1pLHRoaXMuaXNTY2FsZWQ9IXRoaXMuaXNJbnRlZ2VyUHJlY2lzaW9uKCl9fWZ1bmN0aW9uIEdpKCl7aWYodGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmlzQ2xvc2VkRW5kcG9pbnRzSW5JbnRlcmlvcj0hMCx0aGlzLm5vblNpbXBsZUxvY2F0aW9uPW51bGwsMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0R2VvbT10fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmlucHV0R2VvbT1lLHRoaXMuaXNDbG9zZWRFbmRwb2ludHNJbkludGVyaW9yPSFuLmlzSW5Cb3VuZGFyeSgyKX19ZnVuY3Rpb24gcWkoKXt0aGlzLnB0PW51bGwsdGhpcy5pc0Nsb3NlZD1udWxsLHRoaXMuZGVncmVlPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHQ9dCx0aGlzLmlzQ2xvc2VkPSExLHRoaXMuZGVncmVlPTB9ZnVuY3Rpb24gQmkoKXtpZih0aGlzLnF1YWRyYW50U2VnbWVudHM9QmkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUyx0aGlzLmVuZENhcFN0eWxlPUJpLkNBUF9ST1VORCx0aGlzLmpvaW5TdHlsZT1CaS5KT0lOX1JPVU5ELHRoaXMubWl0cmVMaW1pdD1CaS5ERUZBVUxUX01JVFJFX0xJTUlULHRoaXMuX2lzU2luZ2xlU2lkZWQ9ITEsdGhpcy5zaW1wbGlmeUZhY3Rvcj1CaS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUiwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyh0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07dGhpcy5zZXRRdWFkcmFudFNlZ21lbnRzKGUpLHRoaXMuc2V0RW5kQ2FwU3R5bGUobil9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG89YXJndW1lbnRzWzNdO3RoaXMuc2V0UXVhZHJhbnRTZWdtZW50cyhpKSx0aGlzLnNldEVuZENhcFN0eWxlKHIpLHRoaXMuc2V0Sm9pblN0eWxlKHMpLHRoaXMuc2V0TWl0cmVMaW1pdChvKX19ZnVuY3Rpb24gemkoKXt0aGlzLm1pbkluZGV4PS0xLHRoaXMubWluQ29vcmQ9bnVsbCx0aGlzLm1pbkRlPW51bGwsdGhpcy5vcmllbnRlZERlPW51bGx9ZnVuY3Rpb24gVmkoKXt0aGlzLmFycmF5Xz1bXX1mdW5jdGlvbiBraSgpe3RoaXMuZmluZGVyPW51bGwsdGhpcy5kaXJFZGdlTGlzdD1uZXcgSSx0aGlzLm5vZGVzPW5ldyBJLHRoaXMucmlnaHRNb3N0Q29vcmQ9bnVsbCx0aGlzLmVudj1udWxsLHRoaXMuZmluZGVyPW5ldyB6aX1mdW5jdGlvbiBZaSgpe3RoaXMuaW5wdXRMaW5lPW51bGwsXG50aGlzLmRpc3RhbmNlVG9sPW51bGwsdGhpcy5pc0RlbGV0ZWQ9bnVsbCx0aGlzLmFuZ2xlT3JpZW50YXRpb249aGUuQ09VTlRFUkNMT0NLV0lTRTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dExpbmU9dH1mdW5jdGlvbiBVaSgpe3RoaXMucHRMaXN0PW51bGwsdGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMubWluaW1pbVZlcnRleERpc3RhbmNlPTAsdGhpcy5wdExpc3Q9bmV3IEl9ZnVuY3Rpb24gWGkoKXt0aGlzLm1heEN1cnZlU2VnbWVudEVycm9yPTAsdGhpcy5maWxsZXRBbmdsZVF1YW50dW09bnVsbCx0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3I9MSx0aGlzLnNlZ0xpc3Q9bnVsbCx0aGlzLmRpc3RhbmNlPTAsdGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuYnVmUGFyYW1zPW51bGwsdGhpcy5saT1udWxsLHRoaXMuczA9bnVsbCx0aGlzLnMxPW51bGwsdGhpcy5zMj1udWxsLHRoaXMuc2VnMD1uZXcgY2UsdGhpcy5zZWcxPW5ldyBjZSx0aGlzLm9mZnNldDA9bmV3IGNlLHRoaXMub2Zmc2V0MT1uZXcgY2UsdGhpcy5zaWRlPTAsdGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSExO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTt0aGlzLnByZWNpc2lvbk1vZGVsPXQsdGhpcy5idWZQYXJhbXM9ZSx0aGlzLmxpPW5ldyBhZSx0aGlzLmZpbGxldEFuZ2xlUXVhbnR1bT1NYXRoLlBJLzIvZS5nZXRRdWFkcmFudFNlZ21lbnRzKCksZS5nZXRRdWFkcmFudFNlZ21lbnRzKCk+PTgmJmUuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX1JPVU5EJiYodGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPVhpLk1BWF9DTE9TSU5HX1NFR19MRU5fRkFDVE9SKSx0aGlzLmluaXQobil9ZnVuY3Rpb24gSGkoKXt0aGlzLmRpc3RhbmNlPTAsdGhpcy5wcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMuYnVmUGFyYW1zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucHJlY2lzaW9uTW9kZWw9dCx0aGlzLmJ1ZlBhcmFtcz1lfWZ1bmN0aW9uIFdpKCl7dGhpcy5zdWJncmFwaHM9bnVsbCx0aGlzLnNlZz1uZXcgY2UsdGhpcy5jZ2E9bmV3IGhlO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnN1YmdyYXBocz10fWZ1bmN0aW9uIGppKCl7dGhpcy51cHdhcmRTZWc9bnVsbCx0aGlzLmxlZnREZXB0aD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnVwd2FyZFNlZz1uZXcgY2UodCksdGhpcy5sZWZ0RGVwdGg9ZX1mdW5jdGlvbiBLaSgpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5kaXN0YW5jZT1udWxsLHRoaXMuY3VydmVCdWlsZGVyPW51bGwsdGhpcy5jdXJ2ZUxpc3Q9bmV3IEk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaW5wdXRHZW9tPXQsdGhpcy5kaXN0YW5jZT1lLHRoaXMuY3VydmVCdWlsZGVyPW59ZnVuY3Rpb24gWmkoKXt0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITEsdGhpcy5oYXNQcm9wZXI9ITEsdGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMSx0aGlzLmhhc0ludGVyaW9yPSExLHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ9bnVsbCx0aGlzLmxpPW51bGwsdGhpcy5pc1NlbGZJbnRlcnNlY3Rpb249bnVsbCx0aGlzLm51bUludGVyc2VjdGlvbnM9MCx0aGlzLm51bUludGVyaW9ySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtUHJvcGVySW50ZXJzZWN0aW9ucz0wLHRoaXMubnVtVGVzdHM9MDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saT10fWZ1bmN0aW9uIFFpKCl7dGhpcy5idWZQYXJhbXM9bnVsbCx0aGlzLndvcmtpbmdQcmVjaXNpb25Nb2RlbD1udWxsLHRoaXMud29ya2luZ05vZGVyPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsLHRoaXMuZ3JhcGg9bnVsbCx0aGlzLmVkZ2VMaXN0PW5ldyBuaTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5idWZQYXJhbXM9dH1mdW5jdGlvbiBKaSgpe3RoaXMubGk9bmV3IGFlLHRoaXMuc2VnU3RyaW5ncz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNlZ1N0cmluZ3M9dH1mdW5jdGlvbiAkaSgpe3RoaXMubGk9bnVsbCx0aGlzLnB0PW51bGwsdGhpcy5vcmlnaW5hbFB0PW51bGwsdGhpcy5wdFNjYWxlZD1udWxsLHRoaXMucDBTY2FsZWQ9bnVsbCx0aGlzLnAxU2NhbGVkPW51bGwsdGhpcy5zY2FsZUZhY3Rvcj1udWxsLHRoaXMubWlueD1udWxsLHRoaXMubWF4eD1udWxsLHRoaXMubWlueT1udWxsLHRoaXMubWF4eT1udWxsLHRoaXMuY29ybmVyPW5ldyBBcnJheSg0KS5maWxsKG51bGwpLHRoaXMuc2FmZUVudj1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXTtpZih0aGlzLm9yaWdpbmFsUHQ9dCx0aGlzLnB0PXQsdGhpcy5zY2FsZUZhY3Rvcj1lLHRoaXMubGk9biwwPj1lKXRocm93IG5ldyBpKFwiU2NhbGUgZmFjdG9yIG11c3QgYmUgbm9uLXplcm9cIik7MSE9PWUmJih0aGlzLnB0PW5ldyBnKHRoaXMuc2NhbGUodC54KSx0aGlzLnNjYWxlKHQueSkpLHRoaXMucDBTY2FsZWQ9bmV3IGcsdGhpcy5wMVNjYWxlZD1uZXcgZyksdGhpcy5pbml0Q29ybmVycyh0aGlzLnB0KX1mdW5jdGlvbiB0cigpe3RoaXMudGVtcEVudjE9bmV3IEMsdGhpcy5zZWxlY3RlZFNlZ21lbnQ9bmV3IGNlfWZ1bmN0aW9uIGVyKCl7dGhpcy5pbmRleD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmluZGV4PXR9ZnVuY3Rpb24gbnIoKXt0ci5hcHBseSh0aGlzKSx0aGlzLmhvdFBpeGVsPW51bGwsdGhpcy5wYXJlbnRFZGdlPW51bGwsdGhpcy5ob3RQaXhlbFZlcnRleEluZGV4PW51bGwsdGhpcy5faXNOb2RlQWRkZWQ9ITE7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO3RoaXMuaG90UGl4ZWw9dCx0aGlzLnBhcmVudEVkZ2U9ZSx0aGlzLmhvdFBpeGVsVmVydGV4SW5kZXg9bn1mdW5jdGlvbiBpcigpe3RoaXMubGk9bnVsbCx0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpPXQsdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnM9bmV3IEl9ZnVuY3Rpb24gcnIoKXt0aGlzLnBtPW51bGwsdGhpcy5saT1udWxsLHRoaXMuc2NhbGVGYWN0b3I9bnVsbCx0aGlzLm5vZGVyPW51bGwsdGhpcy5wb2ludFNuYXBwZXI9bnVsbCx0aGlzLm5vZGVkU2VnU3RyaW5ncz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnBtPXQsdGhpcy5saT1uZXcgYWUsdGhpcy5saS5zZXRQcmVjaXNpb25Nb2RlbCh0KSx0aGlzLnNjYWxlRmFjdG9yPXQuZ2V0U2NhbGUoKX1mdW5jdGlvbiBzcigpe2lmKHRoaXMuYXJnR2VvbT1udWxsLHRoaXMuZGlzdGFuY2U9bnVsbCx0aGlzLmJ1ZlBhcmFtcz1uZXcgQmksdGhpcy5yZXN1bHRHZW9tZXRyeT1udWxsLHRoaXMuc2F2ZUV4Y2VwdGlvbj1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hcmdHZW9tPXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuYXJnR2VvbT1lLHRoaXMuYnVmUGFyYW1zPW59fWZ1bmN0aW9uIG9yKCl7dGhpcy5jb21wcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXBzPXR9ZnVuY3Rpb24gYXIoKXtpZih0aGlzLmNvbXBvbmVudD1udWxsLHRoaXMuc2VnSW5kZXg9bnVsbCx0aGlzLnB0PW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTthci5jYWxsKHRoaXMsdCxhci5JTlNJREVfQVJFQSxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5jb21wb25lbnQ9bix0aGlzLnNlZ0luZGV4PWksdGhpcy5wdD1yfX1mdW5jdGlvbiB1cigpe3RoaXMucHRzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucHRzPXR9ZnVuY3Rpb24gbHIoKXt0aGlzLmxvY2F0aW9ucz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxvY2F0aW9ucz10fWZ1bmN0aW9uIGhyKCl7aWYodGhpcy5nZW9tPW51bGwsdGhpcy50ZXJtaW5hdGVEaXN0YW5jZT0wLHRoaXMucHRMb2NhdG9yPW5ldyBUZSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb249bnVsbCx0aGlzLm1pbkRpc3RhbmNlPXIuTUFYX1ZBTFVFLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aHIuY2FsbCh0aGlzLHQsZSwwKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5nZW9tPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLHRoaXMuZ2VvbVswXT1uLHRoaXMuZ2VvbVsxXT1pLHRoaXMudGVybWluYXRlRGlzdGFuY2U9c319ZnVuY3Rpb24gY3IoKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmRpcmVjdGVkRWRnZXM9bmV3IEksdGhpcy5jb29yZGluYXRlcz1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmZhY3Rvcnk9dH1mdW5jdGlvbiBmcigpe3RoaXMuX2lzTWFya2VkPSExLHRoaXMuX2lzVmlzaXRlZD0hMSx0aGlzLmRhdGE9bnVsbH1mdW5jdGlvbiBncigpe2ZyLmFwcGx5KHRoaXMpLHRoaXMucGFyZW50RWRnZT1udWxsLHRoaXMuZnJvbT1udWxsLHRoaXMudG89bnVsbCx0aGlzLnAwPW51bGwsdGhpcy5wMT1udWxsLHRoaXMuc3ltPW51bGwsdGhpcy5lZGdlRGlyZWN0aW9uPW51bGwsdGhpcy5xdWFkcmFudD1udWxsLHRoaXMuYW5nbGU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl0saT1hcmd1bWVudHNbM107dGhpcy5mcm9tPXQsdGhpcy50bz1lLHRoaXMuZWRnZURpcmVjdGlvbj1pLHRoaXMucDA9dC5nZXRDb29yZGluYXRlKCksdGhpcy5wMT1uO3ZhciByPXRoaXMucDEueC10aGlzLnAwLngscz10aGlzLnAxLnktdGhpcy5wMC55O3RoaXMucXVhZHJhbnQ9SmUucXVhZHJhbnQocixzKSx0aGlzLmFuZ2xlPU1hdGguYXRhbjIocyxyKX1mdW5jdGlvbiBkcigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtnci5jYWxsKHRoaXMsdCxlLG4saSl9ZnVuY3Rpb24gcHIoKXtpZihmci5hcHBseSh0aGlzKSx0aGlzLmRpckVkZ2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCk7ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuc2V0RGlyZWN0ZWRFZGdlcyh0LGUpfX1mdW5jdGlvbiB2cigpe3RoaXMub3V0RWRnZXM9bmV3IEksdGhpcy5zb3J0ZWQ9ITF9ZnVuY3Rpb24gbXIoKXtpZihmci5hcHBseSh0aGlzKSx0aGlzLnB0PW51bGwsdGhpcy5kZVN0YXI9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO21yLmNhbGwodGhpcyx0LG5ldyB2cil9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMucHQ9ZSx0aGlzLmRlU3Rhcj1ufX1mdW5jdGlvbiB5cigpe3ByLmFwcGx5KHRoaXMpLHRoaXMubGluZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmU9dH1mdW5jdGlvbiB4cigpe3RoaXMubm9kZU1hcD1uZXcgcnR9ZnVuY3Rpb24gRXIoKXt0aGlzLmVkZ2VzPW5ldyBKLHRoaXMuZGlyRWRnZXM9bmV3IEosdGhpcy5ub2RlTWFwPW5ldyB4cn1mdW5jdGlvbiBJcigpe0VyLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIE5yKCl7dGhpcy5ncmFwaD1uZXcgSXIsdGhpcy5tZXJnZWRMaW5lU3RyaW5ncz1udWxsLHRoaXMuZmFjdG9yeT1udWxsLHRoaXMuZWRnZVN0cmluZ3M9bnVsbH1mdW5jdGlvbiBDcigpe3RoaXMuZWRnZVJpbmc9bnVsbCx0aGlzLm5leHQ9bnVsbCx0aGlzLmxhYmVsPS0xO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTtnci5jYWxsKHRoaXMsdCxlLG4saSl9ZnVuY3Rpb24gU3IoKXtwci5hcHBseSh0aGlzKSx0aGlzLmxpbmU9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5saW5lPXR9ZnVuY3Rpb24gd3IoKXt0aGlzLmZhY3Rvcnk9bnVsbCx0aGlzLmRlTGlzdD1uZXcgSSx0aGlzLmxvd2VzdEVkZ2U9bnVsbCx0aGlzLnJpbmc9bnVsbCx0aGlzLnJpbmdQdHM9bnVsbCx0aGlzLmhvbGVzPW51bGwsdGhpcy5zaGVsbD1udWxsLHRoaXMuX2lzSG9sZT1udWxsLHRoaXMuX2lzUHJvY2Vzc2VkPSExLHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITEsdGhpcy5faXNJbmNsdWRlZD0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gTHIoKXt9ZnVuY3Rpb24gUnIoKXtFci5hcHBseSh0aGlzKSx0aGlzLmZhY3Rvcnk9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5mYWN0b3J5PXR9ZnVuY3Rpb24gVHIoKXtpZih0aGlzLmxpbmVTdHJpbmdBZGRlcj1uZXcgUHIodGhpcyksdGhpcy5ncmFwaD1udWxsLHRoaXMuZGFuZ2xlcz1uZXcgSSx0aGlzLmN1dEVkZ2VzPW5ldyBJLHRoaXMuaW52YWxpZFJpbmdMaW5lcz1uZXcgSSx0aGlzLmhvbGVMaXN0PW51bGwsdGhpcy5zaGVsbExpc3Q9bnVsbCx0aGlzLnBvbHlMaXN0PW51bGwsdGhpcy5pc0NoZWNraW5nUmluZ3NWYWxpZD0hMCx0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsPW51bGwsdGhpcy5nZW9tRmFjdG9yeT1udWxsLDA9PT1hcmd1bWVudHMubGVuZ3RoKVRyLmNhbGwodGhpcywhMSk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXh0cmFjdE9ubHlQb2x5Z29uYWw9dH19ZnVuY3Rpb24gUHIoKXt0aGlzLnA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wPXR9ZnVuY3Rpb24gYnIoKXt9ZnVuY3Rpb24gT3IoKXtpZih0aGlzLmVkZ2VFbmRzPW5ldyBJLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07T3IuY2FsbCh0aGlzLG51bGwsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9KGFyZ3VtZW50c1swXSxhcmd1bWVudHNbMV0pO0VuLmNhbGwodGhpcyxlLmdldEVkZ2UoKSxlLmdldENvb3JkaW5hdGUoKSxlLmdldERpcmVjdGVkQ29vcmRpbmF0ZSgpLG5ldyBnbihlLmdldExhYmVsKCkpKSx0aGlzLmluc2VydChlKX19ZnVuY3Rpb24gX3IoKXtQbi5hcHBseSh0aGlzKX1mdW5jdGlvbiBNcigpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt5bi5jYWxsKHRoaXMsdCxlKX1mdW5jdGlvbiBEcigpe05uLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIEFyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5wdExvY2F0b3I9bmV3IFRlLHRoaXMuYXJnPW51bGwsdGhpcy5ub2Rlcz1uZXcgeG4obmV3IERyKSx0aGlzLmltPW51bGwsdGhpcy5pc29sYXRlZEVkZ2VzPW5ldyBJLHRoaXMuaW52YWxpZFBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYXJnPXR9ZnVuY3Rpb24gRnIoKXt0aGlzLnJlY3RFbnY9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIEdyKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5yZWN0RW52PW51bGwsdGhpcy5kaWFnVXAwPW51bGwsdGhpcy5kaWFnVXAxPW51bGwsdGhpcy5kaWFnRG93bjA9bnVsbCx0aGlzLmRpYWdEb3duMT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RFbnY9dCx0aGlzLmRpYWdVcDA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLHRoaXMuZGlhZ1VwMT1uZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksdGhpcy5kaWFnRG93bjA9bmV3IGcodC5nZXRNaW5YKCksdC5nZXRNYXhZKCkpLHRoaXMuZGlhZ0Rvd24xPW5ldyBnKHQuZ2V0TWF4WCgpLHQuZ2V0TWluWSgpKX1mdW5jdGlvbiBxcigpe3RoaXMuX2lzRG9uZT0hMX1mdW5jdGlvbiBCcigpe3RoaXMucmVjdGFuZ2xlPW51bGwsdGhpcy5yZWN0RW52PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMucmVjdGFuZ2xlPXQsdGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpfWZ1bmN0aW9uIHpyKCl7cXIuYXBwbHkodGhpcyksdGhpcy5yZWN0RW52PW51bGwsdGhpcy5faW50ZXJzZWN0cz0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXR9ZnVuY3Rpb24gVnIoKXtxci5hcHBseSh0aGlzKSx0aGlzLnJlY3RTZXE9bnVsbCx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLl9jb250YWluc1BvaW50PSExO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnJlY3RTZXE9dC5nZXRFeHRlcmlvclJpbmcoKS5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSx0aGlzLnJlY3RFbnY9dC5nZXRFbnZlbG9wZUludGVybmFsKCl9ZnVuY3Rpb24ga3IoKXtxci5hcHBseSh0aGlzKSx0aGlzLnJlY3RFbnY9bnVsbCx0aGlzLnJlY3RJbnRlcnNlY3Rvcj1udWxsLHRoaXMuaGFzSW50ZXJzZWN0aW9uPSExLHRoaXMucDA9bmV3IGcsdGhpcy5wMT1uZXcgZzt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZWN0RW52PXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHRoaXMucmVjdEludGVyc2VjdG9yPW5ldyBHcih0aGlzLnJlY3RFbnYpfWZ1bmN0aW9uIFlyKCl7aWYodGhpcy5fcmVsYXRlPW51bGwsMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aS5jYWxsKHRoaXMsdCxlKSx0aGlzLl9yZWxhdGU9bmV3IEFyKHRoaXMuYXJnKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGkuY2FsbCh0aGlzLG4saSxyKSx0aGlzLl9yZWxhdGU9bmV3IEFyKHRoaXMuYXJnKX19ZnVuY3Rpb24gVXIoKXt0aGlzLmdlb21GYWN0b3J5PW51bGwsdGhpcy5za2lwRW1wdHk9ITEsdGhpcy5pbnB1dEdlb21zPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUZhY3Rvcnk9VXIuZXh0cmFjdEZhY3RvcnkodCksdGhpcy5pbnB1dEdlb21zPXR9ZnVuY3Rpb24gWHIoKXt0aGlzLnBvaW50R2VvbT1udWxsLHRoaXMub3RoZXJHZW9tPW51bGwsdGhpcy5nZW9tRmFjdD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnBvaW50R2VvbT10LHRoaXMub3RoZXJHZW9tPWUsdGhpcy5nZW9tRmFjdD1lLmdldEZhY3RvcnkoKX1mdW5jdGlvbiBIcigpe3RoaXMuc29ydEluZGV4PS0xLHRoaXMuY29tcHM9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5zb3J0SW5kZXg9dCx0aGlzLmNvbXBzPWV9ZnVuY3Rpb24gV3IoKXt0aGlzLmlucHV0UG9seXM9bnVsbCx0aGlzLmdlb21GYWN0b3J5PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5wdXRQb2x5cz10LG51bGw9PT10aGlzLmlucHV0UG9seXMmJih0aGlzLmlucHV0UG9seXM9bmV3IEkpfWZ1bmN0aW9uIGpyKCl7aWYodGhpcy5wb2x5Z29ucz1uZXcgSSx0aGlzLmxpbmVzPW5ldyBJLHRoaXMucG9pbnRzPW5ldyBJLHRoaXMuZ2VvbUZhY3Q9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLmV4dHJhY3QoZSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmdlb21GYWN0PWksdGhpcy5leHRyYWN0KG4pfX1mdW5jdGlvbiBLcigpe3RoaXMuZ2VvbWV0cnlGYWN0b3J5PW5ldyBpZSx0aGlzLmdlb21HcmFwaD1udWxsLHRoaXMuZGlzY29ubmVjdGVkUmluZ2Nvb3JkPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUdyYXBoPXR9ZnVuY3Rpb24gWnIoKXt0aGlzLml0ZW1zPW5ldyBJLHRoaXMuc3Vibm9kZT1bbnVsbCxudWxsXX1mdW5jdGlvbiBRcigpe2lmKHRoaXMubWluPW51bGwsdGhpcy5tYXg9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aCl0aGlzLm1pbj0wLHRoaXMubWF4PTA7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuaW5pdCh0Lm1pbix0Lm1heCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuaW5pdChlLG4pfX1mdW5jdGlvbiBKcigpe3RoaXMucHQ9MCx0aGlzLmxldmVsPTAsdGhpcy5pbnRlcnZhbD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmNvbXB1dGVLZXkodCl9ZnVuY3Rpb24gJHIoKXtaci5hcHBseSh0aGlzKSx0aGlzLmludGVydmFsPW51bGwsdGhpcy5jZW50cmU9bnVsbCx0aGlzLmxldmVsPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW50ZXJ2YWw9dCx0aGlzLmxldmVsPWUsdGhpcy5jZW50cmU9KHQuZ2V0TWluKCkrdC5nZXRNYXgoKSkvMn1mdW5jdGlvbiB0cygpe1pyLmFwcGx5KHRoaXMpfWZ1bmN0aW9uIGVzKCl7dGhpcy5yb290PW51bGwsdGhpcy5taW5FeHRlbnQ9MSx0aGlzLnJvb3Q9bmV3IHRzfWZ1bmN0aW9uIG5zKCl7fWZ1bmN0aW9uIGlzKCl7dGhpcy5yaW5nPW51bGwsdGhpcy50cmVlPW51bGwsdGhpcy5jcm9zc2luZ3M9MCx0aGlzLmludGVydmFsPW5ldyBRcjt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yaW5nPXQsdGhpcy5idWlsZEluZGV4KCl9ZnVuY3Rpb24gcnMoKXt0ci5hcHBseSh0aGlzKSx0aGlzLm1jcD1udWxsLHRoaXMucD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLm1jcD10LHRoaXMucD1lfWZ1bmN0aW9uIHNzKCl7dGhpcy5ub2Rlcz1uZXcgeG4obmV3IERyKX1mdW5jdGlvbiBvcygpe3RoaXMubGk9bmV3IGFlLHRoaXMuZ2VvbUdyYXBoPW51bGwsdGhpcy5ub2RlR3JhcGg9bmV3IHNzLHRoaXMuaW52YWxpZFBvaW50PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ2VvbUdyYXBoPXR9ZnVuY3Rpb24gYXMoKXt0aGlzLmdyYXBoPW51bGwsdGhpcy5yaW5ncz1uZXcgSSx0aGlzLnRvdGFsRW52PW5ldyBDLHRoaXMuaW5kZXg9bnVsbCx0aGlzLm5lc3RlZFB0PW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZ3JhcGg9dH1mdW5jdGlvbiB1cygpe2lmKHRoaXMuZXJyb3JUeXBlPW51bGwsdGhpcy5wdD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dXMuY2FsbCh0aGlzLHQsbnVsbCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZXJyb3JUeXBlPWUsbnVsbCE9PW4mJih0aGlzLnB0PW4uY29weSgpKX19ZnVuY3Rpb24gbHMoKXt0aGlzLnBhcmVudEdlb21ldHJ5PW51bGwsdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkPSExLHRoaXMudmFsaWRFcnI9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wYXJlbnRHZW9tZXRyeT10fWZ1bmN0aW9uIGhzKCl7X3QuQ29vcmRpbmF0ZU9wZXJhdGlvbi5hcHBseSh0aGlzKSx0aGlzLnRhcmdldFBNPW51bGwsdGhpcy5yZW1vdmVDb2xsYXBzZWQ9ITA7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMudGFyZ2V0UE09dCx0aGlzLnJlbW92ZUNvbGxhcHNlZD1lfWZ1bmN0aW9uIGNzKCl7dGhpcy50YXJnZXRQTT1udWxsLHRoaXMucmVtb3ZlQ29sbGFwc2VkPSEwLHRoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWw9ITEsdGhpcy5pc1BvaW50d2lzZT0hMTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy50YXJnZXRQTT10fWZ1bmN0aW9uIGZzKCl7dGhpcy5wdHM9bnVsbCx0aGlzLnVzZVB0PW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuc2VnPW5ldyBjZTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wdHM9dH1mdW5jdGlvbiBncygpe3RoaXMuaW5wdXRHZW9tPW51bGwsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuaXNFbnN1cmVWYWxpZFRvcG9sb2d5PSEwO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmlucHV0R2VvbT10fWZ1bmN0aW9uIGRzKCl7eGUuYXBwbHkodGhpcyksdGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9ITAsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT10LHRoaXMuZGlzdGFuY2VUb2xlcmFuY2U9ZX1mdW5jdGlvbiBwcygpe2lmKHRoaXMucGFyZW50PW51bGwsdGhpcy5pbmRleD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cHMuY2FsbCh0aGlzLHQsZSxudWxsLC0xKX1lbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl0scz1hcmd1bWVudHNbM107Y2UuY2FsbCh0aGlzLG4saSksdGhpcy5wYXJlbnQ9cix0aGlzLmluZGV4PXN9fWZ1bmN0aW9uIHZzKCl7aWYodGhpcy5wYXJlbnRMaW5lPW51bGwsdGhpcy5zZWdzPW51bGwsdGhpcy5yZXN1bHRTZWdzPW5ldyBJLHRoaXMubWluaW11bVNpemU9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3ZzLmNhbGwodGhpcyx0LDIpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnBhcmVudExpbmU9ZSx0aGlzLm1pbmltdW1TaXplPW4sdGhpcy5pbml0KCl9fWZ1bmN0aW9uIG1zKCl7dGhpcy5pbmRleD1uZXcgUGl9ZnVuY3Rpb24geXMoKXt0aGlzLnF1ZXJ5U2VnPW51bGwsdGhpcy5pdGVtcz1uZXcgSTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5xdWVyeVNlZz10fWZ1bmN0aW9uIHhzKCl7dGhpcy5saT1uZXcgYWUsdGhpcy5pbnB1dEluZGV4PW5ldyBtcyx0aGlzLm91dHB1dEluZGV4PW5ldyBtcyx0aGlzLmxpbmU9bnVsbCx0aGlzLmxpbmVQdHM9bnVsbCx0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPTA7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMuaW5wdXRJbmRleD10LHRoaXMub3V0cHV0SW5kZXg9ZX1mdW5jdGlvbiBFcygpe3RoaXMuaW5wdXRJbmRleD1uZXcgbXMsdGhpcy5vdXRwdXRJbmRleD1uZXcgbXMsdGhpcy5kaXN0YW5jZVRvbGVyYW5jZT0wfWZ1bmN0aW9uIElzKCl7dGhpcy5pbnB1dEdlb209bnVsbCx0aGlzLmxpbmVTaW1wbGlmaWVyPW5ldyBFcyx0aGlzLmxpbmVzdHJpbmdNYXA9bnVsbDt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbnB1dEdlb209dH1mdW5jdGlvbiBOcygpe3hlLmFwcGx5KHRoaXMpLHRoaXMubGluZXN0cmluZ01hcD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmxpbmVzdHJpbmdNYXA9dH1mdW5jdGlvbiBDcygpe3RoaXMudHBzPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudHBzPXR9ZnVuY3Rpb24gU3MoKXt0aGlzLnNlZz1udWxsLHRoaXMuc2VnTGVuPW51bGwsdGhpcy5zcGxpdFB0PW51bGwsdGhpcy5taW5pbXVtTGVuPTA7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2VnPXQsdGhpcy5zZWdMZW49dC5nZXRMZW5ndGgoKX1mdW5jdGlvbiB3cygpe31mdW5jdGlvbiBMcygpe31mdW5jdGlvbiBScygpe31mdW5jdGlvbiBUcygpe2lmKHRoaXMucD1udWxsLDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5wPW5ldyBnKHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnA9bmV3IGcoZSxuKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07dGhpcy5wPW5ldyBnKGkscixzKX19ZnVuY3Rpb24gUHMoKXt0aGlzLl9pc09uQ29uc3RyYWludD1udWxsLHRoaXMuY29uc3RyYWludD1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTtUcy5jYWxsKHRoaXMsdCl9ZnVuY3Rpb24gYnMoKXt0aGlzLl9yb3Q9bnVsbCx0aGlzLnZlcnRleD1udWxsLHRoaXMubmV4dD1udWxsLHRoaXMuZGF0YT1udWxsfWZ1bmN0aW9uIE9zKCl7dGhpcy5zdWJkaXY9bnVsbCx0aGlzLmlzVXNpbmdUb2xlcmFuY2U9ITE7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc3ViZGl2PXQsdGhpcy5pc1VzaW5nVG9sZXJhbmNlPXQuZ2V0VG9sZXJhbmNlKCk+MH1mdW5jdGlvbiBfcygpe31mdW5jdGlvbiBNcygpe3RoaXMuc3ViZGl2PW51bGwsdGhpcy5sYXN0RWRnZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnN1YmRpdj10LHRoaXMuaW5pdCgpfWZ1bmN0aW9uIERzKCl7aWYodGhpcy5zZWc9bnVsbCwxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIGU9YXJndW1lbnRzWzBdO2wuY2FsbCh0aGlzLFwiTG9jYXRlIGZhaWxlZCB0byBjb252ZXJnZSAoYXQgZWRnZTogXCIrZStcIikuICBQb3NzaWJsZSBjYXVzZXMgaW5jbHVkZSBpbnZhbGlkIFN1YmRpdmlzaW9uIHRvcG9sb2d5IG9yIHZlcnkgY2xvc2Ugc2l0ZXNcIiksdGhpcy5zZWc9bmV3IGNlKGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07bC5jYWxsKHRoaXMsRHMubXNnV2l0aFNwYXRpYWwobixpKSksdGhpcy5zZWc9bmV3IGNlKGkpfX1mdW5jdGlvbiBBcygpe31mdW5jdGlvbiBGcygpe3RoaXMudmlzaXRlZEtleT0wLHRoaXMucXVhZEVkZ2VzPW5ldyBJLHRoaXMuc3RhcnRpbmdFZGdlPW51bGwsdGhpcy50b2xlcmFuY2U9bnVsbCx0aGlzLmVkZ2VDb2luY2lkZW5jZVRvbGVyYW5jZT1udWxsLHRoaXMuZnJhbWVWZXJ0ZXg9bmV3IEFycmF5KDMpLmZpbGwobnVsbCksdGhpcy5mcmFtZUVudj1udWxsLHRoaXMubG9jYXRvcj1udWxsLHRoaXMuc2VnPW5ldyBjZSx0aGlzLnRyaUVkZ2VzPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLnRvbGVyYW5jZT1lLHRoaXMuZWRnZUNvaW5jaWRlbmNlVG9sZXJhbmNlPWUvRnMuRURHRV9DT0lOQ0lERU5DRV9UT0xfRkFDVE9SLHRoaXMuY3JlYXRlRnJhbWUodCksdGhpcy5zdGFydGluZ0VkZ2U9dGhpcy5pbml0U3ViZGl2KCksdGhpcy5sb2NhdG9yPW5ldyBNcyh0aGlzKX1mdW5jdGlvbiBHcygpe31mdW5jdGlvbiBxcygpe3RoaXMudHJpTGlzdD1uZXcgSX1mdW5jdGlvbiBCcygpe3RoaXMudHJpTGlzdD1uZXcgSX1mdW5jdGlvbiB6cygpe3RoaXMuY29vcmRMaXN0PW5ldyBOLHRoaXMudHJpQ29vcmRzPW5ldyBJfWZ1bmN0aW9uIFZzKCl7aWYodGhpcy5scz1udWxsLHRoaXMuZGF0YT1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5scz1uZXcgY2UodCxlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5scz1uZXcgY2UobixpKSx0aGlzLmRhdGE9cn1lbHNlIGlmKDY9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1hcmd1bWVudHNbMl0sdT1hcmd1bWVudHNbM10sbD1hcmd1bWVudHNbNF0saD1hcmd1bWVudHNbNV07VnMuY2FsbCh0aGlzLG5ldyBnKHMsbyxhKSxuZXcgZyh1LGwsaCkpfWVsc2UgaWYoNz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxkPWFyZ3VtZW50c1syXSxwPWFyZ3VtZW50c1szXSx2PWFyZ3VtZW50c1s0XSxtPWFyZ3VtZW50c1s1XSx5PWFyZ3VtZW50c1s2XTtWcy5jYWxsKHRoaXMsbmV3IGcoYyxmLGQpLG5ldyBnKHAsdixtKSx5KX19ZnVuY3Rpb24ga3MoKXt9ZnVuY3Rpb24gWXMoKXtpZih0aGlzLnA9bnVsbCx0aGlzLmRhdGE9bnVsbCx0aGlzLmxlZnQ9bnVsbCx0aGlzLnJpZ2h0PW51bGwsdGhpcy5jb3VudD1udWxsLDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5wPW5ldyBnKHQpLHRoaXMubGVmdD1udWxsLHRoaXMucmlnaHQ9bnVsbCx0aGlzLmNvdW50PTEsdGhpcy5kYXRhPWV9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9YXJndW1lbnRzWzJdO3RoaXMucD1uZXcgZyhuLGkpLHRoaXMubGVmdD1udWxsLHRoaXMucmlnaHQ9bnVsbCx0aGlzLmNvdW50PTEsdGhpcy5kYXRhPXJ9fWZ1bmN0aW9uIFVzKCl7aWYodGhpcy5yb290PW51bGwsdGhpcy5udW1iZXJPZk5vZGVzPW51bGwsdGhpcy50b2xlcmFuY2U9bnVsbCwwPT09YXJndW1lbnRzLmxlbmd0aClVcy5jYWxsKHRoaXMsMCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMudG9sZXJhbmNlPXR9fWZ1bmN0aW9uIFhzKCl7dGhpcy50b2xlcmFuY2U9bnVsbCx0aGlzLm1hdGNoTm9kZT1udWxsLHRoaXMubWF0Y2hEaXN0PTAsdGhpcy5wPW51bGw7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3RoaXMucD10LHRoaXMudG9sZXJhbmNlPWV9ZnVuY3Rpb24gSHMoKXt0aGlzLmluaXRpYWxWZXJ0aWNlcz1udWxsLHRoaXMuc2VnVmVydGljZXM9bnVsbCx0aGlzLnNlZ21lbnRzPW5ldyBJLHRoaXMuc3ViZGl2PW51bGwsdGhpcy5pbmNEZWw9bnVsbCx0aGlzLmNvbnZleEh1bGw9bnVsbCx0aGlzLnNwbGl0RmluZGVyPW5ldyBMcyx0aGlzLmtkdD1udWxsLHRoaXMudmVydGV4RmFjdG9yeT1udWxsLHRoaXMuY29tcHV0ZUFyZWFFbnY9bnVsbCx0aGlzLnNwbGl0UHQ9bnVsbCx0aGlzLnRvbGVyYW5jZT1udWxsO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmluaXRpYWxWZXJ0aWNlcz1uZXcgSSh0KSx0aGlzLnRvbGVyYW5jZT1lLHRoaXMua2R0PW5ldyBVcyhlKX1mdW5jdGlvbiBXcygpe3RoaXMuc2l0ZUNvb3Jkcz1udWxsLHRoaXMudG9sZXJhbmNlPTAsdGhpcy5zdWJkaXY9bnVsbH1mdW5jdGlvbiBqcygpe3RoaXMuc2l0ZUNvb3Jkcz1udWxsLHRoaXMuY29uc3RyYWludExpbmVzPW51bGwsdGhpcy50b2xlcmFuY2U9MCx0aGlzLnN1YmRpdj1udWxsLHRoaXMuY29uc3RyYWludFZlcnRleE1hcD1uZXcgcnR9ZnVuY3Rpb24gS3MoKXt0aGlzLnNpdGVDb29yZHM9bnVsbCx0aGlzLnRvbGVyYW5jZT0wLHRoaXMuc3ViZGl2PW51bGwsdGhpcy5jbGlwRW52PW51bGwsdGhpcy5kaWFncmFtRW52PW51bGx9ZnVuY3Rpb24gWnMoKXt9QXJyYXkucHJvdG90eXBlLmZpbGx8fChBcnJheS5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9T2JqZWN0KHRoaXMpLG49cGFyc2VJbnQoZS5sZW5ndGgsMTApLGk9YXJndW1lbnRzWzFdLHI9cGFyc2VJbnQoaSwxMCl8fDAscz0wPnI/TWF0aC5tYXgobityLDApOk1hdGgubWluKHIsbiksbz1hcmd1bWVudHNbMl0sYT12b2lkIDA9PT1vP246cGFyc2VJbnQobywxMCl8fDAsdT0wPmE/TWF0aC5tYXgobithLDApOk1hdGgubWluKGEsbik7dT5zO3MrKyllW3NdPXQ7cmV0dXJuIGV9KSxOdW1iZXIuaXNGaW5pdGU9TnVtYmVyLmlzRmluaXRlfHxmdW5jdGlvbih0KXtyZXR1cm5cIm51bWJlclwiPT10eXBlb2YgdCYmaXNGaW5pdGUodCl9LE51bWJlci5pc0ludGVnZXI9TnVtYmVyLmlzSW50ZWdlcnx8ZnVuY3Rpb24odCl7cmV0dXJuXCJudW1iZXJcIj09dHlwZW9mIHQmJmlzRmluaXRlKHQpJiZNYXRoLmZsb29yKHQpPT09dH0sTnVtYmVyLnBhcnNlRmxvYXQ9TnVtYmVyLnBhcnNlRmxvYXR8fHBhcnNlRmxvYXQsTnVtYmVyLmlzTmFOPU51bWJlci5pc05hTnx8ZnVuY3Rpb24odCl7cmV0dXJuIHQhPT10fSxNYXRoLnRydW5jPU1hdGgudHJ1bmN8fGZ1bmN0aW9uKHQpe3JldHVybiAwPnQ/TWF0aC5jZWlsKHQpOk1hdGguZmxvb3IodCl9LGUobi5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG59fSksbi5lcXVhbHNXaXRoVG9sZXJhbmNlPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTWF0aC5hYnModC1lKTw9bn0sci5pc05hTj1mdW5jdGlvbih0KXtyZXR1cm4gTnVtYmVyLmlzTmFOKHQpfSxyLmRvdWJsZVRvTG9uZ0JpdHM9ZnVuY3Rpb24odCl7cmV0dXJuIHR9LHIubG9uZ0JpdHNUb0RvdWJsZT1mdW5jdGlvbih0KXtyZXR1cm4gdH0sci5pc0luZmluaXRlPWZ1bmN0aW9uKHQpe3JldHVybiFOdW1iZXIuaXNGaW5pdGUodCl9LHIuTUFYX1ZBTFVFPU51bWJlci5NQVhfVkFMVUUsaChjLGwpLGUoYy5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGN9fSksZShmLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZn19KSxmLnNob3VsZE5ldmVyUmVhY2hIZXJlPWZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZi5zaG91bGROZXZlclJlYWNoSGVyZShudWxsKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhyb3cgbmV3IGMoXCJTaG91bGQgbmV2ZXIgcmVhY2ggaGVyZVwiKyhudWxsIT09dD9cIjogXCIrdDpcIlwiKSl9fSxmLmlzVHJ1ZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07Zi5pc1RydWUodCxudWxsKX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYoIWUpdGhyb3cgbnVsbD09PW4/bmV3IGM6bmV3IGMobil9fSxmLmVxdWFscz1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07Zi5lcXVhbHModCxlLG51bGwpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXTtpZighaS5lcXVhbHMobikpdGhyb3cgbmV3IGMoXCJFeHBlY3RlZCBcIituK1wiIGJ1dCBlbmNvdW50ZXJlZCBcIitpKyhudWxsIT09cj9cIjogXCIrcjpcIlwiKSl9fSxlKGcucHJvdG90eXBlLHtzZXRPcmRpbmF0ZTpmdW5jdGlvbih0LGUpe3N3aXRjaCh0KXtjYXNlIGcuWDp0aGlzLng9ZTticmVhaztjYXNlIGcuWTp0aGlzLnk9ZTticmVhaztjYXNlIGcuWjp0aGlzLno9ZTticmVhaztkZWZhdWx0OnRocm93IG5ldyBpKFwiSW52YWxpZCBvcmRpbmF0ZSBpbmRleDogXCIrdCl9fSxlcXVhbHMyRDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMueCE9PXQueD8hMTp0aGlzLnk9PT10Lnl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gbi5lcXVhbHNXaXRoVG9sZXJhbmNlKHRoaXMueCxlLngsaSk/ISFuLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy55LGUueSxpKTohMX19LGdldE9yZGluYXRlOmZ1bmN0aW9uKHQpe3N3aXRjaCh0KXtjYXNlIGcuWDpyZXR1cm4gdGhpcy54O2Nhc2UgZy5ZOnJldHVybiB0aGlzLnk7Y2FzZSBnLlo6cmV0dXJuIHRoaXMuen10aHJvdyBuZXcgaShcIkludmFsaWQgb3JkaW5hdGUgaW5kZXg6IFwiK3QpfSxlcXVhbHMzRDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy54PT09dC54JiZ0aGlzLnk9PT10LnkmJih0aGlzLno9PT10Lnp8fHIuaXNOYU4odGhpcy56KSYmci5pc05hTih0LnopKX0sZXF1YWxzOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgZz90aGlzLmVxdWFsczJEKHQpOiExfSxlcXVhbEluWjpmdW5jdGlvbih0LGUpe3JldHVybiBuLmVxdWFsc1dpdGhUb2xlcmFuY2UodGhpcy56LHQueixlKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMueDxlLng/LTE6dGhpcy54PmUueD8xOnRoaXMueTxlLnk/LTE6dGhpcy55PmUueT8xOjB9LGNsb25lOmZ1bmN0aW9uKCl7dHJ5e3ZhciB0PW51bGw7cmV0dXJuIHR9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwidGhpcyBzaG91bGRuJ3QgaGFwcGVuIGJlY2F1c2UgdGhpcyBjbGFzcyBpcyBDbG9uZWFibGVcIiksbnVsbDt0aHJvdyB0fWZpbmFsbHl7fX0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIihcIit0aGlzLngrXCIsIFwiK3RoaXMueStcIiwgXCIrdGhpcy56K1wiKVwifSxkaXN0YW5jZTNEOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMueC10Lngsbj10aGlzLnktdC55LGk9dGhpcy56LXQuejtyZXR1cm4gTWF0aC5zcXJ0KGUqZStuKm4raSppKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy54LXQueCxuPXRoaXMueS10Lnk7cmV0dXJuIE1hdGguc3FydChlKmUrbipuKX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD0xNztyZXR1cm4gdD0zNyp0K2cuaGFzaENvZGUodGhpcy54KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLnkpfSxzZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3RoaXMueD10LngsdGhpcy55PXQueSx0aGlzLno9dC56fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzLG8sdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGd9fSksZy5oYXNoQ29kZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1yLmRvdWJsZVRvTG9uZ0JpdHModCk7cmV0dXJuIE1hdGgudHJ1bmMoZV5lPj4+MzIpfX0sZShkLnByb3RvdHlwZSx7Y29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lLHI9ZC5jb21wYXJlKG4ueCxpLngpO2lmKDAhPT1yKXJldHVybiByO3ZhciBzPWQuY29tcGFyZShuLnksaS55KTtpZigwIT09cylyZXR1cm4gcztpZih0aGlzLmRpbWVuc2lvbnNUb1Rlc3Q8PTIpcmV0dXJuIDA7dmFyIG89ZC5jb21wYXJlKG4ueixpLnopO3JldHVybiBvfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZH19KSxkLmNvbXBhcmU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT50Py0xOnQ+ZT8xOnIuaXNOYU4odCk/ci5pc05hTihlKT8wOi0xOnIuaXNOYU4oZSk/MTowfSxnLkRpbWVuc2lvbmFsQ29tcGFyYXRvcj1kLGcuc2VyaWFsVmVyc2lvblVJRD0weDVjYmYyYzIzNWM3ZTU4MDAsZy5OVUxMX09SRElOQVRFPXIuTmFOLGcuWD0wLGcuWT0xLGcuWj0yLHAucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXt9LHAucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXt9LHAucHJvdG90eXBlLnJlbW92ZT1mdW5jdGlvbigpe30sdi5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LHYucHJvdG90eXBlLml0ZXJhdG9yPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7fSx2LnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt9LG0ucHJvdG90eXBlPW5ldyBFcnJvcixtLnByb3RvdHlwZS5uYW1lPVwiSW5kZXhPdXRPZkJvdW5kc0V4Y2VwdGlvblwiLHkucHJvdG90eXBlPU9iamVjdC5jcmVhdGUodi5wcm90b3R5cGUpLHkucHJvdG90eXBlLmNvbnN0cnVjdG9yPXkseS5wcm90b3R5cGUuZ2V0PWZ1bmN0aW9uKCl7fSx5LnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24oKXt9LHkucHJvdG90eXBlLmlzRW1wdHk9ZnVuY3Rpb24oKXt9LHgucHJvdG90eXBlPW5ldyBFcnJvcix4LnByb3RvdHlwZS5uYW1lPVwiTm9TdWNoRWxlbWVudEV4Y2VwdGlvblwiLEUucHJvdG90eXBlPW5ldyBFcnJvcixFLnByb3RvdHlwZS5uYW1lPVwiT3BlcmF0aW9uTm90U3VwcG9ydGVkXCIsSS5wcm90b3R5cGU9T2JqZWN0LmNyZWF0ZSh5LnByb3RvdHlwZSksSS5wcm90b3R5cGUuY29uc3RydWN0b3I9SSxJLnByb3RvdHlwZS5lbnN1cmVDYXBhY2l0eT1mdW5jdGlvbigpe30sSS5wcm90b3R5cGUuaW50ZXJmYWNlc189ZnVuY3Rpb24oKXtyZXR1cm5beSx2XX0sSS5wcm90b3R5cGUuYWRkPWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5Xy5wdXNoKHQpLCEwfSxJLnByb3RvdHlwZS5jbGVhcj1mdW5jdGlvbigpe3RoaXMuYXJyYXlfPVtdfSxJLnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxJLnByb3RvdHlwZS5zZXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFycmF5X1t0XTtyZXR1cm4gdGhpcy5hcnJheV9bdF09ZSxufSxJLnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgUXModGhpcyl9LEkucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZigwPnR8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBtO3JldHVybiB0aGlzLmFycmF5X1t0XX0sSS5wcm90b3R5cGUuaXNFbXB0eT1mdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5hcnJheV8ubGVuZ3RofSxJLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLmxlbmd0aH0sSS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxJLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPSExLG49MCxpPXRoaXMuYXJyYXlfLmxlbmd0aDtpPm47bisrKWlmKHRoaXMuYXJyYXlfW25dPT09dCl7dGhpcy5hcnJheV8uc3BsaWNlKG4sMSksZT0hMDticmVha31yZXR1cm4gZX07dmFyIFFzPWZ1bmN0aW9uKHQpe3RoaXMuYXJyYXlMaXN0Xz10LHRoaXMucG9zaXRpb25fPTB9O1FzLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmFycmF5TGlzdF8uc2l6ZSgpKXRocm93IG5ldyB4O3JldHVybiB0aGlzLmFycmF5TGlzdF8uZ2V0KHRoaXMucG9zaXRpb25fKyspfSxRcy5wcm90b3R5cGUuaGFzTmV4dD1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBvc2l0aW9uXzx0aGlzLmFycmF5TGlzdF8uc2l6ZSgpfSxRcy5wcm90b3R5cGUuc2V0PWZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFycmF5TGlzdF8uc2V0KHRoaXMucG9zaXRpb25fLTEsdCl9LFFzLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRX0saChOLEkpLGUoTi5wcm90b3R5cGUse2dldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0KHQpfSxhZGRBbGw6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPSExLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl0aGlzLmFkZChpLm5leHQoKSxlKSxuPSEwO3JldHVybiBufXJldHVybiBJLnByb3RvdHlwZS5hZGRBbGwuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxjbG9uZTpmdW5jdGlvbiB0KCl7Zm9yKHZhciB0PUkucHJvdG90eXBlLmNsb25lLmNhbGwodGhpcyksZT0wO2U8dGhpcy5zaXplKCk7ZSsrKXQuYWRkKGUsdGhpcy5nZXQoZSkuY29weSgpKTtyZXR1cm4gdH0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b0FycmF5KE4uY29vcmRBcnJheVR5cGUpfSxhZGQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO0kucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQoZSxuLCEwKSwhMH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07aWYoIXImJnRoaXMuc2l6ZSgpPj0xKXt2YXIgcz10aGlzLmdldCh0aGlzLnNpemUoKS0xKTtpZihzLmVxdWFsczJEKGkpKXJldHVybiBudWxsfUkucHJvdG90eXBlLmFkZC5jYWxsKHRoaXMsaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5hZGQobyxhKSwhMH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkmJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0saD1hcmd1bWVudHNbMl07aWYoaClmb3IodmFyIGM9MDtjPHUubGVuZ3RoO2MrKyl0aGlzLmFkZCh1W2NdLGwpO2Vsc2UgZm9yKHZhciBjPXUubGVuZ3RoLTE7Yz49MDtjLS0pdGhpcy5hZGQodVtjXSxsKTtyZXR1cm4hMH1pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBmPWFyZ3VtZW50c1swXSxkPWFyZ3VtZW50c1sxXSxwPWFyZ3VtZW50c1syXTtpZighcCl7dmFyIHY9dGhpcy5zaXplKCk7aWYodj4wKXtpZihmPjApe3ZhciBtPXRoaXMuZ2V0KGYtMSk7aWYobS5lcXVhbHMyRChkKSlyZXR1cm4gbnVsbH1pZih2PmYpe3ZhciB5PXRoaXMuZ2V0KGYpO2lmKHkuZXF1YWxzMkQoZCkpcmV0dXJuIG51bGx9fX1JLnByb3RvdHlwZS5hZGQuY2FsbCh0aGlzLGYsZCl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB4PWFyZ3VtZW50c1swXSxFPWFyZ3VtZW50c1sxXSxOPWFyZ3VtZW50c1syXSxDPWFyZ3VtZW50c1szXSxTPTE7Tj5DJiYoUz0tMSk7Zm9yKHZhciBjPU47YyE9PUM7Yys9Uyl0aGlzLmFkZCh4W2NdLEUpO3JldHVybiEwfX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7dGhpcy5zaXplKCk+MCYmdGhpcy5hZGQobmV3IGcodGhpcy5nZXQoMCkpLCExKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTn19KSxOLmNvb3JkQXJyYXlUeXBlPW5ldyBBcnJheSgwKS5maWxsKG51bGwpLGUoQy5wcm90b3R5cGUse2dldEFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRXaWR0aCgpKnRoaXMuZ2V0SGVpZ2h0KCl9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBDKSlyZXR1cm4hMTt2YXIgZT10O3JldHVybiB0aGlzLmlzTnVsbCgpP2UuaXNOdWxsKCk6dGhpcy5tYXh4PT09ZS5nZXRNYXhYKCkmJnRoaXMubWF4eT09PWUuZ2V0TWF4WSgpJiZ0aGlzLm1pbng9PT1lLmdldE1pblgoKSYmdGhpcy5taW55PT09ZS5nZXRNaW5ZKCl9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtpZih0aGlzLmlzTnVsbCgpfHx0LmlzTnVsbCgpfHwhdGhpcy5pbnRlcnNlY3RzKHQpKXJldHVybiBuZXcgQzt2YXIgZT10aGlzLm1pbng+dC5taW54P3RoaXMubWlueDp0Lm1pbngsbj10aGlzLm1pbnk+dC5taW55P3RoaXMubWlueTp0Lm1pbnksaT10aGlzLm1heHg8dC5tYXh4P3RoaXMubWF4eDp0Lm1heHgscj10aGlzLm1heHk8dC5tYXh5P3RoaXMubWF4eTp0Lm1heHk7cmV0dXJuIG5ldyBDKGUsaSxuLHIpfSxpc051bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh4PHRoaXMubWlueH0sZ2V0TWF4WDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heHh9LGNvdmVyczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb3ZlcnModC54LHQueSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOdWxsKCl8fGUuaXNOdWxsKCk/ITE6ZS5nZXRNaW5YKCk+PXRoaXMubWlueCYmZS5nZXRNYXhYKCk8PXRoaXMubWF4eCYmZS5nZXRNaW5ZKCk+PXRoaXMubWlueSYmZS5nZXRNYXhZKCk8PXRoaXMubWF4eX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzTnVsbCgpPyExOm4+PXRoaXMubWlueCYmbjw9dGhpcy5tYXh4JiZpPj10aGlzLm1pbnkmJmk8PXRoaXMubWF4eX19LGludGVyc2VjdHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOdWxsKCl8fHQuaXNOdWxsKCk/ITE6ISh0Lm1pbng+dGhpcy5tYXh4fHx0Lm1heHg8dGhpcy5taW54fHx0Lm1pbnk+dGhpcy5tYXh5fHx0Lm1heHk8dGhpcy5taW55KX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKGUueCxlLnkpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNOdWxsKCk/ITE6IShuPnRoaXMubWF4eHx8bjx0aGlzLm1pbnh8fGk+dGhpcy5tYXh5fHxpPHRoaXMubWlueSl9fSxnZXRNaW5ZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWlueX0sZ2V0TWluWDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbnh9LGV4cGFuZFRvSW5jbHVkZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmV4cGFuZFRvSW5jbHVkZSh0LngsdC55KX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyl7dmFyIGU9YXJndW1lbnRzWzBdO2lmKGUuaXNOdWxsKCkpcmV0dXJuIG51bGw7dGhpcy5pc051bGwoKT8odGhpcy5taW54PWUuZ2V0TWluWCgpLHRoaXMubWF4eD1lLmdldE1heFgoKSx0aGlzLm1pbnk9ZS5nZXRNaW5ZKCksdGhpcy5tYXh5PWUuZ2V0TWF4WSgpKTooZS5taW54PHRoaXMubWlueCYmKHRoaXMubWlueD1lLm1pbngpLGUubWF4eD50aGlzLm1heHgmJih0aGlzLm1heHg9ZS5tYXh4KSxlLm1pbnk8dGhpcy5taW55JiYodGhpcy5taW55PWUubWlueSksZS5tYXh5PnRoaXMubWF4eSYmKHRoaXMubWF4eT1lLm1heHkpKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMuaXNOdWxsKCk/KHRoaXMubWlueD1uLHRoaXMubWF4eD1uLHRoaXMubWlueT1pLHRoaXMubWF4eT1pKToobjx0aGlzLm1pbngmJih0aGlzLm1pbng9biksbj50aGlzLm1heHgmJih0aGlzLm1heHg9biksaTx0aGlzLm1pbnkmJih0aGlzLm1pbnk9aSksaT50aGlzLm1heHkmJih0aGlzLm1heHk9aSkpfX0sbWluRXh0ZW50OmZ1bmN0aW9uKCl7aWYodGhpcy5pc051bGwoKSlyZXR1cm4gMDt2YXIgdD10aGlzLmdldFdpZHRoKCksZT10aGlzLmdldEhlaWdodCgpO3JldHVybiBlPnQ/dDplfSxnZXRXaWR0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTnVsbCgpPzA6dGhpcy5tYXh4LXRoaXMubWlueH0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuaXNOdWxsKCk/ZS5pc051bGwoKT8wOi0xOmUuaXNOdWxsKCk/MTp0aGlzLm1pbng8ZS5taW54Py0xOnRoaXMubWlueD5lLm1pbng/MTp0aGlzLm1pbnk8ZS5taW55Py0xOnRoaXMubWlueT5lLm1pbnk/MTp0aGlzLm1heHg8ZS5tYXh4Py0xOnRoaXMubWF4eD5lLm1heHg/MTp0aGlzLm1heHk8ZS5tYXh5Py0xOnRoaXMubWF4eT5lLm1heHk/MTowfSx0cmFuc2xhdGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5pc051bGwoKT9udWxsOnZvaWQgdGhpcy5pbml0KHRoaXMuZ2V0TWluWCgpK3QsdGhpcy5nZXRNYXhYKCkrdCx0aGlzLmdldE1pblkoKStlLHRoaXMuZ2V0TWF4WSgpK2UpfSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVyblwiRW52W1wiK3RoaXMubWlueCtcIiA6IFwiK3RoaXMubWF4eCtcIiwgXCIrdGhpcy5taW55K1wiIDogXCIrdGhpcy5tYXh5K1wiXVwifSxzZXRUb051bGw6ZnVuY3Rpb24oKXt0aGlzLm1pbng9MCx0aGlzLm1heHg9LTEsdGhpcy5taW55PTAsdGhpcy5tYXh5PS0xfSxnZXRIZWlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc051bGwoKT8wOnRoaXMubWF4eS10aGlzLm1pbnl9LG1heEV4dGVudDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOdWxsKCkpcmV0dXJuIDA7dmFyIHQ9dGhpcy5nZXRXaWR0aCgpLGU9dGhpcy5nZXRIZWlnaHQoKTtyZXR1cm4gdD5lP3Q6ZX0sZXhwYW5kQnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuZXhwYW5kQnkodCx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07aWYodGhpcy5pc051bGwoKSlyZXR1cm4gbnVsbDt0aGlzLm1pbngtPWUsdGhpcy5tYXh4Kz1lLHRoaXMubWlueS09bix0aGlzLm1heHkrPW4sKHRoaXMubWlueD50aGlzLm1heHh8fHRoaXMubWlueT50aGlzLm1heHkpJiZ0aGlzLnNldFRvTnVsbCgpfX0sY29udGFpbnM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY292ZXJzKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNvdmVycyhlKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvdmVycyhuLGkpfX0sY2VudHJlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOdWxsKCk/bnVsbDpuZXcgZygodGhpcy5nZXRNaW5YKCkrdGhpcy5nZXRNYXhYKCkpLzIsKHRoaXMuZ2V0TWluWSgpK3RoaXMuZ2V0TWF4WSgpKS8yKX0saW5pdDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMuc2V0VG9OdWxsKCk7ZWxzZSBpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5pbml0KHQueCx0LngsdC55LHQueSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEMpe3ZhciBlPWFyZ3VtZW50c1swXTt0aGlzLm1pbng9ZS5taW54LHRoaXMubWF4eD1lLm1heHgsdGhpcy5taW55PWUubWlueSx0aGlzLm1heHk9ZS5tYXh5fX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07dGhpcy5pbml0KG4ueCxpLngsbi55LGkueSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9YXJndW1lbnRzWzNdO3M+cj8odGhpcy5taW54PXIsdGhpcy5tYXh4PXMpOih0aGlzLm1pbng9cyx0aGlzLm1heHg9ciksYT5vPyh0aGlzLm1pbnk9byx0aGlzLm1heHk9YSk6KHRoaXMubWlueT1hLHRoaXMubWF4eT1vKX19LGdldE1heFk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh5fSxkaXN0YW5jZTpmdW5jdGlvbih0KXtpZih0aGlzLmludGVyc2VjdHModCkpcmV0dXJuIDA7dmFyIGU9MDt0aGlzLm1heHg8dC5taW54P2U9dC5taW54LXRoaXMubWF4eDp0aGlzLm1pbng+dC5tYXh4JiYoZT10aGlzLm1pbngtdC5tYXh4KTt2YXIgbj0wO3JldHVybiB0aGlzLm1heHk8dC5taW55P249dC5taW55LXRoaXMubWF4eTp0aGlzLm1pbnk+dC5tYXh5JiYobj10aGlzLm1pbnktdC5tYXh5KSwwPT09ZT9uOjA9PT1uP2U6TWF0aC5zcXJ0KGUqZStuKm4pfSxoYXNoQ29kZTpmdW5jdGlvbigpe3ZhciB0PTE3O3JldHVybiB0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1pbngpLHQ9MzcqdCtnLmhhc2hDb2RlKHRoaXMubWF4eCksdD0zNyp0K2cuaGFzaENvZGUodGhpcy5taW55KSx0PTM3KnQrZy5oYXNoQ29kZSh0aGlzLm1heHkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDfX0pLEMuaW50ZXJzZWN0cz1mdW5jdGlvbigpe2lmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIG4ueD49KHQueDxlLng/dC54OmUueCkmJm4ueDw9KHQueD5lLng/dC54OmUueCkmJm4ueT49KHQueTxlLnk/dC55OmUueSkmJm4ueTw9KHQueT5lLnk/dC55OmUueSl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXSxhPU1hdGgubWluKHMueCxvLngpLHU9TWF0aC5tYXgocy54LG8ueCksbD1NYXRoLm1pbihpLngsci54KSxoPU1hdGgubWF4KGkueCxyLngpO3JldHVybiBsPnU/ITE6YT5oPyExOihhPU1hdGgubWluKHMueSxvLnkpLHU9TWF0aC5tYXgocy55LG8ueSksbD1NYXRoLm1pbihpLnksci55KSxoPU1hdGgubWF4KGkueSxyLnkpLGw+dT8hMTohKGE+aCkpfX0sQy5zZXJpYWxWZXJzaW9uVUlEPTB4NTE4NDVjZDU1MjE4OTgwMCxoKHcsUyksZSh3LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd319KSxlKEwucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMfX0pLEwudG9Mb2NhdGlvblN5bWJvbD1mdW5jdGlvbih0KXtzd2l0Y2godCl7Y2FzZSBMLkVYVEVSSU9SOnJldHVyblwiZVwiO2Nhc2UgTC5CT1VOREFSWTpyZXR1cm5cImJcIjtjYXNlIEwuSU5URVJJT1I6cmV0dXJuXCJpXCI7Y2FzZSBMLk5PTkU6cmV0dXJuXCItXCJ9dGhyb3cgbmV3IGkoXCJVbmtub3duIGxvY2F0aW9uIHZhbHVlOiBcIit0KX0sTC5JTlRFUklPUj0wLEwuQk9VTkRBUlk9MSxMLkVYVEVSSU9SPTIsTC5OT05FPS0xLGUoVC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFR9fSksVC5sb2cxMD1mdW5jdGlvbih0KXt2YXIgZT1NYXRoLmxvZyh0KTtyZXR1cm4gci5pc0luZmluaXRlKGUpP2U6ci5pc05hTihlKT9lOmUvVC5MT0dfMTB9LFQubWluPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQ7cmV0dXJuIHI+ZSYmKHI9ZSkscj5uJiYocj1uKSxyPmkmJihyPWkpLHJ9LFQuY2xhbXA9ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIGU+dD9lOnQ+bj9uOnR9aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMl0pJiZOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJk51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzFdKSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3JldHVybiByPmk/cjppPnM/czppfX0sVC53cmFwPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDA+dD9lLSAtdCVlOnQlZX0sVC5tYXg9ZnVuY3Rpb24oKXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9dDtyZXR1cm4gZT5pJiYoaT1lKSxuPmkmJihpPW4pLGl9aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXSxpPXI7cmV0dXJuIHM+aSYmKGk9cyksbz5pJiYoaT1vKSxhPmkmJihpPWEpLGl9fSxULmF2ZXJhZ2U9ZnVuY3Rpb24odCxlKXtcbnJldHVybih0K2UpLzJ9LFQuTE9HXzEwPU1hdGgubG9nKDEwKSxQLnByb3RvdHlwZS5hcHBlbmQ9ZnVuY3Rpb24odCl7dGhpcy5zdHIrPXR9LFAucHJvdG90eXBlLnNldENoYXJBdD1mdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLnN0ci5zdWJzdHIoMCx0KStlK3RoaXMuc3RyLnN1YnN0cih0KzEpfSxQLnByb3RvdHlwZS50b1N0cmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5zdHJ9LGIucHJvdG90eXBlLmludFZhbHVlPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LGIucHJvdG90eXBlLmNvbXBhcmVUbz1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy52YWx1ZTx0Py0xOnRoaXMudmFsdWU+dD8xOjB9LGIuaXNOYU49ZnVuY3Rpb24odCl7cmV0dXJuIE51bWJlci5pc05hTih0KX0sTy5pc1doaXRlc3BhY2U9ZnVuY3Rpb24odCl7cmV0dXJuIDMyPj10JiZ0Pj0wfHwxMjc9PXR9LE8udG9VcHBlckNhc2U9ZnVuY3Rpb24odCl7cmV0dXJuIHQudG9VcHBlckNhc2UoKX0sZShfLnByb3RvdHlwZSx7bGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk8dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG88PXQubG99LGV4dHJhY3RTaWduaWZpY2FudERpZ2l0czpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuYWJzKCksaT1fLm1hZ25pdHVkZShuLmhpKSxyPV8uVEVOLnBvdyhpKTtuPW4uZGl2aWRlKHIpLG4uZ3QoXy5URU4pPyhuPW4uZGl2aWRlKF8uVEVOKSxpKz0xKTpuLmx0KF8uT05FKSYmKG49bi5tdWx0aXBseShfLlRFTiksaS09MSk7Zm9yKHZhciBzPWkrMSxvPW5ldyBQLGE9Xy5NQVhfUFJJTlRfRElHSVRTLTEsdT0wO2E+PXU7dSsrKXt0JiZ1PT09cyYmby5hcHBlbmQoXCIuXCIpO3ZhciBsPU1hdGgudHJ1bmMobi5oaSk7aWYoMD5sKWJyZWFrO3ZhciBoPSExLGM9MDtsPjk/KGg9ITAsYz1cIjlcIik6Yz1cIjBcIitsLG8uYXBwZW5kKGMpLG49bi5zdWJ0cmFjdChfLnZhbHVlT2YobCkpLm11bHRpcGx5KF8uVEVOKSxoJiZuLnNlbGZBZGQoXy5URU4pO3ZhciBmPSEwLGc9Xy5tYWduaXR1ZGUobi5oaSk7aWYoMD5nJiZNYXRoLmFicyhnKT49YS11JiYoZj0hMSksIWYpYnJlYWt9cmV0dXJuIGVbMF09aSxvLnRvU3RyaW5nKCl9LHNxcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm11bHRpcGx5KHRoaXMpfSxkb3VibGVWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhpK3RoaXMubG99LHN1YnRyYWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuYWRkKHQubmVnYXRlKCkpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5hZGQoLWUpfX0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5oaT09PXQuaGkmJnRoaXMubG89PT10LmxvfX0saXNaZXJvOmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmhpJiYwPT09dGhpcy5sb30sc2VsZlN1YnRyYWN0OmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOnRoaXMuc2VsZkFkZCgtdC5oaSwtdC5sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmlzTmFOKCk/dGhpczp0aGlzLnNlbGZBZGQoLWUsMCl9fSxnZXRTcGVjaWFsTnVtYmVyU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNaZXJvKCk/XCIwLjBcIjp0aGlzLmlzTmFOKCk/XCJOYU4gXCI6bnVsbH0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmxlKHQpP3RoaXM6dH0sc2VsZkRpdmlkZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmRGl2aWRlKHQuaGksdC5sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZEaXZpZGUoZSwwKX19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9bnVsbCx1PW51bGwsbD1udWxsLGg9bnVsbCxjPW51bGw7cmV0dXJuIHU9dGhpcy5oaS9uLGw9Xy5TUExJVCp1LHI9bC11LGM9Xy5TUExJVCpuLHI9bC1yLHM9dS1yLG89Yy1uLGg9dSpuLG89Yy1vLGE9bi1vLGM9cipvLWgrciphK3MqbytzKmEsbD0odGhpcy5oaS1oLWMrdGhpcy5sby11KmkpL24sYz11K2wsdGhpcy5oaT1jLHRoaXMubG89dS1jK2wsdGhpc319LGR1bXA6ZnVuY3Rpb24oKXtyZXR1cm5cIkREPFwiK3RoaXMuaGkrXCIsIFwiK3RoaXMubG8rXCI+XCJ9LGRpdmlkZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bnVsbCxuPW51bGwsaT1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsLHU9bnVsbCxsPW51bGw7bz10aGlzLmhpL3QuaGksYT1fLlNQTElUKm8sZT1hLW8sbD1fLlNQTElUKnQuaGksZT1hLWUsbj1vLWUsaT1sLXQuaGksdT1vKnQuaGksaT1sLWkscz10LmhpLWksbD1lKmktdStlKnMrbippK24qcyxhPSh0aGlzLmhpLXUtbCt0aGlzLmxvLW8qdC5sbykvdC5oaSxsPW8rYTt2YXIgaD1sLGM9by1sK2E7cmV0dXJuIG5ldyBfKGgsYyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGY9YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKGYpP18uY3JlYXRlTmFOKCk6Xy5jb3B5KHRoaXMpLnNlbGZEaXZpZGUoZiwwKX19LGdlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPnQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPj10LmxvfSxwb3c6ZnVuY3Rpb24odCl7aWYoMD09PXQpcmV0dXJuIF8udmFsdWVPZigxKTt2YXIgZT1uZXcgXyh0aGlzKSxuPV8udmFsdWVPZigxKSxpPU1hdGguYWJzKHQpO2lmKGk+MSlmb3IoO2k+MDspaSUyPT09MSYmbi5zZWxmTXVsdGlwbHkoZSksaS89MixpPjAmJihlPWUuc3FyKCkpO2Vsc2Ugbj1lO3JldHVybiAwPnQ/bi5yZWNpcHJvY2FsKCk6bn0sY2VpbDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gXy5OYU47dmFyIHQ9TWF0aC5jZWlsKHRoaXMuaGkpLGU9MDtyZXR1cm4gdD09PXRoaXMuaGkmJihlPU1hdGguY2VpbCh0aGlzLmxvKSksbmV3IF8odCxlKX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuaGk8ZS5oaT8tMTp0aGlzLmhpPmUuaGk/MTp0aGlzLmxvPGUubG8/LTE6dGhpcy5sbz5lLmxvPzE6MH0scmludDpmdW5jdGlvbigpe2lmKHRoaXMuaXNOYU4oKSlyZXR1cm4gdGhpczt2YXIgdD10aGlzLmFkZCguNSk7cmV0dXJuIHQuZmxvb3IoKX0sc2V0VmFsdWU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pbml0KHQpLHRoaXN9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmluaXQoZSksdGhpc319LG1heDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZSh0KT90aGlzOnR9LHNxcnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBfLnZhbHVlT2YoMCk7aWYodGhpcy5pc05lZ2F0aXZlKCkpcmV0dXJuIF8uTmFOO3ZhciB0PTEvTWF0aC5zcXJ0KHRoaXMuaGkpLGU9dGhpcy5oaSp0LG49Xy52YWx1ZU9mKGUpLGk9dGhpcy5zdWJ0cmFjdChuLnNxcigpKSxyPWkuaGkqKC41KnQpO3JldHVybiBuLmFkZChyKX0sc2VsZkFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIF8pe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5zZWxmQWRkKHQuaGksdC5sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdLG49bnVsbCxpPW51bGwscj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsO3JldHVybiByPXRoaXMuaGkrZSxvPXItdGhpcy5oaSxzPXItbyxzPWUtbysodGhpcy5oaS1zKSxhPXMrdGhpcy5sbyxuPXIrYSxpPWErKHItbiksdGhpcy5oaT1uK2ksdGhpcy5sbz1pKyhuLXRoaXMuaGkpLHRoaXN9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB1PWFyZ3VtZW50c1swXSxsPWFyZ3VtZW50c1sxXSxuPW51bGwsaT1udWxsLGg9bnVsbCxjPW51bGwscj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsO3I9dGhpcy5oaSt1LGg9dGhpcy5sbytsLG89ci10aGlzLmhpLGE9aC10aGlzLmxvLHM9ci1vLGM9aC1hLHM9dS1vKyh0aGlzLmhpLXMpLGM9bC1hKyh0aGlzLmxvLWMpLG89cytoLG49citvLGk9bysoci1uKSxvPWMraTt2YXIgZj1uK28sZz1vKyhuLWYpO3JldHVybiB0aGlzLmhpPWYsdGhpcy5sbz1nLHRoaXN9fSxzZWxmTXVsdGlwbHk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBfKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuc2VsZk11bHRpcGx5KHQuaGksdC5sbyl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNlbGZNdWx0aXBseShlLDApfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1udWxsLHM9bnVsbCxvPW51bGwsYT1udWxsLHU9bnVsbCxsPW51bGw7dT1fLlNQTElUKnRoaXMuaGkscj11LXRoaXMuaGksbD1fLlNQTElUKm4scj11LXIscz10aGlzLmhpLXIsbz1sLW4sdT10aGlzLmhpKm4sbz1sLW8sYT1uLW8sbD1yKm8tdStyKmErcypvK3MqYSsodGhpcy5oaSppK3RoaXMubG8qbik7dmFyIGg9dStsO3I9dS1oO3ZhciBjPWwrcjtyZXR1cm4gdGhpcy5oaT1oLHRoaXMubG89Yyx0aGlzfX0sc2VsZlNxcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlbGZNdWx0aXBseSh0aGlzKX0sZmxvb3I6ZnVuY3Rpb24oKXtpZih0aGlzLmlzTmFOKCkpcmV0dXJuIF8uTmFOO3ZhciB0PU1hdGguZmxvb3IodGhpcy5oaSksZT0wO3JldHVybiB0PT09dGhpcy5oaSYmKGU9TWF0aC5mbG9vcih0aGlzLmxvKSksbmV3IF8odCxlKX0sbmVnYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT90aGlzOm5ldyBfKC10aGlzLmhpLC10aGlzLmxvKX0sY2xvbmU6ZnVuY3Rpb24oKXt0cnl7cmV0dXJuIG51bGx9Y2F0Y2godCl7aWYodCBpbnN0YW5jZW9mIENsb25lTm90U3VwcG9ydGVkRXhjZXB0aW9uKXJldHVybiBudWxsO3Rocm93IHR9ZmluYWxseXt9fSxtdWx0aXBseTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmlzTmFOKCk/Xy5jcmVhdGVOYU4oKTpfLmNvcHkodGhpcykuc2VsZk11bHRpcGx5KHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gci5pc05hTihlKT9fLmNyZWF0ZU5hTigpOl8uY29weSh0aGlzKS5zZWxmTXVsdGlwbHkoZSwwKX19LGlzTmFOOmZ1bmN0aW9uKCl7cmV0dXJuIHIuaXNOYU4odGhpcy5oaSl9LGludFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgudHJ1bmModGhpcy5oaSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9Xy5tYWduaXR1ZGUodGhpcy5oaSk7cmV0dXJuIHQ+PS0zJiYyMD49dD90aGlzLnRvU3RhbmRhcmROb3RhdGlvbigpOnRoaXMudG9TY2lOb3RhdGlvbigpfSx0b1N0YW5kYXJkTm90YXRpb246ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDt2YXIgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCEwLGUpLGk9ZVswXSsxLHI9bjtpZihcIi5cIj09PW4uY2hhckF0KDApKXI9XCIwXCIrbjtlbHNlIGlmKDA+aSlyPVwiMC5cIitfLnN0cmluZ09mQ2hhcihcIjBcIiwtaSkrbjtlbHNlIGlmKC0xPT09bi5pbmRleE9mKFwiLlwiKSl7dmFyIHM9aS1uLmxlbmd0aCxvPV8uc3RyaW5nT2ZDaGFyKFwiMFwiLHMpO3I9bitvK1wiLjBcIn1yZXR1cm4gdGhpcy5pc05lZ2F0aXZlKCk/XCItXCIrcjpyfSxyZWNpcHJvY2FsOmZ1bmN0aW9uKCl7dmFyIHQ9bnVsbCxlPW51bGwsbj1udWxsLGk9bnVsbCxyPW51bGwscz1udWxsLG89bnVsbCxhPW51bGw7cj0xL3RoaXMuaGkscz1fLlNQTElUKnIsdD1zLXIsYT1fLlNQTElUKnRoaXMuaGksdD1zLXQsZT1yLXQsbj1hLXRoaXMuaGksbz1yKnRoaXMuaGksbj1hLW4saT10aGlzLmhpLW4sYT10Km4tbyt0KmkrZSpuK2UqaSxzPSgxLW8tYS1yKnRoaXMubG8pL3RoaXMuaGk7dmFyIHU9citzLGw9ci11K3M7cmV0dXJuIG5ldyBfKHUsbCl9LHRvU2NpTm90YXRpb246ZnVuY3Rpb24oKXtpZih0aGlzLmlzWmVybygpKXJldHVybiBfLlNDSV9OT1RfWkVSTzt2YXIgdD10aGlzLmdldFNwZWNpYWxOdW1iZXJTdHJpbmcoKTtpZihudWxsIT09dClyZXR1cm4gdDt2YXIgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuZXh0cmFjdFNpZ25pZmljYW50RGlnaXRzKCExLGUpLGk9Xy5TQ0lfTk9UX0VYUE9ORU5UX0NIQVIrZVswXTtpZihcIjBcIj09PW4uY2hhckF0KDApKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJGb3VuZCBsZWFkaW5nIHplcm86IFwiK24pO3ZhciByPVwiXCI7bi5sZW5ndGg+MSYmKHI9bi5zdWJzdHJpbmcoMSkpO3ZhciBzPW4uY2hhckF0KDApK1wiLlwiK3I7cmV0dXJuIHRoaXMuaXNOZWdhdGl2ZSgpP1wiLVwiK3MraTpzK2l9LGFiczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzTmFOKCk/Xy5OYU46dGhpcy5pc05lZ2F0aXZlKCk/dGhpcy5uZWdhdGUoKTpuZXcgXyh0aGlzKX0saXNQb3NpdGl2ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhpPjB8fDA9PT10aGlzLmhpJiZ0aGlzLmxvPjB9LGx0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmhpPHQuaGl8fHRoaXMuaGk9PT10LmhpJiZ0aGlzLmxvPHQubG99LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBfLmNvcHkodGhpcykuc2VsZkFkZCh0KX1pZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIF8uY29weSh0aGlzKS5zZWxmQWRkKGUpfX0saW5pdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5oaT10LHRoaXMubG89MH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgXyl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuaGk9ZS5oaSx0aGlzLmxvPWUubG99fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTt0aGlzLmhpPW4sdGhpcy5sbz1pfX0sZ3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaGk+dC5oaXx8dGhpcy5oaT09PXQuaGkmJnRoaXMubG8+dC5sb30saXNOZWdhdGl2ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhpPDB8fDA9PT10aGlzLmhpJiZ0aGlzLmxvPDB9LHRydW5jOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNOYU4oKT9fLk5hTjp0aGlzLmlzUG9zaXRpdmUoKT90aGlzLmZsb29yKCk6dGhpcy5jZWlsKCl9LHNpZ251bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhpPjA/MTp0aGlzLmhpPDA/LTE6dGhpcy5sbz4wPzE6dGhpcy5sbzwwPy0xOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3UscyxvXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX319KSxfLnNxcj1mdW5jdGlvbih0KXtyZXR1cm4gXy52YWx1ZU9mKHQpLnNlbGZNdWx0aXBseSh0KX0sXy52YWx1ZU9mPWZ1bmN0aW9uKCl7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBfLnBhcnNlKHQpfWlmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0pe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IF8oZSl9fSxfLnNxcnQ9ZnVuY3Rpb24odCl7cmV0dXJuIF8udmFsdWVPZih0KS5zcXJ0KCl9LF8ucGFyc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj10Lmxlbmd0aDtPLmlzV2hpdGVzcGFjZSh0LmNoYXJBdChlKSk7KWUrKzt2YXIgaT0hMTtpZihuPmUpe3ZhciByPXQuY2hhckF0KGUpO1wiLVwiIT09ciYmXCIrXCIhPT1yfHwoZSsrLFwiLVwiPT09ciYmKGk9ITApKX1mb3IodmFyIHM9bmV3IF8sbz0wLGE9MCx1PTA7Oyl7aWYoZT49bilicmVhazt2YXIgbD10LmNoYXJBdChlKTtpZihlKyssTy5pc0RpZ2l0KGwpKXt2YXIgaD1sLVwiMFwiO3Muc2VsZk11bHRpcGx5KF8uVEVOKSxzLnNlbGZBZGQoaCksbysrfWVsc2V7aWYoXCIuXCIhPT1sKXtpZihcImVcIj09PWx8fFwiRVwiPT09bCl7dmFyIGM9dC5zdWJzdHJpbmcoZSk7dHJ5e3U9Yi5wYXJzZUludChjKX1jYXRjaChlKXt0aHJvdyBlIGluc3RhbmNlb2YgTnVtYmVyRm9ybWF0RXhjZXB0aW9uP25ldyBOdW1iZXJGb3JtYXRFeGNlcHRpb24oXCJJbnZhbGlkIGV4cG9uZW50IFwiK2MrXCIgaW4gc3RyaW5nIFwiK3QpOmV9ZmluYWxseXt9YnJlYWt9dGhyb3cgbmV3IE51bWJlckZvcm1hdEV4Y2VwdGlvbihcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIitsK1wiJyBhdCBwb3NpdGlvbiBcIitlK1wiIGluIHN0cmluZyBcIit0KX1hPW99fXZhciBmPXMsZz1vLWEtdTtpZigwPT09ZylmPXM7ZWxzZSBpZihnPjApe3ZhciBkPV8uVEVOLnBvdyhnKTtmPXMuZGl2aWRlKGQpfWVsc2UgaWYoMD5nKXt2YXIgZD1fLlRFTi5wb3coLWcpO2Y9cy5tdWx0aXBseShkKX1yZXR1cm4gaT9mLm5lZ2F0ZSgpOmZ9LF8uY3JlYXRlTmFOPWZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBfKHIuTmFOLHIuTmFOKX0sXy5jb3B5PWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgXyh0KX0sXy5tYWduaXR1ZGU9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5hYnModCksbj1NYXRoLmxvZyhlKS9NYXRoLmxvZygxMCksaT1NYXRoLnRydW5jKE1hdGguZmxvb3IobikpLHI9TWF0aC5wb3coMTAsaSk7cmV0dXJuIGU+PTEwKnImJihpKz0xKSxpfSxfLnN0cmluZ09mQ2hhcj1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgUCxpPTA7ZT5pO2krKyluLmFwcGVuZCh0KTtyZXR1cm4gbi50b1N0cmluZygpfSxfLlBJPW5ldyBfKDMuMTQxNTkyNjUzNTg5NzkzLDEuMjI0NjQ2Nzk5MTQ3MzUzMmUtMTYpLF8uVFdPX1BJPW5ldyBfKDYuMjgzMTg1MzA3MTc5NTg2LDIuNDQ5MjkzNTk4Mjk0NzA2NGUtMTYpLF8uUElfMj1uZXcgXygxLjU3MDc5NjMyNjc5NDg5NjYsNi4xMjMyMzM5OTU3MzY3NjZlLTE3KSxfLkU9bmV3IF8oMi43MTgyODE4Mjg0NTkwNDUsMS40NDU2NDY4OTE3MjkyNTAyZS0xNiksXy5OYU49bmV3IF8oci5OYU4sci5OYU4pLF8uRVBTPTEuMjMyNTk1MTY0NDA3ODNlLTMyLF8uU1BMSVQ9MTM0MjE3NzI5LF8uTUFYX1BSSU5UX0RJR0lUUz0zMixfLlRFTj1fLnZhbHVlT2YoMTApLF8uT05FPV8udmFsdWVPZigxKSxfLlNDSV9OT1RfRVhQT05FTlRfQ0hBUj1cIkVcIixfLlNDSV9OT1RfWkVSTz1cIjAuMEUwXCIsZShNLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTX19KSxNLm9yaWVudGF0aW9uSW5kZXg9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPU0ub3JpZW50YXRpb25JbmRleEZpbHRlcih0LGUsbik7aWYoMT49aSlyZXR1cm4gaTt2YXIgcj1fLnZhbHVlT2YoZS54KS5zZWxmQWRkKC10LngpLHM9Xy52YWx1ZU9mKGUueSkuc2VsZkFkZCgtdC55KSxvPV8udmFsdWVPZihuLngpLnNlbGZBZGQoLWUueCksYT1fLnZhbHVlT2Yobi55KS5zZWxmQWRkKC1lLnkpO3JldHVybiByLnNlbGZNdWx0aXBseShhKS5zZWxmU3VidHJhY3Qocy5zZWxmTXVsdGlwbHkobykpLnNpZ251bSgpfSxNLnNpZ25PZkRldDJ4Mj1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10Lm11bHRpcGx5KGkpLnNlbGZTdWJ0cmFjdChlLm11bHRpcGx5KG4pKTtyZXR1cm4gci5zaWdudW0oKX0sTS5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy52YWx1ZU9mKGkueSkuc2VsZlN1YnRyYWN0KG4ueSkuc2VsZk11bHRpcGx5KF8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpKSxzPV8udmFsdWVPZihpLngpLnNlbGZTdWJ0cmFjdChuLngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KSksbz1yLnN1YnRyYWN0KHMpLGE9Xy52YWx1ZU9mKGkueCkuc2VsZlN1YnRyYWN0KG4ueCkuc2VsZk11bHRpcGx5KF8udmFsdWVPZih0LnkpLnNlbGZTdWJ0cmFjdChuLnkpKSx1PV8udmFsdWVPZihpLnkpLnNlbGZTdWJ0cmFjdChuLnkpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC54KS5zZWxmU3VidHJhY3Qobi54KSksbD1hLnN1YnRyYWN0KHUpLGg9bC5zZWxmRGl2aWRlKG8pLmRvdWJsZVZhbHVlKCksYz1fLnZhbHVlT2YodC54KS5zZWxmQWRkKF8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShoKSkuZG91YmxlVmFsdWUoKSxmPV8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2YodC55KS5zZWxmU3VidHJhY3Qobi55KSksZD1fLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKHQueCkuc2VsZlN1YnRyYWN0KG4ueCkpLHA9Zi5zdWJ0cmFjdChkKSx2PXAuc2VsZkRpdmlkZShvKS5kb3VibGVWYWx1ZSgpLG09Xy52YWx1ZU9mKG4ueSkuc2VsZkFkZChfLnZhbHVlT2YoaS55KS5zZWxmU3VidHJhY3Qobi55KS5zZWxmTXVsdGlwbHkodikpLmRvdWJsZVZhbHVlKCk7cmV0dXJuIG5ldyBnKGMsbSl9LE0ub3JpZW50YXRpb25JbmRleEZpbHRlcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9bnVsbCxyPSh0Lngtbi54KSooZS55LW4ueSkscz0odC55LW4ueSkqKGUueC1uLngpLG89ci1zO2lmKHI+MCl7aWYoMD49cylyZXR1cm4gTS5zaWdudW0obyk7aT1yK3N9ZWxzZXtpZighKDA+cikpcmV0dXJuIE0uc2lnbnVtKG8pO2lmKHM+PTApcmV0dXJuIE0uc2lnbnVtKG8pO2k9LXItc312YXIgYT1NLkRQX1NBRkVfRVBTSUxPTippO3JldHVybiBvPj1hfHwtbz49YT9NLnNpZ251bShvKToyfSxNLnNpZ251bT1mdW5jdGlvbih0KXtyZXR1cm4gdD4wPzE6MD50Py0xOjB9LE0uRFBfU0FGRV9FUFNJTE9OPTFlLTE1LGUoRC5wcm90b3R5cGUse3NldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSxuKXt9LHNpemU6ZnVuY3Rpb24oKXt9LGdldE9yZGluYXRlOmZ1bmN0aW9uKHQsZSl7fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdfX0sZ2V0Q29vcmRpbmF0ZUNvcHk6ZnVuY3Rpb24odCl7fSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXt9LGdldFg6ZnVuY3Rpb24odCl7fSxjbG9uZTpmdW5jdGlvbigpe30sZXhwYW5kRW52ZWxvcGU6ZnVuY3Rpb24odCl7fSxjb3B5OmZ1bmN0aW9uKCl7fSxnZXRZOmZ1bmN0aW9uKHQpe30sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24oKXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBEfX0pLEQuWD0wLEQuWT0xLEQuWj0yLEQuTT0zLEEuYXJyYXljb3B5PWZ1bmN0aW9uKHQsZSxuLGkscil7Zm9yKHZhciBzPTAsbz1lO2Urcj5vO28rKyluW2krc109dFtvXSxzKyt9LEEuZ2V0UHJvcGVydHk9ZnVuY3Rpb24odCl7cmV0dXJue1wibGluZS5zZXBhcmF0b3JcIjpcIlxcblwifVt0XX0sZShGLnByb3RvdHlwZSx7Z2V0WTpmdW5jdGlvbigpe3ZhciB0PXRoaXMueS90aGlzLnc7aWYoci5pc05hTih0KXx8ci5pc0luZmluaXRlKHQpKXRocm93IG5ldyB3O3JldHVybiB0fSxnZXRYOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy54L3RoaXMudztpZihyLmlzTmFOKHQpfHxyLmlzSW5maW5pdGUodCkpdGhyb3cgbmV3IHc7cmV0dXJuIHR9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZztyZXR1cm4gdC54PXRoaXMuZ2V0WCgpLHQueT10aGlzLmdldFkoKSx0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBGfX0pLEYuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciBzPXQueS1lLnksbz1lLngtdC54LGE9dC54KmUueS1lLngqdC55LHU9bi55LWkueSxsPWkueC1uLngsaD1uLngqaS55LWkueCpuLnksYz1vKmgtbCphLGY9dSphLXMqaCxkPXMqbC11Km8scD1jL2Qsdj1mL2Q7aWYoci5pc05hTihwKXx8ci5pc0luZmluaXRlKHApfHxyLmlzTmFOKHYpfHxyLmlzSW5maW5pdGUodikpdGhyb3cgbmV3IHc7cmV0dXJuIG5ldyBnKHAsdil9LGUoRy5wcm90b3R5cGUse2NyZWF0ZTpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXthcmd1bWVudHNbMF19ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxEKSl7YXJndW1lbnRzWzBdfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR319KSxlKHEucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxfX0pLGUoQi5wcm90b3R5cGUse2lzR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT059LGdldEZhY3Rvcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mYWN0b3J5fSxnZXRHZW9tZXRyeU46ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXN9LGdldEFyZWE6ZnVuY3Rpb24oKXtyZXR1cm4gMH0saXNSZWN0YW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0sZXF1YWxzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBudWxsPT09dD8hMTp0aGlzLmVxdWFsc1RvcG8odCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3Qpe3ZhciBlPWFyZ3VtZW50c1swXTtpZighKGUgaW5zdGFuY2VvZiBCKSlyZXR1cm4hMTt2YXIgbj1lO3JldHVybiB0aGlzLmVxdWFsc0V4YWN0KG4pfX19LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzPT09dHx8dGhpcy5lcXVhbHNFeGFjdCh0LDApfSxnZW9tZXRyeUNoYW5nZWQ6ZnVuY3Rpb24oKXt0aGlzLmFwcGx5KEIuZ2VvbWV0cnlDaGFuZ2VkRmlsdGVyKX0sZ2VvbWV0cnlDaGFuZ2VkQWN0aW9uOmZ1bmN0aW9uKCl7dGhpcy5lbnZlbG9wZT1udWxsfSxlcXVhbHNOb3JtOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dD8hMTp0aGlzLm5vcm0oKS5lcXVhbHNFeGFjdCh0Lm5vcm0oKSl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiAwfSxnZXROdW1HZW9tZXRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGNvbXBhcmVUbzpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10O3JldHVybiB0aGlzLmdldFNvcnRJbmRleCgpIT09ZS5nZXRTb3J0SW5kZXgoKT90aGlzLmdldFNvcnRJbmRleCgpLWUuZ2V0U29ydEluZGV4KCk6dGhpcy5pc0VtcHR5KCkmJmUuaXNFbXB0eSgpPzA6dGhpcy5pc0VtcHR5KCk/LTE6ZS5pc0VtcHR5KCk/MTp0aGlzLmNvbXBhcmVUb1NhbWVDbGFzcyh0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bjtyZXR1cm4gdGhpcy5nZXRTb3J0SW5kZXgoKSE9PWUuZ2V0U29ydEluZGV4KCk/dGhpcy5nZXRTb3J0SW5kZXgoKS1lLmdldFNvcnRJbmRleCgpOnRoaXMuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKT8wOnRoaXMuaXNFbXB0eSgpPy0xOmUuaXNFbXB0eSgpPzE6dGhpcy5jb21wYXJlVG9TYW1lQ2xhc3MobixpKX19LGdldFVzZXJEYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudXNlckRhdGF9LGdldFNSSUQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5TUklEfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEZhY3RvcnkoKS50b0dlb21ldHJ5KHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0sY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7aWYodC5nZXRTb3J0SW5kZXgoKT09PUIuU09SVElOREVYX0dFT01FVFJZQ09MTEVDVElPTil0aHJvdyBuZXcgaShcIlRoaXMgbWV0aG9kIGRvZXMgbm90IHN1cHBvcnQgR2VvbWV0cnlDb2xsZWN0aW9uIGFyZ3VtZW50c1wiKX0sZXF1YWw6ZnVuY3Rpb24odCxlLG4pe3JldHVybiAwPT09bj90LmVxdWFscyhlKTp0LmRpc3RhbmNlKGUpPD1ufSxub3JtOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5jb3B5KCk7cmV0dXJuIHQubm9ybWFsaXplKCksdH0sZ2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmdldFByZWNpc2lvbk1vZGVsKCl9LGdldEVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuZW52ZWxvcGUmJih0aGlzLmVudmVsb3BlPXRoaXMuY29tcHV0ZUVudmVsb3BlSW50ZXJuYWwoKSksbmV3IEModGhpcy5lbnZlbG9wZSl9LHNldFNSSUQ6ZnVuY3Rpb24odCl7dGhpcy5TUklEPXR9LHNldFVzZXJEYXRhOmZ1bmN0aW9uKHQpe3RoaXMudXNlckRhdGE9dH0sY29tcGFyZTpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10Lml0ZXJhdG9yKCksaT1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCkmJmkuaGFzTmV4dCgpOyl7dmFyIHI9bi5uZXh0KCkscz1pLm5leHQoKSxvPXIuY29tcGFyZVRvKHMpO2lmKDAhPT1vKXJldHVybiBvfXJldHVybiBuLmhhc05leHQoKT8xOmkuaGFzTmV4dCgpPy0xOjB9LGhhc2hDb2RlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmhhc2hDb2RlKCl9LGlzR2VvbWV0cnlDb2xsZWN0aW9uT3JEZXJpdmVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT058fHRoaXMuZ2V0U29ydEluZGV4KCk9PT1CLlNPUlRJTkRFWF9NVUxUSVBPSU5UfHx0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HfHx0aGlzLmdldFNvcnRJbmRleCgpPT09Qi5TT1JUSU5ERVhfTVVMVElQT0xZR09OfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltvLHMsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJ9fSksQi5oYXNOb25FbXB0eUVsZW1lbnRzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCF0W2VdLmlzRW1wdHkoKSlyZXR1cm4hMDtyZXR1cm4hMX0sQi5oYXNOdWxsRWxlbWVudHM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aDtlKyspaWYobnVsbD09PXRbZV0pcmV0dXJuITA7cmV0dXJuITF9LEIuc2VyaWFsVmVyc2lvblVJRD0weDc5OWVhNDY1MjI4NTRjMDAsQi5TT1JUSU5ERVhfUE9JTlQ9MCxCLlNPUlRJTkRFWF9NVUxUSVBPSU5UPTEsQi5TT1JUSU5ERVhfTElORVNUUklORz0yLEIuU09SVElOREVYX0xJTkVBUlJJTkc9MyxCLlNPUlRJTkRFWF9NVUxUSUxJTkVTVFJJTkc9NCxCLlNPUlRJTkRFWF9QT0xZR09OPTUsQi5TT1JUSU5ERVhfTVVMVElQT0xZR09OPTYsQi5TT1JUSU5ERVhfR0VPTUVUUllDT0xMRUNUSU9OPTcsQi5nZW9tZXRyeUNoYW5nZWRGaWx0ZXI9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3FdfSxmaWx0ZXI6ZnVuY3Rpb24odCl7dC5nZW9tZXRyeUNoYW5nZWRBY3Rpb24oKX19LGUoei5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHp9fSksZShWLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVn19KSxlKGsucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQlMj09PTF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1ZdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBrfX0pLGUoWS5wcm90b3R5cGUse2lzSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtyZXR1cm4gdD4wfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltWXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWX19KSxlKFUucHJvdG90eXBlLHtpc0luQm91bmRhcnk6ZnVuY3Rpb24odCl7cmV0dXJuIHQ+MX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFV9fSksZShYLnByb3RvdHlwZSx7aXNJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe3JldHVybiAxPT09dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bVl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFh9fSksVi5Nb2QyQm91bmRhcnlOb2RlUnVsZT1rLFYuRW5kUG9pbnRCb3VuZGFyeU5vZGVSdWxlPVksVi5NdWx0aVZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1VLFYuTW9ub1ZhbGVudEVuZFBvaW50Qm91bmRhcnlOb2RlUnVsZT1YLFYuTU9EMl9CT1VOREFSWV9SVUxFPW5ldyBrLFYuRU5EUE9JTlRfQk9VTkRBUllfUlVMRT1uZXcgWSxWLk1VTFRJVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFUsVi5NT05PVkFMRU5UX0VORFBPSU5UX0JPVU5EQVJZX1JVTEU9bmV3IFgsVi5PR0NfU0ZTX0JPVU5EQVJZX1JVTEU9Vi5NT0QyX0JPVU5EQVJZX1JVTEUsZShILnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSH19KSxILmlzUmluZz1mdW5jdGlvbih0KXtyZXR1cm4gdC5sZW5ndGg8ND8hMTohIXRbMF0uZXF1YWxzMkQodFt0Lmxlbmd0aC0xXSl9LEgucHROb3RJbkxpc3Q9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXTtpZihILmluZGV4T2YoaSxlKTwwKXJldHVybiBpfXJldHVybiBudWxsfSxILnNjcm9sbD1mdW5jdGlvbih0LGUpe3ZhciBuPUguaW5kZXhPZihlLHQpO2lmKDA+bilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCk7QS5hcnJheWNvcHkodCxuLGksMCx0Lmxlbmd0aC1uKSxBLmFycmF5Y29weSh0LDAsaSx0Lmxlbmd0aC1uLG4pLEEuYXJyYXljb3B5KGksMCx0LDAsdC5sZW5ndGgpfSxILmVxdWFscz1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYodD09PWUpcmV0dXJuITA7aWYobnVsbD09PXR8fG51bGw9PT1lKXJldHVybiExO2lmKHQubGVuZ3RoIT09ZS5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aDtuKyspaWYoIXRbbl0uZXF1YWxzKGVbbl0pKXJldHVybiExO3JldHVybiEwfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0scz1hcmd1bWVudHNbMl07aWYoaT09PXIpcmV0dXJuITA7aWYobnVsbD09PWl8fG51bGw9PT1yKXJldHVybiExO2lmKGkubGVuZ3RoIT09ci5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPTA7bjxpLmxlbmd0aDtuKyspaWYoMCE9PXMuY29tcGFyZShpW25dLHJbbl0pKXJldHVybiExO3JldHVybiEwfX0sSC5pbnRlcnNlY3Rpb249ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IE4saT0wO2k8dC5sZW5ndGg7aSsrKWUuaW50ZXJzZWN0cyh0W2ldKSYmbi5hZGQodFtpXSwhMCk7cmV0dXJuIG4udG9Db29yZGluYXRlQXJyYXkoKX0sSC5oYXNSZXBlYXRlZFBvaW50cz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPHQubGVuZ3RoO2UrKylpZih0W2UtMV0uZXF1YWxzKHRbZV0pKXJldHVybiEwO3JldHVybiExfSxILnJlbW92ZVJlcGVhdGVkUG9pbnRzPWZ1bmN0aW9uKHQpe2lmKCFILmhhc1JlcGVhdGVkUG9pbnRzKHQpKXJldHVybiB0O3ZhciBlPW5ldyBOKHQsITEpO3JldHVybiBlLnRvQ29vcmRpbmF0ZUFycmF5KCl9LEgucmV2ZXJzZT1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5sZW5ndGgtMSxuPU1hdGgudHJ1bmMoZS8yKSxpPTA7bj49aTtpKyspe3ZhciByPXRbaV07dFtpXT10W2UtaV0sdFtlLWldPXJ9fSxILnJlbW92ZU51bGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTAsbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiZlKys7dmFyIGk9bmV3IEFycmF5KGUpLmZpbGwobnVsbCk7aWYoMD09PWUpcmV0dXJuIGk7Zm9yKHZhciByPTAsbj0wO248dC5sZW5ndGg7bisrKW51bGwhPT10W25dJiYoaVtyKytdPXRbbl0pO3JldHVybiBpfSxILmNvcHlEZWVwPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248dC5sZW5ndGg7bisrKWVbbl09bmV3IGcodFtuXSk7cmV0dXJuIGV9aWYoNT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXSxvPWFyZ3VtZW50c1szXSxhPWFyZ3VtZW50c1s0XSxuPTA7YT5uO24rKylzW28rbl09bmV3IGcoaVtyK25dKX0sSC5pc0VxdWFsUmV2ZXJzZWQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl7dmFyIGk9dFtuXSxyPWVbdC5sZW5ndGgtbi0xXTtpZigwIT09aS5jb21wYXJlVG8ocikpcmV0dXJuITF9cmV0dXJuITB9LEguZW52ZWxvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBDLG49MDtuPHQubGVuZ3RoO24rKyllLmV4cGFuZFRvSW5jbHVkZSh0W25dKTtyZXR1cm4gZX0sSC50b0Nvb3JkaW5hdGVBcnJheT1mdW5jdGlvbih0KXtyZXR1cm4gdC50b0FycmF5KEguY29vcmRBcnJheVR5cGUpfSxILmF0TGVhc3ROQ29vcmRpbmF0ZXNPck5vdGhpbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5sZW5ndGg+PXQ/ZTpbXX0sSC5pbmRleE9mPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjxlLmxlbmd0aDtuKyspaWYodC5lcXVhbHMoZVtuXSkpcmV0dXJuIG47cmV0dXJuLTF9LEguaW5jcmVhc2luZ0RpcmVjdGlvbj1mdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPE1hdGgudHJ1bmModC5sZW5ndGgvMik7ZSsrKXt2YXIgbj10Lmxlbmd0aC0xLWUsaT10W2VdLmNvbXBhcmVUbyh0W25dKTtpZigwIT09aSlyZXR1cm4gaX1yZXR1cm4gMX0sSC5jb21wYXJlPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0Lmxlbmd0aCYmbjxlLmxlbmd0aDspe3ZhciBpPXRbbl0uY29tcGFyZVRvKGVbbl0pO2lmKDAhPT1pKXJldHVybiBpO24rK31yZXR1cm4gbjxlLmxlbmd0aD8tMTpuPHQubGVuZ3RoPzE6MH0sSC5taW5Db29yZGluYXRlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49MDtuPHQubGVuZ3RoO24rKykobnVsbD09PWV8fGUuY29tcGFyZVRvKHRbbl0pPjApJiYoZT10W25dKTtyZXR1cm4gZX0sSC5leHRyYWN0PWZ1bmN0aW9uKHQsZSxuKXtlPVQuY2xhbXAoZSwwLHQubGVuZ3RoKSxuPVQuY2xhbXAobiwtMSx0Lmxlbmd0aCk7dmFyIGk9bi1lKzE7MD5uJiYoaT0wKSxlPj10Lmxlbmd0aCYmKGk9MCksZT5uJiYoaT0wKTt2YXIgcj1uZXcgQXJyYXkoaSkuZmlsbChudWxsKTtpZigwPT09aSlyZXR1cm4gcjtmb3IodmFyIHM9MCxvPWU7bj49bztvKyspcltzKytdPXRbb107cmV0dXJuIHJ9LGUoVy5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtyZXR1cm4gSC5jb21wYXJlKG4saSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXfX0pLGUoai5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZTtpZihuLmxlbmd0aDxpLmxlbmd0aClyZXR1cm4tMTtpZihuLmxlbmd0aD5pLmxlbmd0aClyZXR1cm4gMTtpZigwPT09bi5sZW5ndGgpcmV0dXJuIDA7dmFyIHI9SC5jb21wYXJlKG4saSkscz1ILmlzRXF1YWxSZXZlcnNlZChuLGkpO3JldHVybiBzPzA6cn0sT0xEY29tcGFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1lO2lmKG4ubGVuZ3RoPGkubGVuZ3RoKXJldHVybi0xO2lmKG4ubGVuZ3RoPmkubGVuZ3RoKXJldHVybiAxO2lmKDA9PT1uLmxlbmd0aClyZXR1cm4gMDtmb3IodmFyIHI9SC5pbmNyZWFzaW5nRGlyZWN0aW9uKG4pLHM9SC5pbmNyZWFzaW5nRGlyZWN0aW9uKGkpLG89cj4wPzA6bi5sZW5ndGgtMSxhPXM+MD8wOm4ubGVuZ3RoLTEsdT0wO3U8bi5sZW5ndGg7dSsrKXt2YXIgbD1uW29dLmNvbXBhcmVUbyhpW2FdKTtpZigwIT09bClyZXR1cm4gbDtvKz1yLGErPXN9cmV0dXJuIDB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBqfX0pLEguRm9yd2FyZENvbXBhcmF0b3I9VyxILkJpZGlyZWN0aW9uYWxDb21wYXJhdG9yPWosSC5jb29yZEFycmF5VHlwZT1uZXcgQXJyYXkoMCkuZmlsbChudWxsKSxLLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24oKXt9LEsucHJvdG90eXBlLnB1dD1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe30sSy5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7fSxLLnByb3RvdHlwZS5lbnRyeVNldD1mdW5jdGlvbigpe30sWi5wcm90b3R5cGU9bmV3IEssUS5wcm90b3R5cGU9bmV3IHYsUS5wcm90b3R5cGUuY29udGFpbnM9ZnVuY3Rpb24oKXt9LEoucHJvdG90eXBlPW5ldyBRLEoucHJvdG90eXBlLmNvbnRhaW5zPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspe3ZhciBpPXRoaXMuYXJyYXlfW2VdO2lmKGk9PT10KXJldHVybiEwfXJldHVybiExfSxKLnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29udGFpbnModCk/ITE6KHRoaXMuYXJyYXlfLnB1c2godCksITApfSxKLnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxKLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24odCl7dGhyb3cgbmV3IGphdmFzY3JpcHQudXRpbC5PcGVyYXRpb25Ob3RTdXBwb3J0ZWR9LEoucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxKLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LEoucHJvdG90eXBlLnRvQXJyYXk9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9W10sZT0wLG49dGhpcy5hcnJheV8ubGVuZ3RoO24+ZTtlKyspdC5wdXNoKHRoaXMuYXJyYXlfW2VdKTtyZXR1cm4gdH0sSi5wcm90b3R5cGUuaXRlcmF0b3I9ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEpzKHRoaXMpfTt2YXIgSnM9ZnVuY3Rpb24odCl7dGhpcy5oYXNoU2V0Xz10LHRoaXMucG9zaXRpb25fPTB9O0pzLnByb3RvdHlwZS5uZXh0PWZ1bmN0aW9uKCl7aWYodGhpcy5wb3NpdGlvbl89PT10aGlzLmhhc2hTZXRfLnNpemUoKSl0aHJvdyBuZXcgeDtyZXR1cm4gdGhpcy5oYXNoU2V0Xy5hcnJheV9bdGhpcy5wb3NpdGlvbl8rK119LEpzLnByb3RvdHlwZS5oYXNOZXh0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9zaXRpb25fPHRoaXMuaGFzaFNldF8uc2l6ZSgpfSxKcy5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKCl7dGhyb3cgbmV3IEV9O3ZhciAkcz0wLHRvPTE7cnQucHJvdG90eXBlPW5ldyBaLHJ0LnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMucm9vdF87bnVsbCE9PWU7KXt2YXIgbj10LmNvbXBhcmVUbyhlLmtleSk7aWYoMD5uKWU9ZS5sZWZ0O2Vsc2V7aWYoIShuPjApKXJldHVybiBlLnZhbHVlO2U9ZS5yaWdodH19cmV0dXJuIG51bGx9LHJ0LnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXtpZihudWxsPT09dGhpcy5yb290XylyZXR1cm4gdGhpcy5yb290Xz17a2V5OnQsdmFsdWU6ZSxsZWZ0Om51bGwscmlnaHQ6bnVsbCxwYXJlbnQ6bnVsbCxjb2xvcjokcyxnZXRWYWx1ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZhbHVlfSxnZXRLZXk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZXl9fSx0aGlzLnNpemVfPTEsbnVsbDt2YXIgbixpLHI9dGhpcy5yb290XztkbyBpZihuPXIsaT10LmNvbXBhcmVUbyhyLmtleSksMD5pKXI9ci5sZWZ0O2Vsc2V7aWYoIShpPjApKXt2YXIgcz1yLnZhbHVlO3JldHVybiByLnZhbHVlPWUsc31yPXIucmlnaHR9d2hpbGUobnVsbCE9PXIpO3ZhciBvPXtrZXk6dCxsZWZ0Om51bGwscmlnaHQ6bnVsbCx2YWx1ZTplLHBhcmVudDpuLGNvbG9yOiRzLGdldFZhbHVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmFsdWV9LGdldEtleTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmtleX19O3JldHVybiAwPmk/bi5sZWZ0PW86bi5yaWdodD1vLHRoaXMuZml4QWZ0ZXJJbnNlcnRpb24obyksdGhpcy5zaXplXysrLG51bGx9LHJ0LnByb3RvdHlwZS5maXhBZnRlckluc2VydGlvbj1mdW5jdGlvbih0KXtmb3IodC5jb2xvcj10bztudWxsIT10JiZ0IT10aGlzLnJvb3RfJiZ0LnBhcmVudC5jb2xvcj09dG87KWlmKHR0KHQpPT1udCh0dCh0dCh0KSkpKXt2YXIgZT1pdCh0dCh0dCh0KSkpOyQoZSk9PXRvPyhldCh0dCh0KSwkcyksZXQoZSwkcyksZXQodHQodHQodCkpLHRvKSx0PXR0KHR0KHQpKSk6KHQ9PWl0KHR0KHQpKSYmKHQ9dHQodCksdGhpcy5yb3RhdGVMZWZ0KHQpKSxldCh0dCh0KSwkcyksZXQodHQodHQodCkpLHRvKSx0aGlzLnJvdGF0ZVJpZ2h0KHR0KHR0KHQpKSkpfWVsc2V7dmFyIGU9bnQodHQodHQodCkpKTskKGUpPT10bz8oZXQodHQodCksJHMpLGV0KGUsJHMpLGV0KHR0KHR0KHQpKSx0byksdD10dCh0dCh0KSkpOih0PT1udCh0dCh0KSkmJih0PXR0KHQpLHRoaXMucm90YXRlUmlnaHQodCkpLGV0KHR0KHQpLCRzKSxldCh0dCh0dCh0KSksdG8pLHRoaXMucm90YXRlTGVmdCh0dCh0dCh0KSkpKX10aGlzLnJvb3RfLmNvbG9yPSRzfSxydC5wcm90b3R5cGUudmFsdWVzPWZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEksZT10aGlzLmdldEZpcnN0RW50cnkoKTtpZihudWxsIT09ZSlmb3IodC5hZGQoZS52YWx1ZSk7bnVsbCE9PShlPXJ0LnN1Y2Nlc3NvcihlKSk7KXQuYWRkKGUudmFsdWUpO3JldHVybiB0fSxydC5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSixlPXRoaXMuZ2V0Rmlyc3RFbnRyeSgpO2lmKG51bGwhPT1lKWZvcih0LmFkZChlKTtudWxsIT09KGU9cnQuc3VjY2Vzc29yKGUpKTspdC5hZGQoZSk7cmV0dXJuIHR9LHJ0LnByb3RvdHlwZS5yb3RhdGVMZWZ0PWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3ZhciBlPXQucmlnaHQ7dC5yaWdodD1lLmxlZnQsbnVsbCE9ZS5sZWZ0JiYoZS5sZWZ0LnBhcmVudD10KSxlLnBhcmVudD10LnBhcmVudCxudWxsPT10LnBhcmVudD90aGlzLnJvb3RfPWU6dC5wYXJlbnQubGVmdD09dD90LnBhcmVudC5sZWZ0PWU6dC5wYXJlbnQucmlnaHQ9ZSxlLmxlZnQ9dCx0LnBhcmVudD1lfX0scnQucHJvdG90eXBlLnJvdGF0ZVJpZ2h0PWZ1bmN0aW9uKHQpe2lmKG51bGwhPXQpe3ZhciBlPXQubGVmdDt0LmxlZnQ9ZS5yaWdodCxudWxsIT1lLnJpZ2h0JiYoZS5yaWdodC5wYXJlbnQ9dCksZS5wYXJlbnQ9dC5wYXJlbnQsbnVsbD09dC5wYXJlbnQ/dGhpcy5yb290Xz1lOnQucGFyZW50LnJpZ2h0PT10P3QucGFyZW50LnJpZ2h0PWU6dC5wYXJlbnQubGVmdD1lLGUucmlnaHQ9dCx0LnBhcmVudD1lfX0scnQucHJvdG90eXBlLmdldEZpcnN0RW50cnk9ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnJvb3RfO2lmKG51bGwhPXQpZm9yKDtudWxsIT10LmxlZnQ7KXQ9dC5sZWZ0O3JldHVybiB0fSxydC5zdWNjZXNzb3I9ZnVuY3Rpb24odCl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7aWYobnVsbCE9PXQucmlnaHQpe2Zvcih2YXIgZT10LnJpZ2h0O251bGwhPT1lLmxlZnQ7KWU9ZS5sZWZ0O3JldHVybiBlfWZvcih2YXIgZT10LnBhcmVudCxuPXQ7bnVsbCE9PWUmJm49PT1lLnJpZ2h0OyluPWUsZT1lLnBhcmVudDtyZXR1cm4gZX0scnQucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaXplX30sZShzdC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHN0fX0pLG90LnByb3RvdHlwZT1uZXcgUSxhdC5wcm90b3R5cGU9bmV3IG90LGF0LnByb3RvdHlwZS5jb250YWlucz1mdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXt2YXIgaT10aGlzLmFycmF5X1tlXTtpZigwPT09aS5jb21wYXJlVG8odCkpcmV0dXJuITB9cmV0dXJuITF9LGF0LnByb3RvdHlwZS5hZGQ9ZnVuY3Rpb24odCl7aWYodGhpcy5jb250YWlucyh0KSlyZXR1cm4hMTtmb3IodmFyIGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXt2YXIgaT10aGlzLmFycmF5X1tlXTtpZigxPT09aS5jb21wYXJlVG8odCkpcmV0dXJuIHRoaXMuYXJyYXlfLnNwbGljZShlLDAsdCksITB9cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksITB9LGF0LnByb3RvdHlwZS5hZGRBbGw9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspdGhpcy5hZGQoZS5uZXh0KCkpO3JldHVybiEwfSxhdC5wcm90b3R5cGUucmVtb3ZlPWZ1bmN0aW9uKHQpe3Rocm93IG5ldyBFfSxhdC5wcm90b3R5cGUuc2l6ZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLmFycmF5Xy5sZW5ndGh9LGF0LnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LGF0LnByb3RvdHlwZS50b0FycmF5PWZ1bmN0aW9uKCl7Zm9yKHZhciB0PVtdLGU9MCxuPXRoaXMuYXJyYXlfLmxlbmd0aDtuPmU7ZSsrKXQucHVzaCh0aGlzLmFycmF5X1tlXSk7cmV0dXJuIHR9LGF0LnByb3RvdHlwZS5pdGVyYXRvcj1mdW5jdGlvbigpe3JldHVybiBuZXcgZW8odGhpcyl9O3ZhciBlbz1mdW5jdGlvbih0KXt0aGlzLnRyZWVTZXRfPXQsdGhpcy5wb3NpdGlvbl89MH07ZW8ucHJvdG90eXBlLm5leHQ9ZnVuY3Rpb24oKXtpZih0aGlzLnBvc2l0aW9uXz09PXRoaXMudHJlZVNldF8uc2l6ZSgpKXRocm93IG5ldyB4O3JldHVybiB0aGlzLnRyZWVTZXRfLmFycmF5X1t0aGlzLnBvc2l0aW9uXysrXX0sZW8ucHJvdG90eXBlLmhhc05leHQ9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb3NpdGlvbl88dGhpcy50cmVlU2V0Xy5zaXplKCl9LGVvLnByb3RvdHlwZS5yZW1vdmU9ZnVuY3Rpb24oKXt0aHJvdyBuZXcgRX0sdXQuc29ydD1mdW5jdGlvbigpe3ZhciB0LGUsbixpLHI9YXJndW1lbnRzWzBdO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY29tcGFyZVRvKGUpfSx2b2lkIHIuc29ydChpKTtpZigyPT09YXJndW1lbnRzLmxlbmd0aCluPWFyZ3VtZW50c1sxXSxpPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIG4uY29tcGFyZSh0LGUpfSxyLnNvcnQoaSk7ZWxzZXtpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7ZT1yLnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pLGUuc29ydCgpO3ZhciBzPXIuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHIuc2xpY2UoYXJndW1lbnRzWzJdLHIubGVuZ3RoKSk7Zm9yKHIuc3BsaWNlKDAsci5sZW5ndGgpLHQ9MDt0PHMubGVuZ3RoO3QrKylyLnB1c2goc1t0XSk7cmV0dXJufWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IoZT1yLnNsaWNlKGFyZ3VtZW50c1sxXSxhcmd1bWVudHNbMl0pLG49YXJndW1lbnRzWzNdLGk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbi5jb21wYXJlKHQsZSl9LGUuc29ydChpKSxzPXIuc2xpY2UoMCxhcmd1bWVudHNbMV0pLmNvbmNhdChlLHIuc2xpY2UoYXJndW1lbnRzWzJdLHIubGVuZ3RoKSksci5zcGxpY2UoMCxyLmxlbmd0aCksdD0wO3Q8cy5sZW5ndGg7dCsrKXIucHVzaChzW3RdKTtyZXR1cm59fX0sdXQuYXNMaXN0PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTAsaT10Lmxlbmd0aDtpPm47bisrKWUuYWRkKHRbbl0pO3JldHVybiBlfSxlKGx0LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbHR9fSksbHQudG9EaW1lbnNpb25TeW1ib2w9ZnVuY3Rpb24odCl7c3dpdGNoKHQpe2Nhc2UgbHQuRkFMU0U6cmV0dXJuIGx0LlNZTV9GQUxTRTtjYXNlIGx0LlRSVUU6cmV0dXJuIGx0LlNZTV9UUlVFO2Nhc2UgbHQuRE9OVENBUkU6cmV0dXJuIGx0LlNZTV9ET05UQ0FSRTtjYXNlIGx0LlA6cmV0dXJuIGx0LlNZTV9QO2Nhc2UgbHQuTDpyZXR1cm4gbHQuU1lNX0w7Y2FzZSBsdC5BOnJldHVybiBsdC5TWU1fQX10aHJvdyBuZXcgaShcIlVua25vd24gZGltZW5zaW9uIHZhbHVlOiBcIit0KX0sbHQudG9EaW1lbnNpb25WYWx1ZT1mdW5jdGlvbih0KXtzd2l0Y2goTy50b1VwcGVyQ2FzZSh0KSl7Y2FzZSBsdC5TWU1fRkFMU0U6cmV0dXJuIGx0LkZBTFNFO2Nhc2UgbHQuU1lNX1RSVUU6cmV0dXJuIGx0LlRSVUU7Y2FzZSBsdC5TWU1fRE9OVENBUkU6cmV0dXJuIGx0LkRPTlRDQVJFO2Nhc2UgbHQuU1lNX1A6cmV0dXJuIGx0LlA7Y2FzZSBsdC5TWU1fTDpyZXR1cm4gbHQuTDtjYXNlIGx0LlNZTV9BOnJldHVybiBsdC5BfXRocm93IG5ldyBpKFwiVW5rbm93biBkaW1lbnNpb24gc3ltYm9sOiBcIit0KX0sbHQuUD0wLGx0Lkw9MSxsdC5BPTIsbHQuRkFMU0U9LTEsbHQuVFJVRT0tMixsdC5ET05UQ0FSRT0tMyxsdC5TWU1fRkFMU0U9XCJGXCIsbHQuU1lNX1RSVUU9XCJUXCIsbHQuU1lNX0RPTlRDQVJFPVwiKlwiLGx0LlNZTV9QPVwiMFwiLGx0LlNZTV9MPVwiMVwiLGx0LlNZTV9BPVwiMlwiLGUoaHQucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBodH19KSxlKGN0LnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQsZSl7fSxpc0RvbmU6ZnVuY3Rpb24oKXt9LGlzR2VvbWV0cnlDaGFuZ2VkOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjdH19KSxoKGZ0LEIpLGUoZnQucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQyxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmdlb21ldHJpZXNbZV0uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKTtyZXR1cm4gdH0sZ2V0R2VvbWV0cnlOOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJpZXNbdF19LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9HRU9NRVRSWUNPTExFQ1RJT059LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpLGU9LTEsbj0wO248dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtuKyspZm9yKHZhciBpPXRoaXMuZ2VvbWV0cmllc1tuXS5nZXRDb29yZGluYXRlcygpLHI9MDtyPGkubGVuZ3RoO3IrKyllKyssdFtlXT1pW3JdO3JldHVybiB0fSxnZXRBcmVhOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5nZW9tZXRyaWVzW2VdLmdldEFyZWEoKTtyZXR1cm4gdH0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKCF0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpKXJldHVybiExO3ZhciBuPXQ7aWYodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCE9PW4uZ2VvbWV0cmllcy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2krKylpZighdGhpcy5nZW9tZXRyaWVzW2ldLmVxdWFsc0V4YWN0KG4uZ2VvbWV0cmllc1tpXSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7dCsrKXRoaXMuZ2VvbWV0cmllc1t0XS5ub3JtYWxpemUoKTt1dC5zb3J0KHRoaXMuZ2VvbWV0cmllcyl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdlb21ldHJpZXNbMF0uZ2V0Q29vcmRpbmF0ZSgpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe2Zvcih2YXIgdD1sdC5GQUxTRSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0PU1hdGgubWF4KHQsdGhpcy5nZW9tZXRyaWVzW2VdLmdldEJvdW5kYXJ5RGltZW5zaW9uKCkpO3JldHVybiB0fSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bHQuRkFMU0UsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdD1NYXRoLm1heCh0LHRoaXMuZ2VvbWV0cmllc1tlXS5nZXREaW1lbnNpb24oKSk7cmV0dXJuIHR9LGdldExlbmd0aDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQrPXRoaXMuZ2VvbWV0cmllc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdCs9dGhpcy5nZW9tZXRyaWVzW2VdLmdldE51bVBvaW50cygpO3JldHVybiB0fSxnZXROdW1HZW9tZXRyaWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VvbWV0cmllcy5sZW5ndGh9LHJldmVyc2U6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbbl09dGhpcy5nZW9tZXRyaWVzW25dLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKGUpfSxjb21wYXJlVG9TYW1lQ2xhc3M6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IGF0KHV0LmFzTGlzdCh0aGlzLmdlb21ldHJpZXMpKSxuPW5ldyBhdCh1dC5hc0xpc3QodC5nZW9tZXRyaWVzKSk7cmV0dXJuIHRoaXMuY29tcGFyZShlLG4pfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9aSxvPXRoaXMuZ2V0TnVtR2VvbWV0cmllcygpLGE9cy5nZXROdW1HZW9tZXRyaWVzKCksdT0wO28+dSYmYT51Oyl7dmFyIGw9dGhpcy5nZXRHZW9tZXRyeU4odSksaD1zLmdldEdlb21ldHJ5Tih1KSxjPWwuY29tcGFyZVRvU2FtZUNsYXNzKGgscik7aWYoMCE9PWMpcmV0dXJuIGM7dSsrfXJldHVybiBvPnU/MTphPnU/LTE6MH19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLmdlb21ldHJpZXNbZV0uYXBwbHkodCk7ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5nZW9tZXRyaWVzLmxlbmd0aClyZXR1cm4gbnVsbDtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgmJih0aGlzLmdlb21ldHJpZXNbZV0uYXBwbHkobiksIW4uaXNEb25lKCkpO2UrKyk7bi5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyk7Zm9yKHZhciBlPTA7ZTx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO2UrKyl0aGlzLmdlb21ldHJpZXNbZV0uYXBwbHkoaSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIHI9YXJndW1lbnRzWzBdO3IuZmlsdGVyKHRoaXMpO2Zvcih2YXIgZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspdGhpcy5nZW9tZXRyaWVzW2VdLmFwcGx5KHIpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSxmLnNob3VsZE5ldmVyUmVhY2hIZXJlKCksbnVsbH0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3QuZ2VvbWV0cmllcz1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7ZSsrKXQuZ2VvbWV0cmllc1tlXT10aGlzLmdlb21ldHJpZXNbZV0uY2xvbmUoKTtyZXR1cm4gdH0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJHZW9tZXRyeUNvbGxlY3Rpb25cIn0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5nZW9tZXRyaWVzLmxlbmd0aCkuZmlsbChudWxsKSxlPTA7ZTx0Lmxlbmd0aDtlKyspdFtlXT10aGlzLmdlb21ldHJpZXNbZV0uY29weSgpO3JldHVybiBuZXcgZnQodCx0aGlzLmZhY3RvcnkpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTA7dDx0aGlzLmdlb21ldHJpZXMubGVuZ3RoO3QrKylpZighdGhpcy5nZW9tZXRyaWVzW3RdLmlzRW1wdHkoKSlyZXR1cm4hMTtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnR9fSksZnQuc2VyaWFsVmVyc2lvblVJRD0tMHg0ZjA3YmNiMWY4NTdkODAwLGgoZ3QsZnQpLGUoZ3QucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTVVMVElMSU5FU1RSSU5HfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/ZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpOiExfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmlzQ2xvc2VkKCk/bHQuRkFMU0U6MH0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4hMTtmb3IodmFyIHQ9MDt0PHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7dCsrKWlmKCF0aGlzLmdlb21ldHJpZXNbdF0uaXNDbG9zZWQoKSlyZXR1cm4hMTtyZXR1cm4hMH0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LHJldmVyc2U6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbdC0xLW5dPXRoaXMuZ2VvbWV0cmllc1tuXS5yZXZlcnNlKCk7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGR0KHRoaXMpLmdldEJvdW5kYXJ5KCl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlMaW5lU3RyaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IGd0KHQsdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtcbnJldHVybltzdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGd0fX0pLGd0LnNlcmlhbFZlcnNpb25VSUQ9MHg3MTU1ZDJhYjRhZmE4MDAwLGUoZHQucHJvdG90eXBlLHtib3VuZGFyeU11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXtpZih0aGlzLmdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEVtcHR5TXVsdGlQb2ludCgpO3ZhciBlPXRoaXMuY29tcHV0ZUJvdW5kYXJ5Q29vcmRpbmF0ZXModCk7cmV0dXJuIDE9PT1lLmxlbmd0aD90aGlzLmdlb21GYWN0LmNyZWF0ZVBvaW50KGVbMF0pOnRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludEZyb21Db29yZHMoZSl9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VvbSBpbnN0YW5jZW9mIFN0P3RoaXMuYm91bmRhcnlMaW5lU3RyaW5nKHRoaXMuZ2VvbSk6dGhpcy5nZW9tIGluc3RhbmNlb2YgZ3Q/dGhpcy5ib3VuZGFyeU11bHRpTGluZVN0cmluZyh0aGlzLmdlb20pOnRoaXMuZ2VvbS5nZXRCb3VuZGFyeSgpfSxib3VuZGFyeUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7aWYodGhpcy5nZW9tLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5nZXRFbXB0eU11bHRpUG9pbnQoKTtpZih0LmlzQ2xvc2VkKCkpe3ZhciBlPXRoaXMuYm5SdWxlLmlzSW5Cb3VuZGFyeSgyKTtyZXR1cm4gZT90LmdldFN0YXJ0UG9pbnQoKTp0aGlzLmdlb21GYWN0LmNyZWF0ZU11bHRpUG9pbnQoKX1yZXR1cm4gdGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50KFt0LmdldFN0YXJ0UG9pbnQoKSx0LmdldEVuZFBvaW50KCldKX0sZ2V0RW1wdHlNdWx0aVBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2VvbUZhY3QuY3JlYXRlTXVsdGlQb2ludCgpfSxjb21wdXRlQm91bmRhcnlDb29yZGluYXRlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSTt0aGlzLmVuZHBvaW50TWFwPW5ldyBydDtmb3IodmFyIG49MDtuPHQuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl7dmFyIGk9dC5nZXRHZW9tZXRyeU4obik7MCE9PWkuZ2V0TnVtUG9pbnRzKCkmJih0aGlzLmFkZEVuZHBvaW50KGkuZ2V0Q29vcmRpbmF0ZU4oMCkpLHRoaXMuYWRkRW5kcG9pbnQoaS5nZXRDb29yZGluYXRlTihpLmdldE51bVBvaW50cygpLTEpKSl9Zm9yKHZhciByPXRoaXMuZW5kcG9pbnRNYXAuZW50cnlTZXQoKS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldFZhbHVlKCksYT1vLmNvdW50O3RoaXMuYm5SdWxlLmlzSW5Cb3VuZGFyeShhKSYmZS5hZGQocy5nZXRLZXkoKSl9cmV0dXJuIEgudG9Db29yZGluYXRlQXJyYXkoZSl9LGFkZEVuZHBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZW5kcG9pbnRNYXAuZ2V0KHQpO251bGw9PT1lJiYoZT1uZXcgcHQsdGhpcy5lbmRwb2ludE1hcC5wdXQodCxlKSksZS5jb3VudCsrfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkdH19KSxkdC5nZXRCb3VuZGFyeT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgZHQodCk7cmV0dXJuIGUuZ2V0Qm91bmRhcnkoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLGU9bmV3IGR0KG4saSk7cmV0dXJuIGUuZ2V0Qm91bmRhcnkoKX19LGUocHQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwdH19KSxlKE50LnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTnR9fSksTnQuY2hhcnM9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEFycmF5KGUpLmZpbGwobnVsbCksaT0wO2U+aTtpKyspbltpXT10O3JldHVybiBuZXcgU3RyaW5nKG4pfSxOdC5nZXRTdGFja1RyYWNlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyB4dCxuPW5ldyB2dChlKTtyZXR1cm4gdC5wcmludFN0YWNrVHJhY2UobiksZS50b1N0cmluZygpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9XCJcIixvPW5ldyBtdChOdC5nZXRTdGFja1RyYWNlKGkpKSxhPW5ldyBJdChvKSx1PTA7cj51O3UrKyl0cnl7cys9YS5yZWFkTGluZSgpK050Lk5FV0xJTkV9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgRXQpKXRocm93IHQ7Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpfWZpbmFsbHl7fXJldHVybiBzfX0sTnQuc3BsaXQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5sZW5ndGgsaT1uZXcgSSxyPVwiXCIrdCxzPXIuaW5kZXhPZihlKTtzPj0wOyl7dmFyIG89ci5zdWJzdHJpbmcoMCxzKTtpLmFkZChvKSxyPXIuc3Vic3RyaW5nKHMrbikscz1yLmluZGV4T2YoZSl9ci5sZW5ndGg+MCYmaS5hZGQocik7Zm9yKHZhciBhPW5ldyBBcnJheShpLnNpemUoKSkuZmlsbChudWxsKSx1PTA7dTxhLmxlbmd0aDt1KyspYVt1XT1pLmdldCh1KTtyZXR1cm4gYX0sTnQudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBOdC5TSU1QTEVfT1JESU5BVEVfRk9STUFULmZvcm1hdCh0KX19LE50LnNwYWNlcz1mdW5jdGlvbih0KXtyZXR1cm4gTnQuY2hhcnMoXCIgXCIsdCl9LE50Lk5FV0xJTkU9QS5nZXRQcm9wZXJ0eShcImxpbmUuc2VwYXJhdG9yXCIpLE50LlNJTVBMRV9PUkRJTkFURV9GT1JNQVQ9bmV3IHl0KFwiMC4jXCIpLGUoQ3QucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDdH19KSxDdC5jb3B5Q29vcmQ9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPU1hdGgubWluKHQuZ2V0RGltZW5zaW9uKCksbi5nZXREaW1lbnNpb24oKSkscz0wO3I+cztzKyspbi5zZXRPcmRpbmF0ZShpLHMsdC5nZXRPcmRpbmF0ZShlLHMpKX0sQ3QuaXNSaW5nPWZ1bmN0aW9uKHQpe3ZhciBlPXQuc2l6ZSgpO3JldHVybiAwPT09ZT8hMDozPj1lPyExOnQuZ2V0T3JkaW5hdGUoMCxELlgpPT09dC5nZXRPcmRpbmF0ZShlLTEsRC5YKSYmdC5nZXRPcmRpbmF0ZSgwLEQuWSk9PT10LmdldE9yZGluYXRlKGUtMSxELlkpfSxDdC5pc0VxdWFsPWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5zaXplKCksaT1lLnNpemUoKTtpZihuIT09aSlyZXR1cm4hMTtmb3IodmFyIHM9TWF0aC5taW4odC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKSxvPTA7bj5vO28rKylmb3IodmFyIGE9MDtzPmE7YSsrKXt2YXIgdT10LmdldE9yZGluYXRlKG8sYSksbD1lLmdldE9yZGluYXRlKG8sYSk7aWYoISh0LmdldE9yZGluYXRlKG8sYSk9PT1lLmdldE9yZGluYXRlKG8sYSl8fHIuaXNOYU4odSkmJnIuaXNOYU4obCkpKXJldHVybiExfXJldHVybiEwfSxDdC5leHRlbmQ9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuY3JlYXRlKG4sZS5nZXREaW1lbnNpb24oKSkscj1lLnNpemUoKTtpZihDdC5jb3B5KGUsMCxpLDAscikscj4wKWZvcih2YXIgcz1yO24+cztzKyspQ3QuY29weShlLHItMSxpLHMsMSk7cmV0dXJuIGl9LEN0LnJldmVyc2U9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuc2l6ZSgpLTEsbj1NYXRoLnRydW5jKGUvMiksaT0wO24+PWk7aSsrKUN0LnN3YXAodCxpLGUtaSl9LEN0LnN3YXA9ZnVuY3Rpb24odCxlLG4pe2lmKGU9PT1uKXJldHVybiBudWxsO2Zvcih2YXIgaT0wO2k8dC5nZXREaW1lbnNpb24oKTtpKyspe3ZhciByPXQuZ2V0T3JkaW5hdGUoZSxpKTt0LnNldE9yZGluYXRlKGUsaSx0LmdldE9yZGluYXRlKG4saSkpLHQuc2V0T3JkaW5hdGUobixpLHIpfX0sQ3QuY29weT1mdW5jdGlvbih0LGUsbixpLHIpe2Zvcih2YXIgcz0wO3I+cztzKyspQ3QuY29weUNvb3JkKHQsZStzLG4saStzKX0sQ3QudG9TdHJpbmc9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5zaXplKCk7aWYoMD09PWUpcmV0dXJuXCIoKVwiO3ZhciBuPXQuZ2V0RGltZW5zaW9uKCksaT1uZXcgUDtpLmFwcGVuZChcIihcIik7Zm9yKHZhciByPTA7ZT5yO3IrKyl7cj4wJiZpLmFwcGVuZChcIiBcIik7Zm9yKHZhciBzPTA7bj5zO3MrKylzPjAmJmkuYXBwZW5kKFwiLFwiKSxpLmFwcGVuZChOdC50b1N0cmluZyh0LmdldE9yZGluYXRlKHIscykpKX1yZXR1cm4gaS5hcHBlbmQoXCIpXCIpLGkudG9TdHJpbmcoKX19LEN0LmVuc3VyZVZhbGlkUmluZz1mdW5jdGlvbih0LGUpe3ZhciBuPWUuc2l6ZSgpO2lmKDA9PT1uKXJldHVybiBlO2lmKDM+PW4pcmV0dXJuIEN0LmNyZWF0ZUNsb3NlZFJpbmcodCxlLDQpO3ZhciBpPWUuZ2V0T3JkaW5hdGUoMCxELlgpPT09ZS5nZXRPcmRpbmF0ZShuLTEsRC5YKSYmZS5nZXRPcmRpbmF0ZSgwLEQuWSk9PT1lLmdldE9yZGluYXRlKG4tMSxELlkpO3JldHVybiBpP2U6Q3QuY3JlYXRlQ2xvc2VkUmluZyh0LGUsbisxKX0sQ3QuY3JlYXRlQ2xvc2VkUmluZz1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5jcmVhdGUobixlLmdldERpbWVuc2lvbigpKSxyPWUuc2l6ZSgpO0N0LmNvcHkoZSwwLGksMCxyKTtmb3IodmFyIHM9cjtuPnM7cysrKUN0LmNvcHkoZSwwLGkscywxKTtyZXR1cm4gaX0saChTdCxCKSxlKFN0LnByb3RvdHlwZSx7Y29tcHV0ZUVudmVsb3BlSW50ZXJuYWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bmV3IEM6dGhpcy5wb2ludHMuZXhwYW5kRW52ZWxvcGUobmV3IEMpfSxpc1Jpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpJiZ0aGlzLmlzU2ltcGxlKCl9LGdldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9MSU5FU1RSSU5HfSxnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvaW50cy50b0Nvb3JkaW5hdGVBcnJheSgpfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7dmFyIG49dDtpZih0aGlzLnBvaW50cy5zaXplKCkhPT1uLnBvaW50cy5zaXplKCkpcmV0dXJuITE7Zm9yKHZhciBpPTA7aTx0aGlzLnBvaW50cy5zaXplKCk7aSsrKWlmKCF0aGlzLmVxdWFsKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoaSksbi5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSxlKSlyZXR1cm4hMTtyZXR1cm4hMH1yZXR1cm4gQi5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxub3JtYWxpemU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDt0PE1hdGgudHJ1bmModGhpcy5wb2ludHMuc2l6ZSgpLzIpO3QrKyl7dmFyIGU9dGhpcy5wb2ludHMuc2l6ZSgpLTEtdDtpZighdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KS5lcXVhbHModGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSkpcmV0dXJuIHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUodCkuY29tcGFyZVRvKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkpPjAmJkN0LnJldmVyc2UodGhpcy5wb2ludHMpLG51bGx9fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSgwKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0Nsb3NlZCgpP2x0LkZBTFNFOjB9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPyExOnRoaXMuZ2V0Q29vcmRpbmF0ZU4oMCkuZXF1YWxzMkQodGhpcy5nZXRDb29yZGluYXRlTih0aGlzLmdldE51bVBvaW50cygpLTEpKX0sZ2V0RW5kUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/bnVsbDp0aGlzLmdldFBvaW50Tih0aGlzLmdldE51bVBvaW50cygpLTEpfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIGhlLmNvbXB1dGVMZW5ndGgodGhpcy5wb2ludHMpfSxnZXROdW1Qb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHMuc2l6ZSgpfSxyZXZlcnNlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wb2ludHMuY29weSgpO0N0LnJldmVyc2UodCk7dmFyIGU9dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyh0KTtyZXR1cm4gZX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10LG49MCxpPTA7bjx0aGlzLnBvaW50cy5zaXplKCkmJmk8ZS5wb2ludHMuc2l6ZSgpOyl7dmFyIHI9dGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShuKS5jb21wYXJlVG8oZS5wb2ludHMuZ2V0Q29vcmRpbmF0ZShpKSk7aWYoMCE9PXIpcmV0dXJuIHI7bisrLGkrK31yZXR1cm4gbjx0aGlzLnBvaW50cy5zaXplKCk/MTppPGUucG9pbnRzLnNpemUoKT8tMTowfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sZT1zO3JldHVybiBvLmNvbXBhcmUodGhpcy5wb2ludHMsZS5wb2ludHMpfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSlmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHRoaXMucG9pbnRzLnNpemUoKTtlKyspdC5maWx0ZXIodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZShlKSk7ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBuPWFyZ3VtZW50c1swXTtpZigwPT09dGhpcy5wb2ludHMuc2l6ZSgpKXJldHVybiBudWxsO2Zvcih2YXIgZT0wO2U8dGhpcy5wb2ludHMuc2l6ZSgpJiYobi5maWx0ZXIodGhpcy5wb2ludHMsZSksIW4uaXNEb25lKCkpO2UrKyk7bi5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIHI9YXJndW1lbnRzWzBdO3IuZmlsdGVyKHRoaXMpfX0sZ2V0Qm91bmRhcnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IGR0KHRoaXMpLmdldEJvdW5kYXJ5KCl9LGlzRXF1aXZhbGVudENsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgU3R9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTtyZXR1cm4gdC5wb2ludHM9dGhpcy5wb2ludHMuY2xvbmUoKSx0fSxnZXRDb29yZGluYXRlTjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJMaW5lU3RyaW5nXCJ9LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFN0KHRoaXMucG9pbnRzLmNvcHkoKSx0aGlzLmZhY3RvcnkpfSxnZXRDb29yZGluYXRlU2VxdWVuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wb2ludHN9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PXRoaXMucG9pbnRzLnNpemUoKX0saW5pdDpmdW5jdGlvbih0KXtpZihudWxsPT09dCYmKHQ9dGhpcy5nZXRGYWN0b3J5KCkuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShbXSkpLDE9PT10LnNpemUoKSl0aHJvdyBuZXcgaShcIkludmFsaWQgbnVtYmVyIG9mIHBvaW50cyBpbiBMaW5lU3RyaW5nIChmb3VuZCBcIit0LnNpemUoKStcIiAtIG11c3QgYmUgMCBvciA+PSAyKVwiKTt0aGlzLnBvaW50cz10fSxpc0Nvb3JkaW5hdGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLnBvaW50cy5zaXplKCk7ZSsrKWlmKHRoaXMucG9pbnRzLmdldENvb3JkaW5hdGUoZSkuZXF1YWxzKHQpKXJldHVybiEwO3JldHVybiExfSxnZXRTdGFydFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP251bGw6dGhpcy5nZXRQb2ludE4oMCl9LGdldFBvaW50TjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5wb2ludHMuZ2V0Q29vcmRpbmF0ZSh0KSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3N0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3R9fSksU3Quc2VyaWFsVmVyc2lvblVJRD0weDJiMmI1MWJhNDM1YzhlMDAsZSh3dC5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHd0fX0pLGgoTHQsQiksZShMdC5wcm90b3R5cGUse2NvbXB1dGVFbnZlbG9wZUludGVybmFsOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG5ldyBDO3ZhciB0PW5ldyBDO3JldHVybiB0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNvb3JkaW5hdGVzLmdldFgoMCksdGhpcy5jb29yZGluYXRlcy5nZXRZKDApKSx0fSxnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfUE9JTlR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpP1tdOlt0aGlzLmdldENvb3JkaW5hdGUoKV19LGVxdWFsc0V4YWN0OmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5pc0VxdWl2YWxlbnRDbGFzcyh0KT90aGlzLmlzRW1wdHkoKSYmdC5pc0VtcHR5KCk/ITA6dGhpcy5pc0VtcHR5KCkhPT10LmlzRW1wdHkoKT8hMTp0aGlzLmVxdWFsKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpOiExfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe30sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiAwIT09dGhpcy5jb29yZGluYXRlcy5zaXplKCk/dGhpcy5jb29yZGluYXRlcy5nZXRDb29yZGluYXRlKDApOm51bGx9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIGx0LkZBTFNFfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMH0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6MX0scmV2ZXJzZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvcHkoKX0sZ2V0WDpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmdldENvb3JkaW5hdGUoKSl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiZ2V0WCBjYWxsZWQgb24gZW1wdHkgUG9pbnRcIik7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLnh9LGNvbXBhcmVUb1NhbWVDbGFzczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10O3JldHVybiB0aGlzLmdldENvb3JkaW5hdGUoKS5jb21wYXJlVG8oZS5nZXRDb29yZGluYXRlKCkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0sZT1uO3JldHVybiBpLmNvbXBhcmUodGhpcy5jb29yZGluYXRlcyxlLmNvb3JkaW5hdGVzKX19LGFwcGx5OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0seikpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0LmZpbHRlcih0aGlzLmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxjdCkpe3ZhciBlPWFyZ3VtZW50c1swXTtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtlLmZpbHRlcih0aGlzLmNvb3JkaW5hdGVzLDApLGUuaXNHZW9tZXRyeUNoYW5nZWQoKSYmdGhpcy5nZW9tZXRyeUNoYW5nZWQoKX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGh0KSl7dmFyIG49YXJndW1lbnRzWzBdO24uZmlsdGVyKHRoaXMpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0scSkpe3ZhciBpPWFyZ3VtZW50c1swXTtpLmZpbHRlcih0aGlzKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKX0sY2xvbmU6ZnVuY3Rpb24oKXt2YXIgdD1CLnByb3RvdHlwZS5jbG9uZS5jYWxsKHRoaXMpO3JldHVybiB0LmNvb3JkaW5hdGVzPXRoaXMuY29vcmRpbmF0ZXMuY2xvbmUoKSx0fSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIlBvaW50XCJ9LGNvcHk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEx0KHRoaXMuY29vcmRpbmF0ZXMuY29weSgpLHRoaXMuZmFjdG9yeSl9LGdldENvb3JkaW5hdGVTZXF1ZW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzfSxnZXRZOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZ2V0Q29vcmRpbmF0ZSgpKXRocm93IG5ldyBJbGxlZ2FsU3RhdGVFeGNlcHRpb24oXCJnZXRZIGNhbGxlZCBvbiBlbXB0eSBQb2ludFwiKTtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlKCkueX0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiAwPT09dGhpcy5jb29yZGluYXRlcy5zaXplKCl9LGluaXQ6ZnVuY3Rpb24odCl7bnVsbD09PXQmJih0PXRoaXMuZ2V0RmFjdG9yeSgpLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKSxmLmlzVHJ1ZSh0LnNpemUoKTw9MSksdGhpcy5jb29yZGluYXRlcz10fSxpc1NpbXBsZTpmdW5jdGlvbigpe3JldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt3dF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEx0fX0pLEx0LnNlcmlhbFZlcnNpb25VSUQ9MHg0NDA3N2JhZDE2MWNiYzAwLGUoUnQucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSdH19KSxoKFR0LEIpLGUoVHQucHJvdG90eXBlLHtjb21wdXRlRW52ZWxvcGVJbnRlcm5hbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNoZWxsLmdldEVudmVsb3BlSW50ZXJuYWwoKX0sZ2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX1BPTFlHT059LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuW107Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmdldE51bVBvaW50cygpKS5maWxsKG51bGwpLGU9LTEsbj10aGlzLnNoZWxsLmdldENvb3JkaW5hdGVzKCksaT0wO2k8bi5sZW5ndGg7aSsrKWUrKyx0W2VdPW5baV07Zm9yKHZhciByPTA7cjx0aGlzLmhvbGVzLmxlbmd0aDtyKyspZm9yKHZhciBzPXRoaXMuaG9sZXNbcl0uZ2V0Q29vcmRpbmF0ZXMoKSxvPTA7bzxzLmxlbmd0aDtvKyspZSsrLHRbZV09c1tvXTtyZXR1cm4gdH0sZ2V0QXJlYTpmdW5jdGlvbigpe3ZhciB0PTA7dCs9TWF0aC5hYnMoaGUuc2lnbmVkQXJlYSh0aGlzLnNoZWxsLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKSk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdC09TWF0aC5hYnMoaGUuc2lnbmVkQXJlYSh0aGlzLmhvbGVzW2VdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKSk7cmV0dXJuIHR9LGlzUmVjdGFuZ2xlOmZ1bmN0aW9uKCl7aWYoMCE9PXRoaXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCkpcmV0dXJuITE7aWYobnVsbD09PXRoaXMuc2hlbGwpcmV0dXJuITE7aWYoNSE9PXRoaXMuc2hlbGwuZ2V0TnVtUG9pbnRzKCkpcmV0dXJuITE7Zm9yKHZhciB0PXRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksZT10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPTA7NT5uO24rKyl7dmFyIGk9dC5nZXRYKG4pO2lmKGkhPT1lLmdldE1pblgoKSYmaSE9PWUuZ2V0TWF4WCgpKXJldHVybiExO3ZhciByPXQuZ2V0WShuKTtpZihyIT09ZS5nZXRNaW5ZKCkmJnIhPT1lLmdldE1heFkoKSlyZXR1cm4hMX1mb3IodmFyIHM9dC5nZXRYKDApLG89dC5nZXRZKDApLG49MTs0Pj1uO24rKyl7dmFyIGk9dC5nZXRYKG4pLHI9dC5nZXRZKG4pLGE9aSE9PXMsdT1yIT09bztpZihhPT09dSlyZXR1cm4hMTtzPWksbz1yfXJldHVybiEwfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoIXRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCkpcmV0dXJuITE7dmFyIG49dCxpPXRoaXMuc2hlbGwscj1uLnNoZWxsO2lmKCFpLmVxdWFsc0V4YWN0KHIsZSkpcmV0dXJuITE7aWYodGhpcy5ob2xlcy5sZW5ndGghPT1uLmhvbGVzLmxlbmd0aClyZXR1cm4hMTtmb3IodmFyIHM9MDtzPHRoaXMuaG9sZXMubGVuZ3RoO3MrKylpZighdGhpcy5ob2xlc1tzXS5lcXVhbHNFeGFjdChuLmhvbGVzW3NdLGUpKXJldHVybiExO3JldHVybiEwfXJldHVybiBCLnByb3RvdHlwZS5lcXVhbHNFeGFjdC5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXt0aGlzLm5vcm1hbGl6ZSh0aGlzLnNoZWxsLCEwKTtmb3IodmFyIHQ9MDt0PHRoaXMuaG9sZXMubGVuZ3RoO3QrKyl0aGlzLm5vcm1hbGl6ZSh0aGlzLmhvbGVzW3RdLCExKTt1dC5zb3J0KHRoaXMuaG9sZXMpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgaT1uZXcgQXJyYXkoZS5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKS5maWxsKG51bGwpO0EuYXJyYXljb3B5KGUuZ2V0Q29vcmRpbmF0ZXMoKSwwLGksMCxpLmxlbmd0aCk7dmFyIHI9SC5taW5Db29yZGluYXRlKGUuZ2V0Q29vcmRpbmF0ZXMoKSk7SC5zY3JvbGwoaSxyKSxBLmFycmF5Y29weShpLDAsZS5nZXRDb29yZGluYXRlcygpLDAsaS5sZW5ndGgpLGUuZ2V0Q29vcmRpbmF0ZXMoKVtpLmxlbmd0aF09aVswXSxoZS5pc0NDVyhlLmdldENvb3JkaW5hdGVzKCkpPT09biYmSC5yZXZlcnNlKGUuZ2V0Q29vcmRpbmF0ZXMoKSl9fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGwuZ2V0Q29vcmRpbmF0ZSgpfSxnZXROdW1JbnRlcmlvclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ob2xlcy5sZW5ndGh9LGdldEJvdW5kYXJ5RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDF9LGdldERpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiAyfSxnZXRMZW5ndGg6ZnVuY3Rpb24oKXt2YXIgdD0wO3QrPXRoaXMuc2hlbGwuZ2V0TGVuZ3RoKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdCs9dGhpcy5ob2xlc1tlXS5nZXRMZW5ndGgoKTtyZXR1cm4gdH0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuc2hlbGwuZ2V0TnVtUG9pbnRzKCksZT0wO2U8dGhpcy5ob2xlcy5sZW5ndGg7ZSsrKXQrPXRoaXMuaG9sZXNbZV0uZ2V0TnVtUG9pbnRzKCk7cmV0dXJuIHR9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmNvcHkoKTt0LnNoZWxsPXRoaXMuc2hlbGwuY29weSgpLnJldmVyc2UoKSx0LmhvbGVzPW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0LmhvbGVzW2VdPXRoaXMuaG9sZXNbZV0uY29weSgpLnJldmVyc2UoKTtyZXR1cm4gdH0sY29udmV4SHVsbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdldEV4dGVyaW9yUmluZygpLmNvbnZleEh1bGwoKX0sY29tcGFyZVRvU2FtZUNsYXNzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXRoaXMuc2hlbGwsbj10LnNoZWxsO3JldHVybiBlLmNvbXBhcmVUb1NhbWVDbGFzcyhuKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9aSxlPXRoaXMuc2hlbGwsbj1zLnNoZWxsLG89ZS5jb21wYXJlVG9TYW1lQ2xhc3MobixyKTtpZigwIT09bylyZXR1cm4gbztmb3IodmFyIGE9dGhpcy5nZXROdW1JbnRlcmlvclJpbmcoKSx1PXMuZ2V0TnVtSW50ZXJpb3JSaW5nKCksbD0wO2E+bCYmdT5sOyl7dmFyIGg9dGhpcy5nZXRJbnRlcmlvclJpbmdOKGwpLGM9cy5nZXRJbnRlcmlvclJpbmdOKGwpLGY9aC5jb21wYXJlVG9TYW1lQ2xhc3MoYyxyKTtpZigwIT09ZilyZXR1cm4gZjtsKyt9cmV0dXJuIGE+bD8xOnU+bD8tMTowfX0sYXBwbHk6ZnVuY3Rpb24oKXtpZihSKGFyZ3VtZW50c1swXSx6KSl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2hlbGwuYXBwbHkodCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdGhpcy5ob2xlc1tlXS5hcHBseSh0KX1lbHNlIGlmKFIoYXJndW1lbnRzWzBdLGN0KSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKHRoaXMuc2hlbGwuYXBwbHkobiksIW4uaXNEb25lKCkpZm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aCYmKHRoaXMuaG9sZXNbZV0uYXBwbHkobiksIW4uaXNEb25lKCkpO2UrKyk7bi5pc0dlb21ldHJ5Q2hhbmdlZCgpJiZ0aGlzLmdlb21ldHJ5Q2hhbmdlZCgpfWVsc2UgaWYoUihhcmd1bWVudHNbMF0saHQpKXt2YXIgaT1hcmd1bWVudHNbMF07aS5maWx0ZXIodGhpcyl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSxxKSl7dmFyIHI9YXJndW1lbnRzWzBdO3IuZmlsdGVyKHRoaXMpLHRoaXMuc2hlbGwuYXBwbHkocik7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLmxlbmd0aDtlKyspdGhpcy5ob2xlc1tlXS5hcHBseShyKX19LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpTGluZVN0cmluZygpO3ZhciB0PW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCsxKS5maWxsKG51bGwpO3RbMF09dGhpcy5zaGVsbDtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0W2UrMV09dGhpcy5ob2xlc1tlXTtyZXR1cm4gdC5sZW5ndGg8PTE/dGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZWFyUmluZyh0WzBdLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpKTp0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcodCl9LGNsb25lOmZ1bmN0aW9uKCl7dmFyIHQ9Qi5wcm90b3R5cGUuY2xvbmUuY2FsbCh0aGlzKTt0LnNoZWxsPXRoaXMuc2hlbGwuY2xvbmUoKSx0LmhvbGVzPW5ldyBBcnJheSh0aGlzLmhvbGVzLmxlbmd0aCkuZmlsbChudWxsKTtmb3IodmFyIGU9MDtlPHRoaXMuaG9sZXMubGVuZ3RoO2UrKyl0LmhvbGVzW2VdPXRoaXMuaG9sZXNbZV0uY2xvbmUoKTtyZXR1cm4gdH0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJQb2x5Z29uXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5zaGVsbC5jb3B5KCksZT1uZXcgQXJyYXkodGhpcy5ob2xlcy5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dGhpcy5ob2xlc1tuXS5jb3B5KCk7cmV0dXJuIG5ldyBUdCh0LGUsdGhpcy5mYWN0b3J5KX0sZ2V0RXh0ZXJpb3JSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGx9LGlzRW1wdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zaGVsbC5pc0VtcHR5KCl9LGdldEludGVyaW9yUmluZ046ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuaG9sZXNbdF19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1J0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVHR9fSksVHQuc2VyaWFsVmVyc2lvblVJRD0tMHgzMDdmZmVmZDhkYzk3MjAwLGgoUHQsZnQpLGUoUHQucHJvdG90eXBlLHtnZXRTb3J0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gQi5TT1JUSU5ERVhfTVVMVElQT0lOVH0saXNWYWxpZDpmdW5jdGlvbigpe3JldHVybiEwfSxlcXVhbHNFeGFjdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMuaXNFcXVpdmFsZW50Q2xhc3ModCk/ZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmNhbGwodGhpcyx0LGUpOiExfXJldHVybiBmdC5wcm90b3R5cGUuZXF1YWxzRXhhY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5nZW9tZXRyaWVzW3RdLmdldENvb3JkaW5hdGUoKX1yZXR1cm4gZnQucHJvdG90eXBlLmdldENvb3JkaW5hdGUuYXBwbHkodGhpcyxhcmd1bWVudHMpfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiBsdC5GQUxTRX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDB9LGdldEJvdW5kYXJ5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihudWxsKX0sZ2V0R2VvbWV0cnlUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuXCJNdWx0aVBvaW50XCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IFB0KHQsdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bd3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQdH19KSxQdC5zZXJpYWxWZXJzaW9uVUlEPS0weDZmYjFlZDQxNjJlMGZjMDAsaChidCxTdCksZShidC5wcm90b3R5cGUse2dldFNvcnRJbmRleDpmdW5jdGlvbigpe3JldHVybiBCLlNPUlRJTkRFWF9MSU5FQVJSSU5HfSxnZXRCb3VuZGFyeURpbWVuc2lvbjpmdW5jdGlvbigpe3JldHVybiBsdC5GQUxTRX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ITA6U3QucHJvdG90eXBlLmlzQ2xvc2VkLmNhbGwodGhpcyl9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBvaW50cy5jb3B5KCk7Q3QucmV2ZXJzZSh0KTt2YXIgZT10aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKHQpO3JldHVybiBlfSx2YWxpZGF0ZUNvbnN0cnVjdGlvbjpmdW5jdGlvbigpe2lmKCF0aGlzLmlzRW1wdHkoKSYmIVN0LnByb3RvdHlwZS5pc0Nsb3NlZC5jYWxsKHRoaXMpKXRocm93IG5ldyBpKFwiUG9pbnRzIG9mIExpbmVhclJpbmcgZG8gbm90IGZvcm0gYSBjbG9zZWQgbGluZXN0cmluZ1wiKTtpZih0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLnNpemUoKT49MSYmdGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2UoKS5zaXplKCk8YnQuTUlOSU1VTV9WQUxJRF9TSVpFKXRocm93IG5ldyBpKFwiSW52YWxpZCBudW1iZXIgb2YgcG9pbnRzIGluIExpbmVhclJpbmcgKGZvdW5kIFwiK3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCkuc2l6ZSgpK1wiIC0gbXVzdCBiZSAwIG9yID49IDQpXCIpfSxnZXRHZW9tZXRyeVR5cGU6ZnVuY3Rpb24oKXtyZXR1cm5cIkxpbmVhclJpbmdcIn0sY29weTpmdW5jdGlvbigpe3JldHVybiBuZXcgYnQodGhpcy5wb2ludHMuY29weSgpLHRoaXMuZmFjdG9yeSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJ0fX0pLGJ0Lk1JTklNVU1fVkFMSURfU0laRT00LGJ0LnNlcmlhbFZlcnNpb25VSUQ9LTB4M2IyMjllMjYyMzY3YTYwMCxoKE90LGZ0KSxlKE90LnByb3RvdHlwZSx7Z2V0U29ydEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIEIuU09SVElOREVYX01VTFRJUE9MWUdPTn0sZXF1YWxzRXhhY3Q6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmlzRXF1aXZhbGVudENsYXNzKHQpP2Z0LnByb3RvdHlwZS5lcXVhbHNFeGFjdC5jYWxsKHRoaXMsdCxlKTohMX1yZXR1cm4gZnQucHJvdG90eXBlLmVxdWFsc0V4YWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZ2V0Qm91bmRhcnlEaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gMX0sZ2V0RGltZW5zaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIDJ9LHJldmVyc2U6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5nZW9tZXRyaWVzLmxlbmd0aCxlPW5ldyBBcnJheSh0KS5maWxsKG51bGwpLG49MDtuPHRoaXMuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWVbbl09dGhpcy5nZW9tZXRyaWVzW25dLnJldmVyc2UoKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlQb2x5Z29uKGUpfSxnZXRCb3VuZGFyeTpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmdldEZhY3RvcnkoKS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtmb3IodmFyIHQ9bmV3IEksZT0wO2U8dGhpcy5nZW9tZXRyaWVzLmxlbmd0aDtlKyspZm9yKHZhciBuPXRoaXMuZ2VvbWV0cmllc1tlXSxpPW4uZ2V0Qm91bmRhcnkoKSxyPTA7cjxpLmdldE51bUdlb21ldHJpZXMoKTtyKyspdC5hZGQoaS5nZXRHZW9tZXRyeU4ocikpO3ZhciBzPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdGhpcy5nZXRGYWN0b3J5KCkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKHQudG9BcnJheShzKSl9LGdldEdlb21ldHJ5VHlwZTpmdW5jdGlvbigpe3JldHVyblwiTXVsdGlQb2x5Z29uXCJ9LGNvcHk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuZ2VvbWV0cmllcy5sZW5ndGgpLmZpbGwobnVsbCksZT0wO2U8dC5sZW5ndGg7ZSsrKXRbZV09dGhpcy5nZW9tZXRyaWVzW2VdLmNvcHkoKTtyZXR1cm4gbmV3IE90KHQsdGhpcy5mYWN0b3J5KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bUnRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPdH19KSxPdC5zZXJpYWxWZXJzaW9uVUlEPS0weDdhNWFhMTM2OTE3MTk4MCxlKF90LnByb3RvdHlwZSx7c2V0Q29weVVzZXJEYXRhOmZ1bmN0aW9uKHQpe3RoaXMuaXNVc2VyRGF0YUNvcGllZD10fSxlZGl0OmZ1bmN0aW9uKHQsZSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIG49dGhpcy5lZGl0SW50ZXJuYWwodCxlKTtyZXR1cm4gdGhpcy5pc1VzZXJEYXRhQ29waWVkJiZuLnNldFVzZXJEYXRhKHQuZ2V0VXNlckRhdGEoKSksbn0sZWRpdEludGVybmFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9dC5nZXRGYWN0b3J5KCkpLHQgaW5zdGFuY2VvZiBmdD90aGlzLmVkaXRHZW9tZXRyeUNvbGxlY3Rpb24odCxlKTp0IGluc3RhbmNlb2YgVHQ/dGhpcy5lZGl0UG9seWdvbih0LGUpOnQgaW5zdGFuY2VvZiBMdD9lLmVkaXQodCx0aGlzLmZhY3RvcnkpOnQgaW5zdGFuY2VvZiBTdD9lLmVkaXQodCx0aGlzLmZhY3RvcnkpOihmLnNob3VsZE5ldmVyUmVhY2hIZXJlKFwiVW5zdXBwb3J0ZWQgR2VvbWV0cnkgY2xhc3M6IFwiK3QuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpLG51bGwpfSxlZGl0R2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuZWRpdCh0LHRoaXMuZmFjdG9yeSksaT1uZXcgSSxyPTA7cjxuLmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBzPXRoaXMuZWRpdChuLmdldEdlb21ldHJ5TihyKSxlKTtudWxsPT09c3x8cy5pc0VtcHR5KCl8fGkuYWRkKHMpfXJldHVybiBuLmdldENsYXNzKCk9PT1QdD90aGlzLmZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludChpLnRvQXJyYXkoW10pKTpuLmdldENsYXNzKCk9PT1ndD90aGlzLmZhY3RvcnkuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGkudG9BcnJheShbXSkpOm4uZ2V0Q2xhc3MoKT09PU90P3RoaXMuZmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oaS50b0FycmF5KFtdKSk6dGhpcy5mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpLnRvQXJyYXkoW10pKX0sZWRpdFBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmVkaXQodCx0aGlzLmZhY3RvcnkpO2lmKG51bGw9PT1uJiYobj10aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbihudWxsKSksbi5pc0VtcHR5KCkpcmV0dXJuIG47dmFyIGk9dGhpcy5lZGl0KG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSk7aWYobnVsbD09PWl8fGkuaXNFbXB0eSgpKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbigpO2Zvcih2YXIgcj1uZXcgSSxzPTA7czxuLmdldE51bUludGVyaW9yUmluZygpO3MrKyl7dmFyIG89dGhpcy5lZGl0KG4uZ2V0SW50ZXJpb3JSaW5nTihzKSxlKTtudWxsPT09b3x8by5pc0VtcHR5KCl8fHIuYWRkKG8pfXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbihpLHIudG9BcnJheShbXSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfdH19KSxfdC5HZW9tZXRyeUVkaXRvck9wZXJhdGlvbj1NdCxlKER0LnByb3RvdHlwZSx7ZWRpdDpmdW5jdGlvbih0LGUpe3JldHVybiB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIER0fX0pLGUoQXQucHJvdG90eXBlLHtlZGl0OmZ1bmN0aW9uKHQsZSl7aWYodCBpbnN0YW5jZW9mIGJ0KXJldHVybiBlLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5lZGl0Q29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpLHQpKTtpZih0IGluc3RhbmNlb2YgU3QpcmV0dXJuIGUuY3JlYXRlTGluZVN0cmluZyh0aGlzLmVkaXRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCksdCkpO2lmKHQgaW5zdGFuY2VvZiBMdCl7dmFyIG49dGhpcy5lZGl0Q29vcmRpbmF0ZXModC5nZXRDb29yZGluYXRlcygpLHQpO3JldHVybiBuLmxlbmd0aD4wP2UuY3JlYXRlUG9pbnQoblswXSk6ZS5jcmVhdGVQb2ludCgpfXJldHVybiB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEF0fX0pLGUoRnQucHJvdG90eXBlLHtlZGl0OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQgaW5zdGFuY2VvZiBidD9lLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiBTdD9lLmNyZWF0ZUxpbmVTdHJpbmcodGhpcy5lZGl0KHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCkpOnQgaW5zdGFuY2VvZiBMdD9lLmNyZWF0ZVBvaW50KHRoaXMuZWRpdCh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKTp0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltNdF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZ0fX0pLF90Lk5vT3BHZW9tZXRyeU9wZXJhdGlvbj1EdCxfdC5Db29yZGluYXRlT3BlcmF0aW9uPUF0LF90LkNvb3JkaW5hdGVTZXF1ZW5jZU9wZXJhdGlvbj1GdCxlKEd0LnByb3RvdHlwZSx7c2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlLG4pe3N3aXRjaChlKXtjYXNlIEQuWDp0aGlzLmNvb3JkaW5hdGVzW3RdLng9bjticmVhaztjYXNlIEQuWTp0aGlzLmNvb3JkaW5hdGVzW3RdLnk9bjticmVhaztjYXNlIEQuWjp0aGlzLmNvb3JkaW5hdGVzW3RdLno9bjticmVhaztkZWZhdWx0OnRocm93IG5ldyBpKFwiaW52YWxpZCBvcmRpbmF0ZUluZGV4XCIpfX0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aH0sZ2V0T3JkaW5hdGU6ZnVuY3Rpb24odCxlKXtzd2l0Y2goZSl7Y2FzZSBELlg6cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueDtjYXNlIEQuWTpyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XS55O2Nhc2UgRC5aOnJldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnp9cmV0dXJuIHIuTmFOfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb29yZGluYXRlc1t0XX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO24ueD10aGlzLmNvb3JkaW5hdGVzW2VdLngsbi55PXRoaXMuY29vcmRpbmF0ZXNbZV0ueSxuLno9dGhpcy5jb29yZGluYXRlc1tlXS56fX0sZ2V0Q29vcmRpbmF0ZUNvcHk6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRoaXMuY29vcmRpbmF0ZXNbdF0pfSxnZXREaW1lbnNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaW1lbnNpb259LGdldFg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXNbdF0ueH0sY2xvbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuc2l6ZSgpKS5maWxsKG51bGwpLGU9MDtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0W2VdPXRoaXMuY29vcmRpbmF0ZXNbZV0uY2xvbmUoKTtyZXR1cm4gbmV3IEd0KHQsdGhpcy5kaW1lbnNpb24pfSxleHBhbmRFbnZlbG9wZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuY29vcmRpbmF0ZXMubGVuZ3RoO2UrKyl0LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmNvb3JkaW5hdGVzW2VdKTtyZXR1cm4gdH0sY29weTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5zaXplKCkpLmZpbGwobnVsbCksZT0wO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXRbZV09dGhpcy5jb29yZGluYXRlc1tlXS5jb3B5KCk7cmV0dXJuIG5ldyBHdCh0LHRoaXMuZGltZW5zaW9uKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtpZih0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aD4wKXt2YXIgdD1uZXcgUCgxNyp0aGlzLmNvb3JkaW5hdGVzLmxlbmd0aCk7dC5hcHBlbmQoXCIoXCIpLHQuYXBwZW5kKHRoaXMuY29vcmRpbmF0ZXNbMF0pO2Zvcih2YXIgZT0xO2U8dGhpcy5jb29yZGluYXRlcy5sZW5ndGg7ZSsrKXQuYXBwZW5kKFwiLCBcIiksdC5hcHBlbmQodGhpcy5jb29yZGluYXRlc1tlXSk7cmV0dXJuIHQuYXBwZW5kKFwiKVwiKSx0LnRvU3RyaW5nKCl9cmV0dXJuXCIoKVwifSxnZXRZOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVzW3RdLnl9LHRvQ29vcmRpbmF0ZUFycmF5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0QsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEd0fX0pLEd0LnNlcmlhbFZlcnNpb25VSUQ9LTB4Y2I0NGE3NzhkYjE4ZTAwLGUocXQucHJvdG90eXBlLHtyZWFkUmVzb2x2ZTpmdW5jdGlvbigpe3JldHVybiBxdC5pbnN0YW5jZSgpfSxjcmVhdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgR3QodCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEd0KGUpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV07cmV0dXJuIGk+MyYmKGk9MyksMj5pP25ldyBHdChuKTpuZXcgR3QobixpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0csdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHF0fX0pLHF0Lmluc3RhbmNlPWZ1bmN0aW9uKCl7cmV0dXJuIHF0Lmluc3RhbmNlT2JqZWN0fSxxdC5zZXJpYWxWZXJzaW9uVUlEPS0weDM4ZTQ5ZmE2Y2Y2ZjJlMDAscXQuaW5zdGFuY2VPYmplY3Q9bmV3IHF0O3ZhciBubyxpbz1PYmplY3QuZGVmaW5lUHJvcGVydHkscm89enQoe2RlbGV0ZTprdCxoYXM6WHQsZ2V0Oll0LHNldDpIdCxrZXlzOmp0LHZhbHVlczpLdCxlbnRyaWVzOlp0LGZvckVhY2g6JHQsY2xlYXI6V3R9KSxzbz1cInVuZGVmaW5lZFwiIT10eXBlb2YgTWFwJiZNYXAucHJvdG90eXBlLnZhbHVlcz9NYXA6cm87dGUucHJvdG90eXBlPW5ldyBLLHRlLnByb3RvdHlwZS5nZXQ9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubWFwXy5nZXQodCl8fG51bGx9LHRlLnByb3RvdHlwZS5wdXQ9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5tYXBfLnNldCh0LGUpLGV9LHRlLnByb3RvdHlwZS52YWx1ZXM9ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEksZT10aGlzLm1hcF8udmFsdWVzKCksbj1lLm5leHQoKTshbi5kb25lOyl0LmFkZChuLnZhbHVlKSxuPWUubmV4dCgpO3JldHVybiB0fSx0ZS5wcm90b3R5cGUuZW50cnlTZXQ9ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSjtyZXR1cm4gdGhpcy5tYXBfLmVudHJpZXMoKS5mb3JFYWNoKGZ1bmN0aW9uKGUpe3JldHVybiB0LmFkZChlKX0pLHR9LHRlLnByb3RvdHlwZS5zaXplPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWFwXy5zaXplKCl9LGUoZWUucHJvdG90eXBlLHtlcXVhbHM6ZnVuY3Rpb24odCl7aWYoISh0IGluc3RhbmNlb2YgZWUpKXJldHVybiExO3ZhciBlPXQ7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZS5tb2RlbFR5cGUmJnRoaXMuc2NhbGU9PT1lLnNjYWxlfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMuZ2V0TWF4aW11bVNpZ25pZmljYW50RGlnaXRzKCksaT1lLmdldE1heGltdW1TaWduaWZpY2FudERpZ2l0cygpO3JldHVybiBuZXcgYihuKS5jb21wYXJlVG8obmV3IGIoaSkpfSxnZXRTY2FsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNjYWxlfSxpc0Zsb2F0aW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkd8fHRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFfSxnZXRUeXBlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9kZWxUeXBlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PVwiVU5LTk9XTlwiO3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HP3Q9XCJGbG9hdGluZ1wiOnRoaXMubW9kZWxUeXBlPT09ZWUuRkxPQVRJTkdfU0lOR0xFP3Q9XCJGbG9hdGluZy1TaW5nbGVcIjp0aGlzLm1vZGVsVHlwZT09PWVlLkZJWEVEJiYodD1cIkZpeGVkIChTY2FsZT1cIit0aGlzLmdldFNjYWxlKCkrXCIpXCIpLHR9LG1ha2VQcmVjaXNlOmZ1bmN0aW9uKCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHIuaXNOYU4odCkpcmV0dXJuIHQ7aWYodGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEUpe3ZhciBlPXQ7cmV0dXJuIGV9cmV0dXJuIHRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQ/TWF0aC5yb3VuZCh0KnRoaXMuc2NhbGUpL3RoaXMuc2NhbGU6dH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HKXJldHVybiBudWxsO24ueD10aGlzLm1ha2VQcmVjaXNlKG4ueCksbi55PXRoaXMubWFrZVByZWNpc2Uobi55KX19LGdldE1heGltdW1TaWduaWZpY2FudERpZ2l0czpmdW5jdGlvbigpe3ZhciB0PTE2O3JldHVybiB0aGlzLm1vZGVsVHlwZT09PWVlLkZMT0FUSU5HP3Q9MTY6dGhpcy5tb2RlbFR5cGU9PT1lZS5GTE9BVElOR19TSU5HTEU/dD02OnRoaXMubW9kZWxUeXBlPT09ZWUuRklYRUQmJih0PTErTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5sb2codGhpcy5nZXRTY2FsZSgpKS9NYXRoLmxvZygxMCkpKSksdH0sc2V0U2NhbGU6ZnVuY3Rpb24odCl7dGhpcy5zY2FsZT1NYXRoLmFicyh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdSxzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZWV9fSksZWUubW9zdFByZWNpc2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5jb21wYXJlVG8oZSk+PTA/dDplfSxlKG5lLnByb3RvdHlwZSx7cmVhZFJlc29sdmU6ZnVuY3Rpb24oKXtyZXR1cm4gbmUubmFtZVRvVHlwZU1hcC5nZXQodGhpcy5uYW1lKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uYW1lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbmV9fSksbmUuc2VyaWFsVmVyc2lvblVJRD0tNTUyODYwMjYzMTczMTU5ZTQsbmUubmFtZVRvVHlwZU1hcD1uZXcgdGUsZWUuVHlwZT1uZSxlZS5zZXJpYWxWZXJzaW9uVUlEPTB4NmJlZTY0MDRlOWEyNWMwMCxlZS5GSVhFRD1uZXcgbmUoXCJGSVhFRFwiKSxlZS5GTE9BVElORz1uZXcgbmUoXCJGTE9BVElOR1wiKSxlZS5GTE9BVElOR19TSU5HTEU9bmV3IG5lKFwiRkxPQVRJTkcgU0lOR0xFXCIpLGVlLm1heGltdW1QcmVjaXNlVmFsdWU9OTAwNzE5OTI1NDc0MDk5MixlKGllLnByb3RvdHlwZSx7dG9HZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdC5pc051bGwoKT90aGlzLmNyZWF0ZVBvaW50KG51bGwpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCkmJnQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVQb2ludChuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSkpOnQuZ2V0TWluWCgpPT09dC5nZXRNYXhYKCl8fHQuZ2V0TWluWSgpPT09dC5nZXRNYXhZKCk/dGhpcy5jcmVhdGVMaW5lU3RyaW5nKFtuZXcgZyh0LmdldE1pblgoKSx0LmdldE1pblkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNYXhZKCkpXSk6dGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyhbbmV3IGcodC5nZXRNaW5YKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WSgpKSxuZXcgZyh0LmdldE1heFgoKSx0LmdldE1heFkoKSksbmV3IGcodC5nZXRNYXhYKCksdC5nZXRNaW5ZKCkpLG5ldyBnKHQuZ2V0TWluWCgpLHQuZ2V0TWluWSgpKV0pLG51bGwpfSxjcmVhdGVMaW5lU3RyaW5nOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZUxpbmVTdHJpbmcobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKHQpOm51bGwpfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBTdChlLHRoaXMpfX19LGNyZWF0ZU11bHRpTGluZVN0cmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBuZXcgZ3QobnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgZ3QodCx0aGlzKX19LGJ1aWxkR2VvbWV0cnk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj0hMSxpPSExLHI9dC5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCksbz1zLmdldENsYXNzKCk7bnVsbD09PWUmJihlPW8pLG8hPT1lJiYobj0hMCkscy5pc0dlb21ldHJ5Q29sbGVjdGlvbk9yRGVyaXZlZCgpJiYoaT0hMCl9aWYobnVsbD09PWUpcmV0dXJuIHRoaXMuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKCk7aWYobnx8aSlyZXR1cm4gdGhpcy5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oaWUudG9HZW9tZXRyeUFycmF5KHQpKTt2YXIgYT10Lml0ZXJhdG9yKCkubmV4dCgpLHU9dC5zaXplKCk+MTtpZih1KXtpZihhIGluc3RhbmNlb2YgVHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2x5Z29uKGllLnRvUG9seWdvbkFycmF5KHQpKTtpZihhIGluc3RhbmNlb2YgU3QpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlMaW5lU3RyaW5nKGllLnRvTGluZVN0cmluZ0FycmF5KHQpKTtpZihhIGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMuY3JlYXRlTXVsdGlQb2ludChpZS50b1BvaW50QXJyYXkodCkpO2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJVbmhhbmRsZWQgY2xhc3M6IFwiK2EuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfXJldHVybiBhfSxjcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX0sY3JlYXRlUG9pbnQ6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gdGhpcy5jcmVhdGVQb2ludCh0aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoW10pKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnQobnVsbCE9PXQ/dGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFt0XSk6bnVsbCl9aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IEx0KGUsdGhpcyl9fX0sZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnl9LGNyZWF0ZVBvbHlnb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IFR0KG51bGwsbnVsbCx0aGlzKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sRCkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVQb2x5Z29uKHRoaXMuY3JlYXRlTGluZWFyUmluZyh0KSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmNyZWF0ZVBvbHlnb24odGhpcy5jcmVhdGVMaW5lYXJSaW5nKGUpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGJ0KXt2YXIgbj1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuY3JlYXRlUG9seWdvbihuLG51bGwpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV07cmV0dXJuIG5ldyBUdChpLHIsdGhpcyl9fSxnZXRTUklEOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuU1JJRH0sY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBmdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBmdCh0LHRoaXMpfX0sY3JlYXRlR2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IF90KHRoaXMpO3JldHVybiBlLmVkaXQodCx7ZWRpdDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmNvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkuY3JlYXRlKHQpfX19KX0sZ2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbH0sY3JlYXRlTGluZWFyUmluZzpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLmNyZWF0ZUxpbmVhclJpbmcodGhpcy5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKFtdKSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVMaW5lYXJSaW5nKG51bGwhPT10P3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZSh0KTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBuZXcgYnQoZSx0aGlzKX19fSxjcmVhdGVNdWx0aVBvbHlnb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbmV3IE90KG51bGwsdGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gbmV3IE90KHQsdGhpcyl9fSxjcmVhdGVNdWx0aVBvaW50OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG5ldyBQdChudWxsLHRoaXMpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIG5ldyBQdCh0LHRoaXMpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jcmVhdGVNdWx0aVBvaW50KG51bGwhPT1lP3RoaXMuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlRmFjdG9yeSgpLmNyZWF0ZShlKTpudWxsKX1pZihSKGFyZ3VtZW50c1swXSxEKSl7dmFyIG49YXJndW1lbnRzWzBdO2lmKG51bGw9PT1uKXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQobmV3IEFycmF5KDApLmZpbGwobnVsbCkpO2Zvcih2YXIgaT1uZXcgQXJyYXkobi5zaXplKCkpLmZpbGwobnVsbCkscj0wO3I8bi5zaXplKCk7cisrKXt2YXIgcz10aGlzLmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoMSxuLmdldERpbWVuc2lvbigpKTtDdC5jb3B5KG4scixzLDAsMSksaVtyXT10aGlzLmNyZWF0ZVBvaW50KHMpfXJldHVybiB0aGlzLmNyZWF0ZU11bHRpUG9pbnQoaSl9fX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGllfX0pLGllLnRvTXVsdGlQb2x5Z29uQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvR2VvbWV0cnlBcnJheT1mdW5jdGlvbih0KXtpZihudWxsPT09dClyZXR1cm4gbnVsbDt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUuZ2V0RGVmYXVsdENvb3JkaW5hdGVTZXF1ZW5jZUZhY3Rvcnk9ZnVuY3Rpb24oKXtyZXR1cm4gcXQuaW5zdGFuY2UoKX0saWUudG9NdWx0aUxpbmVTdHJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9MaW5lU3RyaW5nQXJyYXk9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiB0LnRvQXJyYXkoZSl9LGllLnRvTXVsdGlQb2ludEFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b0xpbmVhclJpbmdBcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUudG9Qb2ludEFycmF5PWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKTtyZXR1cm4gdC50b0FycmF5KGUpfSxpZS50b1BvbHlnb25BcnJheT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHQudG9BcnJheShlKX0saWUuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBlLmdldFByZWNpc2lvbk1vZGVsKCkubWFrZVByZWNpc2UodCksZS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodCl9LGllLnNlcmlhbFZlcnNpb25VSUQ9LTB4NWVhNzVmMjA1MWVlYjQwMDt2YXIgb289e3R5cGVTdHI6L15cXHMqKFxcdyspXFxzKlxcKFxccyooLiopXFxzKlxcKVxccyokLyxlbXB0eVR5cGVTdHI6L15cXHMqKFxcdyspXFxzKkVNUFRZXFxzKiQvLHNwYWNlczovXFxzKy8scGFyZW5Db21tYTovXFwpXFxzKixcXHMqXFwoLyxkb3VibGVQYXJlbkNvbW1hOi9cXClcXHMqXFwpXFxzKixcXHMqXFwoXFxzKlxcKC8sdHJpbVBhcmVuczovXlxccypcXCg/KC4qPylcXCk/XFxzKiQvfTtlKHJlLnByb3RvdHlwZSx7cmVhZDpmdW5jdGlvbih0KXt2YXIgZSxuLGk7dD10LnJlcGxhY2UoL1tcXG5cXHJdL2csXCIgXCIpO3ZhciByPW9vLnR5cGVTdHIuZXhlYyh0KTtpZigtMSE9PXQuc2VhcmNoKFwiRU1QVFlcIikmJihyPW9vLmVtcHR5VHlwZVN0ci5leGVjKHQpLHJbMl09dm9pZCAwKSxyJiYobj1yWzFdLnRvTG93ZXJDYXNlKCksaT1yWzJdLHVvW25dJiYoZT11b1tuXS5hcHBseSh0aGlzLFtpXSkpKSx2b2lkIDA9PT1lKXRocm93IG5ldyBFcnJvcihcIkNvdWxkIG5vdCBwYXJzZSBXS1QgXCIrdCk7cmV0dXJuIGV9LHdyaXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmV4dHJhY3RHZW9tZXRyeSh0KX0sZXh0cmFjdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0R2VvbWV0cnlUeXBlKCkudG9Mb3dlckNhc2UoKTtpZighYW9bZV0pcmV0dXJuIG51bGw7dmFyIG4saT1lLnRvVXBwZXJDYXNlKCk7cmV0dXJuIG49dC5pc0VtcHR5KCk/aStcIiBFTVBUWVwiOmkrXCIoXCIrYW9bZV0uYXBwbHkodGhpcyxbdF0pK1wiKVwifX0pO3ZhciBhbz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdC54K1wiIFwiK3QueX0scG9pbnQ6ZnVuY3Rpb24odCl7XG5yZXR1cm4gYW8uY29vcmRpbmF0ZS5jYWxsKHRoaXMsdC5jb29yZGluYXRlcy5jb29yZGluYXRlc1swXSl9LG11bHRpcG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ucG9pbnQuYXBwbHkodGhpcyxbdC5nZW9tZXRyaWVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTAsaT10LnBvaW50cy5jb29yZGluYXRlcy5sZW5ndGg7aT5uOysrbillLnB1c2goYW8uY29vcmRpbmF0ZS5hcHBseSh0aGlzLFt0LnBvaW50cy5jb29yZGluYXRlc1tuXV0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0sbGluZWFycmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5wb2ludHMuY29vcmRpbmF0ZXMubGVuZ3RoO2k+bjsrK24pZS5wdXNoKGFvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbdC5wb2ludHMuY29vcmRpbmF0ZXNbbl1dKSk7cmV0dXJuIGUuam9pbihcIixcIil9LG11bHRpbGluZXN0cmluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtpPm47KytuKWUucHVzaChcIihcIithby5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW3QuZ2VvbWV0cmllc1tuXV0pK1wiKVwiKTtyZXR1cm4gZS5qb2luKFwiLFwiKX0scG9seWdvbjpmdW5jdGlvbih0KXt2YXIgZT1bXTtlLnB1c2goXCIoXCIrYW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFt0LnNoZWxsXSkrXCIpXCIpO2Zvcih2YXIgbj0wLGk9dC5ob2xlcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ubGluZXN0cmluZy5hcHBseSh0aGlzLFt0LmhvbGVzW25dXSkrXCIpXCIpO3JldHVybiBlLmpvaW4oXCIsXCIpfSxtdWx0aXBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MCxpPXQuZ2VvbWV0cmllcy5sZW5ndGg7aT5uOysrbillLnB1c2goXCIoXCIrYW8ucG9seWdvbi5hcHBseSh0aGlzLFt0Lmdlb21ldHJpZXNbbl1dKStcIilcIik7cmV0dXJuIGUuam9pbihcIixcIil9LGdlb21ldHJ5Y29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wLGk9dC5nZW9tZXRyaWVzLmxlbmd0aDtpPm47KytuKWUucHVzaCh0aGlzLmV4dHJhY3RHZW9tZXRyeSh0Lmdlb21ldHJpZXNbbl0pKTtyZXR1cm4gZS5qb2luKFwiLFwiKX19LHVvPXtwb2ludDpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludCgpO3ZhciBlPXQudHJpbSgpLnNwbGl0KG9vLnNwYWNlcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KG5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKSl9LG11bHRpcG9pbnQ6ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2ludCgpO2Zvcih2YXIgZSxuPXQudHJpbSgpLnNwbGl0KFwiLFwiKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLGkucHVzaCh1by5wb2ludC5hcHBseSh0aGlzLFtlXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGkpfSxsaW5lc3RyaW5nOmZ1bmN0aW9uKHQpe2lmKHZvaWQgMD09PXQpcmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChcIixcIiksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS50cmltKCkuc3BsaXQob28uc3BhY2VzKSxpLnB1c2gobmV3IGcoTnVtYmVyLnBhcnNlRmxvYXQoZVswXSksTnVtYmVyLnBhcnNlRmxvYXQoZVsxXSkpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhpKX0sbGluZWFycmluZzpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQoXCIsXCIpLGk9W10scj0wLHM9bi5sZW5ndGg7cz5yOysrcillPW5bcl0udHJpbSgpLnNwbGl0KG9vLnNwYWNlcyksaS5wdXNoKG5ldyBnKE51bWJlci5wYXJzZUZsb2F0KGVbMF0pLE51bWJlci5wYXJzZUZsb2F0KGVbMV0pKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoaSl9LG11bHRpbGluZXN0cmluZzpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoKTtmb3IodmFyIGUsbj10LnRyaW0oKS5zcGxpdChvby5wYXJlbkNvbW1hKSxpPVtdLHI9MCxzPW4ubGVuZ3RoO3M+cjsrK3IpZT1uW3JdLnJlcGxhY2Uob28udHJpbVBhcmVucyxcIiQxXCIpLGkucHVzaCh1by5saW5lc3RyaW5nLmFwcGx5KHRoaXMsW2VdKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhpKX0scG9seWdvbjpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2x5Z29uKCk7Zm9yKHZhciBlLG4saSxyLHM9dC50cmltKCkuc3BsaXQob28ucGFyZW5Db21tYSksbz1bXSxhPTAsdT1zLmxlbmd0aDt1PmE7KythKWU9c1thXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxuPXVvLmxpbmVzdHJpbmcuYXBwbHkodGhpcyxbZV0pLGk9dGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhuLnBvaW50cyksMD09PWE/cj1pOm8ucHVzaChpKTtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihyLG8pfSxtdWx0aXBvbHlnb246ZnVuY3Rpb24odCl7aWYodm9pZCAwPT09dClyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTXVsdGlQb2x5Z29uKCk7Zm9yKHZhciBlLG49dC50cmltKCkuc3BsaXQob28uZG91YmxlUGFyZW5Db21tYSksaT1bXSxyPTAscz1uLmxlbmd0aDtzPnI7KytyKWU9bltyXS5yZXBsYWNlKG9vLnRyaW1QYXJlbnMsXCIkMVwiKSxpLnB1c2godW8ucG9seWdvbi5hcHBseSh0aGlzLFtlXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oaSl9LGdlb21ldHJ5Y29sbGVjdGlvbjpmdW5jdGlvbih0KXtpZih2b2lkIDA9PT10KXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oKTt0PXQucmVwbGFjZSgvLFxccyooW0EtWmEtel0pL2csXCJ8JDFcIik7Zm9yKHZhciBlPXQudHJpbSgpLnNwbGl0KFwifFwiKSxuPVtdLGk9MCxyPWUubGVuZ3RoO3I+aTsrK2kpbi5wdXNoKHRoaXMucmVhZChlW2ldKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuKX19O2Uoc2UucHJvdG90eXBlLHt3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9fSksZShzZSx7dG9MaW5lU3RyaW5nOmZ1bmN0aW9uKHQsZSl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKFwiTm90IGltcGxlbWVudGVkXCIpO3JldHVyblwiTElORVNUUklORyAoIFwiK3QueCtcIiBcIit0LnkrXCIsIFwiK2UueCtcIiBcIitlLnkrXCIgKVwifX0pLGUob2UucHJvdG90eXBlLHtnZXRJbmRleEFsb25nU2VnbWVudDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLmludExpbmVJbmRleFt0XVtlXX0sZ2V0VG9wb2xvZ3lTdW1tYXJ5OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7cmV0dXJuIHRoaXMuaXNFbmRQb2ludCgpJiZ0LmFwcGVuZChcIiBlbmRwb2ludFwiKSx0aGlzLl9pc1Byb3BlciYmdC5hcHBlbmQoXCIgcHJvcGVyXCIpLHRoaXMuaXNDb2xsaW5lYXIoKSYmdC5hcHBlbmQoXCIgY29sbGluZWFyXCIpLHQudG9TdHJpbmcoKX0sY29tcHV0ZUludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt0aGlzLmlucHV0TGluZXNbMF1bMF09dCx0aGlzLmlucHV0TGluZXNbMF1bMV09ZSx0aGlzLmlucHV0TGluZXNbMV1bMF09bix0aGlzLmlucHV0TGluZXNbMV1bMV09aSx0aGlzLnJlc3VsdD10aGlzLmNvbXB1dGVJbnRlcnNlY3QodCxlLG4saSl9LGdldEludGVyc2VjdGlvbk51bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc3VsdH0sY29tcHV0ZUludExpbmVJbmRleDpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKW51bGw9PT10aGlzLmludExpbmVJbmRleCYmKHRoaXMuaW50TGluZUluZGV4PUFycmF5KDIpLmZpbGwoKS5tYXAoZnVuY3Rpb24oKXtyZXR1cm4gQXJyYXkoMil9KSx0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoMCksdGhpcy5jb21wdXRlSW50TGluZUluZGV4KDEpKTtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLmdldEVkZ2VEaXN0YW5jZSh0LDApLG49dGhpcy5nZXRFZGdlRGlzdGFuY2UodCwxKTtlPm4/KHRoaXMuaW50TGluZUluZGV4W3RdWzBdPTAsdGhpcy5pbnRMaW5lSW5kZXhbdF1bMV09MSk6KHRoaXMuaW50TGluZUluZGV4W3RdWzBdPTEsdGhpcy5pbnRMaW5lSW5kZXhbdF1bMV09MCl9fSxpc1Byb3BlcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLl9pc1Byb3Blcn0sc2V0UHJlY2lzaW9uTW9kZWw6ZnVuY3Rpb24odCl7dGhpcy5wcmVjaXNpb25Nb2RlbD10fSxpc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigwKT8hMDohIXRoaXMuaXNJbnRlcmlvckludGVyc2VjdGlvbigxKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0aGlzLnJlc3VsdDtlKyspaWYoIXRoaXMuaW50UHRbZV0uZXF1YWxzMkQodGhpcy5pbnB1dExpbmVzW3RdWzBdKSYmIXRoaXMuaW50UHRbZV0uZXF1YWxzMkQodGhpcy5pbnB1dExpbmVzW3RdWzFdKSlyZXR1cm4hMDtyZXR1cm4hMX19LGdldEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pbnRQdFt0XX0saXNFbmRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbigpJiYhdGhpcy5faXNQcm9wZXJ9LGhhc0ludGVyc2VjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc3VsdCE9PW9lLk5PX0lOVEVSU0VDVElPTn0sZ2V0RWRnZURpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7dmFyIG49b2UuY29tcHV0ZUVkZ2VEaXN0YW5jZSh0aGlzLmludFB0W2VdLHRoaXMuaW5wdXRMaW5lc1t0XVswXSx0aGlzLmlucHV0TGluZXNbdF1bMV0pO3JldHVybiBufSxpc0NvbGxpbmVhcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJlc3VsdD09PW9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT059LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyh0aGlzLmlucHV0TGluZXNbMF1bMF0sdGhpcy5pbnB1dExpbmVzWzBdWzFdKStcIiAtIFwiK3NlLnRvTGluZVN0cmluZyh0aGlzLmlucHV0TGluZXNbMV1bMF0sdGhpcy5pbnB1dExpbmVzWzFdWzFdKSt0aGlzLmdldFRvcG9sb2d5U3VtbWFyeSgpfSxnZXRFbmRwb2ludDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmlucHV0TGluZXNbdF1bZV19LGlzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dGhpcy5yZXN1bHQ7ZSsrKWlmKHRoaXMuaW50UHRbZV0uZXF1YWxzMkQodCkpcmV0dXJuITA7cmV0dXJuITF9LGdldEludGVyc2VjdGlvbkFsb25nU2VnbWVudDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvbXB1dGVJbnRMaW5lSW5kZXgoKSx0aGlzLmludFB0W3RoaXMuaW50TGluZUluZGV4W3RdW2VdXX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb2V9fSksb2UuY29tcHV0ZUVkZ2VEaXN0YW5jZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9TWF0aC5hYnMobi54LWUueCkscj1NYXRoLmFicyhuLnktZS55KSxzPS0xO2lmKHQuZXF1YWxzKGUpKXM9MDtlbHNlIGlmKHQuZXF1YWxzKG4pKXM9aT5yP2k6cjtlbHNle3ZhciBvPU1hdGguYWJzKHQueC1lLngpLGE9TWF0aC5hYnModC55LWUueSk7cz1pPnI/bzphLDAhPT1zfHx0LmVxdWFscyhlKXx8KHM9TWF0aC5tYXgobyxhKSl9cmV0dXJuIGYuaXNUcnVlKCEoMD09PXMmJiF0LmVxdWFscyhlKSksXCJCYWQgZGlzdGFuY2UgY2FsY3VsYXRpb25cIiksc30sb2Uubm9uUm9idXN0Q29tcHV0ZUVkZ2VEaXN0YW5jZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC54LWUueCxyPXQueS1lLnkscz1NYXRoLnNxcnQoaSppK3Iqcik7cmV0dXJuIGYuaXNUcnVlKCEoMD09PXMmJiF0LmVxdWFscyhlKSksXCJJbnZhbGlkIGRpc3RhbmNlIGNhbGN1bGF0aW9uXCIpLHN9LG9lLkRPTlRfSU5URVJTRUNUPTAsb2UuRE9fSU5URVJTRUNUPTEsb2UuQ09MTElORUFSPTIsb2UuTk9fSU5URVJTRUNUSU9OPTAsb2UuUE9JTlRfSU5URVJTRUNUSU9OPTEsb2UuQ09MTElORUFSX0lOVEVSU0VDVElPTj0yLGgoYWUsb2UpLGUoYWUucHJvdG90eXBlLHtpc0luU2VnbWVudEVudmVsb3BlczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgQyh0aGlzLmlucHV0TGluZXNbMF1bMF0sdGhpcy5pbnB1dExpbmVzWzBdWzFdKSxuPW5ldyBDKHRoaXMuaW5wdXRMaW5lc1sxXVswXSx0aGlzLmlucHV0TGluZXNbMV1bMV0pO3JldHVybiBlLmNvbnRhaW5zKHQpJiZuLmNvbnRhaW5zKHQpfSxjb21wdXRlSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7aWYoMyE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIG9lLnByb3RvdHlwZS5jb21wdXRlSW50ZXJzZWN0aW9uLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1hcmd1bWVudHNbMl07cmV0dXJuIHRoaXMuX2lzUHJvcGVyPSExLEMuaW50ZXJzZWN0cyhlLG4sdCkmJjA9PT1oZS5vcmllbnRhdGlvbkluZGV4KGUsbix0KSYmMD09PWhlLm9yaWVudGF0aW9uSW5kZXgobixlLHQpPyh0aGlzLl9pc1Byb3Blcj0hMCwodC5lcXVhbHMoZSl8fHQuZXF1YWxzKG4pKSYmKHRoaXMuX2lzUHJvcGVyPSExKSx0aGlzLnJlc3VsdD1vZS5QT0lOVF9JTlRFUlNFQ1RJT04sbnVsbCk6dm9pZCh0aGlzLnJlc3VsdD1vZS5OT19JTlRFUlNFQ1RJT04pfSxub3JtYWxpemVUb01pbmltdW06ZnVuY3Rpb24odCxlLG4saSxyKXtyLng9dGhpcy5zbWFsbGVzdEluQWJzVmFsdWUodC54LGUueCxuLngsaS54KSxyLnk9dGhpcy5zbWFsbGVzdEluQWJzVmFsdWUodC55LGUueSxuLnksaS55KSx0LngtPXIueCx0LnktPXIueSxlLngtPXIueCxlLnktPXIueSxuLngtPXIueCxuLnktPXIueSxpLngtPXIueCxpLnktPXIueX0sc2FmZUhDb29yZGluYXRlSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW51bGw7dHJ5e3I9Ri5pbnRlcnNlY3Rpb24odCxlLG4saSl9Y2F0Y2gocyl7aWYoIShzIGluc3RhbmNlb2YgdykpdGhyb3cgcztyPWFlLm5lYXJlc3RFbmRwb2ludCh0LGUsbixpKX1maW5hbGx5e31yZXR1cm4gcn0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMuaW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb24odCxlLG4saSk7cmV0dXJuIHRoaXMuaXNJblNlZ21lbnRFbnZlbG9wZXMocil8fChyPW5ldyBnKGFlLm5lYXJlc3RFbmRwb2ludCh0LGUsbixpKSkpLG51bGwhPT10aGlzLnByZWNpc2lvbk1vZGVsJiZ0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHIpLHJ9LHNtYWxsZXN0SW5BYnNWYWx1ZTpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LHM9TWF0aC5hYnMocik7cmV0dXJuIE1hdGguYWJzKGUpPHMmJihyPWUscz1NYXRoLmFicyhlKSksTWF0aC5hYnMobik8cyYmKHI9bixzPU1hdGguYWJzKG4pKSxNYXRoLmFicyhpKTxzJiYocj1pKSxyfSxjaGVja0REOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9TS5pbnRlcnNlY3Rpb24odCxlLG4saSksbz10aGlzLmlzSW5TZWdtZW50RW52ZWxvcGVzKHMpO0Eub3V0LnByaW50bG4oXCJERCBpbiBlbnYgPSBcIitvK1wiICAtLS0tLS0tLS0tLS0tLS0tLS0tLS0gXCIrcyksci5kaXN0YW5jZShzKT4xZS00JiZBLm91dC5wcmludGxuKFwiRGlzdGFuY2UgPSBcIityLmRpc3RhbmNlKHMpKX0saW50ZXJzZWN0aW9uV2l0aE5vcm1hbGl6YXRpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bmV3IGcodCkscz1uZXcgZyhlKSxvPW5ldyBnKG4pLGE9bmV3IGcoaSksdT1uZXcgZzt0aGlzLm5vcm1hbGl6ZVRvRW52Q2VudHJlKHIscyxvLGEsdSk7dmFyIGw9dGhpcy5zYWZlSENvb3JkaW5hdGVJbnRlcnNlY3Rpb24ocixzLG8sYSk7cmV0dXJuIGwueCs9dS54LGwueSs9dS55LGx9LGNvbXB1dGVDb2xsaW5lYXJJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Qy5pbnRlcnNlY3RzKHQsZSxuKSxzPUMuaW50ZXJzZWN0cyh0LGUsaSksbz1DLmludGVyc2VjdHMobixpLHQpLGE9Qy5pbnRlcnNlY3RzKG4saSxlKTtyZXR1cm4gciYmcz8odGhpcy5pbnRQdFswXT1uLHRoaXMuaW50UHRbMV09aSxvZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OKTpvJiZhPyh0aGlzLmludFB0WzBdPXQsdGhpcy5pbnRQdFsxXT1lLG9lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT04pOnImJm8/KHRoaXMuaW50UHRbMF09bix0aGlzLmludFB0WzFdPXQsIW4uZXF1YWxzKHQpfHxzfHxhP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpyJiZhPyh0aGlzLmludFB0WzBdPW4sdGhpcy5pbnRQdFsxXT1lLCFuLmVxdWFscyhlKXx8c3x8bz9vZS5DT0xMSU5FQVJfSU5URVJTRUNUSU9OOm9lLlBPSU5UX0lOVEVSU0VDVElPTik6cyYmbz8odGhpcy5pbnRQdFswXT1pLHRoaXMuaW50UHRbMV09dCwhaS5lcXVhbHModCl8fHJ8fGE/b2UuQ09MTElORUFSX0lOVEVSU0VDVElPTjpvZS5QT0lOVF9JTlRFUlNFQ1RJT04pOnMmJmE/KHRoaXMuaW50UHRbMF09aSx0aGlzLmludFB0WzFdPWUsIWkuZXF1YWxzKGUpfHxyfHxvP29lLkNPTExJTkVBUl9JTlRFUlNFQ1RJT046b2UuUE9JTlRfSU5URVJTRUNUSU9OKTpvZS5OT19JTlRFUlNFQ1RJT059LG5vcm1hbGl6ZVRvRW52Q2VudHJlOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9dC54PGUueD90Lng6ZS54LG89dC55PGUueT90Lnk6ZS55LGE9dC54PmUueD90Lng6ZS54LHU9dC55PmUueT90Lnk6ZS55LGw9bi54PGkueD9uLng6aS54LGg9bi55PGkueT9uLnk6aS55LGM9bi54PmkueD9uLng6aS54LGY9bi55PmkueT9uLnk6aS55LGc9cz5sP3M6bCxkPWM+YT9hOmMscD1vPmg/bzpoLHY9Zj51P3U6ZixtPShnK2QpLzIseT0ocCt2KS8yO3IueD1tLHIueT15LHQueC09ci54LHQueS09ci55LGUueC09ci54LGUueS09ci55LG4ueC09ci54LG4ueS09ci55LGkueC09ci54LGkueS09ci55fSxjb21wdXRlSW50ZXJzZWN0OmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHRoaXMuX2lzUHJvcGVyPSExLCFDLmludGVyc2VjdHModCxlLG4saSkpcmV0dXJuIG9lLk5PX0lOVEVSU0VDVElPTjt2YXIgcj1oZS5vcmllbnRhdGlvbkluZGV4KHQsZSxuKSxzPWhlLm9yaWVudGF0aW9uSW5kZXgodCxlLGkpO2lmKHI+MCYmcz4wfHwwPnImJjA+cylyZXR1cm4gb2UuTk9fSU5URVJTRUNUSU9OO3ZhciBvPWhlLm9yaWVudGF0aW9uSW5kZXgobixpLHQpLGE9aGUub3JpZW50YXRpb25JbmRleChuLGksZSk7aWYobz4wJiZhPjB8fDA+byYmMD5hKXJldHVybiBvZS5OT19JTlRFUlNFQ1RJT047dmFyIHU9MD09PXImJjA9PT1zJiYwPT09byYmMD09PWE7cmV0dXJuIHU/dGhpcy5jb21wdXRlQ29sbGluZWFySW50ZXJzZWN0aW9uKHQsZSxuLGkpOigwPT09cnx8MD09PXN8fDA9PT1vfHwwPT09YT8odGhpcy5faXNQcm9wZXI9ITEsdC5lcXVhbHMyRChuKXx8dC5lcXVhbHMyRChpKT90aGlzLmludFB0WzBdPXQ6ZS5lcXVhbHMyRChuKXx8ZS5lcXVhbHMyRChpKT90aGlzLmludFB0WzBdPWU6MD09PXI/dGhpcy5pbnRQdFswXT1uZXcgZyhuKTowPT09cz90aGlzLmludFB0WzBdPW5ldyBnKGkpOjA9PT1vP3RoaXMuaW50UHRbMF09bmV3IGcodCk6MD09PWEmJih0aGlzLmludFB0WzBdPW5ldyBnKGUpKSk6KHRoaXMuX2lzUHJvcGVyPSEwLHRoaXMuaW50UHRbMF09dGhpcy5pbnRlcnNlY3Rpb24odCxlLG4saSkpLG9lLlBPSU5UX0lOVEVSU0VDVElPTil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFlfX0pLGFlLm5lYXJlc3RFbmRwb2ludD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj10LHM9aGUuZGlzdGFuY2VQb2ludExpbmUodCxuLGkpLG89aGUuZGlzdGFuY2VQb2ludExpbmUoZSxuLGkpO3JldHVybiBzPm8mJihzPW8scj1lKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKG4sdCxlKSxzPm8mJihzPW8scj1uKSxvPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGksdCxlKSxzPm8mJihzPW8scj1pKSxyfSxlKHVlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdWV9fSksdWUub3JpZW50YXRpb25JbmRleD1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS54LXQueCxyPWUueS10Lnkscz1uLngtZS54LG89bi55LWUueTtyZXR1cm4gdWUuc2lnbk9mRGV0MngyKGkscixzLG8pfSx1ZS5zaWduT2ZEZXQyeDI9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bnVsbCxzPW51bGwsbz1udWxsLGE9MDtpZihyPTEsMD09PXR8fDA9PT1pKXJldHVybiAwPT09ZXx8MD09PW4/MDplPjA/bj4wPy1yOnI6bj4wP3I6LXI7aWYoMD09PWV8fDA9PT1uKXJldHVybiBpPjA/dD4wP3I6LXI6dD4wPy1yOnI7aWYoZT4wP2k+MD9pPj1lfHwocj0tcixzPXQsdD1uLG49cyxzPWUsZT1pLGk9cyk6LWk+PWU/KHI9LXIsbj0tbixpPS1pKToocz10LHQ9LW4sbj1zLHM9ZSxlPS1pLGk9cyk6aT4wP2k+PS1lPyhyPS1yLHQ9LXQsZT0tZSk6KHM9LXQsdD1uLG49cyxzPS1lLGU9aSxpPXMpOmU+PWk/KHQ9LXQsZT0tZSxuPS1uLGk9LWkpOihyPS1yLHM9LXQsdD0tbixuPXMscz0tZSxlPS1pLGk9cyksdD4wKXtpZighKG4+MCkpcmV0dXJuIHI7aWYoIShuPj10KSlyZXR1cm4gcn1lbHNle2lmKG4+MClyZXR1cm4tcjtpZighKHQ+PW4pKXJldHVybi1yO3I9LXIsdD0tdCxuPS1ufWZvcig7Oyl7aWYoYSs9MSxvPU1hdGguZmxvb3Iobi90KSxuLT1vKnQsaS09byplLDA+aSlyZXR1cm4tcjtpZihpPmUpcmV0dXJuIHI7aWYodD5uK24pe2lmKGkraT5lKXJldHVybiByfWVsc2V7aWYoZT5pK2kpcmV0dXJuLXI7bj10LW4saT1lLWkscj0tcn1pZigwPT09aSlyZXR1cm4gMD09PW4/MDotcjtpZigwPT09bilyZXR1cm4gcjtpZihvPU1hdGguZmxvb3IodC9uKSx0LT1vKm4sZS09byppLDA+ZSlyZXR1cm4gcjtpZihlPmkpcmV0dXJuLXI7aWYobj50K3Qpe2lmKGUrZT5pKXJldHVybi1yfWVsc2V7aWYoaT5lK2UpcmV0dXJuIHI7dD1uLXQsZT1pLWUscj0tcn1pZigwPT09ZSlyZXR1cm4gMD09PXQ/MDpyO2lmKDA9PT10KXJldHVybi1yfX0sZShsZS5wcm90b3R5cGUse2NvdW50U2VnbWVudDpmdW5jdGlvbih0LGUpe2lmKHQueDx0aGlzLnAueCYmZS54PHRoaXMucC54KXJldHVybiBudWxsO2lmKHRoaXMucC54PT09ZS54JiZ0aGlzLnAueT09PWUueSlyZXR1cm4gdGhpcy5pc1BvaW50T25TZWdtZW50PSEwLG51bGw7aWYodC55PT09dGhpcy5wLnkmJmUueT09PXRoaXMucC55KXt2YXIgbj10LngsaT1lLng7cmV0dXJuIG4+aSYmKG49ZS54LGk9dC54KSx0aGlzLnAueD49biYmdGhpcy5wLng8PWkmJih0aGlzLmlzUG9pbnRPblNlZ21lbnQ9ITApLG51bGx9aWYodC55PnRoaXMucC55JiZlLnk8PXRoaXMucC55fHxlLnk+dGhpcy5wLnkmJnQueTw9dGhpcy5wLnkpe3ZhciByPXQueC10aGlzLnAueCxzPXQueS10aGlzLnAueSxvPWUueC10aGlzLnAueCxhPWUueS10aGlzLnAueSx1PXVlLnNpZ25PZkRldDJ4MihyLHMsbyxhKTtpZigwPT09dSlyZXR1cm4gdGhpcy5pc1BvaW50T25TZWdtZW50PSEwLG51bGw7cz5hJiYodT0tdSksdT4wJiZ0aGlzLmNyb3NzaW5nQ291bnQrK319LGlzUG9pbnRJblBvbHlnb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRMb2NhdGlvbigpIT09TC5FWFRFUklPUn0sZ2V0TG9jYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1BvaW50T25TZWdtZW50P0wuQk9VTkRBUlk6dGhpcy5jcm9zc2luZ0NvdW50JTI9PT0xP0wuSU5URVJJT1I6TC5FWFRFUklPUn0saXNPblNlZ21lbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc1BvaW50T25TZWdtZW50fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBsZX19KSxsZS5sb2NhdGVQb2ludEluUmluZz1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmUihhcmd1bWVudHNbMV0sRCkpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgbGUodCksaT1uZXcgZyxyPW5ldyBnLHM9MTtzPGUuc2l6ZSgpO3MrKylpZihlLmdldENvb3JkaW5hdGUocyxpKSxlLmdldENvb3JkaW5hdGUocy0xLHIpLG4uY291bnRTZWdtZW50KGksciksbi5pc09uU2VnbWVudCgpKXJldHVybiBuLmdldExvY2F0aW9uKCk7cmV0dXJuIG4uZ2V0TG9jYXRpb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgbz1hcmd1bWVudHNbMF0sYT1hcmd1bWVudHNbMV0sbj1uZXcgbGUobykscz0xO3M8YS5sZW5ndGg7cysrKXt2YXIgaT1hW3NdLHI9YVtzLTFdO2lmKG4uY291bnRTZWdtZW50KGksciksbi5pc09uU2VnbWVudCgpKXJldHVybiBuLmdldExvY2F0aW9uKCl9cmV0dXJuIG4uZ2V0TG9jYXRpb24oKX19LGUoaGUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBoZX19KSxoZS5vcmllbnRhdGlvbkluZGV4PWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gTS5vcmllbnRhdGlvbkluZGV4KHQsZSxuKX0saGUuc2lnbmVkQXJlYT1mdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0Lmxlbmd0aDwzKXJldHVybiAwO2Zvcih2YXIgZT0wLG49dFswXS54LGk9MTtpPHQubGVuZ3RoLTE7aSsrKXt2YXIgcj10W2ldLngtbixzPXRbaSsxXS55LG89dFtpLTFdLnk7ZSs9ciooby1zKX1yZXR1cm4gZS8yfWlmKFIoYXJndW1lbnRzWzBdLEQpKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hLnNpemUoKTtpZigzPnUpcmV0dXJuIDA7dmFyIGw9bmV3IGcsaD1uZXcgZyxjPW5ldyBnO2EuZ2V0Q29vcmRpbmF0ZSgwLGgpLGEuZ2V0Q29vcmRpbmF0ZSgxLGMpO3ZhciBuPWgueDtjLngtPW47Zm9yKHZhciBlPTAsaT0xO3UtMT5pO2krKylsLnk9aC55LGgueD1jLngsaC55PWMueSxhLmdldENvb3JkaW5hdGUoaSsxLGMpLGMueC09bixlKz1oLngqKGwueS1jLnkpO3JldHVybiBlLzJ9fSxoZS5kaXN0YW5jZUxpbmVMaW5lPWZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQuZXF1YWxzKGUpKXJldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZSh0LG4saSk7aWYobi5lcXVhbHMoaSkpcmV0dXJuIGhlLmRpc3RhbmNlUG9pbnRMaW5lKGksdCxlKTt2YXIgcj0hMTtpZihDLmludGVyc2VjdHModCxlLG4saSkpe3ZhciBzPShlLngtdC54KSooaS55LW4ueSktKGUueS10LnkpKihpLngtbi54KTtpZigwPT09cylyPSEwO2Vsc2V7dmFyIG89KHQueS1uLnkpKihpLngtbi54KS0odC54LW4ueCkqKGkueS1uLnkpLGE9KHQueS1uLnkpKihlLngtdC54KS0odC54LW4ueCkqKGUueS10LnkpLHU9YS9zLGw9by9zOygwPmx8fGw+MXx8MD51fHx1PjEpJiYocj0hMCl9fWVsc2Ugcj0hMDtyZXR1cm4gcj9ULm1pbihoZS5kaXN0YW5jZVBvaW50TGluZSh0LG4saSksaGUuZGlzdGFuY2VQb2ludExpbmUoZSxuLGkpLGhlLmRpc3RhbmNlUG9pbnRMaW5lKG4sdCxlKSxoZS5kaXN0YW5jZVBvaW50TGluZShpLHQsZSkpOjB9LGhlLmlzUG9pbnRJblJpbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gaGUubG9jYXRlUG9pbnRJblJpbmcodCxlKSE9PUwuRVhURVJJT1J9LGhlLmNvbXB1dGVMZW5ndGg9ZnVuY3Rpb24odCl7dmFyIGU9dC5zaXplKCk7aWYoMT49ZSlyZXR1cm4gMDt2YXIgbj0wLGk9bmV3IGc7dC5nZXRDb29yZGluYXRlKDAsaSk7Zm9yKHZhciByPWkueCxzPWkueSxvPTE7ZT5vO28rKyl7dC5nZXRDb29yZGluYXRlKG8saSk7dmFyIGE9aS54LHU9aS55LGw9YS1yLGg9dS1zO24rPU1hdGguc3FydChsKmwraCpoKSxyPWEscz11fXJldHVybiBufSxoZS5pc0NDVz1mdW5jdGlvbih0KXt2YXIgZT10Lmxlbmd0aC0xO2lmKDM+ZSl0aHJvdyBuZXcgaShcIlJpbmcgaGFzIGZld2VyIHRoYW4gNCBwb2ludHMsIHNvIG9yaWVudGF0aW9uIGNhbm5vdCBiZSBkZXRlcm1pbmVkXCIpO2Zvcih2YXIgbj10WzBdLHI9MCxzPTE7ZT49cztzKyspe3ZhciBvPXRbc107by55Pm4ueSYmKG49byxyPXMpfXZhciBhPXI7ZG8gYS09MSwwPmEmJihhPWUpO3doaWxlKHRbYV0uZXF1YWxzMkQobikmJmEhPT1yKTt2YXIgdT1yO2RvIHU9KHUrMSklZTt3aGlsZSh0W3VdLmVxdWFsczJEKG4pJiZ1IT09cik7dmFyIGw9dFthXSxoPXRbdV07aWYobC5lcXVhbHMyRChuKXx8aC5lcXVhbHMyRChuKXx8bC5lcXVhbHMyRChoKSlyZXR1cm4hMTt2YXIgYz1oZS5jb21wdXRlT3JpZW50YXRpb24obCxuLGgpLGY9ITE7cmV0dXJuIGY9MD09PWM/bC54PmgueDpjPjB9LGhlLmxvY2F0ZVBvaW50SW5SaW5nPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGxlLmxvY2F0ZVBvaW50SW5SaW5nKHQsZSl9LGhlLmRpc3RhbmNlUG9pbnRMaW5lUGVycGVuZGljdWxhcj1mdW5jdGlvbih0LGUsbil7dmFyIGk9KG4ueC1lLngpKihuLngtZS54KSsobi55LWUueSkqKG4ueS1lLnkpLHI9KChlLnktdC55KSoobi54LWUueCktKGUueC10LngpKihuLnktZS55KSkvaTtyZXR1cm4gTWF0aC5hYnMocikqTWF0aC5zcXJ0KGkpfSxoZS5jb21wdXRlT3JpZW50YXRpb249ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoZS5vcmllbnRhdGlvbkluZGV4KHQsZSxuKX0saGUuZGlzdGFuY2VQb2ludExpbmU9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKDA9PT1lLmxlbmd0aCl0aHJvdyBuZXcgaShcIkxpbmUgYXJyYXkgbXVzdCBjb250YWluIGF0IGxlYXN0IG9uZSB2ZXJ0ZXhcIik7Zm9yKHZhciBuPXQuZGlzdGFuY2UoZVswXSkscj0wO3I8ZS5sZW5ndGgtMTtyKyspe3ZhciBzPWhlLmRpc3RhbmNlUG9pbnRMaW5lKHQsZVtyXSxlW3IrMV0pO24+cyYmKG49cyl9cmV0dXJuIG59aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXTtpZihhLng9PT11LngmJmEueT09PXUueSlyZXR1cm4gby5kaXN0YW5jZShhKTt2YXIgbD0odS54LWEueCkqKHUueC1hLngpKyh1LnktYS55KSoodS55LWEueSksaD0oKG8ueC1hLngpKih1LngtYS54KSsoby55LWEueSkqKHUueS1hLnkpKS9sO2lmKDA+PWgpcmV0dXJuIG8uZGlzdGFuY2UoYSk7aWYoaD49MSlyZXR1cm4gby5kaXN0YW5jZSh1KTt2YXIgYz0oKGEueS1vLnkpKih1LngtYS54KS0oYS54LW8ueCkqKHUueS1hLnkpKS9sO3JldHVybiBNYXRoLmFicyhjKSpNYXRoLnNxcnQobCl9fSxoZS5pc09uTGluZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgYWUsaT0xO2k8ZS5sZW5ndGg7aSsrKXt2YXIgcj1lW2ktMV0scz1lW2ldO2lmKG4uY29tcHV0ZUludGVyc2VjdGlvbih0LHIscyksbi5oYXNJbnRlcnNlY3Rpb24oKSlyZXR1cm4hMH1yZXR1cm4hMX0saGUuQ0xPQ0tXSVNFPS0xLGhlLlJJR0hUPWhlLkNMT0NLV0lTRSxoZS5DT1VOVEVSQ0xPQ0tXSVNFPTEsaGUuTEVGVD1oZS5DT1VOVEVSQ0xPQ0tXSVNFLGhlLkNPTExJTkVBUj0wLGhlLlNUUkFJR0hUPWhlLkNPTExJTkVBUixlKGNlLnByb3RvdHlwZSx7bWluWDpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLngsdGhpcy5wMS54KX0sb3JpZW50YXRpb25JbmRleDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgY2Upe3ZhciB0PWFyZ3VtZW50c1swXSxlPWhlLm9yaWVudGF0aW9uSW5kZXgodGhpcy5wMCx0aGlzLnAxLHQucDApLG49aGUub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLHRoaXMucDEsdC5wMSk7cmV0dXJuIGU+PTAmJm4+PTA/TWF0aC5tYXgoZSxuKTowPj1lJiYwPj1uP01hdGgubWF4KGUsbik6MH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBpPWFyZ3VtZW50c1swXTtyZXR1cm4gaGUub3JpZW50YXRpb25JbmRleCh0aGlzLnAwLHRoaXMucDEsaSl9fSx0b0dlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0LmNyZWF0ZUxpbmVTdHJpbmcoW3RoaXMucDAsdGhpcy5wMV0pfSxpc1ZlcnRpY2FsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDAueD09PXRoaXMucDEueH0sZXF1YWxzOmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIGNlKSlyZXR1cm4hMTt2YXIgZT10O3JldHVybiB0aGlzLnAwLmVxdWFscyhlLnAwKSYmdGhpcy5wMS5lcXVhbHMoZS5wMSl9LGludGVyc2VjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT1uZXcgYWU7cmV0dXJuIGUuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKSxlLmhhc0ludGVyc2VjdGlvbigpP2UuZ2V0SW50ZXJzZWN0aW9uKDApOm51bGx9LHByb2plY3Q6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0LmVxdWFscyh0aGlzLnAwKXx8dC5lcXVhbHModGhpcy5wMSkpcmV0dXJuIG5ldyBnKHQpO3ZhciBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KSxuPW5ldyBnO3JldHVybiBuLng9dGhpcy5wMC54K2UqKHRoaXMucDEueC10aGlzLnAwLngpLG4ueT10aGlzLnAwLnkrZSoodGhpcy5wMS55LXRoaXMucDAueSksbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgaT1hcmd1bWVudHNbMF0scj10aGlzLnByb2plY3Rpb25GYWN0b3IoaS5wMCkscz10aGlzLnByb2plY3Rpb25GYWN0b3IoaS5wMSk7aWYocj49MSYmcz49MSlyZXR1cm4gbnVsbDtpZigwPj1yJiYwPj1zKXJldHVybiBudWxsO3ZhciBvPXRoaXMucHJvamVjdChpLnAwKTswPnImJihvPXRoaXMucDApLHI+MSYmKG89dGhpcy5wMSk7dmFyIGE9dGhpcy5wcm9qZWN0KGkucDEpO3JldHVybiAwPnMmJihhPXRoaXMucDApLHM+MSYmKGE9dGhpcy5wMSksbmV3IGNlKG8sYSl9fSxub3JtYWxpemU6ZnVuY3Rpb24oKXt0aGlzLnAxLmNvbXBhcmVUbyh0aGlzLnAwKTwwJiZ0aGlzLnJldmVyc2UoKX0sYW5nbGU6ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5hdGFuMih0aGlzLnAxLnktdGhpcy5wMC55LHRoaXMucDEueC10aGlzLnAwLngpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dD90aGlzLnAwOnRoaXMucDF9LGRpc3RhbmNlUGVycGVuZGljdWxhcjpmdW5jdGlvbih0KXtyZXR1cm4gaGUuZGlzdGFuY2VQb2ludExpbmVQZXJwZW5kaWN1bGFyKHQsdGhpcy5wMCx0aGlzLnAxKX0sbWluWTpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1pbih0aGlzLnAwLnksdGhpcy5wMS55KX0sbWlkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gY2UubWlkUG9pbnQodGhpcy5wMCx0aGlzLnAxKX0scHJvamVjdGlvbkZhY3RvcjpmdW5jdGlvbih0KXtpZih0LmVxdWFscyh0aGlzLnAwKSlyZXR1cm4gMDtpZih0LmVxdWFscyh0aGlzLnAxKSlyZXR1cm4gMTt2YXIgZT10aGlzLnAxLngtdGhpcy5wMC54LG49dGhpcy5wMS55LXRoaXMucDAueSxpPWUqZStuKm47aWYoMD49aSlyZXR1cm4gci5OYU47dmFyIHM9KCh0LngtdGhpcy5wMC54KSplKyh0LnktdGhpcy5wMC55KSpuKS9pO3JldHVybiBzfSxjbG9zZXN0UG9pbnRzOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuaW50ZXJzZWN0aW9uKHQpO2lmKG51bGwhPT1lKXJldHVybltlLGVdO3ZhciBuPW5ldyBBcnJheSgyKS5maWxsKG51bGwpLGk9ci5NQVhfVkFMVUUscz1udWxsLG89dGhpcy5jbG9zZXN0UG9pbnQodC5wMCk7aT1vLmRpc3RhbmNlKHQucDApLG5bMF09byxuWzFdPXQucDA7dmFyIGE9dGhpcy5jbG9zZXN0UG9pbnQodC5wMSk7cz1hLmRpc3RhbmNlKHQucDEpLGk+cyYmKGk9cyxuWzBdPWEsblsxXT10LnAxKTt2YXIgdT10LmNsb3Nlc3RQb2ludCh0aGlzLnAwKTtzPXUuZGlzdGFuY2UodGhpcy5wMCksaT5zJiYoaT1zLG5bMF09dGhpcy5wMCxuWzFdPXUpO3ZhciBsPXQuY2xvc2VzdFBvaW50KHRoaXMucDEpO3JldHVybiBzPWwuZGlzdGFuY2UodGhpcy5wMSksaT5zJiYoaT1zLG5bMF09dGhpcy5wMSxuWzFdPWwpLG59LGNsb3Nlc3RQb2ludDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnByb2plY3Rpb25GYWN0b3IodCk7aWYoZT4wJiYxPmUpcmV0dXJuIHRoaXMucHJvamVjdCh0KTt2YXIgbj10aGlzLnAwLmRpc3RhbmNlKHQpLGk9dGhpcy5wMS5kaXN0YW5jZSh0KTtyZXR1cm4gaT5uP3RoaXMucDA6dGhpcy5wMX0sbWF4WDpmdW5jdGlvbigpe3JldHVybiBNYXRoLm1heCh0aGlzLnAwLngsdGhpcy5wMS54KX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucDAuZGlzdGFuY2UodGhpcy5wMSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49dGhpcy5wMC5jb21wYXJlVG8oZS5wMCk7cmV0dXJuIDAhPT1uP246dGhpcy5wMS5jb21wYXJlVG8oZS5wMSl9LHJldmVyc2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnAwO3RoaXMucDA9dGhpcy5wMSx0aGlzLnAxPXR9LGVxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucDAuZXF1YWxzKHQucDApJiZ0aGlzLnAxLmVxdWFscyh0LnAxKXx8dGhpcy5wMC5lcXVhbHModC5wMSkmJnRoaXMucDEuZXF1YWxzKHQucDApfSxsaW5lSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe3RyeXt2YXIgZT1GLmludGVyc2VjdGlvbih0aGlzLnAwLHRoaXMucDEsdC5wMCx0LnAxKTtyZXR1cm4gZX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiB3KSl0aHJvdyB0fWZpbmFsbHl7fXJldHVybiBudWxsfSxtYXhZOmZ1bmN0aW9uKCl7cmV0dXJuIE1hdGgubWF4KHRoaXMucDAueSx0aGlzLnAxLnkpfSxwb2ludEFsb25nT2Zmc2V0OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLGk9dGhpcy5wMC55K3QqKHRoaXMucDEueS10aGlzLnAwLnkpLHI9dGhpcy5wMS54LXRoaXMucDAueCxzPXRoaXMucDEueS10aGlzLnAwLnksbz1NYXRoLnNxcnQocipyK3MqcyksYT0wLHU9MDtpZigwIT09ZSl7aWYoMD49byl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiQ2Fubm90IGNvbXB1dGUgb2Zmc2V0IGZyb20gemVyby1sZW5ndGggbGluZSBzZWdtZW50XCIpO2E9ZSpyL28sdT1lKnMvb312YXIgbD1uLXUsaD1pK2EsYz1uZXcgZyhsLGgpO3JldHVybiBjfSxzZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5zZXRDb29yZGluYXRlcyh0LnAwLHQucDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLnAwLng9ZS54LHRoaXMucDAueT1lLnksdGhpcy5wMS54PW4ueCx0aGlzLnAxLnk9bi55fX0sc2VnbWVudEZyYWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHJvamVjdGlvbkZhY3Rvcih0KTtyZXR1cm4gMD5lP2U9MDooZT4xfHxyLmlzTmFOKGUpKSYmKGU9MSksZX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkxJTkVTVFJJTkcoIFwiK3RoaXMucDAueCtcIiBcIit0aGlzLnAwLnkrXCIsIFwiK3RoaXMucDEueCtcIiBcIit0aGlzLnAxLnkrXCIpXCJ9LGlzSG9yaXpvbnRhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwLnk9PT10aGlzLnAxLnl9LGRpc3RhbmNlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBjZSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBoZS5kaXN0YW5jZUxpbmVMaW5lKHRoaXMucDAsdGhpcy5wMSx0LnAwLHQucDEpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBoZS5kaXN0YW5jZVBvaW50TGluZShlLHRoaXMucDAsdGhpcy5wMSl9fSxwb2ludEFsb25nOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnO3JldHVybiBlLng9dGhpcy5wMC54K3QqKHRoaXMucDEueC10aGlzLnAwLngpLGUueT10aGlzLnAwLnkrdCoodGhpcy5wMS55LXRoaXMucDAueSksZX0saGFzaENvZGU6ZnVuY3Rpb24oKXt2YXIgdD1qYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC54KTt0Xj0zMSpqYXZhLmxhbmcuRG91YmxlLmRvdWJsZVRvTG9uZ0JpdHModGhpcy5wMC55KTt2YXIgZT1NYXRoLnRydW5jKHQpXk1hdGgudHJ1bmModD4+MzIpLG49amF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueCk7bl49MzEqamF2YS5sYW5nLkRvdWJsZS5kb3VibGVUb0xvbmdCaXRzKHRoaXMucDEueSk7dmFyIGk9TWF0aC50cnVuYyhuKV5NYXRoLnRydW5jKG4+PjMyKTtyZXR1cm4gZV5pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBjZX19KSxjZS5taWRQb2ludD1mdW5jdGlvbih0LGUpe3JldHVybiBuZXcgZygodC54K2UueCkvMiwodC55K2UueSkvMil9LGNlLnNlcmlhbFZlcnNpb25VSUQ9MHgyZDIxNzIxMzVmNDExYzAwLGUoZmUucHJvdG90eXBlLHtpc0ludGVyc2VjdHM6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pc0Rpc2pvaW50KCl9LGlzQ292ZXJzOmZ1bmN0aW9uKCl7dmFyIHQ9ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKTtyZXR1cm4gdCYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0saXNDb3ZlcmVkQnk6ZnVuY3Rpb24oKXt2YXIgdD1mZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl0pfHxmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV0pO3JldHVybiB0JiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFfSxzZXQ6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MDtlPHQubGVuZ3RoO2UrKyl7dmFyIG49TWF0aC50cnVuYyhlLzMpLGk9ZSUzO3RoaXMubWF0cml4W25dW2ldPWx0LnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTt0aGlzLm1hdHJpeFtyXVtzXT1vfX0saXNDb250YWluczpmdW5jdGlvbigpe3JldHVybiBmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXT09PWx0LkZBTFNFfSxzZXRBdExlYXN0OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPTA7ZTx0Lmxlbmd0aDtlKyspe3ZhciBuPU1hdGgudHJ1bmMoZS8zKSxpPWUlMzt0aGlzLnNldEF0TGVhc3QobixpLGx0LnRvRGltZW5zaW9uVmFsdWUodC5jaGFyQXQoZSkpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07dGhpcy5tYXRyaXhbcl1bc108byYmKHRoaXMubWF0cml4W3JdW3NdPW8pfX0sc2V0QXRMZWFzdElmVmFsaWQ6ZnVuY3Rpb24odCxlLG4pe3Q+PTAmJmU+PTAmJnRoaXMuc2V0QXRMZWFzdCh0LGUsbil9LGlzV2l0aGluOmZ1bmN0aW9uKCl7cmV0dXJuIGZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJnRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdPT09bHQuRkFMU0UmJnRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuRVhURVJJT1JdPT09bHQuRkFMU0V9LGlzVG91Y2hlczpmdW5jdGlvbih0LGUpe3JldHVybiB0PmU/dGhpcy5pc1RvdWNoZXMoZSx0KTp0PT09bHQuQSYmZT09PWx0LkF8fHQ9PT1sdC5MJiZlPT09bHQuTHx8dD09PWx0LkwmJmU9PT1sdC5BfHx0PT09bHQuUCYmZT09PWx0LkF8fHQ9PT1sdC5QJiZlPT09bHQuTD90aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiYoZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuQk9VTkRBUlldKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuSU5URVJJT1JdKXx8ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuQk9VTkRBUlldW0wuQk9VTkRBUlldKSk6ITF9LGlzT3ZlcmxhcHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdD09PWx0LlAmJmU9PT1sdC5QfHx0PT09bHQuQSYmZT09PWx0LkE/ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuRVhURVJJT1JdW0wuSU5URVJJT1JdKTp0PT09bHQuTCYmZT09PWx0Lkw/MT09PXRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5FWFRFUklPUl0pJiZmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5FWFRFUklPUl1bTC5JTlRFUklPUl0pOiExfSxpc0VxdWFsczpmdW5jdGlvbih0LGUpe3JldHVybiB0IT09ZT8hMTpmZS5pc1RydWUodGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl0pJiZ0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkJPVU5EQVJZXVtMLkVYVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXT09PWx0LkZBTFNFJiZ0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLkJPVU5EQVJZXT09PWx0LkZBTFNFfSx0b1N0cmluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgUChcIjEyMzQ1Njc4OVwiKSxlPTA7Mz5lO2UrKylmb3IodmFyIG49MDszPm47bisrKXQuc2V0Q2hhckF0KDMqZStuLGx0LnRvRGltZW5zaW9uU3ltYm9sKHRoaXMubWF0cml4W2VdW25dKSk7cmV0dXJuIHQudG9TdHJpbmcoKX0sc2V0QWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKyl0aGlzLm1hdHJpeFtlXVtuXT10fSxnZXQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5tYXRyaXhbdF1bZV19LHRyYW5zcG9zZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWF0cml4WzFdWzBdO3JldHVybiB0aGlzLm1hdHJpeFsxXVswXT10aGlzLm1hdHJpeFswXVsxXSx0aGlzLm1hdHJpeFswXVsxXT10LHQ9dGhpcy5tYXRyaXhbMl1bMF0sdGhpcy5tYXRyaXhbMl1bMF09dGhpcy5tYXRyaXhbMF1bMl0sdGhpcy5tYXRyaXhbMF1bMl09dCx0PXRoaXMubWF0cml4WzJdWzFdLHRoaXMubWF0cml4WzJdWzFdPXRoaXMubWF0cml4WzFdWzJdLHRoaXMubWF0cml4WzFdWzJdPXQsdGhpc30sbWF0Y2hlczpmdW5jdGlvbih0KXtpZig5IT09dC5sZW5ndGgpdGhyb3cgbmV3IGkoXCJTaG91bGQgYmUgbGVuZ3RoIDk6IFwiK3QpO2Zvcih2YXIgZT0wOzM+ZTtlKyspZm9yKHZhciBuPTA7Mz5uO24rKylpZighZmUubWF0Y2hlcyh0aGlzLm1hdHJpeFtlXVtuXSx0LmNoYXJBdCgzKmUrbikpKXJldHVybiExO3JldHVybiEwfSxhZGQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7Mz5lO2UrKylmb3IodmFyIG49MDszPm47bisrKXRoaXMuc2V0QXRMZWFzdChlLG4sdC5nZXQoZSxuKSl9LGlzRGlzam9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5JTlRFUklPUl1bTC5CT1VOREFSWV09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5JTlRFUklPUl09PT1sdC5GQUxTRSYmdGhpcy5tYXRyaXhbTC5CT1VOREFSWV1bTC5CT1VOREFSWV09PT1sdC5GQUxTRX0saXNDcm9zc2VzOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1sdC5QJiZlPT09bHQuTHx8dD09PWx0LlAmJmU9PT1sdC5BfHx0PT09bHQuTCYmZT09PWx0LkE/ZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuSU5URVJJT1JdKSYmZmUuaXNUcnVlKHRoaXMubWF0cml4W0wuSU5URVJJT1JdW0wuRVhURVJJT1JdKTp0PT09bHQuTCYmZT09PWx0LlB8fHQ9PT1sdC5BJiZlPT09bHQuUHx8dD09PWx0LkEmJmU9PT1sdC5MP2ZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXSkmJmZlLmlzVHJ1ZSh0aGlzLm1hdHJpeFtMLkVYVEVSSU9SXVtMLklOVEVSSU9SXSk6dD09PWx0LkwmJmU9PT1sdC5MPzA9PT10aGlzLm1hdHJpeFtMLklOVEVSSU9SXVtMLklOVEVSSU9SXTohMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZlfX0pLGZlLm1hdGNoZXM9ZnVuY3Rpb24oKXtpZihOdW1iZXIuaXNJbnRlZ2VyKGFyZ3VtZW50c1swXSkmJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gZT09PWx0LlNZTV9ET05UQ0FSRT8hMDplPT09bHQuU1lNX1RSVUUmJih0Pj0wfHx0PT09bHQuVFJVRSk/ITA6ZT09PWx0LlNZTV9GQUxTRSYmdD09PWx0LkZBTFNFPyEwOmU9PT1sdC5TWU1fUCYmdD09PWx0LlA/ITA6ZT09PWx0LlNZTV9MJiZ0PT09bHQuTD8hMDplPT09bHQuU1lNX0EmJnQ9PT1sdC5BfWlmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPW5ldyBmZShuKTtyZXR1cm4gci5tYXRjaGVzKGkpfX0sZmUuaXNUcnVlPWZ1bmN0aW9uKHQpe3JldHVybiB0Pj0wfHx0PT09bHQuVFJVRX07dmFyIGxvPU9iamVjdC5mcmVlemUoe0Nvb3JkaW5hdGU6ZyxDb29yZGluYXRlTGlzdDpOLEVudmVsb3BlOkMsTGluZVNlZ21lbnQ6Y2UsR2VvbWV0cnlGYWN0b3J5OmllLEdlb21ldHJ5OkIsUG9pbnQ6THQsTGluZVN0cmluZzpTdCxMaW5lYXJSaW5nOmJ0LFBvbHlnb246VHQsR2VvbWV0cnlDb2xsZWN0aW9uOmZ0LE11bHRpUG9pbnQ6UHQsTXVsdGlMaW5lU3RyaW5nOmd0LE11bHRpUG9seWdvbjpPdCxEaW1lbnNpb246bHQsSW50ZXJzZWN0aW9uTWF0cml4OmZlfSk7ZShnZS5wcm90b3R5cGUse2FkZFBvaW50OmZ1bmN0aW9uKHQpe3RoaXMucHRDb3VudCs9MSx0aGlzLnB0Q2VudFN1bS54Kz10LngsdGhpcy5wdENlbnRTdW0ueSs9dC55fSxzZXRCYXNlUG9pbnQ6ZnVuY3Rpb24odCl7bnVsbD09PXRoaXMuYXJlYUJhc2VQdCYmKHRoaXMuYXJlYUJhc2VQdD10KX0sYWRkTGluZVNlZ21lbnRzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wLG49MDtuPHQubGVuZ3RoLTE7bisrKXt2YXIgaT10W25dLmRpc3RhbmNlKHRbbisxXSk7aWYoMCE9PWkpe2UrPWk7dmFyIHI9KHRbbl0ueCt0W24rMV0ueCkvMjt0aGlzLmxpbmVDZW50U3VtLngrPWkqcjt2YXIgcz0odFtuXS55K3RbbisxXS55KS8yO3RoaXMubGluZUNlbnRTdW0ueSs9aSpzfX10aGlzLnRvdGFsTGVuZ3RoKz1lLDA9PT1lJiZ0Lmxlbmd0aD4wJiZ0aGlzLmFkZFBvaW50KHRbMF0pfSxhZGRIb2xlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1oZS5pc0NDVyh0KSxuPTA7bjx0Lmxlbmd0aC0xO24rKyl0aGlzLmFkZFRyaWFuZ2xlKHRoaXMuYXJlYUJhc2VQdCx0W25dLHRbbisxXSxlKTt0aGlzLmFkZExpbmVTZWdtZW50cyh0KX0sZ2V0Q2VudHJvaWQ6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZztpZihNYXRoLmFicyh0aGlzLmFyZWFzdW0yKT4wKXQueD10aGlzLmNnMy54LzMvdGhpcy5hcmVhc3VtMix0Lnk9dGhpcy5jZzMueS8zL3RoaXMuYXJlYXN1bTI7ZWxzZSBpZih0aGlzLnRvdGFsTGVuZ3RoPjApdC54PXRoaXMubGluZUNlbnRTdW0ueC90aGlzLnRvdGFsTGVuZ3RoLHQueT10aGlzLmxpbmVDZW50U3VtLnkvdGhpcy50b3RhbExlbmd0aDtlbHNle2lmKCEodGhpcy5wdENvdW50PjApKXJldHVybiBudWxsO3QueD10aGlzLnB0Q2VudFN1bS54L3RoaXMucHRDb3VudCx0Lnk9dGhpcy5wdENlbnRTdW0ueS90aGlzLnB0Q291bnR9cmV0dXJuIHR9LGFkZFNoZWxsOmZ1bmN0aW9uKHQpe3QubGVuZ3RoPjAmJnRoaXMuc2V0QmFzZVBvaW50KHRbMF0pO2Zvcih2YXIgZT0haGUuaXNDQ1codCksbj0wO248dC5sZW5ndGgtMTtuKyspdGhpcy5hZGRUcmlhbmdsZSh0aGlzLmFyZWFCYXNlUHQsdFtuXSx0W24rMV0sZSk7dGhpcy5hZGRMaW5lU2VnbWVudHModCl9LGFkZFRyaWFuZ2xlOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWk/MTotMTtnZS5jZW50cm9pZDModCxlLG4sdGhpcy50cmlhbmdsZUNlbnQzKTt2YXIgcz1nZS5hcmVhMih0LGUsbik7dGhpcy5jZzMueCs9cipzKnRoaXMudHJpYW5nbGVDZW50My54LHRoaXMuY2czLnkrPXIqcyp0aGlzLnRyaWFuZ2xlQ2VudDMueSx0aGlzLmFyZWFzdW0yKz1yKnN9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLmFkZFNoZWxsKHQuZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSk7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKyl0aGlzLmFkZEhvbGUodC5nZXRJbnRlcmlvclJpbmdOKGUpLmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgbj1hcmd1bWVudHNbMF07aWYobi5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYobiBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkUG9pbnQobi5nZXRDb29yZGluYXRlKCkpO2Vsc2UgaWYobiBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkTGluZVNlZ21lbnRzKG4uZ2V0Q29vcmRpbmF0ZXMoKSk7ZWxzZSBpZihuIGluc3RhbmNlb2YgVHQpe3ZhciBpPW47dGhpcy5hZGQoaSl9ZWxzZSBpZihuIGluc3RhbmNlb2YgZnQpZm9yKHZhciByPW4sZT0wO2U8ci5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXRoaXMuYWRkKHIuZ2V0R2VvbWV0cnlOKGUpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGdlfX0pLGdlLmFyZWEyPWZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4oZS54LXQueCkqKG4ueS10LnkpLShuLngtdC54KSooZS55LXQueSl9LGdlLmNlbnRyb2lkMz1mdW5jdGlvbih0LGUsbixpKXtyZXR1cm4gaS54PXQueCtlLngrbi54LGkueT10LnkrZS55K24ueSxudWxsfSxnZS5nZXRDZW50cm9pZD1mdW5jdGlvbih0KXt2YXIgZT1uZXcgZ2UodCk7cmV0dXJuIGUuZ2V0Q2VudHJvaWQoKX0sZGUucHJvdG90eXBlPW5ldyBFcnJvcixkZS5wcm90b3R5cGUubmFtZT1cIkVtcHR5U3RhY2tFeGNlcHRpb25cIixwZS5wcm90b3R5cGU9bmV3IHkscGUucHJvdG90eXBlLmFkZD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8ucHVzaCh0KSwhMH0scGUucHJvdG90eXBlLmdldD1mdW5jdGlvbih0KXtpZigwPnR8fHQ+PXRoaXMuc2l6ZSgpKXRocm93IG5ldyBJbmRleE91dE9mQm91bmRzRXhjZXB0aW9uO3JldHVybiB0aGlzLmFycmF5X1t0XX0scGUucHJvdG90eXBlLnB1c2g9ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuYXJyYXlfLnB1c2godCksdH0scGUucHJvdG90eXBlLnBvcD1mdW5jdGlvbih0KXtpZigwPT09dGhpcy5hcnJheV8ubGVuZ3RoKXRocm93IG5ldyBkZTtyZXR1cm4gdGhpcy5hcnJheV8ucG9wKCl9LHBlLnByb3RvdHlwZS5wZWVrPWZ1bmN0aW9uKCl7aWYoMD09PXRoaXMuYXJyYXlfLmxlbmd0aCl0aHJvdyBuZXcgZGU7cmV0dXJuIHRoaXMuYXJyYXlfW3RoaXMuYXJyYXlfLmxlbmd0aC0xXX0scGUucHJvdG90eXBlLmVtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LHBlLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW1wdHkoKX0scGUucHJvdG90eXBlLnNlYXJjaD1mdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5hcnJheV8uaW5kZXhPZih0KX0scGUucHJvdG90eXBlLnNpemU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5hcnJheV8ubGVuZ3RofSxwZS5wcm90b3R5cGUudG9BcnJheT1mdW5jdGlvbigpe2Zvcih2YXIgdD1bXSxlPTAsbj10aGlzLmFycmF5Xy5sZW5ndGg7bj5lO2UrKyl0LnB1c2godGhpcy5hcnJheV9bZV0pO3JldHVybiB0fSxlKHZlLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3RoaXMudHJlZVNldC5jb250YWlucyh0KXx8KHRoaXMubGlzdC5hZGQodCksdGhpcy50cmVlU2V0LmFkZCh0KSl9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEFycmF5KHRoaXMubGlzdC5zaXplKCkpLmZpbGwobnVsbCk7cmV0dXJuIHRoaXMubGlzdC50b0FycmF5KHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt6XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdmV9fSksdmUuZmlsdGVyQ29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyB2ZSxuPTA7bjx0Lmxlbmd0aDtuKyspZS5maWx0ZXIodFtuXSk7cmV0dXJuIGUuZ2V0Q29vcmRpbmF0ZXMoKX0sZShtZS5wcm90b3R5cGUse3ByZVNvcnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj0xO248dC5sZW5ndGg7bisrKSh0W25dLnk8dFswXS55fHx0W25dLnk9PT10WzBdLnkmJnRbbl0ueDx0WzBdLngpJiYoZT10WzBdLHRbMF09dFtuXSx0W25dPWUpO3JldHVybiB1dC5zb3J0KHQsMSx0Lmxlbmd0aCxuZXcgeWUodFswXSkpLHR9LGNvbXB1dGVPY3RSaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29tcHV0ZU9jdFB0cyh0KSxuPW5ldyBOO3JldHVybiBuLmFkZChlLCExKSxuLnNpemUoKTwzP251bGw6KG4uY2xvc2VSaW5nKCksbi50b0Nvb3JkaW5hdGVBcnJheSgpKX0sbGluZU9yUG9seWdvbjpmdW5jdGlvbih0KXtpZih0PXRoaXMuY2xlYW5SaW5nKHQpLDM9PT10Lmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKFt0WzBdLHRbMV1dKTt2YXIgZT10aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCk7cmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlUG9seWdvbihlLG51bGwpfSxjbGVhblJpbmc6ZnVuY3Rpb24odCl7Zi5lcXVhbHModFswXSx0W3QubGVuZ3RoLTFdKTtmb3IodmFyIGU9bmV3IEksbj1udWxsLGk9MDtpPD10Lmxlbmd0aC0yO2krKyl7dmFyIHI9dFtpXSxzPXRbaSsxXTtyLmVxdWFscyhzKXx8bnVsbCE9PW4mJnRoaXMuaXNCZXR3ZWVuKG4scixzKXx8KGUuYWRkKHIpLG49cil9ZS5hZGQodFt0Lmxlbmd0aC0xXSk7dmFyIG89bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpO3JldHVybiBlLnRvQXJyYXkobyl9LGlzQmV0d2VlbjpmdW5jdGlvbih0LGUsbil7aWYoMCE9PWhlLmNvbXB1dGVPcmllbnRhdGlvbih0LGUsbikpcmV0dXJuITE7aWYodC54IT09bi54KXtpZih0Lng8PWUueCYmZS54PD1uLngpcmV0dXJuITA7aWYobi54PD1lLngmJmUueDw9dC54KXJldHVybiEwfWlmKHQueSE9PW4ueSl7aWYodC55PD1lLnkmJmUueTw9bi55KXJldHVybiEwO2lmKG4ueTw9ZS55JiZlLnk8PXQueSlyZXR1cm4hMH1yZXR1cm4hMX0scmVkdWNlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuY29tcHV0ZU9jdFJpbmcodCk7aWYobnVsbD09PWUpcmV0dXJuIHQ7Zm9yKHZhciBuPW5ldyBhdCxpPTA7aTxlLmxlbmd0aDtpKyspbi5hZGQoZVtpXSk7Zm9yKHZhciBpPTA7aTx0Lmxlbmd0aDtpKyspaGUuaXNQb2ludEluUmluZyh0W2ldLGUpfHxuLmFkZCh0W2ldKTt2YXIgcj1ILnRvQ29vcmRpbmF0ZUFycmF5KG4pO3JldHVybiByLmxlbmd0aDwzP3RoaXMucGFkQXJyYXkzKHIpOnJ9LGdldENvbnZleEh1bGw6ZnVuY3Rpb24oKXtpZigwPT09dGhpcy5pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpO2lmKDE9PT10aGlzLmlucHV0UHRzLmxlbmd0aClyZXR1cm4gdGhpcy5nZW9tRmFjdG9yeS5jcmVhdGVQb2ludCh0aGlzLmlucHV0UHRzWzBdKTtpZigyPT09dGhpcy5pbnB1dFB0cy5sZW5ndGgpcmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmlucHV0UHRzKTt2YXIgdD10aGlzLmlucHV0UHRzO3RoaXMuaW5wdXRQdHMubGVuZ3RoPjUwJiYodD10aGlzLnJlZHVjZSh0aGlzLmlucHV0UHRzKSk7dmFyIGU9dGhpcy5wcmVTb3J0KHQpLG49dGhpcy5ncmFoYW1TY2FuKGUpLGk9dGhpcy50b0Nvb3JkaW5hdGVBcnJheShuKTtyZXR1cm4gdGhpcy5saW5lT3JQb2x5Z29uKGkpfSxwYWRBcnJheTM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyluPHQubGVuZ3RoP2Vbbl09dFtuXTplW25dPXRbMF07cmV0dXJuIGV9LGNvbXB1dGVPY3RQdHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSg4KS5maWxsKG51bGwpLG49MDtuPGUubGVuZ3RoO24rKyllW25dPXRbMF07Zm9yKHZhciBpPTE7aTx0Lmxlbmd0aDtpKyspdFtpXS54PGVbMF0ueCYmKGVbMF09dFtpXSksdFtpXS54LXRbaV0ueTxlWzFdLngtZVsxXS55JiYoZVsxXT10W2ldKSx0W2ldLnk+ZVsyXS55JiYoZVsyXT10W2ldKSx0W2ldLngrdFtpXS55PmVbM10ueCtlWzNdLnkmJihlWzNdPXRbaV0pLHRbaV0ueD5lWzRdLngmJihlWzRdPXRbaV0pLHRbaV0ueC10W2ldLnk+ZVs1XS54LWVbNV0ueSYmKGVbNV09dFtpXSksdFtpXS55PGVbNl0ueSYmKGVbNl09dFtpXSksdFtpXS54K3RbaV0ueTxlWzddLngrZVs3XS55JiYoZVs3XT10W2ldKTtyZXR1cm4gZX0sdG9Db29yZGluYXRlQXJyYXk6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjx0LnNpemUoKTtuKyspe3ZhciBpPXQuZ2V0KG4pO2Vbbl09aX1yZXR1cm4gZX0sZ3JhaGFtU2NhbjpmdW5jdGlvbih0KXt2YXIgZT1udWxsLG49bmV3IHBlO2U9bi5wdXNoKHRbMF0pLGU9bi5wdXNoKHRbMV0pLGU9bi5wdXNoKHRbMl0pO2Zvcih2YXIgaT0zO2k8dC5sZW5ndGg7aSsrKXtmb3IoZT1uLnBvcCgpOyFuLmVtcHR5KCkmJmhlLmNvbXB1dGVPcmllbnRhdGlvbihuLnBlZWsoKSxlLHRbaV0pPjA7KWU9bi5wb3AoKTtlPW4ucHVzaChlKSxlPW4ucHVzaCh0W2ldKX1yZXR1cm4gZT1uLnB1c2godFswXSksbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbWV9fSksbWUuZXh0cmFjdENvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB2ZTtyZXR1cm4gdC5hcHBseShlKSxlLmdldENvb3JkaW5hdGVzKCl9LGUoeWUucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7cmV0dXJuIHllLnBvbGFyQ29tcGFyZSh0aGlzLm9yaWdpbixuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geWV9fSkseWUucG9sYXJDb21wYXJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLngtdC54LHI9ZS55LXQueSxzPW4ueC10Lngsbz1uLnktdC55LGE9aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxuKTtcbmlmKGE9PT1oZS5DT1VOVEVSQ0xPQ0tXSVNFKXJldHVybiAxO2lmKGE9PT1oZS5DTE9DS1dJU0UpcmV0dXJuLTE7dmFyIHU9aSppK3IqcixsPXMqcytvKm87cmV0dXJuIGw+dT8tMTp1Pmw/MTowfSxtZS5SYWRpYWxDb21wYXJhdG9yPXllLGUoeGUucHJvdG90eXBlLHt0cmFuc2Zvcm1Qb2ludDpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX0sdHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPSEwLGk9dGhpcy50cmFuc2Zvcm1MaW5lYXJSaW5nKHQuZ2V0RXh0ZXJpb3JSaW5nKCksdCk7bnVsbCE9PWkmJmkgaW5zdGFuY2VvZiBidCYmIWkuaXNFbXB0eSgpfHwobj0hMSk7Zm9yKHZhciByPW5ldyBJLHM9MDtzPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cysrKXt2YXIgbz10aGlzLnRyYW5zZm9ybUxpbmVhclJpbmcodC5nZXRJbnRlcmlvclJpbmdOKHMpLHQpO251bGw9PT1vfHxvLmlzRW1wdHkoKXx8KG8gaW5zdGFuY2VvZiBidHx8KG49ITEpLHIuYWRkKG8pKX1pZihuKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbihpLHIudG9BcnJheShbXSkpO3ZhciBhPW5ldyBJO3JldHVybiBudWxsIT09aSYmYS5hZGQoaSksYS5hZGRBbGwociksdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkoYSl9LGNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUodCl9LGdldElucHV0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dEdlb219LHRyYW5zZm9ybU11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtTGluZVN0cmluZyh0LmdldEdlb21ldHJ5TihpKSx0KTtudWxsIT09ciYmKHIuaXNFbXB0eSgpfHxuLmFkZChyKSl9cmV0dXJuIHRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmNvcHkodCl9LHRyYW5zZm9ybUxpbmVTdHJpbmc6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcodGhpcy50cmFuc2Zvcm1Db29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLHQpKX0sdHJhbnNmb3JtTXVsdGlQb2ludDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0LmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciByPXRoaXMudHJhbnNmb3JtUG9pbnQodC5nZXRHZW9tZXRyeU4oaSksdCk7bnVsbCE9PXImJihyLmlzRW1wdHkoKXx8bi5hZGQocikpfXJldHVybiB0aGlzLmZhY3RvcnkuYnVpbGRHZW9tZXRyeShuKX0sdHJhbnNmb3JtTXVsdGlQb2x5Z29uOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9MDtpPHQuZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9dGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQuZ2V0R2VvbWV0cnlOKGkpLHQpO251bGwhPT1yJiYoci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5mYWN0b3J5LmJ1aWxkR2VvbWV0cnkobil9LGNvcHk6ZnVuY3Rpb24odCl7cmV0dXJuIHQuY29weSgpfSx0cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IEksaT0wO2k8dC5nZXROdW1HZW9tZXRyaWVzKCk7aSsrKXt2YXIgcj10aGlzLnRyYW5zZm9ybSh0LmdldEdlb21ldHJ5TihpKSk7bnVsbCE9PXImJih0aGlzLnBydW5lRW1wdHlHZW9tZXRyeSYmci5pc0VtcHR5KCl8fG4uYWRkKHIpKX1yZXR1cm4gdGhpcy5wcmVzZXJ2ZUdlb21ldHJ5Q29sbGVjdGlvblR5cGU/dGhpcy5mYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkobikpOnRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KG4pfSx0cmFuc2Zvcm06ZnVuY3Rpb24odCl7aWYodGhpcy5pbnB1dEdlb209dCx0aGlzLmZhY3Rvcnk9dC5nZXRGYWN0b3J5KCksdCBpbnN0YW5jZW9mIEx0KXJldHVybiB0aGlzLnRyYW5zZm9ybVBvaW50KHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIFB0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9pbnQodCxudWxsKTtpZih0IGluc3RhbmNlb2YgYnQpcmV0dXJuIHRoaXMudHJhbnNmb3JtTGluZWFyUmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBTdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1MaW5lU3RyaW5nKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIGd0KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpTGluZVN0cmluZyh0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1Qb2x5Z29uKHQsbnVsbCk7aWYodCBpbnN0YW5jZW9mIE90KXJldHVybiB0aGlzLnRyYW5zZm9ybU11bHRpUG9seWdvbih0LG51bGwpO2lmKHQgaW5zdGFuY2VvZiBmdClyZXR1cm4gdGhpcy50cmFuc2Zvcm1HZW9tZXRyeUNvbGxlY3Rpb24odCxudWxsKTt0aHJvdyBuZXcgaShcIlVua25vd24gR2VvbWV0cnkgc3VidHlwZTogXCIrdC5nZXRDbGFzcygpLmdldE5hbWUoKSl9LHRyYW5zZm9ybUxpbmVhclJpbmc6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnRyYW5zZm9ybUNvb3JkaW5hdGVzKHQuZ2V0Q29vcmRpbmF0ZVNlcXVlbmNlKCksdCk7aWYobnVsbD09PW4pcmV0dXJuIHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG51bGwpO3ZhciBpPW4uc2l6ZSgpO3JldHVybiBpPjAmJjQ+aSYmIXRoaXMucHJlc2VydmVUeXBlP3RoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKG4pOnRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4ZX19KSxlKEVlLnByb3RvdHlwZSx7c25hcFZlcnRpY2VzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuX2lzQ2xvc2VkP3Quc2l6ZSgpLTE6dC5zaXplKCksaT0wO24+aTtpKyspe3ZhciByPXQuZ2V0KGkpLHM9dGhpcy5maW5kU25hcEZvclZlcnRleChyLGUpO251bGwhPT1zJiYodC5zZXQoaSxuZXcgZyhzKSksMD09PWkmJnRoaXMuX2lzQ2xvc2VkJiZ0LnNldCh0LnNpemUoKS0xLG5ldyBnKHMpKSl9fSxmaW5kU25hcEZvclZlcnRleDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248ZS5sZW5ndGg7bisrKXtpZih0LmVxdWFsczJEKGVbbl0pKXJldHVybiBudWxsO2lmKHQuZGlzdGFuY2UoZVtuXSk8dGhpcy5zbmFwVG9sZXJhbmNlKXJldHVybiBlW25dfXJldHVybiBudWxsfSxzbmFwVG86ZnVuY3Rpb24odCl7dmFyIGU9bmV3IE4odGhpcy5zcmNQdHMpO3RoaXMuc25hcFZlcnRpY2VzKGUsdCksdGhpcy5zbmFwU2VnbWVudHMoZSx0KTt2YXIgbj1lLnRvQ29vcmRpbmF0ZUFycmF5KCk7cmV0dXJuIG59LHNuYXBTZWdtZW50czpmdW5jdGlvbih0LGUpe2lmKDA9PT1lLmxlbmd0aClyZXR1cm4gbnVsbDt2YXIgbj1lLmxlbmd0aDtlWzBdLmVxdWFsczJEKGVbZS5sZW5ndGgtMV0pJiYobj1lLmxlbmd0aC0xKTtmb3IodmFyIGk9MDtuPmk7aSsrKXt2YXIgcj1lW2ldLHM9dGhpcy5maW5kU2VnbWVudEluZGV4VG9TbmFwKHIsdCk7cz49MCYmdC5hZGQocysxLG5ldyBnKHIpLCExKX19LGZpbmRTZWdtZW50SW5kZXhUb1NuYXA6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ci5NQVhfVkFMVUUsaT0tMSxzPTA7czxlLnNpemUoKS0xO3MrKyl7aWYodGhpcy5zZWcucDA9ZS5nZXQocyksdGhpcy5zZWcucDE9ZS5nZXQocysxKSx0aGlzLnNlZy5wMC5lcXVhbHMyRCh0KXx8dGhpcy5zZWcucDEuZXF1YWxzMkQodCkpe2lmKHRoaXMuYWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXMpY29udGludWU7cmV0dXJuLTF9dmFyIG89dGhpcy5zZWcuZGlzdGFuY2UodCk7bzx0aGlzLnNuYXBUb2xlcmFuY2UmJm4+byYmKG49byxpPXMpfXJldHVybiBpfSxzZXRBbGxvd1NuYXBwaW5nVG9Tb3VyY2VWZXJ0aWNlczpmdW5jdGlvbih0KXt0aGlzLmFsbG93U25hcHBpbmdUb1NvdXJjZVZlcnRpY2VzPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVlfX0pLEVlLmlzQ2xvc2VkPWZ1bmN0aW9uKHQpe3JldHVybiB0Lmxlbmd0aDw9MT8hMTp0WzBdLmVxdWFsczJEKHRbdC5sZW5ndGgtMV0pfSxlKEllLnByb3RvdHlwZSx7c25hcFRvOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5leHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXModCksaT1uZXcgTmUoZSxuKTtyZXR1cm4gaS50cmFuc2Zvcm0odGhpcy5zcmNHZW9tKX0sc25hcFRvU2VsZjpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZXh0cmFjdFRhcmdldENvb3JkaW5hdGVzKHRoaXMuc3JjR2VvbSksaT1uZXcgTmUodCxuLCEwKSxyPWkudHJhbnNmb3JtKHRoaXMuc3JjR2VvbSkscz1yO3JldHVybiBlJiZSKHMsUnQpJiYocz1yLmJ1ZmZlcigwKSksc30sY29tcHV0ZVNuYXBUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5jb21wdXRlTWluaW11bVNlZ21lbnRMZW5ndGgodCksbj1lLzEwO3JldHVybiBufSxleHRyYWN0VGFyZ2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBhdCxuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPTA7aTxuLmxlbmd0aDtpKyspZS5hZGQobltpXSk7cmV0dXJuIGUudG9BcnJheShuZXcgQXJyYXkoMCkuZmlsbChudWxsKSl9LGNvbXB1dGVNaW5pbXVtU2VnbWVudExlbmd0aDpmdW5jdGlvbih0KXtmb3IodmFyIGU9ci5NQVhfVkFMVUUsbj0wO248dC5sZW5ndGgtMTtuKyspe3ZhciBpPXRbbl0uZGlzdGFuY2UodFtuKzFdKTtlPmkmJihlPWkpfXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBJZX19KSxJZS5zbmFwPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgQXJyYXkoMikuZmlsbChudWxsKSxyPW5ldyBJZSh0KTtpWzBdPXIuc25hcFRvKGUsbik7dmFyIHM9bmV3IEllKGUpO3JldHVybiBpWzFdPXMuc25hcFRvKGlbMF0sbiksaX0sSWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPUllLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlKHQpLG49dC5nZXRQcmVjaXNpb25Nb2RlbCgpO2lmKG4uZ2V0VHlwZSgpPT09ZWUuRklYRUQpe3ZhciBpPTEvbi5nZXRTY2FsZSgpKjIvMS40MTU7aT5lJiYoZT1pKX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdO3JldHVybiBNYXRoLm1pbihJZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UociksSWUuY29tcHV0ZU92ZXJsYXlTbmFwVG9sZXJhbmNlKHMpKX19LEllLmNvbXB1dGVTaXplQmFzZWRTbmFwVG9sZXJhbmNlPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLG49TWF0aC5taW4oZS5nZXRIZWlnaHQoKSxlLmdldFdpZHRoKCkpLGk9bipJZS5TTkFQX1BSRUNJU0lPTl9GQUNUT1I7cmV0dXJuIGl9LEllLnNuYXBUb1NlbGY9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBJZSh0KTtyZXR1cm4gaS5zbmFwVG9TZWxmKGUsbil9LEllLlNOQVBfUFJFQ0lTSU9OX0ZBQ1RPUj0xZS05LGgoTmUseGUpLGUoTmUucHJvdG90eXBlLHtzbmFwTGluZTpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBFZSh0LHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG4uc2V0QWxsb3dTbmFwcGluZ1RvU291cmNlVmVydGljZXModGhpcy5pc1NlbGZTbmFwKSxuLnNuYXBUbyhlKX0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCksaT10aGlzLnNuYXBMaW5lKG4sdGhpcy5zbmFwUHRzKTtyZXR1cm4gdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoaSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5lfX0pLGUoQ2UucHJvdG90eXBlLHtnZXRDb21tb246ZnVuY3Rpb24oKXtyZXR1cm4gci5sb25nQml0c1RvRG91YmxlKHRoaXMuY29tbW9uQml0cyl9LGFkZDpmdW5jdGlvbih0KXt2YXIgZT1yLmRvdWJsZVRvTG9uZ0JpdHModCk7aWYodGhpcy5pc0ZpcnN0KXJldHVybiB0aGlzLmNvbW1vbkJpdHM9ZSx0aGlzLmNvbW1vblNpZ25FeHA9Q2Uuc2lnbkV4cEJpdHModGhpcy5jb21tb25CaXRzKSx0aGlzLmlzRmlyc3Q9ITEsbnVsbDt2YXIgbj1DZS5zaWduRXhwQml0cyhlKTtyZXR1cm4gbiE9PXRoaXMuY29tbW9uU2lnbkV4cD8odGhpcy5jb21tb25CaXRzPTAsbnVsbCk6KHRoaXMuY29tbW9uTWFudGlzc2FCaXRzQ291bnQ9Q2UubnVtQ29tbW9uTW9zdFNpZ01hbnRpc3NhQml0cyh0aGlzLmNvbW1vbkJpdHMsZSksdm9pZCh0aGlzLmNvbW1vbkJpdHM9Q2UuemVyb0xvd2VyQml0cyh0aGlzLmNvbW1vbkJpdHMsNjQtKDEyK3RoaXMuY29tbW9uTWFudGlzc2FCaXRzQ291bnQpKSkpfSx0b1N0cmluZzpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1yLmxvbmdCaXRzVG9Eb3VibGUodCksbj1Mb25nLnRvQmluYXJ5U3RyaW5nKHQpLGk9XCIwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwMDAwXCIrbixzPWkuc3Vic3RyaW5nKGkubGVuZ3RoLTY0KSxvPXMuc3Vic3RyaW5nKDAsMSkrXCIgIFwiK3Muc3Vic3RyaW5nKDEsMTIpK1wiKGV4cCkgXCIrcy5zdWJzdHJpbmcoMTIpK1wiIFsgXCIrZStcIiBdXCI7cmV0dXJuIG99fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDZX19KSxDZS5nZXRCaXQ9ZnVuY3Rpb24odCxlKXt2YXIgbj0xPDxlO3JldHVybiAwIT09KHQmbik/MTowfSxDZS5zaWduRXhwQml0cz1mdW5jdGlvbih0KXtyZXR1cm4gdD4+NTJ9LENlLnplcm9Mb3dlckJpdHM9ZnVuY3Rpb24odCxlKXt2YXIgbj0oMTw8ZSktMSxpPX5uLHI9dCZpO3JldHVybiByfSxDZS5udW1Db21tb25Nb3N0U2lnTWFudGlzc2FCaXRzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT01MjtpPj0wO2ktLSl7aWYoQ2UuZ2V0Qml0KHQsaSkhPT1DZS5nZXRCaXQoZSxpKSlyZXR1cm4gbjtuKyt9cmV0dXJuIDUyfSxlKFNlLnByb3RvdHlwZSx7YWRkQ29tbW9uQml0czpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTGUodGhpcy5jb21tb25Db29yZCk7dC5hcHBseShlKSx0Lmdlb21ldHJ5Q2hhbmdlZCgpfSxyZW1vdmVDb21tb25CaXRzOmZ1bmN0aW9uKHQpe2lmKDA9PT10aGlzLmNvbW1vbkNvb3JkLngmJjA9PT10aGlzLmNvbW1vbkNvb3JkLnkpcmV0dXJuIHQ7dmFyIGU9bmV3IGcodGhpcy5jb21tb25Db29yZCk7ZS54PS1lLngsZS55PS1lLnk7dmFyIG49bmV3IExlKGUpO3JldHVybiB0LmFwcGx5KG4pLHQuZ2VvbWV0cnlDaGFuZ2VkKCksdH0sZ2V0Q29tbW9uQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbW1vbkNvb3JkfSxhZGQ6ZnVuY3Rpb24odCl7dC5hcHBseSh0aGlzLmNjRmlsdGVyKSx0aGlzLmNvbW1vbkNvb3JkPXRoaXMuY2NGaWx0ZXIuZ2V0Q29tbW9uQ29vcmRpbmF0ZSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBTZX19KSxlKHdlLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3RoaXMuY29tbW9uQml0c1guYWRkKHQueCksdGhpcy5jb21tb25CaXRzWS5hZGQodC55KX0sZ2V0Q29tbW9uQ29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiBuZXcgZyh0aGlzLmNvbW1vbkJpdHNYLmdldENvbW1vbigpLHRoaXMuY29tbW9uQml0c1kuZ2V0Q29tbW9uKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt6XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd2V9fSksZShMZS5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0T3JkaW5hdGUoZSwwKSt0aGlzLnRyYW5zLngsaT10LmdldE9yZGluYXRlKGUsMSkrdGhpcy50cmFucy55O3Quc2V0T3JkaW5hdGUoZSwwLG4pLHQuc2V0T3JkaW5hdGUoZSwxLGkpfSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4hMX0saXNHZW9tZXRyeUNoYW5nZWQ6ZnVuY3Rpb24oKXtyZXR1cm4hMH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bY3RdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMZX19KSxTZS5Db21tb25Db29yZGluYXRlRmlsdGVyPXdlLFNlLlRyYW5zbGF0ZXI9TGUsZShSZS5wcm90b3R5cGUse25leHQ6ZnVuY3Rpb24oKXtpZih0aGlzLmF0U3RhcnQpcmV0dXJuIHRoaXMuYXRTdGFydD0hMSxSZS5pc0F0b21pYyh0aGlzLnBhcmVudCkmJnRoaXMuaW5kZXgrKyx0aGlzLnBhcmVudDtpZihudWxsIT09dGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3Ipe2lmKHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLmhhc05leHQoKSlyZXR1cm4gdGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IubmV4dCgpO3RoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9aWYodGhpcy5pbmRleD49dGhpcy5tYXgpdGhyb3cgbmV3IHg7dmFyIHQ9dGhpcy5wYXJlbnQuZ2V0R2VvbWV0cnlOKHRoaXMuaW5kZXgrKyk7cmV0dXJuIHQgaW5zdGFuY2VvZiBmdD8odGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3I9bmV3IFJlKHQpLHRoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yLm5leHQoKSk6dH0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpfSxoYXNOZXh0OmZ1bmN0aW9uKCl7aWYodGhpcy5hdFN0YXJ0KXJldHVybiEwO2lmKG51bGwhPT10aGlzLnN1YmNvbGxlY3Rpb25JdGVyYXRvcil7aWYodGhpcy5zdWJjb2xsZWN0aW9uSXRlcmF0b3IuaGFzTmV4dCgpKXJldHVybiEwO3RoaXMuc3ViY29sbGVjdGlvbkl0ZXJhdG9yPW51bGx9cmV0dXJuISh0aGlzLmluZGV4Pj10aGlzLm1heCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3BdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSZX19KSxSZS5pc0F0b21pYz1mdW5jdGlvbih0KXtyZXR1cm4hKHQgaW5zdGFuY2VvZiBmdCl9LGUoVGUucHJvdG90eXBlLHtsb2NhdGVJbnRlcm5hbDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBUdCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO2lmKGUuaXNFbXB0eSgpKXJldHVybiBMLkVYVEVSSU9SO3ZhciBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCksaT10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxuKTtpZihpPT09TC5FWFRFUklPUilyZXR1cm4gTC5FWFRFUklPUjtpZihpPT09TC5CT1VOREFSWSlyZXR1cm4gTC5CT1VOREFSWTtmb3IodmFyIHI9MDtyPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7cisrKXt2YXIgcz1lLmdldEludGVyaW9yUmluZ04ociksbz10aGlzLmxvY2F0ZUluUG9seWdvblJpbmcodCxzKTtpZihvPT09TC5JTlRFUklPUilyZXR1cm4gTC5FWFRFUklPUjtpZihvPT09TC5CT1VOREFSWSlyZXR1cm4gTC5CT1VOREFSWX1yZXR1cm4gTC5JTlRFUklPUn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgU3Qpe3ZhciBhPWFyZ3VtZW50c1swXSx1PWFyZ3VtZW50c1sxXTtpZighdS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhhKSlyZXR1cm4gTC5FWFRFUklPUjt2YXIgbD11LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHUuaXNDbG9zZWQoKXx8IWEuZXF1YWxzKGxbMF0pJiYhYS5lcXVhbHMobFtsLmxlbmd0aC0xXSk/aGUuaXNPbkxpbmUoYSxsKT9MLklOVEVSSU9SOkwuRVhURVJJT1I6TC5CT1VOREFSWX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgTHQpe3ZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxmPWMuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBmLmVxdWFsczJEKGgpP0wuSU5URVJJT1I6TC5FWFRFUklPUn19LGxvY2F0ZUluUG9seWdvblJpbmc6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9oZS5sb2NhdGVQb2ludEluUmluZyh0LGUuZ2V0Q29vcmRpbmF0ZXMoKSk6TC5FWFRFUklPUn0saW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxvY2F0ZSh0LGUpIT09TC5FWFRFUklPUn0sdXBkYXRlTG9jYXRpb25JbmZvOmZ1bmN0aW9uKHQpe3Q9PT1MLklOVEVSSU9SJiYodGhpcy5pc0luPSEwKSx0PT09TC5CT1VOREFSWSYmdGhpcy5udW1Cb3VuZGFyaWVzKyt9LGNvbXB1dGVMb2NhdGlvbjpmdW5jdGlvbih0LGUpe2lmKGUgaW5zdGFuY2VvZiBMdCYmdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpKSxlIGluc3RhbmNlb2YgU3QpdGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpKTtlbHNlIGlmKGUgaW5zdGFuY2VvZiBUdCl0aGlzLnVwZGF0ZUxvY2F0aW9uSW5mbyh0aGlzLmxvY2F0ZUludGVybmFsKHQsZSkpO2Vsc2UgaWYoZSBpbnN0YW5jZW9mIGd0KWZvcih2YXIgbj1lLGk9MDtpPG4uZ2V0TnVtR2VvbWV0cmllcygpO2krKyl7dmFyIHI9bi5nZXRHZW9tZXRyeU4oaSk7dGhpcy51cGRhdGVMb2NhdGlvbkluZm8odGhpcy5sb2NhdGVJbnRlcm5hbCh0LHIpKX1lbHNlIGlmKGUgaW5zdGFuY2VvZiBPdClmb3IodmFyIHM9ZSxpPTA7aTxzLmdldE51bUdlb21ldHJpZXMoKTtpKyspe3ZhciBvPXMuZ2V0R2VvbWV0cnlOKGkpO3RoaXMudXBkYXRlTG9jYXRpb25JbmZvKHRoaXMubG9jYXRlSW50ZXJuYWwodCxvKSl9ZWxzZSBpZihlIGluc3RhbmNlb2YgZnQpZm9yKHZhciBhPW5ldyBSZShlKTthLmhhc05leHQoKTspe3ZhciB1PWEubmV4dCgpO3UhPT1lJiZ0aGlzLmNvbXB1dGVMb2NhdGlvbih0LHUpfX0sbG9jYXRlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuaXNFbXB0eSgpP0wuRVhURVJJT1I6ZSBpbnN0YW5jZW9mIFN0P3RoaXMubG9jYXRlSW50ZXJuYWwodCxlKTplIGluc3RhbmNlb2YgVHQ/dGhpcy5sb2NhdGVJbnRlcm5hbCh0LGUpOih0aGlzLmlzSW49ITEsdGhpcy5udW1Cb3VuZGFyaWVzPTAsdGhpcy5jb21wdXRlTG9jYXRpb24odCxlKSx0aGlzLmJvdW5kYXJ5UnVsZS5pc0luQm91bmRhcnkodGhpcy5udW1Cb3VuZGFyaWVzKT9MLkJPVU5EQVJZOnRoaXMubnVtQm91bmRhcmllcz4wfHx0aGlzLmlzSW4/TC5JTlRFUklPUjpMLkVYVEVSSU9SKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVGV9fSksZShQZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFBlfX0pLFBlLm9jdGFudD1mdW5jdGlvbigpe2lmKFwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMF0mJlwibnVtYmVyXCI9PXR5cGVvZiBhcmd1bWVudHNbMV0pe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtpZigwPT09dCYmMD09PWUpdGhyb3cgbmV3IGkoXCJDYW5ub3QgY29tcHV0ZSB0aGUgb2N0YW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTt2YXIgbj1NYXRoLmFicyh0KSxyPU1hdGguYWJzKGUpO3JldHVybiB0Pj0wP2U+PTA/bj49cj8wOjE6bj49cj83OjY6ZT49MD9uPj1yPzM6MjpuPj1yPzQ6NX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgZyl7dmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9by54LXMueCx1PW8ueS1zLnk7aWYoMD09PWEmJjA9PT11KXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIG9jdGFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrcyk7cmV0dXJuIFBlLm9jdGFudChhLHUpfX0sZShiZS5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7fSxzaXplOmZ1bmN0aW9uKCl7fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe30saXNDbG9zZWQ6ZnVuY3Rpb24oKXt9LHNldERhdGE6ZnVuY3Rpb24odCl7fSxnZXREYXRhOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBiZX19KSxlKE9lLnByb3RvdHlwZSx7Z2V0Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHN9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHMubGVuZ3RofSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0c1t0XX0saXNDbG9zZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdHNbMF0uZXF1YWxzKHRoaXMucHRzW3RoaXMucHRzLmxlbmd0aC0xXSl9LGdldFNlZ21lbnRPY3RhbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT10aGlzLnB0cy5sZW5ndGgtMT8tMTpQZS5vY3RhbnQodGhpcy5nZXRDb29yZGluYXRlKHQpLHRoaXMuZ2V0Q29vcmRpbmF0ZSh0KzEpKX0sc2V0RGF0YTpmdW5jdGlvbih0KXt0aGlzLmRhdGE9dH0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgR3QodGhpcy5wdHMpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bYmVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPZX19KSxlKF9lLnByb3RvdHlwZSx7Z2V0Qm91bmRzOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBfZX19KSxlKE1lLnByb3RvdHlwZSx7Z2V0SXRlbTpmdW5jdGlvbigpe3JldHVybiB0aGlzLml0ZW19LGdldEJvdW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJvdW5kc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bX2UsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE1lfX0pLGUoRGUucHJvdG90eXBlLHtwb2xsOmZ1bmN0aW9uKCl7aWYodGhpcy5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5pdGVtcy5nZXQoMSk7cmV0dXJuIHRoaXMuaXRlbXMuc2V0KDEsdGhpcy5pdGVtcy5nZXQodGhpcy5fc2l6ZSkpLHRoaXMuX3NpemUtPTEsdGhpcy5yZW9yZGVyKDEpLHR9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc2l6ZX0scmVvcmRlcjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bnVsbCxuPXRoaXMuaXRlbXMuZ2V0KHQpOzIqdDw9dGhpcy5fc2l6ZSYmKGU9Mip0LGUhPT10aGlzLl9zaXplJiZ0aGlzLml0ZW1zLmdldChlKzEpLmNvbXBhcmVUbyh0aGlzLml0ZW1zLmdldChlKSk8MCYmZSsrLHRoaXMuaXRlbXMuZ2V0KGUpLmNvbXBhcmVUbyhuKTwwKTt0PWUpdGhpcy5pdGVtcy5zZXQodCx0aGlzLml0ZW1zLmdldChlKSk7dGhpcy5pdGVtcy5zZXQodCxuKX0sY2xlYXI6ZnVuY3Rpb24oKXt0aGlzLl9zaXplPTAsdGhpcy5pdGVtcy5jbGVhcigpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLl9zaXplfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQobnVsbCksdGhpcy5fc2l6ZSs9MTt2YXIgZT10aGlzLl9zaXplO2Zvcih0aGlzLml0ZW1zLnNldCgwLHQpO3QuY29tcGFyZVRvKHRoaXMuaXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpPDA7ZS89Mil0aGlzLml0ZW1zLnNldChlLHRoaXMuaXRlbXMuZ2V0KE1hdGgudHJ1bmMoZS8yKSkpO3RoaXMuaXRlbXMuc2V0KGUsdCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERlfX0pLGUoQWUucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBZX19KSxlKEZlLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQsZSl7fSxyZW1vdmU6ZnVuY3Rpb24odCxlKXt9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRmV9fSksZShHZS5wcm90b3R5cGUse2dldExldmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWx9LHNpemU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZEJvdW5kYWJsZXMuc2l6ZSgpfSxnZXRDaGlsZEJvdW5kYWJsZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGlsZEJvdW5kYWJsZXN9LGFkZENoaWxkQm91bmRhYmxlOmZ1bmN0aW9uKHQpe2YuaXNUcnVlKG51bGw9PT10aGlzLmJvdW5kcyksdGhpcy5jaGlsZEJvdW5kYWJsZXMuYWRkKHQpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hpbGRCb3VuZGFibGVzLmlzRW1wdHkoKX0sZ2V0Qm91bmRzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmJvdW5kcyYmKHRoaXMuYm91bmRzPXRoaXMuY29tcHV0ZUJvdW5kcygpKSx0aGlzLmJvdW5kc30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bX2UsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdlfX0pLEdlLnNlcmlhbFZlcnNpb25VSUQ9MHg1YTFlNTVlYzQxMzY5ODAwO3ZhciBobz17cmV2ZXJzZU9yZGVyOmZ1bmN0aW9uKCl7cmV0dXJue2NvbXBhcmU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5jb21wYXJlVG8odCl9fX0sbWluOmZ1bmN0aW9uKHQpe3JldHVybiBoby5zb3J0KHQpLHQuZ2V0KDApfSxzb3J0OmZ1bmN0aW9uKHQsZSl7dmFyIG49dC50b0FycmF5KCk7ZT91dC5zb3J0KG4sZSk6dXQuc29ydChuKTtmb3IodmFyIGk9dC5pdGVyYXRvcigpLHI9MCxzPW4ubGVuZ3RoO3M+cjtyKyspaS5uZXh0KCksaS5zZXQobltyXSl9LHNpbmdsZXRvbkxpc3Q6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEk7cmV0dXJuIGUuYWRkKHQpLGV9fTtlKHFlLnByb3RvdHlwZSx7ZXhwYW5kVG9RdWV1ZTpmdW5jdGlvbih0LGUpe3ZhciBuPXFlLmlzQ29tcG9zaXRlKHRoaXMuYm91bmRhYmxlMSkscj1xZS5pc0NvbXBvc2l0ZSh0aGlzLmJvdW5kYWJsZTIpO2lmKG4mJnIpcmV0dXJuIHFlLmFyZWEodGhpcy5ib3VuZGFibGUxKT5xZS5hcmVhKHRoaXMuYm91bmRhYmxlMik/KHRoaXMuZXhwYW5kKHRoaXMuYm91bmRhYmxlMSx0aGlzLmJvdW5kYWJsZTIsdCxlKSxudWxsKToodGhpcy5leHBhbmQodGhpcy5ib3VuZGFibGUyLHRoaXMuYm91bmRhYmxlMSx0LGUpLG51bGwpO2lmKG4pcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuYm91bmRhYmxlMSx0aGlzLmJvdW5kYWJsZTIsdCxlKSxudWxsO2lmKHIpcmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMuYm91bmRhYmxlMix0aGlzLmJvdW5kYWJsZTEsdCxlKSxudWxsO3Rocm93IG5ldyBpKFwibmVpdGhlciBib3VuZGFibGUgaXMgY29tcG9zaXRlXCIpfSxpc0xlYXZlczpmdW5jdGlvbigpe3JldHVybiEocWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUxKXx8cWUuaXNDb21wb3NpdGUodGhpcy5ib3VuZGFibGUyKSl9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLl9kaXN0YW5jZTxlLl9kaXN0YW5jZT8tMTp0aGlzLl9kaXN0YW5jZT5lLl9kaXN0YW5jZT8xOjB9LGV4cGFuZDpmdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9dC5nZXRDaGlsZEJvdW5kYWJsZXMoKSxzPXIuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLGE9bmV3IHFlKG8sZSx0aGlzLml0ZW1EaXN0YW5jZSk7YS5nZXREaXN0YW5jZSgpPGkmJm4uYWRkKGEpfX0sZ2V0Qm91bmRhYmxlOmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dD90aGlzLmJvdW5kYWJsZTE6dGhpcy5ib3VuZGFibGUyfSxnZXREaXN0YW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9kaXN0YW5jZX0sZGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pc0xlYXZlcygpP3RoaXMuaXRlbURpc3RhbmNlLmRpc3RhbmNlKHRoaXMuYm91bmRhYmxlMSx0aGlzLmJvdW5kYWJsZTIpOnRoaXMuYm91bmRhYmxlMS5nZXRCb3VuZHMoKS5kaXN0YW5jZSh0aGlzLmJvdW5kYWJsZTIuZ2V0Qm91bmRzKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcWV9fSkscWUuYXJlYT1mdW5jdGlvbih0KXtyZXR1cm4gdC5nZXRCb3VuZHMoKS5nZXRBcmVhKCl9LHFlLmlzQ29tcG9zaXRlPWZ1bmN0aW9uKHQpe3JldHVybiB0IGluc3RhbmNlb2YgR2V9LGUoQmUucHJvdG90eXBlLHtnZXROb2RlQ2FwYWNpdHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlQ2FwYWNpdHl9LGxhc3ROb2RlOmZ1bmN0aW9uKHQpe3JldHVybiB0LmdldCh0LnNpemUoKS0xKX0sc2l6ZTpmdW5jdGlvbiB0KCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLnNpemUodGhpcy5yb290KSk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sdD0wLG49ZS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aSBpbnN0YW5jZW9mIEdlP3QrPXRoaXMuc2l6ZShpKTppIGluc3RhbmNlb2YgTWUmJih0Kz0xKX1yZXR1cm4gdH19LHJlbW92ZUl0ZW06ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bnVsbCxpPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IgaW5zdGFuY2VvZiBNZSYmci5nZXRJdGVtKCk9PT1lJiYobj1yKX1yZXR1cm4gbnVsbCE9PW4/KHQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG4pLCEwKTohMX0saXRlbXNUcmVlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3RoaXMuYnVpbGQoKTt2YXIgdD10aGlzLml0ZW1zVHJlZSh0aGlzLnJvb3QpO3JldHVybiBudWxsPT09dD9uZXcgSTp0fWlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49bmV3IEksaT1lLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZihyIGluc3RhbmNlb2YgR2Upe3ZhciBzPXRoaXMuaXRlbXNUcmVlKHIpO251bGwhPT1zJiZuLmFkZChzKX1lbHNlIHIgaW5zdGFuY2VvZiBNZT9uLmFkZChyLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpfXJldHVybiBuLnNpemUoKTw9MD9udWxsOm59fSxpbnNlcnQ6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdGhpcy5idWlsdCxcIkNhbm5vdCBpbnNlcnQgaXRlbXMgaW50byBhbiBTVFIgcGFja2VkIFItdHJlZSBhZnRlciBpdCBoYXMgYmVlbiBidWlsdC5cIiksdGhpcy5pdGVtQm91bmRhYmxlcy5hZGQobmV3IE1lKHQsZSkpfSxib3VuZGFibGVzQXRMZXZlbDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSTtyZXR1cm4gdGhpcy5ib3VuZGFibGVzQXRMZXZlbCh0LHRoaXMucm9vdCxlKSxlfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07aWYoZi5pc1RydWUobj4tMiksaS5nZXRMZXZlbCgpPT09bilyZXR1cm4gci5hZGQoaSksbnVsbDtmb3IodmFyIHM9aS5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCk7byBpbnN0YW5jZW9mIEdlP3RoaXMuYm91bmRhYmxlc0F0TGV2ZWwobixvLHIpOihmLmlzVHJ1ZShvIGluc3RhbmNlb2YgTWUpLC0xPT09biYmci5hZGQobykpfXJldHVybiBudWxsfX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuYnVpbGQoKTt2YXIgZT1uZXcgSTtyZXR1cm4gdGhpcy5pc0VtcHR5KCk/ZToodGhpcy5nZXRJbnRlcnNlY3RzT3AoKS5pbnRlcnNlY3RzKHRoaXMucm9vdC5nZXRCb3VuZHMoKSx0KSYmdGhpcy5xdWVyeSh0LHRoaXMucm9vdCxlKSxlKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO2lmKHRoaXMuYnVpbGQoKSx0aGlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModGhpcy5yb290LmdldEJvdW5kcygpLG4pJiZ0aGlzLnF1ZXJ5KG4sdGhpcy5yb290LGkpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoUihhcmd1bWVudHNbMl0sQWUpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSlmb3IodmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGE9cy5nZXRDaGlsZEJvdW5kYWJsZXMoKSx1PTA7dTxhLnNpemUoKTt1Kyspe3ZhciBsPWEuZ2V0KHUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhsLmdldEJvdW5kcygpLHIpJiYobCBpbnN0YW5jZW9mIEdlP3RoaXMucXVlcnkocixsLG8pOmwgaW5zdGFuY2VvZiBNZT9vLnZpc2l0SXRlbShsLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpKX1lbHNlIGlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSlmb3IodmFyIGg9YXJndW1lbnRzWzBdLGM9YXJndW1lbnRzWzFdLGc9YXJndW1lbnRzWzJdLGE9Yy5nZXRDaGlsZEJvdW5kYWJsZXMoKSx1PTA7dTxhLnNpemUoKTt1Kyspe3ZhciBsPWEuZ2V0KHUpO3RoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyhsLmdldEJvdW5kcygpLGgpJiYobCBpbnN0YW5jZW9mIEdlP3RoaXMucXVlcnkoaCxsLGcpOmwgaW5zdGFuY2VvZiBNZT9nLmFkZChsLmdldEl0ZW0oKSk6Zi5zaG91bGROZXZlclJlYWNoSGVyZSgpKX19LGJ1aWxkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYnVpbHQ/bnVsbDoodGhpcy5yb290PXRoaXMuaXRlbUJvdW5kYWJsZXMuaXNFbXB0eSgpP3RoaXMuY3JlYXRlTm9kZSgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyh0aGlzLml0ZW1Cb3VuZGFibGVzLC0xKSx0aGlzLml0ZW1Cb3VuZGFibGVzPW51bGwsdm9pZCh0aGlzLmJ1aWx0PSEwKSl9LGdldFJvb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMucm9vdH0scmVtb3ZlOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5idWlsZCgpLHRoaXMuZ2V0SW50ZXJzZWN0c09wKCkuaW50ZXJzZWN0cyh0aGlzLnJvb3QuZ2V0Qm91bmRzKCksdCk/dGhpcy5yZW1vdmUodCx0aGlzLnJvb3QsZSk6ITF9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPXRoaXMucmVtb3ZlSXRlbShpLHIpO2lmKHMpcmV0dXJuITA7Zm9yKHZhciBvPW51bGwsYT1pLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKTtpZih0aGlzLmdldEludGVyc2VjdHNPcCgpLmludGVyc2VjdHModS5nZXRCb3VuZHMoKSxuKSYmdSBpbnN0YW5jZW9mIEdlJiYocz10aGlzLnJlbW92ZShuLHUscikpKXtvPXU7YnJlYWt9fXJldHVybiBudWxsIT09byYmby5nZXRDaGlsZEJvdW5kYWJsZXMoKS5pc0VtcHR5KCkmJmkuZ2V0Q2hpbGRCb3VuZGFibGVzKCkucmVtb3ZlKG8pLHN9fSxjcmVhdGVIaWdoZXJMZXZlbHM6ZnVuY3Rpb24odCxlKXtmLmlzVHJ1ZSghdC5pc0VtcHR5KCkpO3ZhciBuPXRoaXMuY3JlYXRlUGFyZW50Qm91bmRhYmxlcyh0LGUrMSk7cmV0dXJuIDE9PT1uLnNpemUoKT9uLmdldCgwKTp0aGlzLmNyZWF0ZUhpZ2hlckxldmVscyhuLGUrMSl9LGRlcHRoOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuaXNFbXB0eSgpPzA6KHRoaXMuYnVpbGQoKSx0aGlzLmRlcHRoKHRoaXMucm9vdCkpO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9MCxuPXQuZ2V0Q2hpbGRCb3VuZGFibGVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkgaW5zdGFuY2VvZiBHZSl7dmFyIHI9dGhpcy5kZXB0aChpKTtyPmUmJihlPXIpfX1yZXR1cm4gZSsxfX0sY3JlYXRlUGFyZW50Qm91bmRhYmxlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0LmlzRW1wdHkoKSk7dmFyIG49bmV3IEk7bi5hZGQodGhpcy5jcmVhdGVOb2RlKGUpKTt2YXIgaT1uZXcgSSh0KTtoby5zb3J0KGksdGhpcy5nZXRDb21wYXJhdG9yKCkpO2Zvcih2YXIgcj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTt0aGlzLmxhc3ROb2RlKG4pLmdldENoaWxkQm91bmRhYmxlcygpLnNpemUoKT09PXRoaXMuZ2V0Tm9kZUNhcGFjaXR5KCkmJm4uYWRkKHRoaXMuY3JlYXRlTm9kZShlKSksdGhpcy5sYXN0Tm9kZShuKS5hZGRDaGlsZEJvdW5kYWJsZShzKX1yZXR1cm4gbn0saXNFbXB0eTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmJ1aWx0P3RoaXMucm9vdC5pc0VtcHR5KCk6dGhpcy5pdGVtQm91bmRhYmxlcy5pc0VtcHR5KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3VdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCZX19KSxCZS5jb21wYXJlRG91Ymxlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0PmU/MTplPnQ/LTE6MH0sQmUuSW50ZXJzZWN0c09wPXplLEJlLnNlcmlhbFZlcnNpb25VSUQ9LTB4MzVlZjY0YzgyZDRjNTQwMCxCZS5ERUZBVUxUX05PREVfQ0FQQUNJVFk9MTAsZShWZS5wcm90b3R5cGUse2Rpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBWZX19KSxoKGtlLEJlKSxlKGtlLnByb3RvdHlwZSx7Y3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKHQubGVuZ3RoPjApO2Zvcih2YXIgbj1uZXcgSSxpPTA7aTx0Lmxlbmd0aDtpKyspbi5hZGRBbGwodGhpcy5jcmVhdGVQYXJlbnRCb3VuZGFibGVzRnJvbVZlcnRpY2FsU2xpY2UodFtpXSxlKSk7cmV0dXJuIG59LGNyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBZZSh0KX0sc2l6ZTpmdW5jdGlvbigpe3JldHVybiAwPT09YXJndW1lbnRzLmxlbmd0aD9CZS5wcm90b3R5cGUuc2l6ZS5jYWxsKHRoaXMpOkJlLnByb3RvdHlwZS5zaXplLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0saW5zZXJ0OmZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIEJlLnByb3RvdHlwZS5pbnNlcnQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdC5pc051bGwoKT9udWxsOnZvaWQgQmUucHJvdG90eXBlLmluc2VydC5jYWxsKHRoaXMsdCxlKX0sZ2V0SW50ZXJzZWN0c09wOmZ1bmN0aW9uKCl7cmV0dXJuIGtlLmludGVyc2VjdHNPcH0sdmVydGljYWxTbGljZXM6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvZSkpLGk9bmV3IEFycmF5KGUpLmZpbGwobnVsbCkscj10Lml0ZXJhdG9yKCkscz0wO2U+cztzKyspe2lbc109bmV3IEk7Zm9yKHZhciBvPTA7ci5oYXNOZXh0KCkmJm4+bzspe3ZhciBhPXIubmV4dCgpO2lbc10uYWRkKGEpLG8rK319cmV0dXJuIGl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gQmUucHJvdG90eXBlLnF1ZXJ5LmNhbGwodGhpcyx0KX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO0JlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsZSxuKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKFIoYXJndW1lbnRzWzJdLEFlKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBPYmplY3QmJmFyZ3VtZW50c1sxXWluc3RhbmNlb2YgR2Upe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTtCZS5wcm90b3R5cGUucXVlcnkuY2FsbCh0aGlzLGkscixzKX1lbHNlIGlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIE9iamVjdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBHZSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO0JlLnByb3RvdHlwZS5xdWVyeS5jYWxsKHRoaXMsbyxhLHUpfX0sZ2V0Q29tcGFyYXRvcjpmdW5jdGlvbigpe3JldHVybiBrZS55Q29tcGFyYXRvcn0sY3JlYXRlUGFyZW50Qm91bmRhYmxlc0Zyb21WZXJ0aWNhbFNsaWNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEJlLnByb3RvdHlwZS5jcmVhdGVQYXJlbnRCb3VuZGFibGVzLmNhbGwodGhpcyx0LGUpfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiBCZS5wcm90b3R5cGUucmVtb3ZlLmNhbGwodGhpcyx0LGUpfXJldHVybiBCZS5wcm90b3R5cGUucmVtb3ZlLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gMD09PWFyZ3VtZW50cy5sZW5ndGg/QmUucHJvdG90eXBlLmRlcHRoLmNhbGwodGhpcyk6QmUucHJvdG90eXBlLmRlcHRoLmFwcGx5KHRoaXMsYXJndW1lbnRzKX0sY3JlYXRlUGFyZW50Qm91bmRhYmxlczpmdW5jdGlvbih0LGUpe2YuaXNUcnVlKCF0LmlzRW1wdHkoKSk7dmFyIG49TWF0aC50cnVuYyhNYXRoLmNlaWwodC5zaXplKCkvdGhpcy5nZXROb2RlQ2FwYWNpdHkoKSkpLGk9bmV3IEkodCk7aG8uc29ydChpLGtlLnhDb21wYXJhdG9yKTt2YXIgcj10aGlzLnZlcnRpY2FsU2xpY2VzKGksTWF0aC50cnVuYyhNYXRoLmNlaWwoTWF0aC5zcXJ0KG4pKSkpO3JldHVybiB0aGlzLmNyZWF0ZVBhcmVudEJvdW5kYWJsZXNGcm9tVmVydGljYWxTbGljZXMocixlKX0sbmVhcmVzdE5laWdoYm91cjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtpZihSKGFyZ3VtZW50c1swXSxWZSkpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBxZSh0aGlzLmdldFJvb3QoKSx0aGlzLmdldFJvb3QoKSx0KTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcWUpe3ZhciBuPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKG4sci5QT1NJVElWRV9JTkZJTklUWSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2Yga2UmJlIoYXJndW1lbnRzWzFdLFZlKSl7dmFyIGk9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLGU9bmV3IHFlKHRoaXMuZ2V0Um9vdCgpLGkuZ2V0Um9vdCgpLHMpO3JldHVybiB0aGlzLm5lYXJlc3ROZWlnaGJvdXIoZSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBxZSYmXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1sxXSl7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YSxsPW51bGwsaD1uZXcgRGU7Zm9yKGguYWRkKG8pOyFoLmlzRW1wdHkoKSYmdT4wOyl7dmFyIGM9aC5wb2xsKCksZj1jLmdldERpc3RhbmNlKCk7aWYoZj49dSlicmVhaztjLmlzTGVhdmVzKCk/KHU9ZixsPWMpOmMuZXhwYW5kVG9RdWV1ZShoLHUpfXJldHVybltsLmdldEJvdW5kYWJsZSgwKS5nZXRJdGVtKCksbC5nZXRCb3VuZGFibGUoMSkuZ2V0SXRlbSgpXX19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGc9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdLHY9bmV3IE1lKGcsZCksZT1uZXcgcWUodGhpcy5nZXRSb290KCksdixwKTtyZXR1cm4gdGhpcy5uZWFyZXN0TmVpZ2hib3VyKGUpWzBdfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bRmUsdV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtlfX0pLGtlLmNlbnRyZVg9ZnVuY3Rpb24odCl7cmV0dXJuIGtlLmF2Zyh0LmdldE1pblgoKSx0LmdldE1heFgoKSl9LGtlLmF2Zz1mdW5jdGlvbih0LGUpe3JldHVybih0K2UpLzJ9LGtlLmNlbnRyZVk9ZnVuY3Rpb24odCl7cmV0dXJuIGtlLmF2Zyh0LmdldE1pblkoKSx0LmdldE1heFkoKSl9LGgoWWUsR2UpLGUoWWUucHJvdG90eXBlLHtjb21wdXRlQm91bmRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW51bGwsZT10aGlzLmdldENoaWxkQm91bmRhYmxlcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtudWxsPT09dD90PW5ldyBDKG4uZ2V0Qm91bmRzKCkpOnQuZXhwYW5kVG9JbmNsdWRlKG4uZ2V0Qm91bmRzKCkpfXJldHVybiB0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZZX19KSxrZS5TVFJ0cmVlTm9kZT1ZZSxrZS5zZXJpYWxWZXJzaW9uVUlEPTB4Mzk5MjBmN2Q1ZjI2MWUwLGtlLnhDb21wYXJhdG9yPXtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sY29tcGFyZTpmdW5jdGlvbih0LGUpe3JldHVybiBCZS5jb21wYXJlRG91YmxlcyhrZS5jZW50cmVYKHQuZ2V0Qm91bmRzKCkpLGtlLmNlbnRyZVgoZS5nZXRCb3VuZHMoKSkpfX0sa2UueUNvbXBhcmF0b3I9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIEJlLmNvbXBhcmVEb3VibGVzKGtlLmNlbnRyZVkodC5nZXRCb3VuZHMoKSksa2UuY2VudHJlWShlLmdldEJvdW5kcygpKSl9fSxrZS5pbnRlcnNlY3RzT3A9e2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ludGVyc2VjdHNPcF19LGludGVyc2VjdHM6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5pbnRlcnNlY3RzKGUpfX0sa2UuREVGQVVMVF9OT0RFX0NBUEFDSVRZPTEwLGUoVWUucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVZX19KSxVZS5yZWxhdGl2ZVNpZ249ZnVuY3Rpb24odCxlKXtyZXR1cm4gZT50Py0xOnQ+ZT8xOjB9LFVlLmNvbXBhcmU9ZnVuY3Rpb24odCxlLG4pe2lmKGUuZXF1YWxzMkQobikpcmV0dXJuIDA7dmFyIGk9VWUucmVsYXRpdmVTaWduKGUueCxuLngpLHI9VWUucmVsYXRpdmVTaWduKGUueSxuLnkpO3N3aXRjaCh0KXtjYXNlIDA6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShpLHIpO2Nhc2UgMTpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKHIsaSk7Y2FzZSAyOnJldHVybiBVZS5jb21wYXJlVmFsdWUociwtaSk7Y2FzZSAzOnJldHVybiBVZS5jb21wYXJlVmFsdWUoLWkscik7Y2FzZSA0OnJldHVybiBVZS5jb21wYXJlVmFsdWUoLWksLXIpO2Nhc2UgNTpyZXR1cm4gVWUuY29tcGFyZVZhbHVlKC1yLC1pKTtjYXNlIDY6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZSgtcixpKTtjYXNlIDc6cmV0dXJuIFVlLmNvbXBhcmVWYWx1ZShpLC1yKX1yZXR1cm4gZi5zaG91bGROZXZlclJlYWNoSGVyZShcImludmFsaWQgb2N0YW50IHZhbHVlXCIpLDB9LFVlLmNvbXBhcmVWYWx1ZT1mdW5jdGlvbih0LGUpe3JldHVybiAwPnQ/LTE6dD4wPzE6MD5lPy0xOmU+MD8xOjB9LGUoWGUucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29vcmR9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQodGhpcy5jb29yZCksdC5wcmludChcIiBzZWcgIyA9IFwiK3RoaXMuc2VnbWVudEluZGV4KX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PGUuc2VnbWVudEluZGV4Py0xOnRoaXMuc2VnbWVudEluZGV4PmUuc2VnbWVudEluZGV4PzE6dGhpcy5jb29yZC5lcXVhbHMyRChlLmNvb3JkKT8wOlVlLmNvbXBhcmUodGhpcy5zZWdtZW50T2N0YW50LHRoaXMuY29vcmQsZS5jb29yZCl9LGlzRW5kUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIDAhPT10aGlzLnNlZ21lbnRJbmRleHx8dGhpcy5faXNJbnRlcmlvcj90aGlzLnNlZ21lbnRJbmRleD09PXQ6ITB9LGlzSW50ZXJpb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNJbnRlcmlvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhlfX0pLGUoSGUucHJvdG90eXBlLHtnZXRTcGxpdENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IE47dGhpcy5hZGRFbmRwb2ludHMoKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpLG49ZS5uZXh0KCk7ZS5oYXNOZXh0KCk7KXt2YXIgaT1lLm5leHQoKTt0aGlzLmFkZEVkZ2VDb29yZGluYXRlcyhuLGksdCksbj1pfXJldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9LGFkZENvbGxhcHNlZE5vZGVzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7dGhpcy5maW5kQ29sbGFwc2VzRnJvbUluc2VydGVkTm9kZXModCksdGhpcy5maW5kQ29sbGFwc2VzRnJvbUV4aXN0aW5nVmVydGljZXModCk7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLmludFZhbHVlKCk7dGhpcy5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUobiksbil9fSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGZpbmRDb2xsYXBzZXNGcm9tRXhpc3RpbmdWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZS5zaXplKCktMjtlKyspe3ZhciBuPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUpLGk9KHRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUrMSksdGhpcy5lZGdlLmdldENvb3JkaW5hdGUoZSsyKSk7bi5lcXVhbHMyRChpKSYmdC5hZGQobmV3IGIoZSsxKSl9fSxhZGRFZGdlQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUuc2VnbWVudEluZGV4LXQuc2VnbWVudEluZGV4KzIscj10aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZShlLnNlZ21lbnRJbmRleCkscz1lLmlzSW50ZXJpb3IoKXx8IWUuY29vcmQuZXF1YWxzMkQocik7c3x8aS0tO24uYWRkKG5ldyBnKHQuY29vcmQpLCExKTtmb3IodmFyIG89dC5zZWdtZW50SW5kZXgrMTtvPD1lLnNlZ21lbnRJbmRleDtvKyspbi5hZGQodGhpcy5lZGdlLmdldENvb3JkaW5hdGUobykpO3MmJm4uYWRkKG5ldyBnKGUuY29vcmQpKX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LGFkZFNwbGl0RWRnZXM6ZnVuY3Rpb24odCl7dGhpcy5hZGRFbmRwb2ludHMoKSx0aGlzLmFkZENvbGxhcHNlZE5vZGVzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCkscj10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLGkpO3QuYWRkKHIpLG49aX19LGZpbmRDb2xsYXBzZUluZGV4OmZ1bmN0aW9uKHQsZSxuKXtpZighdC5jb29yZC5lcXVhbHMyRChlLmNvb3JkKSlyZXR1cm4hMTt2YXIgaT1lLnNlZ21lbnRJbmRleC10LnNlZ21lbnRJbmRleDtyZXR1cm4gZS5pc0ludGVyaW9yKCl8fGktLSwxPT09aT8oblswXT10LnNlZ21lbnRJbmRleCsxLCEwKTohMX0sZmluZENvbGxhcHNlc0Zyb21JbnNlcnRlZE5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkoMSkuZmlsbChudWxsKSxuPXRoaXMuaXRlcmF0b3IoKSxpPW4ubmV4dCgpO24uaGFzTmV4dCgpOyl7dmFyIHI9bi5uZXh0KCkscz10aGlzLmZpbmRDb2xsYXBzZUluZGV4KGkscixlKTtzJiZ0LmFkZChuZXcgYihlWzBdKSksaT1yfX0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2V9LGFkZEVuZHBvaW50czpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5zaXplKCktMTt0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZSgwKSwwKSx0aGlzLmFkZCh0aGlzLmVkZ2UuZ2V0Q29vcmRpbmF0ZSh0KSx0KX0sY3JlYXRlU3BsaXRFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixpPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGUuc2VnbWVudEluZGV4KSxyPWUuaXNJbnRlcmlvcigpfHwhZS5jb29yZC5lcXVhbHMyRChpKTtyfHxuLS07dmFyIHM9bmV3IEFycmF5KG4pLmZpbGwobnVsbCksbz0wO3NbbysrXT1uZXcgZyh0LmNvb3JkKTtmb3IodmFyIGE9dC5zZWdtZW50SW5kZXgrMTthPD1lLnNlZ21lbnRJbmRleDthKyspc1tvKytdPXRoaXMuZWRnZS5nZXRDb29yZGluYXRlKGEpO3JldHVybiByJiYoc1tvXT1uZXcgZyhlLmNvb3JkKSksbmV3IEtlKHMsdGhpcy5lZGdlLmdldERhdGEoKSl9LGFkZDpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBYZSh0aGlzLmVkZ2UsdCxlLHRoaXMuZWRnZS5nZXRTZWdtZW50T2N0YW50KGUpKSxpPXRoaXMubm9kZU1hcC5nZXQobik7cmV0dXJuIG51bGwhPT1pPyhmLmlzVHJ1ZShpLmNvb3JkLmVxdWFsczJEKHQpLFwiRm91bmQgZXF1YWwgbm9kZXMgd2l0aCBkaWZmZXJlbnQgY29vcmRpbmF0ZXNcIiksaSk6KHRoaXMubm9kZU1hcC5wdXQobixuKSxuKX0sY2hlY2tTcGxpdEVkZ2VzQ29ycmVjdG5lc3M6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlLmdldENvb3JkaW5hdGVzKCksbj10LmdldCgwKSxpPW4uZ2V0Q29vcmRpbmF0ZSgwKTtpZighaS5lcXVhbHMyRChlWzBdKSl0aHJvdyBuZXcgbChcImJhZCBzcGxpdCBlZGdlIHN0YXJ0IHBvaW50IGF0IFwiK2kpO3ZhciByPXQuZ2V0KHQuc2l6ZSgpLTEpLHM9ci5nZXRDb29yZGluYXRlcygpLG89c1tzLmxlbmd0aC0xXTtpZighby5lcXVhbHMyRChlW2UubGVuZ3RoLTFdKSl0aHJvdyBuZXcgbChcImJhZCBzcGxpdCBlZGdlIGVuZCBwb2ludCBhdCBcIitvKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSGV9fSksZShXZS5wcm90b3R5cGUse25leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuY3Vyck5vZGU/KHRoaXMuY3Vyck5vZGU9dGhpcy5uZXh0Tm9kZSx0aGlzLmN1cnJTZWdJbmRleD10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleCx0aGlzLnJlYWROZXh0Tm9kZSgpLHRoaXMuY3Vyck5vZGUpOm51bGw9PT10aGlzLm5leHROb2RlP251bGw6dGhpcy5uZXh0Tm9kZS5zZWdtZW50SW5kZXg9PT10aGlzLmN1cnJOb2RlLnNlZ21lbnRJbmRleD8odGhpcy5jdXJyTm9kZT10aGlzLm5leHROb2RlLHRoaXMuY3VyclNlZ0luZGV4PXRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4LHRoaXMucmVhZE5leHROb2RlKCksdGhpcy5jdXJyTm9kZSk6KHRoaXMubmV4dE5vZGUuc2VnbWVudEluZGV4PnRoaXMuY3Vyck5vZGUuc2VnbWVudEluZGV4LG51bGwpfSxyZW1vdmU6ZnVuY3Rpb24oKXt0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSl9LGhhc05leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMubmV4dE5vZGV9LHJlYWROZXh0Tm9kZTpmdW5jdGlvbigpe3RoaXMubm9kZUl0Lmhhc05leHQoKT90aGlzLm5leHROb2RlPXRoaXMubm9kZUl0Lm5leHQoKTp0aGlzLm5leHROb2RlPW51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3BdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXZX19KSxlKGplLnByb3RvdHlwZSx7YWRkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltiZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGplfX0pLGUoS2UucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c30sc2l6ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0cy5sZW5ndGh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucHRzW3RdfSxpc0Nsb3NlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0c1swXS5lcXVhbHModGhpcy5wdHNbdGhpcy5wdHMubGVuZ3RoLTFdKX0sZ2V0U2VnbWVudE9jdGFudDpmdW5jdGlvbih0KXtyZXR1cm4gdD09PXRoaXMucHRzLmxlbmd0aC0xPy0xOnRoaXMuc2FmZU9jdGFudCh0aGlzLmdldENvb3JkaW5hdGUodCksdGhpcy5nZXRDb29yZGluYXRlKHQrMSkpfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxzYWZlT2N0YW50OmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuZXF1YWxzMkQoZSk/MDpQZS5vY3RhbnQodCxlKX0sZ2V0RGF0YTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRhdGF9LGFkZEludGVyc2VjdGlvbjpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07dGhpcy5hZGRJbnRlcnNlY3Rpb25Ob2RlKHQsZSl9ZWxzZSBpZig0PT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9KGFyZ3VtZW50c1syXSxhcmd1bWVudHNbM10pLHM9bmV3IGcobi5nZXRJbnRlcnNlY3Rpb24ocikpO3RoaXMuYWRkSW50ZXJzZWN0aW9uKHMsaSl9fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiBzZS50b0xpbmVTdHJpbmcobmV3IEd0KHRoaXMucHRzKSl9LGdldE5vZGVMaXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZUxpc3R9LGFkZEludGVyc2VjdGlvbk5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLGk9bisxO2lmKGk8dGhpcy5wdHMubGVuZ3RoKXt2YXIgcj10aGlzLnB0c1tpXTt0LmVxdWFsczJEKHIpJiYobj1pKX12YXIgcz10aGlzLm5vZGVMaXN0LmFkZCh0LG4pO3JldHVybiBzfSxhZGRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuZ2V0SW50ZXJzZWN0aW9uTnVtKCk7aSsrKXRoaXMuYWRkSW50ZXJzZWN0aW9uKHQsZSxuLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltqZV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlfX0pLEtlLmdldE5vZGVkU3Vic3RyaW5ncz1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSTtyZXR1cm4gS2UuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQsZSksZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9bi5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7cy5nZXROb2RlTGlzdCgpLmFkZFNwbGl0RWRnZXMoaSl9fSxlKFplLnByb3RvdHlwZSx7b3ZlcmxhcDpmdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF0sYXJndW1lbnRzWzFdfWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0LmdldExpbmVTZWdtZW50KGUsdGhpcy5vdmVybGFwU2VnMSksbi5nZXRMaW5lU2VnbWVudChpLHRoaXMub3ZlcmxhcFNlZzIpLHRoaXMub3ZlcmxhcCh0aGlzLm92ZXJsYXBTZWcxLHRoaXMub3ZlcmxhcFNlZzIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWmV9fSksZShRZS5wcm90b3R5cGUse2dldExpbmVTZWdtZW50OmZ1bmN0aW9uKHQsZSl7ZS5wMD10aGlzLnB0c1t0XSxlLnAxPXRoaXMucHRzW3QrMV19LGNvbXB1dGVTZWxlY3Q6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5wdHNbZV0scz10aGlzLnB0c1tuXTtpZihpLnRlbXBFbnYxLmluaXQocixzKSxuLWU9PT0xKXJldHVybiBpLnNlbGVjdCh0aGlzLGUpLG51bGw7aWYoIXQuaW50ZXJzZWN0cyhpLnRlbXBFbnYxKSlyZXR1cm4gbnVsbDt2YXIgbz1NYXRoLnRydW5jKChlK24pLzIpO1xubz5lJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxlLG8saSksbj5vJiZ0aGlzLmNvbXB1dGVTZWxlY3QodCxvLG4saSl9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBBcnJheSh0aGlzLmVuZC10aGlzLnN0YXJ0KzEpLmZpbGwobnVsbCksZT0wLG49dGhpcy5zdGFydDtuPD10aGlzLmVuZDtuKyspdFtlKytdPXRoaXMucHRzW25dO3JldHVybiB0fSxjb21wdXRlT3ZlcmxhcHM6ZnVuY3Rpb24odCxlKXt0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHRoaXMuc3RhcnQsdGhpcy5lbmQsdCx0LnN0YXJ0LHQuZW5kLGUpfSxzZXRJZDpmdW5jdGlvbih0KXt0aGlzLmlkPXR9LHNlbGVjdDpmdW5jdGlvbih0LGUpe3RoaXMuY29tcHV0ZVNlbGVjdCh0LHRoaXMuc3RhcnQsdGhpcy5lbmQsZSl9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXt2YXIgdD10aGlzLnB0c1t0aGlzLnN0YXJ0XSxlPXRoaXMucHRzW3RoaXMuZW5kXTt0aGlzLmVudj1uZXcgQyh0LGUpfXJldHVybiB0aGlzLmVudn0sZ2V0RW5kSW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmR9LGdldFN0YXJ0SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydH0sZ2V0Q29udGV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnRleHR9LGdldElkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaWR9LGNvbXB1dGVPdmVybGFwc0ludGVybmFsOmZ1bmN0aW9uKHQsZSxuLGkscixzKXt2YXIgbz10aGlzLnB0c1t0XSxhPXRoaXMucHRzW2VdLHU9bi5wdHNbaV0sbD1uLnB0c1tyXTtpZihlLXQ9PT0xJiZyLWk9PT0xKXJldHVybiBzLm92ZXJsYXAodGhpcyx0LG4saSksbnVsbDtpZihzLnRlbXBFbnYxLmluaXQobyxhKSxzLnRlbXBFbnYyLmluaXQodSxsKSwhcy50ZW1wRW52MS5pbnRlcnNlY3RzKHMudGVtcEVudjIpKXJldHVybiBudWxsO3ZhciBoPU1hdGgudHJ1bmMoKHQrZSkvMiksYz1NYXRoLnRydW5jKChpK3IpLzIpO2g+dCYmKGM+aSYmdGhpcy5jb21wdXRlT3ZlcmxhcHNJbnRlcm5hbCh0LGgsbixpLGMscykscj5jJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKHQsaCxuLGMscixzKSksZT5oJiYoYz5pJiZ0aGlzLmNvbXB1dGVPdmVybGFwc0ludGVybmFsKGgsZSxuLGksYyxzKSxyPmMmJnRoaXMuY29tcHV0ZU92ZXJsYXBzSW50ZXJuYWwoaCxlLG4sYyxyLHMpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUWV9fSksZShKZS5wcm90b3R5cGUse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEplfX0pLEplLmlzTm9ydGhlcm49ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1KZS5ORXx8dD09PUplLk5XfSxKZS5pc09wcG9zaXRlPWZ1bmN0aW9uKHQsZSl7aWYodD09PWUpcmV0dXJuITE7dmFyIG49KHQtZSs0KSU0O3JldHVybiAyPT09bn0sSmUuY29tbW9uSGFsZlBsYW5lPWZ1bmN0aW9uKHQsZSl7aWYodD09PWUpcmV0dXJuIHQ7dmFyIG49KHQtZSs0KSU0O2lmKDI9PT1uKXJldHVybi0xO3ZhciBpPWU+dD90OmUscj10PmU/dDplO3JldHVybiAwPT09aSYmMz09PXI/MzppfSxKZS5pc0luSGFsZlBsYW5lPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU9PT1KZS5TRT90PT09SmUuU0V8fHQ9PT1KZS5TVzp0PT09ZXx8dD09PWUrMX0sSmUucXVhZHJhbnQ9ZnVuY3Rpb24oKXtpZihcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzBdJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07aWYoMD09PXQmJjA9PT1lKXRocm93IG5ldyBpKFwiQ2Fubm90IGNvbXB1dGUgdGhlIHF1YWRyYW50IGZvciBwb2ludCAoIFwiK3QrXCIsIFwiK2UrXCIgKVwiKTtyZXR1cm4gdD49MD9lPj0wP0plLk5FOkplLlNFOmU+PTA/SmUuTlc6SmUuU1d9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnJiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIGcpe3ZhciBuPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTtpZihyLng9PT1uLngmJnIueT09PW4ueSl0aHJvdyBuZXcgaShcIkNhbm5vdCBjb21wdXRlIHRoZSBxdWFkcmFudCBmb3IgdHdvIGlkZW50aWNhbCBwb2ludHMgXCIrbik7cmV0dXJuIHIueD49bi54P3IueT49bi55P0plLk5FOkplLlNFOnIueT49bi55P0plLk5XOkplLlNXfX0sSmUuTkU9MCxKZS5OVz0xLEplLlNXPTIsSmUuU0U9MyxlKCRlLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJGV9fSksJGUuZ2V0Q2hhaW5TdGFydEluZGljZXM9ZnVuY3Rpb24odCl7dmFyIGU9MCxuPW5ldyBJO24uYWRkKG5ldyBiKGUpKTtkb3t2YXIgaT0kZS5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgYihpKSksZT1pfXdoaWxlKGU8dC5sZW5ndGgtMSk7dmFyIHI9JGUudG9JbnRBcnJheShuKTtyZXR1cm4gcn0sJGUuZmluZENoYWluRW5kPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWU7bjx0Lmxlbmd0aC0xJiZ0W25dLmVxdWFsczJEKHRbbisxXSk7KW4rKztpZihuPj10Lmxlbmd0aC0xKXJldHVybiB0Lmxlbmd0aC0xO2Zvcih2YXIgaT1KZS5xdWFkcmFudCh0W25dLHRbbisxXSkscj1lKzE7cjx0Lmxlbmd0aDspe2lmKCF0W3ItMV0uZXF1YWxzMkQodFtyXSkpe3ZhciBzPUplLnF1YWRyYW50KHRbci0xXSx0W3JdKTtpZihzIT09aSlicmVha31yKyt9cmV0dXJuIHItMX0sJGUuZ2V0Q2hhaW5zPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gJGUuZ2V0Q2hhaW5zKHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1uZXcgSSxyPSRlLmdldENoYWluU3RhcnRJbmRpY2VzKGUpLHM9MDtzPHIubGVuZ3RoLTE7cysrKXt2YXIgbz1uZXcgUWUoZSxyW3NdLHJbcysxXSxuKTtpLmFkZChvKX1yZXR1cm4gaX19LCRlLnRvSW50QXJyYXk9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjxlLmxlbmd0aDtuKyspZVtuXT10LmdldChuKS5pbnRWYWx1ZSgpO3JldHVybiBlfSxlKHRuLnByb3RvdHlwZSx7Y29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe30sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB0bn19KSxlKGVuLnByb3RvdHlwZSx7c2V0U2VnbWVudEludGVyc2VjdG9yOmZ1bmN0aW9uKHQpe3RoaXMuc2VnSW50PXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3RuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZW59fSksaChubixlbiksZShubi5wcm90b3R5cGUse2dldE1vbm90b25lQ2hhaW5zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubW9ub0NoYWluc30sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7cmV0dXJuIEtlLmdldE5vZGVkU3Vic3RyaW5ncyh0aGlzLm5vZGVkU2VnU3RyaW5ncyl9LGdldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXh9LGFkZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9JGUuZ2V0Q2hhaW5zKHQuZ2V0Q29vcmRpbmF0ZXMoKSx0KSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0SWQodGhpcy5pZENvdW50ZXIrKyksdGhpcy5pbmRleC5pbnNlcnQoaS5nZXRFbnZlbG9wZSgpLGkpLHRoaXMubW9ub0NoYWlucy5hZGQoaSl9fSxjb21wdXRlTm9kZXM6ZnVuY3Rpb24odCl7dGhpcy5ub2RlZFNlZ1N0cmluZ3M9dDtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmFkZChlLm5leHQoKSk7dGhpcy5pbnRlcnNlY3RDaGFpbnMoKX0saW50ZXJzZWN0Q2hhaW5zOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBybih0aGlzLnNlZ0ludCksZT10aGlzLm1vbm9DaGFpbnMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9dGhpcy5pbmRleC5xdWVyeShuLmdldEVudmVsb3BlKCkpLHI9aS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYocy5nZXRJZCgpPm4uZ2V0SWQoKSYmKG4uY29tcHV0ZU92ZXJsYXBzKHMsdCksdGhpcy5uT3ZlcmxhcHMrKyksdGhpcy5zZWdJbnQuaXNEb25lKCkpcmV0dXJuIG51bGx9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBubn19KSxoKHJuLFplKSxlKHJuLnByb3RvdHlwZSx7b3ZlcmxhcDpmdW5jdGlvbigpe2lmKDQhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBaZS5wcm90b3R5cGUub3ZlcmxhcC5hcHBseSh0aGlzLGFyZ3VtZW50cyk7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdLGk9YXJndW1lbnRzWzNdLHI9dC5nZXRDb250ZXh0KCkscz1uLmdldENvbnRleHQoKTt0aGlzLnNpLnByb2Nlc3NJbnRlcnNlY3Rpb25zKHIsZSxzLGkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBybn19KSxubi5TZWdtZW50T3ZlcmxhcEFjdGlvbj1ybixoKHNuLGwpLGUoc24ucHJvdG90eXBlLHtnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNufX0pLHNuLm1zZ1dpdGhDb29yZD1mdW5jdGlvbih0LGUpe3JldHVybiBudWxsIT09ZT90K1wiIFsgXCIrZStcIiBdXCI6dH0sZShvbi5wcm90b3R5cGUse3Byb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe30saXNEb25lOmZ1bmN0aW9uKCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBvbn19KSxlKGFuLnByb3RvdHlwZSx7Z2V0SW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0sc2V0Q2hlY2tFbmRTZWdtZW50c09ubHk6ZnVuY3Rpb24odCl7dGhpcy5pc0NoZWNrRW5kU2VnbWVudHNPbmx5PXR9LGdldEludGVyc2VjdGlvblNlZ21lbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50U2VnbWVudHN9LGNvdW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJzZWN0aW9uQ291bnR9LGdldEludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcnNlY3Rpb25zfSxzZXRGaW5kQWxsSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0KXt0aGlzLmZpbmRBbGxJbnRlcnNlY3Rpb25zPXR9LHNldEtlZXBJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQpe3RoaXMua2VlcEludGVyc2VjdGlvbnM9dH0scHJvY2Vzc0ludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlLG4saSl7aWYoIXRoaXMuZmluZEFsbEludGVyc2VjdGlvbnMmJnRoaXMuaGFzSW50ZXJzZWN0aW9uKCkpcmV0dXJuIG51bGw7aWYodD09PW4mJmU9PT1pKXJldHVybiBudWxsO2lmKHRoaXMuaXNDaGVja0VuZFNlZ21lbnRzT25seSl7dmFyIHI9dGhpcy5pc0VuZFNlZ21lbnQodCxlKXx8dGhpcy5pc0VuZFNlZ21lbnQobixpKTtpZighcilyZXR1cm4gbnVsbH12YXIgcz10LmdldENvb3JkaW5hdGVzKClbZV0sbz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSx1PW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihzLG8sYSx1KSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSYmKHRoaXMuaW50U2VnbWVudHM9bmV3IEFycmF5KDQpLmZpbGwobnVsbCksdGhpcy5pbnRTZWdtZW50c1swXT1zLHRoaXMuaW50U2VnbWVudHNbMV09byx0aGlzLmludFNlZ21lbnRzWzJdPWEsdGhpcy5pbnRTZWdtZW50c1szXT11LHRoaXMuaW50ZXJpb3JJbnRlcnNlY3Rpb249dGhpcy5saS5nZXRJbnRlcnNlY3Rpb24oMCksdGhpcy5rZWVwSW50ZXJzZWN0aW9ucyYmdGhpcy5pbnRlcnNlY3Rpb25zLmFkZCh0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9uKSx0aGlzLmludGVyc2VjdGlvbkNvdW50KyspfSxpc0VuZFNlZ21lbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gMD09PWU/ITA6ZT49dC5zaXplKCktMn0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz8hMTpudWxsIT09dGhpcy5pbnRlcmlvckludGVyc2VjdGlvbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bb25dfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBhbn19KSxhbi5jcmVhdGVBbGxJbnRlcnNlY3Rpb25zRmluZGVyPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhbih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZX0sYW4uY3JlYXRlQW55SW50ZXJzZWN0aW9uRmluZGVyPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgYW4odCl9LGFuLmNyZWF0ZUludGVyc2VjdGlvbkNvdW50ZXI9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGFuKHQpO3JldHVybiBlLnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKCEwKSxlLnNldEtlZXBJbnRlcnNlY3Rpb25zKCExKSxlfSxlKHVuLnByb3RvdHlwZSx7ZXhlY3V0ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5zZWdJbnQ/bnVsbDp2b2lkIHRoaXMuY2hlY2tJbnRlcmlvckludGVyc2VjdGlvbnMoKX0sZ2V0SW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ0ludC5nZXRJbnRlcnNlY3Rpb25zKCl9LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5leGVjdXRlKCksdGhpcy5faXNWYWxpZH0sc2V0RmluZEFsbEludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCl7dGhpcy5maW5kQWxsSW50ZXJzZWN0aW9ucz10fSxjaGVja0ludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe3RoaXMuX2lzVmFsaWQ9ITAsdGhpcy5zZWdJbnQ9bmV3IGFuKHRoaXMubGkpLHRoaXMuc2VnSW50LnNldEZpbmRBbGxJbnRlcnNlY3Rpb25zKHRoaXMuZmluZEFsbEludGVyc2VjdGlvbnMpO3ZhciB0PW5ldyBubjtyZXR1cm4gdC5zZXRTZWdtZW50SW50ZXJzZWN0b3IodGhpcy5zZWdJbnQpLHQuY29tcHV0ZU5vZGVzKHRoaXMuc2VnU3RyaW5ncyksdGhpcy5zZWdJbnQuaGFzSW50ZXJzZWN0aW9uKCk/KHRoaXMuX2lzVmFsaWQ9ITEsbnVsbCk6dm9pZCAwfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7aWYodGhpcy5leGVjdXRlKCksIXRoaXMuX2lzVmFsaWQpdGhyb3cgbmV3IHNuKHRoaXMuZ2V0RXJyb3JNZXNzYWdlKCksdGhpcy5zZWdJbnQuZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl9LGdldEVycm9yTWVzc2FnZTpmdW5jdGlvbigpe2lmKHRoaXMuX2lzVmFsaWQpcmV0dXJuXCJubyBpbnRlcnNlY3Rpb25zIGZvdW5kXCI7dmFyIHQ9dGhpcy5zZWdJbnQuZ2V0SW50ZXJzZWN0aW9uU2VnbWVudHMoKTtyZXR1cm5cImZvdW5kIG5vbi1ub2RlZCBpbnRlcnNlY3Rpb24gYmV0d2VlbiBcIitzZS50b0xpbmVTdHJpbmcodFswXSx0WzFdKStcIiBhbmQgXCIrc2UudG9MaW5lU3RyaW5nKHRbMl0sdFszXSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHVufX0pLHVuLmNvbXB1dGVJbnRlcnNlY3Rpb25zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyB1bih0KTtyZXR1cm4gZS5zZXRGaW5kQWxsSW50ZXJzZWN0aW9ucyghMCksZS5pc1ZhbGlkKCksZS5nZXRJbnRlcnNlY3Rpb25zKCl9LGUobG4ucHJvdG90eXBlLHtjaGVja1ZhbGlkOmZ1bmN0aW9uKCl7dGhpcy5udi5jaGVja1ZhbGlkKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxufX0pLGxuLnRvU2VnbWVudFN0cmluZ3M9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IE9lKGkuZ2V0Q29vcmRpbmF0ZXMoKSxpKSl9cmV0dXJuIGV9LGxuLmNoZWNrVmFsaWQ9ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGxuKHQpO2UuY2hlY2tWYWxpZCgpfSxlKGhuLnByb3RvdHlwZSx7bWFwOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXRoaXMubWFwT3AubWFwKHQuZ2V0R2VvbWV0cnlOKG4pKTtpLmlzRW1wdHkoKXx8ZS5hZGQoaSl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoZSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBobn19KSxobi5tYXA9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaG4oZSk7cmV0dXJuIG4ubWFwKHQpfSxlKGNuLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY259fSksY24ub3Bwb3NpdGU9ZnVuY3Rpb24odCl7cmV0dXJuIHQ9PT1jbi5MRUZUP2NuLlJJR0hUOnQ9PT1jbi5SSUdIVD9jbi5MRUZUOnR9LGNuLk9OPTAsY24uTEVGVD0xLGNuLlJJR0hUPTIsZShmbi5wcm90b3R5cGUse3NldEFsbExvY2F0aW9uczpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPXR9LGlzTnVsbDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF0hPT1MLk5PTkUpcmV0dXJuITE7cmV0dXJuITB9LHNldEFsbExvY2F0aW9uc0lmTnVsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMubG9jYXRpb24ubGVuZ3RoO2UrKyl0aGlzLmxvY2F0aW9uW2VdPT09TC5OT05FJiYodGhpcy5sb2NhdGlvbltlXT10KX0saXNMaW5lOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxvY2F0aW9uLmxlbmd0aH0sbWVyZ2U6ZnVuY3Rpb24odCl7aWYodC5sb2NhdGlvbi5sZW5ndGg+dGhpcy5sb2NhdGlvbi5sZW5ndGgpe3ZhciBlPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO2VbY24uT05dPXRoaXMubG9jYXRpb25bY24uT05dLGVbY24uTEVGVF09TC5OT05FLGVbY24uUklHSFRdPUwuTk9ORSx0aGlzLmxvY2F0aW9uPWV9Zm9yKHZhciBuPTA7bjx0aGlzLmxvY2F0aW9uLmxlbmd0aDtuKyspdGhpcy5sb2NhdGlvbltuXT09PUwuTk9ORSYmbjx0LmxvY2F0aW9uLmxlbmd0aCYmKHRoaXMubG9jYXRpb25bbl09dC5sb2NhdGlvbltuXSl9LGdldExvY2F0aW9uczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxvY2F0aW9ufSxmbGlwOmZ1bmN0aW9uKCl7aWYodGhpcy5sb2NhdGlvbi5sZW5ndGg8PTEpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5sb2NhdGlvbltjbi5MRUZUXTt0aGlzLmxvY2F0aW9uW2NuLkxFRlRdPXRoaXMubG9jYXRpb25bY24uUklHSFRdLHRoaXMubG9jYXRpb25bY24uUklHSFRdPXR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjEmJnQuYXBwZW5kKEwudG9Mb2NhdGlvblN5bWJvbCh0aGlzLmxvY2F0aW9uW2NuLkxFRlRdKSksdC5hcHBlbmQoTC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bY24uT05dKSksdGhpcy5sb2NhdGlvbi5sZW5ndGg+MSYmdC5hcHBlbmQoTC50b0xvY2F0aW9uU3ltYm9sKHRoaXMubG9jYXRpb25bY24uUklHSFRdKSksdC50b1N0cmluZygpfSxzZXRMb2NhdGlvbnM6ZnVuY3Rpb24odCxlLG4pe3RoaXMubG9jYXRpb25bY24uT05dPXQsdGhpcy5sb2NhdGlvbltjbi5MRUZUXT1lLHRoaXMubG9jYXRpb25bY24uUklHSFRdPW59LGdldDpmdW5jdGlvbih0KXtyZXR1cm4gdDx0aGlzLmxvY2F0aW9uLmxlbmd0aD90aGlzLmxvY2F0aW9uW3RdOkwuTk9ORX0saXNBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubG9jYXRpb24ubGVuZ3RoPjF9LGlzQW55TnVsbDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wO3Q8dGhpcy5sb2NhdGlvbi5sZW5ndGg7dCsrKWlmKHRoaXMubG9jYXRpb25bdF09PT1MLk5PTkUpcmV0dXJuITA7cmV0dXJuITF9LHNldExvY2F0aW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldExvY2F0aW9uKGNuLk9OLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTt0aGlzLmxvY2F0aW9uW2VdPW59fSxpbml0OmZ1bmN0aW9uKHQpe3RoaXMubG9jYXRpb249bmV3IEFycmF5KHQpLmZpbGwobnVsbCksdGhpcy5zZXRBbGxMb2NhdGlvbnMoTC5OT05FKX0saXNFcXVhbE9uU2lkZTpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmxvY2F0aW9uW2VdPT09dC5sb2NhdGlvbltlXX0sYWxsUG9zaXRpb25zRXF1YWw6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0aGlzLmxvY2F0aW9uLmxlbmd0aDtlKyspaWYodGhpcy5sb2NhdGlvbltlXSE9PXQpcmV0dXJuITE7cmV0dXJuITB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZufX0pLGUoZ24ucHJvdG90eXBlLHtnZXRHZW9tZXRyeUNvdW50OmZ1bmN0aW9uKCl7dmFyIHQ9MDtyZXR1cm4gdGhpcy5lbHRbMF0uaXNOdWxsKCl8fHQrKyx0aGlzLmVsdFsxXS5pc051bGwoKXx8dCsrLHR9LHNldEFsbExvY2F0aW9uczpmdW5jdGlvbih0LGUpe3RoaXMuZWx0W3RdLnNldEFsbExvY2F0aW9ucyhlKX0saXNOdWxsOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVsdFt0XS5pc051bGwoKX0sc2V0QWxsTG9jYXRpb25zSWZOdWxsOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNldEFsbExvY2F0aW9uc0lmTnVsbCgwLHQpLHRoaXMuc2V0QWxsTG9jYXRpb25zSWZOdWxsKDEsdCl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3RoaXMuZWx0W2VdLnNldEFsbExvY2F0aW9uc0lmTnVsbChuKX19LGlzTGluZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNMaW5lKCl9LG1lcmdlOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wOzI+ZTtlKyspbnVsbD09PXRoaXMuZWx0W2VdJiZudWxsIT09dC5lbHRbZV0/dGhpcy5lbHRbZV09bmV3IGZuKHQuZWx0W2VdKTp0aGlzLmVsdFtlXS5tZXJnZSh0LmVsdFtlXSl9LGZsaXA6ZnVuY3Rpb24oKXt0aGlzLmVsdFswXS5mbGlwKCksdGhpcy5lbHRbMV0uZmxpcCgpfSxnZXRMb2NhdGlvbjpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZWx0W3RdLmdldChjbi5PTil9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5lbHRbZV0uZ2V0KG4pfX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgUDtyZXR1cm4gbnVsbCE9PXRoaXMuZWx0WzBdJiYodC5hcHBlbmQoXCJBOlwiKSx0LmFwcGVuZCh0aGlzLmVsdFswXS50b1N0cmluZygpKSksbnVsbCE9PXRoaXMuZWx0WzFdJiYodC5hcHBlbmQoXCIgQjpcIiksdC5hcHBlbmQodGhpcy5lbHRbMV0udG9TdHJpbmcoKSkpLHQudG9TdHJpbmcoKX0saXNBcmVhOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMuZWx0WzBdLmlzQXJlYSgpfHx0aGlzLmVsdFsxXS5pc0FyZWEoKTtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVsdFt0XS5pc0FyZWEoKX19LGlzQW55TnVsbDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5lbHRbdF0uaXNBbnlOdWxsKCl9LHNldExvY2F0aW9uOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTt0aGlzLmVsdFt0XS5zZXRMb2NhdGlvbihjbi5PTixlKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07dGhpcy5lbHRbbl0uc2V0TG9jYXRpb24oaSxyKX19LGlzRXF1YWxPblNpZGU6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbHRbMF0uaXNFcXVhbE9uU2lkZSh0LmVsdFswXSxlKSYmdGhpcy5lbHRbMV0uaXNFcXVhbE9uU2lkZSh0LmVsdFsxXSxlKX0sYWxsUG9zaXRpb25zRXF1YWw6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5lbHRbdF0uYWxsUG9zaXRpb25zRXF1YWwoZSl9LHRvTGluZTpmdW5jdGlvbih0KXt0aGlzLmVsdFt0XS5pc0FyZWEoKSYmKHRoaXMuZWx0W3RdPW5ldyBmbih0aGlzLmVsdFt0XS5sb2NhdGlvblswXSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBnbn19KSxnbi50b0xpbmVMYWJlbD1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGduKEwuTk9ORSksbj0wOzI+bjtuKyspZS5zZXRMb2NhdGlvbihuLHQuZ2V0TG9jYXRpb24obikpO3JldHVybiBlfSxlKGRuLnByb3RvdHlwZSx7Y29tcHV0ZVJpbmc6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5yaW5nKXJldHVybiBudWxsO2Zvcih2YXIgdD1uZXcgQXJyYXkodGhpcy5wdHMuc2l6ZSgpKS5maWxsKG51bGwpLGU9MDtlPHRoaXMucHRzLnNpemUoKTtlKyspdFtlXT10aGlzLnB0cy5nZXQoZSk7dGhpcy5yaW5nPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcodCksdGhpcy5faXNIb2xlPWhlLmlzQ0NXKHRoaXMucmluZy5nZXRDb29yZGluYXRlcygpKX0saXNJc29sYXRlZDpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5sYWJlbC5nZXRHZW9tZXRyeUNvdW50KCl9LGNvbXB1dGVQb2ludHM6ZnVuY3Rpb24odCl7dGhpcy5zdGFydERlPXQ7dmFyIGU9dCxuPSEwO2Rve2lmKG51bGw9PT1lKXRocm93IG5ldyBzbihcIkZvdW5kIG51bGwgRGlyZWN0ZWRFZGdlXCIpO2lmKGUuZ2V0RWRnZVJpbmcoKT09PXRoaXMpdGhyb3cgbmV3IHNuKFwiRGlyZWN0ZWQgRWRnZSB2aXNpdGVkIHR3aWNlIGR1cmluZyByaW5nLWJ1aWxkaW5nIGF0IFwiK2UuZ2V0Q29vcmRpbmF0ZSgpKTt0aGlzLmVkZ2VzLmFkZChlKTt2YXIgaT1lLmdldExhYmVsKCk7Zi5pc1RydWUoaS5pc0FyZWEoKSksdGhpcy5tZXJnZUxhYmVsKGkpLHRoaXMuYWRkUG9pbnRzKGUuZ2V0RWRnZSgpLGUuaXNGb3J3YXJkKCksbiksbj0hMSx0aGlzLnNldEVkZ2VSaW5nKGUsdGhpcyksZT10aGlzLmdldE5leHQoZSl9d2hpbGUoZSE9PXRoaXMuc3RhcnREZSl9LGdldExpbmVhclJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaW5nfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLnB0cy5nZXQodCl9LGNvbXB1dGVNYXhOb2RlRGVncmVlOmZ1bmN0aW9uKCl7dGhpcy5tYXhOb2RlRGVncmVlPTA7dmFyIHQ9dGhpcy5zdGFydERlO2Rve3ZhciBlPXQuZ2V0Tm9kZSgpLG49ZS5nZXRFZGdlcygpLmdldE91dGdvaW5nRGVncmVlKHRoaXMpO24+dGhpcy5tYXhOb2RlRGVncmVlJiYodGhpcy5tYXhOb2RlRGVncmVlPW4pLHQ9dGhpcy5nZXROZXh0KHQpfXdoaWxlKHQhPT10aGlzLnN0YXJ0RGUpO3RoaXMubWF4Tm9kZURlZ3JlZSo9Mn0sYWRkUG9pbnRzOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldENvb3JkaW5hdGVzKCk7aWYoZSl7dmFyIHI9MTtuJiYocj0wKTtmb3IodmFyIHM9cjtzPGkubGVuZ3RoO3MrKyl0aGlzLnB0cy5hZGQoaVtzXSl9ZWxzZXt2YXIgcj1pLmxlbmd0aC0yO24mJihyPWkubGVuZ3RoLTEpO2Zvcih2YXIgcz1yO3M+PTA7cy0tKXRoaXMucHRzLmFkZChpW3NdKX19LGlzSG9sZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0hvbGV9LHNldEluUmVzdWx0OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdGFydERlO2RvIHQuZ2V0RWRnZSgpLnNldEluUmVzdWx0KCEwKSx0PXQuZ2V0TmV4dCgpO3doaWxlKHQhPT10aGlzLnN0YXJ0RGUpfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZ2V0TGluZWFyUmluZygpLG49ZS5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIW4uY29udGFpbnModCkpcmV0dXJuITE7aWYoIWhlLmlzUG9pbnRJblJpbmcodCxlLmdldENvb3JkaW5hdGVzKCkpKXJldHVybiExO2Zvcih2YXIgaT10aGlzLmhvbGVzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtpZihyLmNvbnRhaW5zUG9pbnQodCkpcmV0dXJuITF9cmV0dXJuITB9LGFkZEhvbGU6ZnVuY3Rpb24odCl7dGhpcy5ob2xlcy5hZGQodCl9LGlzU2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuc2hlbGx9LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXN9LGdldE1heE5vZGVEZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXhOb2RlRGVncmVlPDAmJnRoaXMuY29tcHV0ZU1heE5vZGVEZWdyZWUoKSx0aGlzLm1heE5vZGVEZWdyZWV9LGdldFNoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2hlbGx9LG1lcmdlTGFiZWw6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VMYWJlbCh0LDApLHRoaXMubWVyZ2VMYWJlbCh0LDEpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPWUuZ2V0TG9jYXRpb24obixjbi5SSUdIVCk7aWYoaT09PUwuTk9ORSlyZXR1cm4gbnVsbDtpZih0aGlzLmxhYmVsLmdldExvY2F0aW9uKG4pPT09TC5OT05FKXJldHVybiB0aGlzLmxhYmVsLnNldExvY2F0aW9uKG4saSksbnVsbH19LHNldFNoZWxsOmZ1bmN0aW9uKHQpe3RoaXMuc2hlbGw9dCxudWxsIT09dCYmdC5hZGRIb2xlKHRoaXMpfSx0b1BvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0aGlzLmhvbGVzLnNpemUoKSkuZmlsbChudWxsKSxuPTA7bjx0aGlzLmhvbGVzLnNpemUoKTtuKyspZVtuXT10aGlzLmhvbGVzLmdldChuKS5nZXRMaW5lYXJSaW5nKCk7dmFyIGk9dC5jcmVhdGVQb2x5Z29uKHRoaXMuZ2V0TGluZWFyUmluZygpLGUpO3JldHVybiBpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBkbn19KSxoKHBuLGRuKSxlKHBuLnByb3RvdHlwZSx7c2V0RWRnZVJpbmc6ZnVuY3Rpb24odCxlKXt0LnNldE1pbkVkZ2VSaW5nKGUpfSxnZXROZXh0OmZ1bmN0aW9uKHQpe3JldHVybiB0LmdldE5leHRNaW4oKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcG59fSksaCh2bixkbiksZSh2bi5wcm90b3R5cGUse2J1aWxkTWluaW1hbFJpbmdzOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEksZT10aGlzLnN0YXJ0RGU7ZG97aWYobnVsbD09PWUuZ2V0TWluRWRnZVJpbmcoKSl7dmFyIG49bmV3IHBuKGUsdGhpcy5nZW9tZXRyeUZhY3RvcnkpO3QuYWRkKG4pfWU9ZS5nZXROZXh0KCl9d2hpbGUoZSE9PXRoaXMuc3RhcnREZSk7cmV0dXJuIHR9LHNldEVkZ2VSaW5nOmZ1bmN0aW9uKHQsZSl7dC5zZXRFZGdlUmluZyhlKX0sbGlua0RpcmVjdGVkRWRnZXNGb3JNaW5pbWFsRWRnZVJpbmdzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zdGFydERlO2Rve3ZhciBlPXQuZ2V0Tm9kZSgpO2UuZ2V0RWRnZXMoKS5saW5rTWluaW1hbERpcmVjdGVkRWRnZXModGhpcyksdD10LmdldE5leHQoKX13aGlsZSh0IT09dGhpcy5zdGFydERlKX0sZ2V0TmV4dDpmdW5jdGlvbih0KXtyZXR1cm4gdC5nZXROZXh0KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHZufX0pLGUobW4ucHJvdG90eXBlLHtzZXRWaXNpdGVkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzVmlzaXRlZD10fSxzZXRJblJlc3VsdDpmdW5jdGlvbih0KXt0aGlzLl9pc0luUmVzdWx0PXR9LGlzQ292ZXJlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0NvdmVyZWR9LGlzQ292ZXJlZFNldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0NvdmVyZWRTZXR9LHNldExhYmVsOmZ1bmN0aW9uKHQpe3RoaXMubGFiZWw9dH0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sc2V0Q292ZXJlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0NvdmVyZWQ9dCx0aGlzLl9pc0NvdmVyZWRTZXQ9ITB9LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe2YuaXNUcnVlKHRoaXMubGFiZWwuZ2V0R2VvbWV0cnlDb3VudCgpPj0yLFwiZm91bmQgcGFydGlhbCBsYWJlbFwiKSx0aGlzLmNvbXB1dGVJTSh0KX0saXNJblJlc3VsdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luUmVzdWx0fSxpc1Zpc2l0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtbn19KSxoKHluLG1uKSxlKHluLnByb3RvdHlwZSx7aXNJbmNpZGVudEVkZ2VJblJlc3VsdDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdldEVkZ2VzKCkuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7aWYoZS5nZXRFZGdlKCkuaXNJblJlc3VsdCgpKXJldHVybiEwfXJldHVybiExfSxpc0lzb2xhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIDE9PT10aGlzLmxhYmVsLmdldEdlb21ldHJ5Q291bnQoKX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkfSxwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJub2RlIFwiK3RoaXMuY29vcmQrXCIgbGJsOiBcIit0aGlzLmxhYmVsKX0sY29tcHV0ZUlNOmZ1bmN0aW9uKHQpe30sY29tcHV0ZU1lcmdlZExvY2F0aW9uOmZ1bmN0aW9uKHQsZSl7dmFyIG49TC5OT05FO2lmKG49dGhpcy5sYWJlbC5nZXRMb2NhdGlvbihlKSwhdC5pc051bGwoZSkpe3ZhciBpPXQuZ2V0TG9jYXRpb24oZSk7biE9PUwuQk9VTkRBUlkmJihuPWkpfXJldHVybiBufSxzZXRMYWJlbDpmdW5jdGlvbigpe2lmKDIhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiBtbi5wcm90b3R5cGUuc2V0TGFiZWwuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtudWxsPT09dGhpcy5sYWJlbD90aGlzLmxhYmVsPW5ldyBnbih0LGUpOnRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxlKX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sbWVyZ2VMYWJlbDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgeW4pe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm1lcmdlTGFiZWwodC5sYWJlbCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGduKWZvcih2YXIgZT1hcmd1bWVudHNbMF0sbj0wOzI+bjtuKyspe3ZhciBpPXRoaXMuY29tcHV0ZU1lcmdlZExvY2F0aW9uKGUsbikscj10aGlzLmxhYmVsLmdldExvY2F0aW9uKG4pO3I9PT1MLk5PTkUmJnRoaXMubGFiZWwuc2V0TG9jYXRpb24obixpKX19LGFkZDpmdW5jdGlvbih0KXt0aGlzLmVkZ2VzLmluc2VydCh0KSx0LnNldE5vZGUodGhpcyl9LHNldExhYmVsQm91bmRhcnk6ZnVuY3Rpb24odCl7aWYobnVsbD09PXRoaXMubGFiZWwpcmV0dXJuIG51bGw7dmFyIGU9TC5OT05FO251bGwhPT10aGlzLmxhYmVsJiYoZT10aGlzLmxhYmVsLmdldExvY2F0aW9uKHQpKTt2YXIgbj1udWxsO3N3aXRjaChlKXtjYXNlIEwuQk9VTkRBUlk6bj1MLklOVEVSSU9SO2JyZWFrO2Nhc2UgTC5JTlRFUklPUjpuPUwuQk9VTkRBUlk7YnJlYWs7ZGVmYXVsdDpuPUwuQk9VTkRBUll9dGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5bn19KSxlKHhuLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmdldCh0KX0sYWRkTm9kZTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PWUmJihlPXRoaXMubm9kZUZhY3QuY3JlYXRlTm9kZSh0KSx0aGlzLm5vZGVNYXAucHV0KHQsZSkpLGV9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5bil7dmFyIG49YXJndW1lbnRzWzBdLGU9dGhpcy5ub2RlTWFwLmdldChuLmdldENvb3JkaW5hdGUoKSk7cmV0dXJuIG51bGw9PT1lPyh0aGlzLm5vZGVNYXAucHV0KG4uZ2V0Q29vcmRpbmF0ZSgpLG4pLG4pOihlLm1lcmdlTGFiZWwobiksZSl9fSxwcmludDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSx2YWx1ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpfSxnZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KT09PUwuQk9VTkRBUlkmJmUuYWRkKGkpfXJldHVybiBlfSxhZGQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRDb29yZGluYXRlKCksbj10aGlzLmFkZE5vZGUoZSk7bi5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhufX0pLGUoRW4ucHJvdG90eXBlLHtjb21wYXJlRGlyZWN0aW9uOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmR4PT09dC5keCYmdGhpcy5keT09PXQuZHk/MDp0aGlzLnF1YWRyYW50PnQucXVhZHJhbnQ/MTp0aGlzLnF1YWRyYW50PHQucXVhZHJhbnQ/LTE6aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQucDAsdC5wMSx0aGlzLnAxKX0sZ2V0RHk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5keX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAwfSxzZXROb2RlOmZ1bmN0aW9uKHQpe3RoaXMubm9kZT10fSxwcmludDpmdW5jdGlvbih0KXt2YXIgZT1NYXRoLmF0YW4yKHRoaXMuZHksdGhpcy5keCksbj10aGlzLmdldENsYXNzKCkuZ2V0TmFtZSgpLGk9bi5sYXN0SW5kZXhPZihcIi5cIikscj1uLnN1YnN0cmluZyhpKzEpO3QucHJpbnQoXCIgIFwiK3IrXCI6IFwiK3RoaXMucDArXCIgLSBcIit0aGlzLnAxK1wiIFwiK3RoaXMucXVhZHJhbnQrXCI6XCIrZStcIiAgIFwiK3RoaXMubGFiZWwpfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfSxnZXREaXJlY3RlZENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wMX0sZ2V0RHg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5keH0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2V9LGdldFF1YWRyYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhZHJhbnR9LGdldE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlfSx0b1N0cmluZzpmdW5jdGlvbigpe3ZhciB0PU1hdGguYXRhbjIodGhpcy5keSx0aGlzLmR4KSxlPXRoaXMuZ2V0Q2xhc3MoKS5nZXROYW1lKCksbj1lLmxhc3RJbmRleE9mKFwiLlwiKSxpPWUuc3Vic3RyaW5nKG4rMSk7cmV0dXJuXCIgIFwiK2krXCI6IFwiK3RoaXMucDArXCIgLSBcIit0aGlzLnAxK1wiIFwiK3RoaXMucXVhZHJhbnQrXCI6XCIrdCtcIiAgIFwiK3RoaXMubGFiZWx9LGNvbXB1dGVMYWJlbDpmdW5jdGlvbih0KXt9LGluaXQ6ZnVuY3Rpb24odCxlKXt0aGlzLnAwPXQsdGhpcy5wMT1lLHRoaXMuZHg9ZS54LXQueCx0aGlzLmR5PWUueS10LnksdGhpcy5xdWFkcmFudD1KZS5xdWFkcmFudCh0aGlzLmR4LHRoaXMuZHkpLGYuaXNUcnVlKCEoMD09PXRoaXMuZHgmJjA9PT10aGlzLmR5KSxcIkVkZ2VFbmQgd2l0aCBpZGVudGljYWwgZW5kcG9pbnRzIGZvdW5kXCIpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRW59fSksaChJbixFbiksZShJbi5wcm90b3R5cGUse2dldE5leHRNaW46ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0TWlufSxnZXREZXB0aDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kZXB0aFt0XX0sc2V0VmlzaXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1Zpc2l0ZWQ9dH0sY29tcHV0ZURpcmVjdGVkTGFiZWw6ZnVuY3Rpb24oKXt0aGlzLmxhYmVsPW5ldyBnbih0aGlzLmVkZ2UuZ2V0TGFiZWwoKSksdGhpcy5faXNGb3J3YXJkfHx0aGlzLmxhYmVsLmZsaXAoKX0sZ2V0TmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5leHR9LHNldERlcHRoOmZ1bmN0aW9uKHQsZSl7aWYoLTk5OSE9PXRoaXMuZGVwdGhbdF0mJnRoaXMuZGVwdGhbdF0hPT1lKXRocm93IG5ldyBzbihcImFzc2lnbmVkIGRlcHRocyBkbyBub3QgbWF0Y2hcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7dGhpcy5kZXB0aFt0XT1lfSxpc0ludGVyaW9yQXJlYUVkZ2U6ZnVuY3Rpb24gdCgpe2Zvcih2YXIgdD0hMCxlPTA7Mj5lO2UrKyl0aGlzLmxhYmVsLmlzQXJlYShlKSYmdGhpcy5sYWJlbC5nZXRMb2NhdGlvbihlLGNuLkxFRlQpPT09TC5JTlRFUklPUiYmdGhpcy5sYWJlbC5nZXRMb2NhdGlvbihlLGNuLlJJR0hUKT09PUwuSU5URVJJT1J8fCh0PSExKTtyZXR1cm4gdH0sc2V0TmV4dE1pbjpmdW5jdGlvbih0KXt0aGlzLm5leHRNaW49dH0scHJpbnQ6ZnVuY3Rpb24odCl7RW4ucHJvdG90eXBlLnByaW50LmNhbGwodGhpcyx0KSx0LnByaW50KFwiIFwiK3RoaXMuZGVwdGhbY24uTEVGVF0rXCIvXCIrdGhpcy5kZXB0aFtjbi5SSUdIVF0pLHQucHJpbnQoXCIgKFwiK3RoaXMuZ2V0RGVwdGhEZWx0YSgpK1wiKVwiKSx0aGlzLl9pc0luUmVzdWx0JiZ0LnByaW50KFwiIGluUmVzdWx0XCIpfSxzZXRNaW5FZGdlUmluZzpmdW5jdGlvbih0KXt0aGlzLm1pbkVkZ2VSaW5nPXR9LGlzTGluZUVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxhYmVsLmlzTGluZSgwKXx8dGhpcy5sYWJlbC5pc0xpbmUoMSksZT0hdGhpcy5sYWJlbC5pc0FyZWEoMCl8fHRoaXMubGFiZWwuYWxsUG9zaXRpb25zRXF1YWwoMCxMLkVYVEVSSU9SKSxuPSF0aGlzLmxhYmVsLmlzQXJlYSgxKXx8dGhpcy5sYWJlbC5hbGxQb3NpdGlvbnNFcXVhbCgxLEwuRVhURVJJT1IpO3JldHVybiB0JiZlJiZufSxzZXRFZGdlUmluZzpmdW5jdGlvbih0KXt0aGlzLmVkZ2VSaW5nPXR9LGdldE1pbkVkZ2VSaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluRWRnZVJpbmd9LGdldERlcHRoRGVsdGE6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmVkZ2UuZ2V0RGVwdGhEZWx0YSgpO3JldHVybiB0aGlzLl9pc0ZvcndhcmR8fCh0PS10KSx0fSxzZXRJblJlc3VsdDpmdW5jdGlvbih0KXt0aGlzLl9pc0luUmVzdWx0PXR9LGdldFN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bX0saXNGb3J3YXJkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzRm9yd2FyZH0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2V9LHByaW50RWRnZTpmdW5jdGlvbih0KXt0aGlzLnByaW50KHQpLHQucHJpbnQoXCIgXCIpLHRoaXMuX2lzRm9yd2FyZD90aGlzLmVkZ2UucHJpbnQodCk6dGhpcy5lZGdlLnByaW50UmV2ZXJzZSh0KX0sc2V0U3ltOmZ1bmN0aW9uKHQpe3RoaXMuc3ltPXR9LHNldFZpc2l0ZWRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuc2V0VmlzaXRlZCh0KSx0aGlzLnN5bS5zZXRWaXNpdGVkKHQpfSxzZXRFZGdlRGVwdGhzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXRFZGdlKCkuZ2V0RGVwdGhEZWx0YSgpO3RoaXMuX2lzRm9yd2FyZHx8KG49LW4pO3ZhciBpPTE7dD09PWNuLkxFRlQmJihpPS0xKTt2YXIgcj1jbi5vcHBvc2l0ZSh0KSxzPW4qaSxvPWUrczt0aGlzLnNldERlcHRoKHQsZSksdGhpcy5zZXREZXB0aChyLG8pfSxnZXRFZGdlUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VSaW5nfSxpc0luUmVzdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5SZXN1bHR9LHNldE5leHQ6ZnVuY3Rpb24odCl7dGhpcy5uZXh0PXR9LGlzVmlzaXRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1Zpc2l0ZWR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElufX0pLEluLmRlcHRoRmFjdG9yPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQ9PT1MLkVYVEVSSU9SJiZlPT09TC5JTlRFUklPUj8xOnQ9PT1MLklOVEVSSU9SJiZlPT09TC5FWFRFUklPUj8tMTowfSxlKE5uLnByb3RvdHlwZSx7Y3JlYXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHluKHQsbnVsbCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5ufX0pLGUoQ24ucHJvdG90eXBlLHtwcmludEVkZ2VzOmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkVkZ2VzOlwiKTtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZXMuc2l6ZSgpO2UrKyl7dC5wcmludGxuKFwiZWRnZSBcIitlK1wiOlwiKTt2YXIgbj10aGlzLmVkZ2VzLmdldChlKTtuLnByaW50KHQpLG4uZWlMaXN0LnByaW50KHQpfX0sZmluZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2Rlcy5maW5kKHQpfSxhZGROb2RlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiB5bil7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLm5vZGVzLmFkZE5vZGUodCl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMubm9kZXMuYWRkTm9kZShlKX19LGdldE5vZGVJdGVyYXRvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm5vZGVzLml0ZXJhdG9yKCl9LGxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX0sZGVidWdQcmludGxuOmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4odCl9LGlzQm91bmRhcnlOb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5ub2Rlcy5maW5kKGUpO2lmKG51bGw9PT1uKXJldHVybiExO3ZhciBpPW4uZ2V0TGFiZWwoKTtyZXR1cm4gbnVsbCE9PWkmJmkuZ2V0TG9jYXRpb24odCk9PT1MLkJPVU5EQVJZfSxsaW5rQWxsRGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldEVkZ2VzKCkubGlua0FsbERpcmVjdGVkRWRnZXMoKX19LG1hdGNoSW5TYW1lRGlyZWN0aW9uOmZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiB0LmVxdWFscyhuKT9oZS5jb21wdXRlT3JpZW50YXRpb24odCxlLGkpPT09aGUuQ09MTElORUFSJiZKZS5xdWFkcmFudCh0LGUpPT09SmUucXVhZHJhbnQobixpKTohMX0sZ2V0RWRnZUVuZHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kTGlzdH0sZGVidWdQcmludDpmdW5jdGlvbih0KXtBLm91dC5wcmludCh0KX0sZ2V0RWRnZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0sZmluZEVkZ2VJblNhbWVEaXJlY3Rpb246ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHRoaXMuZWRnZXMuc2l6ZSgpO24rKyl7dmFyIGk9dGhpcy5lZGdlcy5nZXQobikscj1pLmdldENvb3JkaW5hdGVzKCk7aWYodGhpcy5tYXRjaEluU2FtZURpcmVjdGlvbih0LGUsclswXSxyWzFdKSlyZXR1cm4gaTtpZih0aGlzLm1hdGNoSW5TYW1lRGlyZWN0aW9uKHQsZSxyW3IubGVuZ3RoLTFdLHJbci5sZW5ndGgtMl0pKXJldHVybiBpfXJldHVybiBudWxsfSxpbnNlcnRFZGdlOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuYWRkKHQpfSxmaW5kRWRnZUVuZDpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIG59cmV0dXJuIG51bGx9LGFkZEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmVkZ2VzLmFkZChuKTt2YXIgaT1uZXcgSW4obiwhMCkscj1uZXcgSW4obiwhMSk7aS5zZXRTeW0ociksci5zZXRTeW0oaSksdGhpcy5hZGQoaSksdGhpcy5hZGQocil9fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5ub2Rlcy5hZGQodCksdGhpcy5lZGdlRW5kTGlzdC5hZGQodCl9LGdldE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMudmFsdWVzKCl9LGZpbmRFZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTA7bjx0aGlzLmVkZ2VzLnNpemUoKTtuKyspe3ZhciBpPXRoaXMuZWRnZXMuZ2V0KG4pLHI9aS5nZXRDb29yZGluYXRlcygpO2lmKHQuZXF1YWxzKHJbMF0pJiZlLmVxdWFscyhyWzFdKSlyZXR1cm4gaX1yZXR1cm4gbnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQ259fSksQ24ubGlua1Jlc3VsdERpcmVjdGVkRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0RWRnZXMoKS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpfX0sZShTbi5wcm90b3R5cGUse3NvcnRTaGVsbHNBbmRIb2xlczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IuaXNIb2xlKCk/bi5hZGQocik6ZS5hZGQocil9fSxjb21wdXRlUG9seWdvbnM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLnRvUG9seWdvbih0aGlzLmdlb21ldHJ5RmFjdG9yeSk7ZS5hZGQocil9cmV0dXJuIGV9LHBsYWNlRnJlZUhvbGVzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKG51bGw9PT1pLmdldFNoZWxsKCkpe3ZhciByPXRoaXMuZmluZEVkZ2VSaW5nQ29udGFpbmluZyhpLHQpO2lmKG51bGw9PT1yKXRocm93IG5ldyBzbihcInVuYWJsZSB0byBhc3NpZ24gaG9sZSB0byBhIHNoZWxsXCIsaS5nZXRDb29yZGluYXRlKDApKTtpLnNldFNoZWxsKHIpfX19LGJ1aWxkTWluaW1hbEVkZ2VSaW5nczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW5ldyBJLHI9dC5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7aWYocy5nZXRNYXhOb2RlRGVncmVlKCk+Mil7cy5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTt2YXIgbz1zLmJ1aWxkTWluaW1hbFJpbmdzKCksYT10aGlzLmZpbmRTaGVsbChvKTtudWxsIT09YT8odGhpcy5wbGFjZVBvbHlnb25Ib2xlcyhhLG8pLGUuYWRkKGEpKTpuLmFkZEFsbChvKX1lbHNlIGkuYWRkKHMpfXJldHVybiBpfSxjb250YWluc1BvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLnNoZWxsTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYobi5jb250YWluc1BvaW50KHQpKXJldHVybiEwfXJldHVybiExfSxidWlsZE1heGltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5pc0luUmVzdWx0KCkmJmkuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmbnVsbD09PWkuZ2V0RWRnZVJpbmcoKSl7dmFyIHI9bmV3IHZuKGksdGhpcy5nZW9tZXRyeUZhY3RvcnkpO2UuYWRkKHIpLHIuc2V0SW5SZXN1bHQoKX19cmV0dXJuIGV9LHBsYWNlUG9seWdvbkhvbGVzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuaXNIb2xlKCkmJmkuc2V0U2hlbGwodCl9fSxnZXRQb2x5Z29uczpmdW5jdGlvbigpe3ZhciB0PXRoaXMuY29tcHV0ZVBvbHlnb25zKHRoaXMuc2hlbGxMaXN0KTtyZXR1cm4gdH0sZmluZEVkZ2VSaW5nQ29udGFpbmluZzpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldExpbmVhclJpbmcoKSxpPW4uZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9bi5nZXRDb29yZGluYXRlTigwKSxzPW51bGwsbz1udWxsLGE9ZS5pdGVyYXRvcigpO2EuaGFzTmV4dCgpOyl7dmFyIHU9YS5uZXh0KCksbD11LmdldExpbmVhclJpbmcoKSxoPWwuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO251bGwhPT1zJiYobz1zLmdldExpbmVhclJpbmcoKS5nZXRFbnZlbG9wZUludGVybmFsKCkpO3ZhciBjPSExO2guY29udGFpbnMoaSkmJmhlLmlzUG9pbnRJblJpbmcocixsLmdldENvb3JkaW5hdGVzKCkpJiYoYz0hMCksYyYmKG51bGw9PT1zfHxvLmNvbnRhaW5zKGgpKSYmKHM9dSl9cmV0dXJuIHN9LGZpbmRTaGVsbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MCxuPW51bGwsaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzSG9sZSgpfHwobj1yLGUrKyl9cmV0dXJuIGYuaXNUcnVlKDE+PWUsXCJmb3VuZCB0d28gc2hlbGxzIGluIE1pbmltYWxFZGdlUmluZyBsaXN0XCIpLG59LGFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5hZGQodC5nZXRFZGdlRW5kcygpLHQuZ2V0Tm9kZXMoKSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO0NuLmxpbmtSZXN1bHREaXJlY3RlZEVkZ2VzKG4pO3ZhciBpPXRoaXMuYnVpbGRNYXhpbWFsRWRnZVJpbmdzKGUpLHI9bmV3IEkscz10aGlzLmJ1aWxkTWluaW1hbEVkZ2VSaW5ncyhpLHRoaXMuc2hlbGxMaXN0LHIpO3RoaXMuc29ydFNoZWxsc0FuZEhvbGVzKHMsdGhpcy5zaGVsbExpc3QsciksdGhpcy5wbGFjZUZyZWVIb2xlcyh0aGlzLnNoZWxsTGlzdCxyKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNufX0pLGUod24ucHJvdG90eXBlLHtjb2xsZWN0TGluZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMub3AuZ2V0R3JhcGgoKS5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmNvbGxlY3RMaW5lRWRnZShuLHQsdGhpcy5saW5lRWRnZXNMaXN0KSx0aGlzLmNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZShuLHQsdGhpcy5saW5lRWRnZXNMaXN0KX19LGxhYmVsSXNvbGF0ZWRMaW5lOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMub3AuZ2V0QXJnR2VvbWV0cnkoZSkpO3QuZ2V0TGFiZWwoKS5zZXRMb2NhdGlvbihlLG4pfSxidWlsZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5maW5kQ292ZXJlZExpbmVFZGdlcygpLHRoaXMuY29sbGVjdExpbmVzKHQpLHRoaXMuYnVpbGRMaW5lcyh0KSx0aGlzLnJlc3VsdExpbmVMaXN0fSxjb2xsZWN0TGluZUVkZ2U6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0TGFiZWwoKSxyPXQuZ2V0RWRnZSgpO3QuaXNMaW5lRWRnZSgpJiYodC5pc1Zpc2l0ZWQoKXx8IWlpLmlzUmVzdWx0T2ZPcChpLGUpfHxyLmlzQ292ZXJlZCgpfHwobi5hZGQociksdC5zZXRWaXNpdGVkRWRnZSghMCkpKX0sZmluZENvdmVyZWRMaW5lRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5vcC5nZXRHcmFwaCgpLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5maW5kQ292ZXJlZExpbmVFZGdlcygpfWZvcih2YXIgbj10aGlzLm9wLmdldEdyYXBoKCkuZ2V0RWRnZUVuZHMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldEVkZ2UoKTtpZihpLmlzTGluZUVkZ2UoKSYmIXIuaXNDb3ZlcmVkU2V0KCkpe3ZhciBzPXRoaXMub3AuaXNDb3ZlcmVkQnlBKGkuZ2V0Q29vcmRpbmF0ZSgpKTtyLnNldENvdmVyZWQocyl9fX0sbGFiZWxJc29sYXRlZExpbmVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtuLmlzSXNvbGF0ZWQoKSYmKGkuaXNOdWxsKDApP3RoaXMubGFiZWxJc29sYXRlZExpbmUobiwwKTp0aGlzLmxhYmVsSXNvbGF0ZWRMaW5lKG4sMSkpfX0sYnVpbGRMaW5lczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5saW5lRWRnZXNMaXN0Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPShuLmdldExhYmVsKCksdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyhuLmdldENvb3JkaW5hdGVzKCkpKTt0aGlzLnJlc3VsdExpbmVMaXN0LmFkZChpKSxuLnNldEluUmVzdWx0KCEwKX19LGNvbGxlY3RCb3VuZGFyeVRvdWNoRWRnZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRMYWJlbCgpO3JldHVybiB0LmlzTGluZUVkZ2UoKT9udWxsOnQuaXNWaXNpdGVkKCk/bnVsbDp0LmlzSW50ZXJpb3JBcmVhRWRnZSgpP251bGw6dC5nZXRFZGdlKCkuaXNJblJlc3VsdCgpP251bGw6KGYuaXNUcnVlKCEodC5pc0luUmVzdWx0KCl8fHQuZ2V0U3ltKCkuaXNJblJlc3VsdCgpKXx8IXQuZ2V0RWRnZSgpLmlzSW5SZXN1bHQoKSksdm9pZChpaS5pc1Jlc3VsdE9mT3AoaSxlKSYmZT09PWlpLklOVEVSU0VDVElPTiYmKG4uYWRkKHQuZ2V0RWRnZSgpKSx0LnNldFZpc2l0ZWRFZGdlKCEwKSkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd259fSksZShMbi5wcm90b3R5cGUse2ZpbHRlckNvdmVyZWROb2RlVG9Qb2ludDpmdW5jdGlvbih0KXt2YXIgZT10LmdldENvb3JkaW5hdGUoKTtpZighdGhpcy5vcC5pc0NvdmVyZWRCeUxBKGUpKXt2YXIgbj10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChlKTt0aGlzLnJlc3VsdFBvaW50TGlzdC5hZGQobil9fSxleHRyYWN0Tm9uQ292ZXJlZFJlc3VsdE5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm9wLmdldEdyYXBoKCkuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYoIShuLmlzSW5SZXN1bHQoKXx8bi5pc0luY2lkZW50RWRnZUluUmVzdWx0KCl8fDAhPT1uLmdldEVkZ2VzKCkuZ2V0RGVncmVlKCkmJnQhPT1paS5JTlRFUlNFQ1RJT04pKXt2YXIgaT1uLmdldExhYmVsKCk7aWkuaXNSZXN1bHRPZk9wKGksdCkmJnRoaXMuZmlsdGVyQ292ZXJlZE5vZGVUb1BvaW50KG4pfX19LGJ1aWxkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmV4dHJhY3ROb25Db3ZlcmVkUmVzdWx0Tm9kZXModCksdGhpcy5yZXN1bHRQb2ludExpc3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIExufX0pLGUoUm4ucHJvdG90eXBlLHtsb2NhdGU6ZnVuY3Rpb24odCl7fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSbn19KSxlKFRuLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBUbi5sb2NhdGUodCx0aGlzLmdlb20pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltSbl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRufX0pLFRuLmlzUG9pbnRJblJpbmc9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyh0KT9oZS5pc1BvaW50SW5SaW5nKHQsZS5nZXRDb29yZGluYXRlcygpKTohMX0sVG4uY29udGFpbnNQb2ludEluUG9seWdvbj1mdW5jdGlvbih0LGUpe2lmKGUuaXNFbXB0eSgpKXJldHVybiExO3ZhciBuPWUuZ2V0RXh0ZXJpb3JSaW5nKCk7aWYoIVRuLmlzUG9pbnRJblJpbmcodCxuKSlyZXR1cm4hMTtmb3IodmFyIGk9MDtpPGUuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXt2YXIgcj1lLmdldEludGVyaW9yUmluZ04oaSk7aWYoVG4uaXNQb2ludEluUmluZyh0LHIpKXJldHVybiExfXJldHVybiEwfSxUbi5jb250YWluc1BvaW50PWZ1bmN0aW9uKHQsZSl7aWYoZSBpbnN0YW5jZW9mIFR0KXJldHVybiBUbi5jb250YWluc1BvaW50SW5Qb2x5Z29uKHQsZSk7aWYoZSBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgbj1uZXcgUmUoZSk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpIT09ZSYmVG4uY29udGFpbnNQb2ludCh0LGkpKXJldHVybiEwfXJldHVybiExfSxUbi5sb2NhdGU9ZnVuY3Rpb24odCxlKXtyZXR1cm4gZS5pc0VtcHR5KCk/TC5FWFRFUklPUjpUbi5jb250YWluc1BvaW50KHQsZSk/TC5JTlRFUklPUjpMLkVYVEVSSU9SfSxlKFBuLnByb3RvdHlwZSx7Z2V0TmV4dENXOmZ1bmN0aW9uKHQpe3RoaXMuZ2V0RWRnZXMoKTt2YXIgZT10aGlzLmVkZ2VMaXN0LmluZGV4T2YodCksbj1lLTE7cmV0dXJuIDA9PT1lJiYobj10aGlzLmVkZ2VMaXN0LnNpemUoKS0xKSx0aGlzLmVkZ2VMaXN0LmdldChuKX0scHJvcGFnYXRlU2lkZUxhYmVsczpmdW5jdGlvbih0KXtmb3IodmFyIGU9TC5OT05FLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCk7ci5pc0FyZWEodCkmJnIuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSE9PUwuTk9ORSYmKGU9ci5nZXRMb2NhdGlvbih0LGNuLkxFRlQpKX1pZihlPT09TC5OT05FKXJldHVybiBudWxsO2Zvcih2YXIgcz1lLG49dGhpcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldExhYmVsKCk7aWYoci5nZXRMb2NhdGlvbih0LGNuLk9OKT09PUwuTk9ORSYmci5zZXRMb2NhdGlvbih0LGNuLk9OLHMpLHIuaXNBcmVhKHQpKXt2YXIgbz1yLmdldExvY2F0aW9uKHQsY24uTEVGVCksYT1yLmdldExvY2F0aW9uKHQsY24uUklHSFQpO2lmKGEhPT1MLk5PTkUpe2lmKGEhPT1zKXRocm93IG5ldyBzbihcInNpZGUgbG9jYXRpb24gY29uZmxpY3RcIixpLmdldENvb3JkaW5hdGUoKSk7bz09PUwuTk9ORSYmZi5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHNpbmdsZSBudWxsIHNpZGUgKGF0IFwiK2kuZ2V0Q29vcmRpbmF0ZSgpK1wiKVwiKSxzPW99ZWxzZSBmLmlzVHJ1ZShyLmdldExvY2F0aW9uKHQsY24uTEVGVCk9PT1MLk5PTkUsXCJmb3VuZCBzaW5nbGUgbnVsbCBzaWRlXCIpLHIuc2V0TG9jYXRpb24odCxjbi5SSUdIVCxzKSxyLnNldExvY2F0aW9uKHQsY24uTEVGVCxzKX19fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgZT10Lm5leHQoKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlKCl9LHByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24ucHJpbnQodCl9fSxpc0FyZWFMYWJlbHNDb25zaXN0ZW50OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbXB1dGVFZGdlRW5kTGFiZWxzKHQuZ2V0Qm91bmRhcnlOb2RlUnVsZSgpKSx0aGlzLmNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQoMCl9LGNoZWNrQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRFZGdlcygpO2lmKGUuc2l6ZSgpPD0wKXJldHVybiEwO3ZhciBuPWUuc2l6ZSgpLTEsaT1lLmdldChuKS5nZXRMYWJlbCgpLHI9aS5nZXRMb2NhdGlvbih0LGNuLkxFRlQpO2YuaXNUcnVlKHIhPT1MLk5PTkUsXCJGb3VuZCB1bmxhYmVsbGVkIGFyZWEgZWRnZVwiKTtmb3IodmFyIHM9cixvPXRoaXMuaXRlcmF0b3IoKTtvLmhhc05leHQoKTspe3ZhciBhPW8ubmV4dCgpLHU9YS5nZXRMYWJlbCgpO1xuZi5pc1RydWUodS5pc0FyZWEodCksXCJGb3VuZCBub24tYXJlYSBlZGdlXCIpO3ZhciBsPXUuZ2V0TG9jYXRpb24odCxjbi5MRUZUKSxoPXUuZ2V0TG9jYXRpb24odCxjbi5SSUdIVCk7aWYobD09PWgpcmV0dXJuITE7aWYoaCE9PXMpcmV0dXJuITE7cz1sfXJldHVybiEwfSxmaW5kSW5kZXg6ZnVuY3Rpb24odCl7dGhpcy5pdGVyYXRvcigpO2Zvcih2YXIgZT0wO2U8dGhpcy5lZGdlTGlzdC5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLmVkZ2VMaXN0LmdldChlKTtpZihuPT09dClyZXR1cm4gZX1yZXR1cm4tMX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRFZGdlcygpLml0ZXJhdG9yKCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLmVkZ2VMaXN0JiYodGhpcy5lZGdlTGlzdD1uZXcgSSh0aGlzLmVkZ2VNYXAudmFsdWVzKCkpKSx0aGlzLmVkZ2VMaXN0fSxnZXRMb2NhdGlvbjpmdW5jdGlvbih0LGUsbil7cmV0dXJuIHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT09PUwuTk9ORSYmKHRoaXMucHRJbkFyZWFMb2NhdGlvblt0XT1Ubi5sb2NhdGUoZSxuW3RdLmdldEdlb21ldHJ5KCkpKSx0aGlzLnB0SW5BcmVhTG9jYXRpb25bdF19LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dC5hcHBlbmQoXCJFZGdlRW5kU3RhcjogICBcIit0aGlzLmdldENvb3JkaW5hdGUoKSksdC5hcHBlbmQoXCJcXG5cIik7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QuYXBwZW5kKG4pLHQuYXBwZW5kKFwiXFxuXCIpfXJldHVybiB0LnRvU3RyaW5nKCl9LGNvbXB1dGVFZGdlRW5kTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLmNvbXB1dGVMYWJlbCh0KX19LGNvbXB1dGVMYWJlbGxpbmc6ZnVuY3Rpb24odCl7dGhpcy5jb21wdXRlRWRnZUVuZExhYmVscyh0WzBdLmdldEJvdW5kYXJ5Tm9kZVJ1bGUoKSksdGhpcy5wcm9wYWdhdGVTaWRlTGFiZWxzKDApLHRoaXMucHJvcGFnYXRlU2lkZUxhYmVscygxKTtmb3IodmFyIGU9WyExLCExXSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZm9yKHZhciBpPW4ubmV4dCgpLHI9aS5nZXRMYWJlbCgpLHM9MDsyPnM7cysrKXIuaXNMaW5lKHMpJiZyLmdldExvY2F0aW9uKHMpPT09TC5CT1VOREFSWSYmKGVbc109ITApO2Zvcih2YXIgbj10aGlzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKSxzPTA7Mj5zO3MrKylpZihyLmlzQW55TnVsbChzKSl7dmFyIG89TC5OT05FO2lmKGVbc10pbz1MLkVYVEVSSU9SO2Vsc2V7dmFyIGE9aS5nZXRDb29yZGluYXRlKCk7bz10aGlzLmdldExvY2F0aW9uKHMsYSx0KX1yLnNldEFsbExvY2F0aW9uc0lmTnVsbChzLG8pfX0sZ2V0RGVncmVlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZU1hcC5zaXplKCl9LGluc2VydEVkZ2VFbmQ6ZnVuY3Rpb24odCxlKXt0aGlzLmVkZ2VNYXAucHV0KHQsZSksdGhpcy5lZGdlTGlzdD1udWxsfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQbn19KSxoKGJuLFBuKSxlKGJuLnByb3RvdHlwZSx7bGlua1Jlc3VsdERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldFJlc3VsdEFyZWFFZGdlcygpO2Zvcih2YXIgdD1udWxsLGU9bnVsbCxuPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLGk9MDtpPHRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LnNpemUoKTtpKyspe3ZhciByPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChpKSxzPXIuZ2V0U3ltKCk7aWYoci5nZXRMYWJlbCgpLmlzQXJlYSgpKXN3aXRjaChudWxsPT09dCYmci5pc0luUmVzdWx0KCkmJih0PXIpLG4pe2Nhc2UgdGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkc6aWYoIXMuaXNJblJlc3VsdCgpKWNvbnRpbnVlO2U9cyxuPXRoaXMuTElOS0lOR19UT19PVVRHT0lORzticmVhaztjYXNlIHRoaXMuTElOS0lOR19UT19PVVRHT0lORzppZighci5pc0luUmVzdWx0KCkpY29udGludWU7ZS5zZXROZXh0KHIpLG49dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWlmKG49PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcpe2lmKG51bGw9PT10KXRocm93IG5ldyBzbihcIm5vIG91dGdvaW5nIGRpckVkZ2UgZm91bmRcIix0aGlzLmdldENvb3JkaW5hdGUoKSk7Zi5pc1RydWUodC5pc0luUmVzdWx0KCksXCJ1bmFibGUgdG8gbGluayBsYXN0IGluY29taW5nIGRpckVkZ2VcIiksZS5zZXROZXh0KHQpfX0saW5zZXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5pbnNlcnRFZGdlRW5kKGUsZSl9LGdldFJpZ2h0bW9zdEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmdldEVkZ2VzKCksZT10LnNpemUoKTtpZigxPmUpcmV0dXJuIG51bGw7dmFyIG49dC5nZXQoMCk7aWYoMT09PWUpcmV0dXJuIG47dmFyIGk9dC5nZXQoZS0xKSxyPW4uZ2V0UXVhZHJhbnQoKSxzPWkuZ2V0UXVhZHJhbnQoKTtpZihKZS5pc05vcnRoZXJuKHIpJiZKZS5pc05vcnRoZXJuKHMpKXJldHVybiBuO2lmKCFKZS5pc05vcnRoZXJuKHIpJiYhSmUuaXNOb3J0aGVybihzKSlyZXR1cm4gaTtyZXR1cm4gMCE9PW4uZ2V0RHkoKT9uOjAhPT1pLmdldER5KCk/aTooZi5zaG91bGROZXZlclJlYWNoSGVyZShcImZvdW5kIHR3byBob3Jpem9udGFsIGVkZ2VzIGluY2lkZW50IG9uIG5vZGVcIiksbnVsbCl9LHByaW50OmZ1bmN0aW9uKHQpe0Eub3V0LnByaW50bG4oXCJEaXJlY3RlZEVkZ2VTdGFyOiBcIit0aGlzLmdldENvb3JkaW5hdGUoKSk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3QucHJpbnQoXCJvdXQgXCIpLG4ucHJpbnQodCksdC5wcmludGxuKCksdC5wcmludChcImluIFwiKSxuLmdldFN5bSgpLnByaW50KHQpLHQucHJpbnRsbigpfX0sZ2V0UmVzdWx0QXJlYUVkZ2VzOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0KXJldHVybiB0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdDt0aGlzLnJlc3VsdEFyZWFFZGdlTGlzdD1uZXcgSTtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7KGUuaXNJblJlc3VsdCgpfHxlLmdldFN5bSgpLmlzSW5SZXN1bHQoKSkmJnRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmFkZChlKX1yZXR1cm4gdGhpcy5yZXN1bHRBcmVhRWRnZUxpc3R9LHVwZGF0ZUxhYmVsbGluZzpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCk7aS5zZXRBbGxMb2NhdGlvbnNJZk51bGwoMCx0LmdldExvY2F0aW9uKDApKSxpLnNldEFsbExvY2F0aW9uc0lmTnVsbCgxLHQuZ2V0TG9jYXRpb24oMSkpfX0sbGlua0FsbERpcmVjdGVkRWRnZXM6ZnVuY3Rpb24oKXt0aGlzLmdldEVkZ2VzKCk7Zm9yKHZhciB0PW51bGwsZT1udWxsLG49dGhpcy5lZGdlTGlzdC5zaXplKCktMTtuPj0wO24tLSl7dmFyIGk9dGhpcy5lZGdlTGlzdC5nZXQobikscj1pLmdldFN5bSgpO251bGw9PT1lJiYoZT1yKSxudWxsIT09dCYmci5zZXROZXh0KHQpLHQ9aX1lLnNldE5leHQodCl9LGNvbXB1dGVEZXB0aHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5maW5kSW5kZXgodCksbj0odC5nZXRMYWJlbCgpLHQuZ2V0RGVwdGgoY24uTEVGVCkpLGk9dC5nZXREZXB0aChjbi5SSUdIVCkscj10aGlzLmNvbXB1dGVEZXB0aHMoZSsxLHRoaXMuZWRnZUxpc3Quc2l6ZSgpLG4pLHM9dGhpcy5jb21wdXRlRGVwdGhzKDAsZSxyKTtpZihzIT09aSl0aHJvdyBuZXcgc24oXCJkZXB0aCBtaXNtYXRjaCBhdCBcIit0LmdldENvb3JkaW5hdGUoKSl9ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBvPWFyZ3VtZW50c1swXSxhPWFyZ3VtZW50c1sxXSx1PWFyZ3VtZW50c1syXSxsPXUsaD1vO2E+aDtoKyspe3ZhciBjPXRoaXMuZWRnZUxpc3QuZ2V0KGgpO2MuZ2V0TGFiZWwoKTtjLnNldEVkZ2VEZXB0aHMoY24uUklHSFQsbCksbD1jLmdldERlcHRoKGNuLkxFRlQpfXJldHVybiBsfX0sbWVyZ2VTeW1MYWJlbHM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldExhYmVsKCk7bi5tZXJnZShlLmdldFN5bSgpLmdldExhYmVsKCkpfX0sbGlua01pbmltYWxEaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49bnVsbCxpPXRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HLHI9dGhpcy5yZXN1bHRBcmVhRWRnZUxpc3Quc2l6ZSgpLTE7cj49MDtyLS0pe3ZhciBzPXRoaXMucmVzdWx0QXJlYUVkZ2VMaXN0LmdldChyKSxvPXMuZ2V0U3ltKCk7c3dpdGNoKG51bGw9PT1lJiZzLmdldEVkZ2VSaW5nKCk9PT10JiYoZT1zKSxpKXtjYXNlIHRoaXMuU0NBTk5JTkdfRk9SX0lOQ09NSU5HOmlmKG8uZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bj1vLGk9dGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HO2JyZWFrO2Nhc2UgdGhpcy5MSU5LSU5HX1RPX09VVEdPSU5HOmlmKHMuZ2V0RWRnZVJpbmcoKSE9PXQpY29udGludWU7bi5zZXROZXh0TWluKHMpLGk9dGhpcy5TQ0FOTklOR19GT1JfSU5DT01JTkd9fWk9PT10aGlzLkxJTktJTkdfVE9fT1VUR09JTkcmJihmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgZm9yIGZpcnN0IG91dGdvaW5nIGRpckVkZ2VcIiksZi5pc1RydWUoZS5nZXRFZGdlUmluZygpPT09dCxcInVuYWJsZSB0byBsaW5rIGxhc3QgaW5jb21pbmcgZGlyRWRnZVwiKSxuLnNldE5leHRNaW4oZSkpfSxnZXRPdXRnb2luZ0RlZ3JlZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9MCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNJblJlc3VsdCgpJiZ0Kyt9cmV0dXJuIHR9aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgaT1hcmd1bWVudHNbMF0sdD0wLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlUmluZygpPT09aSYmdCsrfXJldHVybiB0fX0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sZmluZENvdmVyZWRMaW5lRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9TC5OT05FLGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldFN5bSgpO2lmKCFuLmlzTGluZUVkZ2UoKSl7aWYobi5pc0luUmVzdWx0KCkpe3Q9TC5JTlRFUklPUjticmVha31pZihpLmlzSW5SZXN1bHQoKSl7dD1MLkVYVEVSSU9SO2JyZWFrfX19aWYodD09PUwuTk9ORSlyZXR1cm4gbnVsbDtmb3IodmFyIHI9dCxlPXRoaXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRTeW0oKTtuLmlzTGluZUVkZ2UoKT9uLmdldEVkZ2UoKS5zZXRDb3ZlcmVkKHI9PT1MLklOVEVSSU9SKToobi5pc0luUmVzdWx0KCkmJihyPUwuRVhURVJJT1IpLGkuaXNJblJlc3VsdCgpJiYocj1MLklOVEVSSU9SKSl9fSxjb21wdXRlTGFiZWxsaW5nOmZ1bmN0aW9uKHQpe1BuLnByb3RvdHlwZS5jb21wdXRlTGFiZWxsaW5nLmNhbGwodGhpcyx0KSx0aGlzLmxhYmVsPW5ldyBnbihMLk5PTkUpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KWZvcih2YXIgbj1lLm5leHQoKSxpPW4uZ2V0RWRnZSgpLHI9aS5nZXRMYWJlbCgpLHM9MDsyPnM7cysrKXt2YXIgbz1yLmdldExvY2F0aW9uKHMpO28hPT1MLklOVEVSSU9SJiZvIT09TC5CT1VOREFSWXx8dGhpcy5sYWJlbC5zZXRMb2NhdGlvbihzLEwuSU5URVJJT1IpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYm59fSksaChPbixObiksZShPbi5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyB5bih0LG5ldyBibil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE9ufX0pLGUoX24ucHJvdG90eXBlLHtjb21wdXRlSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUpe3RoaXMubWNlLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5jaGFpbkluZGV4LHQubWNlLHQuY2hhaW5JbmRleCxlKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX259fSksZShNbi5wcm90b3R5cGUse2lzRGVsZXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZXZlbnRUeXBlPT09TW4uREVMRVRFfSxzZXREZWxldGVFdmVudEluZGV4OmZ1bmN0aW9uKHQpe3RoaXMuZGVsZXRlRXZlbnRJbmRleD10fSxnZXRPYmplY3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vYmp9LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnhWYWx1ZTxlLnhWYWx1ZT8tMTp0aGlzLnhWYWx1ZT5lLnhWYWx1ZT8xOnRoaXMuZXZlbnRUeXBlPGUuZXZlbnRUeXBlPy0xOnRoaXMuZXZlbnRUeXBlPmUuZXZlbnRUeXBlPzE6MH0sZ2V0SW5zZXJ0RXZlbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnNlcnRFdmVudH0saXNJbnNlcnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ldmVudFR5cGU9PT1Nbi5JTlNFUlR9LGlzU2FtZUxhYmVsOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dGhpcy5sYWJlbD8hMTp0aGlzLmxhYmVsPT09dC5sYWJlbH0sZ2V0RGVsZXRlRXZlbnRJbmRleDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRlbGV0ZUV2ZW50SW5kZXh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBNbn19KSxNbi5JTlNFUlQ9MSxNbi5ERUxFVEU9MixlKERuLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRG59fSksZShBbi5wcm90b3R5cGUse2lzVHJpdmlhbEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmMT09PXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKEFuLmlzQWRqYWNlbnRTZWdtZW50cyhlLGkpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7dmFyIHI9dC5nZXROdW1Qb2ludHMoKS0xO2lmKDA9PT1lJiZpPT09cnx8MD09PWkmJmU9PT1yKXJldHVybiEwfX1yZXR1cm4hMX0sZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wcm9wZXJJbnRlcnNlY3Rpb25Qb2ludH0sc2V0SXNEb25lSWZQcm9wZXJJbnQ6ZnVuY3Rpb24odCl7dGhpcy5pc0RvbmVXaGVuUHJvcGVySW50PXR9LGhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVySW50ZXJpb3J9LGlzQm91bmRhcnlQb2ludEludGVybmFsOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5nZXRDb29yZGluYXRlKCk7aWYodC5pc0ludGVyc2VjdGlvbihyKSlyZXR1cm4hMH1yZXR1cm4hMX0saGFzUHJvcGVySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVyfSxoYXNJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzSW50ZXJzZWN0aW9ufSxpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNEb25lfSxpc0JvdW5kYXJ5UG9pbnQ6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PWU/ITE6dGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMF0pPyEwOiEhdGhpcy5pc0JvdW5kYXJ5UG9pbnRJbnRlcm5hbCh0LGVbMV0pfSxzZXRCb3VuZGFyeU5vZGVzOmZ1bmN0aW9uKHQsZSl7dGhpcy5iZHlOb2Rlcz1uZXcgQXJyYXkoMikuZmlsbChudWxsKSx0aGlzLmJkeU5vZGVzWzBdPXQsdGhpcy5iZHlOb2Rlc1sxXT1lfSxhZGRJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7dmFyIHI9dC5nZXRDb29yZGluYXRlcygpW2VdLHM9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbaV0sYT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixzLG8sYSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMucmVjb3JkSXNvbGF0ZWQmJih0LnNldElzb2xhdGVkKCExKSxuLnNldElzb2xhdGVkKCExKSksdGhpcy5udW1JbnRlcnNlY3Rpb25zKyssdGhpcy5pc1RyaXZpYWxJbnRlcnNlY3Rpb24odCxlLG4saSl8fCh0aGlzLl9oYXNJbnRlcnNlY3Rpb249ITAsIXRoaXMuaW5jbHVkZVByb3BlciYmdGhpcy5saS5pc1Byb3BlcigpfHwodC5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksZSwwKSxuLmFkZEludGVyc2VjdGlvbnModGhpcy5saSxpLDEpKSx0aGlzLmxpLmlzUHJvcGVyKCkmJih0aGlzLnByb3BlckludGVyc2VjdGlvblBvaW50PXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uKDApLmNvcHkoKSx0aGlzLmhhc1Byb3Blcj0hMCx0aGlzLmlzRG9uZVdoZW5Qcm9wZXJJbnQmJih0aGlzLl9pc0RvbmU9ITApLHRoaXMuaXNCb3VuZGFyeVBvaW50KHRoaXMubGksdGhpcy5iZHlOb2Rlcyl8fCh0aGlzLmhhc1Byb3BlckludGVyaW9yPSEwKSkpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQW59fSksQW4uaXNBZGphY2VudFNlZ21lbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfSxoKEZuLERuKSxlKEZuLnByb3RvdHlwZSx7cHJlcGFyZUV2ZW50czpmdW5jdGlvbigpe2hvLnNvcnQodGhpcy5ldmVudHMpO2Zvcih2YXIgdD0wO3Q8dGhpcy5ldmVudHMuc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5ldmVudHMuZ2V0KHQpO2UuaXNEZWxldGUoKSYmZS5nZXRJbnNlcnRFdmVudCgpLnNldERlbGV0ZUV2ZW50SW5kZXgodCl9fSxjb21wdXRlSW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5uT3ZlcmxhcHM9MCx0aGlzLnByZXBhcmVFdmVudHMoKTtmb3IodmFyIGU9MDtlPHRoaXMuZXZlbnRzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMuZXZlbnRzLmdldChlKTtpZihuLmlzSW5zZXJ0KCkmJnRoaXMucHJvY2Vzc092ZXJsYXBzKGUsbi5nZXREZWxldGVFdmVudEluZGV4KCksbix0KSx0LmlzRG9uZSgpKWJyZWFrfX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKWlmKGFyZ3VtZW50c1syXWluc3RhbmNlb2YgQW4mJlIoYXJndW1lbnRzWzBdLHkpJiZSKGFyZ3VtZW50c1sxXSx5KSl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3RoaXMuYWRkRWRnZXMoaSxpKSx0aGlzLmFkZEVkZ2VzKHIsciksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhzKX1lbHNlIGlmKFwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzJdJiZSKGFyZ3VtZW50c1swXSx5KSYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBBbil7dmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdO3U/dGhpcy5hZGRFZGdlcyhvLG51bGwpOnRoaXMuYWRkRWRnZXMobyksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9ucyhhKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRNb25vdG9uZUNoYWluRWRnZSgpLGk9bi5nZXRTdGFydEluZGV4ZXMoKSxyPTA7cjxpLmxlbmd0aC0xO3IrKyl7dmFyIHM9bmV3IF9uKG4sciksbz1uZXcgTW4oZSxuLmdldE1pblgocikscyk7dGhpcy5ldmVudHMuYWRkKG8pLHRoaXMuZXZlbnRzLmFkZChuZXcgTW4obi5nZXRNYXhYKHIpLG8pKX19LHByb2Nlc3NPdmVybGFwczpmdW5jdGlvbih0LGUsbixpKXtmb3IodmFyIHI9bi5nZXRPYmplY3QoKSxzPXQ7ZT5zO3MrKyl7dmFyIG89dGhpcy5ldmVudHMuZ2V0KHMpO2lmKG8uaXNJbnNlcnQoKSl7dmFyIGE9by5nZXRPYmplY3QoKTtuLmlzU2FtZUxhYmVsKG8pfHwoci5jb21wdXRlSW50ZXJzZWN0aW9ucyhhLGkpLHRoaXMubk92ZXJsYXBzKyspfX19LGFkZEVkZ2VzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLG4pfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxlPWkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuYWRkRWRnZShuLHIpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRm59fSksZShHbi5wcm90b3R5cGUse2dldE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0saW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiEodGhpcy5taW4+ZXx8dGhpcy5tYXg8dCl9LGdldE1heDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1heH0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gc2UudG9MaW5lU3RyaW5nKG5ldyBnKHRoaXMubWluLDApLG5ldyBnKHRoaXMubWF4LDApKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gR259fSksZShxbi5wcm90b3R5cGUse2NvbXBhcmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LGk9ZSxyPShuLm1pbituLm1heCkvMixzPShpLm1pbitpLm1heCkvMjtyZXR1cm4gcz5yPy0xOnI+cz8xOjB9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2FdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxbn19KSxHbi5Ob2RlQ29tcGFyYXRvcj1xbixoKEJuLEduKSxlKEJuLnByb3RvdHlwZSx7cXVlcnk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmludGVyc2VjdHModCxlKT92b2lkIG4udmlzaXRJdGVtKHRoaXMuaXRlbSk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQm59fSksaCh6bixHbiksZSh6bi5wcm90b3R5cGUse2J1aWxkRXh0ZW50OmZ1bmN0aW9uKHQsZSl7dGhpcy5taW49TWF0aC5taW4odC5taW4sZS5taW4pLHRoaXMubWF4PU1hdGgubWF4KHQubWF4LGUubWF4KX0scXVlcnk6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmludGVyc2VjdHModCxlKT8obnVsbCE9PXRoaXMubm9kZTEmJnRoaXMubm9kZTEucXVlcnkodCxlLG4pLHZvaWQobnVsbCE9PXRoaXMubm9kZTImJnRoaXMubm9kZTIucXVlcnkodCxlLG4pKSk6bnVsbH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gem59fSksZShWbi5wcm90b3R5cGUse2J1aWxkVHJlZTpmdW5jdGlvbigpe2hvLnNvcnQodGhpcy5sZWF2ZXMsbmV3IEludGVydmFsUlRyZWVOb2RlLk5vZGVDb21wYXJhdG9yKTtmb3IodmFyIHQ9dGhpcy5sZWF2ZXMsZT1udWxsLG49bmV3IEk7Oyl7aWYodGhpcy5idWlsZExldmVsKHQsbiksMT09PW4uc2l6ZSgpKXJldHVybiBuLmdldCgwKTtlPXQsdD1uLG49ZX19LGluc2VydDpmdW5jdGlvbih0LGUsbil7aWYobnVsbCE9PXRoaXMucm9vdCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiSW5kZXggY2Fubm90IGJlIGFkZGVkIHRvIG9uY2UgaXQgaGFzIGJlZW4gcXVlcmllZFwiKTt0aGlzLmxlYXZlcy5hZGQobmV3IEJuKHQsZSxuKSl9LHF1ZXJ5OmZ1bmN0aW9uKHQsZSxuKXt0aGlzLmluaXQoKSx0aGlzLnJvb3QucXVlcnkodCxlLG4pfSxidWlsZFJvb3Q6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD9udWxsOnZvaWQodGhpcy5yb290PXRoaXMuYnVpbGRUcmVlKCkpfSxwcmludE5vZGU6ZnVuY3Rpb24odCl7QS5vdXQucHJpbnRsbihzZS50b0xpbmVTdHJpbmcobmV3IGcodC5taW4sdGhpcy5sZXZlbCksbmV3IGcodC5tYXgsdGhpcy5sZXZlbCkpKX0saW5pdDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P251bGw6dm9pZCB0aGlzLmJ1aWxkUm9vdCgpfSxidWlsZExldmVsOmZ1bmN0aW9uKHQsZSl7dGhpcy5sZXZlbCsrLGUuY2xlYXIoKTtmb3IodmFyIG49MDtuPHQuc2l6ZSgpO24rPTIpe3ZhciBpPXQuZ2V0KG4pLHI9bisxPHQuc2l6ZSgpP3QuZ2V0KG4pOm51bGw7aWYobnVsbD09PXIpZS5hZGQoaSk7ZWxzZXt2YXIgcz1uZXcgem4odC5nZXQobiksdC5nZXQobisxKSk7ZS5hZGQocyl9fX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVm59fSksZShrbi5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXtpZih0aGlzLmlzRm9yY2VkVG9MaW5lU3RyaW5nJiZ0IGluc3RhbmNlb2YgYnQpe3ZhciBlPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSk7cmV0dXJuIHRoaXMubGluZXMuYWRkKGUpLG51bGx9dCBpbnN0YW5jZW9mIFN0JiZ0aGlzLmxpbmVzLmFkZCh0KX0sc2V0Rm9yY2VUb0xpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dGhpcy5pc0ZvcmNlZFRvTGluZVN0cmluZz10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga259fSksa24uZ2V0R2VvbWV0cnk9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0LmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGtuLmdldExpbmVzKHQpKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdO3JldHVybiBlLmdldEZhY3RvcnkoKS5idWlsZEdlb21ldHJ5KGtuLmdldExpbmVzKGUsbikpfX0sa24uZ2V0TGluZXM9ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBrbi5nZXRMaW5lcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoUihhcmd1bWVudHNbMF0sdikmJlIoYXJndW1lbnRzWzFdLHYpKXtmb3IodmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7a24uZ2V0TGluZXMocixuKX1yZXR1cm4gbn1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlwiYm9vbGVhblwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgcz1hcmd1bWVudHNbMF0sbz1hcmd1bWVudHNbMV0sYT1uZXcgSTtyZXR1cm4gcy5hcHBseShuZXcga24oYSxvKSksYX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEImJlIoYXJndW1lbnRzWzFdLHYpKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV07cmV0dXJuIHUgaW5zdGFuY2VvZiBTdD9sLmFkZCh1KTp1LmFwcGx5KG5ldyBrbihsKSksbH19ZWxzZSBpZigzPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJib29sZWFuXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJlIoYXJndW1lbnRzWzBdLHYpJiZSKGFyZ3VtZW50c1sxXSx2KSl7Zm9yKHZhciBoPWFyZ3VtZW50c1swXSxjPWFyZ3VtZW50c1sxXSxmPWFyZ3VtZW50c1syXSxpPWguaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2tuLmdldExpbmVzKHIsYyxmKX1yZXR1cm4gY31pZihcImJvb2xlYW5cIj09dHlwZW9mIGFyZ3VtZW50c1syXSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZSKGFyZ3VtZW50c1sxXSx2KSl7dmFyIGc9YXJndW1lbnRzWzBdLGQ9YXJndW1lbnRzWzFdLHA9YXJndW1lbnRzWzJdO3JldHVybiBnLmFwcGx5KG5ldyBrbihkLHApKSxkfX19LGUoWW4ucHJvdG90eXBlLHt2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQodCl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWW59fSksZShVbi5wcm90b3R5cGUse2xvY2F0ZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgbGUodCksbj1uZXcgWG4oZSk7cmV0dXJuIHRoaXMuaW5kZXgucXVlcnkodC55LHQueSxuKSxlLmdldExvY2F0aW9uKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW1JuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVW59fSksZShYbi5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuY291bnRlci5jb3VudFNlZ21lbnQoZS5nZXRDb29yZGluYXRlKDApLGUuZ2V0Q29vcmRpbmF0ZSgxKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWG59fSksZShIbi5wcm90b3R5cGUse2luaXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPWtuLmdldExpbmVzKHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1pLmdldENvb3JkaW5hdGVzKCk7dGhpcy5hZGRMaW5lKHIpfX0sYWRkTGluZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9MTtlPHQubGVuZ3RoO2UrKyl7dmFyIG49bmV3IGNlKHRbZS0xXSx0W2VdKSxpPU1hdGgubWluKG4ucDAueSxuLnAxLnkpLHI9TWF0aC5tYXgobi5wMC55LG4ucDEueSk7dGhpcy5pbmRleC5pbnNlcnQoaSxyLG4pfX0scXVlcnk6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49bmV3IFluO3JldHVybiB0aGlzLmluZGV4LnF1ZXJ5KHQsZSxuKSxuLmdldEl0ZW1zKCl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSxzPWFyZ3VtZW50c1syXTt0aGlzLmluZGV4LnF1ZXJ5KGkscixzKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEhufX0pLFVuLlNlZ21lbnRWaXNpdG9yPVhuLFVuLkludGVydmFsSW5kZXhlZEdlb21ldHJ5PUhuLGUoV24ucHJvdG90eXBlLHtnZXRTZWdtZW50SW5kZXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdtZW50SW5kZXh9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb29yZH0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludCh0aGlzLmNvb3JkKSx0LnByaW50KFwiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgpLHQucHJpbnRsbihcIiBkaXN0ID0gXCIrdGhpcy5kaXN0KX0sY29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7cmV0dXJuIHRoaXMuY29tcGFyZShlLnNlZ21lbnRJbmRleCxlLmRpc3QpfSxpc0VuZFBvaW50OmZ1bmN0aW9uKHQpe3JldHVybiAwPT09dGhpcy5zZWdtZW50SW5kZXgmJjA9PT10aGlzLmRpc3Q/ITA6dGhpcy5zZWdtZW50SW5kZXg9PT10fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvb3JkK1wiIHNlZyAjID0gXCIrdGhpcy5zZWdtZW50SW5kZXgrXCIgZGlzdCA9IFwiK3RoaXMuZGlzdH0sZ2V0RGlzdGFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXN0fSxjb21wYXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMuc2VnbWVudEluZGV4PHQ/LTE6dGhpcy5zZWdtZW50SW5kZXg+dD8xOnRoaXMuZGlzdDxlPy0xOnRoaXMuZGlzdD5lPzE6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFdufX0pLGUoam4ucHJvdG90eXBlLHtwcmludDpmdW5jdGlvbih0KXt0LnByaW50bG4oXCJJbnRlcnNlY3Rpb25zOlwiKTtmb3IodmFyIGU9dGhpcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5wcmludCh0KX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKS5pdGVyYXRvcigpfSxhZGRTcGxpdEVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuYWRkRW5kcG9pbnRzKCk7Zm9yKHZhciBlPXRoaXMuaXRlcmF0b3IoKSxuPWUubmV4dCgpO2UuaGFzTmV4dCgpOyl7dmFyIGk9ZS5uZXh0KCkscj10aGlzLmNyZWF0ZVNwbGl0RWRnZShuLGkpO3QuYWRkKHIpLG49aX19LGFkZEVuZHBvaW50czpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZWRnZS5wdHMubGVuZ3RoLTE7dGhpcy5hZGQodGhpcy5lZGdlLnB0c1swXSwwLDApLHRoaXMuYWRkKHRoaXMuZWRnZS5wdHNbdF0sdCwwKX0sY3JlYXRlU3BsaXRFZGdlOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5zZWdtZW50SW5kZXgtdC5zZWdtZW50SW5kZXgrMixpPXRoaXMuZWRnZS5wdHNbZS5zZWdtZW50SW5kZXhdLHI9ZS5kaXN0PjB8fCFlLmNvb3JkLmVxdWFsczJEKGkpO3J8fG4tLTt2YXIgcz1uZXcgQXJyYXkobikuZmlsbChudWxsKSxvPTA7c1tvKytdPW5ldyBnKHQuY29vcmQpO2Zvcih2YXIgYT10LnNlZ21lbnRJbmRleCsxO2E8PWUuc2VnbWVudEluZGV4O2ErKylzW28rK109dGhpcy5lZGdlLnB0c1thXTtyZXR1cm4gciYmKHNbb109ZS5jb29yZCksbmV3IEpuKHMsbmV3IGduKHRoaXMuZWRnZS5sYWJlbCkpfSxhZGQ6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBXbih0LGUsbikscj10aGlzLm5vZGVNYXAuZ2V0KGkpO3JldHVybiBudWxsIT09cj9yOih0aGlzLm5vZGVNYXAucHV0KGksaSksaSl9LGlzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZihuLmNvb3JkLmVxdWFscyh0KSlyZXR1cm4hMH1yZXR1cm4hMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gam59fSksZShLbi5wcm90b3R5cGUse2dldENoYWluU3RhcnRJbmRpY2VzOmZ1bmN0aW9uKHQpe3ZhciBlPTAsbj1uZXcgSTtuLmFkZChuZXcgYihlKSk7ZG97dmFyIGk9dGhpcy5maW5kQ2hhaW5FbmQodCxlKTtuLmFkZChuZXcgYihpKSksZT1pfXdoaWxlKGU8dC5sZW5ndGgtMSk7dmFyIHI9S24udG9JbnRBcnJheShuKTtyZXR1cm4gcn0sZmluZENoYWluRW5kOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPUplLnF1YWRyYW50KHRbZV0sdFtlKzFdKSxpPWUrMTtpPHQubGVuZ3RoOyl7dmFyIHI9SmUucXVhZHJhbnQodFtpLTFdLHRbaV0pO2lmKHIhPT1uKWJyZWFrO2krK31yZXR1cm4gaS0xfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLbn19KSxLbi50b0ludEFycmF5PWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5zaXplKCkpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09dC5nZXQobikuaW50VmFsdWUoKTtyZXR1cm4gZX0sZShabi5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxnZXRNYXhYOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBlPm4/ZTpufSxnZXRNaW5YOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0XV0ueCxuPXRoaXMucHRzW3RoaXMuc3RhcnRJbmRleFt0KzFdXS54O3JldHVybiBuPmU/ZTpufSxjb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluOmZ1bmN0aW9uKCl7aWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWFyZ3VtZW50c1szXTt0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4odGhpcy5zdGFydEluZGV4W3RdLHRoaXMuc3RhcnRJbmRleFt0KzFdLGUsZS5zdGFydEluZGV4W25dLGUuc3RhcnRJbmRleFtuKzFdLGkpfWVsc2UgaWYoNj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXSxhPWFyZ3VtZW50c1szXSx1PWFyZ3VtZW50c1s0XSxsPWFyZ3VtZW50c1s1XSxoPXRoaXMucHRzW3JdLGM9dGhpcy5wdHNbc10sZj1vLnB0c1thXSxnPW8ucHRzW3VdO2lmKHMtcj09PTEmJnUtYT09PTEpcmV0dXJuIGwuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmUscixvLmUsYSksbnVsbDtpZih0aGlzLmVudjEuaW5pdChoLGMpLHRoaXMuZW52Mi5pbml0KGYsZyksIXRoaXMuZW52MS5pbnRlcnNlY3RzKHRoaXMuZW52MikpcmV0dXJuIG51bGw7dmFyIGQ9TWF0aC50cnVuYygocitzKS8yKSxwPU1hdGgudHJ1bmMoKGErdSkvMik7ZD5yJiYocD5hJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4ocixkLG8sYSxwLGwpLHU+cCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKHIsZCxvLHAsdSxsKSkscz5kJiYocD5hJiZ0aGlzLmNvbXB1dGVJbnRlcnNlY3RzRm9yQ2hhaW4oZCxzLG8sYSxwLGwpLHU+cCYmdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKGQscyxvLHAsdSxsKSl9fSxnZXRTdGFydEluZGV4ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdGFydEluZGV4fSxjb21wdXRlSW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dGhpcy5zdGFydEluZGV4Lmxlbmd0aC0xO24rKylmb3IodmFyIGk9MDtpPHQuc3RhcnRJbmRleC5sZW5ndGgtMTtpKyspdGhpcy5jb21wdXRlSW50ZXJzZWN0c0ZvckNoYWluKG4sdCxpLGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBabn19KSxlKFFuLnByb3RvdHlwZSx7Z2V0RGVwdGg6ZnVuY3Rpb24odCxlKXtyZXR1cm4gdGhpcy5kZXB0aFt0XVtlXX0sc2V0RGVwdGg6ZnVuY3Rpb24odCxlLG4pe3RoaXMuZGVwdGhbdF1bZV09bn0saXNOdWxsOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD0wOzI+dDt0KyspZm9yKHZhciBlPTA7Mz5lO2UrKylpZih0aGlzLmRlcHRoW3RdW2VdIT09UW4uTlVMTF9WQUxVRSlyZXR1cm4hMTtyZXR1cm4hMH1pZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmRlcHRoW25dWzFdPT09UW4uTlVMTF9WQUxVRX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLmRlcHRoW2ldW3JdPT09UW4uTlVMTF9WQUxVRX19LG5vcm1hbGl6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wOzI+dDt0KyspaWYoIXRoaXMuaXNOdWxsKHQpKXt2YXIgZT10aGlzLmRlcHRoW3RdWzFdO3RoaXMuZGVwdGhbdF1bMl08ZSYmKGU9dGhpcy5kZXB0aFt0XVsyXSksMD5lJiYoZT0wKTtmb3IodmFyIG49MTszPm47bisrKXt2YXIgaT0wO3RoaXMuZGVwdGhbdF1bbl0+ZSYmKGk9MSksdGhpcy5kZXB0aFt0XVtuXT1pfX19LGdldERlbHRhOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmRlcHRoW3RdW2NuLlJJR0hUXS10aGlzLmRlcHRoW3RdW2NuLkxFRlRdfSxnZXRMb2NhdGlvbjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLmRlcHRoW3RdW2VdPD0wP0wuRVhURVJJT1I6TC5JTlRFUklPUn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIkE6IFwiK3RoaXMuZGVwdGhbMF1bMV0rXCIsXCIrdGhpcy5kZXB0aFswXVsyXStcIiBCOiBcIit0aGlzLmRlcHRoWzFdWzFdK1wiLFwiK3RoaXMuZGVwdGhbMV1bMl19LGFkZDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wOzI+ZTtlKyspZm9yKHZhciBuPTE7Mz5uO24rKyl7dmFyIGk9dC5nZXRMb2NhdGlvbihlLG4pO2khPT1MLkVYVEVSSU9SJiZpIT09TC5JTlRFUklPUnx8KHRoaXMuaXNOdWxsKGUsbik/dGhpcy5kZXB0aFtlXVtuXT1Rbi5kZXB0aEF0TG9jYXRpb24oaSk6dGhpcy5kZXB0aFtlXVtuXSs9UW4uZGVwdGhBdExvY2F0aW9uKGkpKX1lbHNlIGlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07bz09PUwuSU5URVJJT1ImJnRoaXMuZGVwdGhbcl1bc10rK319LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFufX0pLFFuLmRlcHRoQXRMb2NhdGlvbj1mdW5jdGlvbih0KXtyZXR1cm4gdD09PUwuRVhURVJJT1I/MDp0PT09TC5JTlRFUklPUj8xOlFuLk5VTExfVkFMVUV9LFFuLk5VTExfVkFMVUU9LTEsaChKbixtbiksZShKbi5wcm90b3R5cGUse2dldERlcHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVwdGh9LGdldENvbGxhcHNlZEVkZ2U6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgQXJyYXkoMikuZmlsbChudWxsKTt0WzBdPXRoaXMucHRzWzBdLHRbMV09dGhpcy5wdHNbMV07dmFyIGU9bmV3IEpuKHQsZ24udG9MaW5lTGFiZWwodGhpcy5sYWJlbCkpO3JldHVybiBlfSxpc0lzb2xhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSXNvbGF0ZWR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzfSxzZXRJc29sYXRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc0lzb2xhdGVkPXR9LHNldE5hbWU6ZnVuY3Rpb24odCl7dGhpcy5uYW1lPXR9LGVxdWFsczpmdW5jdGlvbih0KXtpZighKHQgaW5zdGFuY2VvZiBKbikpcmV0dXJuITE7dmFyIGU9dDtpZih0aGlzLnB0cy5sZW5ndGghPT1lLnB0cy5sZW5ndGgpcmV0dXJuITE7Zm9yKHZhciBuPSEwLGk9ITAscj10aGlzLnB0cy5sZW5ndGgscz0wO3M8dGhpcy5wdHMubGVuZ3RoO3MrKylpZih0aGlzLnB0c1tzXS5lcXVhbHMyRChlLnB0c1tzXSl8fChuPSExKSx0aGlzLnB0c1tzXS5lcXVhbHMyRChlLnB0c1stLXJdKXx8KGk9ITEpLCFuJiYhaSlyZXR1cm4hMTtyZXR1cm4hMH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0aGlzLnB0cy5sZW5ndGg+MD90aGlzLnB0c1swXTpudWxsO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMucHRzW3RdfX0scHJpbnQ6ZnVuY3Rpb24odCl7dC5wcmludChcImVkZ2UgXCIrdGhpcy5uYW1lK1wiOiBcIiksdC5wcmludChcIkxJTkVTVFJJTkcgKFwiKTtmb3IodmFyIGU9MDtlPHRoaXMucHRzLmxlbmd0aDtlKyspZT4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KHRoaXMucHRzW2VdLngrXCIgXCIrdGhpcy5wdHNbZV0ueSk7dC5wcmludChcIikgIFwiK3RoaXMubGFiZWwrXCIgXCIrdGhpcy5kZXB0aERlbHRhKX0sY29tcHV0ZUlNOmZ1bmN0aW9uKHQpe0puLnVwZGF0ZUlNKHRoaXMubGFiZWwsdCl9LGlzQ29sbGFwc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWwuaXNBcmVhKCk/MyE9PXRoaXMucHRzLmxlbmd0aD8hMTohIXRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1syXSk6ITF9LGlzQ2xvc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzWzBdLmVxdWFscyh0aGlzLnB0c1t0aGlzLnB0cy5sZW5ndGgtMV0pfSxnZXRNYXhpbXVtU2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aC0xfSxnZXREZXB0aERlbHRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGVwdGhEZWx0YX0sZ2V0TnVtUG9pbnRzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHRzLmxlbmd0aH0scHJpbnRSZXZlcnNlOmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpO2Zvcih2YXIgZT10aGlzLnB0cy5sZW5ndGgtMTtlPj0wO2UtLSl0LnByaW50KHRoaXMucHRzW2VdK1wiIFwiKTt0LnByaW50bG4oXCJcIil9LGdldE1vbm90b25lQ2hhaW5FZGdlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLm1jZSYmKHRoaXMubWNlPW5ldyBabih0aGlzKSksdGhpcy5tY2V9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuZW52KXt0aGlzLmVudj1uZXcgQztmb3IodmFyIHQ9MDt0PHRoaXMucHRzLmxlbmd0aDt0KyspdGhpcy5lbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMucHRzW3RdKX1yZXR1cm4gdGhpcy5lbnZ9LGFkZEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgZyh0LmdldEludGVyc2VjdGlvbihpKSkscz1lLG89dC5nZXRFZGdlRGlzdGFuY2UobixpKSxhPXMrMTtpZihhPHRoaXMucHRzLmxlbmd0aCl7dmFyIHU9dGhpcy5wdHNbYV07ci5lcXVhbHMyRCh1KSYmKHM9YSxvPTApfXRoaXMuZWlMaXN0LmFkZChyLHMsbyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IFA7dC5hcHBlbmQoXCJlZGdlIFwiK3RoaXMubmFtZStcIjogXCIpLHQuYXBwZW5kKFwiTElORVNUUklORyAoXCIpO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKyllPjAmJnQuYXBwZW5kKFwiLFwiKSx0LmFwcGVuZCh0aGlzLnB0c1tlXS54K1wiIFwiK3RoaXMucHRzW2VdLnkpO3JldHVybiB0LmFwcGVuZChcIikgIFwiK3RoaXMubGFiZWwrXCIgXCIrdGhpcy5kZXB0aERlbHRhKSx0LnRvU3RyaW5nKCl9LGlzUG9pbnR3aXNlRXF1YWw6ZnVuY3Rpb24odCl7aWYodGhpcy5wdHMubGVuZ3RoIT09dC5wdHMubGVuZ3RoKXJldHVybiExO2Zvcih2YXIgZT0wO2U8dGhpcy5wdHMubGVuZ3RoO2UrKylpZighdGhpcy5wdHNbZV0uZXF1YWxzMkQodC5wdHNbZV0pKXJldHVybiExO3JldHVybiEwfSxzZXREZXB0aERlbHRhOmZ1bmN0aW9uKHQpe3RoaXMuZGVwdGhEZWx0YT10fSxnZXRFZGdlSW50ZXJzZWN0aW9uTGlzdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVpTGlzdH0sYWRkSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPTA7aTx0LmdldEludGVyc2VjdGlvbk51bSgpO2krKyl0aGlzLmFkZEludGVyc2VjdGlvbih0LGUsbixpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSm59fSksSm4udXBkYXRlSU09ZnVuY3Rpb24oKXtpZigyIT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4gbW4ucHJvdG90eXBlLnVwZGF0ZUlNLmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV07ZS5zZXRBdExlYXN0SWZWYWxpZCh0LmdldExvY2F0aW9uKDAsY24uT04pLHQuZ2V0TG9jYXRpb24oMSxjbi5PTiksMSksdC5pc0FyZWEoKSYmKGUuc2V0QXRMZWFzdElmVmFsaWQodC5nZXRMb2NhdGlvbigwLGNuLkxFRlQpLHQuZ2V0TG9jYXRpb24oMSxjbi5MRUZUKSwyKSxlLnNldEF0TGVhc3RJZlZhbGlkKHQuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCksdC5nZXRMb2NhdGlvbigxLGNuLlJJR0hUKSwyKSl9LGgoJG4sQ24pLGUoJG4ucHJvdG90eXBlLHtpbnNlcnRCb3VuZGFyeVBvaW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5ub2Rlcy5hZGROb2RlKGUpLGk9bi5nZXRMYWJlbCgpLHI9MSxzPUwuTk9ORTtzPWkuZ2V0TG9jYXRpb24odCxjbi5PTikscz09PUwuQk9VTkRBUlkmJnIrKzt2YXIgbz0kbi5kZXRlcm1pbmVCb3VuZGFyeSh0aGlzLmJvdW5kYXJ5Tm9kZVJ1bGUscik7aS5zZXRMb2NhdGlvbih0LG8pfSxjb21wdXRlU2VsZk5vZGVzOmZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gdGhpcy5jb21wdXRlU2VsZk5vZGVzKHQsZSwhMSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPWFyZ3VtZW50c1syXSxzPW5ldyBBbihuLCEwLCExKTtzLnNldElzRG9uZUlmUHJvcGVySW50KHIpO3ZhciBvPXRoaXMuY3JlYXRlRWRnZVNldEludGVyc2VjdG9yKCksYT10aGlzLnBhcmVudEdlb20gaW5zdGFuY2VvZiBidHx8dGhpcy5wYXJlbnRHZW9tIGluc3RhbmNlb2YgVHR8fHRoaXMucGFyZW50R2VvbSBpbnN0YW5jZW9mIE90LHU9aXx8IWE7cmV0dXJuIG8uY29tcHV0ZUludGVyc2VjdGlvbnModGhpcy5lZGdlcyxzLHUpLHRoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGVzKHRoaXMuYXJnSW5kZXgpLHN9fSxjb21wdXRlU3BsaXRFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5lZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5laUxpc3QuYWRkU3BsaXRFZGdlcyh0KX19LGNvbXB1dGVFZGdlSW50ZXJzZWN0aW9uczpmdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IEFuKGUsbiwhMCk7aS5zZXRCb3VuZGFyeU5vZGVzKHRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLHQuZ2V0Qm91bmRhcnlOb2RlcygpKTt2YXIgcj10aGlzLmNyZWF0ZUVkZ2VTZXRJbnRlcnNlY3RvcigpO3JldHVybiByLmNvbXB1dGVJbnRlcnNlY3Rpb25zKHRoaXMuZWRnZXMsdC5lZGdlcyxpKSxpfSxnZXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudEdlb219LGdldEJvdW5kYXJ5Tm9kZVJ1bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ib3VuZGFyeU5vZGVSdWxlfSxoYXNUb29GZXdQb2ludHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzfSxhZGRQb2ludDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0Q29vcmRpbmF0ZSgpO3RoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxlLEwuSU5URVJJT1IpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgbj1hcmd1bWVudHNbMF07dGhpcy5pbnNlcnRQb2ludCh0aGlzLmFyZ0luZGV4LG4sTC5JTlRFUklPUil9fSxhZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe3RoaXMuYWRkUG9seWdvblJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSxMLkVYVEVSSU9SLEwuSU5URVJJT1IpO2Zvcih2YXIgZT0wO2U8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtlKyspe3ZhciBuPXQuZ2V0SW50ZXJpb3JSaW5nTihlKTt0aGlzLmFkZFBvbHlnb25SaW5nKG4sTC5JTlRFUklPUixMLkVYVEVSSU9SKX19LGFkZEVkZ2U6ZnVuY3Rpb24odCl7dGhpcy5pbnNlcnRFZGdlKHQpO3ZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZVswXSxMLkJPVU5EQVJZKSx0aGlzLmluc2VydFBvaW50KHRoaXMuYXJnSW5kZXgsZVtlLmxlbmd0aC0xXSxMLkJPVU5EQVJZKX0sYWRkTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gdGhpcy5faGFzVG9vRmV3UG9pbnRzPSEwLHRoaXMuaW52YWxpZFBvaW50PWVbMF0sbnVsbDt2YXIgbj1uZXcgSm4oZSxuZXcgZ24odGhpcy5hcmdJbmRleCxMLklOVEVSSU9SKSk7dGhpcy5saW5lRWRnZU1hcC5wdXQodCxuKSx0aGlzLmluc2VydEVkZ2UobiksZi5pc1RydWUoZS5sZW5ndGg+PTIsXCJmb3VuZCBMaW5lU3RyaW5nIHdpdGggc2luZ2xlIHBvaW50XCIpLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLmFyZ0luZGV4LGVbMF0pLHRoaXMuaW5zZXJ0Qm91bmRhcnlQb2ludCh0aGlzLmFyZ0luZGV4LGVbZS5sZW5ndGgtMV0pfSxnZXRJbnZhbGlkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZhbGlkUG9pbnR9LGdldEJvdW5kYXJ5UG9pbnRzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ2V0Qm91bmRhcnlOb2RlcygpLGU9bmV3IEFycmF5KHQuc2l6ZSgpKS5maWxsKG51bGwpLG49MCxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2VbbisrXT1yLmdldENvb3JkaW5hdGUoKS5jb3B5KCl9cmV0dXJuIGV9LGdldEJvdW5kYXJ5Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuYm91bmRhcnlOb2RlcyYmKHRoaXMuYm91bmRhcnlOb2Rlcz10aGlzLm5vZGVzLmdldEJvdW5kYXJ5Tm9kZXModGhpcy5hcmdJbmRleCkpLHRoaXMuYm91bmRhcnlOb2Rlc30sYWRkU2VsZkludGVyc2VjdGlvbk5vZGU6ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0aGlzLmlzQm91bmRhcnlOb2RlKHQsZSk/bnVsbDp2b2lkKG49PT1MLkJPVU5EQVJZJiZ0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU/dGhpcy5pbnNlcnRCb3VuZGFyeVBvaW50KHQsZSk6dGhpcy5pbnNlcnRQb2ludCh0LGUsbikpfSxhZGRQb2x5Z29uUmluZzpmdW5jdGlvbih0LGUsbil7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGk9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGkubGVuZ3RoPDQpcmV0dXJuIHRoaXMuX2hhc1Rvb0Zld1BvaW50cz0hMCx0aGlzLmludmFsaWRQb2ludD1pWzBdLG51bGw7dmFyIHI9ZSxzPW47aGUuaXNDQ1coaSkmJihyPW4scz1lKTt2YXIgbz1uZXcgSm4oaSxuZXcgZ24odGhpcy5hcmdJbmRleCxMLkJPVU5EQVJZLHIscykpO3RoaXMubGluZUVkZ2VNYXAucHV0KHQsbyksdGhpcy5pbnNlcnRFZGdlKG8pLHRoaXMuaW5zZXJ0UG9pbnQodGhpcy5hcmdJbmRleCxpWzBdLEwuQk9VTkRBUlkpfSxpbnNlcnRQb2ludDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5ub2Rlcy5hZGROb2RlKGUpLHI9aS5nZXRMYWJlbCgpO251bGw9PT1yP2kubGFiZWw9bmV3IGduKHQsbik6ci5zZXRMb2NhdGlvbih0LG4pfSxjcmVhdGVFZGdlU2V0SW50ZXJzZWN0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IEZufSxhZGRTZWxmSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5laUxpc3QuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO3RoaXMuYWRkU2VsZkludGVyc2VjdGlvbk5vZGUodCxzLmNvb3JkLGkpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoMSE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIENuLnByb3RvdHlwZS5hZGQuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZih0IGluc3RhbmNlb2YgT3QmJih0aGlzLnVzZUJvdW5kYXJ5RGV0ZXJtaW5hdGlvblJ1bGU9ITEpLHQgaW5zdGFuY2VvZiBUdCl0aGlzLmFkZFBvbHlnb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRMaW5lU3RyaW5nKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIEx0KXRoaXMuYWRkUG9pbnQodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgUHQpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGd0KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBPdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZXtpZighKHQgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKHQuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuYWRkQ29sbGVjdGlvbih0KX19LGFkZENvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX0sbG9jYXRlOmZ1bmN0aW9uKHQpe3JldHVybiBSKHRoaXMucGFyZW50R2VvbSxSdCkmJnRoaXMucGFyZW50R2VvbS5nZXROdW1HZW9tZXRyaWVzKCk+NTA/KG51bGw9PT10aGlzLmFyZWFQdExvY2F0b3ImJih0aGlzLmFyZWFQdExvY2F0b3I9bmV3IFVuKHRoaXMucGFyZW50R2VvbSkpLHRoaXMuYXJlYVB0TG9jYXRvci5sb2NhdGUodCkpOnRoaXMucHRMb2NhdG9yLmxvY2F0ZSh0LHRoaXMucGFyZW50R2VvbSl9LGZpbmRFZGdlOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5saW5lRWRnZU1hcC5nZXQodCl9cmV0dXJuIENuLnByb3RvdHlwZS5maW5kRWRnZS5hcHBseSh0aGlzLGFyZ3VtZW50cyl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuICRufX0pLCRuLmRldGVybWluZUJvdW5kYXJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNJbkJvdW5kYXJ5KGUpP0wuQk9VTkRBUlk6TC5JTlRFUklPUn0sZSh0aS5wcm90b3R5cGUse2dldEFyZ0dlb21ldHJ5OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmFyZ1t0XS5nZXRHZW9tZXRyeSgpfSxzZXRDb21wdXRhdGlvblByZWNpc2lvbjpmdW5jdGlvbih0KXt0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsPXQsdGhpcy5saS5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLnJlc3VsdFByZWNpc2lvbk1vZGVsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdGl9fSksZShlaS5wcm90b3R5cGUse2NvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10LG49ZWkuY29tcGFyZU9yaWVudGVkKHRoaXMucHRzLHRoaXMuX29yaWVudGF0aW9uLGUucHRzLGUuX29yaWVudGF0aW9uKTtyZXR1cm4gbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVpfX0pLGVpLm9yaWVudGF0aW9uPWZ1bmN0aW9uKHQpe3JldHVybiAxPT09SC5pbmNyZWFzaW5nRGlyZWN0aW9uKHQpfSxlaS5jb21wYXJlT3JpZW50ZWQ9ZnVuY3Rpb24odCxlLG4saSl7Zm9yKHZhciByPWU/MTotMSxzPWk/MTotMSxvPWU/dC5sZW5ndGg6LTEsYT1pP24ubGVuZ3RoOi0xLHU9ZT8wOnQubGVuZ3RoLTEsbD1pPzA6bi5sZW5ndGgtMTs7KXt2YXIgaD10W3VdLmNvbXBhcmVUbyhuW2xdKTtpZigwIT09aClyZXR1cm4gaDt1Kz1yLGwrPXM7dmFyIGM9dT09PW8sZj1sPT09YTtpZihjJiYhZilyZXR1cm4tMTtpZighYyYmZilyZXR1cm4gMTtpZihjJiZmKXJldHVybiAwfX0sZShuaS5wcm90b3R5cGUse3ByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnQoXCJNVUxUSUxJTkVTVFJJTkcgKCBcIik7Zm9yKHZhciBlPTA7ZTx0aGlzLmVkZ2VzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMuZWRnZXMuZ2V0KGUpO2U+MCYmdC5wcmludChcIixcIiksdC5wcmludChcIihcIik7Zm9yKHZhciBpPW4uZ2V0Q29vcmRpbmF0ZXMoKSxyPTA7cjxpLmxlbmd0aDtyKyspcj4wJiZ0LnByaW50KFwiLFwiKSx0LnByaW50KGlbcl0ueCtcIiBcIitpW3JdLnkpO3QucHJpbnRsbihcIilcIil9dC5wcmludChcIikgIFwiKX0sYWRkQWxsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXRoaXMuYWRkKGUubmV4dCgpKX0sZmluZEVkZ2VJbmRleDpmdW5jdGlvbih0KXtmb3IodmFyIGU9MDtlPHRoaXMuZWRnZXMuc2l6ZSgpO2UrKylpZih0aGlzLmVkZ2VzLmdldChlKS5lcXVhbHModCkpcmV0dXJuIGU7cmV0dXJuLTF9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZWRnZXMuaXRlcmF0b3IoKX0sZ2V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlc30sZ2V0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVkZ2VzLmdldCh0KX0sZmluZEVxdWFsRWRnZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZWkodC5nZXRDb29yZGluYXRlcygpKSxuPXRoaXMub2NhTWFwLmdldChlKTtyZXR1cm4gbn0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMuYWRkKHQpO3ZhciBlPW5ldyBlaSh0LmdldENvb3JkaW5hdGVzKCkpO3RoaXMub2NhTWFwLnB1dChlLHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBuaX19KSxoKGlpLHRpKSxlKGlpLnByb3RvdHlwZSx7aW5zZXJ0VW5pcXVlRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmVkZ2VMaXN0LmZpbmRFcXVhbEVkZ2UodCk7aWYobnVsbCE9PWUpe3ZhciBuPWUuZ2V0TGFiZWwoKSxpPXQuZ2V0TGFiZWwoKTtlLmlzUG9pbnR3aXNlRXF1YWwodCl8fChpPW5ldyBnbih0LmdldExhYmVsKCkpLGkuZmxpcCgpKTt2YXIgcj1lLmdldERlcHRoKCk7ci5pc051bGwoKSYmci5hZGQobiksci5hZGQoaSksbi5tZXJnZShpKX1lbHNlIHRoaXMuZWRnZUxpc3QuYWRkKHQpfSxnZXRHcmFwaDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmdyYXBofSxjYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRTeW0oKTtlLmlzSW5SZXN1bHQoKSYmbi5pc0luUmVzdWx0KCkmJihlLnNldEluUmVzdWx0KCExKSxuLnNldEluUmVzdWx0KCExKSl9fSxpc0NvdmVyZWRCeUxBOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzQ292ZXJlZCh0LHRoaXMucmVzdWx0TGluZUxpc3QpPyEwOiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0sY29tcHV0ZUdlb21ldHJ5OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW5ldyBJO3JldHVybiByLmFkZEFsbCh0KSxyLmFkZEFsbChlKSxyLmFkZEFsbChuKSxyLmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpLHRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCksdGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKSx0aGlzLmdlb21GYWN0KTp0aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkocil9LG1lcmdlU3ltTGFiZWxzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLm1lcmdlU3ltTGFiZWxzKCl9fSxpc0NvdmVyZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj10aGlzLnB0TG9jYXRvci5sb2NhdGUodCxpKTtpZihyIT09TC5FWFRFUklPUilyZXR1cm4hMH1yZXR1cm4hMX0scmVwbGFjZUNvbGxhcHNlZEVkZ2VzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5lZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5pc0NvbGxhcHNlZCgpJiYoZS5yZW1vdmUoKSx0LmFkZChuLmdldENvbGxhcHNlZEVkZ2UoKSkpfXRoaXMuZWRnZUxpc3QuYWRkQWxsKHQpfSx1cGRhdGVOb2RlTGFiZWxsaW5nOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCksbj1lLmdldEVkZ2VzKCkuZ2V0TGFiZWwoKTtlLmdldExhYmVsKCkubWVyZ2Uobil9fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb21wdXRlT3ZlcmxheSh0KSx0aGlzLnJlc3VsdEdlb219LGluc2VydFVuaXF1ZUVkZ2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFVuaXF1ZUVkZ2Uobil9fSxjb21wdXRlT3ZlcmxheTpmdW5jdGlvbih0KXt0aGlzLmNvcHlQb2ludHMoMCksdGhpcy5jb3B5UG9pbnRzKDEpLHRoaXMuYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKSx0aGlzLmFyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5hcmdbMV0sdGhpcy5saSwhMCk7dmFyIGU9bmV3IEk7dGhpcy5hcmdbMF0uY29tcHV0ZVNwbGl0RWRnZXMoZSksdGhpcy5hcmdbMV0uY29tcHV0ZVNwbGl0RWRnZXMoZSk7dGhpcy5pbnNlcnRVbmlxdWVFZGdlcyhlKSx0aGlzLmNvbXB1dGVMYWJlbHNGcm9tRGVwdGhzKCksdGhpcy5yZXBsYWNlQ29sbGFwc2VkRWRnZXMoKSxsbi5jaGVja1ZhbGlkKHRoaXMuZWRnZUxpc3QuZ2V0RWRnZXMoKSksdGhpcy5ncmFwaC5hZGRFZGdlcyh0aGlzLmVkZ2VMaXN0LmdldEVkZ2VzKCkpLHRoaXMuY29tcHV0ZUxhYmVsbGluZygpLHRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZXMoKSx0aGlzLmZpbmRSZXN1bHRBcmVhRWRnZXModCksdGhpcy5jYW5jZWxEdXBsaWNhdGVSZXN1bHRFZGdlcygpO3ZhciBuPW5ldyBTbih0aGlzLmdlb21GYWN0KTtuLmFkZCh0aGlzLmdyYXBoKSx0aGlzLnJlc3VsdFBvbHlMaXN0PW4uZ2V0UG9seWdvbnMoKTt2YXIgaT1uZXcgd24odGhpcyx0aGlzLmdlb21GYWN0LHRoaXMucHRMb2NhdG9yKTt0aGlzLnJlc3VsdExpbmVMaXN0PWkuYnVpbGQodCk7dmFyIHI9bmV3IExuKHRoaXMsdGhpcy5nZW9tRmFjdCx0aGlzLnB0TG9jYXRvcik7dGhpcy5yZXN1bHRQb2ludExpc3Q9ci5idWlsZCh0KSxcbnRoaXMucmVzdWx0R2VvbT10aGlzLmNvbXB1dGVHZW9tZXRyeSh0aGlzLnJlc3VsdFBvaW50TGlzdCx0aGlzLnJlc3VsdExpbmVMaXN0LHRoaXMucmVzdWx0UG9seUxpc3QsdCl9LGxhYmVsSW5jb21wbGV0ZU5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSk7dC5nZXRMYWJlbCgpLnNldExvY2F0aW9uKGUsbil9LGNvcHlQb2ludHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldE5vZGVJdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT10aGlzLmdyYXBoLmFkZE5vZGUobi5nZXRDb29yZGluYXRlKCkpO2kuc2V0TGFiZWwodCxuLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkpfX0sZmluZFJlc3VsdEFyZWFFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dGhpcy5ncmFwaC5nZXRFZGdlRW5kcygpLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW4uZ2V0TGFiZWwoKTtpLmlzQXJlYSgpJiYhbi5pc0ludGVyaW9yQXJlYUVkZ2UoKSYmaWkuaXNSZXN1bHRPZk9wKGkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCksaS5nZXRMb2NhdGlvbigxLGNuLlJJR0hUKSx0KSYmbi5zZXRJblJlc3VsdCghMCl9fSxjb21wdXRlTGFiZWxzRnJvbURlcHRoczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKSxuPWUuZ2V0TGFiZWwoKSxpPWUuZ2V0RGVwdGgoKTtpZighaS5pc051bGwoKSl7aS5ub3JtYWxpemUoKTtmb3IodmFyIHI9MDsyPnI7cisrKW4uaXNOdWxsKHIpfHwhbi5pc0FyZWEoKXx8aS5pc051bGwocil8fCgwPT09aS5nZXREZWx0YShyKT9uLnRvTGluZShyKTooZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uTEVGVCksXCJkZXB0aCBvZiBMRUZUIHNpZGUgaGFzIG5vdCBiZWVuIGluaXRpYWxpemVkXCIpLG4uc2V0TG9jYXRpb24ocixjbi5MRUZULGkuZ2V0TG9jYXRpb24ocixjbi5MRUZUKSksZi5pc1RydWUoIWkuaXNOdWxsKHIsY24uUklHSFQpLFwiZGVwdGggb2YgUklHSFQgc2lkZSBoYXMgbm90IGJlZW4gaW5pdGlhbGl6ZWRcIiksbi5zZXRMb2NhdGlvbihyLGNuLlJJR0hULGkuZ2V0TG9jYXRpb24ocixjbi5SSUdIVCkpKSl9fX0sY29tcHV0ZUxhYmVsbGluZzpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpO2UuZ2V0RWRnZXMoKS5jb21wdXRlTGFiZWxsaW5nKHRoaXMuYXJnKX10aGlzLm1lcmdlU3ltTGFiZWxzKCksdGhpcy51cGRhdGVOb2RlTGFiZWxsaW5nKCl9LGxhYmVsSW5jb21wbGV0ZU5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT10aGlzLmdyYXBoLmdldE5vZGVzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpO24uaXNJc29sYXRlZCgpJiYodCsrLGkuaXNOdWxsKDApP3RoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDApOnRoaXMubGFiZWxJbmNvbXBsZXRlTm9kZShuLDEpKSxuLmdldEVkZ2VzKCkudXBkYXRlTGFiZWxsaW5nKGkpfX0saXNDb3ZlcmVkQnlBOmZ1bmN0aW9uKHQpe3JldHVybiEhdGhpcy5pc0NvdmVyZWQodCx0aGlzLnJlc3VsdFBvbHlMaXN0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaWl9fSksaWkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgaWkodCxlKSxyPWkuZ2V0UmVzdWx0R2VvbWV0cnkobik7cmV0dXJuIHJ9LGlpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpfHxlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuSU5URVJTRUNUSU9OLHQsZSx0LmdldEZhY3RvcnkoKSk7aWYodC5pc0dlb21ldHJ5Q29sbGVjdGlvbigpKXt2YXIgbj1lO3JldHVybiBobi5tYXAodCx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bTWFwT3BdfSxtYXA6ZnVuY3Rpb24odCl7cmV0dXJuIHQuaW50ZXJzZWN0aW9uKG4pfX0pfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5JTlRFUlNFQ1RJT04pfSxpaS5zeW1EaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7aWYodC5pc0VtcHR5KCl8fGUuaXNFbXB0eSgpKXtpZih0LmlzRW1wdHkoKSYmZS5pc0VtcHR5KCkpcmV0dXJuIGlpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLlNZTURJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0saWkucmVzdWx0RGltZW5zaW9uPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmdldERpbWVuc2lvbigpLHI9bi5nZXREaW1lbnNpb24oKSxzPS0xO3N3aXRjaCh0KXtjYXNlIGlpLklOVEVSU0VDVElPTjpzPU1hdGgubWluKGkscik7YnJlYWs7Y2FzZSBpaS5VTklPTjpzPU1hdGgubWF4KGkscik7YnJlYWs7Y2FzZSBpaS5ESUZGRVJFTkNFOnM9aTticmVhaztjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cz1NYXRoLm1heChpLHIpfXJldHVybiBzfSxpaS5jcmVhdGVFbXB0eVJlc3VsdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj1udWxsO3N3aXRjaChpaS5yZXN1bHREaW1lbnNpb24odCxlLG4pKXtjYXNlLTE6cj1pLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihuZXcgQXJyYXkoMCkuZmlsbChudWxsKSk7YnJlYWs7Y2FzZSAwOnI9aS5jcmVhdGVQb2ludCgpO2JyZWFrO2Nhc2UgMTpyPWkuY3JlYXRlTGluZVN0cmluZygpO2JyZWFrO2Nhc2UgMjpyPWkuY3JlYXRlUG9seWdvbigpfXJldHVybiByfSxpaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuaXNFbXB0eSgpP2lpLmNyZWF0ZUVtcHR5UmVzdWx0KGlpLkRJRkZFUkVOQ0UsdCxlLHQuZ2V0RmFjdG9yeSgpKTplLmlzRW1wdHkoKT90LmNvcHkoKToodC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSx0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKGUpLHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSkpfSxpaS5pc1Jlc3VsdE9mT3A9ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49dC5nZXRMb2NhdGlvbigwKSxpPXQuZ2V0TG9jYXRpb24oMSk7cmV0dXJuIGlpLmlzUmVzdWx0T2ZPcChuLGksZSl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxvPWFyZ3VtZW50c1syXTtzd2l0Y2gocj09PUwuQk9VTkRBUlkmJihyPUwuSU5URVJJT1IpLHM9PT1MLkJPVU5EQVJZJiYocz1MLklOVEVSSU9SKSxvKXtjYXNlIGlpLklOVEVSU0VDVElPTjpyZXR1cm4gcj09PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SO2Nhc2UgaWkuVU5JT046cmV0dXJuIHI9PT1MLklOVEVSSU9SfHxzPT09TC5JTlRFUklPUjtjYXNlIGlpLkRJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUjtjYXNlIGlpLlNZTURJRkZFUkVOQ0U6cmV0dXJuIHI9PT1MLklOVEVSSU9SJiZzIT09TC5JTlRFUklPUnx8ciE9PUwuSU5URVJJT1ImJnM9PT1MLklOVEVSSU9SfXJldHVybiExfX0saWkuSU5URVJTRUNUSU9OPTEsaWkuVU5JT049MixpaS5ESUZGRVJFTkNFPTMsaWkuU1lNRElGRkVSRU5DRT00LGUocmkucHJvdG90eXBlLHtzZWxmU25hcDpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSWUodCksbj1lLnNuYXBUbyh0LHRoaXMuc25hcFRvbGVyYW5jZSk7cmV0dXJuIG59LHJlbW92ZUNvbW1vbkJpdHM6ZnVuY3Rpb24odCl7dGhpcy5jYnI9bmV3IFNlLHRoaXMuY2JyLmFkZCh0WzBdKSx0aGlzLmNici5hZGQodFsxXSk7dmFyIGU9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7cmV0dXJuIGVbMF09dGhpcy5jYnIucmVtb3ZlQ29tbW9uQml0cyh0WzBdLmNvcHkoKSksZVsxXT10aGlzLmNici5yZW1vdmVDb21tb25CaXRzKHRbMV0uY29weSgpKSxlfSxwcmVwYXJlUmVzdWx0OmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNici5hZGRDb21tb25CaXRzKHQpLHR9LGdldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc25hcCh0aGlzLmdlb20pLG49aWkub3ZlcmxheU9wKGVbMF0sZVsxXSx0KTtyZXR1cm4gdGhpcy5wcmVwYXJlUmVzdWx0KG4pfSxjaGVja1ZhbGlkOmZ1bmN0aW9uKHQpe3QuaXNWYWxpZCgpfHxBLm91dC5wcmludGxuKFwiU25hcHBlZCBnZW9tZXRyeSBpcyBpbnZhbGlkXCIpfSxjb21wdXRlU25hcFRvbGVyYW5jZTpmdW5jdGlvbigpe3RoaXMuc25hcFRvbGVyYW5jZT1JZS5jb21wdXRlT3ZlcmxheVNuYXBUb2xlcmFuY2UodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSl9LHNuYXA6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5yZW1vdmVDb21tb25CaXRzKHQpLG49SWUuc25hcChlWzBdLGVbMV0sdGhpcy5zbmFwVG9sZXJhbmNlKTtyZXR1cm4gbn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcml9fSkscmkub3ZlcmxheU9wPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgcmkodCxlKTtyZXR1cm4gaS5nZXRSZXN1bHRHZW9tZXRyeShuKX0scmkudW5pb249ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LHJpLmludGVyc2VjdGlvbj1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLklOVEVSU0VDVElPTil9LHJpLnN5bURpZmZlcmVuY2U9ZnVuY3Rpb24odCxlKXtyZXR1cm4gcmkub3ZlcmxheU9wKHQsZSxpaS5TWU1ESUZGRVJFTkNFKX0scmkuZGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiByaS5vdmVybGF5T3AodCxlLGlpLkRJRkZFUkVOQ0UpfSxlKHNpLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbCxuPSExLGk9bnVsbDt0cnl7ZT1paS5vdmVybGF5T3AodGhpcy5nZW9tWzBdLHRoaXMuZ2VvbVsxXSx0KTt2YXIgcj0hMDtyJiYobj0hMCl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgbCkpdGhyb3cgdDtpPXR9ZmluYWxseXt9aWYoIW4pdHJ5e2U9cmkub3ZlcmxheU9wKHRoaXMuZ2VvbVswXSx0aGlzLmdlb21bMV0sdCl9Y2F0Y2godCl7dGhyb3cgdCBpbnN0YW5jZW9mIGw/aTp0fWZpbmFsbHl7fXJldHVybiBlfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBzaX19KSxzaS5vdmVybGF5T3A9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPW5ldyBzaSh0LGUpO3JldHVybiBpLmdldFJlc3VsdEdlb21ldHJ5KG4pfSxzaS51bmlvbj1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlVOSU9OKX0sc2kuaW50ZXJzZWN0aW9uPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuSU5URVJTRUNUSU9OKX0sc2kuc3ltRGlmZmVyZW5jZT1mdW5jdGlvbih0LGUpe3JldHVybiBzaS5vdmVybGF5T3AodCxlLGlpLlNZTURJRkZFUkVOQ0UpfSxzaS5kaWZmZXJlbmNlPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuRElGRkVSRU5DRSl9LGUob2kucHJvdG90eXBlLHthZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBlPW51bGwsbj0wLGk9dGhpcy5ob3Jpem9udGFsQmlzZWN0b3IodCk7aWYoMD09PWkuZ2V0TGVuZ3RoKCkpbj0wLGU9aS5nZXRDb29yZGluYXRlKCk7ZWxzZXt2YXIgcj1zaS5vdmVybGF5T3AoaSx0LGlpLklOVEVSU0VDVElPTikscz10aGlzLndpZGVzdEdlb21ldHJ5KHIpO249cy5nZXRFbnZlbG9wZUludGVybmFsKCkuZ2V0V2lkdGgoKSxlPW9pLmNlbnRyZShzLmdldEVudmVsb3BlSW50ZXJuYWwoKSl9KG51bGw9PT10aGlzLmludGVyaW9yUG9pbnR8fG4+dGhpcy5tYXhXaWR0aCkmJih0aGlzLmludGVyaW9yUG9pbnQ9ZSx0aGlzLm1heFdpZHRoPW4pfSxnZXRJbnRlcmlvclBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW50ZXJpb3JQb2ludH0sd2lkZXN0R2VvbWV0cnk6ZnVuY3Rpb24gdCgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpe3ZhciBlPWFyZ3VtZW50c1swXTtpZihlLmlzRW1wdHkoKSlyZXR1cm4gZTtmb3IodmFyIHQ9ZS5nZXRHZW9tZXRyeU4oMCksbj0xO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWUuZ2V0R2VvbWV0cnlOKG4pLmdldEVudmVsb3BlSW50ZXJuYWwoKS5nZXRXaWR0aCgpPnQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmdldFdpZHRoKCkmJih0PWUuZ2V0R2VvbWV0cnlOKG4pKTtyZXR1cm4gdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBpPWFyZ3VtZW50c1swXTtyZXR1cm4gaSBpbnN0YW5jZW9mIGZ0P3RoaXMud2lkZXN0R2VvbWV0cnkoaSk6aX19LGhvcml6b250YWxCaXNlY3RvcjpmdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxuPWFpLmdldEJpc2VjdG9yWSh0KTtyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZUxpbmVTdHJpbmcoW25ldyBnKGUuZ2V0TWluWCgpLG4pLG5ldyBnKGUuZ2V0TWF4WCgpLG4pXSl9LGFkZDpmdW5jdGlvbih0KXtpZih0IGluc3RhbmNlb2YgVHQpdGhpcy5hZGRQb2x5Z29uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIGZ0KWZvcih2YXIgZT10LG49MDtuPGUuZ2V0TnVtR2VvbWV0cmllcygpO24rKyl0aGlzLmFkZChlLmdldEdlb21ldHJ5TihuKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9pfX0pLG9pLmNlbnRyZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGcob2kuYXZnKHQuZ2V0TWluWCgpLHQuZ2V0TWF4WCgpKSxvaS5hdmcodC5nZXRNaW5ZKCksdC5nZXRNYXhZKCkpKX0sb2kuYXZnPWZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQrZSkvMn0sZShhaS5wcm90b3R5cGUse3VwZGF0ZUludGVydmFsOmZ1bmN0aW9uKHQpe3Q8PXRoaXMuY2VudHJlWT90PnRoaXMubG9ZJiYodGhpcy5sb1k9dCk6dD50aGlzLmNlbnRyZVkmJnQ8dGhpcy5oaVkmJih0aGlzLmhpWT10KX0sZ2V0QmlzZWN0b3JZOmZ1bmN0aW9uKCl7dGhpcy5wcm9jZXNzKHRoaXMucG9seS5nZXRFeHRlcmlvclJpbmcoKSk7Zm9yKHZhciB0PTA7dDx0aGlzLnBvbHkuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7dCsrKXRoaXMucHJvY2Vzcyh0aGlzLnBvbHkuZ2V0SW50ZXJpb3JSaW5nTih0KSk7dmFyIGU9b2kuYXZnKHRoaXMuaGlZLHRoaXMubG9ZKTtyZXR1cm4gZX0scHJvY2VzczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPTA7bjxlLnNpemUoKTtuKyspe3ZhciBpPWUuZ2V0WShuKTt0aGlzLnVwZGF0ZUludGVydmFsKGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYWl9fSksYWkuZ2V0QmlzZWN0b3JZPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBhaSh0KTtyZXR1cm4gZS5nZXRCaXNlY3RvclkoKX0sb2kuU2FmZUJpc2VjdG9yRmluZGVyPWFpLGUodWkucHJvdG90eXBlLHthZGRFbmRwb2ludHM6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTtpZih0IGluc3RhbmNlb2YgU3QpdGhpcy5hZGRFbmRwb2ludHModC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGRFbmRwb2ludHMoZS5nZXRHZW9tZXRyeU4obikpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBBcnJheSl7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuYWRkKGlbMF0pLHRoaXMuYWRkKGlbaS5sZW5ndGgtMV0pfX0sZ2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LGFkZEludGVyaW9yOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07aWYodCBpbnN0YW5jZW9mIFN0KXRoaXMuYWRkSW50ZXJpb3IodC5nZXRDb29yZGluYXRlcygpKTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBmdClmb3IodmFyIGU9dCxuPTA7bjxlLmdldE51bUdlb21ldHJpZXMoKTtuKyspdGhpcy5hZGRJbnRlcmlvcihlLmdldEdlb21ldHJ5TihuKSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KWZvcih2YXIgaT1hcmd1bWVudHNbMF0sbj0xO248aS5sZW5ndGgtMTtuKyspdGhpcy5hZGQoaVtuXSl9LGFkZDpmdW5jdGlvbih0KXt2YXIgZT10LmRpc3RhbmNlKHRoaXMuY2VudHJvaWQpO2U8dGhpcy5taW5EaXN0YW5jZSYmKHRoaXMuaW50ZXJpb3JQb2ludD1uZXcgZyh0KSx0aGlzLm1pbkRpc3RhbmNlPWUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB1aX19KSxlKGxpLnByb3RvdHlwZSx7Z2V0SW50ZXJpb3JQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVyaW9yUG9pbnR9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO2lmKHQgaW5zdGFuY2VvZiBMdCl0aGlzLmFkZCh0LmdldENvb3JkaW5hdGUoKSk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZnQpZm9yKHZhciBlPXQsbj0wO248ZS5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXRoaXMuYWRkKGUuZ2V0R2VvbWV0cnlOKG4pKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGk9YXJndW1lbnRzWzBdLHI9aS5kaXN0YW5jZSh0aGlzLmNlbnRyb2lkKTtyPHRoaXMubWluRGlzdGFuY2UmJih0aGlzLmludGVyaW9yUG9pbnQ9bmV3IGcoaSksdGhpcy5taW5EaXN0YW5jZT1yKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGxpfX0pLGUoaGkucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBoaX19KSxoaS50b0RlZ3JlZXM9ZnVuY3Rpb24odCl7cmV0dXJuIDE4MCp0L01hdGguUEl9LGhpLm5vcm1hbGl6ZT1mdW5jdGlvbih0KXtmb3IoO3Q+TWF0aC5QSTspdC09aGkuUElfVElNRVNfMjtmb3IoO3Q8PS1NYXRoLlBJOyl0Kz1oaS5QSV9USU1FU18yO3JldHVybiB0fSxoaS5hbmdsZT1mdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIE1hdGguYXRhbjIodC55LHQueCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPW4ueC1lLngscj1uLnktZS55O3JldHVybiBNYXRoLmF0YW4yKHIsaSl9fSxoaS5pc0FjdXRlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LngtZS54LHI9dC55LWUueSxzPW4ueC1lLngsbz1uLnktZS55LGE9aSpzK3IqbztyZXR1cm4gYT4wfSxoaS5pc09idHVzZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC54LWUueCxyPXQueS1lLnkscz1uLngtZS54LG89bi55LWUueSxhPWkqcytyKm87cmV0dXJuIDA+YX0saGkuaW50ZXJpb3JBbmdsZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9aGkuYW5nbGUoZSx0KSxyPWhpLmFuZ2xlKGUsbik7cmV0dXJuIE1hdGguYWJzKHItaSl9LGhpLm5vcm1hbGl6ZVBvc2l0aXZlPWZ1bmN0aW9uKHQpe2lmKDA+dCl7Zm9yKDswPnQ7KXQrPWhpLlBJX1RJTUVTXzI7dD49aGkuUElfVElNRVNfMiYmKHQ9MCl9ZWxzZXtmb3IoO3Q+PWhpLlBJX1RJTUVTXzI7KXQtPWhpLlBJX1RJTUVTXzI7MD50JiYodD0wKX1yZXR1cm4gdH0saGkuYW5nbGVCZXR3ZWVuPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1oaS5hbmdsZShlLHQpLHI9aGkuYW5nbGUoZSxuKTtyZXR1cm4gaGkuZGlmZihpLHIpfSxoaS5kaWZmPWZ1bmN0aW9uKHQsZSl7dmFyIG49bnVsbDtyZXR1cm4gbj1lPnQ/ZS10OnQtZSxuPk1hdGguUEkmJihuPTIqTWF0aC5QSS1uKSxufSxoaS50b1JhZGlhbnM9ZnVuY3Rpb24odCl7cmV0dXJuIHQqTWF0aC5QSS8xODB9LGhpLmdldFR1cm49ZnVuY3Rpb24odCxlKXt2YXIgbj1NYXRoLnNpbihlLXQpO3JldHVybiBuPjA/aGkuQ09VTlRFUkNMT0NLV0lTRTowPm4/aGkuQ0xPQ0tXSVNFOmhpLk5PTkV9LGhpLmFuZ2xlQmV0d2Vlbk9yaWVudGVkPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1oaS5hbmdsZShlLHQpLHI9aGkuYW5nbGUoZSxuKSxzPXItaTtyZXR1cm4gczw9LU1hdGguUEk/cytoaS5QSV9USU1FU18yOnM+TWF0aC5QST9zLWhpLlBJX1RJTUVTXzI6c30saGkuUElfVElNRVNfMj0yKk1hdGguUEksaGkuUElfT1ZFUl8yPU1hdGguUEkvMixoaS5QSV9PVkVSXzQ9TWF0aC5QSS80LGhpLkNPVU5URVJDTE9DS1dJU0U9aGUuQ09VTlRFUkNMT0NLV0lTRSxoaS5DTE9DS1dJU0U9aGUuQ0xPQ0tXSVNFLGhpLk5PTkU9aGUuQ09MTElORUFSLGUoY2kucHJvdG90eXBlLHthcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLmFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxzaWduZWRBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIGNpLnNpZ25lZEFyZWEodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpbnRlcnBvbGF0ZVo6ZnVuY3Rpb24odCl7aWYobnVsbD09PXQpdGhyb3cgbmV3IGkoXCJTdXBwbGllZCBwb2ludCBpcyBudWxsLlwiKTtyZXR1cm4gY2kuaW50ZXJwb2xhdGVaKHQsdGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxsb25nZXN0U2lkZUxlbmd0aDpmdW5jdGlvbigpe3JldHVybiBjaS5sb25nZXN0U2lkZUxlbmd0aCh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGlzQWN1dGU6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuaXNBY3V0ZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGNpcmN1bWNlbnRyZTpmdW5jdGlvbigpe3JldHVybiBjaS5jaXJjdW1jZW50cmUodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxhcmVhM0Q6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuYXJlYTNEKHRoaXMucDAsdGhpcy5wMSx0aGlzLnAyKX0sY2VudHJvaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gY2kuY2VudHJvaWQodGhpcy5wMCx0aGlzLnAxLHRoaXMucDIpfSxpbkNlbnRyZTpmdW5jdGlvbigpe3JldHVybiBjaS5pbkNlbnRyZSh0aGlzLnAwLHRoaXMucDEsdGhpcy5wMil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGNpfX0pLGNpLmFyZWE9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBNYXRoLmFicygoKG4ueC10LngpKihlLnktdC55KS0oZS54LXQueCkqKG4ueS10LnkpKS8yKX0sY2kuc2lnbmVkQXJlYT1mdW5jdGlvbih0LGUsbil7cmV0dXJuKChuLngtdC54KSooZS55LXQueSktKGUueC10LngpKihuLnktdC55KSkvMn0sY2kuZGV0PWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiB0KmktZSpufSxjaS5pbnRlcnBvbGF0ZVo9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9ZS54LHM9ZS55LG89bi54LXIsYT1pLngtcix1PW4ueS1zLGw9aS55LXMsaD1vKmwtYSp1LGM9dC54LXIsZj10LnktcyxnPShsKmMtYSpmKS9oLGQ9KC11KmMrbypmKS9oLHA9ZS56K2cqKG4uei1lLnopK2QqKGkuei1lLnopO3JldHVybiBwfSxjaS5sb25nZXN0U2lkZUxlbmd0aD1mdW5jdGlvbih0LGUsbil7dmFyIGk9dC5kaXN0YW5jZShlKSxyPWUuZGlzdGFuY2Uobikscz1uLmRpc3RhbmNlKHQpLG89aTtyZXR1cm4gcj5vJiYobz1yKSxzPm8mJihvPXMpLG99LGNpLmlzQWN1dGU9ZnVuY3Rpb24odCxlLG4pe3JldHVybiBoaS5pc0FjdXRlKHQsZSxuKSYmaGkuaXNBY3V0ZShlLG4sdCk/ISFoaS5pc0FjdXRlKG4sdCxlKTohMX0sY2kuY2lyY3VtY2VudHJlPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uLngscj1uLnkscz10LngtaSxvPXQueS1yLGE9ZS54LWksdT1lLnktcixsPTIqY2kuZGV0KHMsbyxhLHUpLGg9Y2kuZGV0KG8scypzK28qbyx1LGEqYSt1KnUpLGM9Y2kuZGV0KHMscypzK28qbyxhLGEqYSt1KnUpLGY9aS1oL2wsZD1yK2MvbDtyZXR1cm4gbmV3IGcoZixkKX0sY2kucGVycGVuZGljdWxhckJpc2VjdG9yPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS54LXQueCxpPWUueS10Lnkscj1uZXcgRih0Lngrbi8yLHQueStpLzIsMSkscz1uZXcgRih0LngtaStuLzIsdC55K24raS8yLDEpO3JldHVybiBuZXcgRihyLHMpfSxjaS5hbmdsZUJpc2VjdG9yPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1lLmRpc3RhbmNlKHQpLHI9ZS5kaXN0YW5jZShuKSxzPWkvKGkrciksbz1uLngtdC54LGE9bi55LXQueSx1PW5ldyBnKHQueCtzKm8sdC55K3MqYSk7cmV0dXJuIHV9LGNpLmFyZWEzRD1mdW5jdGlvbih0LGUsbil7dmFyIGk9ZS54LXQueCxyPWUueS10Lnkscz1lLnotdC56LG89bi54LXQueCxhPW4ueS10LnksdT1uLnotdC56LGw9cip1LXMqYSxoPXMqby1pKnUsYz1pKmEtcipvLGY9bCpsK2gqaCtjKmMsZz1NYXRoLnNxcnQoZikvMjtyZXR1cm4gZ30sY2kuY2VudHJvaWQ9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPSh0LngrZS54K24ueCkvMyxyPSh0LnkrZS55K24ueSkvMztyZXR1cm4gbmV3IGcoaSxyKX0sY2kuaW5DZW50cmU9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPWUuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKG4pLHM9dC5kaXN0YW5jZShlKSxvPWkrcitzLGE9KGkqdC54K3IqZS54K3Mqbi54KS9vLHU9KGkqdC55K3IqZS55K3Mqbi55KS9vO3JldHVybiBuZXcgZyhhLHUpfSxlKGZpLnByb3RvdHlwZSx7Z2V0UmFkaXVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZSgpLHRoaXMucmFkaXVzfSxnZXREaWFtZXRlcjpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmNvbXB1dGUoKSx0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKCk7Y2FzZSAxOnJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0aGlzLmNlbnRyZSl9dmFyIHQ9dGhpcy5leHRyZW1hbFB0c1swXSxlPXRoaXMuZXh0cmVtYWxQdHNbMV07cmV0dXJuIHRoaXMuaW5wdXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcoW3QsZV0pfSxnZXRFeHRyZW1hbFBvaW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLmV4dHJlbWFsUHRzfSxjb21wdXRlQ2lyY2xlUG9pbnRzOmZ1bmN0aW9uKCl7aWYodGhpcy5pbnB1dC5pc0VtcHR5KCkpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9bmV3IEFycmF5KDApLmZpbGwobnVsbCksbnVsbDtpZigxPT09dGhpcy5pbnB1dC5nZXROdW1Qb2ludHMoKSl7dmFyIHQ9dGhpcy5pbnB1dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLmV4dHJlbWFsUHRzPVtuZXcgZyh0WzBdKV0sbnVsbH12YXIgZT10aGlzLmlucHV0LmNvbnZleEh1bGwoKSxuPWUuZ2V0Q29vcmRpbmF0ZXMoKSx0PW47aWYoblswXS5lcXVhbHMyRChuW24ubGVuZ3RoLTFdKSYmKHQ9bmV3IEFycmF5KG4ubGVuZ3RoLTEpLmZpbGwobnVsbCksSC5jb3B5RGVlcChuLDAsdCwwLG4ubGVuZ3RoLTEpKSx0Lmxlbmd0aDw9MilyZXR1cm4gdGhpcy5leHRyZW1hbFB0cz1ILmNvcHlEZWVwKHQpLG51bGw7Zm9yKHZhciBpPWZpLmxvd2VzdFBvaW50KHQpLHI9ZmkucG9pbnRXaXRNaW5BbmdsZVdpdGhYKHQsaSkscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgbz1maS5wb2ludFdpdGhNaW5BbmdsZVdpdGhTZWdtZW50KHQsaSxyKTtpZihoaS5pc09idHVzZShpLG8scikpcmV0dXJuIHRoaXMuZXh0cmVtYWxQdHM9W25ldyBnKGkpLG5ldyBnKHIpXSxudWxsO2lmKGhpLmlzT2J0dXNlKG8saSxyKSlpPW87ZWxzZXtpZighaGkuaXNPYnR1c2UobyxyLGkpKXJldHVybiB0aGlzLmV4dHJlbWFsUHRzPVtuZXcgZyhpKSxuZXcgZyhyKSxuZXcgZyhvKV0sbnVsbDtyPW99fWYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJMb2dpYyBmYWlsdXJlIGluIE1pbmltdW0gQm91bmRpbmcgQ2lyY2xlIGFsZ29yaXRobSFcIil9LGNvbXB1dGU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZXh0cmVtYWxQdHM/bnVsbDoodGhpcy5jb21wdXRlQ2lyY2xlUG9pbnRzKCksdGhpcy5jb21wdXRlQ2VudHJlKCksdm9pZChudWxsIT09dGhpcy5jZW50cmUmJih0aGlzLnJhZGl1cz10aGlzLmNlbnRyZS5kaXN0YW5jZSh0aGlzLmV4dHJlbWFsUHRzWzBdKSkpKX0sZ2V0RmFydGhlc3RQb2ludHM6ZnVuY3Rpb24oKXtzd2l0Y2godGhpcy5jb21wdXRlKCksdGhpcy5leHRyZW1hbFB0cy5sZW5ndGgpe2Nhc2UgMDpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZygpO2Nhc2UgMTpyZXR1cm4gdGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5jZW50cmUpfXZhciB0PXRoaXMuZXh0cmVtYWxQdHNbMF0sZT10aGlzLmV4dHJlbWFsUHRzW3RoaXMuZXh0cmVtYWxQdHMubGVuZ3RoLTFdO3JldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LGVdKX0sZ2V0Q2lyY2xlOmZ1bmN0aW9uKCl7aWYodGhpcy5jb21wdXRlKCksbnVsbD09PXRoaXMuY2VudHJlKXJldHVybiB0aGlzLmlucHV0LmdldEZhY3RvcnkoKS5jcmVhdGVQb2x5Z29uKCk7dmFyIHQ9dGhpcy5pbnB1dC5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5jZW50cmUpO3JldHVybiAwPT09dGhpcy5yYWRpdXM/dDp0LmJ1ZmZlcih0aGlzLnJhZGl1cyl9LGdldENlbnRyZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGUoKSx0aGlzLmNlbnRyZX0sY29tcHV0ZUNlbnRyZTpmdW5jdGlvbigpe3N3aXRjaCh0aGlzLmV4dHJlbWFsUHRzLmxlbmd0aCl7Y2FzZSAwOnRoaXMuY2VudHJlPW51bGw7YnJlYWs7Y2FzZSAxOnRoaXMuY2VudHJlPXRoaXMuZXh0cmVtYWxQdHNbMF07YnJlYWs7Y2FzZSAyOnRoaXMuY2VudHJlPW5ldyBnKCh0aGlzLmV4dHJlbWFsUHRzWzBdLngrdGhpcy5leHRyZW1hbFB0c1sxXS54KS8yLCh0aGlzLmV4dHJlbWFsUHRzWzBdLnkrdGhpcy5leHRyZW1hbFB0c1sxXS55KS8yKTticmVhaztjYXNlIDM6dGhpcy5jZW50cmU9Y2kuY2lyY3VtY2VudHJlKHRoaXMuZXh0cmVtYWxQdHNbMF0sdGhpcy5leHRyZW1hbFB0c1sxXSx0aGlzLmV4dHJlbWFsUHRzWzJdKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGZpfX0pLGZpLnBvaW50V2l0TWluQW5nbGVXaXRoWD1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj1yLk1BWF9WQUxVRSxpPW51bGwscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgbz10W3NdO2lmKG8hPT1lKXt2YXIgYT1vLngtZS54LHU9by55LWUueTswPnUmJih1PS11KTt2YXIgbD1NYXRoLnNxcnQoYSphK3UqdSksaD11L2w7bj5oJiYobj1oLGk9byl9fXJldHVybiBpfSxmaS5sb3dlc3RQb2ludD1mdW5jdGlvbih0KXtmb3IodmFyIGU9dFswXSxuPTE7bjx0Lmxlbmd0aDtuKyspdFtuXS55PGUueSYmKGU9dFtuXSk7cmV0dXJuIGV9LGZpLnBvaW50V2l0aE1pbkFuZ2xlV2l0aFNlZ21lbnQ9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1yLk1BWF9WQUxVRSxzPW51bGwsbz0wO288dC5sZW5ndGg7bysrKXt2YXIgYT10W29dO2lmKGEhPT1lJiZhIT09bil7dmFyIHU9aGkuYW5nbGVCZXR3ZWVuKGUsYSxuKTtpPnUmJihpPXUscz1hKX19cmV0dXJuIHN9LGUoZ2kucHJvdG90eXBlLHtnZXRXaWR0aENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluaW11bURpYW1ldGVyKCksdGhpcy5taW5XaWR0aFB0fSxnZXRTdXBwb3J0aW5nU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXB1dGVNaW5pbXVtRGlhbWV0ZXIoKSx0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlTGluZVN0cmluZyhbdGhpcy5taW5CYXNlU2VnLnAwLHRoaXMubWluQmFzZVNlZy5wMV0pfSxnZXREaWFtZXRlcjpmdW5jdGlvbigpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLG51bGw9PT10aGlzLm1pbldpZHRoUHQpcmV0dXJuIHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKG51bGwpO3ZhciB0PXRoaXMubWluQmFzZVNlZy5wcm9qZWN0KHRoaXMubWluV2lkdGhQdCk7cmV0dXJuIHRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lU3RyaW5nKFt0LHRoaXMubWluV2lkdGhQdF0pfSxjb21wdXRlV2lkdGhDb252ZXg6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIFR0P3RoaXMuY29udmV4SHVsbFB0cz10LmdldEV4dGVyaW9yUmluZygpLmdldENvb3JkaW5hdGVzKCk6dGhpcy5jb252ZXhIdWxsUHRzPXQuZ2V0Q29vcmRpbmF0ZXMoKSwwPT09dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5taW5XaWR0aD0wLHRoaXMubWluV2lkdGhQdD1udWxsLHRoaXMubWluQmFzZVNlZz1udWxsKToxPT09dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aD8odGhpcy5taW5XaWR0aD0wLHRoaXMubWluV2lkdGhQdD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAwPXRoaXMuY29udmV4SHVsbFB0c1swXSx0aGlzLm1pbkJhc2VTZWcucDE9dGhpcy5jb252ZXhIdWxsUHRzWzBdKToyPT09dGhpcy5jb252ZXhIdWxsUHRzLmxlbmd0aHx8Mz09PXRoaXMuY29udmV4SHVsbFB0cy5sZW5ndGg/KHRoaXMubWluV2lkdGg9MCx0aGlzLm1pbldpZHRoUHQ9dGhpcy5jb252ZXhIdWxsUHRzWzBdLHRoaXMubWluQmFzZVNlZy5wMD10aGlzLmNvbnZleEh1bGxQdHNbMF0sdGhpcy5taW5CYXNlU2VnLnAxPXRoaXMuY29udmV4SHVsbFB0c1sxXSk6dGhpcy5jb21wdXRlQ29udmV4UmluZ01pbkRpYW1ldGVyKHRoaXMuY29udmV4SHVsbFB0cyl9LGNvbXB1dGVDb252ZXhSaW5nTWluRGlhbWV0ZXI6ZnVuY3Rpb24odCl7dGhpcy5taW5XaWR0aD1yLk1BWF9WQUxVRTtmb3IodmFyIGU9MSxuPW5ldyBjZSxpPTA7aTx0Lmxlbmd0aC0xO2krKyluLnAwPXRbaV0sbi5wMT10W2krMV0sZT10aGlzLmZpbmRNYXhQZXJwRGlzdGFuY2UodCxuLGUpfSxjb21wdXRlTWluaW11bURpYW1ldGVyOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMubWluV2lkdGhQdClyZXR1cm4gbnVsbDtpZih0aGlzLmlzQ29udmV4KXRoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHRoaXMuaW5wdXRHZW9tKTtlbHNle3ZhciB0PW5ldyBtZSh0aGlzLmlucHV0R2VvbSkuZ2V0Q29udmV4SHVsbCgpO3RoaXMuY29tcHV0ZVdpZHRoQ29udmV4KHQpfX0sZ2V0TGVuZ3RoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLHRoaXMubWluV2lkdGh9LGZpbmRNYXhQZXJwRGlzdGFuY2U6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W25dKSxyPWkscz1uLG89cztyPj1pOylpPXIscz1vLG89Z2kubmV4dEluZGV4KHQscykscj1lLmRpc3RhbmNlUGVycGVuZGljdWxhcih0W29dKTtyZXR1cm4gaTx0aGlzLm1pbldpZHRoJiYodGhpcy5taW5QdEluZGV4PXMsdGhpcy5taW5XaWR0aD1pLHRoaXMubWluV2lkdGhQdD10W3RoaXMubWluUHRJbmRleF0sdGhpcy5taW5CYXNlU2VnPW5ldyBjZShlKSksc30sZ2V0TWluaW11bVJlY3RhbmdsZTpmdW5jdGlvbigpe2lmKHRoaXMuY29tcHV0ZU1pbmltdW1EaWFtZXRlcigpLDA9PT10aGlzLm1pbldpZHRoKXJldHVybiB0aGlzLm1pbkJhc2VTZWcucDAuZXF1YWxzMkQodGhpcy5taW5CYXNlU2VnLnAxKT90aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkuY3JlYXRlUG9pbnQodGhpcy5taW5CYXNlU2VnLnAwKTp0aGlzLm1pbkJhc2VTZWcudG9HZW9tZXRyeSh0aGlzLmlucHV0R2VvbS5nZXRGYWN0b3J5KCkpO2Zvcih2YXIgdD10aGlzLm1pbkJhc2VTZWcucDEueC10aGlzLm1pbkJhc2VTZWcucDAueCxlPXRoaXMubWluQmFzZVNlZy5wMS55LXRoaXMubWluQmFzZVNlZy5wMC55LG49ci5NQVhfVkFMVUUsaT0tci5NQVhfVkFMVUUscz1yLk1BWF9WQUxVRSxvPS1yLk1BWF9WQUxVRSxhPTA7YTx0aGlzLmNvbnZleEh1bGxQdHMubGVuZ3RoO2ErKyl7dmFyIHU9Z2kuY29tcHV0ZUModCxlLHRoaXMuY29udmV4SHVsbFB0c1thXSk7dT5pJiYoaT11KSxuPnUmJihuPXUpO3ZhciBsPWdpLmNvbXB1dGVDKC1lLHQsdGhpcy5jb252ZXhIdWxsUHRzW2FdKTtsPm8mJihvPWwpLHM+bCYmKHM9bCl9dmFyIGg9Z2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLG8pLGM9Z2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC10LC1lLHMpLGY9Z2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lKC1lLHQsaSksZz1naS5jb21wdXRlU2VnbWVudEZvckxpbmUoLWUsdCxuKSxkPWYubGluZUludGVyc2VjdGlvbihoKSxwPWcubGluZUludGVyc2VjdGlvbihoKSx2PWcubGluZUludGVyc2VjdGlvbihjKSxtPWYubGluZUludGVyc2VjdGlvbihjKSx5PXRoaXMuaW5wdXRHZW9tLmdldEZhY3RvcnkoKS5jcmVhdGVMaW5lYXJSaW5nKFtkLHAsdixtLGRdKTtyZXR1cm4gdGhpcy5pbnB1dEdlb20uZ2V0RmFjdG9yeSgpLmNyZWF0ZVBvbHlnb24oeSxudWxsKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ2l9fSksZ2kubmV4dEluZGV4PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUrKyxlPj10Lmxlbmd0aCYmKGU9MCksZX0sZ2kuY29tcHV0ZUM9ZnVuY3Rpb24odCxlLG4pe3JldHVybiB0Km4ueS1lKm4ueH0sZ2kuZ2V0TWluaW11bURpYW1ldGVyPWZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZ2kodCkuZ2V0RGlhbWV0ZXIoKX0sZ2kuZ2V0TWluaW11bVJlY3RhbmdsZT1mdW5jdGlvbih0KXtyZXR1cm4gbmV3IGdpKHQpLmdldE1pbmltdW1SZWN0YW5nbGUoKX0sZ2kuY29tcHV0ZVNlZ21lbnRGb3JMaW5lPWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1udWxsLHI9bnVsbDtyZXR1cm4gTWF0aC5hYnMoZSk+TWF0aC5hYnModCk/KGk9bmV3IGcoMCxuL2UpLHI9bmV3IGcoMSxuL2UtdC9lKSk6KGk9bmV3IGcobi90LDApLHI9bmV3IGcobi90LWUvdCwxKSksbmV3IGNlKGkscil9O3ZhciBjbz1PYmplY3QuZnJlZXplKHtDZW50cm9pZDpnZSxDR0FsZ29yaXRobXM6aGUsQ29udmV4SHVsbDptZSxJbnRlcmlvclBvaW50QXJlYTpvaSxJbnRlcmlvclBvaW50TGluZTp1aSxJbnRlcmlvclBvaW50UG9pbnQ6bGksUm9idXN0TGluZUludGVyc2VjdG9yOmFlLE1pbmltdW1Cb3VuZGluZ0NpcmNsZTpmaSxNaW5pbXVtRGlhbWV0ZXI6Z2l9KTtlKGRpLnByb3RvdHlwZSx7Z2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IHBpKHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLnRyYW5zZm9ybSh0aGlzLmlucHV0R2VvbSl9LHNldERpc3RhbmNlVG9sZXJhbmNlOmZ1bmN0aW9uKHQpe2lmKDA+PXQpdGhyb3cgbmV3IGkoXCJUb2xlcmFuY2UgbXVzdCBiZSBwb3NpdGl2ZVwiKTt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRpfX0pLGRpLmRlbnNpZnlQb2ludHM9ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgY2Uscj1uZXcgTixzPTA7czx0Lmxlbmd0aC0xO3MrKyl7aS5wMD10W3NdLGkucDE9dFtzKzFdLHIuYWRkKGkucDAsITEpO3ZhciBvPWkuZ2V0TGVuZ3RoKCksYT1NYXRoLnRydW5jKG8vZSkrMTtpZihhPjEpZm9yKHZhciB1PW8vYSxsPTE7YT5sO2wrKyl7dmFyIGg9bCp1L28sYz1pLnBvaW50QWxvbmcoaCk7bi5tYWtlUHJlY2lzZShjKSxyLmFkZChjLCExKX19cmV0dXJuIHIuYWRkKHRbdC5sZW5ndGgtMV0sITEpLHIudG9Db29yZGluYXRlQXJyYXkoKX0sZGkuZGVuc2lmeT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBkaSh0KTtyZXR1cm4gbi5zZXREaXN0YW5jZVRvbGVyYW5jZShlKSxuLmdldFJlc3VsdEdlb21ldHJ5KCl9LGgocGkseGUpLGUocGkucHJvdG90eXBlLHt0cmFuc2Zvcm1NdWx0aVBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj14ZS5wcm90b3R5cGUudHJhbnNmb3JtTXVsdGlQb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiB0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgT3Q/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sdHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnRvQ29vcmRpbmF0ZUFycmF5KCksaT1kaS5kZW5zaWZ5UG9pbnRzKG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSxlLmdldFByZWNpc2lvbk1vZGVsKCkpO3JldHVybiBlIGluc3RhbmNlb2YgU3QmJjE9PT1pLmxlbmd0aCYmKGk9bmV3IEFycmF5KDApLmZpbGwobnVsbCkpLHRoaXMuZmFjdG9yeS5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkuY3JlYXRlKGkpfSxjcmVhdGVWYWxpZEFyZWE6ZnVuY3Rpb24odCl7cmV0dXJuIHQuYnVmZmVyKDApfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBwaX19KSxkaS5EZW5zaWZ5VHJhbnNmb3JtZXI9cGk7dmFyIGZvPU9iamVjdC5mcmVlemUoe0RlbnNpZmllcjpkaX0pO2UodmkucHJvdG90eXBlLHtmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXM7ZG97aWYobnVsbD09PWUpcmV0dXJuIG51bGw7aWYoZS5kZXN0KCkuZXF1YWxzMkQodCkpcmV0dXJuIGU7ZT1lLm9OZXh0KCl9d2hpbGUoZSE9PXRoaXMpO3JldHVybiBudWxsfSxkZXN0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZ30sb05leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fc3ltLl9uZXh0fSxpbnNlcnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5vTmV4dCgpPT09dGhpcylyZXR1cm4gdGhpcy5pbnNlcnRBZnRlcih0KSxudWxsO3ZhciBlPXRoaXMuY29tcGFyZVRvKHQpLG49dGhpcztkb3t2YXIgaT1uLm9OZXh0KCkscj1pLmNvbXBhcmVUbyh0KTtpZihyIT09ZXx8aT09PXRoaXMpcmV0dXJuIG4uaW5zZXJ0QWZ0ZXIodCksbnVsbDtuPWl9d2hpbGUobiE9PXRoaXMpO2Yuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoKX0saW5zZXJ0QWZ0ZXI6ZnVuY3Rpb24odCl7Zi5lcXVhbHModGhpcy5fb3JpZyx0Lm9yaWcoKSk7dmFyIGU9dGhpcy5vTmV4dCgpO3RoaXMuX3N5bS5zZXROZXh0KHQpLHQuc3ltKCkuc2V0TmV4dChlKX0sZGVncmVlOmZ1bmN0aW9uIHQoKXt2YXIgdD0wLGU9dGhpcztkbyB0KyssZT1lLm9OZXh0KCk7d2hpbGUoZSE9PXRoaXMpO3JldHVybiB0fSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3JldHVybiB0aGlzLl9vcmlnLmVxdWFsczJEKHQpJiZ0aGlzLl9zeW0uX29yaWcuZXF1YWxzKGUpfX0sZGVsdGFZOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZy55LXRoaXMuX29yaWcueX0sc3ltOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bX0scHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9zeW0ubmV4dCgpLl9zeW19LGNvbXBhcmVBbmd1bGFyRGlyZWN0aW9uOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGVsdGFYKCksbj10aGlzLmRlbHRhWSgpLGk9dC5kZWx0YVgoKSxyPXQuZGVsdGFZKCk7aWYoZT09PWkmJm49PT1yKXJldHVybiAwO3ZhciBzPUplLnF1YWRyYW50KGUsbiksbz1KZS5xdWFkcmFudChpLHIpO3JldHVybiBzPm8/MTpvPnM/LTE6aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQuX29yaWcsdC5kZXN0KCksdGhpcy5kZXN0KCkpfSxwcmV2Tm9kZTpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzOzI9PT10LmRlZ3JlZSgpOylpZih0PXQucHJldigpLHQ9PT10aGlzKXJldHVybiBudWxsO3JldHVybiB0fSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dCxuPXRoaXMuY29tcGFyZUFuZ3VsYXJEaXJlY3Rpb24oZSk7cmV0dXJuIG59LG5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fbmV4dH0sc2V0U3ltOmZ1bmN0aW9uKHQpe3RoaXMuX3N5bT10fSxvcmlnOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX29yaWd9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJIRShcIit0aGlzLl9vcmlnLngrXCIgXCIrdGhpcy5fb3JpZy55K1wiLCBcIit0aGlzLl9zeW0uX29yaWcueCtcIiBcIit0aGlzLl9zeW0uX29yaWcueStcIilcIn0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLl9uZXh0PXR9LGluaXQ6ZnVuY3Rpb24odCl7dGhpcy5zZXRTeW0odCksdC5zZXRTeW0odGhpcyksdGhpcy5zZXROZXh0KHQpLHQuc2V0TmV4dCh0aGlzKX0sZGVsdGFYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3N5bS5fb3JpZy54LXRoaXMuX29yaWcueH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdml9fSksdmkuaW5pdD1mdW5jdGlvbih0LGUpe2lmKG51bGwhPT10Ll9zeW18fG51bGwhPT1lLl9zeW18fG51bGwhPT10Ll9uZXh0fHxudWxsIT09ZS5fbmV4dCl0aHJvdyBuZXcgSWxsZWdhbFN0YXRlRXhjZXB0aW9uKFwiRWRnZXMgYXJlIGFscmVhZHkgaW5pdGlhbGl6ZWRcIik7cmV0dXJuIHQuaW5pdChlKSx0fSx2aS5jcmVhdGU9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgdmkodCksaT1uZXcgdmkoZSk7cmV0dXJuIG4uaW5pdChpKSxufSxoKG1pLHZpKSxlKG1pLnByb3RvdHlwZSx7bWFyazpmdW5jdGlvbigpe3RoaXMuX2lzTWFya2VkPSEwfSxzZXRNYXJrOmZ1bmN0aW9uKHQpe3RoaXMuX2lzTWFya2VkPXR9LGlzTWFya2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBtaX19KSxtaS5zZXRNYXJrQm90aD1mdW5jdGlvbih0LGUpe3Quc2V0TWFyayhlKSx0LnN5bSgpLnNldE1hcmsoZSl9LG1pLmlzTWFya2VkPWZ1bmN0aW9uKHQpe3JldHVybiB0LmlzTWFya2VkKCl9LG1pLnNldE1hcms9ZnVuY3Rpb24odCxlKXt0LnNldE1hcmsoZSl9LG1pLm1hcmtCb3RoPWZ1bmN0aW9uKHQpe3QubWFyaygpLHQuc3ltKCkubWFyaygpfSxtaS5tYXJrPWZ1bmN0aW9uKHQpe3QubWFyaygpfSxlKHlpLnByb3RvdHlwZSx7aW5zZXJ0OmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLmNyZWF0ZSh0LGUpO251bGwhPT1uP24uaW5zZXJ0KGkpOnRoaXMudmVydGV4TWFwLnB1dCh0LGkpO3ZhciByPXRoaXMudmVydGV4TWFwLmdldChlKTtyZXR1cm4gbnVsbCE9PXI/ci5pbnNlcnQoaS5zeW0oKSk6dGhpcy52ZXJ0ZXhNYXAucHV0KGUsaS5zeW0oKSksaX0sY3JlYXRlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jcmVhdGVFZGdlKHQpLGk9dGhpcy5jcmVhdGVFZGdlKGUpO3JldHVybiB2aS5pbml0KG4saSksbn0sY3JlYXRlRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IHZpKHQpfSxhZGRFZGdlOmZ1bmN0aW9uKHQsZSl7aWYoIXlpLmlzVmFsaWRFZGdlKHQsZSkpcmV0dXJuIG51bGw7dmFyIG49dGhpcy52ZXJ0ZXhNYXAuZ2V0KHQpLGk9bnVsbDtpZihudWxsIT09biYmKGk9bi5maW5kKGUpKSxudWxsIT09aSlyZXR1cm4gaTt2YXIgcj10aGlzLmluc2VydCh0LGUsbik7cmV0dXJuIHJ9LGdldFZlcnRleEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudmVydGV4TWFwLnZhbHVlcygpfSxmaW5kRWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMudmVydGV4TWFwLmdldCh0KTtyZXR1cm4gbnVsbD09PW4/bnVsbDpuLmZpbmQoZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHlpfX0pLHlpLmlzVmFsaWRFZGdlPWZ1bmN0aW9uKHQsZSl7dmFyIG49ZS5jb21wYXJlVG8odCk7cmV0dXJuIDAhPT1ufSxoKHhpLG1pKSxlKHhpLnByb3RvdHlwZSx7c2V0U3RhcnQ6ZnVuY3Rpb24oKXt0aGlzLl9pc1N0YXJ0PSEwfSxpc1N0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzU3RhcnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhpfX0pLGgoRWkseWkpLGUoRWkucHJvdG90eXBlLHtjcmVhdGVFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgeGkodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEVpfX0pLGUoSWkucHJvdG90eXBlLHthZGRMaW5lOmZ1bmN0aW9uKHQpe3RoaXMubGluZXMuYWRkKHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQudG9Db29yZGluYXRlQXJyYXkoKSkpfSx1cGRhdGVSaW5nU3RhcnRFZGdlOmZ1bmN0aW9uKHQpe3JldHVybiB0LmlzU3RhcnQoKXx8KHQ9dC5zeW0oKSx0LmlzU3RhcnQoKSk/bnVsbD09PXRoaXMucmluZ1N0YXJ0RWRnZT8odGhpcy5yaW5nU3RhcnRFZGdlPXQsbnVsbCk6dm9pZCh0Lm9yaWcoKS5jb21wYXJlVG8odGhpcy5yaW5nU3RhcnRFZGdlLm9yaWcoKSk8MCYmKHRoaXMucmluZ1N0YXJ0RWRnZT10KSk6bnVsbH0sZ2V0UmVzdWx0OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnJlc3VsdCYmdGhpcy5jb21wdXRlUmVzdWx0KCksdGhpcy5yZXN1bHR9LHByb2Nlc3M6ZnVuY3Rpb24odCl7dmFyIGU9dC5wcmV2Tm9kZSgpO251bGw9PT1lJiYoZT10KSx0aGlzLnN0YWNrRWRnZXMoZSksdGhpcy5idWlsZExpbmVzKCl9LGJ1aWxkUmluZzpmdW5jdGlvbih0KXt2YXIgZT1uZXcgTixuPXQ7Zm9yKGUuYWRkKG4ub3JpZygpLmNvcHkoKSwhMSk7Mj09PW4uc3ltKCkuZGVncmVlKCk7KXt2YXIgaT1uLm5leHQoKTtpZihpPT09dClicmVhaztlLmFkZChpLm9yaWcoKS5jb3B5KCksITEpLG49aX1lLmFkZChuLmRlc3QoKS5jb3B5KCksITEpLHRoaXMuYWRkTGluZShlKX0sYnVpbGRMaW5lOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBOLG49dDtmb3IodGhpcy5yaW5nU3RhcnRFZGdlPW51bGwsbWkubWFya0JvdGgobiksZS5hZGQobi5vcmlnKCkuY29weSgpLCExKTsyPT09bi5zeW0oKS5kZWdyZWUoKTspe3RoaXMudXBkYXRlUmluZ1N0YXJ0RWRnZShuKTt2YXIgaT1uLm5leHQoKTtpZihpPT09dClyZXR1cm4gdGhpcy5idWlsZFJpbmcodGhpcy5yaW5nU3RhcnRFZGdlKSxudWxsO2UuYWRkKGkub3JpZygpLmNvcHkoKSwhMSksbj1pLG1pLm1hcmtCb3RoKG4pfWUuYWRkKG4uZGVzdCgpLmNvcHkoKSwhMSksdGhpcy5zdGFja0VkZ2VzKG4uc3ltKCkpLHRoaXMuYWRkTGluZShlKX0sc3RhY2tFZGdlczpmdW5jdGlvbih0KXt2YXIgZT10O2RvIG1pLmlzTWFya2VkKGUpfHx0aGlzLm5vZGVFZGdlU3RhY2suYWRkKGUpLGU9ZS5vTmV4dCgpO3doaWxlKGUhPT10KX0sY29tcHV0ZVJlc3VsdDpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmdyYXBoLmdldFZlcnRleEVkZ2VzKCksZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTttaS5pc01hcmtlZChuKXx8dGhpcy5wcm9jZXNzKG4pfXRoaXMucmVzdWx0PXRoaXMuZmFjdG9yeS5idWlsZEdlb21ldHJ5KHRoaXMubGluZXMpfSxidWlsZExpbmVzOmZ1bmN0aW9uKCl7Zm9yKDshdGhpcy5ub2RlRWRnZVN0YWNrLmVtcHR5KCk7KXt2YXIgdD10aGlzLm5vZGVFZGdlU3RhY2sucG9wKCk7bWkuaXNNYXJrZWQodCl8fHRoaXMuYnVpbGRMaW5lKHQpfX0sYWRkOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF07dC5hcHBseSh7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgU3QmJnRoaXMuYWRkKHQpfX0pfWVsc2UgaWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWUuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO3RoaXMuYWRkKGkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCl7dmFyIHI9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmZhY3RvcnkmJih0aGlzLmZhY3Rvcnk9ci5nZXRGYWN0b3J5KCkpO2Zvcih2YXIgcz1yLmdldENvb3JkaW5hdGVTZXF1ZW5jZSgpLG89ITEsbj0xO248cy5zaXplKCk7bisrKXt2YXIgYT10aGlzLmdyYXBoLmFkZEVkZ2Uocy5nZXRDb29yZGluYXRlKG4tMSkscy5nZXRDb29yZGluYXRlKG4pKTtudWxsIT09YSYmKG98fChhLnNldFN0YXJ0KCksbz0hMCkpfX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIElpfX0pLElpLmRpc3NvbHZlPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJaTtyZXR1cm4gZS5hZGQodCksZS5nZXRSZXN1bHQoKX07dmFyIGdvPU9iamVjdC5mcmVlemUoe0xpbmVEaXNzb2x2ZXI6SWl9KTtlKE5pLnByb3RvdHlwZSx7aGFzQ2hpbGRyZW46ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MDs0PnQ7dCsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbdF0pcmV0dXJuITA7cmV0dXJuITF9LGlzUHJ1bmFibGU6ZnVuY3Rpb24oKXtyZXR1cm4hKHRoaXMuaGFzQ2hpbGRyZW4oKXx8dGhpcy5oYXNJdGVtcygpKX0sYWRkQWxsSXRlbXM6ZnVuY3Rpb24odCl7dC5hZGRBbGwodGhpcy5pdGVtcyk7Zm9yKHZhciBlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiZ0aGlzLnN1Ym5vZGVbZV0uYWRkQWxsSXRlbXModCk7cmV0dXJuIHR9LGdldE5vZGVDb3VudDpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDs0PmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCsxfSxzaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzQ+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5zaXplKCkpO3JldHVybiB0K3RoaXMuaXRlbXMuc2l6ZSgpfSxhZGRBbGxJdGVtc0Zyb21PdmVybGFwcGluZzpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7ZS5hZGRBbGwodGhpcy5pdGVtcyk7Zm9yKHZhciBuPTA7ND5uO24rKyludWxsIT09dGhpcy5zdWJub2RlW25dJiZ0aGlzLnN1Ym5vZGVbbl0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKX0sdmlzaXRJdGVtczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLml0ZW1zLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWUudmlzaXRJdGVtKG4ubmV4dCgpKX0saGFzSXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4hdGhpcy5pdGVtcy5pc0VtcHR5KCl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuITE7Zm9yKHZhciBuPSExLGk9MDs0Pmk7aSsrKWlmKG51bGwhPT10aGlzLnN1Ym5vZGVbaV0mJihuPXRoaXMuc3Vibm9kZVtpXS5yZW1vdmUodCxlKSkpe3RoaXMuc3Vibm9kZVtpXS5pc1BydW5hYmxlKCkmJih0aGlzLnN1Ym5vZGVbaV09bnVsbCk7YnJlYWt9cmV0dXJuIG4/bjpuPXRoaXMuaXRlbXMucmVtb3ZlKGUpfSx2aXNpdDpmdW5jdGlvbih0LGUpe2lmKCF0aGlzLmlzU2VhcmNoTWF0Y2godCkpcmV0dXJuIG51bGw7dGhpcy52aXNpdEl0ZW1zKHQsZSk7Zm9yKHZhciBuPTA7ND5uO24rKyludWxsIT09dGhpcy5zdWJub2RlW25dJiZ0aGlzLnN1Ym5vZGVbbl0udmlzaXQodCxlKX0sZ2V0SXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtc30sZGVwdGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7ND5lO2UrKylpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9LGlzRW1wdHk6ZnVuY3Rpb24gdCgpe3ZhciB0PSEwO3RoaXMuaXRlbXMuaXNFbXB0eSgpfHwodD0hMSk7Zm9yKHZhciBlPTA7ND5lO2UrKyludWxsIT09dGhpcy5zdWJub2RlW2VdJiYodGhpcy5zdWJub2RlW2VdLmlzRW1wdHkoKXx8KHQ9ITEpKTtyZXR1cm4gdH0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMuaXRlbXMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt1XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTml9fSksTmkuZ2V0U3Vibm9kZUluZGV4PWZ1bmN0aW9uKHQsZSxuKXt2YXIgaT0tMTtyZXR1cm4gdC5nZXRNaW5YKCk+PWUmJih0LmdldE1pblkoKT49biYmKGk9MyksdC5nZXRNYXhZKCk8PW4mJihpPTEpKSx0LmdldE1heFgoKTw9ZSYmKHQuZ2V0TWluWSgpPj1uJiYoaT0yKSx0LmdldE1heFkoKTw9biYmKGk9MCkpLGl9LENpLmV4cG9uZW50PWZ1bmN0aW9uKHQpe3JldHVybiBTaSg2NCx0KS0xMDIzfSxDaS5wb3dlck9mMj1mdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5wb3coMix0KX0sZSh3aS5wcm90b3R5cGUse2dldExldmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGV2ZWx9LGNvbXB1dGVLZXk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO2Zvcih0aGlzLmxldmVsPXdpLmNvbXB1dGVRdWFkTGV2ZWwodCksdGhpcy5lbnY9bmV3IEMsdGhpcy5jb21wdXRlS2V5KHRoaXMubGV2ZWwsdCk7IXRoaXMuZW52LmNvbnRhaW5zKHQpOyl0aGlzLmxldmVsKz0xLHRoaXMuY29tcHV0ZUtleSh0aGlzLmxldmVsLHQpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPUNpLnBvd2VyT2YyKGUpO3RoaXMucHQueD1NYXRoLmZsb29yKG4uZ2V0TWluWCgpL2kpKmksdGhpcy5wdC55PU1hdGguZmxvb3Iobi5nZXRNaW5ZKCkvaSkqaSx0aGlzLmVudi5pbml0KHRoaXMucHQueCx0aGlzLnB0LngraSx0aGlzLnB0LnksdGhpcy5wdC55K2kpfX0sZ2V0RW52ZWxvcGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbnZ9LGdldENlbnRyZTpmdW5jdGlvbigpe3JldHVybiBuZXcgZygodGhpcy5lbnYuZ2V0TWluWCgpK3RoaXMuZW52LmdldE1heFgoKSkvMiwodGhpcy5lbnYuZ2V0TWluWSgpK3RoaXMuZW52LmdldE1heFkoKSkvMil9LGdldFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHdpfX0pLHdpLmNvbXB1dGVRdWFkTGV2ZWw9ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpLG49dC5nZXRIZWlnaHQoKSxpPWU+bj9lOm4scj1DaS5leHBvbmVudChpKSsxO3JldHVybiByfSxoKExpLE5pKSxlKExpLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXt2YXIgZT1OaS5nZXRTdWJub2RlSW5kZXgodCx0aGlzLmNlbnRyZXgsdGhpcy5jZW50cmV5KTtpZigtMT09PWUpcmV0dXJuIHRoaXM7aWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdO3JldHVybiBuLmZpbmQodCl9cmV0dXJuIHRoaXN9LGlzU2VhcmNoTWF0Y2g6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZW52LmludGVyc2VjdHModCl9LGdldFN1Ym5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG51bGw9PT10aGlzLnN1Ym5vZGVbdF0mJih0aGlzLnN1Ym5vZGVbdF09dGhpcy5jcmVhdGVTdWJub2RlKHQpKSx0aGlzLnN1Ym5vZGVbdF19LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZW52fSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPU5pLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJleCx0aGlzLmNlbnRyZXkpO2lmKC0xIT09ZSl7dmFyIG49dGhpcy5nZXRTdWJub2RlKGUpO3JldHVybiBuLmdldE5vZGUodCl9cmV0dXJuIHRoaXN9LGNyZWF0ZVN1Ym5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9MCxuPTAsaT0wLHI9MDtzd2l0Y2godCl7Y2FzZSAwOmU9dGhpcy5lbnYuZ2V0TWluWCgpLG49dGhpcy5jZW50cmV4LGk9dGhpcy5lbnYuZ2V0TWluWSgpLHI9dGhpcy5jZW50cmV5O2JyZWFrO2Nhc2UgMTplPXRoaXMuY2VudHJleCxuPXRoaXMuZW52LmdldE1heFgoKSxpPXRoaXMuZW52LmdldE1pblkoKSxyPXRoaXMuY2VudHJleTticmVhaztjYXNlIDI6ZT10aGlzLmVudi5nZXRNaW5YKCksbj10aGlzLmNlbnRyZXgsaT10aGlzLmNlbnRyZXkscj10aGlzLmVudi5nZXRNYXhZKCk7YnJlYWs7Y2FzZSAzOmU9dGhpcy5jZW50cmV4LG49dGhpcy5lbnYuZ2V0TWF4WCgpLGk9dGhpcy5jZW50cmV5LHI9dGhpcy5lbnYuZ2V0TWF4WSgpfXZhciBzPW5ldyBDKGUsbixpLHIpLG89bmV3IExpKHMsdGhpcy5sZXZlbC0xKTtyZXR1cm4gb30saW5zZXJ0Tm9kZTpmdW5jdGlvbih0KXtmLmlzVHJ1ZShudWxsPT09dGhpcy5lbnZ8fHRoaXMuZW52LmNvbnRhaW5zKHQuZW52KSk7dmFyIGU9TmkuZ2V0U3Vibm9kZUluZGV4KHQuZW52LHRoaXMuY2VudHJleCx0aGlzLmNlbnRyZXkpO2lmKHQubGV2ZWw9PT10aGlzLmxldmVsLTEpdGhpcy5zdWJub2RlW2VdPXQ7ZWxzZXt2YXIgbj10aGlzLmNyZWF0ZVN1Ym5vZGUoZSk7bi5pbnNlcnROb2RlKHQpLHRoaXMuc3Vibm9kZVtlXT1ufX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTGl9fSksTGkuY3JlYXRlTm9kZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgd2kodCksbj1uZXcgTGkoZS5nZXRFbnZlbG9wZSgpLGUuZ2V0TGV2ZWwoKSk7cmV0dXJuIG59LExpLmNyZWF0ZUV4cGFuZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEMoZSk7bnVsbCE9PXQmJm4uZXhwYW5kVG9JbmNsdWRlKHQuZW52KTt2YXIgaT1MaS5jcmVhdGVOb2RlKG4pO3JldHVybiBudWxsIT09dCYmaS5pbnNlcnROb2RlKHQpLGl9LGUoUmkucHJvdG90eXBlLHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBSaX19KSxSaS5pc1plcm9XaWR0aD1mdW5jdGlvbih0LGUpe3ZhciBuPWUtdDtpZigwPT09bilyZXR1cm4hMDt2YXIgaT1NYXRoLm1heChNYXRoLmFicyh0KSxNYXRoLmFicyhlKSkscj1uL2kscz1DaS5leHBvbmVudChyKTtyZXR1cm4gczw9UmkuTUlOX0JJTkFSWV9FWFBPTkVOVH0sUmkuTUlOX0JJTkFSWV9FWFBPTkVOVD0tNTAsaChUaSxOaSksZShUaS5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe3ZhciBuPU5pLmdldFN1Ym5vZGVJbmRleCh0LFRpLm9yaWdpbi54LFRpLm9yaWdpbi55KTtpZigtMT09PW4pcmV0dXJuIHRoaXMuYWRkKGUpLG51bGw7dmFyIGk9dGhpcy5zdWJub2RlW25dO2lmKG51bGw9PT1pfHwhaS5nZXRFbnZlbG9wZSgpLmNvbnRhaW5zKHQpKXt2YXIgcj1MaS5jcmVhdGVFeHBhbmRlZChpLHQpO3RoaXMuc3Vibm9kZVtuXT1yfXRoaXMuaW5zZXJ0Q29udGFpbmVkKHRoaXMuc3Vibm9kZVtuXSx0LGUpfSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiEwfSxpbnNlcnRDb250YWluZWQ6ZnVuY3Rpb24odCxlLG4pe2YuaXNUcnVlKHQuZ2V0RW52ZWxvcGUoKS5jb250YWlucyhlKSk7dmFyIGk9UmkuaXNaZXJvV2lkdGgoZS5nZXRNaW5YKCksZS5nZXRNYXhYKCkpLHI9UmkuaXNaZXJvV2lkdGgoZS5nZXRNaW5ZKCksZS5nZXRNYXhZKCkpLHM9bnVsbDtzPWl8fHI/dC5maW5kKGUpOnQuZ2V0Tm9kZShlKSxzLmFkZChuKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVGl9fSksVGkub3JpZ2luPW5ldyBnKDAsMCksZShQaS5wcm90b3R5cGUse3NpemU6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3Quc2l6ZSgpOjB9LGluc2VydDpmdW5jdGlvbih0LGUpe3RoaXMuY29sbGVjdFN0YXRzKHQpO3ZhciBuPVBpLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTt0aGlzLnJvb3QuaW5zZXJ0KG4sZSl9LHF1ZXJ5OmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBZbjtyZXR1cm4gdGhpcy5xdWVyeSh0LGUpLGUuZ2V0SXRlbXMoKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdO3RoaXMucm9vdC52aXNpdChuLGkpfX0scXVlcnlBbGw6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgSTtyZXR1cm4gdGhpcy5yb290LmFkZEFsbEl0ZW1zKHQpLFxudH0scmVtb3ZlOmZ1bmN0aW9uKHQsZSl7dmFyIG49UGkuZW5zdXJlRXh0ZW50KHQsdGhpcy5taW5FeHRlbnQpO3JldHVybiB0aGlzLnJvb3QucmVtb3ZlKG4sZSl9LGNvbGxlY3RTdGF0czpmdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCk7ZTx0aGlzLm1pbkV4dGVudCYmZT4wJiYodGhpcy5taW5FeHRlbnQ9ZSk7dmFyIG49dC5nZXRIZWlnaHQoKTtuPHRoaXMubWluRXh0ZW50JiZuPjAmJih0aGlzLm1pbkV4dGVudD1uKX0sZGVwdGg6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMucm9vdD90aGlzLnJvb3QuZGVwdGgoKTowfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnJvb3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0ZlLHVdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBQaX19KSxQaS5lbnN1cmVFeHRlbnQ9ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldE1pblgoKSxpPXQuZ2V0TWF4WCgpLHI9dC5nZXRNaW5ZKCkscz10LmdldE1heFkoKTtyZXR1cm4gbiE9PWkmJnIhPT1zP3Q6KG49PT1pJiYobi09ZS8yLGk9bitlLzIpLHI9PT1zJiYoci09ZS8yLHM9citlLzIpLG5ldyBDKG4saSxyLHMpKX0sUGkuc2VyaWFsVmVyc2lvblVJRD0tMHg2NzhiNjBjOTY3YTI1NDAwO3ZhciBwbz1PYmplY3QuZnJlZXplKHtRdWFkdHJlZTpQaX0pLHZvPU9iamVjdC5mcmVlemUoe1NUUnRyZWU6a2V9KSxtbz1PYmplY3QuZnJlZXplKHtxdWFkdHJlZTpwbyxzdHJ0cmVlOnZvfSkseW89W1wiUG9pbnRcIixcIk11bHRpUG9pbnRcIixcIkxpbmVTdHJpbmdcIixcIk11bHRpTGluZVN0cmluZ1wiLFwiUG9seWdvblwiLFwiTXVsdGlQb2x5Z29uXCJdO2UoYmkucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlPXZvaWQgMDtlPVwic3RyaW5nXCI9PXR5cGVvZiB0P0pTT04ucGFyc2UodCk6dDt2YXIgbj1lLnR5cGU7aWYoIXhvW25dKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIitlLnR5cGUpO3JldHVybi0xIT09eW8uaW5kZXhPZihuKT94b1tuXS5hcHBseSh0aGlzLFtlLmNvb3JkaW5hdGVzXSk6XCJHZW9tZXRyeUNvbGxlY3Rpb25cIj09PW4/eG9bbl0uYXBwbHkodGhpcyxbZS5nZW9tZXRyaWVzXSk6eG9bbl0uYXBwbHkodGhpcyxbZV0pfSx3cml0ZTpmdW5jdGlvbih0KXt2YXIgZT10LmdldEdlb21ldHJ5VHlwZSgpO2lmKCFFb1tlXSl0aHJvdyBuZXcgRXJyb3IoXCJHZW9tZXRyeSBpcyBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiBFb1tlXS5hcHBseSh0aGlzLFt0XSl9fSk7dmFyIHhvPXtGZWF0dXJlOmZ1bmN0aW9uKHQpe3ZhciBlPXt9O2Zvcih2YXIgbiBpbiB0KWVbbl09dFtuXTtpZih0Lmdlb21ldHJ5KXt2YXIgaT10Lmdlb21ldHJ5LnR5cGU7aWYoIXhvW2ldKXRocm93IG5ldyBFcnJvcihcIlVua25vd24gR2VvSlNPTiB0eXBlOiBcIit0LnR5cGUpO2UuZ2VvbWV0cnk9dGhpcy5yZWFkKHQuZ2VvbWV0cnkpfXJldHVybiB0LmJib3gmJihlLmJib3g9eG8uYmJveC5hcHBseSh0aGlzLFt0LmJib3hdKSksZX0sRmVhdHVyZUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7dmFyIGU9e307aWYodC5mZWF0dXJlcyl7ZS5mZWF0dXJlcz1bXTtmb3IodmFyIG49MDtuPHQuZmVhdHVyZXMubGVuZ3RoOysrbillLmZlYXR1cmVzLnB1c2godGhpcy5yZWFkKHQuZmVhdHVyZXNbbl0pKX1yZXR1cm4gdC5iYm94JiYoZS5iYm94PXRoaXMucGFyc2UuYmJveC5hcHBseSh0aGlzLFt0LmJib3hdKSksZX0sY29vcmRpbmF0ZXM6ZnVuY3Rpb24gdChlKXtmb3IodmFyIHQ9W10sbj0wO248ZS5sZW5ndGg7KytuKXt2YXIgaT1lW25dO3QucHVzaChuZXcgZyhpWzBdLGlbMV0pKX1yZXR1cm4gdH0sYmJveDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyhbbmV3IGcodFswXSx0WzFdKSxuZXcgZyh0WzJdLHRbMV0pLG5ldyBnKHRbMl0sdFszXSksbmV3IGcodFswXSx0WzNdKSxuZXcgZyh0WzBdLHRbMV0pXSl9LFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnKHRbMF0sdFsxXSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvaW50KGUpfSxNdWx0aVBvaW50OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmxlbmd0aDsrK24pZS5wdXNoKHhvLlBvaW50LmFwcGx5KHRoaXMsW3Rbbl1dKSk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpUG9pbnQoZSl9LExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9eG8uY29vcmRpbmF0ZXMuYXBwbHkodGhpcyxbdF0pO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKGUpfSxNdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbillLnB1c2goeG8uTGluZVN0cmluZy5hcHBseSh0aGlzLFt0W25dXSkpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aUxpbmVTdHJpbmcoZSl9LFBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXhvLmNvb3JkaW5hdGVzLmFwcGx5KHRoaXMsW3RbMF1dKSxuPXRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUxpbmVhclJpbmcoZSksaT1bXSxyPTE7cjx0Lmxlbmd0aDsrK3Ipe3ZhciBzPXRbcl0sbz14by5jb29yZGluYXRlcy5hcHBseSh0aGlzLFtzXSksYT10aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKG8pO2kucHVzaChhKX1yZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlUG9seWdvbihuLGkpfSxNdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQubGVuZ3RoOysrbil7dmFyIGk9dFtuXTtlLnB1c2goeG8uUG9seWdvbi5hcHBseSh0aGlzLFtpXSkpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LEdlb21ldHJ5Q29sbGVjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5sZW5ndGg7KytuKXt2YXIgaT10W25dO2UucHVzaCh0aGlzLnJlYWQoaSkpfXJldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oZSl9fSxFbz17Y29vcmRpbmF0ZTpmdW5jdGlvbih0KXtyZXR1cm5bdC54LHQueV19LFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPUVvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbdC5nZXRDb29yZGluYXRlKCldKTtyZXR1cm57dHlwZTpcIlBvaW50XCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1Fby5Qb2ludC5hcHBseSh0aGlzLFtpXSk7ZS5wdXNoKHIuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlQb2ludFwiLGNvb3JkaW5hdGVzOmV9fSxMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPTA7aTxuLmxlbmd0aDsrK2kpe3ZhciByPW5baV07ZS5wdXNoKEVvLmNvb3JkaW5hdGUuYXBwbHkodGhpcyxbcl0pKX1yZXR1cm57dHlwZTpcIkxpbmVTdHJpbmdcIixjb29yZGluYXRlczplfX0sTXVsdGlMaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoOysrbil7dmFyIGk9dC5nZW9tZXRyaWVzW25dLHI9RW8uTGluZVN0cmluZy5hcHBseSh0aGlzLFtpXSk7ZS5wdXNoKHIuY29vcmRpbmF0ZXMpfXJldHVybnt0eXBlOlwiTXVsdGlMaW5lU3RyaW5nXCIsY29vcmRpbmF0ZXM6ZX19LFBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9W10sbj1Fby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW3Quc2hlbGxdKTtlLnB1c2gobi5jb29yZGluYXRlcyk7Zm9yKHZhciBpPTA7aTx0LmhvbGVzLmxlbmd0aDsrK2kpe3ZhciByPXQuaG9sZXNbaV0scz1Fby5MaW5lU3RyaW5nLmFwcGx5KHRoaXMsW3JdKTtlLnB1c2gocy5jb29yZGluYXRlcyl9cmV0dXJue3R5cGU6XCJQb2x5Z29uXCIsY29vcmRpbmF0ZXM6ZX19LE11bHRpUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W10sbj0wO248dC5nZW9tZXRyaWVzLmxlbmd0aDsrK24pe3ZhciBpPXQuZ2VvbWV0cmllc1tuXSxyPUVvLlBvbHlnb24uYXBwbHkodGhpcyxbaV0pO2UucHVzaChyLmNvb3JkaW5hdGVzKX1yZXR1cm57dHlwZTpcIk11bHRpUG9seWdvblwiLGNvb3JkaW5hdGVzOmV9fSxHZW9tZXRyeUNvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7KytuKXt2YXIgaT10Lmdlb21ldHJpZXNbbl0scj1pLmdldEdlb21ldHJ5VHlwZSgpO2UucHVzaChFb1tyXS5hcHBseSh0aGlzLFtpXSkpfXJldHVybnt0eXBlOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCIsZ2VvbWV0cmllczplfX19O2UoT2kucHJvdG90eXBlLHtyZWFkOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucGFyc2VyLnJlYWQodCk7cmV0dXJuIHRoaXMucHJlY2lzaW9uTW9kZWwuZ2V0VHlwZSgpPT09ZWUuRklYRUQmJnRoaXMucmVkdWNlUHJlY2lzaW9uKGUpLGV9LHJlZHVjZVByZWNpc2lvbjpmdW5jdGlvbih0KXt2YXIgZSxuO2lmKHQuY29vcmRpbmF0ZSl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQuY29vcmRpbmF0ZSk7ZWxzZSBpZih0LnBvaW50cylmb3IoZT0wLG49dC5wb2ludHMubGVuZ3RoO24+ZTtlKyspdGhpcy5wcmVjaXNpb25Nb2RlbC5tYWtlUHJlY2lzZSh0LnBvaW50c1tlXSk7ZWxzZSBpZih0Lmdlb21ldHJpZXMpZm9yKGU9MCxuPXQuZ2VvbWV0cmllcy5sZW5ndGg7bj5lO2UrKyl0aGlzLnJlZHVjZVByZWNpc2lvbih0Lmdlb21ldHJpZXNbZV0pfX0pLGUoX2kucHJvdG90eXBlLHt3cml0ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wYXJzZXIud3JpdGUodCl9fSksZShNaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5wYXJzZXIucmVhZCh0KTtyZXR1cm4gdGhpcy5wcmVjaXNpb25Nb2RlbC5nZXRUeXBlKCk9PT1lZS5GSVhFRCYmdGhpcy5yZWR1Y2VQcmVjaXNpb24oZSksZX0scmVkdWNlUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe2lmKHQuY29vcmRpbmF0ZSl0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKHQuY29vcmRpbmF0ZSk7ZWxzZSBpZih0LnBvaW50cylmb3IodmFyIGU9MCxuPXQucG9pbnRzLmNvb3JkaW5hdGVzLmxlbmd0aDtuPmU7ZSsrKXRoaXMucHJlY2lzaW9uTW9kZWwubWFrZVByZWNpc2UodC5wb2ludHMuY29vcmRpbmF0ZXNbZV0pO2Vsc2UgaWYodC5nZW9tZXRyaWVzKWZvcih2YXIgaT0wLHI9dC5nZW9tZXRyaWVzLmxlbmd0aDtyPmk7aSsrKXRoaXMucmVkdWNlUHJlY2lzaW9uKHQuZ2VvbWV0cmllc1tpXSl9fSksZShBaS5wcm90b3R5cGUse3JlYWQ6ZnVuY3Rpb24odCl7cmV0dXJuIHQgaW5zdGFuY2VvZiBvbC5nZW9tLlBvaW50P3RoaXMuY29udmVydEZyb21Qb2ludCh0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5MaW5lU3RyaW5nP3RoaXMuY29udmVydEZyb21MaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLkxpbmVhclJpbmc/dGhpcy5jb252ZXJ0RnJvbUxpbmVhclJpbmcodCk6dCBpbnN0YW5jZW9mIG9sLmdlb20uUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tUG9seWdvbih0KTp0IGluc3RhbmNlb2Ygb2wuZ2VvbS5NdWx0aVBvaW50P3RoaXMuY29udmVydEZyb21NdWx0aVBvaW50KHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLk11bHRpTGluZVN0cmluZz90aGlzLmNvbnZlcnRGcm9tTXVsdGlMaW5lU3RyaW5nKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLk11bHRpUG9seWdvbj90aGlzLmNvbnZlcnRGcm9tTXVsdGlQb2x5Z29uKHQpOnQgaW5zdGFuY2VvZiBvbC5nZW9tLkdlb21ldHJ5Q29sbGVjdGlvbj90aGlzLmNvbnZlcnRGcm9tQ29sbGVjdGlvbih0KTp2b2lkIDB9LGNvbnZlcnRGcm9tUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRDb29yZGluYXRlcygpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVQb2ludChuZXcgZyhlWzBdLGVbMV0pKX0sY29udmVydEZyb21MaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHQuZ2V0Q29vcmRpbmF0ZXMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBnKHRbMF0sdFsxXSl9KSl9LGNvbnZlcnRGcm9tTGluZWFyUmluZzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5nZW9tZXRyeUZhY3RvcnkuY3JlYXRlTGluZWFyUmluZyh0LmdldENvb3JkaW5hdGVzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiBuZXcgZyh0WzBdLHRbMV0pfSkpfSxjb252ZXJ0RnJvbVBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0TGluZWFyUmluZ3MoKSxuPW51bGwsaT1bXSxyPTA7cjxlLmxlbmd0aDtyKyspe3ZhciBzPXRoaXMuY29udmVydEZyb21MaW5lYXJSaW5nKGVbcl0pOzA9PT1yP249czppLnB1c2gocyl9cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZVBvbHlnb24obixpKX0sY29udmVydEZyb21NdWx0aVBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0UG9pbnRzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tUG9pbnQodCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvaW50KGUpfSxjb252ZXJ0RnJvbU11bHRpTGluZVN0cmluZzpmdW5jdGlvbih0KXt2YXIgZT10LmdldExpbmVTdHJpbmdzKCkubWFwKGZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNvbnZlcnRGcm9tTGluZVN0cmluZyh0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZU11bHRpTGluZVN0cmluZyhlKX0sY29udmVydEZyb21NdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRQb2x5Z29ucygpLm1hcChmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jb252ZXJ0RnJvbVBvbHlnb24odCl9LHRoaXMpO3JldHVybiB0aGlzLmdlb21ldHJ5RmFjdG9yeS5jcmVhdGVNdWx0aVBvbHlnb24oZSl9LGNvbnZlcnRGcm9tQ29sbGVjdGlvbjpmdW5jdGlvbih0KXt2YXIgZT10LmdldEdlb21ldHJpZXMoKS5tYXAoZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucmVhZCh0KX0sdGhpcyk7cmV0dXJuIHRoaXMuZ2VvbWV0cnlGYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihlKX0sd3JpdGU6ZnVuY3Rpb24odCl7cmV0dXJuXCJQb2ludFwiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb1BvaW50KHQuZ2V0Q29vcmRpbmF0ZSgpKTpcIkxpbmVTdHJpbmdcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9MaW5lU3RyaW5nKHQpOlwiTGluZWFyUmluZ1wiPT09dC5nZXRHZW9tZXRyeVR5cGUoKT90aGlzLmNvbnZlcnRUb0xpbmVhclJpbmcodCk6XCJQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvUG9seWdvbih0KTpcIk11bHRpUG9pbnRcIj09PXQuZ2V0R2VvbWV0cnlUeXBlKCk/dGhpcy5jb252ZXJ0VG9NdWx0aVBvaW50KHQpOlwiTXVsdGlMaW5lU3RyaW5nXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlMaW5lU3RyaW5nKHQpOlwiTXVsdGlQb2x5Z29uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvTXVsdGlQb2x5Z29uKHQpOlwiR2VvbWV0cnlDb2xsZWN0aW9uXCI9PT10LmdldEdlb21ldHJ5VHlwZSgpP3RoaXMuY29udmVydFRvQ29sbGVjdGlvbih0KTp2b2lkIDB9LGNvbnZlcnRUb1BvaW50OmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgb2wuZ2VvbS5Qb2ludChbdC54LHQueV0pfSxjb252ZXJ0VG9MaW5lU3RyaW5nOmZ1bmN0aW9uKHQpe3ZhciBlPXQucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSk7cmV0dXJuIG5ldyBvbC5nZW9tLkxpbmVTdHJpbmcoZSl9LGNvbnZlcnRUb0xpbmVhclJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9dC5wb2ludHMuY29vcmRpbmF0ZXMubWFwKERpKTtyZXR1cm4gbmV3IG9sLmdlb20uTGluZWFyUmluZyhlKX0sY29udmVydFRvUG9seWdvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9W3Quc2hlbGwucG9pbnRzLmNvb3JkaW5hdGVzLm1hcChEaSldLG49MDtuPHQuaG9sZXMubGVuZ3RoO24rKyllLnB1c2godC5ob2xlc1tuXS5wb2ludHMuY29vcmRpbmF0ZXMubWFwKERpKSk7cmV0dXJuIG5ldyBvbC5nZW9tLlBvbHlnb24oZSl9LGNvbnZlcnRUb011bHRpUG9pbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBvbC5nZW9tLk11bHRpUG9pbnQodC5nZXRDb29yZGluYXRlcygpLm1hcChEaSkpfSxjb252ZXJ0VG9NdWx0aUxpbmVTdHJpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb0xpbmVTdHJpbmcodC5nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IG9sLmdlb20uTXVsdGlMaW5lU3RyaW5nKGUpfSxjb252ZXJ0VG9NdWx0aVBvbHlnb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPVtdLG49MDtuPHQuZ2VvbWV0cmllcy5sZW5ndGg7bisrKWUucHVzaCh0aGlzLmNvbnZlcnRUb1BvbHlnb24odC5nZW9tZXRyaWVzW25dKS5nZXRDb29yZGluYXRlcygpKTtyZXR1cm4gbmV3IG9sLmdlb20uTXVsdGlQb2x5Z29uKGUpfSxjb252ZXJ0VG9Db2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1bXSxuPTA7bjx0Lmdlb21ldHJpZXMubGVuZ3RoO24rKyl7dmFyIGk9dC5nZW9tZXRyaWVzW25dO2UucHVzaCh0aGlzLndyaXRlKGkpKX1yZXR1cm4gbmV3IG9sLmdlb20uR2VvbWV0cnlDb2xsZWN0aW9uKGUpfX0pO3ZhciBJbz1PYmplY3QuZnJlZXplKHtHZW9KU09OUmVhZGVyOk9pLEdlb0pTT05Xcml0ZXI6X2ksT0wzUGFyc2VyOkFpLFdLVFJlYWRlcjpNaSxXS1RXcml0ZXI6c2V9KTtlKEZpLnByb3RvdHlwZSx7cmVzY2FsZTpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLnJlc2NhbGUobi5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe3ZhciBpPWFyZ3VtZW50c1swXSxyPW51bGwscz1udWxsOzI9PT1pLmxlbmd0aCYmKHI9bmV3IGcoaVswXSkscz1uZXcgZyhpWzFdKSk7Zm9yKHZhciBlPTA7ZTxpLmxlbmd0aDtlKyspaVtlXS54PWlbZV0ueC90aGlzLnNjYWxlRmFjdG9yK3RoaXMub2Zmc2V0WCxpW2VdLnk9aVtlXS55L3RoaXMuc2NhbGVGYWN0b3IrdGhpcy5vZmZzZXRZOzI9PT1pLmxlbmd0aCYmaVswXS5lcXVhbHMyRChpWzFdKSYmQS5vdXQucHJpbnRsbihpKX19LHNjYWxlOmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuYWRkKG5ldyBLZSh0aGlzLnNjYWxlKGkuZ2V0Q29vcmRpbmF0ZXMoKSksaS5nZXREYXRhKCkpKX1yZXR1cm4gZX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEFycmF5KXtmb3IodmFyIHI9YXJndW1lbnRzWzBdLHM9bmV3IEFycmF5KHIubGVuZ3RoKS5maWxsKG51bGwpLG49MDtuPHIubGVuZ3RoO24rKylzW25dPW5ldyBnKE1hdGgucm91bmQoKHJbbl0ueC10aGlzLm9mZnNldFgpKnRoaXMuc2NhbGVGYWN0b3IpLE1hdGgucm91bmQoKHJbbl0ueS10aGlzLm9mZnNldFkpKnRoaXMuc2NhbGVGYWN0b3IpLHJbbl0ueik7dmFyIG89SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhzKTtyZXR1cm4gb319LGlzSW50ZWdlclByZWNpc2lvbjpmdW5jdGlvbigpe3JldHVybiAxPT09dGhpcy5zY2FsZUZhY3Rvcn0sZ2V0Tm9kZWRTdWJzdHJpbmdzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5ub2Rlci5nZXROb2RlZFN1YnN0cmluZ3MoKTtyZXR1cm4gdGhpcy5pc1NjYWxlZCYmdGhpcy5yZXNjYWxlKHQpLHR9LGNvbXB1dGVOb2RlczpmdW5jdGlvbih0KXt2YXIgZT10O3RoaXMuaXNTY2FsZWQmJihlPXRoaXMuc2NhbGUodCkpLHRoaXMubm9kZXIuY29tcHV0ZU5vZGVzKGUpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblt0bl19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZpfX0pO3ZhciBObz1PYmplY3QuZnJlZXplKHtNQ0luZGV4Tm9kZXI6bm4sU2NhbGVkTm9kZXI6RmksU2VnbWVudFN0cmluZzpiZX0pO2UoR2kucHJvdG90eXBlLHtpc1NpbXBsZU11bHRpUG9pbnQ6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuITA7Zm9yKHZhciBlPW5ldyBhdCxuPTA7bjx0LmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXQuZ2V0R2VvbWV0cnlOKG4pLHI9aS5nZXRDb29yZGluYXRlKCk7aWYoZS5jb250YWlucyhyKSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1yLCExO2UuYWRkKHIpfXJldHVybiEwfSxpc1NpbXBsZVBvbHlnb25hbDpmdW5jdGlvbih0KXtmb3IodmFyIGU9a24uZ2V0TGluZXModCksbj1lLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighdGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KGkpKXJldHVybiExfXJldHVybiEwfSxoYXNDbG9zZWRFbmRwb2ludEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IHJ0LG49dC5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9KGkuZ2V0TWF4aW11bVNlZ21lbnRJbmRleCgpLGkuaXNDbG9zZWQoKSkscz1pLmdldENvb3JkaW5hdGUoMCk7dGhpcy5hZGRFbmRwb2ludChlLHMscik7dmFyIG89aS5nZXRDb29yZGluYXRlKGkuZ2V0TnVtUG9pbnRzKCktMSk7dGhpcy5hZGRFbmRwb2ludChlLG8scil9Zm9yKHZhciBuPWUudmFsdWVzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBhPW4ubmV4dCgpO2lmKGEuaXNDbG9zZWQmJjIhPT1hLmRlZ3JlZSlyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1hLmdldENvb3JkaW5hdGUoKSwhMH1yZXR1cm4hMX0sZ2V0Tm9uU2ltcGxlTG9jYXRpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbn0saXNTaW1wbGVMaW5lYXJHZW9tZXRyeTpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4hMDt2YXIgZT1uZXcgJG4oMCx0KSxuPW5ldyBhZSxpPWUuY29tcHV0ZVNlbGZOb2RlcyhuLCEwKTtyZXR1cm4gaS5oYXNJbnRlcnNlY3Rpb24oKT9pLmhhc1Byb3BlckludGVyc2VjdGlvbigpPyh0aGlzLm5vblNpbXBsZUxvY2F0aW9uPWkuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6dGhpcy5oYXNOb25FbmRwb2ludEludGVyc2VjdGlvbihlKT8hMTohdGhpcy5pc0Nsb3NlZEVuZHBvaW50c0luSW50ZXJpb3J8fCF0aGlzLmhhc0Nsb3NlZEVuZHBvaW50SW50ZXJzZWN0aW9uKGUpOiEwfSxoYXNOb25FbmRwb2ludEludGVyc2VjdGlvbjpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRNYXhpbXVtU2VnbWVudEluZGV4KCkscj1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO2lmKCFzLmlzRW5kUG9pbnQoaSkpcmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249cy5nZXRDb29yZGluYXRlKCksITB9cmV0dXJuITF9LGFkZEVuZHBvaW50OmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10LmdldChlKTtudWxsPT09aSYmKGk9bmV3IHFpKGUpLHQucHV0KGUsaSkpLGkuYWRkRW5kcG9pbnQobil9LGNvbXB1dGVTaW1wbGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9uU2ltcGxlTG9jYXRpb249bnVsbCx0LmlzRW1wdHkoKT8hMDp0IGluc3RhbmNlb2YgU3Q/dGhpcy5pc1NpbXBsZUxpbmVhckdlb21ldHJ5KHQpOnQgaW5zdGFuY2VvZiBndD90aGlzLmlzU2ltcGxlTGluZWFyR2VvbWV0cnkodCk6dCBpbnN0YW5jZW9mIFB0P3RoaXMuaXNTaW1wbGVNdWx0aVBvaW50KHQpOlIodCxSdCk/dGhpcy5pc1NpbXBsZVBvbHlnb25hbCh0KTp0IGluc3RhbmNlb2YgZnQ/dGhpcy5pc1NpbXBsZUdlb21ldHJ5Q29sbGVjdGlvbih0KTohMH0saXNTaW1wbGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub25TaW1wbGVMb2NhdGlvbj1udWxsLHRoaXMuY29tcHV0ZVNpbXBsZSh0aGlzLmlucHV0R2VvbSl9LGlzU2ltcGxlR2VvbWV0cnlDb2xsZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCk7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTtpZighdGhpcy5jb21wdXRlU2ltcGxlKG4pKXJldHVybiExfXJldHVybiEwfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHaX19KSxlKHFpLnByb3RvdHlwZSx7YWRkRW5kcG9pbnQ6ZnVuY3Rpb24odCl7dGhpcy5kZWdyZWUrKyx0aGlzLmlzQ2xvc2VkfD10fSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFpfX0pLEdpLkVuZHBvaW50SW5mbz1xaSxlKEJpLnByb3RvdHlwZSx7Z2V0RW5kQ2FwU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lbmRDYXBTdHlsZX0saXNTaW5nbGVTaWRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc1NpbmdsZVNpZGVkfSxzZXRRdWFkcmFudFNlZ21lbnRzOmZ1bmN0aW9uKHQpe3RoaXMucXVhZHJhbnRTZWdtZW50cz10LDA9PT10aGlzLnF1YWRyYW50U2VnbWVudHMmJih0aGlzLmpvaW5TdHlsZT1CaS5KT0lOX0JFVkVMKSx0aGlzLnF1YWRyYW50U2VnbWVudHM8MCYmKHRoaXMuam9pblN0eWxlPUJpLkpPSU5fTUlUUkUsdGhpcy5taXRyZUxpbWl0PU1hdGguYWJzKHRoaXMucXVhZHJhbnRTZWdtZW50cykpLDA+PXQmJih0aGlzLnF1YWRyYW50U2VnbWVudHM9MSksdGhpcy5qb2luU3R5bGUhPT1CaS5KT0lOX1JPVU5EJiYodGhpcy5xdWFkcmFudFNlZ21lbnRzPUJpLkRFRkFVTFRfUVVBRFJBTlRfU0VHTUVOVFMpfSxnZXRKb2luU3R5bGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5qb2luU3R5bGV9LHNldEpvaW5TdHlsZTpmdW5jdGlvbih0KXt0aGlzLmpvaW5TdHlsZT10fSxzZXRTaW1wbGlmeUZhY3RvcjpmdW5jdGlvbih0KXt0aGlzLnNpbXBsaWZ5RmFjdG9yPTA+dD8wOnR9LGdldFNpbXBsaWZ5RmFjdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2ltcGxpZnlGYWN0b3J9LGdldFF1YWRyYW50U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5xdWFkcmFudFNlZ21lbnRzfSxzZXRFbmRDYXBTdHlsZTpmdW5jdGlvbih0KXt0aGlzLmVuZENhcFN0eWxlPXR9LGdldE1pdHJlTGltaXQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taXRyZUxpbWl0fSxzZXRNaXRyZUxpbWl0OmZ1bmN0aW9uKHQpe3RoaXMubWl0cmVMaW1pdD10fSxzZXRTaW5nbGVTaWRlZDpmdW5jdGlvbih0KXt0aGlzLl9pc1NpbmdsZVNpZGVkPXR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEJpfX0pLEJpLmJ1ZmZlckRpc3RhbmNlRXJyb3I9ZnVuY3Rpb24odCl7dmFyIGU9TWF0aC5QSS8yL3Q7cmV0dXJuIDEtTWF0aC5jb3MoZS8yKX0sQmkuQ0FQX1JPVU5EPTEsQmkuQ0FQX0ZMQVQ9MixCaS5DQVBfU1FVQVJFPTMsQmkuSk9JTl9ST1VORD0xLEJpLkpPSU5fTUlUUkU9MixCaS5KT0lOX0JFVkVMPTMsQmkuREVGQVVMVF9RVUFEUkFOVF9TRUdNRU5UUz04LEJpLkRFRkFVTFRfTUlUUkVfTElNSVQ9NSxCaS5ERUZBVUxUX1NJTVBMSUZZX0ZBQ1RPUj0uMDEsZSh6aS5wcm90b3R5cGUse2dldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5taW5Db29yZH0sZ2V0UmlnaHRtb3N0U2lkZTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUpO3JldHVybiAwPm4mJihuPXRoaXMuZ2V0UmlnaHRtb3N0U2lkZU9mU2VnbWVudCh0LGUtMSkpLDA+biYmKHRoaXMubWluQ29vcmQ9bnVsbCx0aGlzLmNoZWNrRm9yUmlnaHRtb3N0Q29vcmRpbmF0ZSh0KSksbn0sZmluZFJpZ2h0bW9zdEVkZ2VBdFZlcnRleDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubWluRGUuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCk7Zi5pc1RydWUodGhpcy5taW5JbmRleD4wJiZ0aGlzLm1pbkluZGV4PHQubGVuZ3RoLFwicmlnaHRtb3N0IHBvaW50IGV4cGVjdGVkIHRvIGJlIGludGVyaW9yIHZlcnRleCBvZiBlZGdlXCIpO3ZhciBlPXRbdGhpcy5taW5JbmRleC0xXSxuPXRbdGhpcy5taW5JbmRleCsxXSxpPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLm1pbkNvb3JkLG4sZSkscj0hMTtlLnk8dGhpcy5taW5Db29yZC55JiZuLnk8dGhpcy5taW5Db29yZC55JiZpPT09aGUuQ09VTlRFUkNMT0NLV0lTRT9yPSEwOmUueT50aGlzLm1pbkNvb3JkLnkmJm4ueT50aGlzLm1pbkNvb3JkLnkmJmk9PT1oZS5DTE9DS1dJU0UmJihyPSEwKSxyJiYodGhpcy5taW5JbmRleD10aGlzLm1pbkluZGV4LTEpfSxnZXRSaWdodG1vc3RTaWRlT2ZTZWdtZW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRFZGdlKCksaT1uLmdldENvb3JkaW5hdGVzKCk7aWYoMD5lfHxlKzE+PWkubGVuZ3RoKXJldHVybi0xO2lmKGlbZV0ueT09PWlbZSsxXS55KXJldHVybi0xO3ZhciByPWNuLkxFRlQ7cmV0dXJuIGlbZV0ueTxpW2UrMV0ueSYmKHI9Y24uUklHSFQpLHJ9LGdldEVkZ2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmllbnRlZERlfSxjaGVja0ZvclJpZ2h0bW9zdENvb3JkaW5hdGU6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZSgpLmdldENvb3JkaW5hdGVzKCksbj0wO248ZS5sZW5ndGgtMTtuKyspKG51bGw9PT10aGlzLm1pbkNvb3JkfHxlW25dLng+dGhpcy5taW5Db29yZC54KSYmKHRoaXMubWluRGU9dCx0aGlzLm1pbkluZGV4PW4sdGhpcy5taW5Db29yZD1lW25dKX0sZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGU6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLm1pbkRlLmdldE5vZGUoKSxlPXQuZ2V0RWRnZXMoKTt0aGlzLm1pbkRlPWUuZ2V0UmlnaHRtb3N0RWRnZSgpLHRoaXMubWluRGUuaXNGb3J3YXJkKCl8fCh0aGlzLm1pbkRlPXRoaXMubWluRGUuZ2V0U3ltKCksdGhpcy5taW5JbmRleD10aGlzLm1pbkRlLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLmxlbmd0aC0xKX0sZmluZEVkZ2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uaXNGb3J3YXJkKCkmJnRoaXMuY2hlY2tGb3JSaWdodG1vc3RDb29yZGluYXRlKG4pfWYuaXNUcnVlKDAhPT10aGlzLm1pbkluZGV4fHx0aGlzLm1pbkNvb3JkLmVxdWFscyh0aGlzLm1pbkRlLmdldENvb3JkaW5hdGUoKSksXCJpbmNvbnNpc3RlbmN5IGluIHJpZ2h0bW9zdCBwcm9jZXNzaW5nXCIpLDA9PT10aGlzLm1pbkluZGV4P3RoaXMuZmluZFJpZ2h0bW9zdEVkZ2VBdE5vZGUoKTp0aGlzLmZpbmRSaWdodG1vc3RFZGdlQXRWZXJ0ZXgoKSx0aGlzLm9yaWVudGVkRGU9dGhpcy5taW5EZTt2YXIgaT10aGlzLmdldFJpZ2h0bW9zdFNpZGUodGhpcy5taW5EZSx0aGlzLm1pbkluZGV4KTtpPT09Y24uTEVGVCYmKHRoaXMub3JpZW50ZWREZT10aGlzLm1pbkRlLmdldFN5bSgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geml9fSksVmkucHJvdG90eXBlLmFkZExhc3Q9ZnVuY3Rpb24odCl7dGhpcy5hcnJheV8ucHVzaCh0KX0sVmkucHJvdG90eXBlLnJlbW92ZUZpcnN0PWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYXJyYXlfLnNoaWZ0KCl9LFZpLnByb3RvdHlwZS5pc0VtcHR5PWZ1bmN0aW9uKCl7cmV0dXJuIDA9PT10aGlzLmFycmF5Xy5sZW5ndGh9LGUoa2kucHJvdG90eXBlLHtjbGVhclZpc2l0ZWRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmRpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLnNldFZpc2l0ZWQoITEpfX0sZ2V0UmlnaHRtb3N0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnJpZ2h0TW9zdENvb3JkfSxjb21wdXRlTm9kZURlcHRoOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1udWxsLG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZihpLmlzVmlzaXRlZCgpfHxpLmdldFN5bSgpLmlzVmlzaXRlZCgpKXtlPWk7YnJlYWt9fWlmKG51bGw9PT1lKXRocm93IG5ldyBzbihcInVuYWJsZSB0byBmaW5kIGVkZ2UgdG8gY29tcHV0ZSBkZXB0aHMgYXQgXCIrdC5nZXRDb29yZGluYXRlKCkpO3QuZ2V0RWRnZXMoKS5jb21wdXRlRGVwdGhzKGUpO2Zvcih2YXIgbj10LmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0VmlzaXRlZCghMCksdGhpcy5jb3B5U3ltRGVwdGhzKGkpfX0sY29tcHV0ZURlcHRoOmZ1bmN0aW9uKHQpe3RoaXMuY2xlYXJWaXNpdGVkRWRnZXMoKTt2YXIgZT10aGlzLmZpbmRlci5nZXRFZGdlKCk7ZS5nZXROb2RlKCksZS5nZXRMYWJlbCgpO2Uuc2V0RWRnZURlcHRocyhjbi5SSUdIVCx0KSx0aGlzLmNvcHlTeW1EZXB0aHMoZSksdGhpcy5jb21wdXRlRGVwdGhzKGUpfSxjcmVhdGU6ZnVuY3Rpb24odCl7dGhpcy5hZGRSZWFjaGFibGUodCksdGhpcy5maW5kZXIuZmluZEVkZ2UodGhpcy5kaXJFZGdlTGlzdCksdGhpcy5yaWdodE1vc3RDb29yZD10aGlzLmZpbmRlci5nZXRDb29yZGluYXRlKCl9LGZpbmRSZXN1bHRFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLmRpckVkZ2VMaXN0Lml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtlLmdldERlcHRoKGNuLlJJR0hUKT49MSYmZS5nZXREZXB0aChjbi5MRUZUKTw9MCYmIWUuaXNJbnRlcmlvckFyZWFFZGdlKCkmJmUuc2V0SW5SZXN1bHQoITApfX0sY29tcHV0ZURlcHRoczpmdW5jdGlvbih0KXt2YXIgZT1uZXcgSixuPW5ldyBWaSxpPXQuZ2V0Tm9kZSgpO2ZvcihuLmFkZExhc3QoaSksZS5hZGQoaSksdC5zZXRWaXNpdGVkKCEwKTshbi5pc0VtcHR5KCk7KXt2YXIgcj1uLnJlbW92ZUZpcnN0KCk7ZS5hZGQociksdGhpcy5jb21wdXRlTm9kZURlcHRoKHIpO2Zvcih2YXIgcz1yLmdldEVkZ2VzKCkuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpLGE9by5nZXRTeW0oKTtpZighYS5pc1Zpc2l0ZWQoKSl7dmFyIHU9YS5nZXROb2RlKCk7ZS5jb250YWlucyh1KXx8KG4uYWRkTGFzdCh1KSxlLmFkZCh1KSl9fX19LGNvbXBhcmVUbzpmdW5jdGlvbih0KXt2YXIgZT10O3JldHVybiB0aGlzLnJpZ2h0TW9zdENvb3JkLng8ZS5yaWdodE1vc3RDb29yZC54Py0xOnRoaXMucmlnaHRNb3N0Q29vcmQueD5lLnJpZ2h0TW9zdENvb3JkLng/MTowfSxnZXRFbnZlbG9wZTpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmVudil7Zm9yKHZhciB0PW5ldyBDLGU9dGhpcy5kaXJFZGdlTGlzdC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlcygpLHI9MDtyPGkubGVuZ3RoLTE7cisrKXQuZXhwYW5kVG9JbmNsdWRlKGlbcl0pO3RoaXMuZW52PXR9cmV0dXJuIHRoaXMuZW52fSxhZGRSZWFjaGFibGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHBlO2ZvcihlLmFkZCh0KTshZS5lbXB0eSgpOyl7dmFyIG49ZS5wb3AoKTt0aGlzLmFkZChuLGUpfX0sY29weVN5bURlcHRoczpmdW5jdGlvbih0KXt2YXIgZT10LmdldFN5bSgpO2Uuc2V0RGVwdGgoY24uTEVGVCx0LmdldERlcHRoKGNuLlJJR0hUKSksZS5zZXREZXB0aChjbi5SSUdIVCx0LmdldERlcHRoKGNuLkxFRlQpKX0sYWRkOmZ1bmN0aW9uKHQsZSl7dC5zZXRWaXNpdGVkKCEwKSx0aGlzLm5vZGVzLmFkZCh0KTtmb3IodmFyIG49dC5nZXRFZGdlcygpLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmRpckVkZ2VMaXN0LmFkZChpKTt2YXIgcj1pLmdldFN5bSgpLHM9ci5nZXROb2RlKCk7cy5pc1Zpc2l0ZWQoKXx8ZS5wdXNoKHMpfX0sZ2V0Tm9kZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2Rlc30sZ2V0RGlyZWN0ZWRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpckVkZ2VMaXN0fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ga2l9fSksZShZaS5wcm90b3R5cGUse2lzRGVsZXRhYmxlOmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXRoaXMuaW5wdXRMaW5lW3RdLHM9dGhpcy5pbnB1dExpbmVbZV0sbz10aGlzLmlucHV0TGluZVtuXTtyZXR1cm4gdGhpcy5pc0NvbmNhdmUocixzLG8pJiZ0aGlzLmlzU2hhbGxvdyhyLHMsbyxpKT90aGlzLmlzU2hhbGxvd1NhbXBsZWQocixzLHQsbixpKTohMX0sZGVsZXRlU2hhbGxvd0NvbmNhdml0aWVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTEsZT0odGhpcy5pbnB1dExpbmUubGVuZ3RoLTEsdGhpcy5maW5kTmV4dE5vbkRlbGV0ZWRJbmRleCh0KSksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpLGk9ITE7bjx0aGlzLmlucHV0TGluZS5sZW5ndGg7KXt2YXIgcj0hMTt0aGlzLmlzRGVsZXRhYmxlKHQsZSxuLHRoaXMuZGlzdGFuY2VUb2wpJiYodGhpcy5pc0RlbGV0ZWRbZV09WWkuREVMRVRFLHI9ITAsaT0hMCksdD1yP246ZSxlPXRoaXMuZmluZE5leHROb25EZWxldGVkSW5kZXgodCksbj10aGlzLmZpbmROZXh0Tm9uRGVsZXRlZEluZGV4KGUpfXJldHVybiBpfSxpc1NoYWxsb3dDb25jYXZpdHk6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9aGUuY29tcHV0ZU9yaWVudGF0aW9uKHQsZSxuKSxzPXI9PT10aGlzLmFuZ2xlT3JpZW50YXRpb247aWYoIXMpcmV0dXJuITE7dmFyIG89aGUuZGlzdGFuY2VQb2ludExpbmUoZSx0LG4pO3JldHVybiBpPm99LGlzU2hhbGxvd1NhbXBsZWQ6ZnVuY3Rpb24odCxlLG4saSxyKXt2YXIgcz1NYXRoLnRydW5jKChpLW4pL1lpLk5VTV9QVFNfVE9fQ0hFQ0spOzA+PXMmJihzPTEpO2Zvcih2YXIgbz1uO2k+bztvKz1zKWlmKCF0aGlzLmlzU2hhbGxvdyh0LGUsdGhpcy5pbnB1dExpbmVbb10scikpcmV0dXJuITE7cmV0dXJuITB9LGlzQ29uY2F2ZTpmdW5jdGlvbiB0KGUsbixpKXt2YXIgcj1oZS5jb21wdXRlT3JpZW50YXRpb24oZSxuLGkpLHQ9cj09PXRoaXMuYW5nbGVPcmllbnRhdGlvbjtyZXR1cm4gdH0sc2ltcGxpZnk6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbD1NYXRoLmFicyh0KSwwPnQmJih0aGlzLmFuZ2xlT3JpZW50YXRpb249aGUuQ0xPQ0tXSVNFKSx0aGlzLmlzRGVsZXRlZD1uZXcgQXJyYXkodGhpcy5pbnB1dExpbmUubGVuZ3RoKS5maWxsKG51bGwpO3ZhciBlPSExO2RvIGU9dGhpcy5kZWxldGVTaGFsbG93Q29uY2F2aXRpZXMoKTt3aGlsZShlKTtyZXR1cm4gdGhpcy5jb2xsYXBzZUxpbmUoKX0sZmluZE5leHROb25EZWxldGVkSW5kZXg6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQrMTtlPHRoaXMuaW5wdXRMaW5lLmxlbmd0aCYmdGhpcy5pc0RlbGV0ZWRbZV09PT1ZaS5ERUxFVEU7KWUrKztyZXR1cm4gZX0saXNTaGFsbG93OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWhlLmRpc3RhbmNlUG9pbnRMaW5lKGUsdCxuKTtyZXR1cm4gaT5yfSxjb2xsYXBzZUxpbmU6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IE4sZT0wO2U8dGhpcy5pbnB1dExpbmUubGVuZ3RoO2UrKyl0aGlzLmlzRGVsZXRlZFtlXSE9PVlpLkRFTEVURSYmdC5hZGQodGhpcy5pbnB1dExpbmVbZV0pO3JldHVybiB0LnRvQ29vcmRpbmF0ZUFycmF5KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFlpfX0pLFlpLnNpbXBsaWZ5PWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFlpKHQpO3JldHVybiBuLnNpbXBsaWZ5KGUpfSxZaS5JTklUPTAsWWkuREVMRVRFPTEsWWkuS0VFUD0xLFlpLk5VTV9QVFNfVE9fQ0hFQ0s9MTAsZShVaS5wcm90b3R5cGUse2dldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5wdExpc3QudG9BcnJheShVaS5DT09SRElOQVRFX0FSUkFZX1RZUEUpO3JldHVybiB0fSxzZXRQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLnByZWNpc2lvbk1vZGVsPXR9LGFkZFB0OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBnKHQpO3JldHVybiB0aGlzLnByZWNpc2lvbk1vZGVsLm1ha2VQcmVjaXNlKGUpLHRoaXMuaXNSZWR1bmRhbnQoZSk/bnVsbDp2b2lkIHRoaXMucHRMaXN0LmFkZChlKX0scmV2ZXJzZTpmdW5jdGlvbigpe30sYWRkUHRzOmZ1bmN0aW9uKHQsZSl7aWYoZSlmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKyl0aGlzLmFkZFB0KHRbbl0pO2Vsc2UgZm9yKHZhciBuPXQubGVuZ3RoLTE7bj49MDtuLS0pdGhpcy5hZGRQdCh0W25dKX0saXNSZWR1bmRhbnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5wdExpc3Quc2l6ZSgpPDEpcmV0dXJuITE7dmFyIGU9dGhpcy5wdExpc3QuZ2V0KHRoaXMucHRMaXN0LnNpemUoKS0xKSxuPXQuZGlzdGFuY2UoZSk7cmV0dXJuIG48dGhpcy5taW5pbWltVmVydGV4RGlzdGFuY2V9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IGllLGU9dC5jcmVhdGVMaW5lU3RyaW5nKHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSk7cmV0dXJuIGUudG9TdHJpbmcoKX0sY2xvc2VSaW5nOmZ1bmN0aW9uKCl7aWYodGhpcy5wdExpc3Quc2l6ZSgpPDEpcmV0dXJuIG51bGw7dmFyIHQ9bmV3IGcodGhpcy5wdExpc3QuZ2V0KDApKSxlPXRoaXMucHRMaXN0LmdldCh0aGlzLnB0TGlzdC5zaXplKCktMSksbj1udWxsO3JldHVybiB0aGlzLnB0TGlzdC5zaXplKCk+PTImJihuPXRoaXMucHRMaXN0LmdldCh0aGlzLnB0TGlzdC5zaXplKCktMikpLHQuZXF1YWxzKGUpP251bGw6dm9pZCB0aGlzLnB0TGlzdC5hZGQodCl9LHNldE1pbmltdW1WZXJ0ZXhEaXN0YW5jZTpmdW5jdGlvbih0KXt0aGlzLm1pbmltaW1WZXJ0ZXhEaXN0YW5jZT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVaX19KSxVaS5DT09SRElOQVRFX0FSUkFZX1RZUEU9bmV3IEFycmF5KDApLmZpbGwobnVsbCksZShYaS5wcm90b3R5cGUse2FkZE5leHRTZWdtZW50OmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5zMD10aGlzLnMxLHRoaXMuczE9dGhpcy5zMix0aGlzLnMyPXQsdGhpcy5zZWcwLnNldENvb3JkaW5hdGVzKHRoaXMuczAsdGhpcy5zMSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLnNlZzAsdGhpcy5zaWRlLHRoaXMuZGlzdGFuY2UsdGhpcy5vZmZzZXQwKSx0aGlzLnNlZzEuc2V0Q29vcmRpbmF0ZXModGhpcy5zMSx0aGlzLnMyKSx0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KHRoaXMuc2VnMSx0aGlzLnNpZGUsdGhpcy5kaXN0YW5jZSx0aGlzLm9mZnNldDEpLHRoaXMuczEuZXF1YWxzKHRoaXMuczIpKXJldHVybiBudWxsO3ZhciBuPWhlLmNvbXB1dGVPcmllbnRhdGlvbih0aGlzLnMwLHRoaXMuczEsdGhpcy5zMiksaT1uPT09aGUuQ0xPQ0tXSVNFJiZ0aGlzLnNpZGU9PT1jbi5MRUZUfHxuPT09aGUuQ09VTlRFUkNMT0NLV0lTRSYmdGhpcy5zaWRlPT09Y24uUklHSFQ7MD09PW4/dGhpcy5hZGRDb2xsaW5lYXIoZSk6aT90aGlzLmFkZE91dHNpZGVUdXJuKG4sZSk6dGhpcy5hZGRJbnNpZGVUdXJuKG4sZSl9LGFkZExpbmVFbmRDYXA6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgY2UodCxlKSxpPW5ldyBjZTt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sY24uTEVGVCx0aGlzLmRpc3RhbmNlLGkpO3ZhciByPW5ldyBjZTt0aGlzLmNvbXB1dGVPZmZzZXRTZWdtZW50KG4sY24uUklHSFQsdGhpcy5kaXN0YW5jZSxyKTt2YXIgcz1lLngtdC54LG89ZS55LXQueSxhPU1hdGguYXRhbjIobyxzKTtzd2l0Y2godGhpcy5idWZQYXJhbXMuZ2V0RW5kQ2FwU3R5bGUoKSl7Y2FzZSBCaS5DQVBfUk9VTkQ6dGhpcy5zZWdMaXN0LmFkZFB0KGkucDEpLHRoaXMuYWRkRmlsbGV0QXJjKGUsYStNYXRoLlBJLzIsYS1NYXRoLlBJLzIsaGUuQ0xPQ0tXSVNFLHRoaXMuZGlzdGFuY2UpLHRoaXMuc2VnTGlzdC5hZGRQdChyLnAxKTticmVhaztjYXNlIEJpLkNBUF9GTEFUOnRoaXMuc2VnTGlzdC5hZGRQdChpLnAxKSx0aGlzLnNlZ0xpc3QuYWRkUHQoci5wMSk7YnJlYWs7Y2FzZSBCaS5DQVBfU1FVQVJFOnZhciB1PW5ldyBnO3UueD1NYXRoLmFicyh0aGlzLmRpc3RhbmNlKSpNYXRoLmNvcyhhKSx1Lnk9TWF0aC5hYnModGhpcy5kaXN0YW5jZSkqTWF0aC5zaW4oYSk7dmFyIGw9bmV3IGcoaS5wMS54K3UueCxpLnAxLnkrdS55KSxoPW5ldyBnKHIucDEueCt1Lngsci5wMS55K3UueSk7dGhpcy5zZWdMaXN0LmFkZFB0KGwpLHRoaXMuc2VnTGlzdC5hZGRQdChoKX19LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5zZWdMaXN0LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHR9LGFkZE1pdHJlSm9pbjpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj0hMCxzPW51bGw7dHJ5e3M9Ri5pbnRlcnNlY3Rpb24oZS5wMCxlLnAxLG4ucDAsbi5wMSk7dmFyIG89MD49aT8xOnMuZGlzdGFuY2UodCkvTWF0aC5hYnMoaSk7bz50aGlzLmJ1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkmJihyPSExKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiB3KSl0aHJvdyB0O3M9bmV3IGcoMCwwKSxyPSExfWZpbmFsbHl7fXI/dGhpcy5zZWdMaXN0LmFkZFB0KHMpOnRoaXMuYWRkTGltaXRlZE1pdHJlSm9pbihlLG4saSx0aGlzLmJ1ZlBhcmFtcy5nZXRNaXRyZUxpbWl0KCkpfSxhZGRGaWxsZXRDb3JuZXI6ZnVuY3Rpb24odCxlLG4saSxyKXt2YXIgcz1lLngtdC54LG89ZS55LXQueSxhPU1hdGguYXRhbjIobyxzKSx1PW4ueC10LngsbD1uLnktdC55LGg9TWF0aC5hdGFuMihsLHUpO2k9PT1oZS5DTE9DS1dJU0U/aD49YSYmKGErPTIqTWF0aC5QSSk6YT49aCYmKGEtPTIqTWF0aC5QSSksdGhpcy5zZWdMaXN0LmFkZFB0KGUpLHRoaXMuYWRkRmlsbGV0QXJjKHQsYSxoLGksciksdGhpcy5zZWdMaXN0LmFkZFB0KG4pfSxhZGRPdXRzaWRlVHVybjpmdW5jdGlvbih0LGUpe3JldHVybiB0aGlzLm9mZnNldDAucDEuZGlzdGFuY2UodGhpcy5vZmZzZXQxLnAwKTx0aGlzLmRpc3RhbmNlKlhpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPyh0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKSxudWxsKTp2b2lkKHRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9NSVRSRT90aGlzLmFkZE1pdHJlSm9pbih0aGlzLnMxLHRoaXMub2Zmc2V0MCx0aGlzLm9mZnNldDEsdGhpcy5kaXN0YW5jZSk6dGhpcy5idWZQYXJhbXMuZ2V0Sm9pblN0eWxlKCk9PT1CaS5KT0lOX0JFVkVMP3RoaXMuYWRkQmV2ZWxKb2luKHRoaXMub2Zmc2V0MCx0aGlzLm9mZnNldDEpOihlJiZ0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQwLnAxKSx0aGlzLmFkZEZpbGxldENvcm5lcih0aGlzLnMxLHRoaXMub2Zmc2V0MC5wMSx0aGlzLm9mZnNldDEucDAsdCx0aGlzLmRpc3RhbmNlKSx0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAwKSkpfSxjcmVhdGVTcXVhcmU6ZnVuY3Rpb24odCl7dGhpcy5zZWdMaXN0LmFkZFB0KG5ldyBnKHQueCt0aGlzLmRpc3RhbmNlLHQueSt0aGlzLmRpc3RhbmNlKSksdGhpcy5zZWdMaXN0LmFkZFB0KG5ldyBnKHQueCt0aGlzLmRpc3RhbmNlLHQueS10aGlzLmRpc3RhbmNlKSksdGhpcy5zZWdMaXN0LmFkZFB0KG5ldyBnKHQueC10aGlzLmRpc3RhbmNlLHQueS10aGlzLmRpc3RhbmNlKSksdGhpcy5zZWdMaXN0LmFkZFB0KG5ldyBnKHQueC10aGlzLmRpc3RhbmNlLHQueSt0aGlzLmRpc3RhbmNlKSksdGhpcy5zZWdMaXN0LmNsb3NlUmluZygpfSxhZGRTZWdtZW50czpmdW5jdGlvbih0LGUpe3RoaXMuc2VnTGlzdC5hZGRQdHModCxlKX0sYWRkRmlyc3RTZWdtZW50OmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCl9LGFkZExhc3RTZWdtZW50OmZ1bmN0aW9uKCl7dGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMSl9LGluaXRTaWRlU2VnbWVudHM6ZnVuY3Rpb24odCxlLG4pe3RoaXMuczE9dCx0aGlzLnMyPWUsdGhpcy5zaWRlPW4sdGhpcy5zZWcxLnNldENvb3JkaW5hdGVzKHQsZSksdGhpcy5jb21wdXRlT2Zmc2V0U2VnbWVudCh0aGlzLnNlZzEsbix0aGlzLmRpc3RhbmNlLHRoaXMub2Zmc2V0MSl9LGFkZExpbWl0ZWRNaXRyZUpvaW46ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9dGhpcy5zZWcwLnAxLHM9aGkuYW5nbGUocix0aGlzLnNlZzAucDApLG89KGhpLmFuZ2xlKHIsdGhpcy5zZWcxLnAxKSxoaS5hbmdsZUJldHdlZW5PcmllbnRlZCh0aGlzLnNlZzAucDAscix0aGlzLnNlZzEucDEpKSxhPW8vMix1PWhpLm5vcm1hbGl6ZShzK2EpLGw9aGkubm9ybWFsaXplKHUrTWF0aC5QSSksaD1pKm4sYz1oKk1hdGguYWJzKE1hdGguc2luKGEpKSxmPW4tYyxkPXIueCtoKk1hdGguY29zKGwpLHA9ci55K2gqTWF0aC5zaW4obCksdj1uZXcgZyhkLHApLG09bmV3IGNlKHIsdikseT1tLnBvaW50QWxvbmdPZmZzZXQoMSxmKSx4PW0ucG9pbnRBbG9uZ09mZnNldCgxLC1mKTt0aGlzLnNpZGU9PT1jbi5MRUZUPyh0aGlzLnNlZ0xpc3QuYWRkUHQoeSksdGhpcy5zZWdMaXN0LmFkZFB0KHgpKToodGhpcy5zZWdMaXN0LmFkZFB0KHgpLHRoaXMuc2VnTGlzdC5hZGRQdCh5KSl9LGNvbXB1dGVPZmZzZXRTZWdtZW50OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPWU9PT1jbi5MRUZUPzE6LTEscz10LnAxLngtdC5wMC54LG89dC5wMS55LXQucDAueSxhPU1hdGguc3FydChzKnMrbypvKSx1PXIqbipzL2EsbD1yKm4qby9hO2kucDAueD10LnAwLngtbCxpLnAwLnk9dC5wMC55K3UsaS5wMS54PXQucDEueC1sLGkucDEueT10LnAxLnkrdX0sYWRkRmlsbGV0QXJjOmZ1bmN0aW9uKHQsZSxuLGkscil7dmFyIHM9aT09PWhlLkNMT0NLV0lTRT8tMToxLG89TWF0aC5hYnMoZS1uKSxhPU1hdGgudHJ1bmMoby90aGlzLmZpbGxldEFuZ2xlUXVhbnR1bSsuNSk7aWYoMT5hKXJldHVybiBudWxsO3ZhciB1PW51bGwsbD1udWxsO3U9MCxsPW8vYTtmb3IodmFyIGg9dSxjPW5ldyBnO28+aDspe3ZhciBmPWUrcypoO2MueD10LngrcipNYXRoLmNvcyhmKSxjLnk9dC55K3IqTWF0aC5zaW4oZiksdGhpcy5zZWdMaXN0LmFkZFB0KGMpLGgrPWx9fSxhZGRJbnNpZGVUdXJuOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHRoaXMub2Zmc2V0MC5wMCx0aGlzLm9mZnNldDAucDEsdGhpcy5vZmZzZXQxLnAwLHRoaXMub2Zmc2V0MS5wMSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSl0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5saS5nZXRJbnRlcnNlY3Rpb24oMCkpO2Vsc2UgaWYodGhpcy5faGFzTmFycm93Q29uY2F2ZUFuZ2xlPSEwLHRoaXMub2Zmc2V0MC5wMS5kaXN0YW5jZSh0aGlzLm9mZnNldDEucDApPHRoaXMuZGlzdGFuY2UqWGkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKXRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLm9mZnNldDAucDEpO2Vsc2V7aWYodGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksdGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yPjApe3ZhciBuPW5ldyBnKCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQwLnAxLngrdGhpcy5zMS54KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpLCh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IqdGhpcy5vZmZzZXQwLnAxLnkrdGhpcy5zMS55KS8odGhpcy5jbG9zaW5nU2VnTGVuZ3RoRmFjdG9yKzEpKTt0aGlzLnNlZ0xpc3QuYWRkUHQobik7dmFyIGk9bmV3IGcoKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLm9mZnNldDEucDAueCt0aGlzLnMxLngpLyh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSksKHRoaXMuY2xvc2luZ1NlZ0xlbmd0aEZhY3Rvcip0aGlzLm9mZnNldDEucDAueSt0aGlzLnMxLnkpLyh0aGlzLmNsb3NpbmdTZWdMZW5ndGhGYWN0b3IrMSkpO3RoaXMuc2VnTGlzdC5hZGRQdChpKX1lbHNlIHRoaXMuc2VnTGlzdC5hZGRQdCh0aGlzLnMxKTt0aGlzLnNlZ0xpc3QuYWRkUHQodGhpcy5vZmZzZXQxLnAwKX19LGNyZWF0ZUNpcmNsZTpmdW5jdGlvbih0KXt2YXIgZT1uZXcgZyh0LngrdGhpcy5kaXN0YW5jZSx0LnkpO3RoaXMuc2VnTGlzdC5hZGRQdChlKSx0aGlzLmFkZEZpbGxldEFyYyh0LDAsMipNYXRoLlBJLC0xLHRoaXMuZGlzdGFuY2UpLHRoaXMuc2VnTGlzdC5jbG9zZVJpbmcoKX0sYWRkQmV2ZWxKb2luOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWdMaXN0LmFkZFB0KHQucDEpLHRoaXMuc2VnTGlzdC5hZGRQdChlLnAwKX0saW5pdDpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlPXQsdGhpcy5tYXhDdXJ2ZVNlZ21lbnRFcnJvcj10KigxLU1hdGguY29zKHRoaXMuZmlsbGV0QW5nbGVRdWFudHVtLzIpKSx0aGlzLnNlZ0xpc3Q9bmV3IFVpLHRoaXMuc2VnTGlzdC5zZXRQcmVjaXNpb25Nb2RlbCh0aGlzLnByZWNpc2lvbk1vZGVsKSx0aGlzLnNlZ0xpc3Quc2V0TWluaW11bVZlcnRleERpc3RhbmNlKHQqWGkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SKX0sYWRkQ29sbGluZWFyOmZ1bmN0aW9uKHQpe3RoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0aGlzLnMwLHRoaXMuczEsdGhpcy5zMSx0aGlzLnMyKTt2YXIgZT10aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpO2U+PTImJih0aGlzLmJ1ZlBhcmFtcy5nZXRKb2luU3R5bGUoKT09PUJpLkpPSU5fQkVWRUx8fHRoaXMuYnVmUGFyYW1zLmdldEpvaW5TdHlsZSgpPT09QmkuSk9JTl9NSVRSRT8odCYmdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MC5wMSksdGhpcy5zZWdMaXN0LmFkZFB0KHRoaXMub2Zmc2V0MS5wMCkpOnRoaXMuYWRkRmlsbGV0Q29ybmVyKHRoaXMuczEsdGhpcy5vZmZzZXQwLnAxLHRoaXMub2Zmc2V0MS5wMCxoZS5DTE9DS1dJU0UsdGhpcy5kaXN0YW5jZSkpfSxjbG9zZVJpbmc6ZnVuY3Rpb24oKXt0aGlzLnNlZ0xpc3QuY2xvc2VSaW5nKCl9LGhhc05hcnJvd0NvbmNhdmVBbmdsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9oYXNOYXJyb3dDb25jYXZlQW5nbGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFhpfX0pLFhpLk9GRlNFVF9TRUdNRU5UX1NFUEFSQVRJT05fRkFDVE9SPS4wMDEsWGkuSU5TSURFX1RVUk5fVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPS4wMDEsWGkuQ1VSVkVfVkVSVEVYX1NOQVBfRElTVEFOQ0VfRkFDVE9SPTFlLTYsWGkuTUFYX0NMT1NJTkdfU0VHX0xFTl9GQUNUT1I9ODAsZShIaS5wcm90b3R5cGUse2dldE9mZnNldEN1cnZlOmZ1bmN0aW9uKHQsZSl7aWYodGhpcy5kaXN0YW5jZT1lLDA9PT1lKXJldHVybiBudWxsO3ZhciBuPTA+ZSxpPU1hdGguYWJzKGUpLHI9dGhpcy5nZXRTZWdHZW4oaSk7dC5sZW5ndGg8PTE/dGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLHIpOnRoaXMuY29tcHV0ZU9mZnNldEN1cnZlKHQsbixyKTt2YXIgcz1yLmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIG4mJkgucmV2ZXJzZShzKSxzfSxjb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dGhpcy5zaW1wbGlmeVRvbGVyYW5jZSh0aGlzLmRpc3RhbmNlKTtpZihlKXtuLmFkZFNlZ21lbnRzKHQsITApO3ZhciByPVlpLnNpbXBsaWZ5KHQsLWkpLHM9ci5sZW5ndGgtMTtuLmluaXRTaWRlU2VnbWVudHMocltzXSxyW3MtMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89cy0yO28+PTA7by0tKW4uYWRkTmV4dFNlZ21lbnQocltvXSwhMCl9ZWxzZXtuLmFkZFNlZ21lbnRzKHQsITEpO3ZhciBhPVlpLnNpbXBsaWZ5KHQsaSksdT1hLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhhWzBdLGFbMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89Mjt1Pj1vO28rKyluLmFkZE5leHRTZWdtZW50KGFbb10sITApfW4uYWRkTGFzdFNlZ21lbnQoKSxuLmNsb3NlUmluZygpfSxjb21wdXRlUmluZ0J1ZmZlckN1cnZlOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpO2U9PT1jbi5SSUdIVCYmKGk9LWkpO3ZhciByPVlpLnNpbXBsaWZ5KHQsaSkscz1yLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhyW3MtMV0sclswXSxlKTtmb3IodmFyIG89MTtzPj1vO28rKyl7dmFyIGE9MSE9PW87bi5hZGROZXh0U2VnbWVudChyW29dLGEpfW4uY2xvc2VSaW5nKCl9LGNvbXB1dGVMaW5lQnVmZmVyQ3VydmU6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLnNpbXBsaWZ5VG9sZXJhbmNlKHRoaXMuZGlzdGFuY2UpLGk9WWkuc2ltcGxpZnkodCxuKSxyPWkubGVuZ3RoLTE7ZS5pbml0U2lkZVNlZ21lbnRzKGlbMF0saVsxXSxjbi5MRUZUKTtmb3IodmFyIHM9MjtyPj1zO3MrKyllLmFkZE5leHRTZWdtZW50KGlbc10sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAoaVtyLTFdLGlbcl0pO3ZhciBvPVlpLnNpbXBsaWZ5KHQsLW4pLGE9by5sZW5ndGgtMTtlLmluaXRTaWRlU2VnbWVudHMob1thXSxvW2EtMV0sY24uTEVGVCk7Zm9yKHZhciBzPWEtMjtzPj0wO3MtLSllLmFkZE5leHRTZWdtZW50KG9bc10sITApO2UuYWRkTGFzdFNlZ21lbnQoKSxlLmFkZExpbmVFbmRDYXAob1sxXSxvWzBdKSxlLmNsb3NlUmluZygpfSxjb21wdXRlUG9pbnRDdXJ2ZTpmdW5jdGlvbih0LGUpe3N3aXRjaCh0aGlzLmJ1ZlBhcmFtcy5nZXRFbmRDYXBTdHlsZSgpKXtjYXNlIEJpLkNBUF9ST1VORDplLmNyZWF0ZUNpcmNsZSh0KTticmVhaztjYXNlIEJpLkNBUF9TUVVBUkU6ZS5jcmVhdGVTcXVhcmUodCl9fSxnZXRMaW5lQ3VydmU6ZnVuY3Rpb24odCxlKXtpZih0aGlzLmRpc3RhbmNlPWUsMD5lJiYhdGhpcy5idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXJldHVybiBudWxsO2lmKDA9PT1lKXJldHVybiBudWxsO3ZhciBuPU1hdGguYWJzKGUpLGk9dGhpcy5nZXRTZWdHZW4obik7aWYodC5sZW5ndGg8PTEpdGhpcy5jb21wdXRlUG9pbnRDdXJ2ZSh0WzBdLGkpO2Vsc2UgaWYodGhpcy5idWZQYXJhbXMuaXNTaW5nbGVTaWRlZCgpKXt2YXIgcj0wPmU7dGhpcy5jb21wdXRlU2luZ2xlU2lkZWRCdWZmZXJDdXJ2ZSh0LHIsaSl9ZWxzZSB0aGlzLmNvbXB1dGVMaW5lQnVmZmVyQ3VydmUodCxpKTt2YXIgcz1pLmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIHN9LGdldEJ1ZmZlclBhcmFtZXRlcnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5idWZQYXJhbXN9LHNpbXBsaWZ5VG9sZXJhbmNlOmZ1bmN0aW9uKHQpe3JldHVybiB0KnRoaXMuYnVmUGFyYW1zLmdldFNpbXBsaWZ5RmFjdG9yKCl9LGdldFJpbmdDdXJ2ZTpmdW5jdGlvbih0LGUsbil7aWYodGhpcy5kaXN0YW5jZT1uLHQubGVuZ3RoPD0yKXJldHVybiB0aGlzLmdldExpbmVDdXJ2ZSh0LG4pO2lmKDA9PT1uKXJldHVybiBIaS5jb3B5Q29vcmRpbmF0ZXModCk7dmFyIGk9dGhpcy5nZXRTZWdHZW4obik7cmV0dXJuIHRoaXMuY29tcHV0ZVJpbmdCdWZmZXJDdXJ2ZSh0LGUsaSksaS5nZXRDb29yZGluYXRlcygpfSxjb21wdXRlT2Zmc2V0Q3VydmU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXRoaXMuc2ltcGxpZnlUb2xlcmFuY2UodGhpcy5kaXN0YW5jZSk7aWYoZSl7dmFyIHI9WWkuc2ltcGxpZnkodCwtaSkscz1yLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhyW3NdLHJbcy0xXSxjbi5MRUZUKSxuLmFkZEZpcnN0U2VnbWVudCgpO2Zvcih2YXIgbz1zLTI7bz49MDtvLS0pbi5hZGROZXh0U2VnbWVudChyW29dLCEwKX1lbHNle3ZhciBhPVlpLnNpbXBsaWZ5KHQsaSksdT1hLmxlbmd0aC0xO24uaW5pdFNpZGVTZWdtZW50cyhhWzBdLGFbMV0sY24uTEVGVCksbi5hZGRGaXJzdFNlZ21lbnQoKTtmb3IodmFyIG89Mjt1Pj1vO28rKyluLmFkZE5leHRTZWdtZW50KGFbb10sITApfW4uYWRkTGFzdFNlZ21lbnQoKX0sZ2V0U2VnR2VuOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgWGkodGhpcy5wcmVjaXNpb25Nb2RlbCx0aGlzLmJ1ZlBhcmFtcyx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSGl9fSksSGkuY29weUNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksbj0wO248ZS5sZW5ndGg7bisrKWVbbl09bmV3IGcodFtuXSk7cmV0dXJuIGV9LGUoV2kucHJvdG90eXBlLHtmaW5kU3RhYmJlZFNlZ21lbnRzOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgSSxuPXRoaXMuc3ViZ3JhcGhzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPWkuZ2V0RW52ZWxvcGUoKTt0Lnk8ci5nZXRNaW5ZKCl8fHQueT5yLmdldE1heFkoKXx8dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQsaS5nZXREaXJlY3RlZEVkZ2VzKCksZSl9cmV0dXJuIGV9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoUihhcmd1bWVudHNbMl0seSkmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBJbilmb3IodmFyIHM9YXJndW1lbnRzWzBdLG89YXJndW1lbnRzWzFdLGE9YXJndW1lbnRzWzJdLHU9by5nZXRFZGdlKCkuZ2V0Q29vcmRpbmF0ZXMoKSxuPTA7bjx1Lmxlbmd0aC0xO24rKyl7dGhpcy5zZWcucDA9dVtuXSx0aGlzLnNlZy5wMT11W24rMV0sdGhpcy5zZWcucDAueT50aGlzLnNlZy5wMS55JiZ0aGlzLnNlZy5yZXZlcnNlKCk7dmFyIGw9TWF0aC5tYXgodGhpcy5zZWcucDAueCx0aGlzLnNlZy5wMS54KTtpZighKGw8cy54fHx0aGlzLnNlZy5pc0hvcml6b250YWwoKXx8cy55PHRoaXMuc2VnLnAwLnl8fHMueT50aGlzLnNlZy5wMS55fHxoZS5jb21wdXRlT3JpZW50YXRpb24odGhpcy5zZWcucDAsdGhpcy5zZWcucDEscyk9PT1oZS5SSUdIVCkpe3ZhciBoPW8uZ2V0RGVwdGgoY24uTEVGVCk7dGhpcy5zZWcucDAuZXF1YWxzKHVbbl0pfHwoaD1vLmdldERlcHRoKGNuLlJJR0hUKSk7dmFyIGM9bmV3IGppKHRoaXMuc2VnLGgpO2EuYWRkKGMpfX1lbHNlIGlmKFIoYXJndW1lbnRzWzJdLHkpJiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcmJlIoYXJndW1lbnRzWzFdLHkpKWZvcih2YXIgZj1hcmd1bWVudHNbMF0sZD1hcmd1bWVudHNbMV0scD1hcmd1bWVudHNbMl0sbj1kLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgdj1uLm5leHQoKTt2LmlzRm9yd2FyZCgpJiZ0aGlzLmZpbmRTdGFiYmVkU2VnbWVudHMoZix2LHApfX0sZ2V0RGVwdGg6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5maW5kU3RhYmJlZFNlZ21lbnRzKHQpO2lmKDA9PT1lLnNpemUoKSlyZXR1cm4gMDt2YXIgbj1oby5taW4oZSk7cmV0dXJuIG4ubGVmdERlcHRofSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXaX19KSxlKGppLnByb3RvdHlwZSx7Y29tcGFyZVRvOmZ1bmN0aW9uKHQpe3ZhciBlPXQ7aWYodGhpcy51cHdhcmRTZWcubWluWCgpPj1lLnVwd2FyZFNlZy5tYXhYKCkpcmV0dXJuIDE7aWYodGhpcy51cHdhcmRTZWcubWF4WCgpPD1lLnVwd2FyZFNlZy5taW5YKCkpcmV0dXJuLTE7dmFyIG49dGhpcy51cHdhcmRTZWcub3JpZW50YXRpb25JbmRleChlLnVwd2FyZFNlZyk7cmV0dXJuIDAhPT1uP246KG49LTEqZS51cHdhcmRTZWcub3JpZW50YXRpb25JbmRleCh0aGlzLnVwd2FyZFNlZyksMCE9PW4/bjp0aGlzLnVwd2FyZFNlZy5jb21wYXJlVG8oZS51cHdhcmRTZWcpKX0sY29tcGFyZVg6ZnVuY3Rpb24odCxlKXt2YXIgbj10LnAwLmNvbXBhcmVUbyhlLnAwKTtyZXR1cm4gMCE9PW4/bjp0LnAxLmNvbXBhcmVUbyhlLnAxKX0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy51cHdhcmRTZWcudG9TdHJpbmcoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGppfX0pLFdpLkRlcHRoU2VnbWVudD1qaSxlKEtpLnByb3RvdHlwZSx7YWRkUG9pbnQ6ZnVuY3Rpb24odCl7aWYodGhpcy5kaXN0YW5jZTw9MClyZXR1cm4gbnVsbDtcbnZhciBlPXQuZ2V0Q29vcmRpbmF0ZXMoKSxuPXRoaXMuY3VydmVCdWlsZGVyLmdldExpbmVDdXJ2ZShlLHRoaXMuZGlzdGFuY2UpO3RoaXMuYWRkQ3VydmUobixMLkVYVEVSSU9SLEwuSU5URVJJT1IpfSxhZGRQb2x5Z29uOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZGlzdGFuY2Usbj1jbi5MRUZUO3RoaXMuZGlzdGFuY2U8MCYmKGU9LXRoaXMuZGlzdGFuY2Usbj1jbi5SSUdIVCk7dmFyIGk9dC5nZXRFeHRlcmlvclJpbmcoKSxyPUgucmVtb3ZlUmVwZWF0ZWRQb2ludHMoaS5nZXRDb29yZGluYXRlcygpKTtpZih0aGlzLmRpc3RhbmNlPDAmJnRoaXMuaXNFcm9kZWRDb21wbGV0ZWx5KGksdGhpcy5kaXN0YW5jZSkpcmV0dXJuIG51bGw7aWYodGhpcy5kaXN0YW5jZTw9MCYmci5sZW5ndGg8MylyZXR1cm4gbnVsbDt0aGlzLmFkZFBvbHlnb25SaW5nKHIsZSxuLEwuRVhURVJJT1IsTC5JTlRFUklPUik7Zm9yKHZhciBzPTA7czx0LmdldE51bUludGVyaW9yUmluZygpO3MrKyl7dmFyIG89dC5nZXRJbnRlcmlvclJpbmdOKHMpLGE9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyhvLmdldENvb3JkaW5hdGVzKCkpO3RoaXMuZGlzdGFuY2U+MCYmdGhpcy5pc0Vyb2RlZENvbXBsZXRlbHkobywtdGhpcy5kaXN0YW5jZSl8fHRoaXMuYWRkUG9seWdvblJpbmcoYSxlLGNuLm9wcG9zaXRlKG4pLEwuSU5URVJJT1IsTC5FWFRFUklPUil9fSxpc1RyaWFuZ2xlRXJvZGVkQ29tcGxldGVseTpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBjaSh0WzBdLHRbMV0sdFsyXSksaT1uLmluQ2VudHJlKCkscj1oZS5kaXN0YW5jZVBvaW50TGluZShpLG4ucDAsbi5wMSk7cmV0dXJuIHI8TWF0aC5hYnMoZSl9LGFkZExpbmVTdHJpbmc6ZnVuY3Rpb24odCl7aWYodGhpcy5kaXN0YW5jZTw9MCYmIXRoaXMuY3VydmVCdWlsZGVyLmdldEJ1ZmZlclBhcmFtZXRlcnMoKS5pc1NpbmdsZVNpZGVkKCkpcmV0dXJuIG51bGw7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpLG49dGhpcy5jdXJ2ZUJ1aWxkZXIuZ2V0TGluZUN1cnZlKGUsdGhpcy5kaXN0YW5jZSk7dGhpcy5hZGRDdXJ2ZShuLEwuRVhURVJJT1IsTC5JTlRFUklPUil9LGFkZEN1cnZlOmZ1bmN0aW9uKHQsZSxuKXtpZihudWxsPT09dHx8dC5sZW5ndGg8MilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgS2UodCxuZXcgZ24oMCxMLkJPVU5EQVJZLGUsbikpO3RoaXMuY3VydmVMaXN0LmFkZChpKX0sZ2V0Q3VydmVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuYWRkKHRoaXMuaW5wdXRHZW9tKSx0aGlzLmN1cnZlTGlzdH0sYWRkUG9seWdvblJpbmc6ZnVuY3Rpb24odCxlLG4saSxyKXtpZigwPT09ZSYmdC5sZW5ndGg8YnQuTUlOSU1VTV9WQUxJRF9TSVpFKXJldHVybiBudWxsO3ZhciBzPWksbz1yO3QubGVuZ3RoPj1idC5NSU5JTVVNX1ZBTElEX1NJWkUmJmhlLmlzQ0NXKHQpJiYocz1yLG89aSxuPWNuLm9wcG9zaXRlKG4pKTt2YXIgYT10aGlzLmN1cnZlQnVpbGRlci5nZXRSaW5nQ3VydmUodCxuLGUpO3RoaXMuYWRkQ3VydmUoYSxzLG8pfSxhZGQ6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7aWYodCBpbnN0YW5jZW9mIFR0KXRoaXMuYWRkUG9seWdvbih0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBTdCl0aGlzLmFkZExpbmVTdHJpbmcodCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgTHQpdGhpcy5hZGRQb2ludCh0KTtlbHNlIGlmKHQgaW5zdGFuY2VvZiBQdCl0aGlzLmFkZENvbGxlY3Rpb24odCk7ZWxzZSBpZih0IGluc3RhbmNlb2YgZ3QpdGhpcy5hZGRDb2xsZWN0aW9uKHQpO2Vsc2UgaWYodCBpbnN0YW5jZW9mIE90KXRoaXMuYWRkQ29sbGVjdGlvbih0KTtlbHNle2lmKCEodCBpbnN0YW5jZW9mIGZ0KSl0aHJvdyBuZXcgVW5zdXBwb3J0ZWRPcGVyYXRpb25FeGNlcHRpb24odC5nZXRDbGFzcygpLmdldE5hbWUoKSk7dGhpcy5hZGRDb2xsZWN0aW9uKHQpfX0saXNFcm9kZWRDb21wbGV0ZWx5OmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRDb29yZGluYXRlcygpO2lmKG4ubGVuZ3RoPDQpcmV0dXJuIDA+ZTtpZig0PT09bi5sZW5ndGgpcmV0dXJuIHRoaXMuaXNUcmlhbmdsZUVyb2RlZENvbXBsZXRlbHkobixlKTt2YXIgaT10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxyPU1hdGgubWluKGkuZ2V0SGVpZ2h0KCksaS5nZXRXaWR0aCgpKTtyZXR1cm4gMD5lJiYyKk1hdGguYWJzKGUpPnJ9LGFkZENvbGxlY3Rpb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO3RoaXMuYWRkKG4pfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gS2l9fSksZShaaS5wcm90b3R5cGUse2lzVHJpdmlhbEludGVyc2VjdGlvbjpmdW5jdGlvbih0LGUsbixpKXtpZih0PT09biYmMT09PXRoaXMubGkuZ2V0SW50ZXJzZWN0aW9uTnVtKCkpe2lmKFppLmlzQWRqYWNlbnRTZWdtZW50cyhlLGkpKXJldHVybiEwO2lmKHQuaXNDbG9zZWQoKSl7dmFyIHI9dC5zaXplKCktMTtpZigwPT09ZSYmaT09PXJ8fDA9PT1pJiZlPT09cilyZXR1cm4hMH19cmV0dXJuITF9LGdldFByb3BlckludGVyc2VjdGlvblBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHJvcGVySW50ZXJzZWN0aW9uUG9pbnR9LGhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzUHJvcGVySW50ZXJpb3J9LGdldExpbmVJbnRlcnNlY3RvcjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpfSxoYXNQcm9wZXJJbnRlcnNlY3Rpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNQcm9wZXJ9LHByb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDt0aGlzLm51bVRlc3RzKys7dmFyIHI9dC5nZXRDb29yZGluYXRlcygpW2VdLHM9dC5nZXRDb29yZGluYXRlcygpW2UrMV0sbz1uLmdldENvb3JkaW5hdGVzKClbaV0sYT1uLmdldENvb3JkaW5hdGVzKClbaSsxXTt0aGlzLmxpLmNvbXB1dGVJbnRlcnNlY3Rpb24ocixzLG8sYSksdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSYmKHRoaXMubnVtSW50ZXJzZWN0aW9ucysrLHRoaXMubGkuaXNJbnRlcmlvckludGVyc2VjdGlvbigpJiYodGhpcy5udW1JbnRlcmlvckludGVyc2VjdGlvbnMrKyx0aGlzLmhhc0ludGVyaW9yPSEwKSx0aGlzLmlzVHJpdmlhbEludGVyc2VjdGlvbih0LGUsbixpKXx8KHRoaXMuX2hhc0ludGVyc2VjdGlvbj0hMCx0LmFkZEludGVyc2VjdGlvbnModGhpcy5saSxlLDApLG4uYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGksMSksdGhpcy5saS5pc1Byb3BlcigpJiYodGhpcy5udW1Qcm9wZXJJbnRlcnNlY3Rpb25zKyssdGhpcy5oYXNQcm9wZXI9ITAsdGhpcy5oYXNQcm9wZXJJbnRlcmlvcj0hMCkpKX0saGFzSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2hhc0ludGVyc2VjdGlvbn0saXNEb25lOmZ1bmN0aW9uKCl7cmV0dXJuITF9LGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaGFzSW50ZXJpb3J9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29uXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWml9fSksWmkuaXNBZGphY2VudFNlZ21lbnRzPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIDE9PT1NYXRoLmFicyh0LWUpfSxlKFFpLnByb3RvdHlwZSx7c2V0V29ya2luZ1ByZWNpc2lvbk1vZGVsOmZ1bmN0aW9uKHQpe3RoaXMud29ya2luZ1ByZWNpc2lvbk1vZGVsPXR9LGluc2VydFVuaXF1ZUVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5lZGdlTGlzdC5maW5kRXF1YWxFZGdlKHQpO2lmKG51bGwhPT1lKXt2YXIgbj1lLmdldExhYmVsKCksaT10LmdldExhYmVsKCk7ZS5pc1BvaW50d2lzZUVxdWFsKHQpfHwoaT1uZXcgZ24odC5nZXRMYWJlbCgpKSxpLmZsaXAoKSksbi5tZXJnZShpKTt2YXIgcj1RaS5kZXB0aERlbHRhKGkpLHM9ZS5nZXREZXB0aERlbHRhKCksbz1zK3I7ZS5zZXREZXB0aERlbHRhKG8pfWVsc2UgdGhpcy5lZGdlTGlzdC5hZGQodCksdC5zZXREZXB0aERlbHRhKFFpLmRlcHRoRGVsdGEodC5nZXRMYWJlbCgpKSl9LGJ1aWxkU3ViZ3JhcGhzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCkscz1yLmdldFJpZ2h0bW9zdENvb3JkaW5hdGUoKSxvPW5ldyBXaShuKSxhPW8uZ2V0RGVwdGgocyk7ci5jb21wdXRlRGVwdGgoYSksci5maW5kUmVzdWx0RWRnZXMoKSxuLmFkZChyKSxlLmFkZChyLmdldERpcmVjdGVkRWRnZXMoKSxyLmdldE5vZGVzKCkpfX0sY3JlYXRlU3ViZ3JhcGhzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoIWkuaXNWaXNpdGVkKCkpe3ZhciByPW5ldyBraTtyLmNyZWF0ZShpKSxlLmFkZChyKX19cmV0dXJuIGhvLnNvcnQoZSxoby5yZXZlcnNlT3JkZXIoKSksZX0sY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2VvbUZhY3QuY3JlYXRlUG9seWdvbigpO3JldHVybiB0fSxnZXROb2RlcjpmdW5jdGlvbih0KXtpZihudWxsIT09dGhpcy53b3JraW5nTm9kZXIpcmV0dXJuIHRoaXMud29ya2luZ05vZGVyO3ZhciBlPW5ldyBubixuPW5ldyBhZTtyZXR1cm4gbi5zZXRQcmVjaXNpb25Nb2RlbCh0KSxlLnNldFNlZ21lbnRJbnRlcnNlY3RvcihuZXcgWmkobikpLGV9LGJ1ZmZlcjpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMud29ya2luZ1ByZWNpc2lvbk1vZGVsO251bGw9PT1uJiYobj10LmdldFByZWNpc2lvbk1vZGVsKCkpLHRoaXMuZ2VvbUZhY3Q9dC5nZXRGYWN0b3J5KCk7dmFyIGk9bmV3IEhpKG4sdGhpcy5idWZQYXJhbXMpLHI9bmV3IEtpKHQsZSxpKSxzPXIuZ2V0Q3VydmVzKCk7aWYocy5zaXplKCk8PTApcmV0dXJuIHRoaXMuY3JlYXRlRW1wdHlSZXN1bHRHZW9tZXRyeSgpO3RoaXMuY29tcHV0ZU5vZGVkRWRnZXMocyxuKSx0aGlzLmdyYXBoPW5ldyBDbihuZXcgT24pLHRoaXMuZ3JhcGguYWRkRWRnZXModGhpcy5lZGdlTGlzdC5nZXRFZGdlcygpKTt2YXIgbz10aGlzLmNyZWF0ZVN1YmdyYXBocyh0aGlzLmdyYXBoKSxhPW5ldyBTbih0aGlzLmdlb21GYWN0KTt0aGlzLmJ1aWxkU3ViZ3JhcGhzKG8sYSk7dmFyIHU9YS5nZXRQb2x5Z29ucygpO2lmKHUuc2l6ZSgpPD0wKXJldHVybiB0aGlzLmNyZWF0ZUVtcHR5UmVzdWx0R2VvbWV0cnkoKTt2YXIgbD10aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkodSk7cmV0dXJuIGx9LGNvbXB1dGVOb2RlZEVkZ2VzOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5nZXROb2RlcihlKTtuLmNvbXB1dGVOb2Rlcyh0KTtmb3IodmFyIGk9bi5nZXROb2RlZFN1YnN0cmluZ3MoKSxyPWkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89cy5nZXRDb29yZGluYXRlcygpO2lmKDIhPT1vLmxlbmd0aHx8IW9bMF0uZXF1YWxzMkQob1sxXSkpe3ZhciBhPXMuZ2V0RGF0YSgpLHU9bmV3IEpuKHMuZ2V0Q29vcmRpbmF0ZXMoKSxuZXcgZ24oYSkpO3RoaXMuaW5zZXJ0VW5pcXVlRWRnZSh1KX19fSxzZXROb2RlcjpmdW5jdGlvbih0KXt0aGlzLndvcmtpbmdOb2Rlcj10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBRaX19KSxRaS5kZXB0aERlbHRhPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0TG9jYXRpb24oMCxjbi5MRUZUKSxuPXQuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk7cmV0dXJuIGU9PT1MLklOVEVSSU9SJiZuPT09TC5FWFRFUklPUj8xOmU9PT1MLkVYVEVSSU9SJiZuPT09TC5JTlRFUklPUj8tMTowfSxRaS5jb252ZXJ0U2VnU3RyaW5ncz1mdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IGllLG49bmV3IEk7dC5oYXNOZXh0KCk7KXt2YXIgaT10Lm5leHQoKSxyPWUuY3JlYXRlTGluZVN0cmluZyhpLmdldENvb3JkaW5hdGVzKCkpO24uYWRkKHIpfXJldHVybiBlLmJ1aWxkR2VvbWV0cnkobil9LGUoSmkucHJvdG90eXBlLHtjaGVja0VuZFB0VmVydGV4SW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRDb29yZGluYXRlcygpO3RoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMoblswXSx0aGlzLnNlZ1N0cmluZ3MpLHRoaXMuY2hlY2tFbmRQdFZlcnRleEludGVyc2VjdGlvbnMobltuLmxlbmd0aC0xXSx0aGlzLnNlZ1N0cmluZ3MpfWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXSx0PXIuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZm9yKHZhciBlPXQubmV4dCgpLG49ZS5nZXRDb29yZGluYXRlcygpLHM9MTtzPG4ubGVuZ3RoLTE7cysrKWlmKG5bc10uZXF1YWxzKGkpKXRocm93IG5ldyBsKFwiZm91bmQgZW5kcHQvaW50ZXJpb3IgcHQgaW50ZXJzZWN0aW9uIGF0IGluZGV4IFwiK3MrXCIgOnB0IFwiK2kpfSxjaGVja0ludGVyaW9ySW50ZXJzZWN0aW9uczpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKWZvcih2YXIgdD10aGlzLnNlZ1N0cmluZ3MuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspZm9yKHZhciBlPXQubmV4dCgpLG49dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNoZWNrSW50ZXJpb3JJbnRlcnNlY3Rpb25zKGUsaSl9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89ci5nZXRDb29yZGluYXRlcygpLGE9cy5nZXRDb29yZGluYXRlcygpLHU9MDt1PG8ubGVuZ3RoLTE7dSsrKWZvcih2YXIgaD0wO2g8YS5sZW5ndGgtMTtoKyspdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucyhyLHUscyxoKTtlbHNlIGlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYz1hcmd1bWVudHNbMF0sZj1hcmd1bWVudHNbMV0sZz1hcmd1bWVudHNbMl0sZD1hcmd1bWVudHNbM107aWYoYz09PWcmJmY9PT1kKXJldHVybiBudWxsO3ZhciBwPWMuZ2V0Q29vcmRpbmF0ZXMoKVtmXSx2PWMuZ2V0Q29vcmRpbmF0ZXMoKVtmKzFdLG09Zy5nZXRDb29yZGluYXRlcygpW2RdLHk9Zy5nZXRDb29yZGluYXRlcygpW2QrMV07aWYodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHAsdixtLHkpLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCkmJih0aGlzLmxpLmlzUHJvcGVyKCl8fHRoaXMuaGFzSW50ZXJpb3JJbnRlcnNlY3Rpb24odGhpcy5saSxwLHYpfHx0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHRoaXMubGksbSx5KSkpdGhyb3cgbmV3IGwoXCJmb3VuZCBub24tbm9kZWQgaW50ZXJzZWN0aW9uIGF0IFwiK3ArXCItXCIrditcIiBhbmQgXCIrbStcIi1cIit5KX19LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXt0aGlzLmNoZWNrRW5kUHRWZXJ0ZXhJbnRlcnNlY3Rpb25zKCksdGhpcy5jaGVja0ludGVyaW9ySW50ZXJzZWN0aW9ucygpLHRoaXMuY2hlY2tDb2xsYXBzZXMoKX0sY2hlY2tDb2xsYXBzZXM6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClmb3IodmFyIHQ9dGhpcy5zZWdTdHJpbmdzLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTt0aGlzLmNoZWNrQ29sbGFwc2VzKGUpfWVsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBuPWFyZ3VtZW50c1swXSxpPW4uZ2V0Q29vcmRpbmF0ZXMoKSx0PTA7dDxpLmxlbmd0aC0yO3QrKyl0aGlzLmNoZWNrQ29sbGFwc2UoaVt0XSxpW3QrMV0saVt0KzJdKX0saGFzSW50ZXJpb3JJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT0wO2k8dC5nZXRJbnRlcnNlY3Rpb25OdW0oKTtpKyspe3ZhciByPXQuZ2V0SW50ZXJzZWN0aW9uKGkpO2lmKCFyLmVxdWFscyhlKSYmIXIuZXF1YWxzKG4pKXJldHVybiEwfXJldHVybiExfSxjaGVja0NvbGxhcHNlOmZ1bmN0aW9uKHQsZSxuKXtpZih0LmVxdWFscyhuKSl0aHJvdyBuZXcgbChcImZvdW5kIG5vbi1ub2RlZCBjb2xsYXBzZSBhdCBcIitKaS5mYWN0LmNyZWF0ZUxpbmVTdHJpbmcoW3QsZSxuXSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBKaX19KSxKaS5mYWN0PW5ldyBpZSxlKCRpLnByb3RvdHlwZSx7aW50ZXJzZWN0c1NjYWxlZDpmdW5jdGlvbih0LGUpe3ZhciBuPU1hdGgubWluKHQueCxlLngpLGk9TWF0aC5tYXgodC54LGUueCkscj1NYXRoLm1pbih0LnksZS55KSxzPU1hdGgubWF4KHQueSxlLnkpLG89dGhpcy5tYXh4PG58fHRoaXMubWlueD5pfHx0aGlzLm1heHk8cnx8dGhpcy5taW55PnM7aWYobylyZXR1cm4hMTt2YXIgYT10aGlzLmludGVyc2VjdHNUb2xlcmFuY2VTcXVhcmUodCxlKTtyZXR1cm4gZi5pc1RydWUoIShvJiZhKSxcIkZvdW5kIGJhZCBlbnZlbG9wZSB0ZXN0XCIpLGF9LGluaXRDb3JuZXJzOmZ1bmN0aW9uKHQpe3ZhciBlPS41O3RoaXMubWlueD10LngtZSx0aGlzLm1heHg9dC54K2UsdGhpcy5taW55PXQueS1lLHRoaXMubWF4eT10LnkrZSx0aGlzLmNvcm5lclswXT1uZXcgZyh0aGlzLm1heHgsdGhpcy5tYXh5KSx0aGlzLmNvcm5lclsxXT1uZXcgZyh0aGlzLm1pbngsdGhpcy5tYXh5KSx0aGlzLmNvcm5lclsyXT1uZXcgZyh0aGlzLm1pbngsdGhpcy5taW55KSx0aGlzLmNvcm5lclszXT1uZXcgZyh0aGlzLm1heHgsdGhpcy5taW55KX0saW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3JldHVybiAxPT09dGhpcy5zY2FsZUZhY3Rvcj90aGlzLmludGVyc2VjdHNTY2FsZWQodCxlKToodGhpcy5jb3B5U2NhbGVkKHQsdGhpcy5wMFNjYWxlZCksdGhpcy5jb3B5U2NhbGVkKGUsdGhpcy5wMVNjYWxlZCksdGhpcy5pbnRlcnNlY3RzU2NhbGVkKHRoaXMucDBTY2FsZWQsdGhpcy5wMVNjYWxlZCkpfSxzY2FsZTpmdW5jdGlvbih0KXtyZXR1cm4gTWF0aC5yb3VuZCh0KnRoaXMuc2NhbGVGYWN0b3IpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMub3JpZ2luYWxQdH0sY29weVNjYWxlZDpmdW5jdGlvbih0LGUpe2UueD10aGlzLnNjYWxlKHQueCksZS55PXRoaXMuc2NhbGUodC55KX0sZ2V0U2FmZUVudmVsb3BlOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMuc2FmZUVudil7dmFyIHQ9JGkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUi90aGlzLnNjYWxlRmFjdG9yO3RoaXMuc2FmZUVudj1uZXcgQyh0aGlzLm9yaWdpbmFsUHQueC10LHRoaXMub3JpZ2luYWxQdC54K3QsdGhpcy5vcmlnaW5hbFB0LnktdCx0aGlzLm9yaWdpbmFsUHQueSt0KX1yZXR1cm4gdGhpcy5zYWZlRW52fSxpbnRlcnNlY3RzUGl4ZWxDbG9zdXJlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMF0sdGhpcy5jb3JuZXJbMV0pLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCk/ITA6KHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMV0sdGhpcy5jb3JuZXJbMl0pLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCk/ITA6KHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMl0sdGhpcy5jb3JuZXJbM10pLHRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCk/ITA6KHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbM10sdGhpcy5jb3JuZXJbMF0pLCEhdGhpcy5saS5oYXNJbnRlcnNlY3Rpb24oKSkpKX0saW50ZXJzZWN0c1RvbGVyYW5jZVNxdWFyZTpmdW5jdGlvbih0LGUpe3ZhciBuPSExLGk9ITE7cmV0dXJuIHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LGUsdGhpcy5jb3JuZXJbMF0sdGhpcy5jb3JuZXJbMV0pLHRoaXMubGkuaXNQcm9wZXIoKT8hMDoodGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsxXSx0aGlzLmNvcm5lclsyXSksdGhpcy5saS5pc1Byb3BlcigpPyEwOih0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYobj0hMCksdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclsyXSx0aGlzLmNvcm5lclszXSksdGhpcy5saS5pc1Byb3BlcigpPyEwOih0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiYoaT0hMCksdGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmNvcm5lclszXSx0aGlzLmNvcm5lclswXSksdGhpcy5saS5pc1Byb3BlcigpPyEwOm4mJmk/ITA6dC5lcXVhbHModGhpcy5wdCk/ITA6ISFlLmVxdWFscyh0aGlzLnB0KSkpKX0sYWRkU25hcHBlZE5vZGU6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldENvb3JkaW5hdGUoZSksaT10LmdldENvb3JkaW5hdGUoZSsxKTtyZXR1cm4gdGhpcy5pbnRlcnNlY3RzKG4saSk/KHQuYWRkSW50ZXJzZWN0aW9uKHRoaXMuZ2V0Q29vcmRpbmF0ZSgpLGUpLCEwKTohMX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJGl9fSksJGkuU0FGRV9FTlZfRVhQQU5TSU9OX0ZBQ1RPUj0uNzUsZSh0ci5wcm90b3R5cGUse3NlbGVjdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXthcmd1bWVudHNbMF19ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdO3QuZ2V0TGluZVNlZ21lbnQoZSx0aGlzLnNlbGVjdGVkU2VnbWVudCksdGhpcy5zZWxlY3QodGhpcy5zZWxlY3RlZFNlZ21lbnQpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdHJ9fSksZShlci5wcm90b3R5cGUse3NuYXA6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnNuYXAodCxudWxsLC0xKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGU9YXJndW1lbnRzWzBdLG49YXJndW1lbnRzWzFdLGk9YXJndW1lbnRzWzJdLHI9ZS5nZXRTYWZlRW52ZWxvcGUoKSxzPW5ldyBucihlLG4saSk7cmV0dXJuIHRoaXMuaW5kZXgucXVlcnkocix7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQWVdfSx2aXNpdEl0ZW06ZnVuY3Rpb24odCl7dmFyIGU9dDtlLnNlbGVjdChyLHMpfX0pLHMuaXNOb2RlQWRkZWQoKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGVyfX0pLGgobnIsdHIpLGUobnIucHJvdG90eXBlLHtpc05vZGVBZGRlZDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc05vZGVBZGRlZH0sc2VsZWN0OmZ1bmN0aW9uKCl7aWYoMiE9PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRyLnByb3RvdHlwZS5zZWxlY3QuYXBwbHkodGhpcyxhcmd1bWVudHMpO3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPXQuZ2V0Q29udGV4dCgpO3JldHVybiBudWxsIT09dGhpcy5wYXJlbnRFZGdlJiZuPT09dGhpcy5wYXJlbnRFZGdlJiZlPT09dGhpcy5ob3RQaXhlbFZlcnRleEluZGV4P251bGw6dm9pZCh0aGlzLl9pc05vZGVBZGRlZD10aGlzLmhvdFBpeGVsLmFkZFNuYXBwZWROb2RlKG4sZSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBucn19KSxlci5Ib3RQaXhlbFNuYXBBY3Rpb249bnIsZShpci5wcm90b3R5cGUse3Byb2Nlc3NJbnRlcnNlY3Rpb25zOmZ1bmN0aW9uKHQsZSxuLGkpe2lmKHQ9PT1uJiZlPT09aSlyZXR1cm4gbnVsbDt2YXIgcj10LmdldENvb3JkaW5hdGVzKClbZV0scz10LmdldENvb3JkaW5hdGVzKClbZSsxXSxvPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpXSxhPW4uZ2V0Q29vcmRpbmF0ZXMoKVtpKzFdO2lmKHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbihyLHMsbyxhKSx0aGlzLmxpLmhhc0ludGVyc2VjdGlvbigpJiZ0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKSl7Zm9yKHZhciB1PTA7dTx0aGlzLmxpLmdldEludGVyc2VjdGlvbk51bSgpO3UrKyl0aGlzLmludGVyaW9ySW50ZXJzZWN0aW9ucy5hZGQodGhpcy5saS5nZXRJbnRlcnNlY3Rpb24odSkpO3QuYWRkSW50ZXJzZWN0aW9ucyh0aGlzLmxpLGUsMCksbi5hZGRJbnRlcnNlY3Rpb25zKHRoaXMubGksaSwxKX19LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiExfSxnZXRJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnRlcmlvckludGVyc2VjdGlvbnN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW29uXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaXJ9fSksZShyci5wcm90b3R5cGUse2NoZWNrQ29ycmVjdG5lc3M6ZnVuY3Rpb24odCl7dmFyIGU9S2UuZ2V0Tm9kZWRTdWJzdHJpbmdzKHQpLG49bmV3IEppKGUpO3RyeXtuLmNoZWNrVmFsaWQoKX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBTKSl0aHJvdyB0O3QucHJpbnRTdGFja1RyYWNlKCl9ZmluYWxseXt9fSxnZXROb2RlZFN1YnN0cmluZ3M6ZnVuY3Rpb24oKXtyZXR1cm4gS2UuZ2V0Tm9kZWRTdWJzdHJpbmdzKHRoaXMubm9kZWRTZWdTdHJpbmdzKX0sc25hcFJvdW5kOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5maW5kSW50ZXJpb3JJbnRlcnNlY3Rpb25zKHQsZSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uU25hcHMobiksdGhpcy5jb21wdXRlVmVydGV4U25hcHModCl9LGZpbmRJbnRlcmlvckludGVyc2VjdGlvbnM6ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgaXIoZSk7cmV0dXJuIHRoaXMubm9kZXIuc2V0U2VnbWVudEludGVyc2VjdG9yKG4pLHRoaXMubm9kZXIuY29tcHV0ZU5vZGVzKHQpLG4uZ2V0SW50ZXJpb3JJbnRlcnNlY3Rpb25zKCl9LGNvbXB1dGVWZXJ0ZXhTbmFwczpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmNvbXB1dGVWZXJ0ZXhTbmFwcyhuKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgS2UpZm9yKHZhciBpPWFyZ3VtZW50c1swXSxyPWkuZ2V0Q29vcmRpbmF0ZXMoKSxzPTA7czxyLmxlbmd0aDtzKyspe3ZhciBvPW5ldyAkaShyW3NdLHRoaXMuc2NhbGVGYWN0b3IsdGhpcy5saSksYT10aGlzLnBvaW50U25hcHBlci5zbmFwKG8saSxzKTthJiZpLmFkZEludGVyc2VjdGlvbihyW3NdLHMpfX0sY29tcHV0ZU5vZGVzOmZ1bmN0aW9uKHQpe3RoaXMubm9kZWRTZWdTdHJpbmdzPXQsdGhpcy5ub2Rlcj1uZXcgbm4sdGhpcy5wb2ludFNuYXBwZXI9bmV3IGVyKHRoaXMubm9kZXIuZ2V0SW5kZXgoKSksdGhpcy5zbmFwUm91bmQodCx0aGlzLmxpKX0sY29tcHV0ZUludGVyc2VjdGlvblNuYXBzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKSxpPW5ldyAkaShuLHRoaXMuc2NhbGVGYWN0b3IsdGhpcy5saSk7dGhpcy5wb2ludFNuYXBwZXIuc25hcChpKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3RuXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcnJ9fSksZShzci5wcm90b3R5cGUse2J1ZmZlckZpeGVkUHJlY2lzaW9uOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBGaShuZXcgcnIobmV3IGVlKDEpKSx0LmdldFNjYWxlKCkpLG49bmV3IFFpKHRoaXMuYnVmUGFyYW1zKTtuLnNldFdvcmtpbmdQcmVjaXNpb25Nb2RlbCh0KSxuLnNldE5vZGVyKGUpLHRoaXMucmVzdWx0R2VvbWV0cnk9bi5idWZmZXIodGhpcy5hcmdHZW9tLHRoaXMuZGlzdGFuY2UpfSxidWZmZXJSZWR1Y2VkUHJlY2lzaW9uOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1zci5NQVhfUFJFQ0lTSU9OX0RJR0lUUzt0Pj0wO3QtLSl7dHJ5e3RoaXMuYnVmZmVyUmVkdWNlZFByZWNpc2lvbih0KX1jYXRjaCh0KXtpZighKHQgaW5zdGFuY2VvZiBzbikpdGhyb3cgdDt0aGlzLnNhdmVFeGNlcHRpb249dH1maW5hbGx5e31pZihudWxsIT09dGhpcy5yZXN1bHRHZW9tZXRyeSlyZXR1cm4gbnVsbH10aHJvdyB0aGlzLnNhdmVFeGNlcHRpb259aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPXNyLnByZWNpc2lvblNjYWxlRmFjdG9yKHRoaXMuYXJnR2VvbSx0aGlzLmRpc3RhbmNlLGUpLGk9bmV3IGVlKG4pO3RoaXMuYnVmZmVyRml4ZWRQcmVjaXNpb24oaSl9fSxjb21wdXRlR2VvbWV0cnk6ZnVuY3Rpb24oKXtpZih0aGlzLmJ1ZmZlck9yaWdpbmFsUHJlY2lzaW9uKCksbnVsbCE9PXRoaXMucmVzdWx0R2VvbWV0cnkpcmV0dXJuIG51bGw7dmFyIHQ9dGhpcy5hcmdHZW9tLmdldEZhY3RvcnkoKS5nZXRQcmVjaXNpb25Nb2RlbCgpO3QuZ2V0VHlwZSgpPT09ZWUuRklYRUQ/dGhpcy5idWZmZXJGaXhlZFByZWNpc2lvbih0KTp0aGlzLmJ1ZmZlclJlZHVjZWRQcmVjaXNpb24oKX0sc2V0UXVhZHJhbnRTZWdtZW50czpmdW5jdGlvbih0KXt0aGlzLmJ1ZlBhcmFtcy5zZXRRdWFkcmFudFNlZ21lbnRzKHQpfSxidWZmZXJPcmlnaW5hbFByZWNpc2lvbjpmdW5jdGlvbigpe3RyeXt2YXIgdD1uZXcgUWkodGhpcy5idWZQYXJhbXMpO3RoaXMucmVzdWx0R2VvbWV0cnk9dC5idWZmZXIodGhpcy5hcmdHZW9tLHRoaXMuZGlzdGFuY2UpfWNhdGNoKHQpe2lmKCEodCBpbnN0YW5jZW9mIGwpKXRocm93IHQ7dGhpcy5zYXZlRXhjZXB0aW9uPXR9ZmluYWxseXt9fSxnZXRSZXN1bHRHZW9tZXRyeTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kaXN0YW5jZT10LHRoaXMuY29tcHV0ZUdlb21ldHJ5KCksdGhpcy5yZXN1bHRHZW9tZXRyeX0sc2V0RW5kQ2FwU3R5bGU6ZnVuY3Rpb24odCl7dGhpcy5idWZQYXJhbXMuc2V0RW5kQ2FwU3R5bGUodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNyfX0pLHNyLmJ1ZmZlck9wPWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPW5ldyBzcih0KSxpPW4uZ2V0UmVzdWx0R2VvbWV0cnkoZSk7cmV0dXJuIGl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzJdKSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl0sYT1uZXcgc3Iocik7YS5zZXRRdWFkcmFudFNlZ21lbnRzKG8pO3ZhciBpPWEuZ2V0UmVzdWx0R2VvbWV0cnkocyk7cmV0dXJuIGl9aWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBCaSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCJiZcIm51bWJlclwiPT10eXBlb2YgYXJndW1lbnRzWzFdKXt2YXIgdT1hcmd1bWVudHNbMF0sbD1hcmd1bWVudHNbMV0saD1hcmd1bWVudHNbMl0sYT1uZXcgc3IodSxoKSxpPWEuZ2V0UmVzdWx0R2VvbWV0cnkobCk7cmV0dXJuIGl9fWVsc2UgaWYoND09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBjPWFyZ3VtZW50c1swXSxmPWFyZ3VtZW50c1sxXSxnPWFyZ3VtZW50c1syXSxkPWFyZ3VtZW50c1szXSxhPW5ldyBzcihjKTthLnNldFF1YWRyYW50U2VnbWVudHMoZyksYS5zZXRFbmRDYXBTdHlsZShkKTt2YXIgaT1hLmdldFJlc3VsdEdlb21ldHJ5KGYpO3JldHVybiBpfX0sc3IucHJlY2lzaW9uU2NhbGVGYWN0b3I9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLHI9VC5tYXgoTWF0aC5hYnMoaS5nZXRNYXhYKCkpLE1hdGguYWJzKGkuZ2V0TWF4WSgpKSxNYXRoLmFicyhpLmdldE1pblgoKSksTWF0aC5hYnMoaS5nZXRNaW5ZKCkpKSxzPWU+MD9lOjAsbz1yKzIqcyxhPU1hdGgudHJ1bmMoTWF0aC5sb2cobykvTWF0aC5sb2coMTApKzEpLHU9bi1hLGw9TWF0aC5wb3coMTAsdSk7cmV0dXJuIGx9LHNyLkNBUF9ST1VORD1CaS5DQVBfUk9VTkQsc3IuQ0FQX0JVVFQ9QmkuQ0FQX0ZMQVQsc3IuQ0FQX0ZMQVQ9QmkuQ0FQX0ZMQVQsc3IuQ0FQX1NRVUFSRT1CaS5DQVBfU1FVQVJFLHNyLk1BWF9QUkVDSVNJT05fRElHSVRTPTEyO3ZhciBDbz1PYmplY3QuZnJlZXplKHtCdWZmZXJPcDpzcixCdWZmZXJQYXJhbWV0ZXJzOkJpfSk7ZShvci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXt0IGluc3RhbmNlb2YgVHQmJnRoaXMuY29tcHMuYWRkKHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltodF19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG9yfX0pLG9yLmdldFBvbHlnb25zPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gb3IuZ2V0UG9seWdvbnModCxuZXcgSSl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtyZXR1cm4gZSBpbnN0YW5jZW9mIFR0P24uYWRkKGUpOmUgaW5zdGFuY2VvZiBmdCYmZS5hcHBseShuZXcgb3IobikpLG59fSxlKGFyLnByb3RvdHlwZSx7aXNJbnNpZGVBcmVhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnSW5kZXg9PT1hci5JTlNJREVfQVJFQX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB0fSxnZXRHZW9tZXRyeUNvbXBvbmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbXBvbmVudH0sZ2V0U2VnbWVudEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc2VnSW5kZXh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGFyfX0pLGFyLklOU0lERV9BUkVBPS0xLGUodXIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7dCBpbnN0YW5jZW9mIEx0JiZ0aGlzLnB0cy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdXJ9fSksdXIuZ2V0UG9pbnRzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdCBpbnN0YW5jZW9mIEx0P2hvLnNpbmdsZXRvbkxpc3QodCk6dXIuZ2V0UG9pbnRzKHQsbmV3IEkpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIGUgaW5zdGFuY2VvZiBMdD9uLmFkZChlKTplIGluc3RhbmNlb2YgZnQmJmUuYXBwbHkobmV3IHVyKG4pKSxufX0sZShsci5wcm90b3R5cGUse2ZpbHRlcjpmdW5jdGlvbih0KXsodCBpbnN0YW5jZW9mIEx0fHx0IGluc3RhbmNlb2YgU3R8fHQgaW5zdGFuY2VvZiBUdCkmJnRoaXMubG9jYXRpb25zLmFkZChuZXcgYXIodCwwLHQuZ2V0Q29vcmRpbmF0ZSgpKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2h0XX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbHJ9fSksbHIuZ2V0TG9jYXRpb25zPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBJO3JldHVybiB0LmFwcGx5KG5ldyBscihlKSksZX0sZShoci5wcm90b3R5cGUse2NvbXB1dGVDb250YWlubWVudERpc3RhbmNlOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PW5ldyBBcnJheSgyKS5maWxsKG51bGwpO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMCx0KSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsO3RoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoMSx0KX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT0xLWUscj1vci5nZXRQb2x5Z29ucyh0aGlzLmdlb21bZV0pO2lmKHIuc2l6ZSgpPjApe3ZhciBzPWxyLmdldExvY2F0aW9ucyh0aGlzLmdlb21baV0pO2lmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UocyxyLG4pLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbltpXT1uWzBdLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvbltlXT1uWzFdLG51bGx9fWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmUihhcmd1bWVudHNbMF0seSkmJlIoYXJndW1lbnRzWzFdLHkpKXtmb3IodmFyIG89YXJndW1lbnRzWzBdLGE9YXJndW1lbnRzWzFdLHU9YXJndW1lbnRzWzJdLGw9MDtsPG8uc2l6ZSgpO2wrKylmb3IodmFyIGg9by5nZXQobCksYz0wO2M8YS5zaXplKCk7YysrKWlmKHRoaXMuY29tcHV0ZUNvbnRhaW5tZW50RGlzdGFuY2UoaCxhLmdldChjKSx1KSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfWVsc2UgaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBhciYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBUdCl7dmFyIGY9YXJndW1lbnRzWzBdLGc9YXJndW1lbnRzWzFdLGQ9YXJndW1lbnRzWzJdLHA9Zi5nZXRDb29yZGluYXRlKCk7aWYoTC5FWFRFUklPUiE9PXRoaXMucHRMb2NhdG9yLmxvY2F0ZShwLGcpKXJldHVybiB0aGlzLm1pbkRpc3RhbmNlPTAsZFswXT1mLGRbMV09bmV3IGFyKGcscCksbnVsbH19LGNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzUG9pbnRzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuc2l6ZSgpO2krKylmb3IodmFyIHI9dC5nZXQoaSkscz0wO3M8ZS5zaXplKCk7cysrKXt2YXIgbz1lLmdldChzKTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShyLG8sbiksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19LGNvbXB1dGVGYWNldERpc3RhbmNlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEFycmF5KDIpLmZpbGwobnVsbCksZT1rbi5nZXRMaW5lcyh0aGlzLmdlb21bMF0pLG49a24uZ2V0TGluZXModGhpcy5nZW9tWzFdKSxpPXVyLmdldFBvaW50cyh0aGlzLmdlb21bMF0pLHI9dXIuZ2V0UG9pbnRzKHRoaXMuZ2VvbVsxXSk7cmV0dXJuIHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXMoZSxuLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMoZSxyLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlTGluZXNQb2ludHMobixpLHQpLHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMCksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZT9udWxsOih0WzBdPW51bGwsdFsxXT1udWxsLHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzKGkscix0KSx2b2lkIHRoaXMudXBkYXRlTWluRGlzdGFuY2UodCwhMSkpKSl9LG5lYXJlc3RMb2NhdGlvbnM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb21wdXRlTWluRGlzdGFuY2UoKSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb259LHVwZGF0ZU1pbkRpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10WzBdP251bGw6dm9pZChlPyh0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMF09dFsxXSx0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMV09dFswXSk6KHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblswXT10WzBdLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblsxXT10WzFdKSl9LG5lYXJlc3RQb2ludHM6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZSgpO3ZhciB0PVt0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb25bMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMubWluRGlzdGFuY2VMb2NhdGlvblsxXS5nZXRDb29yZGluYXRlKCldO3JldHVybiB0fSxjb21wdXRlTWluRGlzdGFuY2U6ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aCl7aWYobnVsbCE9PXRoaXMubWluRGlzdGFuY2VMb2NhdGlvbilyZXR1cm4gbnVsbDtpZih0aGlzLm1pbkRpc3RhbmNlTG9jYXRpb249bmV3IEFycmF5KDIpLmZpbGwobnVsbCksdGhpcy5jb21wdXRlQ29udGFpbm1lbnREaXN0YW5jZSgpLHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGw7dGhpcy5jb21wdXRlRmFjZXREaXN0YW5jZSgpfWVsc2UgaWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzJdaW5zdGFuY2VvZiBBcnJheSYmYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBTdCYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBMdCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9YXJndW1lbnRzWzFdLG49YXJndW1lbnRzWzJdO2lmKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmRpc3RhbmNlKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT50aGlzLm1pbkRpc3RhbmNlKXJldHVybiBudWxsO2Zvcih2YXIgaT10LmdldENvb3JkaW5hdGVzKCkscj1lLmdldENvb3JkaW5hdGUoKSxzPTA7czxpLmxlbmd0aC0xO3MrKyl7dmFyIG89aGUuZGlzdGFuY2VQb2ludExpbmUocixpW3NdLGlbcysxXSk7aWYobzx0aGlzLm1pbkRpc3RhbmNlKXt0aGlzLm1pbkRpc3RhbmNlPW87dmFyIGE9bmV3IGNlKGlbc10saVtzKzFdKSx1PWEuY2xvc2VzdFBvaW50KHIpO25bMF09bmV3IGFyKHQscyx1KSxuWzFdPW5ldyBhcihlLDAscil9aWYodGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19ZWxzZSBpZihhcmd1bWVudHNbMl1pbnN0YW5jZW9mIEFycmF5JiZhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0JiZhcmd1bWVudHNbMV1pbnN0YW5jZW9mIFN0KXt2YXIgbD1hcmd1bWVudHNbMF0saD1hcmd1bWVudHNbMV0sYz1hcmd1bWVudHNbMl07aWYobC5nZXRFbnZlbG9wZUludGVybmFsKCkuZGlzdGFuY2UoaC5nZXRFbnZlbG9wZUludGVybmFsKCkpPnRoaXMubWluRGlzdGFuY2UpcmV0dXJuIG51bGw7Zm9yKHZhciBpPWwuZ2V0Q29vcmRpbmF0ZXMoKSxmPWguZ2V0Q29vcmRpbmF0ZXMoKSxzPTA7czxpLmxlbmd0aC0xO3MrKylmb3IodmFyIGc9MDtnPGYubGVuZ3RoLTE7ZysrKXt2YXIgbz1oZS5kaXN0YW5jZUxpbmVMaW5lKGlbc10saVtzKzFdLGZbZ10sZltnKzFdKTtpZihvPHRoaXMubWluRGlzdGFuY2Upe3RoaXMubWluRGlzdGFuY2U9bzt2YXIgZD1uZXcgY2UoaVtzXSxpW3MrMV0pLHA9bmV3IGNlKGZbZ10sZltnKzFdKSx2PWQuY2xvc2VzdFBvaW50cyhwKTtjWzBdPW5ldyBhcihsLHMsdlswXSksY1sxXT1uZXcgYXIoaCxnLHZbMV0pfWlmKHRoaXMubWluRGlzdGFuY2U8PXRoaXMudGVybWluYXRlRGlzdGFuY2UpcmV0dXJuIG51bGx9fX0sY29tcHV0ZU1pbkRpc3RhbmNlUG9pbnRzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuc2l6ZSgpO2krKylmb3IodmFyIHI9dC5nZXQoaSkscz0wO3M8ZS5zaXplKCk7cysrKXt2YXIgbz1lLmdldChzKSxhPXIuZ2V0Q29vcmRpbmF0ZSgpLmRpc3RhbmNlKG8uZ2V0Q29vcmRpbmF0ZSgpKTtpZihhPHRoaXMubWluRGlzdGFuY2UmJih0aGlzLm1pbkRpc3RhbmNlPWEsblswXT1uZXcgYXIociwwLHIuZ2V0Q29vcmRpbmF0ZSgpKSxuWzFdPW5ldyBhcihvLDAsby5nZXRDb29yZGluYXRlKCkpKSx0aGlzLm1pbkRpc3RhbmNlPD10aGlzLnRlcm1pbmF0ZURpc3RhbmNlKXJldHVybiBudWxsfX0sZGlzdGFuY2U6ZnVuY3Rpb24oKXtpZihudWxsPT09dGhpcy5nZW9tWzBdfHxudWxsPT09dGhpcy5nZW9tWzFdKXRocm93IG5ldyBpKFwibnVsbCBnZW9tZXRyaWVzIGFyZSBub3Qgc3VwcG9ydGVkXCIpO3JldHVybiB0aGlzLmdlb21bMF0uaXNFbXB0eSgpfHx0aGlzLmdlb21bMV0uaXNFbXB0eSgpPzA6KHRoaXMuY29tcHV0ZU1pbkRpc3RhbmNlKCksdGhpcy5taW5EaXN0YW5jZSl9LGNvbXB1dGVNaW5EaXN0YW5jZUxpbmVzOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9MDtpPHQuc2l6ZSgpO2krKylmb3IodmFyIHI9dC5nZXQoaSkscz0wO3M8ZS5zaXplKCk7cysrKXt2YXIgbz1lLmdldChzKTtpZih0aGlzLmNvbXB1dGVNaW5EaXN0YW5jZShyLG8sbiksdGhpcy5taW5EaXN0YW5jZTw9dGhpcy50ZXJtaW5hdGVEaXN0YW5jZSlyZXR1cm4gbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGhyfX0pLGhyLmRpc3RhbmNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGhyKHQsZSk7cmV0dXJuIG4uZGlzdGFuY2UoKX0saHIuaXNXaXRoaW5EaXN0YW5jZT1mdW5jdGlvbih0LGUsbil7dmFyIGk9bmV3IGhyKHQsZSxuKTtyZXR1cm4gaS5kaXN0YW5jZSgpPD1ufSxoci5uZWFyZXN0UG9pbnRzPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGhyKHQsZSk7cmV0dXJuIG4ubmVhcmVzdFBvaW50cygpfTt2YXIgU289T2JqZWN0LmZyZWV6ZSh7RGlzdGFuY2VPcDpocn0pO2UoY3IucHJvdG90eXBlLHtnZXRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmNvb3JkaW5hdGVzKXtmb3IodmFyIHQ9MCxlPTAsbj1uZXcgTixpPXRoaXMuZGlyZWN0ZWRFZGdlcy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7ci5nZXRFZGdlRGlyZWN0aW9uKCk/dCsrOmUrKyxuLmFkZChyLmdldEVkZ2UoKS5nZXRMaW5lKCkuZ2V0Q29vcmRpbmF0ZXMoKSwhMSxyLmdldEVkZ2VEaXJlY3Rpb24oKSl9dGhpcy5jb29yZGluYXRlcz1uLnRvQ29vcmRpbmF0ZUFycmF5KCksZT50JiZILnJldmVyc2UodGhpcy5jb29yZGluYXRlcyl9cmV0dXJuIHRoaXMuY29vcmRpbmF0ZXN9LHRvTGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlTGluZVN0cmluZyh0aGlzLmdldENvb3JkaW5hdGVzKCkpfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5kaXJlY3RlZEVkZ2VzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3J9fSksZShmci5wcm90b3R5cGUse3NldFZpc2l0ZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNWaXNpdGVkPXR9LGlzTWFya2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzTWFya2VkfSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sc2V0TWFya2VkOmZ1bmN0aW9uKHQpe3RoaXMuX2lzTWFya2VkPXR9LGdldENvbnRleHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxpc1Zpc2l0ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faXNWaXNpdGVkfSxzZXRDb250ZXh0OmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBmcn19KSxmci5nZXRDb21wb25lbnRXaXRoVmlzaXRlZFN0YXRlPWZ1bmN0aW9uKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3ZhciBuPXQubmV4dCgpO2lmKG4uaXNWaXNpdGVkKCk9PT1lKXJldHVybiBufXJldHVybiBudWxsfSxmci5zZXRWaXNpdGVkPWZ1bmN0aW9uKHQsZSl7Zm9yKDt0Lmhhc05leHQoKTspe3ZhciBuPXQubmV4dCgpO24uc2V0VmlzaXRlZChlKX19LGZyLnNldE1hcmtlZD1mdW5jdGlvbih0LGUpe2Zvcig7dC5oYXNOZXh0KCk7KXt2YXIgbj10Lm5leHQoKTtuLnNldE1hcmtlZChlKX19LGgoZ3IsZnIpLGUoZ3IucHJvdG90eXBlLHtpc1JlbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMucGFyZW50RWRnZX0sY29tcGFyZURpcmVjdGlvbjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5xdWFkcmFudD50LnF1YWRyYW50PzE6dGhpcy5xdWFkcmFudDx0LnF1YWRyYW50Py0xOmhlLmNvbXB1dGVPcmllbnRhdGlvbih0LnAwLHQucDEsdGhpcy5wMSl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5mcm9tLmdldENvb3JkaW5hdGUoKX0scHJpbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRDbGFzcygpLmdldE5hbWUoKSxuPWUubGFzdEluZGV4T2YoXCIuXCIpLGk9ZS5zdWJzdHJpbmcobisxKTt0LnByaW50KFwiICBcIitpK1wiOiBcIit0aGlzLnAwK1wiIC0gXCIrdGhpcy5wMStcIiBcIit0aGlzLnF1YWRyYW50K1wiOlwiK3RoaXMuYW5nbGUpfSxnZXREaXJlY3Rpb25QdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAxfSxnZXRBbmdsZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmFuZ2xlfSxjb21wYXJlVG86ZnVuY3Rpb24odCl7dmFyIGU9dDtyZXR1cm4gdGhpcy5jb21wYXJlRGlyZWN0aW9uKGUpfSxnZXRGcm9tTm9kZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmZyb219LGdldFN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bX0sc2V0RWRnZTpmdW5jdGlvbih0KXt0aGlzLnBhcmVudEVkZ2U9dH0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5zeW09bnVsbCx0aGlzLnBhcmVudEVkZ2U9bnVsbH0sZ2V0RWRnZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudEVkZ2V9LGdldFF1YWRyYW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucXVhZHJhbnR9LHNldFN5bTpmdW5jdGlvbih0KXt0aGlzLnN5bT10fSxnZXRUb05vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b30sZ2V0RWRnZURpcmVjdGlvbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VEaXJlY3Rpb259LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBncn19KSxnci50b0VkZ2VzPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspZS5hZGQobi5uZXh0KCkucGFyZW50RWRnZSk7cmV0dXJuIGV9LGgoZHIsZ3IpLGUoZHIucHJvdG90eXBlLHtnZXROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIDIhPT10aGlzLmdldFRvTm9kZSgpLmdldERlZ3JlZSgpP251bGw6dGhpcy5nZXRUb05vZGUoKS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkuZ2V0KDApPT09dGhpcy5nZXRTeW0oKT90aGlzLmdldFRvTm9kZSgpLmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKS5nZXQoMSk6KGYuaXNUcnVlKHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgxKT09PXRoaXMuZ2V0U3ltKCkpLHRoaXMuZ2V0VG9Ob2RlKCkuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLmdldCgwKSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRyfX0pLGgocHIsZnIpLGUocHIucHJvdG90eXBlLHtpc1JlbW92ZWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbD09PXRoaXMuZGlyRWRnZX0sc2V0RGlyZWN0ZWRFZGdlczpmdW5jdGlvbih0LGUpe3RoaXMuZGlyRWRnZT1bdCxlXSx0LnNldEVkZ2UodGhpcyksZS5zZXRFZGdlKHRoaXMpLHQuc2V0U3ltKGUpLGUuc2V0U3ltKHQpLHQuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKHQpLGUuZ2V0RnJvbU5vZGUoKS5hZGRPdXRFZGdlKGUpfSxnZXREaXJFZGdlOmZ1bmN0aW9uKCl7aWYoTnVtYmVyLmlzSW50ZWdlcihhcmd1bWVudHNbMF0pKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGlyRWRnZVt0XX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1yKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuZGlyRWRnZVswXS5nZXRGcm9tTm9kZSgpPT09ZT90aGlzLmRpckVkZ2VbMF06dGhpcy5kaXJFZGdlWzFdLmdldEZyb21Ob2RlKCk9PT1lP3RoaXMuZGlyRWRnZVsxXTpudWxsfX0scmVtb3ZlOmZ1bmN0aW9uKCl7dGhpcy5kaXJFZGdlPW51bGx9LGdldE9wcG9zaXRlTm9kZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5kaXJFZGdlWzBdLmdldEZyb21Ob2RlKCk9PT10P3RoaXMuZGlyRWRnZVswXS5nZXRUb05vZGUoKTp0aGlzLmRpckVkZ2VbMV0uZ2V0RnJvbU5vZGUoKT09PXQ/dGhpcy5kaXJFZGdlWzFdLmdldFRvTm9kZSgpOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHByfX0pLGUodnIucHJvdG90eXBlLHtnZXROZXh0RWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLm91dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUrMSkpfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5pdGVyYXRvcigpO2lmKCF0Lmhhc05leHQoKSlyZXR1cm4gbnVsbDt2YXIgZT10Lm5leHQoKTtyZXR1cm4gZS5nZXRDb29yZGluYXRlKCl9LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5vdXRFZGdlcy5pdGVyYXRvcigpfSxzb3J0RWRnZXM6ZnVuY3Rpb24oKXt0aGlzLnNvcnRlZHx8KGhvLnNvcnQodGhpcy5vdXRFZGdlcyksdGhpcy5zb3J0ZWQ9ITApfSxyZW1vdmU6ZnVuY3Rpb24odCl7dGhpcy5vdXRFZGdlcy5yZW1vdmUodCl9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc29ydEVkZ2VzKCksdGhpcy5vdXRFZGdlc30sZ2V0TmV4dENXRWRnZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdldEluZGV4KHQpO3JldHVybiB0aGlzLm91dEVkZ2VzLmdldCh0aGlzLmdldEluZGV4KGUtMSkpfSxnZXRJbmRleDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgcHIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLnNvcnRFZGdlcygpO2Zvcih2YXIgZT0wO2U8dGhpcy5vdXRFZGdlcy5zaXplKCk7ZSsrKXt2YXIgbj10aGlzLm91dEVkZ2VzLmdldChlKTtpZihuLmdldEVkZ2UoKT09PXQpcmV0dXJuIGV9cmV0dXJuLTF9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBncil7dmFyIGk9YXJndW1lbnRzWzBdO3RoaXMuc29ydEVkZ2VzKCk7Zm9yKHZhciBlPTA7ZTx0aGlzLm91dEVkZ2VzLnNpemUoKTtlKyspe3ZhciBuPXRoaXMub3V0RWRnZXMuZ2V0KGUpO2lmKG49PT1pKXJldHVybiBlfXJldHVybi0xfWlmKE51bWJlci5pc0ludGVnZXIoYXJndW1lbnRzWzBdKSl7dmFyIHI9YXJndW1lbnRzWzBdLHM9ciV0aGlzLm91dEVkZ2VzLnNpemUoKTtyZXR1cm4gMD5zJiYocys9dGhpcy5vdXRFZGdlcy5zaXplKCkpLHN9fSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5vdXRFZGdlcy5hZGQodCksdGhpcy5zb3J0ZWQ9ITF9LGdldERlZ3JlZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLm91dEVkZ2VzLnNpemUoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdnJ9fSksaChtcixmciksZShtci5wcm90b3R5cGUse2lzUmVtb3ZlZDpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5wdH0sYWRkT3V0RWRnZTpmdW5jdGlvbih0KXt0aGlzLmRlU3Rhci5hZGQodCl9LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0sZ2V0T3V0RWRnZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZVN0YXJ9LHJlbW92ZTpmdW5jdGlvbigpe2lmKDA9PT1hcmd1bWVudHMubGVuZ3RoKXRoaXMucHQ9bnVsbDtlbHNlIGlmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5kZVN0YXIucmVtb3ZlKHQpfX0sZ2V0SW5kZXg6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZGVTdGFyLmdldEluZGV4KHQpfSxnZXREZWdyZWU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kZVN0YXIuZ2V0RGVncmVlKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIG1yfX0pLG1yLmdldEVkZ2VzQmV0d2Vlbj1mdW5jdGlvbih0LGUpe3ZhciBuPWdyLnRvRWRnZXModC5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkpLGk9bmV3IEoobikscj1nci50b0VkZ2VzKGUuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpKTtyZXR1cm4gaS5yZXRhaW5BbGwociksaX0saCh5cixwciksZSh5ci5wcm90b3R5cGUse2dldExpbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5saW5lfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB5cn19KSxlKHhyLnByb3RvdHlwZSx7ZmluZDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLmdldCh0KX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLnZhbHVlcygpLml0ZXJhdG9yKCl9LHJlbW92ZTpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5ub2RlTWFwLnJlbW92ZSh0KX0sdmFsdWVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX0sYWRkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLm5vZGVNYXAucHV0KHQuZ2V0Q29vcmRpbmF0ZSgpLHQpLHR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHhyfX0pLGUoRXIucHJvdG90eXBlLHtmaW5kTm9kZXNPZkRlZ3JlZTpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10aGlzLm5vZGVJdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5nZXREZWdyZWUoKT09PXQmJmUuYWRkKGkpfXJldHVybiBlfSxkaXJFZGdlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kaXJFZGdlcy5pdGVyYXRvcigpfSxlZGdlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlcy5pdGVyYXRvcigpfSxyZW1vdmU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHByKXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5yZW1vdmUodC5nZXREaXJFZGdlKDApKSx0aGlzLnJlbW92ZSh0LmdldERpckVkZ2UoMSkpLHRoaXMuZWRnZXMucmVtb3ZlKHQpLHQucmVtb3ZlKCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGdyKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1lLmdldFN5bSgpO251bGwhPT1uJiZuLnNldFN5bShudWxsKSxlLmdldEZyb21Ob2RlKCkucmVtb3ZlKGUpLGUucmVtb3ZlKCksdGhpcy5kaXJFZGdlcy5yZW1vdmUoZSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIG1yKXtmb3IodmFyIGk9YXJndW1lbnRzWzBdLHI9aS5nZXRPdXRFZGdlcygpLmdldEVkZ2VzKCkscz1yLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKSxuPW8uZ2V0U3ltKCk7bnVsbCE9PW4mJnRoaXMucmVtb3ZlKG4pLHRoaXMuZGlyRWRnZXMucmVtb3ZlKG8pO3ZhciBhPW8uZ2V0RWRnZSgpO251bGwhPT1hJiZ0aGlzLmVkZ2VzLnJlbW92ZShhKX10aGlzLm5vZGVNYXAucmVtb3ZlKGkuZ2V0Q29vcmRpbmF0ZSgpKSxpLnJlbW92ZSgpfX0sZmluZE5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubm9kZU1hcC5maW5kKHQpfSxnZXRFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VzfSxub2RlSXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5ub2RlTWFwLml0ZXJhdG9yKCl9LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwcil7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmVkZ2VzLmNvbnRhaW5zKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Ipe3ZhciBlPWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5kaXJFZGdlcy5jb250YWlucyhlKX19LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgbXIpe3ZhciB0PWFyZ3VtZW50c1swXTt0aGlzLm5vZGVNYXAuYWRkKHQpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBwcil7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuZWRnZXMuYWRkKGUpLHRoaXMuYWRkKGUuZ2V0RGlyRWRnZSgwKSksdGhpcy5hZGQoZS5nZXREaXJFZGdlKDEpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZ3Ipe3ZhciBuPWFyZ3VtZW50c1swXTt0aGlzLmRpckVkZ2VzLmFkZChuKX19LGdldE5vZGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZU1hcC52YWx1ZXMoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRXJ9fSksaChJcixFciksZShJci5wcm90b3R5cGUse2FkZEVkZ2U6ZnVuY3Rpb24odCl7aWYodC5pc0VtcHR5KCkpcmV0dXJuIG51bGw7dmFyIGU9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0LmdldENvb3JkaW5hdGVzKCkpO2lmKGUubGVuZ3RoPD0xKXJldHVybiBudWxsO3ZhciBuPWVbMF0saT1lW2UubGVuZ3RoLTFdLHI9dGhpcy5nZXROb2RlKG4pLHM9dGhpcy5nZXROb2RlKGkpLG89bmV3IGRyKHIscyxlWzFdLCEwKSxhPW5ldyBkcihzLHIsZVtlLmxlbmd0aC0yXSwhMSksdT1uZXcgeXIodCk7dS5zZXREaXJlY3RlZEVkZ2VzKG8sYSksdGhpcy5hZGQodSl9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBtcih0KSx0aGlzLmFkZChlKSksZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSXJ9fSksZShOci5wcm90b3R5cGUse2J1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZ3JhcGguZ2V0Tm9kZXMoKS5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5pc01hcmtlZCgpfHwoZi5pc1RydWUoMj09PWUuZ2V0RGVncmVlKCkpLHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JOb25EZWdyZWUyTm9kZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ncmFwaC5nZXROb2RlcygpLml0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTsyIT09ZS5nZXREZWdyZWUoKSYmKHRoaXMuYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQoZSksZS5zZXRNYXJrZWQoITApKX19LGJ1aWxkRWRnZVN0cmluZ3NGb3JPYnZpb3VzU3RhcnROb2RlczpmdW5jdGlvbigpe3RoaXMuYnVpbGRFZGdlU3RyaW5nc0Zvck5vbkRlZ3JlZTJOb2RlcygpfSxnZXRNZXJnZWRMaW5lU3RyaW5nczpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1lcmdlKCksdGhpcy5tZXJnZWRMaW5lU3RyaW5nc30sYnVpbGRFZGdlU3RyaW5nc1N0YXJ0aW5nQXQ6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7bi5nZXRFZGdlKCkuaXNNYXJrZWQoKXx8dGhpcy5lZGdlU3RyaW5ncy5hZGQodGhpcy5idWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGgobikpfX0sbWVyZ2U6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5tZXJnZWRMaW5lU3RyaW5ncylyZXR1cm4gbnVsbDtmci5zZXRNYXJrZWQodGhpcy5ncmFwaC5ub2RlSXRlcmF0b3IoKSwhMSksZnIuc2V0TWFya2VkKHRoaXMuZ3JhcGguZWRnZUl0ZXJhdG9yKCksITEpLHRoaXMuZWRnZVN0cmluZ3M9bmV3IEksdGhpcy5idWlsZEVkZ2VTdHJpbmdzRm9yT2J2aW91c1N0YXJ0Tm9kZXMoKSx0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JJc29sYXRlZExvb3BzKCksdGhpcy5tZXJnZWRMaW5lU3RyaW5ncz1uZXcgSTtmb3IodmFyIHQ9dGhpcy5lZGdlU3RyaW5ncy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7dGhpcy5tZXJnZWRMaW5lU3RyaW5ncy5hZGQoZS50b0xpbmVTdHJpbmcoKSl9fSxidWlsZEVkZ2VTdHJpbmdTdGFydGluZ1dpdGg6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IGNyKHRoaXMuZmFjdG9yeSksbj10O2RvIGUuYWRkKG4pLG4uZ2V0RWRnZSgpLnNldE1hcmtlZCghMCksbj1uLmdldE5leHQoKTt3aGlsZShudWxsIT09biYmbiE9PXQpO3JldHVybiBlfSxhZGQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciB0PWFyZ3VtZW50c1swXTt0LmFwcGx5KHtpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltxXX0sZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBTdCYmdGhpcy5hZGQodCl9fSl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMubWVyZ2VkTGluZVN0cmluZ3M9bnVsbDtmb3IodmFyIG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7XG52YXIgaT1uLm5leHQoKTt0aGlzLmFkZChpKX19ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFN0KXt2YXIgcj1hcmd1bWVudHNbMF07bnVsbD09PXRoaXMuZmFjdG9yeSYmKHRoaXMuZmFjdG9yeT1yLmdldEZhY3RvcnkoKSksdGhpcy5ncmFwaC5hZGRFZGdlKHIpfX0sYnVpbGRFZGdlU3RyaW5nc0Zvcklzb2xhdGVkTG9vcHM6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkRWRnZVN0cmluZ3NGb3JVbnByb2Nlc3NlZE5vZGVzKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5yfX0pO3ZhciB3bz1PYmplY3QuZnJlZXplKHtMaW5lTWVyZ2VyOk5yfSksTG89T2JqZWN0LmZyZWV6ZSh7T3ZlcmxheU9wOmlpfSk7aChDcixnciksZShDci5wcm90b3R5cGUse2dldE5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0fSxpc0luUmluZzpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5lZGdlUmluZ30sc2V0UmluZzpmdW5jdGlvbih0KXt0aGlzLmVkZ2VSaW5nPXR9LHNldExhYmVsOmZ1bmN0aW9uKHQpe3RoaXMubGFiZWw9dH0sZ2V0TGFiZWw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5sYWJlbH0sc2V0TmV4dDpmdW5jdGlvbih0KXt0aGlzLm5leHQ9dH0sZ2V0UmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VSaW5nfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBDcn19KSxoKFNyLHByKSxlKFNyLnByb3RvdHlwZSx7Z2V0TGluZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxpbmV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFNyfX0pLGUod3IucHJvdG90eXBlLHtpc0luY2x1ZGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSW5jbHVkZWR9LGdldENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7aWYobnVsbD09PXRoaXMucmluZ1B0cyl7Zm9yKHZhciB0PW5ldyBOLGU9dGhpcy5kZUxpc3QuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRFZGdlKCk7d3IuYWRkRWRnZShpLmdldExpbmUoKS5nZXRDb29yZGluYXRlcygpLG4uZ2V0RWRnZURpcmVjdGlvbigpLHQpfXRoaXMucmluZ1B0cz10LnRvQ29vcmRpbmF0ZUFycmF5KCl9cmV0dXJuIHRoaXMucmluZ1B0c30saXNJbmNsdWRlZFNldDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0luY2x1ZGVkU2V0fSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLnJpbmdQdHMubGVuZ3RoPD0zPyExOih0aGlzLmdldFJpbmcoKSx0aGlzLnJpbmcuaXNWYWxpZCgpKX0sYnVpbGQ6ZnVuY3Rpb24odCl7dmFyIGU9dDtkbyB0aGlzLmFkZChlKSxlLnNldFJpbmcodGhpcyksZT1lLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09ZSxcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShlPT09dHx8IWUuaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKTt3aGlsZShlIT09dCl9LGlzT3V0ZXJIb2xlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzSG9sZT8hdGhpcy5oYXNTaGVsbCgpOiExfSxnZXRQb2x5Z29uOmZ1bmN0aW9uKCl7dmFyIHQ9bnVsbDtpZihudWxsIT09dGhpcy5ob2xlcyl7dD1uZXcgQXJyYXkodGhpcy5ob2xlcy5zaXplKCkpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0aGlzLmhvbGVzLnNpemUoKTtlKyspdFtlXT10aGlzLmhvbGVzLmdldChlKX12YXIgbj10aGlzLmZhY3RvcnkuY3JlYXRlUG9seWdvbih0aGlzLnJpbmcsdCk7cmV0dXJuIG59LGlzSG9sZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc0hvbGV9LGlzUHJvY2Vzc2VkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX2lzUHJvY2Vzc2VkfSxhZGRIb2xlOmZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBidCl7dmFyIHQ9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmhvbGVzJiYodGhpcy5ob2xlcz1uZXcgSSksdGhpcy5ob2xlcy5hZGQodCl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIHdyKXt2YXIgZT1hcmd1bWVudHNbMF07ZS5zZXRTaGVsbCh0aGlzKTt2YXIgbj1lLmdldFJpbmcoKTtudWxsPT09dGhpcy5ob2xlcyYmKHRoaXMuaG9sZXM9bmV3IEkpLHRoaXMuaG9sZXMuYWRkKG4pfX0sc2V0SW5jbHVkZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNJbmNsdWRlZD10LHRoaXMuX2lzSW5jbHVkZWRTZXQ9ITB9LGdldE91dGVySG9sZTpmdW5jdGlvbigpe2lmKHRoaXMuaXNIb2xlKCkpcmV0dXJuIG51bGw7Zm9yKHZhciB0PTA7dDx0aGlzLmRlTGlzdC5zaXplKCk7dCsrKXt2YXIgZT10aGlzLmRlTGlzdC5nZXQodCksbj1lLmdldFN5bSgpLmdldFJpbmcoKTtpZihuLmlzT3V0ZXJIb2xlKCkpcmV0dXJuIG59cmV0dXJuIG51bGx9LGNvbXB1dGVIb2xlOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5nZXRSaW5nKCk7dGhpcy5faXNIb2xlPWhlLmlzQ0NXKHQuZ2V0Q29vcmRpbmF0ZXMoKSl9LGhhc1NoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnNoZWxsfSxpc091dGVyU2hlbGw6ZnVuY3Rpb24oKXtyZXR1cm4gbnVsbCE9PXRoaXMuZ2V0T3V0ZXJIb2xlKCl9LGdldExpbmVTdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRDb29yZGluYXRlcygpLHRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lU3RyaW5nKHRoaXMucmluZ1B0cyl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuIHNlLnRvTGluZVN0cmluZyhuZXcgR3QodGhpcy5nZXRDb29yZGluYXRlcygpKSl9LGdldFNoZWxsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXNIb2xlKCk/dGhpcy5zaGVsbDp0aGlzfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5kZUxpc3QuYWRkKHQpfSxnZXRSaW5nOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucmluZylyZXR1cm4gdGhpcy5yaW5nO3RoaXMuZ2V0Q29vcmRpbmF0ZXMoKSx0aGlzLnJpbmdQdHMubGVuZ3RoPDMmJkEub3V0LnByaW50bG4odGhpcy5yaW5nUHRzKTt0cnl7dGhpcy5yaW5nPXRoaXMuZmFjdG9yeS5jcmVhdGVMaW5lYXJSaW5nKHRoaXMucmluZ1B0cyl9Y2F0Y2godCl7aWYoISh0IGluc3RhbmNlb2YgUykpdGhyb3cgdDtBLm91dC5wcmludGxuKHRoaXMucmluZ1B0cyl9ZmluYWxseXt9cmV0dXJuIHRoaXMucmluZ30sdXBkYXRlSW5jbHVkZWQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzSG9sZSgpKXJldHVybiBudWxsO2Zvcih2YXIgdD0wO3Q8dGhpcy5kZUxpc3Quc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5kZUxpc3QuZ2V0KHQpLG49ZS5nZXRTeW0oKS5nZXRSaW5nKCkuZ2V0U2hlbGwoKTtpZihudWxsIT09biYmbi5pc0luY2x1ZGVkU2V0KCkpcmV0dXJuIHRoaXMuc2V0SW5jbHVkZWQoIW4uaXNJbmNsdWRlZCgpKSxudWxsfX0sc2V0U2hlbGw6ZnVuY3Rpb24odCl7dGhpcy5zaGVsbD10fSxzZXRQcm9jZXNzZWQ6ZnVuY3Rpb24odCl7dGhpcy5faXNQcm9jZXNzZWQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd3J9fSksd3IuZmluZERpckVkZ2VzSW5SaW5nPWZ1bmN0aW9uKHQpe3ZhciBlPXQsbj1uZXcgSTtkbyBuLmFkZChlKSxlPWUuZ2V0TmV4dCgpLGYuaXNUcnVlKG51bGwhPT1lLFwiZm91bmQgbnVsbCBERSBpbiByaW5nXCIpLGYuaXNUcnVlKGU9PT10fHwhZS5pc0luUmluZygpLFwiZm91bmQgREUgYWxyZWFkeSBpbiByaW5nXCIpO3doaWxlKGUhPT10KTtyZXR1cm4gbn0sd3IuYWRkRWRnZT1mdW5jdGlvbih0LGUsbil7aWYoZSlmb3IodmFyIGk9MDtpPHQubGVuZ3RoO2krKyluLmFkZCh0W2ldLCExKTtlbHNlIGZvcih2YXIgaT10Lmxlbmd0aC0xO2k+PTA7aS0tKW4uYWRkKHRbaV0sITEpfSx3ci5maW5kRWRnZVJpbmdDb250YWluaW5nPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0UmluZygpLGk9bi5nZXRFbnZlbG9wZUludGVybmFsKCkscj1uLmdldENvb3JkaW5hdGVOKDApLHM9bnVsbCxvPW51bGwsYT1lLml0ZXJhdG9yKCk7YS5oYXNOZXh0KCk7KXt2YXIgdT1hLm5leHQoKSxsPXUuZ2V0UmluZygpLGg9bC5nZXRFbnZlbG9wZUludGVybmFsKCk7aWYoIWguZXF1YWxzKGkpJiZoLmNvbnRhaW5zKGkpKXtyPUgucHROb3RJbkxpc3Qobi5nZXRDb29yZGluYXRlcygpLGwuZ2V0Q29vcmRpbmF0ZXMoKSk7dmFyIGM9ITE7aGUuaXNQb2ludEluUmluZyhyLGwuZ2V0Q29vcmRpbmF0ZXMoKSkmJihjPSEwKSxjJiYobnVsbD09PXN8fG8uY29udGFpbnMoaCkpJiYocz11LG89cy5nZXRSaW5nKCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX19cmV0dXJuIHN9LGUoTHIucHJvdG90eXBlLHtjb21wYXJlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dCxpPWU7cmV0dXJuIG4uZ2V0UmluZygpLmdldEVudmVsb3BlKCkuY29tcGFyZVRvKGkuZ2V0UmluZygpLmdldEVudmVsb3BlKCkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVyblthXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTHJ9fSksd3IuRW52ZWxvcGVDb21wYXJhdG9yPUxyLGgoUnIsRXIpLGUoUnIucHJvdG90eXBlLHtmaW5kRWRnZVJpbmc6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHdyKHRoaXMuZmFjdG9yeSk7cmV0dXJuIGUuYnVpbGQodCksZX0sY29tcHV0ZURlcHRoUGFyaXR5OmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKDs7KXt2YXIgdD1udWxsO2lmKG51bGw9PT10KXJldHVybiBudWxsO3RoaXMuY29tcHV0ZURlcHRoUGFyaXR5KHQpfWVsc2UgaWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2FyZ3VtZW50c1swXX19LGNvbXB1dGVOZXh0Q1dFZGdlczpmdW5jdGlvbigpe2Zvcih2YXIgdD10aGlzLm5vZGVJdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7UnIuY29tcHV0ZU5leHRDV0VkZ2VzKGUpfX0sYWRkRWRnZTpmdW5jdGlvbih0KXtpZih0LmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt2YXIgZT1ILnJlbW92ZVJlcGVhdGVkUG9pbnRzKHQuZ2V0Q29vcmRpbmF0ZXMoKSk7aWYoZS5sZW5ndGg8MilyZXR1cm4gbnVsbDt2YXIgbj1lWzBdLGk9ZVtlLmxlbmd0aC0xXSxyPXRoaXMuZ2V0Tm9kZShuKSxzPXRoaXMuZ2V0Tm9kZShpKSxvPW5ldyBDcihyLHMsZVsxXSwhMCksYT1uZXcgQ3IocyxyLGVbZS5sZW5ndGgtMl0sITEpLHU9bmV3IFNyKHQpO3Uuc2V0RGlyZWN0ZWRFZGdlcyhvLGEpLHRoaXMuYWRkKHUpfSxkZWxldGVDdXRFZGdlczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksUnIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5kaXJFZGdlcyk7Zm9yKHZhciB0PW5ldyBJLGU9dGhpcy5kaXJFZGdlcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7aWYoIW4uaXNNYXJrZWQoKSl7dmFyIGk9bi5nZXRTeW0oKTtpZihuLmdldExhYmVsKCk9PT1pLmdldExhYmVsKCkpe24uc2V0TWFya2VkKCEwKSxpLnNldE1hcmtlZCghMCk7dmFyIHI9bi5nZXRFZGdlKCk7dC5hZGQoci5nZXRMaW5lKCkpfX19cmV0dXJuIHR9LGdldEVkZ2VSaW5nczpmdW5jdGlvbigpe3RoaXMuY29tcHV0ZU5leHRDV0VkZ2VzKCksUnIubGFiZWwodGhpcy5kaXJFZGdlcywtMSk7dmFyIHQ9UnIuZmluZExhYmVsZWRFZGdlUmluZ3ModGhpcy5kaXJFZGdlcyk7dGhpcy5jb252ZXJ0TWF4aW1hbFRvTWluaW1hbEVkZ2VSaW5ncyh0KTtmb3IodmFyIGU9bmV3IEksbj10aGlzLmRpckVkZ2VzLml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtpZighaS5pc01hcmtlZCgpJiYhaS5pc0luUmluZygpKXt2YXIgcj10aGlzLmZpbmRFZGdlUmluZyhpKTtlLmFkZChyKX19cmV0dXJuIGV9LGdldE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5maW5kTm9kZSh0KTtyZXR1cm4gbnVsbD09PWUmJihlPW5ldyBtcih0KSx0aGlzLmFkZChlKSksZX0sY29udmVydE1heGltYWxUb01pbmltYWxFZGdlUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLHI9UnIuZmluZEludGVyc2VjdGlvbk5vZGVzKG4saSk7aWYobnVsbCE9PXIpZm9yKHZhciBzPXIuaXRlcmF0b3IoKTtzLmhhc05leHQoKTspe3ZhciBvPXMubmV4dCgpO1JyLmNvbXB1dGVOZXh0Q0NXRWRnZXMobyxpKX19fSxkZWxldGVEYW5nbGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMuZmluZE5vZGVzT2ZEZWdyZWUoMSksZT1uZXcgSixuPW5ldyBwZSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspbi5wdXNoKGkubmV4dCgpKTtmb3IoOyFuLmlzRW1wdHkoKTspe3ZhciByPW4ucG9wKCk7UnIuZGVsZXRlQWxsRWRnZXMocik7Zm9yKHZhciBzPXIuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLGk9cy5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIG89aS5uZXh0KCk7by5zZXRNYXJrZWQoITApO3ZhciBhPW8uZ2V0U3ltKCk7bnVsbCE9PWEmJmEuc2V0TWFya2VkKCEwKTt2YXIgdT1vLmdldEVkZ2UoKTtlLmFkZCh1LmdldExpbmUoKSk7dmFyIGw9by5nZXRUb05vZGUoKTsxPT09UnIuZ2V0RGVncmVlTm9uRGVsZXRlZChsKSYmbi5wdXNoKGwpfX1yZXR1cm4gZX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnJ9fSksUnIuZmluZExhYmVsZWRFZGdlUmluZ3M9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49MSxpPXQuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO2lmKCEoci5pc01hcmtlZCgpfHxyLmdldExhYmVsKCk+PTApKXtlLmFkZChyKTt2YXIgcz13ci5maW5kRGlyRWRnZXNJblJpbmcocik7UnIubGFiZWwocyxuKSxuKyt9fXJldHVybiBlfSxSci5nZXREZWdyZWVOb25EZWxldGVkPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxuPTAsaT1lLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzTWFya2VkKCl8fG4rK31yZXR1cm4gbn0sUnIuZGVsZXRlQWxsRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKS5nZXRFZGdlcygpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5zZXRNYXJrZWQoITApO3ZhciByPWkuZ2V0U3ltKCk7bnVsbCE9PXImJnIuc2V0TWFya2VkKCEwKX19LFJyLmxhYmVsPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuc2V0TGFiZWwoZSl9fSxSci5jb21wdXRlTmV4dENXRWRnZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0T3V0RWRnZXMoKSxuPW51bGwsaT1udWxsLHI9ZS5nZXRFZGdlcygpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZighcy5pc01hcmtlZCgpKXtpZihudWxsPT09biYmKG49cyksbnVsbCE9PWkpe3ZhciBvPWkuZ2V0U3ltKCk7by5zZXROZXh0KHMpfWk9c319aWYobnVsbCE9PWkpe3ZhciBvPWkuZ2V0U3ltKCk7by5zZXROZXh0KG4pfX0sUnIuY29tcHV0ZU5leHRDQ1dFZGdlcz1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE91dEVkZ2VzKCksaT1udWxsLHI9bnVsbCxzPW4uZ2V0RWRnZXMoKSxvPXMuc2l6ZSgpLTE7bz49MDtvLS0pe3ZhciBhPXMuZ2V0KG8pLHU9YS5nZXRTeW0oKSxsPW51bGw7YS5nZXRMYWJlbCgpPT09ZSYmKGw9YSk7dmFyIGg9bnVsbDt1LmdldExhYmVsKCk9PT1lJiYoaD11KSxudWxsPT09bCYmbnVsbD09PWh8fChudWxsIT09aCYmKHI9aCksbnVsbCE9PWwmJihudWxsIT09ciYmKHIuc2V0TmV4dChsKSxyPW51bGwpLG51bGw9PT1pJiYoaT1sKSkpfW51bGwhPT1yJiYoZi5pc1RydWUobnVsbCE9PWkpLHIuc2V0TmV4dChpKSl9LFJyLmdldERlZ3JlZT1mdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10LmdldE91dEVkZ2VzKCkuZ2V0RWRnZXMoKSxpPTAscj1uLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtzLmdldExhYmVsKCk9PT1lJiZpKyt9cmV0dXJuIGl9LFJyLmZpbmRJbnRlcnNlY3Rpb25Ob2Rlcz1mdW5jdGlvbih0LGUpe3ZhciBuPXQsaT1udWxsO2Rve3ZhciByPW4uZ2V0RnJvbU5vZGUoKTtSci5nZXREZWdyZWUocixlKT4xJiYobnVsbD09PWkmJihpPW5ldyBJKSxpLmFkZChyKSksbj1uLmdldE5leHQoKSxmLmlzVHJ1ZShudWxsIT09bixcImZvdW5kIG51bGwgREUgaW4gcmluZ1wiKSxmLmlzVHJ1ZShuPT09dHx8IW4uaXNJblJpbmcoKSxcImZvdW5kIERFIGFscmVhZHkgaW4gcmluZ1wiKX13aGlsZShuIT09dCk7cmV0dXJuIGl9LGUoVHIucHJvdG90eXBlLHtnZXRHZW9tZXRyeTpmdW5jdGlvbigpe3JldHVybiBudWxsPT09dGhpcy5nZW9tRmFjdG9yeSYmKHRoaXMuZ2VvbUZhY3Rvcnk9bmV3IGllKSx0aGlzLnBvbHlnb25pemUoKSx0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsP3RoaXMuZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeSh0aGlzLnBvbHlMaXN0KTp0aGlzLmdlb21GYWN0b3J5LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkodGhpcy5wb2x5TGlzdCkpfSxnZXRJbnZhbGlkUmluZ0xpbmVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuaW52YWxpZFJpbmdMaW5lc30sZmluZFZhbGlkUmluZ3M6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10Lml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtyLmlzVmFsaWQoKT9lLmFkZChyKTpuLmFkZChyLmdldExpbmVTdHJpbmcoKSl9fSxwb2x5Z29uaXplOmZ1bmN0aW9uKCl7aWYobnVsbCE9PXRoaXMucG9seUxpc3QpcmV0dXJuIG51bGw7aWYodGhpcy5wb2x5TGlzdD1uZXcgSSxudWxsPT09dGhpcy5ncmFwaClyZXR1cm4gbnVsbDt0aGlzLmRhbmdsZXM9dGhpcy5ncmFwaC5kZWxldGVEYW5nbGVzKCksdGhpcy5jdXRFZGdlcz10aGlzLmdyYXBoLmRlbGV0ZUN1dEVkZ2VzKCk7dmFyIHQ9dGhpcy5ncmFwaC5nZXRFZGdlUmluZ3MoKSxlPW5ldyBJO3RoaXMuaW52YWxpZFJpbmdMaW5lcz1uZXcgSSx0aGlzLmlzQ2hlY2tpbmdSaW5nc1ZhbGlkP3RoaXMuZmluZFZhbGlkUmluZ3ModCxlLHRoaXMuaW52YWxpZFJpbmdMaW5lcyk6ZT10LHRoaXMuZmluZFNoZWxsc0FuZEhvbGVzKGUpLFRyLmFzc2lnbkhvbGVzVG9TaGVsbHModGhpcy5ob2xlTGlzdCx0aGlzLnNoZWxsTGlzdCksaG8uc29ydCh0aGlzLnNoZWxsTGlzdCxuZXcgd3IuRW52ZWxvcGVDb21wYXJhdG9yKTt2YXIgbj0hMDt0aGlzLmV4dHJhY3RPbmx5UG9seWdvbmFsJiYoVHIuZmluZERpc2pvaW50U2hlbGxzKHRoaXMuc2hlbGxMaXN0KSxuPSExKSx0aGlzLnBvbHlMaXN0PVRyLmV4dHJhY3RQb2x5Z29ucyh0aGlzLnNoZWxsTGlzdCxuKX0sZ2V0RGFuZ2xlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBvbHlnb25pemUoKSx0aGlzLmRhbmdsZXN9LGdldEN1dEVkZ2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMuY3V0RWRnZXN9LGdldFBvbHlnb25zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucG9seWdvbml6ZSgpLHRoaXMucG9seUxpc3R9LGFkZDpmdW5jdGlvbigpe2lmKFIoYXJndW1lbnRzWzBdLHYpKWZvcih2YXIgdD1hcmd1bWVudHNbMF0sZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmFkZChuKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLmdlb21GYWN0b3J5PWkuZ2V0RmFjdG9yeSgpLG51bGw9PT10aGlzLmdyYXBoJiYodGhpcy5ncmFwaD1uZXcgUnIodGhpcy5nZW9tRmFjdG9yeSkpLHRoaXMuZ3JhcGguYWRkRWRnZShpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHI9YXJndW1lbnRzWzBdO3IuYXBwbHkodGhpcy5saW5lU3RyaW5nQWRkZXIpfX0sc2V0Q2hlY2tSaW5nc1ZhbGlkOmZ1bmN0aW9uKHQpe3RoaXMuaXNDaGVja2luZ1JpbmdzVmFsaWQ9dH0sZmluZFNoZWxsc0FuZEhvbGVzOmZ1bmN0aW9uKHQpe3RoaXMuaG9sZUxpc3Q9bmV3IEksdGhpcy5zaGVsbExpc3Q9bmV3IEk7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uY29tcHV0ZUhvbGUoKSxuLmlzSG9sZSgpP3RoaXMuaG9sZUxpc3QuYWRkKG4pOnRoaXMuc2hlbGxMaXN0LmFkZChuKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFRyfX0pLFRyLmZpbmRPdXRlclNoZWxscz1mdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCksaT1uLmdldE91dGVySG9sZSgpO251bGw9PT1pfHxpLmlzUHJvY2Vzc2VkKCl8fChuLnNldEluY2x1ZGVkKCEwKSxpLnNldFByb2Nlc3NlZCghMCkpfX0sVHIuZXh0cmFjdFBvbHlnb25zPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPW5ldyBJLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7KGV8fHIuaXNJbmNsdWRlZCgpKSYmbi5hZGQoci5nZXRQb2x5Z29uKCkpfXJldHVybiBufSxUci5hc3NpZ25Ib2xlc1RvU2hlbGxzPWZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO1RyLmFzc2lnbkhvbGVUb1NoZWxsKGksZSl9fSxUci5hc3NpZ25Ib2xlVG9TaGVsbD1mdW5jdGlvbih0LGUpe3ZhciBuPXdyLmZpbmRFZGdlUmluZ0NvbnRhaW5pbmcodCxlKTtudWxsIT09biYmbi5hZGRIb2xlKHQpfSxUci5maW5kRGlzam9pbnRTaGVsbHM9ZnVuY3Rpb24odCl7VHIuZmluZE91dGVyU2hlbGxzKHQpO3ZhciBlPW51bGw7ZG97ZT0hMTtmb3IodmFyIG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aS5pc0luY2x1ZGVkU2V0KCl8fChpLnVwZGF0ZUluY2x1ZGVkKCksaS5pc0luY2x1ZGVkU2V0KCl8fChlPSEwKSl9fXdoaWxlKGUpfSxlKFByLnByb3RvdHlwZSx7ZmlsdGVyOmZ1bmN0aW9uKHQpe3QgaW5zdGFuY2VvZiBTdCYmdGhpcy5wLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFByfX0pLFRyLkxpbmVTdHJpbmdBZGRlcj1Qcjt2YXIgUm89T2JqZWN0LmZyZWV6ZSh7UG9seWdvbml6ZXI6VHJ9KTtlKGJyLnByb3RvdHlwZSx7Y3JlYXRlRWRnZUVuZEZvck5leHQ6ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9bi5zZWdtZW50SW5kZXgrMTtpZihyPj10LmdldE51bVBvaW50cygpJiZudWxsPT09aSlyZXR1cm4gbnVsbDt2YXIgcz10LmdldENvb3JkaW5hdGUocik7bnVsbCE9PWkmJmkuc2VnbWVudEluZGV4PT09bi5zZWdtZW50SW5kZXgmJihzPWkuY29vcmQpO3ZhciBvPW5ldyBFbih0LG4uY29vcmQscyxuZXcgZ24odC5nZXRMYWJlbCgpKSk7ZS5hZGQobyl9LGNyZWF0ZUVkZ2VFbmRGb3JQcmV2OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPW4uc2VnbWVudEluZGV4O2lmKDA9PT1uLmRpc3Qpe2lmKDA9PT1yKXJldHVybiBudWxsO3ItLX12YXIgcz10LmdldENvb3JkaW5hdGUocik7bnVsbCE9PWkmJmkuc2VnbWVudEluZGV4Pj1yJiYocz1pLmNvb3JkKTt2YXIgbz1uZXcgZ24odC5nZXRMYWJlbCgpKTtvLmZsaXAoKTt2YXIgYT1uZXcgRW4odCxuLmNvb3JkLHMsbyk7ZS5hZGQoYSl9LGNvbXB1dGVFZGdlRW5kczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9bmV3IEksbj10O24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dGhpcy5jb21wdXRlRWRnZUVuZHMoaSxlKX1yZXR1cm4gZX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89ci5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpO28uYWRkRW5kcG9pbnRzKCk7dmFyIGE9by5pdGVyYXRvcigpLHU9bnVsbCxsPW51bGw7aWYoIWEuaGFzTmV4dCgpKXJldHVybiBudWxsO3ZhciBoPWEubmV4dCgpO2RvIHU9bCxsPWgsaD1udWxsLGEuaGFzTmV4dCgpJiYoaD1hLm5leHQoKSksbnVsbCE9PWwmJih0aGlzLmNyZWF0ZUVkZ2VFbmRGb3JQcmV2KHIscyxsLHUpLHRoaXMuY3JlYXRlRWRnZUVuZEZvck5leHQocixzLGwsaCkpO3doaWxlKG51bGwhPT1sKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGJyfX0pLGgoT3IsRW4pLGUoT3IucHJvdG90eXBlLHtpbnNlcnQ6ZnVuY3Rpb24odCl7dGhpcy5lZGdlRW5kcy5hZGQodCl9LHByaW50OmZ1bmN0aW9uKHQpe3QucHJpbnRsbihcIkVkZ2VFbmRCdW5kbGUtLT4gTGFiZWw6IFwiK3RoaXMubGFiZWwpO2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnByaW50KHQpLHQucHJpbnRsbigpfX0saXRlcmF0b3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5lZGdlRW5kcy5pdGVyYXRvcigpfSxnZXRFZGdlRW5kczpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVkZ2VFbmRzfSxjb21wdXRlTGFiZWxPbjpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wLGk9ITEscj10aGlzLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXMuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbih0KTtvPT09TC5CT1VOREFSWSYmbisrLG89PT1MLklOVEVSSU9SJiYoaT0hMCl9dmFyIG89TC5OT05FO2kmJihvPUwuSU5URVJJT1IpLG4+MCYmKG89JG4uZGV0ZXJtaW5lQm91bmRhcnkoZSxuKSksdGhpcy5sYWJlbC5zZXRMb2NhdGlvbih0LG8pfSxjb21wdXRlTGFiZWxTaWRlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuZ2V0TGFiZWwoKS5pc0FyZWEoKSl7dmFyIHI9aS5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQsZSk7aWYocj09PUwuSU5URVJJT1IpcmV0dXJuIHRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxlLEwuSU5URVJJT1IpLG51bGw7cj09PUwuRVhURVJJT1ImJnRoaXMubGFiZWwuc2V0TG9jYXRpb24odCxlLEwuRVhURVJJT1IpfX19LGdldExhYmVsOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGFiZWx9LGNvbXB1dGVMYWJlbFNpZGVzOmZ1bmN0aW9uKHQpe3RoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LGNuLkxFRlQpLHRoaXMuY29tcHV0ZUxhYmVsU2lkZSh0LGNuLlJJR0hUKX0sdXBkYXRlSU06ZnVuY3Rpb24odCl7Sm4udXBkYXRlSU0odGhpcy5sYWJlbCx0KX0sY29tcHV0ZUxhYmVsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0hMSxuPXRoaXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuZ2V0TGFiZWwoKS5pc0FyZWEoKSYmKGU9ITApfWU/dGhpcy5sYWJlbD1uZXcgZ24oTC5OT05FLEwuTk9ORSxMLk5PTkUpOnRoaXMubGFiZWw9bmV3IGduKEwuTk9ORSk7Zm9yKHZhciByPTA7Mj5yO3IrKyl0aGlzLmNvbXB1dGVMYWJlbE9uKHIsdCksZSYmdGhpcy5jb21wdXRlTGFiZWxTaWRlcyhyKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gT3J9fSksaChfcixQbiksZShfci5wcm90b3R5cGUse3VwZGF0ZUlNOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtuLnVwZGF0ZUlNKHQpfX0saW5zZXJ0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuZWRnZU1hcC5nZXQodCk7bnVsbD09PWU/KGU9bmV3IE9yKHQpLHRoaXMuaW5zZXJ0RWRnZUVuZCh0LGUpKTplLmluc2VydCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3J9fSksaChNcix5biksZShNci5wcm90b3R5cGUse3VwZGF0ZUlNRnJvbUVkZ2VzOmZ1bmN0aW9uKHQpe3RoaXMuZWRnZXMudXBkYXRlSU0odCl9LGNvbXB1dGVJTTpmdW5jdGlvbih0KXt0LnNldEF0TGVhc3RJZlZhbGlkKHRoaXMubGFiZWwuZ2V0TG9jYXRpb24oMCksdGhpcy5sYWJlbC5nZXRMb2NhdGlvbigxKSwwKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTXJ9fSksaChEcixObiksZShEci5wcm90b3R5cGUse2NyZWF0ZU5vZGU6ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBNcih0LG5ldyBfcil9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIERyfX0pLGUoQXIucHJvdG90eXBlLHtpbnNlcnRFZGdlRW5kczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5ub2Rlcy5hZGQobil9fSxjb21wdXRlUHJvcGVySW50ZXJzZWN0aW9uSU06ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLmdldERpbWVuc2lvbigpLGk9dGhpcy5hcmdbMV0uZ2V0R2VvbWV0cnkoKS5nZXREaW1lbnNpb24oKSxyPXQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCkscz10Lmhhc1Byb3BlckludGVyaW9ySW50ZXJzZWN0aW9uKCk7Mj09PW4mJjI9PT1pP3ImJmUuc2V0QXRMZWFzdChcIjIxMjEwMTIxMlwiKToyPT09biYmMT09PWk/KHImJmUuc2V0QXRMZWFzdChcIkZGRjBGRkZGMlwiKSxzJiZlLnNldEF0TGVhc3QoXCIxRkZGRkYxRkZcIikpOjE9PT1uJiYyPT09aT8ociYmZS5zZXRBdExlYXN0KFwiRjBGRkZGRkYyXCIpLHMmJmUuc2V0QXRMZWFzdChcIjFGMUZGRkZGRlwiKSk6MT09PW4mJjE9PT1pJiZzJiZlLnNldEF0TGVhc3QoXCIwRkZGRkZGRkZcIil9LGxhYmVsSXNvbGF0ZWRFZGdlczpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2kuaXNJc29sYXRlZCgpJiYodGhpcy5sYWJlbElzb2xhdGVkRWRnZShpLGUsdGhpcy5hcmdbZV0uZ2V0R2VvbWV0cnkoKSksdGhpcy5pc29sYXRlZEVkZ2VzLmFkZChpKSl9fSxsYWJlbElzb2xhdGVkRWRnZTpmdW5jdGlvbih0LGUsbil7aWYobi5nZXREaW1lbnNpb24oKT4wKXt2YXIgaT10aGlzLnB0TG9jYXRvci5sb2NhdGUodC5nZXRDb29yZGluYXRlKCksbik7dC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLGkpfWVsc2UgdC5nZXRMYWJlbCgpLnNldEFsbExvY2F0aW9ucyhlLEwuRVhURVJJT1IpfSxjb21wdXRlSU06ZnVuY3Rpb24oKXt2YXIgdD1uZXcgZmU7aWYodC5zZXQoTC5FWFRFUklPUixMLkVYVEVSSU9SLDIpLCF0aGlzLmFyZ1swXS5nZXRHZW9tZXRyeSgpLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCkuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSlyZXR1cm4gdGhpcy5jb21wdXRlRGlzam9pbnRJTSh0KSx0O3RoaXMuYXJnWzBdLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMSksdGhpcy5hcmdbMV0uY29tcHV0ZVNlbGZOb2Rlcyh0aGlzLmxpLCExKTt2YXIgZT10aGlzLmFyZ1swXS5jb21wdXRlRWRnZUludGVyc2VjdGlvbnModGhpcy5hcmdbMV0sdGhpcy5saSwhMSk7dGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMCksdGhpcy5jb21wdXRlSW50ZXJzZWN0aW9uTm9kZXMoMSksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMCksdGhpcy5jb3B5Tm9kZXNBbmRMYWJlbHMoMSksdGhpcy5sYWJlbElzb2xhdGVkTm9kZXMoKSx0aGlzLmNvbXB1dGVQcm9wZXJJbnRlcnNlY3Rpb25JTShlLHQpO3ZhciBuPW5ldyBicixpPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuYXJnWzBdLmdldEVkZ2VJdGVyYXRvcigpKTt0aGlzLmluc2VydEVkZ2VFbmRzKGkpO3ZhciByPW4uY29tcHV0ZUVkZ2VFbmRzKHRoaXMuYXJnWzFdLmdldEVkZ2VJdGVyYXRvcigpKTtyZXR1cm4gdGhpcy5pbnNlcnRFZGdlRW5kcyhyKSx0aGlzLmxhYmVsTm9kZUVkZ2VzKCksdGhpcy5sYWJlbElzb2xhdGVkRWRnZXMoMCwxKSx0aGlzLmxhYmVsSXNvbGF0ZWRFZGdlcygxLDApLHRoaXMudXBkYXRlSU0odCksdH0sbGFiZWxOb2RlRWRnZXM6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2Rlcy5pdGVyYXRvcigpO3QuaGFzTmV4dCgpOyl7dmFyIGU9dC5uZXh0KCk7ZS5nZXRFZGdlcygpLmNvbXB1dGVMYWJlbGxpbmcodGhpcy5hcmcpfX0sY29weU5vZGVzQW5kTGFiZWxzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXROb2RlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpLGk9dGhpcy5ub2Rlcy5hZGROb2RlKG4uZ2V0Q29vcmRpbmF0ZSgpKTtpLnNldExhYmVsKHQsbi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpKX19LGxhYmVsSW50ZXJzZWN0aW9uTm9kZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuYXJnW3RdLmdldEVkZ2VJdGVyYXRvcigpO2UuaGFzTmV4dCgpOylmb3IodmFyIG49ZS5uZXh0KCksaT1uLmdldExhYmVsKCkuZ2V0TG9jYXRpb24odCkscj1uLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5ub2Rlcy5maW5kKHMuY29vcmQpO28uZ2V0TGFiZWwoKS5pc051bGwodCkmJihpPT09TC5CT1VOREFSWT9vLnNldExhYmVsQm91bmRhcnkodCk6by5zZXRMYWJlbCh0LEwuSU5URVJJT1IpKX19LGxhYmVsSXNvbGF0ZWROb2RlOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5wdExvY2F0b3IubG9jYXRlKHQuZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuYXJnW2VdLmdldEdlb21ldHJ5KCkpO3QuZ2V0TGFiZWwoKS5zZXRBbGxMb2NhdGlvbnMoZSxuKX0sY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmFyZ1t0XS5nZXRFZGdlSXRlcmF0b3IoKTtlLmhhc05leHQoKTspZm9yKHZhciBuPWUubmV4dCgpLGk9bi5nZXRMYWJlbCgpLmdldExvY2F0aW9uKHQpLHI9bi5nZXRFZGdlSW50ZXJzZWN0aW9uTGlzdCgpLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKSxvPXRoaXMubm9kZXMuYWRkTm9kZShzLmNvb3JkKTtpPT09TC5CT1VOREFSWT9vLnNldExhYmVsQm91bmRhcnkodCk6by5nZXRMYWJlbCgpLmlzTnVsbCh0KSYmby5zZXRMYWJlbCh0LEwuSU5URVJJT1IpfX0sbGFiZWxJc29sYXRlZE5vZGVzOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PXRoaXMubm9kZXMuaXRlcmF0b3IoKTt0Lmhhc05leHQoKTspe3ZhciBlPXQubmV4dCgpLG49ZS5nZXRMYWJlbCgpO2YuaXNUcnVlKG4uZ2V0R2VvbWV0cnlDb3VudCgpPjAsXCJub2RlIHdpdGggZW1wdHkgbGFiZWwgZm91bmRcIiksZS5pc0lzb2xhdGVkKCkmJihuLmlzTnVsbCgwKT90aGlzLmxhYmVsSXNvbGF0ZWROb2RlKGUsMCk6dGhpcy5sYWJlbElzb2xhdGVkTm9kZShlLDEpKX19LHVwZGF0ZUlNOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLmlzb2xhdGVkRWRnZXMuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24udXBkYXRlSU0odCl9Zm9yKHZhciBpPXRoaXMubm9kZXMuaXRlcmF0b3IoKTtpLmhhc05leHQoKTspe3ZhciByPWkubmV4dCgpO3IudXBkYXRlSU0odCksci51cGRhdGVJTUZyb21FZGdlcyh0KX19LGNvbXB1dGVEaXNqb2ludElNOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuYXJnWzBdLmdldEdlb21ldHJ5KCk7ZS5pc0VtcHR5KCl8fCh0LnNldChMLklOVEVSSU9SLEwuRVhURVJJT1IsZS5nZXREaW1lbnNpb24oKSksdC5zZXQoTC5CT1VOREFSWSxMLkVYVEVSSU9SLGUuZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpO3ZhciBuPXRoaXMuYXJnWzFdLmdldEdlb21ldHJ5KCk7bi5pc0VtcHR5KCl8fCh0LnNldChMLkVYVEVSSU9SLEwuSU5URVJJT1Isbi5nZXREaW1lbnNpb24oKSksdC5zZXQoTC5FWFRFUklPUixMLkJPVU5EQVJZLG4uZ2V0Qm91bmRhcnlEaW1lbnNpb24oKSkpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBBcn19KSxlKEZyLnByb3RvdHlwZSx7aXNDb250YWluZWRJbkJvdW5kYXJ5OmZ1bmN0aW9uKHQpe2lmKHQgaW5zdGFuY2VvZiBUdClyZXR1cm4hMTtpZih0IGluc3RhbmNlb2YgTHQpcmV0dXJuIHRoaXMuaXNQb2ludENvbnRhaW5lZEluQm91bmRhcnkodCk7aWYodCBpbnN0YW5jZW9mIFN0KXJldHVybiB0aGlzLmlzTGluZVN0cmluZ0NvbnRhaW5lZEluQm91bmRhcnkodCk7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUdlb21ldHJpZXMoKTtlKyspe3ZhciBuPXQuZ2V0R2VvbWV0cnlOKGUpO2lmKCF0aGlzLmlzQ29udGFpbmVkSW5Cb3VuZGFyeShuKSlyZXR1cm4hMX1yZXR1cm4hMH0saXNMaW5lU2VnbWVudENvbnRhaW5lZEluQm91bmRhcnk6ZnVuY3Rpb24odCxlKXtpZih0LmVxdWFscyhlKSlyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0KTtpZih0Lng9PT1lLngpe2lmKHQueD09PXRoaXMucmVjdEVudi5nZXRNaW5YKCl8fHQueD09PXRoaXMucmVjdEVudi5nZXRNYXhYKCkpcmV0dXJuITB9ZWxzZSBpZih0Lnk9PT1lLnkmJih0Lnk9PT10aGlzLnJlY3RFbnYuZ2V0TWluWSgpfHx0Lnk9PT10aGlzLnJlY3RFbnYuZ2V0TWF4WSgpKSlyZXR1cm4hMDtyZXR1cm4hMX0saXNMaW5lU3RyaW5nQ29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPW5ldyBnLGk9bmV3IGcscj0wO3I8ZS5zaXplKCktMTtyKyspaWYoZS5nZXRDb29yZGluYXRlKHIsbiksZS5nZXRDb29yZGluYXRlKHIrMSxpKSwhdGhpcy5pc0xpbmVTZWdtZW50Q29udGFpbmVkSW5Cb3VuZGFyeShuLGkpKXJldHVybiExO3JldHVybiEwfSxpc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeTpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgTHQpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5pc1BvaW50Q29udGFpbmVkSW5Cb3VuZGFyeSh0LmdldENvb3JkaW5hdGUoKSl9aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBnKXt2YXIgZT1hcmd1bWVudHNbMF07cmV0dXJuIGUueD09PXRoaXMucmVjdEVudi5nZXRNaW5YKCl8fGUueD09PXRoaXMucmVjdEVudi5nZXRNYXhYKCl8fGUueT09PXRoaXMucmVjdEVudi5nZXRNaW5ZKCl8fGUueT09PXRoaXMucmVjdEVudi5nZXRNYXhZKCl9fSxjb250YWluczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5yZWN0RW52LmNvbnRhaW5zKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT8hdGhpcy5pc0NvbnRhaW5lZEluQm91bmRhcnkodCk6ITF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEZyfX0pLEZyLmNvbnRhaW5zPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEZyKHQpO3JldHVybiBuLmNvbnRhaW5zKGUpfSxlKEdyLnByb3RvdHlwZSx7aW50ZXJzZWN0czpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBDKHQsZSk7aWYoIXRoaXMucmVjdEVudi5pbnRlcnNlY3RzKG4pKXJldHVybiExO2lmKHRoaXMucmVjdEVudi5pbnRlcnNlY3RzKHQpKXJldHVybiEwO2lmKHRoaXMucmVjdEVudi5pbnRlcnNlY3RzKGUpKXJldHVybiEwO2lmKHQuY29tcGFyZVRvKGUpPjApe3ZhciBpPXQ7dD1lLGU9aX12YXIgcj0hMTtyZXR1cm4gZS55PnQueSYmKHI9ITApLHI/dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmRpYWdEb3duMCx0aGlzLmRpYWdEb3duMSk6dGhpcy5saS5jb21wdXRlSW50ZXJzZWN0aW9uKHQsZSx0aGlzLmRpYWdVcDAsdGhpcy5kaWFnVXAxKSwhIXRoaXMubGkuaGFzSW50ZXJzZWN0aW9uKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEdyfX0pLGUocXIucHJvdG90eXBlLHthcHBseVRvOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT0wO2U8dC5nZXROdW1HZW9tZXRyaWVzKCkmJiF0aGlzLl9pc0RvbmU7ZSsrKXt2YXIgbj10LmdldEdlb21ldHJ5TihlKTtpZihuIGluc3RhbmNlb2YgZnQpdGhpcy5hcHBseVRvKG4pO2Vsc2UgaWYodGhpcy52aXNpdChuKSx0aGlzLmlzRG9uZSgpKXJldHVybiB0aGlzLl9pc0RvbmU9ITAsbnVsbH19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHFyfX0pLGUoQnIucHJvdG90eXBlLHtpbnRlcnNlY3RzOmZ1bmN0aW9uKHQpe2lmKCF0aGlzLnJlY3RFbnYuaW50ZXJzZWN0cyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSkpcmV0dXJuITE7dmFyIGU9bmV3IHpyKHRoaXMucmVjdEVudik7aWYoZS5hcHBseVRvKHQpLGUuaW50ZXJzZWN0cygpKXJldHVybiEwO3ZhciBuPW5ldyBWcih0aGlzLnJlY3RhbmdsZSk7aWYobi5hcHBseVRvKHQpLG4uY29udGFpbnNQb2ludCgpKXJldHVybiEwO3ZhciBpPW5ldyBrcih0aGlzLnJlY3RhbmdsZSk7cmV0dXJuIGkuYXBwbHlUbyh0KSwhIWkuaW50ZXJzZWN0cygpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBCcn19KSxCci5pbnRlcnNlY3RzPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IEJyKHQpO3JldHVybiBuLmludGVyc2VjdHMoZSl9LGgoenIscXIpLGUoenIucHJvdG90eXBlLHtpc0RvbmU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0cz09PSEwfSx2aXNpdDpmdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtyZXR1cm4gdGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSk/dGhpcy5yZWN0RW52LmNvbnRhaW5zKGUpPyh0aGlzLl9pbnRlcnNlY3RzPSEwLG51bGwpOmUuZ2V0TWluWCgpPj10aGlzLnJlY3RFbnYuZ2V0TWluWCgpJiZlLmdldE1heFgoKTw9dGhpcy5yZWN0RW52LmdldE1heFgoKT8odGhpcy5faW50ZXJzZWN0cz0hMCxudWxsKTplLmdldE1pblkoKT49dGhpcy5yZWN0RW52LmdldE1pblkoKSYmZS5nZXRNYXhZKCk8PXRoaXMucmVjdEVudi5nZXRNYXhZKCk/KHRoaXMuX2ludGVyc2VjdHM9ITAsbnVsbCk6dm9pZCAwOm51bGx9LGludGVyc2VjdHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5faW50ZXJzZWN0c30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4genJ9fSksaChWcixxciksZShWci5wcm90b3R5cGUse2lzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9jb250YWluc1BvaW50PT09ITB9LHZpc2l0OmZ1bmN0aW9uKHQpe2lmKCEodCBpbnN0YW5jZW9mIFR0KSlyZXR1cm4gbnVsbDt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7Zm9yKHZhciBuPW5ldyBnLGk9MDs0Pmk7aSsrKWlmKHRoaXMucmVjdFNlcS5nZXRDb29yZGluYXRlKGksbiksZS5jb250YWlucyhuKSYmVG4uY29udGFpbnNQb2ludEluUG9seWdvbihuLHQpKXJldHVybiB0aGlzLl9jb250YWluc1BvaW50PSEwLG51bGx9LGNvbnRhaW5zUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fY29udGFpbnNQb2ludH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVnJ9fSksaChrcixxciksZShrci5wcm90b3R5cGUse2ludGVyc2VjdHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5oYXNJbnRlcnNlY3Rpb259LGlzRG9uZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmhhc0ludGVyc2VjdGlvbj09PSEwfSx2aXNpdDpmdW5jdGlvbih0KXt2YXIgZT10LmdldEVudmVsb3BlSW50ZXJuYWwoKTtpZighdGhpcy5yZWN0RW52LmludGVyc2VjdHMoZSkpcmV0dXJuIG51bGw7dmFyIG49a24uZ2V0TGluZXModCk7dGhpcy5jaGVja0ludGVyc2VjdGlvbldpdGhMaW5lU3RyaW5ncyhuKX0sY2hlY2tJbnRlcnNlY3Rpb25XaXRoTGluZVN0cmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO2lmKHRoaXMuY2hlY2tJbnRlcnNlY3Rpb25XaXRoU2VnbWVudHMobiksdGhpcy5oYXNJbnRlcnNlY3Rpb24pcmV0dXJuIG51bGx9fSxjaGVja0ludGVyc2VjdGlvbldpdGhTZWdtZW50czpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5nZXRDb29yZGluYXRlU2VxdWVuY2UoKSxuPTE7bjxlLnNpemUoKTtuKyspaWYoZS5nZXRDb29yZGluYXRlKG4tMSx0aGlzLnAwKSxlLmdldENvb3JkaW5hdGUobix0aGlzLnAxKSx0aGlzLnJlY3RJbnRlcnNlY3Rvci5pbnRlcnNlY3RzKHRoaXMucDAsdGhpcy5wMSkpcmV0dXJuIHRoaXMuaGFzSW50ZXJzZWN0aW9uPSEwLG51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtyfX0pLGgoWXIsdGkpLGUoWXIucHJvdG90eXBlLHtnZXRJbnRlcnNlY3Rpb25NYXRyaXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcmVsYXRlLmNvbXB1dGVJTSgpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBZcn19KSxZci5jb3ZlcnM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY292ZXJzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT90LmlzUmVjdGFuZ2xlKCk/ITA6WXIucmVsYXRlKHQsZSkuaXNDb3ZlcnMoKTohMX0sWXIuaW50ZXJzZWN0cz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT90LmlzUmVjdGFuZ2xlKCk/QnIuaW50ZXJzZWN0cyh0LGUpOmUuaXNSZWN0YW5nbGUoKT9Cci5pbnRlcnNlY3RzKGUsdCk6WXIucmVsYXRlKHQsZSkuaXNJbnRlcnNlY3RzKCk6ITF9LFlyLnRvdWNoZXM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuaW50ZXJzZWN0cyhlLmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHQsZSkuaXNUb3VjaGVzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk6ITF9LFlyLndpdGhpbj1mdW5jdGlvbih0LGUpe3JldHVybiBlLmNvbnRhaW5zKHQpfSxZci5jb3ZlcmVkQnk9ZnVuY3Rpb24odCxlKXtyZXR1cm4gWXIuY292ZXJzKGUsdCl9LFlyLnJlbGF0ZT1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgWXIodCxlKSxpPW4uZ2V0SW50ZXJzZWN0aW9uTWF0cml4KCk7cmV0dXJuIGl9aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFwic3RyaW5nXCI9PXR5cGVvZiBhcmd1bWVudHNbMl0mJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBCKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV0sbz1hcmd1bWVudHNbMl07cmV0dXJuIFlyLnJlbGF0ZVdpdGhDaGVjayhyLHMpLm1hdGNoZXMobyl9aWYoUihhcmd1bWVudHNbMl0sVikmJmFyZ3VtZW50c1swXWluc3RhbmNlb2YgQiYmYXJndW1lbnRzWzFdaW5zdGFuY2VvZiBCKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0sbj1uZXcgWXIoYSx1LGwpLGk9bi5nZXRJbnRlcnNlY3Rpb25NYXRyaXgoKTtyZXR1cm4gaX19fSxZci5vdmVybGFwcz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9Zci5yZWxhdGUodCxlKS5pc092ZXJsYXBzKHQuZ2V0RGltZW5zaW9uKCksZS5nZXREaW1lbnNpb24oKSk6ITF9LFlyLmRpc2pvaW50PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIXQuaW50ZXJzZWN0cyhlKX0sWXIucmVsYXRlV2l0aENoZWNrPWZ1bmN0aW9uKHQsZSl7cmV0dXJuIHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksdC5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbihlKSxZci5yZWxhdGUodCxlKX0sWXIuY3Jvc3Nlcz1mdW5jdGlvbih0LGUpe3JldHVybiB0LmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKT9Zci5yZWxhdGUodCxlKS5pc0Nyb3NzZXModC5nZXREaW1lbnNpb24oKSxlLmdldERpbWVuc2lvbigpKTohMX0sWXIuY29udGFpbnM9ZnVuY3Rpb24odCxlKXtyZXR1cm4gdC5nZXRFbnZlbG9wZUludGVybmFsKCkuY29udGFpbnMoZS5nZXRFbnZlbG9wZUludGVybmFsKCkpP3QuaXNSZWN0YW5nbGUoKT9Gci5jb250YWlucyh0LGUpOllyLnJlbGF0ZSh0LGUpLmlzQ29udGFpbnMoKTohMX07dmFyIFRvPU9iamVjdC5mcmVlemUoe1JlbGF0ZU9wOllyfSk7ZShVci5wcm90b3R5cGUse2V4dHJhY3RFbGVtZW50czpmdW5jdGlvbih0LGUpe2lmKG51bGw9PT10KXJldHVybiBudWxsO2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKXt2YXIgaT10LmdldEdlb21ldHJ5TihuKTt0aGlzLnNraXBFbXB0eSYmaS5pc0VtcHR5KCl8fGUuYWRkKGkpfX0sY29tYmluZTpmdW5jdGlvbigpe2Zvcih2YXIgdD1uZXcgSSxlPXRoaXMuaW5wdXRHZW9tcy5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5leHRyYWN0RWxlbWVudHMobix0KX1yZXR1cm4gMD09PXQuc2l6ZSgpP251bGwhPT10aGlzLmdlb21GYWN0b3J5P3RoaXMuZ2VvbUZhY3RvcnkuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG51bGwpOm51bGw6dGhpcy5nZW9tRmFjdG9yeS5idWlsZEdlb21ldHJ5KHQpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVcn19KSxVci5jb21iaW5lPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPW5ldyBVcih0KTtyZXR1cm4gZS5jb21iaW5lKCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW5ldyBVcihVci5jcmVhdGVMaXN0KG4saSkpO3JldHVybiBlLmNvbWJpbmUoKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHI9YXJndW1lbnRzWzBdLHM9YXJndW1lbnRzWzFdLG89YXJndW1lbnRzWzJdLGU9bmV3IFVyKFVyLmNyZWF0ZUxpc3QocixzLG8pKTtyZXR1cm4gZS5jb21iaW5lKCl9fSxVci5leHRyYWN0RmFjdG9yeT1mdW5jdGlvbih0KXtyZXR1cm4gdC5pc0VtcHR5KCk/bnVsbDp0Lml0ZXJhdG9yKCkubmV4dCgpLmdldEZhY3RvcnkoKX0sVXIuY3JlYXRlTGlzdD1mdW5jdGlvbigpe2lmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1hcmd1bWVudHNbMV0sbj1uZXcgSTtyZXR1cm4gbi5hZGQodCksbi5hZGQoZSksbn1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdLG49bmV3IEk7cmV0dXJuIG4uYWRkKGkpLG4uYWRkKHIpLG4uYWRkKHMpLG59fSxlKFhyLnByb3RvdHlwZSx7dW5pb246ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IFRlLGU9bmV3IGF0LG49MDtuPHRoaXMucG9pbnRHZW9tLmdldE51bUdlb21ldHJpZXMoKTtuKyspe3ZhciBpPXRoaXMucG9pbnRHZW9tLmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0Q29vcmRpbmF0ZSgpLHM9dC5sb2NhdGUocix0aGlzLm90aGVyR2VvbSk7cz09PUwuRVhURVJJT1ImJmUuYWRkKHIpfWlmKDA9PT1lLnNpemUoKSlyZXR1cm4gdGhpcy5vdGhlckdlb207dmFyIG89bnVsbCxhPUgudG9Db29yZGluYXRlQXJyYXkoZSk7cmV0dXJuIG89MT09PWEubGVuZ3RoP3RoaXMuZ2VvbUZhY3QuY3JlYXRlUG9pbnQoYVswXSk6dGhpcy5nZW9tRmFjdC5jcmVhdGVNdWx0aVBvaW50RnJvbUNvb3JkcyhhKSxVci5jb21iaW5lKG8sdGhpcy5vdGhlckdlb20pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBYcn19KSxYci51bmlvbj1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBYcih0LGUpO3JldHVybiBuLnVuaW9uKCl9LGUoSHIucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7LTEhPT10aGlzLnNvcnRJbmRleCYmdC5nZXRTb3J0SW5kZXgoKSE9PXRoaXMuc29ydEluZGV4fHx0aGlzLmNvbXBzLmFkZCh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5baHRdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBIcn19KSxIci5leHRyYWN0PWZ1bmN0aW9uKCl7aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXTtyZXR1cm4gSHIuZXh0cmFjdCh0LGUsbmV3IEkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1hcmd1bWVudHNbMV0scj1hcmd1bWVudHNbMl07cmV0dXJuIG4uZ2V0U29ydEluZGV4KCk9PT1pP3IuYWRkKG4pOm4gaW5zdGFuY2VvZiBmdCYmbi5hcHBseShuZXcgSHIoaSxyKSkscn19LGUoV3IucHJvdG90eXBlLHtyZWR1Y2VUb0dlb21ldHJpZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCkscj1udWxsO1IoaSx5KT9yPXRoaXMudW5pb25UcmVlKGkpOmkgaW5zdGFuY2VvZiBCJiYocj1pKSxlLmFkZChyKX1yZXR1cm4gZX0sZXh0cmFjdEJ5RW52ZWxvcGU6ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT1uZXcgSSxyPTA7cjxlLmdldE51bUdlb21ldHJpZXMoKTtyKyspe3ZhciBzPWUuZ2V0R2VvbWV0cnlOKHIpO3MuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmludGVyc2VjdHModCk/aS5hZGQocyk6bi5hZGQocyl9cmV0dXJuIHRoaXMuZ2VvbUZhY3RvcnkuYnVpbGRHZW9tZXRyeShpKX0sdW5pb25PcHRpbWl6ZWQ6ZnVuY3Rpb24odCxlKXt2YXIgbj10LmdldEVudmVsb3BlSW50ZXJuYWwoKSxpPWUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpO2lmKCFuLmludGVyc2VjdHMoaSkpe3ZhciByPVVyLmNvbWJpbmUodCxlKTtyZXR1cm4gcn1pZih0LmdldE51bUdlb21ldHJpZXMoKTw9MSYmZS5nZXROdW1HZW9tZXRyaWVzKCk8PTEpcmV0dXJuIHRoaXMudW5pb25BY3R1YWwodCxlKTt2YXIgcz1uLmludGVyc2VjdGlvbihpKTtyZXR1cm4gdGhpcy51bmlvblVzaW5nRW52ZWxvcGVJbnRlcnNlY3Rpb24odCxlLHMpfSx1bmlvbjpmdW5jdGlvbigpe2lmKG51bGw9PT10aGlzLmlucHV0UG9seXMpdGhyb3cgbmV3IElsbGVnYWxTdGF0ZUV4Y2VwdGlvbihcInVuaW9uKCkgbWV0aG9kIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2VcIik7aWYodGhpcy5pbnB1dFBvbHlzLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDt0aGlzLmdlb21GYWN0b3J5PXRoaXMuaW5wdXRQb2x5cy5pdGVyYXRvcigpLm5leHQoKS5nZXRGYWN0b3J5KCk7Zm9yKHZhciB0PW5ldyBrZShXci5TVFJUUkVFX05PREVfQ0FQQUNJVFkpLGU9dGhpcy5pbnB1dFBvbHlzLml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0Lmluc2VydChuLmdldEVudmVsb3BlSW50ZXJuYWwoKSxuKX10aGlzLmlucHV0UG9seXM9bnVsbDt2YXIgaT10Lml0ZW1zVHJlZSgpLHI9dGhpcy51bmlvblRyZWUoaSk7cmV0dXJuIHJ9LGJpbmFyeVVuaW9uOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5iaW5hcnlVbmlvbih0LDAsdC5zaXplKCkpfWlmKDM9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV0saT1hcmd1bWVudHNbMl07aWYoMT49aS1uKXt2YXIgcj1Xci5nZXRHZW9tZXRyeShlLG4pO3JldHVybiB0aGlzLnVuaW9uU2FmZShyLG51bGwpfWlmKGktbj09PTIpcmV0dXJuIHRoaXMudW5pb25TYWZlKFdyLmdldEdlb21ldHJ5KGUsbiksV3IuZ2V0R2VvbWV0cnkoZSxuKzEpKTt2YXIgcz1NYXRoLnRydW5jKChpK24pLzIpLHI9dGhpcy5iaW5hcnlVbmlvbihlLG4scyksbz10aGlzLmJpbmFyeVVuaW9uKGUscyxpKTtyZXR1cm4gdGhpcy51bmlvblNhZmUocixvKX19LHJlcGVhdGVkVW5pb246ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW51bGwsbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTtlPW51bGw9PT1lP2kuY29weSgpOmUudW5pb24oaSl9cmV0dXJuIGV9LHVuaW9uU2FmZTpmdW5jdGlvbih0LGUpe3JldHVybiBudWxsPT09dCYmbnVsbD09PWU/bnVsbDpudWxsPT09dD9lLmNvcHkoKTpudWxsPT09ZT90LmNvcHkoKTp0aGlzLnVuaW9uT3B0aW1pemVkKHQsZSl9LHVuaW9uQWN0dWFsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIFdyLnJlc3RyaWN0VG9Qb2x5Z29ucyh0LnVuaW9uKGUpKX0sdW5pb25UcmVlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucmVkdWNlVG9HZW9tZXRyaWVzKHQpLG49dGhpcy5iaW5hcnlVbmlvbihlKTtyZXR1cm4gbn0sdW5pb25Vc2luZ0VudmVsb3BlSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXt2YXIgaT1uZXcgSSxyPXRoaXMuZXh0cmFjdEJ5RW52ZWxvcGUobix0LGkpLHM9dGhpcy5leHRyYWN0QnlFbnZlbG9wZShuLGUsaSksbz10aGlzLnVuaW9uQWN0dWFsKHIscyk7aS5hZGQobyk7dmFyIGE9VXIuY29tYmluZShpKTtyZXR1cm4gYX0sYnVmZmVyVW5pb246ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9dC5nZXQoMCkuZ2V0RmFjdG9yeSgpLG49ZS5idWlsZEdlb21ldHJ5KHQpLGk9bi5idWZmZXIoMCk7cmV0dXJuIGl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciByPWFyZ3VtZW50c1swXSxzPWFyZ3VtZW50c1sxXSxlPXIuZ2V0RmFjdG9yeSgpLG49ZS5jcmVhdGVHZW9tZXRyeUNvbGxlY3Rpb24oW3Isc10pLGk9bi5idWZmZXIoMCk7cmV0dXJuIGl9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBXcn19KSxXci5yZXN0cmljdFRvUG9seWdvbnM9ZnVuY3Rpb24odCl7aWYoUih0LFJ0KSlyZXR1cm4gdDt2YXIgZT1vci5nZXRQb2x5Z29ucyh0KTtyZXR1cm4gMT09PWUuc2l6ZSgpP2UuZ2V0KDApOnQuZ2V0RmFjdG9yeSgpLmNyZWF0ZU11bHRpUG9seWdvbihpZS50b1BvbHlnb25BcnJheShlKSl9LFdyLmdldEdlb21ldHJ5PWZ1bmN0aW9uKHQsZSl7cmV0dXJuIGU+PXQuc2l6ZSgpP251bGw6dC5nZXQoZSl9LFdyLnVuaW9uPWZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBXcih0KTtyZXR1cm4gZS51bmlvbigpfSxXci5TVFJUUkVFX05PREVfQ0FQQUNJVFk9NCxlKGpyLnByb3RvdHlwZSx7dW5pb25Ob09wdDpmdW5jdGlvbih0KXt2YXIgZT10aGlzLmdlb21GYWN0LmNyZWF0ZVBvaW50KCk7cmV0dXJuIHNpLm92ZXJsYXlPcCh0LGUsaWkuVU5JT04pfSx1bmlvbldpdGhOdWxsOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIG51bGw9PT10JiZudWxsPT09ZT9udWxsOm51bGw9PT1lP3Q6bnVsbD09PXQ/ZTp0LnVuaW9uKGUpfSxleHRyYWN0OmZ1bmN0aW9uKCl7aWYoUihhcmd1bWVudHNbMF0sdikpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMuZXh0cmFjdChuKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGk9YXJndW1lbnRzWzBdO251bGw9PT10aGlzLmdlb21GYWN0JiYodGhpcy5nZW9tRmFjdD1pLmdldEZhY3RvcnkoKSksSHIuZXh0cmFjdChpLEIuU09SVElOREVYX1BPTFlHT04sdGhpcy5wb2x5Z29ucyksSHIuZXh0cmFjdChpLEIuU09SVElOREVYX0xJTkVTVFJJTkcsdGhpcy5saW5lcyksSHIuZXh0cmFjdChpLEIuU09SVElOREVYX1BPSU5ULHRoaXMucG9pbnRzKX19LHVuaW9uOmZ1bmN0aW9uIHQoKXtpZihudWxsPT09dGhpcy5nZW9tRmFjdClyZXR1cm4gbnVsbDt2YXIgZT1udWxsO2lmKHRoaXMucG9pbnRzLnNpemUoKT4wKXt2YXIgbj10aGlzLmdlb21GYWN0LmJ1aWxkR2VvbWV0cnkodGhpcy5wb2ludHMpO2U9dGhpcy51bmlvbk5vT3B0KG4pfXZhciBpPW51bGw7aWYodGhpcy5saW5lcy5zaXplKCk+MCl7dmFyIHI9dGhpcy5nZW9tRmFjdC5idWlsZEdlb21ldHJ5KHRoaXMubGluZXMpO2k9dGhpcy51bmlvbk5vT3B0KHIpfXZhciBzPW51bGw7dGhpcy5wb2x5Z29ucy5zaXplKCk+MCYmKHM9V3IudW5pb24odGhpcy5wb2x5Z29ucykpO3ZhciBvPXRoaXMudW5pb25XaXRoTnVsbChpLHMpLHQ9bnVsbDtyZXR1cm4gdD1udWxsPT09ZT9vOm51bGw9PT1vP2U6WHIudW5pb24oZSxvKSxudWxsPT09dD90aGlzLmdlb21GYWN0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbigpOnR9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGpyfX0pLGpyLnVuaW9uPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKFIoYXJndW1lbnRzWzBdLHYpKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcganIodCk7cmV0dXJuIGUudW5pb24oKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEIpe3ZhciBuPWFyZ3VtZW50c1swXSxlPW5ldyBqcihuKTtyZXR1cm4gZS51bmlvbigpfX1lbHNlIGlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgaT1hcmd1bWVudHNbMF0scj1hcmd1bWVudHNbMV0sZT1uZXcganIoaSxyKTtyZXR1cm4gZS51bmlvbigpfX07dmFyIFBvPU9iamVjdC5mcmVlemUoe1VuYXJ5VW5pb25PcDpqcn0pO2UoS3IucHJvdG90eXBlLHt2aXNpdEludGVyaW9yUmluZzpmdW5jdGlvbih0LGUpe3ZhciBuPXQuZ2V0Q29vcmRpbmF0ZXMoKSxpPW5bMF0scj1Lci5maW5kRGlmZmVyZW50UG9pbnQobixpKSxzPWUuZmluZEVkZ2VJblNhbWVEaXJlY3Rpb24oaSxyKSxvPWUuZmluZEVkZ2VFbmQocyksYT1udWxsO28uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1I/YT1vOm8uZ2V0U3ltKCkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1ImJihhPW8uZ2V0U3ltKCkpLGYuaXNUcnVlKG51bGwhPT1hLFwidW5hYmxlIHRvIGZpbmQgZGlyRWRnZSB3aXRoIEludGVyaW9yIG9uIFJIU1wiKSx0aGlzLnZpc2l0TGlua2VkRGlyZWN0ZWRFZGdlcyhhKX0sdmlzaXRTaGVsbEludGVyaW9yczpmdW5jdGlvbih0LGUpe2lmKHQgaW5zdGFuY2VvZiBUdCl7dmFyIG49dDt0aGlzLnZpc2l0SW50ZXJpb3JSaW5nKG4uZ2V0RXh0ZXJpb3JSaW5nKCksZSl9aWYodCBpbnN0YW5jZW9mIE90KWZvcih2YXIgaT10LHI9MDtyPGkuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIG49aS5nZXRHZW9tZXRyeU4ocik7dGhpcy52aXNpdEludGVyaW9yUmluZyhuLmdldEV4dGVyaW9yUmluZygpLGUpfX0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmRpc2Nvbm5lY3RlZFJpbmdjb29yZH0sc2V0SW50ZXJpb3JFZGdlc0luUmVzdWx0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldEVkZ2VFbmRzKCkuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO24uZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbigwLGNuLlJJR0hUKT09PUwuSU5URVJJT1ImJm4uc2V0SW5SZXN1bHQoITApfX0sdmlzaXRMaW5rZWREaXJlY3RlZEVkZ2VzOmZ1bmN0aW9uKHQpe3ZhciBlPXQsbj10O2RvIGYuaXNUcnVlKG51bGwhPT1uLFwiZm91bmQgbnVsbCBEaXJlY3RlZCBFZGdlXCIpLG4uc2V0VmlzaXRlZCghMCksbj1uLmdldE5leHQoKTt3aGlsZShuIT09ZSl9LGJ1aWxkRWRnZVJpbmdzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2lmKGkuaXNJblJlc3VsdCgpJiZudWxsPT09aS5nZXRFZGdlUmluZygpKXt2YXIgcj1uZXcgdm4oaSx0aGlzLmdlb21ldHJ5RmFjdG9yeSk7ci5saW5rRGlyZWN0ZWRFZGdlc0Zvck1pbmltYWxFZGdlUmluZ3MoKTt2YXIgcz1yLmJ1aWxkTWluaW1hbFJpbmdzKCk7ZS5hZGRBbGwocyl9fXJldHVybiBlfSxoYXNVbnZpc2l0ZWRTaGVsbEVkZ2U6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPTA7ZTx0LnNpemUoKTtlKyspe3ZhciBuPXQuZ2V0KGUpO2lmKCFuLmlzSG9sZSgpKXt2YXIgaT1uLmdldEVkZ2VzKCkscj1pLmdldCgwKTtpZihyLmdldExhYmVsKCkuZ2V0TG9jYXRpb24oMCxjbi5SSUdIVCk9PT1MLklOVEVSSU9SKWZvcih2YXIgcz0wO3M8aS5zaXplKCk7cysrKWlmKHI9aS5nZXQocyksXG4hci5pc1Zpc2l0ZWQoKSlyZXR1cm4gdGhpcy5kaXNjb25uZWN0ZWRSaW5nY29vcmQ9ci5nZXRDb29yZGluYXRlKCksITB9fXJldHVybiExfSxpc0ludGVyaW9yc0Nvbm5lY3RlZDpmdW5jdGlvbigpe3ZhciB0PW5ldyBJO3RoaXMuZ2VvbUdyYXBoLmNvbXB1dGVTcGxpdEVkZ2VzKHQpO3ZhciBlPW5ldyBDbihuZXcgT24pO2UuYWRkRWRnZXModCksdGhpcy5zZXRJbnRlcmlvckVkZ2VzSW5SZXN1bHQoZSksZS5saW5rUmVzdWx0RGlyZWN0ZWRFZGdlcygpO3ZhciBuPXRoaXMuYnVpbGRFZGdlUmluZ3MoZS5nZXRFZGdlRW5kcygpKTtyZXR1cm4gdGhpcy52aXNpdFNoZWxsSW50ZXJpb3JzKHRoaXMuZ2VvbUdyYXBoLmdldEdlb21ldHJ5KCksZSksIXRoaXMuaGFzVW52aXNpdGVkU2hlbGxFZGdlKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBLcn19KSxLci5maW5kRGlmZmVyZW50UG9pbnQ9ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49MDtuPHQubGVuZ3RoO24rKylpZighdFtuXS5lcXVhbHMoZSkpcmV0dXJuIHRbbl07cmV0dXJuIG51bGx9LGUoWnIucHJvdG90eXBlLHtoYXNDaGlsZHJlbjpmdW5jdGlvbigpe2Zvcih2YXIgdD0wOzI+dDt0KyspaWYobnVsbCE9PXRoaXMuc3Vibm9kZVt0XSlyZXR1cm4hMDtyZXR1cm4hMX0saXNQcnVuYWJsZTpmdW5jdGlvbigpe3JldHVybiEodGhpcy5oYXNDaGlsZHJlbigpfHx0aGlzLmhhc0l0ZW1zKCkpfSxhZGRBbGxJdGVtczpmdW5jdGlvbih0KXt0LmFkZEFsbCh0aGlzLml0ZW1zKTtmb3IodmFyIGU9MDsyPmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJnRoaXMuc3Vibm9kZVtlXS5hZGRBbGxJdGVtcyh0KTtyZXR1cm4gdH0sc2l6ZTpmdW5jdGlvbigpe2Zvcih2YXIgdD0wLGU9MDsyPmU7ZSsrKW51bGwhPT10aGlzLnN1Ym5vZGVbZV0mJih0Kz10aGlzLnN1Ym5vZGVbZV0uc2l6ZSgpKTtyZXR1cm4gdCt0aGlzLml0ZW1zLnNpemUoKX0sYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmc6ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbD09PXR8fHRoaXMuaXNTZWFyY2hNYXRjaCh0KT8oZS5hZGRBbGwodGhpcy5pdGVtcyksbnVsbCE9PXRoaXMuc3Vibm9kZVswXSYmdGhpcy5zdWJub2RlWzBdLmFkZEFsbEl0ZW1zRnJvbU92ZXJsYXBwaW5nKHQsZSksdm9pZChudWxsIT09dGhpcy5zdWJub2RlWzFdJiZ0aGlzLnN1Ym5vZGVbMV0uYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcodCxlKSkpOm51bGx9LGhhc0l0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIXRoaXMuaXRlbXMuaXNFbXB0eSgpfSxyZW1vdmU6ZnVuY3Rpb24odCxlKXtpZighdGhpcy5pc1NlYXJjaE1hdGNoKHQpKXJldHVybiExO2Zvcih2YXIgbj0hMSxpPTA7Mj5pO2krKylpZihudWxsIT09dGhpcy5zdWJub2RlW2ldJiYobj10aGlzLnN1Ym5vZGVbaV0ucmVtb3ZlKHQsZSkpKXt0aGlzLnN1Ym5vZGVbaV0uaXNQcnVuYWJsZSgpJiYodGhpcy5zdWJub2RlW2ldPW51bGwpO2JyZWFrfXJldHVybiBuP246bj10aGlzLml0ZW1zLnJlbW92ZShlKX0sZ2V0SXRlbXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pdGVtc30sZGVwdGg6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9MCxlPTA7Mj5lO2UrKylpZihudWxsIT09dGhpcy5zdWJub2RlW2VdKXt2YXIgbj10aGlzLnN1Ym5vZGVbZV0uZGVwdGgoKTtuPnQmJih0PW4pfXJldHVybiB0KzF9LG5vZGVTaXplOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PTAsZT0wOzI+ZTtlKyspbnVsbCE9PXRoaXMuc3Vibm9kZVtlXSYmKHQrPXRoaXMuc3Vibm9kZVtlXS5ub2RlU2l6ZSgpKTtyZXR1cm4gdCsxfSxhZGQ6ZnVuY3Rpb24odCl7dGhpcy5pdGVtcy5hZGQodCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFpyfX0pLFpyLmdldFN1Ym5vZGVJbmRleD1mdW5jdGlvbih0LGUpe3ZhciBuPS0xO3JldHVybiB0Lm1pbj49ZSYmKG49MSksdC5tYXg8PWUmJihuPTApLG59LGUoUXIucHJvdG90eXBlLHtleHBhbmRUb0luY2x1ZGU6ZnVuY3Rpb24odCl7dC5tYXg+dGhpcy5tYXgmJih0aGlzLm1heD10Lm1heCksdC5taW48dGhpcy5taW4mJih0aGlzLm1pbj10Lm1pbil9LGdldFdpZHRoOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWF4LXRoaXMubWlufSxvdmVybGFwczpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMub3ZlcmxhcHModC5taW4sdC5tYXgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuISh0aGlzLm1pbj5ufHx0aGlzLm1heDxlKX19LGdldE1pbjpmdW5jdGlvbigpe3JldHVybiB0aGlzLm1pbn0sdG9TdHJpbmc6ZnVuY3Rpb24oKXtyZXR1cm5cIltcIit0aGlzLm1pbitcIiwgXCIrdGhpcy5tYXgrXCJdXCJ9LGNvbnRhaW5zOmZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgUXIpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gdGhpcy5jb250YWlucyh0Lm1pbix0Lm1heCl9aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiBlPj10aGlzLm1pbiYmZTw9dGhpcy5tYXh9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXTtyZXR1cm4gbj49dGhpcy5taW4mJmk8PXRoaXMubWF4fX0saW5pdDpmdW5jdGlvbih0LGUpe3RoaXMubWluPXQsdGhpcy5tYXg9ZSx0PmUmJih0aGlzLm1pbj1lLHRoaXMubWF4PXQpfSxnZXRNYXg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXh9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFFyfX0pLGUoSnIucHJvdG90eXBlLHtnZXRJbnRlcnZhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVydmFsfSxnZXRMZXZlbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxldmVsfSxjb21wdXRlS2V5OmZ1bmN0aW9uKHQpe2Zvcih0aGlzLmxldmVsPUpyLmNvbXB1dGVMZXZlbCh0KSx0aGlzLmludGVydmFsPW5ldyBRcix0aGlzLmNvbXB1dGVJbnRlcnZhbCh0aGlzLmxldmVsLHQpOyF0aGlzLmludGVydmFsLmNvbnRhaW5zKHQpOyl0aGlzLmxldmVsKz0xLHRoaXMuY29tcHV0ZUludGVydmFsKHRoaXMubGV2ZWwsdCl9LGNvbXB1dGVJbnRlcnZhbDpmdW5jdGlvbih0LGUpe3ZhciBuPUNpLnBvd2VyT2YyKHQpO3RoaXMucHQ9TWF0aC5mbG9vcihlLmdldE1pbigpL24pKm4sdGhpcy5pbnRlcnZhbC5pbml0KHRoaXMucHQsdGhpcy5wdCtuKX0sZ2V0UG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSnJ9fSksSnIuY29tcHV0ZUxldmVsPWZ1bmN0aW9uKHQpe3ZhciBlPXQuZ2V0V2lkdGgoKSxuPUNpLmV4cG9uZW50KGUpKzE7cmV0dXJuIG59LGgoJHIsWnIpLGUoJHIucHJvdG90eXBlLHtnZXRJbnRlcnZhbDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludGVydmFsfSxmaW5kOmZ1bmN0aW9uKHQpe3ZhciBlPVpyLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJlKTtpZigtMT09PWUpcmV0dXJuIHRoaXM7aWYobnVsbCE9PXRoaXMuc3Vibm9kZVtlXSl7dmFyIG49dGhpcy5zdWJub2RlW2VdO3JldHVybiBuLmZpbmQodCl9cmV0dXJuIHRoaXN9LGluc2VydDpmdW5jdGlvbih0KXtmLmlzVHJ1ZShudWxsPT09dGhpcy5pbnRlcnZhbHx8dGhpcy5pbnRlcnZhbC5jb250YWlucyh0LmludGVydmFsKSk7dmFyIGU9WnIuZ2V0U3Vibm9kZUluZGV4KHQuaW50ZXJ2YWwsdGhpcy5jZW50cmUpO2lmKHQubGV2ZWw9PT10aGlzLmxldmVsLTEpdGhpcy5zdWJub2RlW2VdPXQ7ZWxzZXt2YXIgbj10aGlzLmNyZWF0ZVN1Ym5vZGUoZSk7bi5pbnNlcnQodCksdGhpcy5zdWJub2RlW2VdPW59fSxpc1NlYXJjaE1hdGNoOmZ1bmN0aW9uKHQpe3JldHVybiB0Lm92ZXJsYXBzKHRoaXMuaW50ZXJ2YWwpfSxnZXRTdWJub2RlOmZ1bmN0aW9uKHQpe3JldHVybiBudWxsPT09dGhpcy5zdWJub2RlW3RdJiYodGhpcy5zdWJub2RlW3RdPXRoaXMuY3JlYXRlU3Vibm9kZSh0KSksdGhpcy5zdWJub2RlW3RdfSxnZXROb2RlOmZ1bmN0aW9uKHQpe3ZhciBlPVpyLmdldFN1Ym5vZGVJbmRleCh0LHRoaXMuY2VudHJlKTtpZigtMSE9PWUpe3ZhciBuPXRoaXMuZ2V0U3Vibm9kZShlKTtyZXR1cm4gbi5nZXROb2RlKHQpfXJldHVybiB0aGlzfSxjcmVhdGVTdWJub2RlOmZ1bmN0aW9uKHQpe3ZhciBlPTAsbj0wO3N3aXRjaCh0KXtjYXNlIDA6ZT10aGlzLmludGVydmFsLmdldE1pbigpLG49dGhpcy5jZW50cmU7YnJlYWs7Y2FzZSAxOmU9dGhpcy5jZW50cmUsbj10aGlzLmludGVydmFsLmdldE1heCgpfXZhciBpPW5ldyBRcihlLG4pLHI9bmV3ICRyKGksdGhpcy5sZXZlbC0xKTtyZXR1cm4gcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gJHJ9fSksJHIuY3JlYXRlTm9kZT1mdW5jdGlvbih0KXt2YXIgZT1uZXcgSnIodCksbj1uZXcgJHIoZS5nZXRJbnRlcnZhbCgpLGUuZ2V0TGV2ZWwoKSk7cmV0dXJuIG59LCRyLmNyZWF0ZUV4cGFuZGVkPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IFFyKGUpO251bGwhPT10JiZuLmV4cGFuZFRvSW5jbHVkZSh0LmludGVydmFsKTt2YXIgaT0kci5jcmVhdGVOb2RlKG4pO3JldHVybiBudWxsIT09dCYmaS5pbnNlcnQodCksaX0saCh0cyxaciksZSh0cy5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbih0LGUpe3ZhciBuPVpyLmdldFN1Ym5vZGVJbmRleCh0LHRzLm9yaWdpbik7aWYoLTE9PT1uKXJldHVybiB0aGlzLmFkZChlKSxudWxsO3ZhciBpPXRoaXMuc3Vibm9kZVtuXTtpZihudWxsPT09aXx8IWkuZ2V0SW50ZXJ2YWwoKS5jb250YWlucyh0KSl7dmFyIHI9JHIuY3JlYXRlRXhwYW5kZWQoaSx0KTt0aGlzLnN1Ym5vZGVbbl09cn10aGlzLmluc2VydENvbnRhaW5lZCh0aGlzLnN1Ym5vZGVbbl0sdCxlKX0saXNTZWFyY2hNYXRjaDpmdW5jdGlvbih0KXtyZXR1cm4hMH0saW5zZXJ0Q29udGFpbmVkOmZ1bmN0aW9uKHQsZSxuKXtmLmlzVHJ1ZSh0LmdldEludGVydmFsKCkuY29udGFpbnMoZSkpO3ZhciBpPVJpLmlzWmVyb1dpZHRoKGUuZ2V0TWluKCksZS5nZXRNYXgoKSkscj1udWxsO3I9aT90LmZpbmQoZSk6dC5nZXROb2RlKGUpLHIuYWRkKG4pfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB0c319KSx0cy5vcmlnaW49MCxlKGVzLnByb3RvdHlwZSx7c2l6ZTpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5zaXplKCk6MH0saW5zZXJ0OmZ1bmN0aW9uKHQsZSl7dGhpcy5jb2xsZWN0U3RhdHModCk7dmFyIG49ZXMuZW5zdXJlRXh0ZW50KHQsdGhpcy5taW5FeHRlbnQpO3RoaXMucm9vdC5pbnNlcnQobixlKX0scXVlcnk6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoXCJudW1iZXJcIj09dHlwZW9mIGFyZ3VtZW50c1swXSl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnF1ZXJ5KG5ldyBRcih0LHQpKX1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFFyKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1uZXcgSTtyZXR1cm4gdGhpcy5xdWVyeShlLG4pLG59fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBpPWFyZ3VtZW50c1swXSxyPWFyZ3VtZW50c1sxXTt0aGlzLnJvb3QuYWRkQWxsSXRlbXNGcm9tT3ZlcmxhcHBpbmcoaSxyKX19LGl0ZXJhdG9yOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEk7cmV0dXJuIHRoaXMucm9vdC5hZGRBbGxJdGVtcyh0KSx0Lml0ZXJhdG9yKCl9LHJlbW92ZTpmdW5jdGlvbih0LGUpe3ZhciBuPWVzLmVuc3VyZUV4dGVudCh0LHRoaXMubWluRXh0ZW50KTtyZXR1cm4gdGhpcy5yb290LnJlbW92ZShuLGUpfSxjb2xsZWN0U3RhdHM6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRXaWR0aCgpO2U8dGhpcy5taW5FeHRlbnQmJmU+MCYmKHRoaXMubWluRXh0ZW50PWUpfSxkZXB0aDpmdW5jdGlvbigpe3JldHVybiBudWxsIT09dGhpcy5yb290P3RoaXMucm9vdC5kZXB0aCgpOjB9LG5vZGVTaXplOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLnJvb3Q/dGhpcy5yb290Lm5vZGVTaXplKCk6MH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZXN9fSksZXMuZW5zdXJlRXh0ZW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRNaW4oKSxpPXQuZ2V0TWF4KCk7cmV0dXJuIG4hPT1pP3Q6KG49PT1pJiYobi09ZS8yLGk9bitlLzIpLG5ldyBRcihuLGkpKX0sZShucy5wcm90b3R5cGUse2lzSW5zaWRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbnN9fSksZShpcy5wcm90b3R5cGUse3Rlc3RMaW5lU2VnbWVudDpmdW5jdGlvbih0LGUpe3ZhciBuPW51bGwsaT1udWxsLHI9bnVsbCxzPW51bGwsbz1udWxsLGE9ZS5wMCx1PWUucDE7aT1hLngtdC54LHI9YS55LXQueSxzPXUueC10Lngsbz11LnktdC55LChyPjAmJjA+PW98fG8+MCYmMD49cikmJihuPXVlLnNpZ25PZkRldDJ4MihpLHIscyxvKS8oby1yKSxuPjAmJnRoaXMuY3Jvc3NpbmdzKyspfSxidWlsZEluZGV4OmZ1bmN0aW9uKCl7dGhpcy50cmVlPW5ldyBlcztmb3IodmFyIHQ9SC5yZW1vdmVSZXBlYXRlZFBvaW50cyh0aGlzLnJpbmcuZ2V0Q29vcmRpbmF0ZXMoKSksZT0kZS5nZXRDaGFpbnModCksbj0wO248ZS5zaXplKCk7bisrKXt2YXIgaT1lLmdldChuKSxyPWkuZ2V0RW52ZWxvcGUoKTt0aGlzLmludGVydmFsLm1pbj1yLmdldE1pblkoKSx0aGlzLmludGVydmFsLm1heD1yLmdldE1heFkoKSx0aGlzLnRyZWUuaW5zZXJ0KHRoaXMuaW50ZXJ2YWwsaSl9fSx0ZXN0TW9ub3RvbmVDaGFpbjpmdW5jdGlvbih0LGUsbil7bi5zZWxlY3QodCxlKX0saXNJbnNpZGU6ZnVuY3Rpb24odCl7dGhpcy5jcm9zc2luZ3M9MDt2YXIgZT1uZXcgQyhyLk5FR0FUSVZFX0lORklOSVRZLHIuUE9TSVRJVkVfSU5GSU5JVFksdC55LHQueSk7dGhpcy5pbnRlcnZhbC5taW49dC55LHRoaXMuaW50ZXJ2YWwubWF4PXQueTtmb3IodmFyIG49dGhpcy50cmVlLnF1ZXJ5KHRoaXMuaW50ZXJ2YWwpLGk9bmV3IHJzKHRoaXMsdCkscz1uLml0ZXJhdG9yKCk7cy5oYXNOZXh0KCk7KXt2YXIgbz1zLm5leHQoKTt0aGlzLnRlc3RNb25vdG9uZUNoYWluKGUsaSxvKX1yZXR1cm4gdGhpcy5jcm9zc2luZ3MlMj09PTF9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW25zXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaXN9fSksaChycyx0ciksZShycy5wcm90b3R5cGUse3NlbGVjdDpmdW5jdGlvbigpe2lmKDEhPT1hcmd1bWVudHMubGVuZ3RoKXJldHVybiB0ci5wcm90b3R5cGUuc2VsZWN0LmFwcGx5KHRoaXMsYXJndW1lbnRzKTt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5tY3AudGVzdExpbmVTZWdtZW50KHRoaXMucCx0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcnN9fSksaXMuTUNTZWxlY3Rlcj1ycyxlKHNzLnByb3RvdHlwZSx7aW5zZXJ0RWRnZUVuZHM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuaXRlcmF0b3IoKTtlLmhhc05leHQoKTspe3ZhciBuPWUubmV4dCgpO3RoaXMubm9kZXMuYWRkKG4pfX0sZ2V0Tm9kZUl0ZXJhdG9yOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubm9kZXMuaXRlcmF0b3IoKX0sY29weU5vZGVzQW5kTGFiZWxzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0Tm9kZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKSxyPXRoaXMubm9kZXMuYWRkTm9kZShpLmdldENvb3JkaW5hdGUoKSk7ci5zZXRMYWJlbChlLGkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSl9fSxidWlsZDpmdW5jdGlvbih0KXt0aGlzLmNvbXB1dGVJbnRlcnNlY3Rpb25Ob2Rlcyh0LDApLHRoaXMuY29weU5vZGVzQW5kTGFiZWxzKHQsMCk7dmFyIGU9bmV3IGJyLG49ZS5jb21wdXRlRWRnZUVuZHModC5nZXRFZGdlSXRlcmF0b3IoKSk7dGhpcy5pbnNlcnRFZGdlRW5kcyhuKX0sY29tcHV0ZUludGVyc2VjdGlvbk5vZGVzOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KWZvcih2YXIgaT1uLm5leHQoKSxyPWkuZ2V0TGFiZWwoKS5nZXRMb2NhdGlvbihlKSxzPWkuZ2V0RWRnZUludGVyc2VjdGlvbkxpc3QoKS5pdGVyYXRvcigpO3MuaGFzTmV4dCgpOyl7dmFyIG89cy5uZXh0KCksYT10aGlzLm5vZGVzLmFkZE5vZGUoby5jb29yZCk7cj09PUwuQk9VTkRBUlk/YS5zZXRMYWJlbEJvdW5kYXJ5KGUpOmEuZ2V0TGFiZWwoKS5pc051bGwoZSkmJmEuc2V0TGFiZWwoZSxMLklOVEVSSU9SKX19LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHNzfX0pLGUob3MucHJvdG90eXBlLHtpc05vZGVFZGdlQXJlYUxhYmVsc0NvbnNpc3RlbnQ6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KXt2YXIgZT10Lm5leHQoKTtpZighZS5nZXRFZGdlcygpLmlzQXJlYUxhYmVsc0NvbnNpc3RlbnQodGhpcy5nZW9tR3JhcGgpKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1lLmdldENvb3JkaW5hdGUoKS5jb3B5KCksITF9cmV0dXJuITB9LGdldEludmFsaWRQb2ludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludmFsaWRQb2ludH0saGFzRHVwbGljYXRlUmluZ3M6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9dGhpcy5ub2RlR3JhcGguZ2V0Tm9kZUl0ZXJhdG9yKCk7dC5oYXNOZXh0KCk7KWZvcih2YXIgZT10Lm5leHQoKSxuPWUuZ2V0RWRnZXMoKS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYoaS5nZXRFZGdlRW5kcygpLnNpemUoKT4xKXJldHVybiB0aGlzLmludmFsaWRQb2ludD1pLmdldEVkZ2UoKS5nZXRDb29yZGluYXRlKDApLCEwfXJldHVybiExfSxpc05vZGVDb25zaXN0ZW50QXJlYTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuZ2VvbUdyYXBoLmNvbXB1dGVTZWxmTm9kZXModGhpcy5saSwhMCwhMCk7cmV0dXJuIHQuaGFzUHJvcGVySW50ZXJzZWN0aW9uKCk/KHRoaXMuaW52YWxpZFBvaW50PXQuZ2V0UHJvcGVySW50ZXJzZWN0aW9uUG9pbnQoKSwhMSk6KHRoaXMubm9kZUdyYXBoLmJ1aWxkKHRoaXMuZ2VvbUdyYXBoKSx0aGlzLmlzTm9kZUVkZ2VBcmVhTGFiZWxzQ29uc2lzdGVudCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gb3N9fSksZShhcy5wcm90b3R5cGUse2J1aWxkSW5kZXg6ZnVuY3Rpb24oKXt0aGlzLmluZGV4PW5ldyBrZTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKyl7dmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldEVudmVsb3BlSW50ZXJuYWwoKTt0aGlzLmluZGV4Lmluc2VydChuLGUpfX0sZ2V0TmVzdGVkUG9pbnQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXN0ZWRQdH0saXNOb25OZXN0ZWQ6ZnVuY3Rpb24oKXt0aGlzLmJ1aWxkSW5kZXgoKTtmb3IodmFyIHQ9MDt0PHRoaXMucmluZ3Muc2l6ZSgpO3QrKylmb3IodmFyIGU9dGhpcy5yaW5ncy5nZXQodCksbj1lLmdldENvb3JkaW5hdGVzKCksaT10aGlzLmluZGV4LnF1ZXJ5KGUuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSxyPTA7cjxpLnNpemUoKTtyKyspe3ZhciBzPWkuZ2V0KHIpLG89cy5nZXRDb29yZGluYXRlcygpO2lmKGUhPT1zJiZlLmdldEVudmVsb3BlSW50ZXJuYWwoKS5pbnRlcnNlY3RzKHMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSl7dmFyIGE9bHMuZmluZFB0Tm90Tm9kZShuLHMsdGhpcy5ncmFwaCk7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxvKTtpZih1KXJldHVybiB0aGlzLm5lc3RlZFB0PWEsITF9fX1yZXR1cm4hMH0sYWRkOmZ1bmN0aW9uKHQpe3RoaXMucmluZ3MuYWRkKHQpLHRoaXMudG90YWxFbnYuZXhwYW5kVG9JbmNsdWRlKHQuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gYXN9fSksZSh1cy5wcm90b3R5cGUse2dldEVycm9yVHlwZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLmVycm9yVHlwZX0sZ2V0TWVzc2FnZTpmdW5jdGlvbigpe3JldHVybiB1cy5lcnJNc2dbdGhpcy5lcnJvclR5cGVdfSxnZXRDb29yZGluYXRlOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucHR9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9XCJcIjtyZXR1cm4gbnVsbCE9PXRoaXMucHQmJih0PVwiIGF0IG9yIG5lYXIgcG9pbnQgXCIrdGhpcy5wdCksdGhpcy5nZXRNZXNzYWdlKCkrdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gdXN9fSksdXMuRVJST1I9MCx1cy5SRVBFQVRFRF9QT0lOVD0xLHVzLkhPTEVfT1VUU0lERV9TSEVMTD0yLHVzLk5FU1RFRF9IT0xFUz0zLHVzLkRJU0NPTk5FQ1RFRF9JTlRFUklPUj00LHVzLlNFTEZfSU5URVJTRUNUSU9OPTUsdXMuUklOR19TRUxGX0lOVEVSU0VDVElPTj02LHVzLk5FU1RFRF9TSEVMTFM9Nyx1cy5EVVBMSUNBVEVfUklOR1M9OCx1cy5UT09fRkVXX1BPSU5UUz05LHVzLklOVkFMSURfQ09PUkRJTkFURT0xMCx1cy5SSU5HX05PVF9DTE9TRUQ9MTEsdXMuZXJyTXNnPVtcIlRvcG9sb2d5IFZhbGlkYXRpb24gRXJyb3JcIixcIlJlcGVhdGVkIFBvaW50XCIsXCJIb2xlIGxpZXMgb3V0c2lkZSBzaGVsbFwiLFwiSG9sZXMgYXJlIG5lc3RlZFwiLFwiSW50ZXJpb3IgaXMgZGlzY29ubmVjdGVkXCIsXCJTZWxmLWludGVyc2VjdGlvblwiLFwiUmluZyBTZWxmLWludGVyc2VjdGlvblwiLFwiTmVzdGVkIHNoZWxsc1wiLFwiRHVwbGljYXRlIFJpbmdzXCIsXCJUb28gZmV3IGRpc3RpbmN0IHBvaW50cyBpbiBnZW9tZXRyeSBjb21wb25lbnRcIixcIkludmFsaWQgQ29vcmRpbmF0ZVwiLFwiUmluZyBpcyBub3QgY2xvc2VkXCJdLGUobHMucHJvdG90eXBlLHtjaGVja0ludmFsaWRDb29yZGluYXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQXJyYXkpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT0wO2U8dC5sZW5ndGg7ZSsrKWlmKCFscy5pc1ZhbGlkKHRbZV0pKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5JTlZBTElEX0NPT1JESU5BVEUsdFtlXSksbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0RXh0ZXJpb3JSaW5nKCkuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTxuLmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0SW50ZXJpb3JSaW5nTihlKS5nZXRDb29yZGluYXRlcygpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH19LGNoZWNrSG9sZXNOb3ROZXN0ZWQ6ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49bmV3IGFzKGUpLGk9MDtpPHQuZ2V0TnVtSW50ZXJpb3JSaW5nKCk7aSsrKXt2YXIgcj10LmdldEludGVyaW9yUmluZ04oaSk7bi5hZGQocil9dmFyIHM9bi5pc05vbk5lc3RlZCgpO3N8fCh0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfSE9MRVMsbi5nZXROZXN0ZWRQb2ludCgpKSl9LGNoZWNrQ29uc2lzdGVudEFyZWE6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IG9zKHQpLG49ZS5pc05vZGVDb25zaXN0ZW50QXJlYSgpO3JldHVybiBuP3ZvaWQoZS5oYXNEdXBsaWNhdGVSaW5ncygpJiYodGhpcy52YWxpZEVycj1uZXcgdXModXMuRFVQTElDQVRFX1JJTkdTLGUuZ2V0SW52YWxpZFBvaW50KCkpKSk6KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLlNFTEZfSU5URVJTRUNUSU9OLGUuZ2V0SW52YWxpZFBvaW50KCkpLG51bGwpfSxpc1ZhbGlkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY2hlY2tWYWxpZCh0aGlzLnBhcmVudEdlb21ldHJ5KSxudWxsPT09dGhpcy52YWxpZEVycn0sY2hlY2tTaGVsbEluc2lkZUhvbGU6ZnVuY3Rpb24odCxlLG4pe3ZhciBpPXQuZ2V0Q29vcmRpbmF0ZXMoKSxyPWUuZ2V0Q29vcmRpbmF0ZXMoKSxzPWxzLmZpbmRQdE5vdE5vZGUoaSxlLG4pO2lmKG51bGwhPT1zKXt2YXIgbz1oZS5pc1BvaW50SW5SaW5nKHMscik7aWYoIW8pcmV0dXJuIHN9dmFyIGE9bHMuZmluZFB0Tm90Tm9kZShyLHQsbik7aWYobnVsbCE9PWEpe3ZhciB1PWhlLmlzUG9pbnRJblJpbmcoYSxpKTtyZXR1cm4gdT9hOm51bGx9cmV0dXJuIGYuc2hvdWxkTmV2ZXJSZWFjaEhlcmUoXCJwb2ludHMgaW4gc2hlbGwgYW5kIGhvbGUgYXBwZWFyIHRvIGJlIGVxdWFsXCIpLG51bGx9LGNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZ3M6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXQuZ2V0RWRnZUl0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTtpZih0aGlzLmNoZWNrTm9TZWxmSW50ZXJzZWN0aW5nUmluZyhuLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0sY2hlY2tDb25uZWN0ZWRJbnRlcmlvcnM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEtyKHQpO2UuaXNJbnRlcmlvcnNDb25uZWN0ZWQoKXx8KHRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLkRJU0NPTk5FQ1RFRF9JTlRFUklPUixlLmdldENvb3JkaW5hdGUoKSkpfSxjaGVja05vU2VsZkludGVyc2VjdGluZ1Jpbmc6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBhdCxuPSEwLGk9dC5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7aWYobiluPSExO2Vsc2V7aWYoZS5jb250YWlucyhyLmNvb3JkKSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuUklOR19TRUxGX0lOVEVSU0VDVElPTixyLmNvb3JkKSxudWxsO2UuYWRkKHIuY29vcmQpfX19LGNoZWNrSG9sZXNJblNoZWxsOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXQuZ2V0RXh0ZXJpb3JSaW5nKCksaT1uZXcgaXMobikscj0wO3I8dC5nZXROdW1JbnRlcmlvclJpbmcoKTtyKyspe3ZhciBzPXQuZ2V0SW50ZXJpb3JSaW5nTihyKSxvPWxzLmZpbmRQdE5vdE5vZGUocy5nZXRDb29yZGluYXRlcygpLG4sZSk7aWYobnVsbD09PW8pcmV0dXJuIG51bGw7dmFyIGE9IWkuaXNJbnNpZGUobyk7aWYoYSlyZXR1cm4gdGhpcy52YWxpZEVycj1uZXcgdXModXMuSE9MRV9PVVRTSURFX1NIRUxMLG8pLG51bGx9fSxjaGVja1Rvb0Zld1BvaW50czpmdW5jdGlvbih0KXtyZXR1cm4gdC5oYXNUb29GZXdQb2ludHMoKT8odGhpcy52YWxpZEVycj1uZXcgdXModXMuVE9PX0ZFV19QT0lOVFMsdC5nZXRJbnZhbGlkUG9pbnQoKSksbnVsbCk6dm9pZCAwfSxnZXRWYWxpZGF0aW9uRXJyb3I6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jaGVja1ZhbGlkKHRoaXMucGFyZW50R2VvbWV0cnkpLHRoaXMudmFsaWRFcnJ9LGNoZWNrVmFsaWQ6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIEx0KXt2YXIgdD1hcmd1bWVudHNbMF07dGhpcy5jaGVja0ludmFsaWRDb29yZGluYXRlcyh0LmdldENvb3JkaW5hdGVzKCkpfWVsc2UgaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBQdCl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuY2hlY2tJbnZhbGlkQ29vcmRpbmF0ZXMoZS5nZXRDb29yZGluYXRlcygpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgYnQpe3ZhciBuPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG4uZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcobiksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAsbik7aWYodGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgcj1uZXcgYWU7aS5jb21wdXRlU2VsZk5vZGVzKHIsITAsITApLHRoaXMuY2hlY2tOb1NlbGZJbnRlcnNlY3RpbmdSaW5ncyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgU3Qpe3ZhciBzPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKHMuZ2V0Q29vcmRpbmF0ZXMoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dmFyIGk9bmV3ICRuKDAscyk7dGhpcy5jaGVja1Rvb0Zld1BvaW50cyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgVHQpe3ZhciBvPWFyZ3VtZW50c1swXTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKG8pLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhvKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDt2YXIgaT1uZXcgJG4oMCxvKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtpZih0aGlzLmNoZWNrSG9sZXNJblNoZWxsKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7aWYodGhpcy5jaGVja0hvbGVzTm90TmVzdGVkKG8saSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgT3Qpe2Zvcih2YXIgYT1hcmd1bWVudHNbMF0sdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSW52YWxpZENvb3JkaW5hdGVzKGwpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDbG9zZWRSaW5ncyhsKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH12YXIgaT1uZXcgJG4oMCxhKTtpZih0aGlzLmNoZWNrVG9vRmV3UG9pbnRzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsO2lmKHRoaXMuY2hlY2tDb25zaXN0ZW50QXJlYShpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbDtpZighdGhpcy5pc1NlbGZUb3VjaGluZ1JpbmdGb3JtaW5nSG9sZVZhbGlkJiYodGhpcy5jaGVja05vU2VsZkludGVyc2VjdGluZ1JpbmdzKGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKSlyZXR1cm4gbnVsbDtmb3IodmFyIHU9MDt1PGEuZ2V0TnVtR2VvbWV0cmllcygpO3UrKyl7dmFyIGw9YS5nZXRHZW9tZXRyeU4odSk7aWYodGhpcy5jaGVja0hvbGVzSW5TaGVsbChsLGkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfWZvcih2YXIgdT0wO3U8YS5nZXROdW1HZW9tZXRyaWVzKCk7dSsrKXt2YXIgbD1hLmdldEdlb21ldHJ5Tih1KTtpZih0aGlzLmNoZWNrSG9sZXNOb3ROZXN0ZWQobCxpKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1pZih0aGlzLmNoZWNrU2hlbGxzTm90TmVzdGVkKGEsaSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7dGhpcy5jaGVja0Nvbm5lY3RlZEludGVyaW9ycyhpKX1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZnQpZm9yKHZhciBoPWFyZ3VtZW50c1swXSx1PTA7dTxoLmdldE51bUdlb21ldHJpZXMoKTt1Kyspe3ZhciBjPWguZ2V0R2VvbWV0cnlOKHUpO2lmKHRoaXMuY2hlY2tWYWxpZChjKSxudWxsIT09dGhpcy52YWxpZEVycilyZXR1cm4gbnVsbH1lbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIGY9YXJndW1lbnRzWzBdO2lmKHRoaXMudmFsaWRFcnI9bnVsbCxmLmlzRW1wdHkoKSlyZXR1cm4gbnVsbDtpZihmIGluc3RhbmNlb2YgTHQpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFB0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBidCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZSBpZihmIGluc3RhbmNlb2YgU3QpdGhpcy5jaGVja1ZhbGlkKGYpO2Vsc2UgaWYoZiBpbnN0YW5jZW9mIFR0KXRoaXMuY2hlY2tWYWxpZChmKTtlbHNlIGlmKGYgaW5zdGFuY2VvZiBPdCl0aGlzLmNoZWNrVmFsaWQoZik7ZWxzZXtpZighKGYgaW5zdGFuY2VvZiBmdCkpdGhyb3cgbmV3IFVuc3VwcG9ydGVkT3BlcmF0aW9uRXhjZXB0aW9uKGYuZ2V0Q2xhc3MoKS5nZXROYW1lKCkpO3RoaXMuY2hlY2tWYWxpZChmKX19fSxzZXRTZWxmVG91Y2hpbmdSaW5nRm9ybWluZ0hvbGVWYWxpZDpmdW5jdGlvbih0KXt0aGlzLmlzU2VsZlRvdWNoaW5nUmluZ0Zvcm1pbmdIb2xlVmFsaWQ9dH0sY2hlY2tTaGVsbE5vdE5lc3RlZDpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRDb29yZGluYXRlcygpLHI9ZS5nZXRFeHRlcmlvclJpbmcoKSxzPXIuZ2V0Q29vcmRpbmF0ZXMoKSxvPWxzLmZpbmRQdE5vdE5vZGUoaSxyLG4pO2lmKG51bGw9PT1vKXJldHVybiBudWxsO3ZhciBhPWhlLmlzUG9pbnRJblJpbmcobyxzKTtpZighYSlyZXR1cm4gbnVsbDtpZihlLmdldE51bUludGVyaW9yUmluZygpPD0wKXJldHVybiB0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5ORVNURURfU0hFTExTLG8pLG51bGw7Zm9yKHZhciB1PW51bGwsbD0wO2w8ZS5nZXROdW1JbnRlcmlvclJpbmcoKTtsKyspe3ZhciBoPWUuZ2V0SW50ZXJpb3JSaW5nTihsKTtpZih1PXRoaXMuY2hlY2tTaGVsbEluc2lkZUhvbGUodCxoLG4pLG51bGw9PT11KXJldHVybiBudWxsfXRoaXMudmFsaWRFcnI9bmV3IHVzKHVzLk5FU1RFRF9TSEVMTFMsdSl9LGNoZWNrQ2xvc2VkUmluZ3M6ZnVuY3Rpb24odCl7aWYodGhpcy5jaGVja0Nsb3NlZFJpbmcodC5nZXRFeHRlcmlvclJpbmcoKSksbnVsbCE9PXRoaXMudmFsaWRFcnIpcmV0dXJuIG51bGw7Zm9yKHZhciBlPTA7ZTx0LmdldE51bUludGVyaW9yUmluZygpO2UrKylpZih0aGlzLmNoZWNrQ2xvc2VkUmluZyh0LmdldEludGVyaW9yUmluZ04oZSkpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfSxjaGVja0Nsb3NlZFJpbmc6ZnVuY3Rpb24odCl7aWYoIXQuaXNDbG9zZWQoKSl7dmFyIGU9bnVsbDt0LmdldE51bVBvaW50cygpPj0xJiYoZT10LmdldENvb3JkaW5hdGVOKDApKSx0aGlzLnZhbGlkRXJyPW5ldyB1cyh1cy5SSU5HX05PVF9DTE9TRUQsZSl9fSxjaGVja1NoZWxsc05vdE5lc3RlZDpmdW5jdGlvbih0LGUpe2Zvcih2YXIgbj0wO248dC5nZXROdW1HZW9tZXRyaWVzKCk7bisrKWZvcih2YXIgaT10LmdldEdlb21ldHJ5TihuKSxyPWkuZ2V0RXh0ZXJpb3JSaW5nKCkscz0wO3M8dC5nZXROdW1HZW9tZXRyaWVzKCk7cysrKWlmKG4hPT1zKXt2YXIgbz10LmdldEdlb21ldHJ5TihzKTtpZih0aGlzLmNoZWNrU2hlbGxOb3ROZXN0ZWQocixvLGUpLG51bGwhPT10aGlzLnZhbGlkRXJyKXJldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbHN9fSksbHMuZmluZFB0Tm90Tm9kZT1mdW5jdGlvbih0LGUsbil7Zm9yKHZhciBpPW4uZmluZEVkZ2UoZSkscj1pLmdldEVkZ2VJbnRlcnNlY3Rpb25MaXN0KCkscz0wO3M8dC5sZW5ndGg7cysrKXt2YXIgbz10W3NdO2lmKCFyLmlzSW50ZXJzZWN0aW9uKG8pKXJldHVybiBvfXJldHVybiBudWxsfSxscy5pc1ZhbGlkPWZ1bmN0aW9uKCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBCKXt2YXIgdD1hcmd1bWVudHNbMF0sZT1uZXcgbHModCk7cmV0dXJuIGUuaXNWYWxpZCgpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIG49YXJndW1lbnRzWzBdO3JldHVybiByLmlzTmFOKG4ueCk/ITE6ci5pc0luZmluaXRlKG4ueCk/ITE6ci5pc05hTihuLnkpPyExOiFyLmlzSW5maW5pdGUobi55KX19O3ZhciBibz1PYmplY3QuZnJlZXplKHtJc1ZhbGlkT3A6bHN9KSxPbz1PYmplY3QuZnJlZXplKHtCb3VuZGFyeU9wOmR0LElzU2ltcGxlT3A6R2ksYnVmZmVyOkNvLGRpc3RhbmNlOlNvLGxpbmVtZXJnZTp3byxvdmVybGF5OkxvLHBvbHlnb25pemU6Um8scmVsYXRlOlRvLHVuaW9uOlBvLHZhbGlkOmJvfSk7aChocyxfdC5Db29yZGluYXRlT3BlcmF0aW9uKSxlKGhzLnByb3RvdHlwZSx7ZWRpdENvb3JkaW5hdGVzOmZ1bmN0aW9uKHQsZSl7aWYoMD09PXQubGVuZ3RoKXJldHVybiBudWxsO2Zvcih2YXIgbj1uZXcgQXJyYXkodC5sZW5ndGgpLmZpbGwobnVsbCksaT0wO2k8dC5sZW5ndGg7aSsrKXt2YXIgcj1uZXcgZyh0W2ldKTt0aGlzLnRhcmdldFBNLm1ha2VQcmVjaXNlKHIpLG5baV09cn12YXIgcz1uZXcgTihuLCExKSxvPXMudG9Db29yZGluYXRlQXJyYXkoKSxhPTA7ZSBpbnN0YW5jZW9mIFN0JiYoYT0yKSxlIGluc3RhbmNlb2YgYnQmJihhPTQpO3ZhciB1PW47cmV0dXJuIHRoaXMucmVtb3ZlQ29sbGFwc2VkJiYodT1udWxsKSxvLmxlbmd0aDxhP3U6b30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gaHN9fSksZShjcy5wcm90b3R5cGUse2ZpeFBvbHlnb25hbFRvcG9sb2d5OmZ1bmN0aW9uKHQpe3ZhciBlPXQ7dGhpcy5jaGFuZ2VQcmVjaXNpb25Nb2RlbHx8KGU9dGhpcy5jaGFuZ2VQTSh0LHRoaXMudGFyZ2V0UE0pKTt2YXIgbj1lLmJ1ZmZlcigwKSxpPW47cmV0dXJuIHRoaXMuY2hhbmdlUHJlY2lzaW9uTW9kZWx8fChpPXQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5KG4pKSxpfSxyZWR1Y2VQb2ludHdpc2U6ZnVuY3Rpb24odCl7dmFyIGU9bnVsbDtpZih0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsKXt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodC5nZXRGYWN0b3J5KCksdGhpcy50YXJnZXRQTSk7ZT1uZXcgX3Qobil9ZWxzZSBlPW5ldyBfdDt2YXIgaT10aGlzLnJlbW92ZUNvbGxhcHNlZDt0LmdldERpbWVuc2lvbigpPj0yJiYoaT0hMCk7dmFyIHI9ZS5lZGl0KHQsbmV3IGhzKHRoaXMudGFyZ2V0UE0saSkpO3JldHVybiByfSxjaGFuZ2VQTTpmdW5jdGlvbih0LGUpe3ZhciBuPXRoaXMuY3JlYXRlRWRpdG9yKHQuZ2V0RmFjdG9yeSgpLGUpO3JldHVybiBuLmVkaXQodCxuZXcgX3QuTm9PcEdlb21ldHJ5T3BlcmF0aW9uKX0sc2V0UmVtb3ZlQ29sbGFwc2VkQ29tcG9uZW50czpmdW5jdGlvbih0KXt0aGlzLnJlbW92ZUNvbGxhcHNlZD10fSxjcmVhdGVGYWN0b3J5OmZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGllKGUsdC5nZXRTUklEKCksdC5nZXRDb29yZGluYXRlU2VxdWVuY2VGYWN0b3J5KCkpO3JldHVybiBufSxzZXRDaGFuZ2VQcmVjaXNpb25Nb2RlbDpmdW5jdGlvbih0KXt0aGlzLmNoYW5nZVByZWNpc2lvbk1vZGVsPXR9LHJlZHVjZTpmdW5jdGlvbih0KXt2YXIgZT10aGlzLnJlZHVjZVBvaW50d2lzZSh0KTtyZXR1cm4gdGhpcy5pc1BvaW50d2lzZT9lOlIoZSxSdCk/ZS5pc1ZhbGlkKCk/ZTp0aGlzLmZpeFBvbHlnb25hbFRvcG9sb2d5KGUpOmV9LHNldFBvaW50d2lzZTpmdW5jdGlvbih0KXt0aGlzLmlzUG9pbnR3aXNlPXR9LGNyZWF0ZUVkaXRvcjpmdW5jdGlvbih0LGUpe2lmKHQuZ2V0UHJlY2lzaW9uTW9kZWwoKT09PWUpcmV0dXJuIG5ldyBfdDt2YXIgbj10aGlzLmNyZWF0ZUZhY3RvcnkodCxlKSxpPW5ldyBfdChuKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gY3N9fSksY3MucmVkdWNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnJlZHVjZSh0KX0sY3MucmVkdWNlUG9pbnR3aXNlPWZ1bmN0aW9uKHQsZSl7dmFyIG49bmV3IGNzKGUpO3JldHVybiBuLnNldFBvaW50d2lzZSghMCksbi5yZWR1Y2UodCl9O3ZhciBfbz1PYmplY3QuZnJlZXplKHtHZW9tZXRyeVByZWNpc2lvblJlZHVjZXI6Y3N9KTtlKGZzLnByb3RvdHlwZSx7c2ltcGxpZnlTZWN0aW9uOmZ1bmN0aW9uKHQsZSl7aWYodCsxPT09ZSlyZXR1cm4gbnVsbDt0aGlzLnNlZy5wMD10aGlzLnB0c1t0XSx0aGlzLnNlZy5wMT10aGlzLnB0c1tlXTtmb3IodmFyIG49LTEsaT10LHI9dCsxO2U+cjtyKyspe3ZhciBzPXRoaXMuc2VnLmRpc3RhbmNlKHRoaXMucHRzW3JdKTtzPm4mJihuPXMsaT1yKX1pZihuPD10aGlzLmRpc3RhbmNlVG9sZXJhbmNlKWZvcih2YXIgcj10KzE7ZT5yO3IrKyl0aGlzLnVzZVB0W3JdPSExO2Vsc2UgdGhpcy5zaW1wbGlmeVNlY3Rpb24odCxpKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbihpLGUpfSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLmRpc3RhbmNlVG9sZXJhbmNlPXR9LHNpbXBsaWZ5OmZ1bmN0aW9uKCl7dGhpcy51c2VQdD1uZXcgQXJyYXkodGhpcy5wdHMubGVuZ3RoKS5maWxsKG51bGwpO2Zvcih2YXIgdD0wO3Q8dGhpcy5wdHMubGVuZ3RoO3QrKyl0aGlzLnVzZVB0W3RdPSEwO3RoaXMuc2ltcGxpZnlTZWN0aW9uKDAsdGhpcy5wdHMubGVuZ3RoLTEpO2Zvcih2YXIgZT1uZXcgTix0PTA7dDx0aGlzLnB0cy5sZW5ndGg7dCsrKXRoaXMudXNlUHRbdF0mJmUuYWRkKG5ldyBnKHRoaXMucHRzW3RdKSk7cmV0dXJuIGUudG9Db29yZGluYXRlQXJyYXkoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZnN9fSksZnMuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZnModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5zaW1wbGlmeSgpfSxlKGdzLnByb3RvdHlwZSx7c2V0RW5zdXJlVmFsaWQ6ZnVuY3Rpb24odCl7dGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3k9dH0sZ2V0UmVzdWx0R2VvbWV0cnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnB1dEdlb20uaXNFbXB0eSgpP3RoaXMuaW5wdXRHZW9tLmNvcHkoKTpuZXcgZHModGhpcy5pc0Vuc3VyZVZhbGlkVG9wb2xvZ3ksdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSkudHJhbnNmb3JtKHRoaXMuaW5wdXRHZW9tKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7aWYoMD50KXRocm93IG5ldyBpKFwiVG9sZXJhbmNlIG11c3QgYmUgbm9uLW5lZ2F0aXZlXCIpO3RoaXMuZGlzdGFuY2VUb2xlcmFuY2U9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gZ3N9fSksZ3Muc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZ3ModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKGRzLHhlKSxlKGRzLnByb3RvdHlwZSx7dHJhbnNmb3JtUG9seWdvbjpmdW5jdGlvbih0LGUpe2lmKHQuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1Qb2x5Z29uLmNhbGwodGhpcyx0LGUpO3JldHVybiBlIGluc3RhbmNlb2YgT3Q/bjp0aGlzLmNyZWF0ZVZhbGlkQXJlYShuKX0sY3JlYXRlVmFsaWRBcmVhOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzRW5zdXJlVmFsaWRUb3BvbG9neT90LmJ1ZmZlcigwKTp0fSx0cmFuc2Zvcm1Db29yZGluYXRlczpmdW5jdGlvbih0LGUpe3ZhciBuPXQudG9Db29yZGluYXRlQXJyYXkoKSxpPW51bGw7cmV0dXJuIGk9MD09PW4ubGVuZ3RoP25ldyBBcnJheSgwKS5maWxsKG51bGwpOmZzLnNpbXBsaWZ5KG4sdGhpcy5kaXN0YW5jZVRvbGVyYW5jZSksdGhpcy5mYWN0b3J5LmdldENvb3JkaW5hdGVTZXF1ZW5jZUZhY3RvcnkoKS5jcmVhdGUoaSl9LHRyYW5zZm9ybU11bHRpUG9seWdvbjpmdW5jdGlvbih0LGUpe3ZhciBuPXhlLnByb3RvdHlwZS50cmFuc2Zvcm1NdWx0aVBvbHlnb24uY2FsbCh0aGlzLHQsZSk7cmV0dXJuIHRoaXMuY3JlYXRlVmFsaWRBcmVhKG4pfSx0cmFuc2Zvcm1MaW5lYXJSaW5nOmZ1bmN0aW9uKHQsZSl7dmFyIG49ZSBpbnN0YW5jZW9mIFR0LGk9eGUucHJvdG90eXBlLnRyYW5zZm9ybUxpbmVhclJpbmcuY2FsbCh0aGlzLHQsZSk7cmV0dXJuIW58fGkgaW5zdGFuY2VvZiBidD9pOm51bGx9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGRzfX0pLGdzLkRQVHJhbnNmb3JtZXI9ZHMsaChwcyxjZSksZShwcy5wcm90b3R5cGUse2dldEluZGV4OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5kZXh9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gcHN9fSksZSh2cy5wcm90b3R5cGUse2FkZFRvUmVzdWx0OmZ1bmN0aW9uKHQpe3RoaXMucmVzdWx0U2Vncy5hZGQodCl9LGFzTGluZVN0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVTdHJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRSZXN1bHRTaXplOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5yZXN1bHRTZWdzLnNpemUoKTtyZXR1cm4gMD09PXQ/MDp0KzF9LGdldFBhcmVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmV9LGdldFNlZ21lbnQ6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuc2Vnc1t0XX0sZ2V0UGFyZW50Q29vcmRpbmF0ZXM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJlbnRMaW5lLmdldENvb3JkaW5hdGVzKCl9LGdldE1pbmltdW1TaXplOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubWluaW11bVNpemV9LGFzTGluZWFyUmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcmVudExpbmUuZ2V0RmFjdG9yeSgpLmNyZWF0ZUxpbmVhclJpbmcodnMuZXh0cmFjdENvb3JkaW5hdGVzKHRoaXMucmVzdWx0U2VncykpfSxnZXRTZWdtZW50czpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ3N9LGluaXQ6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLnBhcmVudExpbmUuZ2V0Q29vcmRpbmF0ZXMoKTt0aGlzLnNlZ3M9bmV3IEFycmF5KHQubGVuZ3RoLTEpLmZpbGwobnVsbCk7Zm9yKHZhciBlPTA7ZTx0Lmxlbmd0aC0xO2UrKyl7dmFyIG49bmV3IHBzKHRbZV0sdFtlKzFdLHRoaXMucGFyZW50TGluZSxlKTt0aGlzLnNlZ3NbZV09bn19LGdldFJlc3VsdENvb3JkaW5hdGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHZzLmV4dHJhY3RDb29yZGluYXRlcyh0aGlzLnJlc3VsdFNlZ3MpfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB2c319KSx2cy5leHRyYWN0Q29vcmRpbmF0ZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBBcnJheSh0LnNpemUoKSsxKS5maWxsKG51bGwpLG49bnVsbCxpPTA7aTx0LnNpemUoKTtpKyspbj10LmdldChpKSxlW2ldPW4ucDA7cmV0dXJuIGVbZS5sZW5ndGgtMV09bi5wMSxlfSxlKG1zLnByb3RvdHlwZSx7cmVtb3ZlOmZ1bmN0aW9uKHQpe3RoaXMuaW5kZXgucmVtb3ZlKG5ldyBDKHQucDAsdC5wMSksdCl9LGFkZDpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgdnMpZm9yKHZhciB0PWFyZ3VtZW50c1swXSxlPXQuZ2V0U2VnbWVudHMoKSxuPTA7bjxlLmxlbmd0aDtuKyspe3ZhciBpPWVbbl07dGhpcy5hZGQoaSl9ZWxzZSBpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGNlKXt2YXIgcj1hcmd1bWVudHNbMF07dGhpcy5pbmRleC5pbnNlcnQobmV3IEMoci5wMCxyLnAxKSxyKX19LHF1ZXJ5OmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBDKHQucDAsdC5wMSksbj1uZXcgeXModCk7dGhpcy5pbmRleC5xdWVyeShlLG4pO3ZhciBpPW4uZ2V0SXRlbXMoKTtyZXR1cm4gaX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbXN9fSksZSh5cy5wcm90b3R5cGUse3Zpc2l0SXRlbTpmdW5jdGlvbih0KXt2YXIgZT10O0MuaW50ZXJzZWN0cyhlLnAwLGUucDEsdGhpcy5xdWVyeVNlZy5wMCx0aGlzLnF1ZXJ5U2VnLnAxKSYmdGhpcy5pdGVtcy5hZGQodCl9LGdldEl0ZW1zOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaXRlbXN9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FlXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4geXN9fSksZSh4cy5wcm90b3R5cGUse2ZsYXR0ZW46ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmxpbmVQdHNbdF0saT10aGlzLmxpbmVQdHNbZV0scj1uZXcgY2UobixpKTtyZXR1cm4gdGhpcy5yZW1vdmUodGhpcy5saW5lLHQsZSksdGhpcy5vdXRwdXRJbmRleC5hZGQocikscn0saGFzQmFkSW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gdGhpcy5oYXNCYWRPdXRwdXRJbnRlcnNlY3Rpb24obik/ITA6ISF0aGlzLmhhc0JhZElucHV0SW50ZXJzZWN0aW9uKHQsZSxuKX0sc2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeVNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe24rPTE7dmFyIGk9bmV3IEFycmF5KDIpLmZpbGwobnVsbCk7aWYodCsxPT09ZSl7dmFyIHI9dGhpcy5saW5lLmdldFNlZ21lbnQodCk7cmV0dXJuIHRoaXMubGluZS5hZGRUb1Jlc3VsdChyKSxudWxsfXZhciBzPSEwO2lmKHRoaXMubGluZS5nZXRSZXN1bHRTaXplKCk8dGhpcy5saW5lLmdldE1pbmltdW1TaXplKCkpe3ZhciBvPW4rMTtvPHRoaXMubGluZS5nZXRNaW5pbXVtU2l6ZSgpJiYocz0hMSl9dmFyIGE9bmV3IEFycmF5KDEpLmZpbGwobnVsbCksdT10aGlzLmZpbmRGdXJ0aGVzdFBvaW50KHRoaXMubGluZVB0cyx0LGUsYSk7YVswXT50aGlzLmRpc3RhbmNlVG9sZXJhbmNlJiYocz0hMSk7dmFyIGw9bmV3IGNlO2lmKGwucDA9dGhpcy5saW5lUHRzW3RdLGwucDE9dGhpcy5saW5lUHRzW2VdLGlbMF09dCxpWzFdPWUsdGhpcy5oYXNCYWRJbnRlcnNlY3Rpb24odGhpcy5saW5lLGksbCkmJihzPSExKSxzKXt2YXIgcj10aGlzLmZsYXR0ZW4odCxlKTtyZXR1cm4gdGhpcy5saW5lLmFkZFRvUmVzdWx0KHIpLG51bGx9dGhpcy5zaW1wbGlmeVNlY3Rpb24odCx1LG4pLHRoaXMuc2ltcGxpZnlTZWN0aW9uKHUsZSxuKX0saGFzQmFkT3V0cHV0SW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10aGlzLm91dHB1dEluZGV4LnF1ZXJ5KHQpLG49ZS5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7aWYodGhpcy5oYXNJbnRlcmlvckludGVyc2VjdGlvbihpLHQpKXJldHVybiEwfXJldHVybiExfSxmaW5kRnVydGhlc3RQb2ludDpmdW5jdGlvbih0LGUsbixpKXt2YXIgcj1uZXcgY2U7ci5wMD10W2VdLHIucDE9dFtuXTtmb3IodmFyIHM9LTEsbz1lLGE9ZSsxO24+YTthKyspe3ZhciB1PXRbYV0sbD1yLmRpc3RhbmNlKHUpO2w+cyYmKHM9bCxvPWEpfXJldHVybiBpWzBdPXMsb30sc2ltcGxpZnk6ZnVuY3Rpb24odCl7dGhpcy5saW5lPXQsdGhpcy5saW5lUHRzPXQuZ2V0UGFyZW50Q29vcmRpbmF0ZXMoKSx0aGlzLnNpbXBsaWZ5U2VjdGlvbigwLHRoaXMubGluZVB0cy5sZW5ndGgtMSwwKX0scmVtb3ZlOmZ1bmN0aW9uKHQsZSxuKXtmb3IodmFyIGk9ZTtuPmk7aSsrKXt2YXIgcj10LmdldFNlZ21lbnQoaSk7dGhpcy5pbnB1dEluZGV4LnJlbW92ZShyKX19LGhhc0ludGVyaW9ySW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIHRoaXMubGkuY29tcHV0ZUludGVyc2VjdGlvbih0LnAwLHQucDEsZS5wMCxlLnAxKSx0aGlzLmxpLmlzSW50ZXJpb3JJbnRlcnNlY3Rpb24oKX0saGFzQmFkSW5wdXRJbnRlcnNlY3Rpb246ZnVuY3Rpb24odCxlLG4pe2Zvcih2YXIgaT10aGlzLmlucHV0SW5kZXgucXVlcnkobikscj1pLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgcz1yLm5leHQoKTtpZih0aGlzLmhhc0ludGVyaW9ySW50ZXJzZWN0aW9uKHMsbikpe2lmKHhzLmlzSW5MaW5lU2VjdGlvbih0LGUscykpY29udGludWU7cmV0dXJuITB9fXJldHVybiExfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiB4c319KSx4cy5pc0luTGluZVNlY3Rpb249ZnVuY3Rpb24odCxlLG4pe2lmKG4uZ2V0UGFyZW50KCkhPT10LmdldFBhcmVudCgpKXJldHVybiExO3ZhciBpPW4uZ2V0SW5kZXgoKTtyZXR1cm4gaT49ZVswXSYmaTxlWzFdfSxlKEVzLnByb3RvdHlwZSx7c2V0RGlzdGFuY2VUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy5kaXN0YW5jZVRvbGVyYW5jZT10fSxzaW1wbGlmeTpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl0aGlzLmlucHV0SW5kZXguYWRkKGUubmV4dCgpKTtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49bmV3IHhzKHRoaXMuaW5wdXRJbmRleCx0aGlzLm91dHB1dEluZGV4KTtuLnNldERpc3RhbmNlVG9sZXJhbmNlKHRoaXMuZGlzdGFuY2VUb2xlcmFuY2UpLG4uc2ltcGxpZnkoZS5uZXh0KCkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRXN9fSksZShJcy5wcm90b3R5cGUse2dldFJlc3VsdEdlb21ldHJ5OmZ1bmN0aW9uKCl7aWYodGhpcy5pbnB1dEdlb20uaXNFbXB0eSgpKXJldHVybiB0aGlzLmlucHV0R2VvbS5jb3B5KCk7dGhpcy5saW5lc3RyaW5nTWFwPW5ldyB0ZSx0aGlzLmlucHV0R2VvbS5hcHBseShuZXcgQ3ModGhpcykpLHRoaXMubGluZVNpbXBsaWZpZXIuc2ltcGxpZnkodGhpcy5saW5lc3RyaW5nTWFwLnZhbHVlcygpKTt2YXIgdD1uZXcgTnModGhpcy5saW5lc3RyaW5nTWFwKS50cmFuc2Zvcm0odGhpcy5pbnB1dEdlb20pO3JldHVybiB0fSxzZXREaXN0YW5jZVRvbGVyYW5jZTpmdW5jdGlvbih0KXtpZigwPnQpdGhyb3cgbmV3IGkoXCJUb2xlcmFuY2UgbXVzdCBiZSBub24tbmVnYXRpdmVcIik7dGhpcy5saW5lU2ltcGxpZmllci5zZXREaXN0YW5jZVRvbGVyYW5jZSh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSXN9fSksSXMuc2ltcGxpZnk9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSXModCk7cmV0dXJuIG4uc2V0RGlzdGFuY2VUb2xlcmFuY2UoZSksbi5nZXRSZXN1bHRHZW9tZXRyeSgpfSxoKE5zLHhlKSxlKE5zLnByb3RvdHlwZSx7dHJhbnNmb3JtQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCxlKXtpZigwPT09dC5zaXplKCkpcmV0dXJuIG51bGw7aWYoZSBpbnN0YW5jZW9mIFN0KXt2YXIgbj10aGlzLmxpbmVzdHJpbmdNYXAuZ2V0KGUpO3JldHVybiB0aGlzLmNyZWF0ZUNvb3JkaW5hdGVTZXF1ZW5jZShuLmdldFJlc3VsdENvb3JkaW5hdGVzKCkpfXJldHVybiB4ZS5wcm90b3R5cGUudHJhbnNmb3JtQ29vcmRpbmF0ZXMuY2FsbCh0aGlzLHQsZSl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIE5zfX0pLGUoQ3MucHJvdG90eXBlLHtmaWx0ZXI6ZnVuY3Rpb24odCl7aWYodCBpbnN0YW5jZW9mIFN0KXt2YXIgZT10O2lmKGUuaXNFbXB0eSgpKXJldHVybiBudWxsO3ZhciBuPWUuaXNDbG9zZWQoKT80OjIsaT1uZXcgdnMoZSxuKTt0aGlzLnRwcy5saW5lc3RyaW5nTWFwLnB1dChlLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bcV19LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIENzfX0pLElzLkxpbmVTdHJpbmdUcmFuc2Zvcm1lcj1OcyxJcy5MaW5lU3RyaW5nTWFwQnVpbGRlckZpbHRlcj1Dczt2YXIgTW89T2JqZWN0LmZyZWV6ZSh7RG91Z2xhc1BldWNrZXJTaW1wbGlmaWVyOmdzLFRvcG9sb2d5UHJlc2VydmluZ1NpbXBsaWZpZXI6SXN9KTtlKFNzLnByb3RvdHlwZSx7c3BsaXRBdDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLm1pbmltdW1MZW4vdGhpcy5zZWdMZW47aWYodC5kaXN0YW5jZSh0aGlzLnNlZy5wMCk8dGhpcy5taW5pbXVtTGVuKXJldHVybiB0aGlzLnNwbGl0UHQ9dGhpcy5zZWcucG9pbnRBbG9uZyhlKSxudWxsO2lmKHQuZGlzdGFuY2UodGhpcy5zZWcucDEpPHRoaXMubWluaW11bUxlbilyZXR1cm4gdGhpcy5zcGxpdFB0PVNzLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuc2VnLGUpLG51bGw7dGhpcy5zcGxpdFB0PXR9ZWxzZSBpZigyPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIG49YXJndW1lbnRzWzBdLGk9YXJndW1lbnRzWzFdLHI9dGhpcy5nZXRDb25zdHJhaW5lZExlbmd0aChuKSxzPXIvdGhpcy5zZWdMZW47aS5lcXVhbHMyRCh0aGlzLnNlZy5wMCk/dGhpcy5zcGxpdFB0PXRoaXMuc2VnLnBvaW50QWxvbmcocyk6dGhpcy5zcGxpdFB0PVNzLnBvaW50QWxvbmdSZXZlcnNlKHRoaXMuc2VnLHMpfX0sc2V0TWluaW11bUxlbmd0aDpmdW5jdGlvbih0KXt0aGlzLm1pbmltdW1MZW49dH0sZ2V0Q29uc3RyYWluZWRMZW5ndGg6ZnVuY3Rpb24odCl7cmV0dXJuIHQ8dGhpcy5taW5pbXVtTGVuP3RoaXMubWluaW11bUxlbjp0fSxnZXRTcGxpdFBvaW50OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3BsaXRQdH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gU3N9fSksU3MucG9pbnRBbG9uZ1JldmVyc2U9ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgZztyZXR1cm4gbi54PXQucDEueC1lKih0LnAxLngtdC5wMC54KSxuLnk9dC5wMS55LWUqKHQucDEueS10LnAwLnkpLG59LGUod3MucHJvdG90eXBlLHtmaW5kU3BsaXRQb2ludDpmdW5jdGlvbih0LGUpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gd3N9fSksZShMcy5wcm90b3R5cGUse2ZpbmRTcGxpdFBvaW50OmZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRMaW5lU2VnbWVudCgpLGk9bi5nZXRMZW5ndGgoKSxyPWkvMixzPW5ldyBTcyhuKSxvPUxzLnByb2plY3RlZFNwbGl0UG9pbnQodCxlKSxhPTIqby5kaXN0YW5jZShlKSouOCx1PWE7cmV0dXJuIHU+ciYmKHU9cikscy5zZXRNaW5pbXVtTGVuZ3RoKHUpLHMuc3BsaXRBdChvKSxzLmdldFNwbGl0UG9pbnQoKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bd3NdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBMc319KSxMcy5wcm9qZWN0ZWRTcGxpdFBvaW50PWZ1bmN0aW9uKHQsZSl7dmFyIG49dC5nZXRMaW5lU2VnbWVudCgpLGk9bi5wcm9qZWN0KGUpO3JldHVybiBpfSxlKFJzLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUnN9fSksUnMudHJpQXJlYT1mdW5jdGlvbih0LGUsbil7cmV0dXJuKGUueC10LngpKihuLnktdC55KS0oZS55LXQueSkqKG4ueC10LngpfSxScy5pc0luQ2lyY2xlREROb3JtYWxpemVkPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPV8udmFsdWVPZih0LngpLnNlbGZTdWJ0cmFjdChpLngpLHM9Xy52YWx1ZU9mKHQueSkuc2VsZlN1YnRyYWN0KGkueSksbz1fLnZhbHVlT2YoZS54KS5zZWxmU3VidHJhY3QoaS54KSxhPV8udmFsdWVPZihlLnkpLnNlbGZTdWJ0cmFjdChpLnkpLHU9Xy52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KGkueCksbD1fLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QoaS55KSxoPXIubXVsdGlwbHkoYSkuc2VsZlN1YnRyYWN0KG8ubXVsdGlwbHkocykpLGM9by5tdWx0aXBseShsKS5zZWxmU3VidHJhY3QodS5tdWx0aXBseShhKSksZj11Lm11bHRpcGx5KHMpLnNlbGZTdWJ0cmFjdChyLm11bHRpcGx5KGwpKSxnPXIubXVsdGlwbHkocikuc2VsZkFkZChzLm11bHRpcGx5KHMpKSxkPW8ubXVsdGlwbHkobykuc2VsZkFkZChhLm11bHRpcGx5KGEpKSxwPXUubXVsdGlwbHkodSkuc2VsZkFkZChsLm11bHRpcGx5KGwpKSx2PWcuc2VsZk11bHRpcGx5KGMpLnNlbGZBZGQoZC5zZWxmTXVsdGlwbHkoZikpLnNlbGZBZGQocC5zZWxmTXVsdGlwbHkoaCkpLG09di5kb3VibGVWYWx1ZSgpPjA7cmV0dXJuIG19LFJzLmNoZWNrUm9idXN0SW5DaXJjbGU9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9UnMuaXNJbkNpcmNsZU5vblJvYnVzdCh0LGUsbixpKSxzPVJzLmlzSW5DaXJjbGVERFNsb3codCxlLG4saSksbz1Scy5pc0luQ2lyY2xlQ0ModCxlLG4saSksYT1jaS5jaXJjdW1jZW50cmUodCxlLG4pO0Eub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpLXQuZGlzdGFuY2UoYSkpL3QuZGlzdGFuY2UoYSkpLHI9PT1zJiZyPT09b3x8KEEub3V0LnByaW50bG4oXCJpbkNpcmNsZSByb2J1c3RuZXNzIGZhaWx1cmUgKGRvdWJsZSByZXN1bHQgPSBcIityK1wiLCBERCByZXN1bHQgPSBcIitzK1wiLCBDQyByZXN1bHQgPSBcIitvK1wiKVwiKSxBLm91dC5wcmludGxuKHNlLnRvTGluZVN0cmluZyhuZXcgR3QoW3QsZSxuLGldKSkpLEEub3V0LnByaW50bG4oXCJDaXJjdW1jZW50cmUgPSBcIitzZS50b1BvaW50KGEpK1wiIHJhZGl1cyA9IFwiK3QuZGlzdGFuY2UoYSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGEgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL3QuZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGIgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL2UuZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oXCJwIHJhZGl1cyBkaWZmIGMgPSBcIitNYXRoLmFicyhpLmRpc3RhbmNlKGEpL24uZGlzdGFuY2UoYSktMSkpLEEub3V0LnByaW50bG4oKSl9LFJzLmlzSW5DaXJjbGVEREZhc3Q9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy5zcXIodC54KS5zZWxmQWRkKF8uc3FyKHQueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KGUsbixpKSkscz1fLnNxcihlLngpLnNlbGZBZGQoXy5zcXIoZS55KSkuc2VsZk11bHRpcGx5KFJzLnRyaUFyZWFEREZhc3QodCxuLGkpKSxvPV8uc3FyKG4ueCkuc2VsZkFkZChfLnNxcihuLnkpKS5zZWxmTXVsdGlwbHkoUnMudHJpQXJlYURERmFzdCh0LGUsaSkpLGE9Xy5zcXIoaS54KS5zZWxmQWRkKF8uc3FyKGkueSkpLnNlbGZNdWx0aXBseShScy50cmlBcmVhRERGYXN0KHQsZSxuKSksdT1yLnNlbGZTdWJ0cmFjdChzKS5zZWxmQWRkKG8pLnNlbGZTdWJ0cmFjdChhKSxsPXUuZG91YmxlVmFsdWUoKT4wO3JldHVybiBsfSxScy5pc0luQ2lyY2xlQ0M9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Y2kuY2lyY3VtY2VudHJlKHQsZSxuKSxzPXQuZGlzdGFuY2Uociksbz1pLmRpc3RhbmNlKHIpLXM7cmV0dXJuIDA+PW99LFJzLmlzSW5DaXJjbGVOb3JtYWxpemVkPWZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQueC1pLngscz10LnktaS55LG89ZS54LWkueCxhPWUueS1pLnksdT1uLngtaS54LGw9bi55LWkueSxoPXIqYS1vKnMsYz1vKmwtdSphLGY9dSpzLXIqbCxnPXIqcitzKnMsZD1vKm8rYSphLHA9dSp1K2wqbCx2PWcqYytkKmYrcCpoO3JldHVybiB2PjB9LFJzLmlzSW5DaXJjbGVERFNsb3c9ZnVuY3Rpb24odCxlLG4saSl7dmFyIHI9Xy52YWx1ZU9mKGkueCkscz1fLnZhbHVlT2YoaS55KSxvPV8udmFsdWVPZih0LngpLGE9Xy52YWx1ZU9mKHQueSksdT1fLnZhbHVlT2YoZS54KSxsPV8udmFsdWVPZihlLnkpLGg9Xy52YWx1ZU9mKG4ueCksYz1fLnZhbHVlT2Yobi55KSxmPW8ubXVsdGlwbHkobykuYWRkKGEubXVsdGlwbHkoYSkpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3codSxsLGgsYyxyLHMpKSxnPXUubXVsdGlwbHkodSkuYWRkKGwubXVsdGlwbHkobCkpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLGgsYyxyLHMpKSxkPWgubXVsdGlwbHkoaCkuYWRkKGMubXVsdGlwbHkoYykpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLHUsbCxyLHMpKSxwPXIubXVsdGlwbHkocikuYWRkKHMubXVsdGlwbHkocykpLm11bHRpcGx5KFJzLnRyaUFyZWFERFNsb3cobyxhLHUsbCxoLGMpKSx2PWYuc3VidHJhY3QoZykuYWRkKGQpLnN1YnRyYWN0KHApLG09di5kb3VibGVWYWx1ZSgpPjA7XG5yZXR1cm4gbX0sUnMuaXNJbkNpcmNsZU5vblJvYnVzdD1mdW5jdGlvbih0LGUsbixpKXt2YXIgcj0odC54KnQueCt0LnkqdC55KSpScy50cmlBcmVhKGUsbixpKS0oZS54KmUueCtlLnkqZS55KSpScy50cmlBcmVhKHQsbixpKSsobi54Km4ueCtuLnkqbi55KSpScy50cmlBcmVhKHQsZSxpKS0oaS54KmkueCtpLnkqaS55KSpScy50cmlBcmVhKHQsZSxuKT4wO3JldHVybiByfSxScy5pc0luQ2lyY2xlUm9idXN0PWZ1bmN0aW9uKHQsZSxuLGkpe3JldHVybiBScy5pc0luQ2lyY2xlTm9ybWFsaXplZCh0LGUsbixpKX0sUnMudHJpQXJlYUREU2xvdz1mdW5jdGlvbih0LGUsbixpLHIscyl7cmV0dXJuIG4uc3VidHJhY3QodCkubXVsdGlwbHkocy5zdWJ0cmFjdChlKSkuc3VidHJhY3QoaS5zdWJ0cmFjdChlKS5tdWx0aXBseShyLnN1YnRyYWN0KHQpKSl9LFJzLnRyaUFyZWFEREZhc3Q9ZnVuY3Rpb24odCxlLG4pe3ZhciBpPV8udmFsdWVPZihlLngpLnNlbGZTdWJ0cmFjdCh0LngpLnNlbGZNdWx0aXBseShfLnZhbHVlT2Yobi55KS5zZWxmU3VidHJhY3QodC55KSkscj1fLnZhbHVlT2YoZS55KS5zZWxmU3VidHJhY3QodC55KS5zZWxmTXVsdGlwbHkoXy52YWx1ZU9mKG4ueCkuc2VsZlN1YnRyYWN0KHQueCkpO3JldHVybiBpLnNlbGZTdWJ0cmFjdChyKX0sZShUcy5wcm90b3R5cGUse2NpcmNsZUNlbnRlcjpmdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBUcyh0aGlzLmdldFgoKSx0aGlzLmdldFkoKSksaT10aGlzLmJpc2VjdG9yKG4sdCkscj10aGlzLmJpc2VjdG9yKHQsZSkscz1uZXcgRihpLHIpLG89bnVsbDt0cnl7bz1uZXcgVHMocy5nZXRYKCkscy5nZXRZKCkpfWNhdGNoKGkpe2lmKCEoaSBpbnN0YW5jZW9mIHcpKXRocm93IGk7QS5lcnIucHJpbnRsbihcImE6IFwiK24rXCIgIGI6IFwiK3QrXCIgIGM6IFwiK2UpLEEuZXJyLnByaW50bG4oaSl9ZmluYWxseXt9cmV0dXJuIG99LGRvdDpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5wLngqdC5nZXRYKCkrdGhpcy5wLnkqdC5nZXRZKCl9LG1hZ246ZnVuY3Rpb24oKXtyZXR1cm4gTWF0aC5zcXJ0KHRoaXMucC54KnRoaXMucC54K3RoaXMucC55KnRoaXMucC55KX0sZ2V0WjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAuen0sYmlzZWN0b3I6ZnVuY3Rpb24odCxlKXt2YXIgbj1lLmdldFgoKS10LmdldFgoKSxpPWUuZ2V0WSgpLXQuZ2V0WSgpLHI9bmV3IEYodC5nZXRYKCkrbi8yLHQuZ2V0WSgpK2kvMiwxKSxzPW5ldyBGKHQuZ2V0WCgpLWkrbi8yLHQuZ2V0WSgpK24raS8yLDEpO3JldHVybiBuZXcgRihyLHMpfSxlcXVhbHM6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLnAueD09PXQuZ2V0WCgpJiZ0aGlzLnAueT09PXQuZ2V0WSgpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHRoaXMucC5kaXN0YW5jZShlLmdldENvb3JkaW5hdGUoKSk8bn19LGdldENvb3JkaW5hdGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wfSxpc0luQ2lyY2xlOmZ1bmN0aW9uKHQsZSxuKXtyZXR1cm4gUnMuaXNJbkNpcmNsZVJvYnVzdCh0LnAsZS5wLG4ucCx0aGlzLnApfSxpbnRlcnBvbGF0ZVpWYWx1ZTpmdW5jdGlvbih0LGUsbil7dmFyIGk9dC5nZXRYKCkscj10LmdldFkoKSxzPWUuZ2V0WCgpLWksbz1uLmdldFgoKS1pLGE9ZS5nZXRZKCktcix1PW4uZ2V0WSgpLXIsbD1zKnUtbyphLGg9dGhpcy5nZXRYKCktaSxjPXRoaXMuZ2V0WSgpLXIsZj0odSpoLW8qYykvbCxnPSgtYSpoK3MqYykvbCxkPXQuZ2V0WigpK2YqKGUuZ2V0WigpLXQuZ2V0WigpKStnKihuLmdldFooKS10LmdldFooKSk7cmV0dXJuIGR9LG1pZFBvaW50OmZ1bmN0aW9uKHQpe3ZhciBlPSh0aGlzLnAueCt0LmdldFgoKSkvMixuPSh0aGlzLnAueSt0LmdldFkoKSkvMixpPSh0aGlzLnAueit0LmdldFooKSkvMjtyZXR1cm4gbmV3IFRzKGUsbixpKX0scmlnaHRPZjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0LmRlc3QoKSx0Lm9yaWcoKSl9LGlzQ0NXOmZ1bmN0aW9uKHQsZSl7cmV0dXJuKHQucC54LXRoaXMucC54KSooZS5wLnktdGhpcy5wLnkpLSh0LnAueS10aGlzLnAueSkqKGUucC54LXRoaXMucC54KT4wfSxnZXRYOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucC54fSxjcm9zc1Byb2R1Y3Q6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMucC54KnQuZ2V0WSgpLXRoaXMucC55KnQuZ2V0WCgpfSxzZXRaOmZ1bmN0aW9uKHQpe3RoaXMucC56PXR9LHRpbWVzOmZ1bmN0aW9uKHQpe3JldHVybiBuZXcgVHModCp0aGlzLnAueCx0KnRoaXMucC55KX0sY3Jvc3M6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IFRzKHRoaXMucC55LC10aGlzLnAueCl9LGxlZnRPZjpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5pc0NDVyh0Lm9yaWcoKSx0LmRlc3QoKSl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7cmV0dXJuXCJQT0lOVCAoXCIrdGhpcy5wLngrXCIgXCIrdGhpcy5wLnkrXCIpXCJ9LHN1YjpmdW5jdGlvbih0KXtyZXR1cm4gbmV3IFRzKHRoaXMucC54LXQuZ2V0WCgpLHRoaXMucC55LXQuZ2V0WSgpKX0sZ2V0WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueX0sY2xhc3NpZnk6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLGk9ZS5zdWIodCkscj1uLnN1Yih0KSxzPWkuY3Jvc3NQcm9kdWN0KHIpO3JldHVybiBzPjA/VHMuTEVGVDowPnM/VHMuUklHSFQ6aS5nZXRYKCkqci5nZXRYKCk8MHx8aS5nZXRZKCkqci5nZXRZKCk8MD9Ucy5CRUhJTkQ6aS5tYWduKCk8ci5tYWduKCk/VHMuQkVZT05EOnQuZXF1YWxzKG4pP1RzLk9SSUdJTjplLmVxdWFscyhuKT9Ucy5ERVNUSU5BVElPTjpUcy5CRVRXRUVOfSxzdW06ZnVuY3Rpb24odCl7cmV0dXJuIG5ldyBUcyh0aGlzLnAueCt0LmdldFgoKSx0aGlzLnAueSt0LmdldFkoKSl9LGRpc3RhbmNlOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIE1hdGguc3FydChNYXRoLnBvdyhlLmdldFgoKS10LmdldFgoKSwyKStNYXRoLnBvdyhlLmdldFkoKS10LmdldFkoKSwyKSl9LGNpcmN1bVJhZGl1c1JhdGlvOmZ1bmN0aW9uKHQsZSl7dmFyIG49dGhpcy5jaXJjbGVDZW50ZXIodCxlKSxpPXRoaXMuZGlzdGFuY2Uobix0KSxyPXRoaXMuZGlzdGFuY2UodGhpcyx0KSxzPXRoaXMuZGlzdGFuY2UodCxlKTtyZXR1cm4gcj5zJiYocj1zKSxzPXRoaXMuZGlzdGFuY2UoZSx0aGlzKSxyPnMmJihyPXMpLGkvcn0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gVHN9fSksVHMuaW50ZXJwb2xhdGVaPWZ1bmN0aW9uKCl7aWYoMz09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXSxlPWFyZ3VtZW50c1sxXSxuPWFyZ3VtZW50c1syXSxpPWUuZGlzdGFuY2Uobikscj10LmRpc3RhbmNlKGUpLHM9bi56LWUueixvPWUueitzKihyL2kpO3JldHVybiBvfWlmKDQ9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgYT1hcmd1bWVudHNbMF0sdT1hcmd1bWVudHNbMV0sbD1hcmd1bWVudHNbMl0saD1hcmd1bWVudHNbM10sYz11LngsZj11LnksZz1sLngtYyxkPWgueC1jLHA9bC55LWYsdj1oLnktZixtPWcqdi1kKnAseT1hLngtYyx4PWEueS1mLEU9KHYqeS1kKngpL20sST0oLXAqeStnKngpL20sTj11LnorRSoobC56LXUueikrSSooaC56LXUueik7cmV0dXJuIE59fSxUcy5MRUZUPTAsVHMuUklHSFQ9MSxUcy5CRVlPTkQ9MixUcy5CRUhJTkQ9MyxUcy5CRVRXRUVOPTQsVHMuT1JJR0lOPTUsVHMuREVTVElOQVRJT049NixoKFBzLFRzKSxlKFBzLnByb3RvdHlwZSx7Z2V0Q29uc3RyYWludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvbnN0cmFpbnR9LHNldE9uQ29uc3RyYWludDpmdW5jdGlvbih0KXt0aGlzLl9pc09uQ29uc3RyYWludD10fSxtZXJnZTpmdW5jdGlvbih0KXt0Ll9pc09uQ29uc3RyYWludCYmKHRoaXMuX2lzT25Db25zdHJhaW50PSEwLHRoaXMuY29uc3RyYWludD10LmNvbnN0cmFpbnQpfSxpc09uQ29uc3RyYWludDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9pc09uQ29uc3RyYWludH0sc2V0Q29uc3RyYWludDpmdW5jdGlvbih0KXt0aGlzLl9pc09uQ29uc3RyYWludD0hMCx0aGlzLmNvbnN0cmFpbnQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gUHN9fSksZShicy5wcm90b3R5cGUse2VxdWFsc05vbk9yaWVudGVkOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmVxdWFsc09yaWVudGVkKHQpPyEwOiEhdGhpcy5lcXVhbHNPcmllbnRlZCh0LnN5bSgpKX0sdG9MaW5lU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiBuZXcgY2UodGhpcy52ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZGVzdCgpLmdldENvb3JkaW5hdGUoKSl9LGRlc3Q6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zeW0oKS5vcmlnKCl9LG9OZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubmV4dH0sZXF1YWxzT3JpZW50ZWQ6ZnVuY3Rpb24odCl7cmV0dXJuISghdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmVxdWFsczJEKHQub3JpZygpLmdldENvb3JkaW5hdGUoKSl8fCF0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQodC5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKSl9LGROZXh0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuc3ltKCkub05leHQoKS5zeW0oKX0sbFByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5uZXh0LnN5bSgpfSxyUHJldjpmdW5jdGlvbigpe3JldHVybiB0aGlzLnN5bSgpLm9OZXh0KCl9LHJvdDpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3R9LG9QcmV2OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5uZXh0Ll9yb3R9LHN5bTpmdW5jdGlvbigpe3JldHVybiB0aGlzLl9yb3QuX3JvdH0sc2V0T3JpZzpmdW5jdGlvbih0KXt0aGlzLnZlcnRleD10fSxsTmV4dDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmludlJvdCgpLm9OZXh0KCkucm90KCl9LGdldExlbmd0aDpmdW5jdGlvbigpe3JldHVybiB0aGlzLm9yaWcoKS5nZXRDb29yZGluYXRlKCkuZGlzdGFuY2UodGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpKX0saW52Um90OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuX3JvdC5zeW0oKX0sc2V0RGVzdDpmdW5jdGlvbih0KXt0aGlzLnN5bSgpLnNldE9yaWcodCl9LHNldERhdGE6ZnVuY3Rpb24odCl7dGhpcy5kYXRhPXR9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxkZWxldGU6ZnVuY3Rpb24oKXt0aGlzLl9yb3Q9bnVsbH0sb3JpZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleH0sck5leHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5fcm90Lm5leHQuaW52Um90KCl9LHRvU3RyaW5nOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy52ZXJ0ZXguZ2V0Q29vcmRpbmF0ZSgpLGU9dGhpcy5kZXN0KCkuZ2V0Q29vcmRpbmF0ZSgpO3JldHVybiBzZS50b0xpbmVTdHJpbmcodCxlKX0saXNMaXZlOmZ1bmN0aW9uKCl7cmV0dXJuIG51bGwhPT10aGlzLl9yb3R9LGdldFByaW1hcnk6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLmNvbXBhcmVUbyh0aGlzLmRlc3QoKS5nZXRDb29yZGluYXRlKCkpPD0wP3RoaXM6dGhpcy5zeW0oKX0sZFByZXY6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5pbnZSb3QoKS5vTmV4dCgpLmludlJvdCgpfSxzZXROZXh0OmZ1bmN0aW9uKHQpe3RoaXMubmV4dD10fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBic319KSxicy5tYWtlRWRnZT1mdW5jdGlvbih0LGUpe3ZhciBuPW5ldyBicyxpPW5ldyBicyxyPW5ldyBicyxzPW5ldyBicztuLl9yb3Q9aSxpLl9yb3Q9cixyLl9yb3Q9cyxzLl9yb3Q9bixuLnNldE5leHQobiksaS5zZXROZXh0KHMpLHIuc2V0TmV4dChyKSxzLnNldE5leHQoaSk7dmFyIG89bjtyZXR1cm4gby5zZXRPcmlnKHQpLG8uc2V0RGVzdChlKSxvfSxicy5zd2FwPWZ1bmN0aW9uKHQpe3ZhciBlPXQub1ByZXYoKSxuPXQuc3ltKCkub1ByZXYoKTticy5zcGxpY2UodCxlKSxicy5zcGxpY2UodC5zeW0oKSxuKSxicy5zcGxpY2UodCxlLmxOZXh0KCkpLGJzLnNwbGljZSh0LnN5bSgpLG4ubE5leHQoKSksdC5zZXRPcmlnKGUuZGVzdCgpKSx0LnNldERlc3Qobi5kZXN0KCkpfSxicy5zcGxpY2U9ZnVuY3Rpb24odCxlKXt2YXIgbj10Lm9OZXh0KCkucm90KCksaT1lLm9OZXh0KCkucm90KCkscj1lLm9OZXh0KCkscz10Lm9OZXh0KCksbz1pLm9OZXh0KCksYT1uLm9OZXh0KCk7dC5zZXROZXh0KHIpLGUuc2V0TmV4dChzKSxuLnNldE5leHQobyksaS5zZXROZXh0KGEpfSxicy5jb25uZWN0PWZ1bmN0aW9uKHQsZSl7dmFyIG49YnMubWFrZUVkZ2UodC5kZXN0KCksZS5vcmlnKCkpO3JldHVybiBicy5zcGxpY2Uobix0LmxOZXh0KCkpLGJzLnNwbGljZShuLnN5bSgpLGUpLG59LGUoT3MucHJvdG90eXBlLHtpbnNlcnRTaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMuc3ViZGl2LmxvY2F0ZSh0KTtpZih0aGlzLnN1YmRpdi5pc1ZlcnRleE9mRWRnZShlLHQpKXJldHVybiBlO3RoaXMuc3ViZGl2LmlzT25FZGdlKGUsdC5nZXRDb29yZGluYXRlKCkpJiYoZT1lLm9QcmV2KCksdGhpcy5zdWJkaXYuZGVsZXRlKGUub05leHQoKSkpO3ZhciBuPXRoaXMuc3ViZGl2Lm1ha2VFZGdlKGUub3JpZygpLHQpO2JzLnNwbGljZShuLGUpO3ZhciBpPW47ZG8gbj10aGlzLnN1YmRpdi5jb25uZWN0KGUsbi5zeW0oKSksZT1uLm9QcmV2KCk7d2hpbGUoZS5sTmV4dCgpIT09aSk7Zm9yKDs7KXt2YXIgcj1lLm9QcmV2KCk7aWYoci5kZXN0KCkucmlnaHRPZihlKSYmdC5pc0luQ2lyY2xlKGUub3JpZygpLHIuZGVzdCgpLGUuZGVzdCgpKSlicy5zd2FwKGUpLGU9ZS5vUHJldigpO2Vsc2V7aWYoZS5vTmV4dCgpPT09aSlyZXR1cm4gbjtlPWUub05leHQoKS5sUHJldigpfX19LGluc2VydFNpdGVzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10Lml0ZXJhdG9yKCk7ZS5oYXNOZXh0KCk7KXt2YXIgbj1lLm5leHQoKTt0aGlzLmluc2VydFNpdGUobil9fSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBPc319KSxlKF9zLnByb3RvdHlwZSx7bG9jYXRlOmZ1bmN0aW9uKHQpe30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gX3N9fSksZShNcy5wcm90b3R5cGUse2luaXQ6ZnVuY3Rpb24oKXt0aGlzLmxhc3RFZGdlPXRoaXMuZmluZEVkZ2UoKX0sbG9jYXRlOmZ1bmN0aW9uKHQpe3RoaXMubGFzdEVkZ2UuaXNMaXZlKCl8fHRoaXMuaW5pdCgpO3ZhciBlPXRoaXMuc3ViZGl2LmxvY2F0ZUZyb21FZGdlKHQsdGhpcy5sYXN0RWRnZSk7cmV0dXJuIHRoaXMubGFzdEVkZ2U9ZSxlfSxmaW5kRWRnZTpmdW5jdGlvbigpe3ZhciB0PXRoaXMuc3ViZGl2LmdldEVkZ2VzKCk7cmV0dXJuIHQuaXRlcmF0b3IoKS5uZXh0KCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW19zXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gTXN9fSksaChEcyxsKSxlKERzLnByb3RvdHlwZSx7Z2V0U2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLnNlZ30saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRHN9fSksRHMubXNnV2l0aFNwYXRpYWw9ZnVuY3Rpb24odCxlKXtyZXR1cm4gbnVsbCE9PWU/dCtcIiBbIFwiK2UrXCIgXVwiOnR9LGUoQXMucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEFzfX0pLGUoRnMucHJvdG90eXBlLHtnZXRUcmlhbmdsZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe3ZhciBlPW5ldyBCcztyZXR1cm4gdGhpcy52aXNpdFRyaWFuZ2xlcyhlLHQpLGUuZ2V0VHJpYW5nbGVWZXJ0aWNlcygpfSxpc0ZyYW1lVmVydGV4OmZ1bmN0aW9uKHQpe3JldHVybiB0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzBdKT8hMDp0LmVxdWFscyh0aGlzLmZyYW1lVmVydGV4WzFdKT8hMDohIXQuZXF1YWxzKHRoaXMuZnJhbWVWZXJ0ZXhbMl0pfSxpc1ZlcnRleE9mRWRnZTpmdW5jdGlvbih0LGUpe3JldHVybiEoIWUuZXF1YWxzKHQub3JpZygpLHRoaXMudG9sZXJhbmNlKSYmIWUuZXF1YWxzKHQuZGVzdCgpLHRoaXMudG9sZXJhbmNlKSl9LGNvbm5lY3Q6ZnVuY3Rpb24odCxlKXt2YXIgbj1icy5jb25uZWN0KHQsZSk7cmV0dXJuIHRoaXMucXVhZEVkZ2VzLmFkZChuKSxufSxnZXRWb3Jvbm9pQ2VsbFBvbHlnb246ZnVuY3Rpb24odCxlKXt2YXIgbj1uZXcgSSxpPXQ7ZG97dmFyIHI9dC5yb3QoKS5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpO24uYWRkKHIpLHQ9dC5vUHJldigpfXdoaWxlKHQhPT1pKTt2YXIgcz1uZXcgTjtzLmFkZEFsbChuLCExKSxzLmNsb3NlUmluZygpLHMuc2l6ZSgpPDQmJihBLm91dC5wcmludGxuKHMpLHMuYWRkKHMuZ2V0KHMuc2l6ZSgpLTEpLCEwKSk7dmFyIG89cy50b0Nvb3JkaW5hdGVBcnJheSgpLGE9ZS5jcmVhdGVQb2x5Z29uKGUuY3JlYXRlTGluZWFyUmluZyhvKSxudWxsKSx1PWkub3JpZygpO3JldHVybiBhLnNldFVzZXJEYXRhKHUuZ2V0Q29vcmRpbmF0ZSgpKSxhfSxzZXRMb2NhdG9yOmZ1bmN0aW9uKHQpe3RoaXMubG9jYXRvcj10fSxpbml0U3ViZGl2OmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5tYWtlRWRnZSh0aGlzLmZyYW1lVmVydGV4WzBdLHRoaXMuZnJhbWVWZXJ0ZXhbMV0pLGU9dGhpcy5tYWtlRWRnZSh0aGlzLmZyYW1lVmVydGV4WzFdLHRoaXMuZnJhbWVWZXJ0ZXhbMl0pO2JzLnNwbGljZSh0LnN5bSgpLGUpO3ZhciBuPXRoaXMubWFrZUVkZ2UodGhpcy5mcmFtZVZlcnRleFsyXSx0aGlzLmZyYW1lVmVydGV4WzBdKTtyZXR1cm4gYnMuc3BsaWNlKGUuc3ltKCksbiksYnMuc3BsaWNlKG4uc3ltKCksdCksdH0saXNGcmFtZUJvcmRlckVkZ2U6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IEFycmF5KDMpLmZpbGwobnVsbCk7RnMuZ2V0VHJpYW5nbGVFZGdlcyh0LGUpO3ZhciBuPW5ldyBBcnJheSgzKS5maWxsKG51bGwpO0ZzLmdldFRyaWFuZ2xlRWRnZXModC5zeW0oKSxuKTt2YXIgaT10LmxOZXh0KCkuZGVzdCgpO2lmKHRoaXMuaXNGcmFtZVZlcnRleChpKSlyZXR1cm4hMDt2YXIgcj10LnN5bSgpLmxOZXh0KCkuZGVzdCgpO3JldHVybiEhdGhpcy5pc0ZyYW1lVmVydGV4KHIpfSxtYWtlRWRnZTpmdW5jdGlvbih0LGUpe3ZhciBuPWJzLm1ha2VFZGdlKHQsZSk7cmV0dXJuIHRoaXMucXVhZEVkZ2VzLmFkZChuKSxufSx2aXNpdFRyaWFuZ2xlczpmdW5jdGlvbih0LGUpe3RoaXMudmlzaXRlZEtleSsrO3ZhciBuPW5ldyBwZTtuLnB1c2godGhpcy5zdGFydGluZ0VkZ2UpO2Zvcih2YXIgaT1uZXcgSjshbi5lbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtpZighaS5jb250YWlucyhyKSl7dmFyIHM9dGhpcy5mZXRjaFRyaWFuZ2xlVG9WaXNpdChyLG4sZSxpKTtudWxsIT09cyYmdC52aXNpdChzKX19fSxpc0ZyYW1lRWRnZTpmdW5jdGlvbih0KXtyZXR1cm4hKCF0aGlzLmlzRnJhbWVWZXJ0ZXgodC5vcmlnKCkpJiYhdGhpcy5pc0ZyYW1lVmVydGV4KHQuZGVzdCgpKSl9LGlzT25FZGdlOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWcuc2V0Q29vcmRpbmF0ZXModC5vcmlnKCkuZ2V0Q29vcmRpbmF0ZSgpLHQuZGVzdCgpLmdldENvb3JkaW5hdGUoKSk7dmFyIG49dGhpcy5zZWcuZGlzdGFuY2UoZSk7cmV0dXJuIG48dGhpcy5lZGdlQ29pbmNpZGVuY2VUb2xlcmFuY2V9LGdldEVudmVsb3BlOmZ1bmN0aW9uKCl7cmV0dXJuIG5ldyBDKHRoaXMuZnJhbWVFbnYpfSxjcmVhdGVGcmFtZTpmdW5jdGlvbih0KXt2YXIgZT10LmdldFdpZHRoKCksbj10LmdldEhlaWdodCgpLGk9MDtpPWU+bj8xMCplOjEwKm4sdGhpcy5mcmFtZVZlcnRleFswXT1uZXcgVHMoKHQuZ2V0TWF4WCgpK3QuZ2V0TWluWCgpKS8yLHQuZ2V0TWF4WSgpK2kpLHRoaXMuZnJhbWVWZXJ0ZXhbMV09bmV3IFRzKHQuZ2V0TWluWCgpLWksdC5nZXRNaW5ZKCktaSksdGhpcy5mcmFtZVZlcnRleFsyXT1uZXcgVHModC5nZXRNYXhYKCkraSx0LmdldE1pblkoKS1pKSx0aGlzLmZyYW1lRW52PW5ldyBDKHRoaXMuZnJhbWVWZXJ0ZXhbMF0uZ2V0Q29vcmRpbmF0ZSgpLHRoaXMuZnJhbWVWZXJ0ZXhbMV0uZ2V0Q29vcmRpbmF0ZSgpKSx0aGlzLmZyYW1lRW52LmV4cGFuZFRvSW5jbHVkZSh0aGlzLmZyYW1lVmVydGV4WzJdLmdldENvb3JkaW5hdGUoKSl9LGdldFRyaWFuZ2xlQ29vcmRpbmF0ZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHpzO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZXMoKX0sZ2V0VmVydGljZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBKLG49dGhpcy5xdWFkRWRnZXMuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpLHI9aS5vcmlnKCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChyKXx8ZS5hZGQocik7dmFyIHM9aS5kZXN0KCk7IXQmJnRoaXMuaXNGcmFtZVZlcnRleChzKXx8ZS5hZGQocyl9cmV0dXJuIGV9LGZldGNoVHJpYW5nbGVUb1Zpc2l0OmZ1bmN0aW9uKHQsZSxuLGkpe3ZhciByPXQscz0wLG89ITE7ZG97dGhpcy50cmlFZGdlc1tzXT1yLHRoaXMuaXNGcmFtZUVkZ2UocikmJihvPSEwKTt2YXIgYT1yLnN5bSgpO2kuY29udGFpbnMoYSl8fGUucHVzaChhKSxpLmFkZChyKSxzKysscj1yLmxOZXh0KCl9d2hpbGUociE9PXQpO3JldHVybiBvJiYhbj9udWxsOnRoaXMudHJpRWRnZXN9LGdldEVkZ2VzOmZ1bmN0aW9uKCl7aWYoMD09PWFyZ3VtZW50cy5sZW5ndGgpcmV0dXJuIHRoaXMucXVhZEVkZ2VzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXtmb3IodmFyIHQ9YXJndW1lbnRzWzBdLGU9dGhpcy5nZXRQcmltYXJ5RWRnZXMoITEpLG49bmV3IEFycmF5KGUuc2l6ZSgpKS5maWxsKG51bGwpLGk9MCxyPWUuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpO25baSsrXT10LmNyZWF0ZUxpbmVTdHJpbmcoW3Mub3JpZygpLmdldENvb3JkaW5hdGUoKSxzLmRlc3QoKS5nZXRDb29yZGluYXRlKCldKX1yZXR1cm4gdC5jcmVhdGVNdWx0aUxpbmVTdHJpbmcobil9fSxnZXRWZXJ0ZXhVbmlxdWVFZGdlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj1uZXcgSixpPXRoaXMucXVhZEVkZ2VzLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKSxzPXIub3JpZygpO24uY29udGFpbnMocyl8fChuLmFkZChzKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KHMpfHxlLmFkZChyKSk7dmFyIG89ci5zeW0oKSxhPW8ub3JpZygpO24uY29udGFpbnMoYSl8fChuLmFkZChhKSwhdCYmdGhpcy5pc0ZyYW1lVmVydGV4KGEpfHxlLmFkZChvKSl9cmV0dXJuIGV9LGdldFRyaWFuZ2xlRWRnZXM6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IHFzO3JldHVybiB0aGlzLnZpc2l0VHJpYW5nbGVzKGUsdCksZS5nZXRUcmlhbmdsZUVkZ2VzKCl9LGdldFByaW1hcnlFZGdlczpmdW5jdGlvbih0KXt0aGlzLnZpc2l0ZWRLZXkrKzt2YXIgZT1uZXcgSSxuPW5ldyBwZTtuLnB1c2godGhpcy5zdGFydGluZ0VkZ2UpO2Zvcih2YXIgaT1uZXcgSjshbi5lbXB0eSgpOyl7dmFyIHI9bi5wb3AoKTtpZighaS5jb250YWlucyhyKSl7dmFyIHM9ci5nZXRQcmltYXJ5KCk7IXQmJnRoaXMuaXNGcmFtZUVkZ2Uocyl8fGUuYWRkKHMpLG4ucHVzaChyLm9OZXh0KCkpLG4ucHVzaChyLnN5bSgpLm9OZXh0KCkpLGkuYWRkKHIpLGkuYWRkKHIuc3ltKCkpfX1yZXR1cm4gZX0sZGVsZXRlOmZ1bmN0aW9uKHQpe2JzLnNwbGljZSh0LHQub1ByZXYoKSksYnMuc3BsaWNlKHQuc3ltKCksdC5zeW0oKS5vUHJldigpKTt2YXIgZT10LnN5bSgpLG49dC5yb3QoKSxpPXQucm90KCkuc3ltKCk7dGhpcy5xdWFkRWRnZXMucmVtb3ZlKHQpLHRoaXMucXVhZEVkZ2VzLnJlbW92ZShlKSx0aGlzLnF1YWRFZGdlcy5yZW1vdmUobiksdGhpcy5xdWFkRWRnZXMucmVtb3ZlKGkpLHQuZGVsZXRlKCksZS5kZWxldGUoKSxuLmRlbGV0ZSgpLGkuZGVsZXRlKCl9LGxvY2F0ZUZyb21FZGdlOmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPTAsaT10aGlzLnF1YWRFZGdlcy5zaXplKCkscj1lOzspe2lmKG4rKyxuPmkpdGhyb3cgbmV3IERzKHIudG9MaW5lU2VnbWVudCgpKTtpZih0LmVxdWFscyhyLm9yaWcoKSl8fHQuZXF1YWxzKHIuZGVzdCgpKSlicmVhaztpZih0LnJpZ2h0T2Yocikpcj1yLnN5bSgpO2Vsc2UgaWYodC5yaWdodE9mKHIub05leHQoKSkpe2lmKHQucmlnaHRPZihyLmRQcmV2KCkpKWJyZWFrO3I9ci5kUHJldigpfWVsc2Ugcj1yLm9OZXh0KCl9cmV0dXJuIHJ9LGdldFRvbGVyYW5jZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRvbGVyYW5jZX0sZ2V0Vm9yb25vaUNlbGxQb2x5Z29uczpmdW5jdGlvbih0KXt0aGlzLnZpc2l0VHJpYW5nbGVzKG5ldyBHcywhMCk7Zm9yKHZhciBlPW5ldyBJLG49dGhpcy5nZXRWZXJ0ZXhVbmlxdWVFZGdlcyghMSksaT1uLml0ZXJhdG9yKCk7aS5oYXNOZXh0KCk7KXt2YXIgcj1pLm5leHQoKTtlLmFkZCh0aGlzLmdldFZvcm9ub2lDZWxsUG9seWdvbihyLHQpKX1yZXR1cm4gZX0sZ2V0Vm9yb25vaURpYWdyYW06ZnVuY3Rpb24odCl7dmFyIGU9dGhpcy5nZXRWb3Jvbm9pQ2VsbFBvbHlnb25zKHQpO3JldHVybiB0LmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoZSkpfSxnZXRUcmlhbmdsZXM6ZnVuY3Rpb24odCl7Zm9yKHZhciBlPXRoaXMuZ2V0VHJpYW5nbGVDb29yZGluYXRlcyghMSksbj1uZXcgQXJyYXkoZS5zaXplKCkpLmZpbGwobnVsbCksaT0wLHI9ZS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOyl7dmFyIHM9ci5uZXh0KCk7bltpKytdPXQuY3JlYXRlUG9seWdvbih0LmNyZWF0ZUxpbmVhclJpbmcocyksbnVsbCl9cmV0dXJuIHQuY3JlYXRlR2VvbWV0cnlDb2xsZWN0aW9uKG4pfSxpbnNlcnRTaXRlOmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMubG9jYXRlKHQpO2lmKHQuZXF1YWxzKGUub3JpZygpLHRoaXMudG9sZXJhbmNlKXx8dC5lcXVhbHMoZS5kZXN0KCksdGhpcy50b2xlcmFuY2UpKXJldHVybiBlO3ZhciBuPXRoaXMubWFrZUVkZ2UoZS5vcmlnKCksdCk7YnMuc3BsaWNlKG4sZSk7dmFyIGk9bjtkbyBuPXRoaXMuY29ubmVjdChlLG4uc3ltKCkpLGU9bi5vUHJldigpO3doaWxlKGUubE5leHQoKSE9PWkpO3JldHVybiBpfSxsb2NhdGU6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7aWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBUcyl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmxvY2F0b3IubG9jYXRlKHQpfWlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgZyl7dmFyIGU9YXJndW1lbnRzWzBdO3JldHVybiB0aGlzLmxvY2F0b3IubG9jYXRlKG5ldyBUcyhlKSl9fWVsc2UgaWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxyPXRoaXMubG9jYXRvci5sb2NhdGUobmV3IFRzKG4pKTtpZihudWxsPT09cilyZXR1cm4gbnVsbDt2YXIgcz1yO3IuZGVzdCgpLmdldENvb3JkaW5hdGUoKS5lcXVhbHMyRChuKSYmKHM9ci5zeW0oKSk7dmFyIG89cztkb3tpZihvLmRlc3QoKS5nZXRDb29yZGluYXRlKCkuZXF1YWxzMkQoaSkpcmV0dXJuIG87bz1vLm9OZXh0KCl9d2hpbGUobyE9PXMpO3JldHVybiBudWxsfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gRnN9fSksRnMuZ2V0VHJpYW5nbGVFZGdlcz1mdW5jdGlvbih0LGUpe2lmKGVbMF09dCxlWzFdPWVbMF0ubE5leHQoKSxlWzJdPWVbMV0ubE5leHQoKSxlWzJdLmxOZXh0KCkhPT1lWzBdKXRocm93IG5ldyBpKFwiRWRnZXMgZG8gbm90IGZvcm0gYSB0cmlhbmdsZVwiKX0sZShHcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10WzBdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksbj10WzFdLm9yaWcoKS5nZXRDb29yZGluYXRlKCksaT10WzJdLm9yaWcoKS5nZXRDb29yZGluYXRlKCkscj1jaS5jaXJjdW1jZW50cmUoZSxuLGkpLHM9bmV3IFRzKHIpLG89MDszPm87bysrKXRbb10ucm90KCkuc2V0T3JpZyhzKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBHc319KSxlKHFzLnByb3RvdHlwZSx7Z2V0VHJpYW5nbGVFZGdlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUxpc3R9LHZpc2l0OmZ1bmN0aW9uKHQpe3RoaXMudHJpTGlzdC5hZGQodC5jbG9uZSgpKX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bQXNdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBxc319KSxlKEJzLnByb3RvdHlwZSx7dmlzaXQ6ZnVuY3Rpb24odCl7dGhpcy50cmlMaXN0LmFkZChbdFswXS5vcmlnKCksdFsxXS5vcmlnKCksdFsyXS5vcmlnKCldKX0sZ2V0VHJpYW5nbGVWZXJ0aWNlczpmdW5jdGlvbigpe3JldHVybiB0aGlzLnRyaUxpc3R9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW0FzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gQnN9fSksZSh6cy5wcm90b3R5cGUse2NoZWNrVHJpYW5nbGVTaXplOmZ1bmN0aW9uKHQpe3ZhciBlPVwiXCI7dC5sZW5ndGg+PTI/ZT1zZS50b0xpbmVTdHJpbmcodFswXSx0WzFdKTp0Lmxlbmd0aD49MSYmKGU9c2UudG9Qb2ludCh0WzBdKSl9LHZpc2l0OmZ1bmN0aW9uKHQpe3RoaXMuY29vcmRMaXN0LmNsZWFyKCk7Zm9yKHZhciBlPTA7Mz5lO2UrKyl7dmFyIG49dFtlXS5vcmlnKCk7dGhpcy5jb29yZExpc3QuYWRkKG4uZ2V0Q29vcmRpbmF0ZSgpKX1pZih0aGlzLmNvb3JkTGlzdC5zaXplKCk+MCl7dGhpcy5jb29yZExpc3QuY2xvc2VSaW5nKCk7dmFyIGk9dGhpcy5jb29yZExpc3QudG9Db29yZGluYXRlQXJyYXkoKTtpZig0IT09aS5sZW5ndGgpcmV0dXJuIG51bGw7dGhpcy50cmlDb29yZHMuYWRkKGkpfX0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMudHJpQ29vcmRzfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltBc119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIHpzfX0pLEZzLlRyaWFuZ2xlQ2lyY3VtY2VudHJlVmlzaXRvcj1HcyxGcy5UcmlhbmdsZUVkZ2VzTGlzdFZpc2l0b3I9cXMsRnMuVHJpYW5nbGVWZXJ0ZXhMaXN0VmlzaXRvcj1CcyxGcy5UcmlhbmdsZUNvb3JkaW5hdGVzVmlzaXRvcj16cyxGcy5FREdFX0NPSU5DSURFTkNFX1RPTF9GQUNUT1I9MWUzLGUoVnMucHJvdG90eXBlLHtnZXRMaW5lU2VnbWVudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzfSxnZXRFbmRaOmZ1bmN0aW9uKCl7dmFyIHQ9dGhpcy5scy5nZXRDb29yZGluYXRlKDEpO3JldHVybiB0Lnp9LGdldFN0YXJ0WjpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKTtyZXR1cm4gdC56fSxpbnRlcnNlY3Rpb246ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMubHMuaW50ZXJzZWN0aW9uKHQuZ2V0TGluZVNlZ21lbnQoKSl9LGdldFN0YXJ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKX0sZ2V0RW5kOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKX0sZ2V0RW5kWTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC55fSxnZXRTdGFydFg6ZnVuY3Rpb24oKXt2YXIgdD10aGlzLmxzLmdldENvb3JkaW5hdGUoMCk7cmV0dXJuIHQueH0sZXF1YWxzVG9wbzpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5scy5lcXVhbHNUb3BvKHQuZ2V0TGluZVNlZ21lbnQoKSl9LGdldFN0YXJ0WTpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgwKTtyZXR1cm4gdC55fSxzZXREYXRhOmZ1bmN0aW9uKHQpe3RoaXMuZGF0YT10fSxnZXREYXRhOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuZGF0YX0sZ2V0RW5kWDpmdW5jdGlvbigpe3ZhciB0PXRoaXMubHMuZ2V0Q29vcmRpbmF0ZSgxKTtyZXR1cm4gdC54fSx0b1N0cmluZzpmdW5jdGlvbigpe3JldHVybiB0aGlzLmxzLnRvU3RyaW5nKCl9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIFZzfX0pLGUoa3MucHJvdG90eXBlLHt2aXNpdDpmdW5jdGlvbih0KXt9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIGtzfX0pLGUoWXMucHJvdG90eXBlLHtpc1JlcGVhdGVkOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY291bnQ+MX0sZ2V0UmlnaHQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5yaWdodH0sZ2V0Q29vcmRpbmF0ZTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnB9LHNldExlZnQ6ZnVuY3Rpb24odCl7dGhpcy5sZWZ0PXR9LGdldFg6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wLnh9LGdldERhdGE6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5kYXRhfSxnZXRDb3VudDpmdW5jdGlvbigpe3JldHVybiB0aGlzLmNvdW50fSxnZXRMZWZ0OmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMubGVmdH0sZ2V0WTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnAueX0saW5jcmVtZW50OmZ1bmN0aW9uKCl7dGhpcy5jb3VudD10aGlzLmNvdW50KzF9LHNldFJpZ2h0OmZ1bmN0aW9uKHQpe3RoaXMucmlnaHQ9dH0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWXN9fSksZShVcy5wcm90b3R5cGUse2luc2VydDpmdW5jdGlvbigpe2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgdD1hcmd1bWVudHNbMF07cmV0dXJuIHRoaXMuaW5zZXJ0KHQsbnVsbCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXTtpZihudWxsPT09dGhpcy5yb290KXJldHVybiB0aGlzLnJvb3Q9bmV3IFlzKGUsbiksdGhpcy5yb290O2lmKHRoaXMudG9sZXJhbmNlPjApe3ZhciBpPXRoaXMuZmluZEJlc3RNYXRjaE5vZGUoZSk7aWYobnVsbCE9PWkpcmV0dXJuIGkuaW5jcmVtZW50KCksaX1yZXR1cm4gdGhpcy5pbnNlcnRFeGFjdChlLG4pfX0scXVlcnk6ZnVuY3Rpb24oKXt2YXIgdD1hcmd1bWVudHMsZT10aGlzO2lmKDE9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgbj1hcmd1bWVudHNbMF0saT1uZXcgSTtyZXR1cm4gdGhpcy5xdWVyeShuLGkpLGl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpaWYoYXJndW1lbnRzWzBdaW5zdGFuY2VvZiBDJiZSKGFyZ3VtZW50c1sxXSx5KSkhZnVuY3Rpb24oKXt2YXIgbj10WzBdLGk9dFsxXTtlLnF1ZXJ5Tm9kZShlLnJvb3QsbiwhMCx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5ba3NdfSx2aXNpdDpmdW5jdGlvbih0KXtpLmFkZCh0KX19KX0oKTtlbHNlIGlmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQyYmUihhcmd1bWVudHNbMV0sa3MpKXt2YXIgcj1hcmd1bWVudHNbMF0scz1hcmd1bWVudHNbMV07dGhpcy5xdWVyeU5vZGUodGhpcy5yb290LHIsITAscyl9fSxxdWVyeU5vZGU6ZnVuY3Rpb24odCxlLG4saSl7aWYobnVsbD09PXQpcmV0dXJuIG51bGw7dmFyIHI9bnVsbCxzPW51bGwsbz1udWxsO24/KHI9ZS5nZXRNaW5YKCkscz1lLmdldE1heFgoKSxvPXQuZ2V0WCgpKToocj1lLmdldE1pblkoKSxzPWUuZ2V0TWF4WSgpLG89dC5nZXRZKCkpO3ZhciBhPW8+cix1PXM+PW87YSYmdGhpcy5xdWVyeU5vZGUodC5nZXRMZWZ0KCksZSwhbixpKSxlLmNvbnRhaW5zKHQuZ2V0Q29vcmRpbmF0ZSgpKSYmaS52aXNpdCh0KSx1JiZ0aGlzLnF1ZXJ5Tm9kZSh0LmdldFJpZ2h0KCksZSwhbixpKX0sZmluZEJlc3RNYXRjaE5vZGU6ZnVuY3Rpb24odCl7dmFyIGU9bmV3IFhzKHQsdGhpcy50b2xlcmFuY2UpO3JldHVybiB0aGlzLnF1ZXJ5KGUucXVlcnlFbnZlbG9wZSgpLGUpLGUuZ2V0Tm9kZSgpfSxpc0VtcHR5OmZ1bmN0aW9uKCl7cmV0dXJuIG51bGw9PT10aGlzLnJvb3R9LGluc2VydEV4YWN0OmZ1bmN0aW9uKHQsZSl7Zm9yKHZhciBuPXRoaXMucm9vdCxpPXRoaXMucm9vdCxyPSEwLHM9ITA7bnVsbCE9PW47KXtpZihudWxsIT09bil7dmFyIG89dC5kaXN0YW5jZShuLmdldENvb3JkaW5hdGUoKSk8PXRoaXMudG9sZXJhbmNlO2lmKG8pcmV0dXJuIG4uaW5jcmVtZW50KCksbn1zPXI/dC54PG4uZ2V0WCgpOnQueTxuLmdldFkoKSxpPW4sbj1zP24uZ2V0TGVmdCgpOm4uZ2V0UmlnaHQoKSxyPSFyfXRoaXMubnVtYmVyT2ZOb2Rlcz10aGlzLm51bWJlck9mTm9kZXMrMTt2YXIgYT1uZXcgWXModCxlKTtyZXR1cm4gcz9pLnNldExlZnQoYSk6aS5zZXRSaWdodChhKSxhfSxpbnRlcmZhY2VzXzpmdW5jdGlvbigpe3JldHVybltdfSxnZXRDbGFzczpmdW5jdGlvbigpe3JldHVybiBVc319KSxVcy50b0Nvb3JkaW5hdGVzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gVXMudG9Db29yZGluYXRlcyh0LCExKX1pZigyPT09YXJndW1lbnRzLmxlbmd0aCl7Zm9yKHZhciBlPWFyZ3VtZW50c1swXSxuPWFyZ3VtZW50c1sxXSxpPW5ldyBOLHI9ZS5pdGVyYXRvcigpO3IuaGFzTmV4dCgpOylmb3IodmFyIHM9ci5uZXh0KCksbz1uP3MuZ2V0Q291bnQoKToxLGE9MDtvPmE7YSsrKWkuYWRkKHMuZ2V0Q29vcmRpbmF0ZSgpLCEwKTtyZXR1cm4gaS50b0Nvb3JkaW5hdGVBcnJheSgpfX0sZShYcy5wcm90b3R5cGUse3Zpc2l0OmZ1bmN0aW9uKHQpe3ZhciBlPXRoaXMucC5kaXN0YW5jZSh0LmdldENvb3JkaW5hdGUoKSksbj1lPD10aGlzLnRvbGVyYW5jZTtpZighbilyZXR1cm4gbnVsbDt2YXIgaT0hMTsobnVsbD09PXRoaXMubWF0Y2hOb2RlfHxlPHRoaXMubWF0Y2hEaXN0fHxudWxsIT09dGhpcy5tYXRjaE5vZGUmJmU9PT10aGlzLm1hdGNoRGlzdCYmdC5nZXRDb29yZGluYXRlKCkuY29tcGFyZVRvKHRoaXMubWF0Y2hOb2RlLmdldENvb3JkaW5hdGUoKSk8MSkmJihpPSEwKSxpJiYodGhpcy5tYXRjaE5vZGU9dCx0aGlzLm1hdGNoRGlzdD1lKX0scXVlcnlFbnZlbG9wZTpmdW5jdGlvbigpe3ZhciB0PW5ldyBDKHRoaXMucCk7cmV0dXJuIHQuZXhwYW5kQnkodGhpcy50b2xlcmFuY2UpLHR9LGdldE5vZGU6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5tYXRjaE5vZGV9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW2tzXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWHN9fSksVXMuQmVzdE1hdGNoVmlzaXRvcj1YcyxlKEhzLnByb3RvdHlwZSx7Z2V0SW5pdGlhbFZlcnRpY2VzOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuaW5pdGlhbFZlcnRpY2VzfSxnZXRLRFQ6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5rZHR9LGVuZm9yY2VDb25zdHJhaW50czpmdW5jdGlvbigpe3RoaXMuYWRkQ29uc3RyYWludFZlcnRpY2VzKCk7dmFyIHQ9MCxlPTA7ZG8gZT10aGlzLmVuZm9yY2VHYWJyaWVsKHRoaXMuc2VnbWVudHMpLHQrKzt3aGlsZShlPjAmJnQ8SHMuTUFYX1NQTElUX0lURVIpfSxpbnNlcnRTaXRlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9dC5pdGVyYXRvcigpO2UuaGFzTmV4dCgpOyl7dmFyIG49ZS5uZXh0KCk7dGhpcy5pbnNlcnRTaXRlKG4pfX0sZ2V0VmVydGV4RmFjdG9yeTpmdW5jdGlvbigpe3JldHVybiB0aGlzLnZlcnRleEZhY3Rvcnl9LGdldFBvaW50QXJyYXk6ZnVuY3Rpb24oKXtmb3IodmFyIHQ9bmV3IEFycmF5KHRoaXMuaW5pdGlhbFZlcnRpY2VzLnNpemUoKSt0aGlzLnNlZ1ZlcnRpY2VzLnNpemUoKSkuZmlsbChudWxsKSxlPTAsbj10aGlzLmluaXRpYWxWZXJ0aWNlcy5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7dFtlKytdPWkuZ2V0Q29vcmRpbmF0ZSgpfWZvcih2YXIgcj10aGlzLnNlZ1ZlcnRpY2VzLml0ZXJhdG9yKCk7ci5oYXNOZXh0KCk7KXt2YXIgaT1yLm5leHQoKTt0W2UrK109aS5nZXRDb29yZGluYXRlKCl9cmV0dXJuIHR9LHNldENvbnN0cmFpbnRzOmZ1bmN0aW9uKHQsZSl7dGhpcy5zZWdtZW50cz10LHRoaXMuc2VnVmVydGljZXM9ZX0sY29tcHV0ZUNvbnZleEh1bGw6ZnVuY3Rpb24oKXt2YXIgdD1uZXcgaWUsZT10aGlzLmdldFBvaW50QXJyYXkoKSxuPW5ldyBtZShlLHQpO3RoaXMuY29udmV4SHVsbD1uLmdldENvbnZleEh1bGwoKX0sYWRkQ29uc3RyYWludFZlcnRpY2VzOmZ1bmN0aW9uKCl7dGhpcy5jb21wdXRlQ29udmV4SHVsbCgpLHRoaXMuaW5zZXJ0U2l0ZXModGhpcy5zZWdWZXJ0aWNlcyl9LGZpbmROb25HYWJyaWVsUG9pbnQ6ZnVuY3Rpb24odCl7dmFyIGU9dC5nZXRTdGFydCgpLG49dC5nZXRFbmQoKSxpPW5ldyBnKChlLngrbi54KS8yLChlLnkrbi55KS8yKSxzPWUuZGlzdGFuY2UoaSksbz1uZXcgQyhpKTtvLmV4cGFuZEJ5KHMpO2Zvcih2YXIgYT10aGlzLmtkdC5xdWVyeShvKSx1PW51bGwsbD1yLk1BWF9WQUxVRSxoPWEuaXRlcmF0b3IoKTtoLmhhc05leHQoKTspe3ZhciBjPWgubmV4dCgpLGY9Yy5nZXRDb29yZGluYXRlKCk7aWYoIWYuZXF1YWxzMkQoZSkmJiFmLmVxdWFsczJEKG4pKXt2YXIgZD1pLmRpc3RhbmNlKGYpO2lmKHM+ZCl7dmFyIHA9ZDsobnVsbD09PXV8fGw+cCkmJih1PWYsbD1wKX19fXJldHVybiB1fSxnZXRDb25zdHJhaW50U2VnbWVudHM6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zZWdtZW50c30sc2V0U3BsaXRQb2ludEZpbmRlcjpmdW5jdGlvbih0KXt0aGlzLnNwbGl0RmluZGVyPXR9LGdldENvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jb252ZXhIdWxsfSxnZXRUb2xlcmFuY2U6ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy50b2xlcmFuY2V9LGVuZm9yY2VHYWJyaWVsOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgSSxuPTAsaT1uZXcgSSxyPXQuaXRlcmF0b3IoKTtyLmhhc05leHQoKTspe3ZhciBzPXIubmV4dCgpLG89dGhpcy5maW5kTm9uR2FicmllbFBvaW50KHMpO2lmKG51bGwhPT1vKXt0aGlzLnNwbGl0UHQ9dGhpcy5zcGxpdEZpbmRlci5maW5kU3BsaXRQb2ludChzLG8pO3ZhciBhPXRoaXMuY3JlYXRlVmVydGV4KHRoaXMuc3BsaXRQdCxzKSx1PSh0aGlzLmluc2VydFNpdGUoYSksbmV3IFZzKHMuZ2V0U3RhcnRYKCkscy5nZXRTdGFydFkoKSxzLmdldFN0YXJ0WigpLGEuZ2V0WCgpLGEuZ2V0WSgpLGEuZ2V0WigpLHMuZ2V0RGF0YSgpKSksbD1uZXcgVnMoYS5nZXRYKCksYS5nZXRZKCksYS5nZXRaKCkscy5nZXRFbmRYKCkscy5nZXRFbmRZKCkscy5nZXRFbmRaKCkscy5nZXREYXRhKCkpO2UuYWRkKHUpLGUuYWRkKGwpLGkuYWRkKHMpLG4rPTF9fXJldHVybiB0LnJlbW92ZUFsbChpKSx0LmFkZEFsbChlKSxufSxjcmVhdGVWZXJ0ZXg6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdLGU9bnVsbDtyZXR1cm4gZT1udWxsIT09dGhpcy52ZXJ0ZXhGYWN0b3J5P3RoaXMudmVydGV4RmFjdG9yeS5jcmVhdGVWZXJ0ZXgodCxudWxsKTpuZXcgUHModCl9aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciBuPWFyZ3VtZW50c1swXSxpPWFyZ3VtZW50c1sxXSxlPW51bGw7cmV0dXJuIGU9bnVsbCE9PXRoaXMudmVydGV4RmFjdG9yeT90aGlzLnZlcnRleEZhY3RvcnkuY3JlYXRlVmVydGV4KG4saSk6bmV3IFBzKG4pLGUuc2V0T25Db25zdHJhaW50KCEwKSxlfX0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5zdWJkaXZ9LGNvbXB1dGVCb3VuZGluZ0JveDpmdW5jdGlvbigpe3ZhciB0PUhzLmNvbXB1dGVWZXJ0ZXhFbnZlbG9wZSh0aGlzLmluaXRpYWxWZXJ0aWNlcyksZT1Icy5jb21wdXRlVmVydGV4RW52ZWxvcGUodGhpcy5zZWdWZXJ0aWNlcyksbj1uZXcgQyh0KTtuLmV4cGFuZFRvSW5jbHVkZShlKTt2YXIgaT0uMipuLmdldFdpZHRoKCkscj0uMipuLmdldEhlaWdodCgpLHM9TWF0aC5tYXgoaSxyKTt0aGlzLmNvbXB1dGVBcmVhRW52PW5ldyBDKG4pLHRoaXMuY29tcHV0ZUFyZWFFbnYuZXhwYW5kQnkocyl9LHNldFZlcnRleEZhY3Rvcnk6ZnVuY3Rpb24odCl7dGhpcy52ZXJ0ZXhGYWN0b3J5PXR9LGZvcm1Jbml0aWFsRGVsYXVuYXk6ZnVuY3Rpb24oKXt0aGlzLmNvbXB1dGVCb3VuZGluZ0JveCgpLHRoaXMuc3ViZGl2PW5ldyBGcyh0aGlzLmNvbXB1dGVBcmVhRW52LHRoaXMudG9sZXJhbmNlKSx0aGlzLnN1YmRpdi5zZXRMb2NhdG9yKG5ldyBNcyh0aGlzLnN1YmRpdikpLHRoaXMuaW5jRGVsPW5ldyBPcyh0aGlzLnN1YmRpdiksdGhpcy5pbnNlcnRTaXRlcyh0aGlzLmluaXRpYWxWZXJ0aWNlcyl9LGluc2VydFNpdGU6ZnVuY3Rpb24oKXtpZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIFBzKXt2YXIgdD1hcmd1bWVudHNbMF0sZT10aGlzLmtkdC5pbnNlcnQodC5nZXRDb29yZGluYXRlKCksdCk7aWYoZS5pc1JlcGVhdGVkKCkpe3ZhciBuPWUuZ2V0RGF0YSgpO3JldHVybiBuLm1lcmdlKHQpLG59cmV0dXJuIHRoaXMuaW5jRGVsLmluc2VydFNpdGUodCksdH1pZihhcmd1bWVudHNbMF1pbnN0YW5jZW9mIGcpe3ZhciBpPWFyZ3VtZW50c1swXTt0aGlzLmluc2VydFNpdGUodGhpcy5jcmVhdGVWZXJ0ZXgoaSkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gSHN9fSksSHMuY29tcHV0ZVZlcnRleEVudmVsb3BlPWZ1bmN0aW9uKHQpe2Zvcih2YXIgZT1uZXcgQyxuPXQuaXRlcmF0b3IoKTtuLmhhc05leHQoKTspe3ZhciBpPW4ubmV4dCgpO2UuZXhwYW5kVG9JbmNsdWRlKGkuZ2V0Q29vcmRpbmF0ZSgpKX1yZXR1cm4gZX0sSHMuTUFYX1NQTElUX0lURVI9OTksZShXcy5wcm90b3R5cGUse2NyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpLGU9V3MudG9WZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpO3RoaXMuc3ViZGl2PW5ldyBGcyh0LHRoaXMudG9sZXJhbmNlKTt2YXIgbj1uZXcgT3ModGhpcy5zdWJkaXYpO24uaW5zZXJ0U2l0ZXMoZSl9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRTaXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy51bmlxdWUoSC50b0Nvb3JkaW5hdGVBcnJheShlKSl9fSxnZXRFZGdlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRFZGdlcyh0KX0sZ2V0U3ViZGl2aXNpb246ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdn0sZ2V0VHJpYW5nbGVzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmNyZWF0ZSgpLHRoaXMuc3ViZGl2LmdldFRyaWFuZ2xlcyh0KX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gV3N9fSksV3MuZXh0cmFjdFVuaXF1ZUNvb3JkaW5hdGVzPWZ1bmN0aW9uKHQpe2lmKG51bGw9PT10KXJldHVybiBuZXcgTjt2YXIgZT10LmdldENvb3JkaW5hdGVzKCk7cmV0dXJuIFdzLnVuaXF1ZShlKX0sV3MuZW52ZWxvcGU9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBDLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5leHBhbmRUb0luY2x1ZGUoaSl9cmV0dXJuIGV9LFdzLnVuaXF1ZT1mdW5jdGlvbih0KXt2YXIgZT1ILmNvcHlEZWVwKHQpO3V0LnNvcnQoZSk7dmFyIG49bmV3IE4oZSwhMSk7cmV0dXJuIG59LFdzLnRvVmVydGljZXM9ZnVuY3Rpb24odCl7Zm9yKHZhciBlPW5ldyBJLG49dC5pdGVyYXRvcigpO24uaGFzTmV4dCgpOyl7dmFyIGk9bi5uZXh0KCk7ZS5hZGQobmV3IFRzKGkpKX1yZXR1cm4gZX0sZShqcy5wcm90b3R5cGUse2NyZWF0ZVNpdGVWZXJ0aWNlczpmdW5jdGlvbih0KXtmb3IodmFyIGU9bmV3IEksbj10Lml0ZXJhdG9yKCk7bi5oYXNOZXh0KCk7KXt2YXIgaT1uLm5leHQoKTt0aGlzLmNvbnN0cmFpbnRWZXJ0ZXhNYXAuY29udGFpbnNLZXkoaSl8fGUuYWRkKG5ldyBQcyhpKSl9cmV0dXJuIGV9LGNyZWF0ZTpmdW5jdGlvbigpe2lmKG51bGwhPT10aGlzLnN1YmRpdilyZXR1cm4gbnVsbDt2YXIgdD1Xcy5lbnZlbG9wZSh0aGlzLnNpdGVDb29yZHMpLGU9bmV3IEk7bnVsbCE9PXRoaXMuY29uc3RyYWludExpbmVzJiYodC5leHBhbmRUb0luY2x1ZGUodGhpcy5jb25zdHJhaW50TGluZXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpKSx0aGlzLmNyZWF0ZVZlcnRpY2VzKHRoaXMuY29uc3RyYWludExpbmVzKSxlPWpzLmNyZWF0ZUNvbnN0cmFpbnRTZWdtZW50cyh0aGlzLmNvbnN0cmFpbnRMaW5lcykpO3ZhciBuPXRoaXMuY3JlYXRlU2l0ZVZlcnRpY2VzKHRoaXMuc2l0ZUNvb3JkcyksaT1uZXcgSHMobix0aGlzLnRvbGVyYW5jZSk7aS5zZXRDb25zdHJhaW50cyhlLG5ldyBJKHRoaXMuY29uc3RyYWludFZlcnRleE1hcC52YWx1ZXMoKSkpLGkuZm9ybUluaXRpYWxEZWxhdW5heSgpLGkuZW5mb3JjZUNvbnN0cmFpbnRzKCksdGhpcy5zdWJkaXY9aS5nZXRTdWJkaXZpc2lvbigpfSxzZXRUb2xlcmFuY2U6ZnVuY3Rpb24odCl7dGhpcy50b2xlcmFuY2U9dH0sc2V0Q29uc3RyYWludHM6ZnVuY3Rpb24odCl7dGhpcy5jb25zdHJhaW50TGluZXM9dH0sc2V0U2l0ZXM6ZnVuY3Rpb24odCl7dGhpcy5zaXRlQ29vcmRzPVdzLmV4dHJhY3RVbmlxdWVDb29yZGluYXRlcyh0KX0sZ2V0RWRnZXM6ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXYuZ2V0RWRnZXModCl9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGdldFRyaWFuZ2xlczpmdW5jdGlvbih0KXtyZXR1cm4gdGhpcy5jcmVhdGUoKSx0aGlzLnN1YmRpdi5nZXRUcmlhbmdsZXModCl9LGNyZWF0ZVZlcnRpY2VzOmZ1bmN0aW9uKHQpe2Zvcih2YXIgZT10LmdldENvb3JkaW5hdGVzKCksbj0wO248ZS5sZW5ndGg7bisrKXt2YXIgaT1uZXcgUHMoZVtuXSk7dGhpcy5jb25zdHJhaW50VmVydGV4TWFwLnB1dChlW25dLGkpfX0saW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4ganN9fSksanMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzPWZ1bmN0aW9uKCl7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe2Zvcih2YXIgdD1hcmd1bWVudHNbMF0sZT1rbi5nZXRMaW5lcyh0KSxuPW5ldyBJLGk9ZS5pdGVyYXRvcigpO2kuaGFzTmV4dCgpOyl7dmFyIHI9aS5uZXh0KCk7anMuY3JlYXRlQ29uc3RyYWludFNlZ21lbnRzKHIsbil9cmV0dXJuIG59aWYoMj09PWFyZ3VtZW50cy5sZW5ndGgpZm9yKHZhciBzPWFyZ3VtZW50c1swXSxvPWFyZ3VtZW50c1sxXSxhPXMuZ2V0Q29vcmRpbmF0ZXMoKSxpPTE7aTxhLmxlbmd0aDtpKyspby5hZGQobmV3IFZzKGFbaS0xXSxhW2ldKSl9LGUoS3MucHJvdG90eXBlLHtjcmVhdGU6ZnVuY3Rpb24oKXtpZihudWxsIT09dGhpcy5zdWJkaXYpcmV0dXJuIG51bGw7dmFyIHQ9V3MuZW52ZWxvcGUodGhpcy5zaXRlQ29vcmRzKTt0aGlzLmRpYWdyYW1FbnY9dDt2YXIgZT1NYXRoLm1heCh0aGlzLmRpYWdyYW1FbnYuZ2V0V2lkdGgoKSx0aGlzLmRpYWdyYW1FbnYuZ2V0SGVpZ2h0KCkpO3RoaXMuZGlhZ3JhbUVudi5leHBhbmRCeShlKSxudWxsIT09dGhpcy5jbGlwRW52JiZ0aGlzLmRpYWdyYW1FbnYuZXhwYW5kVG9JbmNsdWRlKHRoaXMuY2xpcEVudik7dmFyIG49V3MudG9WZXJ0aWNlcyh0aGlzLnNpdGVDb29yZHMpO3RoaXMuc3ViZGl2PW5ldyBGcyh0LHRoaXMudG9sZXJhbmNlKTt2YXIgaT1uZXcgT3ModGhpcy5zdWJkaXYpO2kuaW5zZXJ0U2l0ZXMobil9LGdldERpYWdyYW06ZnVuY3Rpb24odCl7dGhpcy5jcmVhdGUoKTt2YXIgZT10aGlzLnN1YmRpdi5nZXRWb3Jvbm9pRGlhZ3JhbSh0KTtyZXR1cm4gS3MuY2xpcEdlb21ldHJ5Q29sbGVjdGlvbihlLHRoaXMuZGlhZ3JhbUVudil9LHNldFRvbGVyYW5jZTpmdW5jdGlvbih0KXt0aGlzLnRvbGVyYW5jZT10fSxzZXRTaXRlczpmdW5jdGlvbigpe2lmKGFyZ3VtZW50c1swXWluc3RhbmNlb2YgQil7dmFyIHQ9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy5leHRyYWN0VW5pcXVlQ29vcmRpbmF0ZXModCl9ZWxzZSBpZihSKGFyZ3VtZW50c1swXSx2KSl7dmFyIGU9YXJndW1lbnRzWzBdO3RoaXMuc2l0ZUNvb3Jkcz1Xcy51bmlxdWUoSC50b0Nvb3JkaW5hdGVBcnJheShlKSl9fSxzZXRDbGlwRW52ZWxvcGU6ZnVuY3Rpb24odCl7dGhpcy5jbGlwRW52PXR9LGdldFN1YmRpdmlzaW9uOmZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMuY3JlYXRlKCksdGhpcy5zdWJkaXZ9LGludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW119LGdldENsYXNzOmZ1bmN0aW9uKCl7cmV0dXJuIEtzfX0pLEtzLmNsaXBHZW9tZXRyeUNvbGxlY3Rpb249ZnVuY3Rpb24odCxlKXtmb3IodmFyIG49dC5nZXRGYWN0b3J5KCkudG9HZW9tZXRyeShlKSxpPW5ldyBJLHI9MDtyPHQuZ2V0TnVtR2VvbWV0cmllcygpO3IrKyl7dmFyIHM9dC5nZXRHZW9tZXRyeU4ociksbz1udWxsO2UuY29udGFpbnMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpP289czplLmludGVyc2VjdHMocy5nZXRFbnZlbG9wZUludGVybmFsKCkpJiYobz1uLmludGVyc2VjdGlvbihzKSxvLnNldFVzZXJEYXRhKHMuZ2V0VXNlckRhdGEoKSkpLG51bGw9PT1vfHxvLmlzRW1wdHkoKXx8aS5hZGQobyl9cmV0dXJuIHQuZ2V0RmFjdG9yeSgpLmNyZWF0ZUdlb21ldHJ5Q29sbGVjdGlvbihpZS50b0dlb21ldHJ5QXJyYXkoaSkpfTt2YXIgRG89T2JqZWN0LmZyZWV6ZSh7Q29uZm9ybWluZ0RlbGF1bmF5VHJpYW5ndWxhdGlvbkJ1aWxkZXI6anMsRGVsYXVuYXlUcmlhbmd1bGF0aW9uQnVpbGRlcjpXcyxWb3Jvbm9pRGlhZ3JhbUJ1aWxkZXI6S3N9KTtlKFpzLnByb3RvdHlwZSx7aW50ZXJmYWNlc186ZnVuY3Rpb24oKXtyZXR1cm5bXX0sZ2V0Q2xhc3M6ZnVuY3Rpb24oKXtyZXR1cm4gWnN9fSksWnMudW5pb249ZnVuY3Rpb24odCxlKXtpZih0LmlzRW1wdHkoKXx8ZS5pc0VtcHR5KCkpe2lmKHQuaXNFbXB0eSgpJiZlLmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuVU5JT04sdCxlLHQuZ2V0RmFjdG9yeSgpKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gZS5jb3B5KCk7aWYoZS5pc0VtcHR5KCkpcmV0dXJuIHQuY29weSgpfXJldHVybiB0LmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHQuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24oZSksc2kub3ZlcmxheU9wKHQsZSxpaS5VTklPTil9LGUoQi5wcm90b3R5cGUse2VxdWFsc1RvcG86ZnVuY3Rpb24odCl7cmV0dXJuIHRoaXMuZ2V0RW52ZWxvcGVJbnRlcm5hbCgpLmVxdWFscyh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk/WXIucmVsYXRlKHRoaXMsdCkuaXNFcXVhbHModGhpcy5nZXREaW1lbnNpb24oKSx0LmdldERpbWVuc2lvbigpKTohMX0sdW5pb246ZnVuY3Rpb24oKXtpZigwPT09YXJndW1lbnRzLmxlbmd0aClyZXR1cm4ganIudW5pb24odGhpcyk7aWYoMT09PWFyZ3VtZW50cy5sZW5ndGgpe3ZhciB0PWFyZ3VtZW50c1swXTtyZXR1cm4gWnMudW5pb24odGhpcyx0KX19LGlzVmFsaWQ6ZnVuY3Rpb24oKXtyZXR1cm4gbHMuaXNWYWxpZCh0aGlzKX0saW50ZXJzZWN0aW9uOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSlyZXR1cm4gaWkuY3JlYXRlRW1wdHlSZXN1bHQoaWkuSU5URVJTRUNUSU9OLHRoaXMsdCx0aGlzLmZhY3RvcnkpO2lmKHRoaXMuaXNHZW9tZXRyeUNvbGxlY3Rpb24oKSl7dmFyIGU9dDtyZXR1cm4gaG4ubWFwKHRoaXMse2ludGVyZmFjZXNfOmZ1bmN0aW9uKCl7cmV0dXJuW01hcE9wXX0sbWFwOmZ1bmN0aW9uKHQpe3JldHVybiB0LmludGVyc2VjdGlvbihlKX19KX1yZXR1cm4gdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0aGlzKSx0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHQpLHNpLm92ZXJsYXlPcCh0aGlzLHQsaWkuSU5URVJTRUNUSU9OKX0sY292ZXJzOmZ1bmN0aW9uKHQpe3JldHVybiBZci5jb3ZlcnModGhpcyx0KX0sY292ZXJlZEJ5OmZ1bmN0aW9uKHQpe3JldHVybiBZci5jb3ZlcmVkQnkodGhpcyx0KX0sdG91Y2hlczpmdW5jdGlvbih0KXtyZXR1cm4gWXIudG91Y2hlcyh0aGlzLHQpfSxpbnRlcnNlY3RzOmZ1bmN0aW9uKHQpe3JldHVybiBZci5pbnRlcnNlY3RzKHRoaXMsdCl9LHdpdGhpbjpmdW5jdGlvbih0KXtyZXR1cm4gWXIud2l0aGluKHRoaXMsdCl9LG92ZXJsYXBzOmZ1bmN0aW9uKHQpe3JldHVybiBZci5vdmVybGFwcyh0aGlzLHQpfSxkaXNqb2ludDpmdW5jdGlvbih0KXtyZXR1cm4gWXIuZGlzam9pbnQodGhpcyx0KX0sY3Jvc3NlczpmdW5jdGlvbih0KXtyZXR1cm4gWXIuY3Jvc3Nlcyh0aGlzLHQpfSxidWZmZXI6ZnVuY3Rpb24oKXtpZigxPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIHQ9YXJndW1lbnRzWzBdO3JldHVybiBzci5idWZmZXJPcCh0aGlzLHQpfWlmKDI9PT1hcmd1bWVudHMubGVuZ3RoKXt2YXIgZT1hcmd1bWVudHNbMF0sbj1hcmd1bWVudHNbMV07cmV0dXJuIHNyLmJ1ZmZlck9wKHRoaXMsZSxuKX1pZigzPT09YXJndW1lbnRzLmxlbmd0aCl7dmFyIGk9YXJndW1lbnRzWzBdLHI9YXJndW1lbnRzWzFdLHM9YXJndW1lbnRzWzJdO3JldHVybiBzci5idWZmZXJPcCh0aGlzLGkscixzKX19LGNvbnZleEh1bGw6ZnVuY3Rpb24oKXtyZXR1cm4gbmV3IG1lKHRoaXMpLmdldENvbnZleEh1bGwoKX0scmVsYXRlOmZ1bmN0aW9uKCl7Zm9yKHZhciB0PWFyZ3VtZW50cy5sZW5ndGgsZT1BcnJheSh0KSxuPTA7dD5uO24rKyllW25dPWFyZ3VtZW50c1tuXTtyZXR1cm4gWXIucmVsYXRlLmFwcGx5KFlyLFt0aGlzXS5jb25jYXQoZSkpfSxnZXRDZW50cm9pZDpmdW5jdGlvbigpe2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0aGlzLmZhY3RvcnkuY3JlYXRlUG9pbnQoKTt2YXIgdD1nZS5nZXRDZW50cm9pZCh0aGlzKTtyZXR1cm4gdGhpcy5jcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkKHQsdGhpcyl9LGdldEludGVyaW9yUG9pbnQ6ZnVuY3Rpb24oKXtpZih0aGlzLmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5mYWN0b3J5LmNyZWF0ZVBvaW50KCk7dmFyIHQ9bnVsbCxlPXRoaXMuZ2V0RGltZW5zaW9uKCk7aWYoMD09PWUpe3ZhciBuPW5ldyBsaSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfWVsc2UgaWYoMT09PWUpe3ZhciBuPW5ldyB1aSh0aGlzKTt0PW4uZ2V0SW50ZXJpb3JQb2ludCgpfWVsc2V7dmFyIG49bmV3IG9pKHRoaXMpO3Q9bi5nZXRJbnRlcmlvclBvaW50KCl9cmV0dXJuIHRoaXMuY3JlYXRlUG9pbnRGcm9tSW50ZXJuYWxDb29yZCh0LHRoaXMpfSxzeW1EaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe2lmKHRoaXMuaXNFbXB0eSgpfHx0LmlzRW1wdHkoKSl7aWYodGhpcy5pc0VtcHR5KCkmJnQuaXNFbXB0eSgpKXJldHVybiBpaS5jcmVhdGVFbXB0eVJlc3VsdChpaS5TWU1ESUZGRVJFTkNFLHRoaXMsdCx0aGlzLmZhY3RvcnkpO2lmKHRoaXMuaXNFbXB0eSgpKXJldHVybiB0LmNvcHkoKTtpZih0LmlzRW1wdHkoKSlyZXR1cm4gdGhpcy5jb3B5KCl9cmV0dXJuIHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odGhpcyksdGhpcy5jaGVja05vdEdlb21ldHJ5Q29sbGVjdGlvbih0KSxzaS5vdmVybGF5T3AodGhpcyx0LGlpLlNZTURJRkZFUkVOQ0UpfSxjcmVhdGVQb2ludEZyb21JbnRlcm5hbENvb3JkOmZ1bmN0aW9uKHQsZSl7cmV0dXJuIGUuZ2V0UHJlY2lzaW9uTW9kZWwoKS5tYWtlUHJlY2lzZSh0KSxlLmdldEZhY3RvcnkoKS5jcmVhdGVQb2ludCh0KX0sdG9UZXh0OmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IHNlO3JldHVybiB0LndyaXRlKHRoaXMpfSx0b1N0cmluZzpmdW5jdGlvbigpe3RoaXMudG9UZXh0KCl9LGNvbnRhaW5zOmZ1bmN0aW9uKHQpe3JldHVybiBZci5jb250YWlucyh0aGlzLHQpfSxkaWZmZXJlbmNlOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmlzRW1wdHkoKT9paS5jcmVhdGVFbXB0eVJlc3VsdChpaS5ESUZGRVJFTkNFLHRoaXMsdCx0aGlzLmZhY3RvcnkpOnQuaXNFbXB0eSgpP3RoaXMuY29weSgpOih0aGlzLmNoZWNrTm90R2VvbWV0cnlDb2xsZWN0aW9uKHRoaXMpLHRoaXMuY2hlY2tOb3RHZW9tZXRyeUNvbGxlY3Rpb24odCksc2kub3ZlcmxheU9wKHRoaXMsdCxpaS5ESUZGRVJFTkNFKSl9LGlzU2ltcGxlOmZ1bmN0aW9uKCl7dmFyIHQ9bmV3IEdpKHRoaXMpO3JldHVybiB0LmlzU2ltcGxlKCl9LGlzV2l0aGluRGlzdGFuY2U6ZnVuY3Rpb24odCxlKXt2YXIgbj10aGlzLmdldEVudmVsb3BlSW50ZXJuYWwoKS5kaXN0YW5jZSh0LmdldEVudmVsb3BlSW50ZXJuYWwoKSk7cmV0dXJuIG4+ZT8hMTpoci5pc1dpdGhpbkRpc3RhbmNlKHRoaXMsdCxlKX0sZGlzdGFuY2U6ZnVuY3Rpb24odCl7cmV0dXJuIGhyLmRpc3RhbmNlKHRoaXMsdCl9LGlzRXF1aXZhbGVudENsYXNzOmZ1bmN0aW9uKHQpe3JldHVybiB0aGlzLmdldENsYXNzKCk9PT10LmdldENsYXNzKCl9fSk7dmFyIEFvPVwiMS4xLjIgKDI0OGRhYjgpXCI7dC52ZXJzaW9uPUFvLHQuYWxnb3JpdGhtPWNvLHQuZGVuc2lmeT1mbyx0LmRpc3NvbHZlPWdvLHQuZ2VvbT1sbyx0LmluZGV4PW1vLHQuaW89SW8sdC5ub2Rpbmc9Tm8sdC5vcGVyYXRpb249T28sdC5wcmVjaXNpb249X28sdC5zaW1wbGlmeT1Nbyx0LnRyaWFuZ3VsYXRlPURvfSk7XG4iLCIndXNlIHN0cmljdCdcblxubW9kdWxlLmV4cG9ydHMgPSBtb25vdG9uZUNvbnZleEh1bGwyRFxuXG52YXIgb3JpZW50ID0gcmVxdWlyZSgncm9idXN0LW9yaWVudGF0aW9uJylbM11cblxuZnVuY3Rpb24gbW9ub3RvbmVDb252ZXhIdWxsMkQocG9pbnRzKSB7XG4gIHZhciBuID0gcG9pbnRzLmxlbmd0aFxuXG4gIGlmKG4gPCAzKSB7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBBcnJheShuKVxuICAgIGZvcih2YXIgaT0wOyBpPG47ICsraSkge1xuICAgICAgcmVzdWx0W2ldID0gaVxuICAgIH1cblxuICAgIGlmKG4gPT09IDIgJiZcbiAgICAgICBwb2ludHNbMF1bMF0gPT09IHBvaW50c1sxXVswXSAmJlxuICAgICAgIHBvaW50c1swXVsxXSA9PT0gcG9pbnRzWzFdWzFdKSB7XG4gICAgICByZXR1cm4gWzBdXG4gICAgfVxuXG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG5cbiAgLy9Tb3J0IHBvaW50IGluZGljZXMgYWxvbmcgeC1heGlzXG4gIHZhciBzb3J0ZWQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgc29ydGVkW2ldID0gaVxuICB9XG4gIHNvcnRlZC5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHZhciBkID0gcG9pbnRzW2FdWzBdLXBvaW50c1tiXVswXVxuICAgIGlmKGQpIHtcbiAgICAgIHJldHVybiBkXG4gICAgfVxuICAgIHJldHVybiBwb2ludHNbYV1bMV0gLSBwb2ludHNbYl1bMV1cbiAgfSlcblxuICAvL0NvbnN0cnVjdCB1cHBlciBhbmQgbG93ZXIgaHVsbHNcbiAgdmFyIGxvd2VyID0gW3NvcnRlZFswXSwgc29ydGVkWzFdXVxuICB2YXIgdXBwZXIgPSBbc29ydGVkWzBdLCBzb3J0ZWRbMV1dXG5cbiAgZm9yKHZhciBpPTI7IGk8bjsgKytpKSB7XG4gICAgdmFyIGlkeCA9IHNvcnRlZFtpXVxuICAgIHZhciBwICAgPSBwb2ludHNbaWR4XVxuXG4gICAgLy9JbnNlcnQgaW50byBsb3dlciBsaXN0XG4gICAgdmFyIG0gPSBsb3dlci5sZW5ndGhcbiAgICB3aGlsZShtID4gMSAmJiBvcmllbnQoXG4gICAgICAgIHBvaW50c1tsb3dlclttLTJdXSwgXG4gICAgICAgIHBvaW50c1tsb3dlclttLTFdXSwgXG4gICAgICAgIHApIDw9IDApIHtcbiAgICAgIG0gLT0gMVxuICAgICAgbG93ZXIucG9wKClcbiAgICB9XG4gICAgbG93ZXIucHVzaChpZHgpXG5cbiAgICAvL0luc2VydCBpbnRvIHVwcGVyIGxpc3RcbiAgICBtID0gdXBwZXIubGVuZ3RoXG4gICAgd2hpbGUobSA+IDEgJiYgb3JpZW50KFxuICAgICAgICBwb2ludHNbdXBwZXJbbS0yXV0sIFxuICAgICAgICBwb2ludHNbdXBwZXJbbS0xXV0sIFxuICAgICAgICBwKSA+PSAwKSB7XG4gICAgICBtIC09IDFcbiAgICAgIHVwcGVyLnBvcCgpXG4gICAgfVxuICAgIHVwcGVyLnB1c2goaWR4KVxuICB9XG5cbiAgLy9NZXJnZSBsaXN0cyB0b2dldGhlclxuICB2YXIgcmVzdWx0ID0gbmV3IEFycmF5KHVwcGVyLmxlbmd0aCArIGxvd2VyLmxlbmd0aCAtIDIpXG4gIHZhciBwdHIgICAgPSAwXG4gIGZvcih2YXIgaT0wLCBubD1sb3dlci5sZW5ndGg7IGk8bmw7ICsraSkge1xuICAgIHJlc3VsdFtwdHIrK10gPSBsb3dlcltpXVxuICB9XG4gIGZvcih2YXIgaj11cHBlci5sZW5ndGgtMjsgaj4wOyAtLWopIHtcbiAgICByZXN1bHRbcHRyKytdID0gdXBwZXJbal1cbiAgfVxuXG4gIC8vUmV0dXJuIHJlc3VsdFxuICByZXR1cm4gcmVzdWx0XG59IiwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcblx0dHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnID8gbW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCkgOlxuXHR0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQgPyBkZWZpbmUoZmFjdG9yeSkgOlxuXHQoZ2xvYmFsLnF1aWNrc2VsZWN0ID0gZmFjdG9yeSgpKTtcbn0odGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG5mdW5jdGlvbiBxdWlja3NlbGVjdChhcnIsIGssIGxlZnQsIHJpZ2h0LCBjb21wYXJlKSB7XG4gICAgcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCB8fCAwLCByaWdodCB8fCAoYXJyLmxlbmd0aCAtIDEpLCBjb21wYXJlIHx8IGRlZmF1bHRDb21wYXJlKTtcbn1cblxuZnVuY3Rpb24gcXVpY2tzZWxlY3RTdGVwKGFyciwgaywgbGVmdCwgcmlnaHQsIGNvbXBhcmUpIHtcblxuICAgIHdoaWxlIChyaWdodCA+IGxlZnQpIHtcbiAgICAgICAgaWYgKHJpZ2h0IC0gbGVmdCA+IDYwMCkge1xuICAgICAgICAgICAgdmFyIG4gPSByaWdodCAtIGxlZnQgKyAxO1xuICAgICAgICAgICAgdmFyIG0gPSBrIC0gbGVmdCArIDE7XG4gICAgICAgICAgICB2YXIgeiA9IE1hdGgubG9nKG4pO1xuICAgICAgICAgICAgdmFyIHMgPSAwLjUgKiBNYXRoLmV4cCgyICogeiAvIDMpO1xuICAgICAgICAgICAgdmFyIHNkID0gMC41ICogTWF0aC5zcXJ0KHogKiBzICogKG4gLSBzKSAvIG4pICogKG0gLSBuIC8gMiA8IDAgPyAtMSA6IDEpO1xuICAgICAgICAgICAgdmFyIG5ld0xlZnQgPSBNYXRoLm1heChsZWZ0LCBNYXRoLmZsb29yKGsgLSBtICogcyAvIG4gKyBzZCkpO1xuICAgICAgICAgICAgdmFyIG5ld1JpZ2h0ID0gTWF0aC5taW4ocmlnaHQsIE1hdGguZmxvb3IoayArIChuIC0gbSkgKiBzIC8gbiArIHNkKSk7XG4gICAgICAgICAgICBxdWlja3NlbGVjdFN0ZXAoYXJyLCBrLCBuZXdMZWZ0LCBuZXdSaWdodCwgY29tcGFyZSk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgdCA9IGFycltrXTtcbiAgICAgICAgdmFyIGkgPSBsZWZ0O1xuICAgICAgICB2YXIgaiA9IHJpZ2h0O1xuXG4gICAgICAgIHN3YXAoYXJyLCBsZWZ0LCBrKTtcbiAgICAgICAgaWYgKGNvbXBhcmUoYXJyW3JpZ2h0XSwgdCkgPiAwKSBzd2FwKGFyciwgbGVmdCwgcmlnaHQpO1xuXG4gICAgICAgIHdoaWxlIChpIDwgaikge1xuICAgICAgICAgICAgc3dhcChhcnIsIGksIGopO1xuICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgai0tO1xuICAgICAgICAgICAgd2hpbGUgKGNvbXBhcmUoYXJyW2ldLCB0KSA8IDApIGkrKztcbiAgICAgICAgICAgIHdoaWxlIChjb21wYXJlKGFycltqXSwgdCkgPiAwKSBqLS07XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoY29tcGFyZShhcnJbbGVmdF0sIHQpID09PSAwKSBzd2FwKGFyciwgbGVmdCwgaik7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgc3dhcChhcnIsIGosIHJpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChqIDw9IGspIGxlZnQgPSBqICsgMTtcbiAgICAgICAgaWYgKGsgPD0gaikgcmlnaHQgPSBqIC0gMTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIHN3YXAoYXJyLCBpLCBqKSB7XG4gICAgdmFyIHRtcCA9IGFycltpXTtcbiAgICBhcnJbaV0gPSBhcnJbal07XG4gICAgYXJyW2pdID0gdG1wO1xufVxuXG5mdW5jdGlvbiBkZWZhdWx0Q29tcGFyZShhLCBiKSB7XG4gICAgcmV0dXJuIGEgPCBiID8gLTEgOiBhID4gYiA/IDEgOiAwO1xufVxuXG5yZXR1cm4gcXVpY2tzZWxlY3Q7XG5cbn0pKSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gcmJ1c2g7XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gcmJ1c2g7XG5cbnZhciBxdWlja3NlbGVjdCA9IHJlcXVpcmUoJ3F1aWNrc2VsZWN0Jyk7XG5cbmZ1bmN0aW9uIHJidXNoKG1heEVudHJpZXMsIGZvcm1hdCkge1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiByYnVzaCkpIHJldHVybiBuZXcgcmJ1c2gobWF4RW50cmllcywgZm9ybWF0KTtcblxuICAgIC8vIG1heCBlbnRyaWVzIGluIGEgbm9kZSBpcyA5IGJ5IGRlZmF1bHQ7IG1pbiBub2RlIGZpbGwgaXMgNDAlIGZvciBiZXN0IHBlcmZvcm1hbmNlXG4gICAgdGhpcy5fbWF4RW50cmllcyA9IE1hdGgubWF4KDQsIG1heEVudHJpZXMgfHwgOSk7XG4gICAgdGhpcy5fbWluRW50cmllcyA9IE1hdGgubWF4KDIsIE1hdGguY2VpbCh0aGlzLl9tYXhFbnRyaWVzICogMC40KSk7XG5cbiAgICBpZiAoZm9ybWF0KSB7XG4gICAgICAgIHRoaXMuX2luaXRGb3JtYXQoZm9ybWF0KTtcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFyKCk7XG59XG5cbnJidXNoLnByb3RvdHlwZSA9IHtcblxuICAgIGFsbDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYWxsKHRoaXMuZGF0YSwgW10pO1xuICAgIH0sXG5cbiAgICBzZWFyY2g6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICByZXN1bHQgPSBbXSxcbiAgICAgICAgICAgIHRvQkJveCA9IHRoaXMudG9CQm94O1xuXG4gICAgICAgIGlmICghaW50ZXJzZWN0cyhiYm94LCBub2RlKSkgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmKSByZXN1bHQucHVzaChjaGlsZCk7XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHRoaXMuX2FsbChjaGlsZCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZSBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgY29sbGlkZXM6IGZ1bmN0aW9uIChiYm94KSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLmRhdGEsXG4gICAgICAgICAgICB0b0JCb3ggPSB0aGlzLnRvQkJveDtcblxuICAgICAgICBpZiAoIWludGVyc2VjdHMoYmJveCwgbm9kZSkpIHJldHVybiBmYWxzZTtcblxuICAgICAgICB2YXIgbm9kZXNUb1NlYXJjaCA9IFtdLFxuICAgICAgICAgICAgaSwgbGVuLCBjaGlsZCwgY2hpbGRCQm94O1xuXG4gICAgICAgIHdoaWxlIChub2RlKSB7XG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cbiAgICAgICAgICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgY2hpbGRCQm94ID0gbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkO1xuXG4gICAgICAgICAgICAgICAgaWYgKGludGVyc2VjdHMoYmJveCwgY2hpbGRCQm94KSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAobm9kZS5sZWFmIHx8IGNvbnRhaW5zKGJib3gsIGNoaWxkQkJveCkpIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBub2Rlc1RvU2VhcmNoLnB1c2goY2hpbGQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vZGUgPSBub2Rlc1RvU2VhcmNoLnBvcCgpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH0sXG5cbiAgICBsb2FkOiBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoIShkYXRhICYmIGRhdGEubGVuZ3RoKSkgcmV0dXJuIHRoaXM7XG5cbiAgICAgICAgaWYgKGRhdGEubGVuZ3RoIDwgdGhpcy5fbWluRW50cmllcykge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IGRhdGEubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICAgICAgICAgICAgICB0aGlzLmluc2VydChkYXRhW2ldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVjdXJzaXZlbHkgYnVpbGQgdGhlIHRyZWUgd2l0aCB0aGUgZ2l2ZW4gZGF0YSBmcm9tIHNjcmF0Y2ggdXNpbmcgT01UIGFsZ29yaXRobVxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuX2J1aWxkKGRhdGEuc2xpY2UoKSwgMCwgZGF0YS5sZW5ndGggLSAxLCAwKTtcblxuICAgICAgICBpZiAoIXRoaXMuZGF0YS5jaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgYXMgaXMgaWYgdHJlZSBpcyBlbXB0eVxuICAgICAgICAgICAgdGhpcy5kYXRhID0gbm9kZTtcblxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPT09IG5vZGUuaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyBzcGxpdCByb290IGlmIHRyZWVzIGhhdmUgdGhlIHNhbWUgaGVpZ2h0XG4gICAgICAgICAgICB0aGlzLl9zcGxpdFJvb3QodGhpcy5kYXRhLCBub2RlKTtcblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHRoaXMuZGF0YS5oZWlnaHQgPCBub2RlLmhlaWdodCkge1xuICAgICAgICAgICAgICAgIC8vIHN3YXAgdHJlZXMgaWYgaW5zZXJ0ZWQgb25lIGlzIGJpZ2dlclxuICAgICAgICAgICAgICAgIHZhciB0bXBOb2RlID0gdGhpcy5kYXRhO1xuICAgICAgICAgICAgICAgIHRoaXMuZGF0YSA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IHRtcE5vZGU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIC8vIGluc2VydCB0aGUgc21hbGwgdHJlZSBpbnRvIHRoZSBsYXJnZSB0cmVlIGF0IGFwcHJvcHJpYXRlIGxldmVsXG4gICAgICAgICAgICB0aGlzLl9pbnNlcnQobm9kZSwgdGhpcy5kYXRhLmhlaWdodCAtIG5vZGUuaGVpZ2h0IC0gMSwgdHJ1ZSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbSkgdGhpcy5faW5zZXJ0KGl0ZW0sIHRoaXMuZGF0YS5oZWlnaHQgLSAxKTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuZGF0YSA9IGNyZWF0ZU5vZGUoW10pO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcmVtb3ZlOiBmdW5jdGlvbiAoaXRlbSwgZXF1YWxzRm4pIHtcbiAgICAgICAgaWYgKCFpdGVtKSByZXR1cm4gdGhpcztcblxuICAgICAgICB2YXIgbm9kZSA9IHRoaXMuZGF0YSxcbiAgICAgICAgICAgIGJib3ggPSB0aGlzLnRvQkJveChpdGVtKSxcbiAgICAgICAgICAgIHBhdGggPSBbXSxcbiAgICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICAgIGksIHBhcmVudCwgaW5kZXgsIGdvaW5nVXA7XG5cbiAgICAgICAgLy8gZGVwdGgtZmlyc3QgaXRlcmF0aXZlIHRyZWUgdHJhdmVyc2FsXG4gICAgICAgIHdoaWxlIChub2RlIHx8IHBhdGgubGVuZ3RoKSB7XG5cbiAgICAgICAgICAgIGlmICghbm9kZSkgeyAvLyBnbyB1cFxuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXRoLnBvcCgpO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IHBhdGhbcGF0aC5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgICBpID0gaW5kZXhlcy5wb3AoKTtcbiAgICAgICAgICAgICAgICBnb2luZ1VwID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKG5vZGUubGVhZikgeyAvLyBjaGVjayBjdXJyZW50IG5vZGVcbiAgICAgICAgICAgICAgICBpbmRleCA9IGZpbmRJdGVtKGl0ZW0sIG5vZGUuY2hpbGRyZW4sIGVxdWFsc0ZuKTtcblxuICAgICAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXRlbSBmb3VuZCwgcmVtb3ZlIHRoZSBpdGVtIGFuZCBjb25kZW5zZSB0cmVlIHVwd2FyZHNcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5jaGlsZHJlbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgICAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2NvbmRlbnNlKHBhdGgpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghZ29pbmdVcCAmJiAhbm9kZS5sZWFmICYmIGNvbnRhaW5zKG5vZGUsIGJib3gpKSB7IC8vIGdvIGRvd25cbiAgICAgICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgaW5kZXhlcy5wdXNoKGkpO1xuICAgICAgICAgICAgICAgIGkgPSAwO1xuICAgICAgICAgICAgICAgIHBhcmVudCA9IG5vZGU7XG4gICAgICAgICAgICAgICAgbm9kZSA9IG5vZGUuY2hpbGRyZW5bMF07XG5cbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyZW50KSB7IC8vIGdvIHJpZ2h0XG4gICAgICAgICAgICAgICAgaSsrO1xuICAgICAgICAgICAgICAgIG5vZGUgPSBwYXJlbnQuY2hpbGRyZW5baV07XG4gICAgICAgICAgICAgICAgZ29pbmdVcCA9IGZhbHNlO1xuXG4gICAgICAgICAgICB9IGVsc2Ugbm9kZSA9IG51bGw7IC8vIG5vdGhpbmcgZm91bmRcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICB0b0JCb3g6IGZ1bmN0aW9uIChpdGVtKSB7IHJldHVybiBpdGVtOyB9LFxuXG4gICAgY29tcGFyZU1pblg6IGNvbXBhcmVOb2RlTWluWCxcbiAgICBjb21wYXJlTWluWTogY29tcGFyZU5vZGVNaW5ZLFxuXG4gICAgdG9KU09OOiBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzLmRhdGE7IH0sXG5cbiAgICBmcm9tSlNPTjogZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgdGhpcy5kYXRhID0gZGF0YTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIF9hbGw6IGZ1bmN0aW9uIChub2RlLCByZXN1bHQpIHtcbiAgICAgICAgdmFyIG5vZGVzVG9TZWFyY2ggPSBbXTtcbiAgICAgICAgd2hpbGUgKG5vZGUpIHtcbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYpIHJlc3VsdC5wdXNoLmFwcGx5KHJlc3VsdCwgbm9kZS5jaGlsZHJlbik7XG4gICAgICAgICAgICBlbHNlIG5vZGVzVG9TZWFyY2gucHVzaC5hcHBseShub2Rlc1RvU2VhcmNoLCBub2RlLmNoaWxkcmVuKTtcblxuICAgICAgICAgICAgbm9kZSA9IG5vZGVzVG9TZWFyY2gucG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuXG4gICAgX2J1aWxkOiBmdW5jdGlvbiAoaXRlbXMsIGxlZnQsIHJpZ2h0LCBoZWlnaHQpIHtcblxuICAgICAgICB2YXIgTiA9IHJpZ2h0IC0gbGVmdCArIDEsXG4gICAgICAgICAgICBNID0gdGhpcy5fbWF4RW50cmllcyxcbiAgICAgICAgICAgIG5vZGU7XG5cbiAgICAgICAgaWYgKE4gPD0gTSkge1xuICAgICAgICAgICAgLy8gcmVhY2hlZCBsZWFmIGxldmVsOyByZXR1cm4gbGVhZlxuICAgICAgICAgICAgbm9kZSA9IGNyZWF0ZU5vZGUoaXRlbXMuc2xpY2UobGVmdCwgcmlnaHQgKyAxKSk7XG4gICAgICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICByZXR1cm4gbm9kZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmICghaGVpZ2h0KSB7XG4gICAgICAgICAgICAvLyB0YXJnZXQgaGVpZ2h0IG9mIHRoZSBidWxrLWxvYWRlZCB0cmVlXG4gICAgICAgICAgICBoZWlnaHQgPSBNYXRoLmNlaWwoTWF0aC5sb2coTikgLyBNYXRoLmxvZyhNKSk7XG5cbiAgICAgICAgICAgIC8vIHRhcmdldCBudW1iZXIgb2Ygcm9vdCBlbnRyaWVzIHRvIG1heGltaXplIHN0b3JhZ2UgdXRpbGl6YXRpb25cbiAgICAgICAgICAgIE0gPSBNYXRoLmNlaWwoTiAvIE1hdGgucG93KE0sIGhlaWdodCAtIDEpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIG5vZGUgPSBjcmVhdGVOb2RlKFtdKTtcbiAgICAgICAgbm9kZS5sZWFmID0gZmFsc2U7XG4gICAgICAgIG5vZGUuaGVpZ2h0ID0gaGVpZ2h0O1xuXG4gICAgICAgIC8vIHNwbGl0IHRoZSBpdGVtcyBpbnRvIE0gbW9zdGx5IHNxdWFyZSB0aWxlc1xuXG4gICAgICAgIHZhciBOMiA9IE1hdGguY2VpbChOIC8gTSksXG4gICAgICAgICAgICBOMSA9IE4yICogTWF0aC5jZWlsKE1hdGguc3FydChNKSksXG4gICAgICAgICAgICBpLCBqLCByaWdodDIsIHJpZ2h0MztcblxuICAgICAgICBtdWx0aVNlbGVjdChpdGVtcywgbGVmdCwgcmlnaHQsIE4xLCB0aGlzLmNvbXBhcmVNaW5YKTtcblxuICAgICAgICBmb3IgKGkgPSBsZWZ0OyBpIDw9IHJpZ2h0OyBpICs9IE4xKSB7XG5cbiAgICAgICAgICAgIHJpZ2h0MiA9IE1hdGgubWluKGkgKyBOMSAtIDEsIHJpZ2h0KTtcblxuICAgICAgICAgICAgbXVsdGlTZWxlY3QoaXRlbXMsIGksIHJpZ2h0MiwgTjIsIHRoaXMuY29tcGFyZU1pblkpO1xuXG4gICAgICAgICAgICBmb3IgKGogPSBpOyBqIDw9IHJpZ2h0MjsgaiArPSBOMikge1xuXG4gICAgICAgICAgICAgICAgcmlnaHQzID0gTWF0aC5taW4oaiArIE4yIC0gMSwgcmlnaHQyKTtcblxuICAgICAgICAgICAgICAgIC8vIHBhY2sgZWFjaCBlbnRyeSByZWN1cnNpdmVseVxuICAgICAgICAgICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaCh0aGlzLl9idWlsZChpdGVtcywgaiwgcmlnaHQzLCBoZWlnaHQgLSAxKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjYWxjQkJveChub2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfSxcblxuICAgIF9jaG9vc2VTdWJ0cmVlOiBmdW5jdGlvbiAoYmJveCwgbm9kZSwgbGV2ZWwsIHBhdGgpIHtcblxuICAgICAgICB2YXIgaSwgbGVuLCBjaGlsZCwgdGFyZ2V0Tm9kZSwgYXJlYSwgZW5sYXJnZW1lbnQsIG1pbkFyZWEsIG1pbkVubGFyZ2VtZW50O1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBwYXRoLnB1c2gobm9kZSk7XG5cbiAgICAgICAgICAgIGlmIChub2RlLmxlYWYgfHwgcGF0aC5sZW5ndGggLSAxID09PSBsZXZlbCkgYnJlYWs7XG5cbiAgICAgICAgICAgIG1pbkFyZWEgPSBtaW5FbmxhcmdlbWVudCA9IEluZmluaXR5O1xuXG4gICAgICAgICAgICBmb3IgKGkgPSAwLCBsZW4gPSBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY2hpbGQgPSBub2RlLmNoaWxkcmVuW2ldO1xuICAgICAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShjaGlsZCk7XG4gICAgICAgICAgICAgICAgZW5sYXJnZW1lbnQgPSBlbmxhcmdlZEFyZWEoYmJveCwgY2hpbGQpIC0gYXJlYTtcblxuICAgICAgICAgICAgICAgIC8vIGNob29zZSBlbnRyeSB3aXRoIHRoZSBsZWFzdCBhcmVhIGVubGFyZ2VtZW50XG4gICAgICAgICAgICAgICAgaWYgKGVubGFyZ2VtZW50IDwgbWluRW5sYXJnZW1lbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbWluRW5sYXJnZW1lbnQgPSBlbmxhcmdlbWVudDtcbiAgICAgICAgICAgICAgICAgICAgbWluQXJlYSA9IGFyZWEgPCBtaW5BcmVhID8gYXJlYSA6IG1pbkFyZWE7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZW5sYXJnZW1lbnQgPT09IG1pbkVubGFyZ2VtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIG90aGVyd2lzZSBjaG9vc2Ugb25lIHdpdGggdGhlIHNtYWxsZXN0IGFyZWFcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZWEgPCBtaW5BcmVhKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGUgPSBjaGlsZDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgbm9kZSA9IHRhcmdldE5vZGUgfHwgbm9kZS5jaGlsZHJlblswXTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBub2RlO1xuICAgIH0sXG5cbiAgICBfaW5zZXJ0OiBmdW5jdGlvbiAoaXRlbSwgbGV2ZWwsIGlzTm9kZSkge1xuXG4gICAgICAgIHZhciB0b0JCb3ggPSB0aGlzLnRvQkJveCxcbiAgICAgICAgICAgIGJib3ggPSBpc05vZGUgPyBpdGVtIDogdG9CQm94KGl0ZW0pLFxuICAgICAgICAgICAgaW5zZXJ0UGF0aCA9IFtdO1xuXG4gICAgICAgIC8vIGZpbmQgdGhlIGJlc3Qgbm9kZSBmb3IgYWNjb21tb2RhdGluZyB0aGUgaXRlbSwgc2F2aW5nIGFsbCBub2RlcyBhbG9uZyB0aGUgcGF0aCB0b29cbiAgICAgICAgdmFyIG5vZGUgPSB0aGlzLl9jaG9vc2VTdWJ0cmVlKGJib3gsIHRoaXMuZGF0YSwgbGV2ZWwsIGluc2VydFBhdGgpO1xuXG4gICAgICAgIC8vIHB1dCB0aGUgaXRlbSBpbnRvIHRoZSBub2RlXG4gICAgICAgIG5vZGUuY2hpbGRyZW4ucHVzaChpdGVtKTtcbiAgICAgICAgZXh0ZW5kKG5vZGUsIGJib3gpO1xuXG4gICAgICAgIC8vIHNwbGl0IG9uIG5vZGUgb3ZlcmZsb3c7IHByb3BhZ2F0ZSB1cHdhcmRzIGlmIG5lY2Vzc2FyeVxuICAgICAgICB3aGlsZSAobGV2ZWwgPj0gMCkge1xuICAgICAgICAgICAgaWYgKGluc2VydFBhdGhbbGV2ZWxdLmNoaWxkcmVuLmxlbmd0aCA+IHRoaXMuX21heEVudHJpZXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9zcGxpdChpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgICAgICAgICAgICAgbGV2ZWwtLTtcbiAgICAgICAgICAgIH0gZWxzZSBicmVhaztcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGluc2VydGlvbiBwYXRoXG4gICAgICAgIHRoaXMuX2FkanVzdFBhcmVudEJCb3hlcyhiYm94LCBpbnNlcnRQYXRoLCBsZXZlbCk7XG4gICAgfSxcblxuICAgIC8vIHNwbGl0IG92ZXJmbG93ZWQgbm9kZSBpbnRvIHR3b1xuICAgIF9zcGxpdDogZnVuY3Rpb24gKGluc2VydFBhdGgsIGxldmVsKSB7XG5cbiAgICAgICAgdmFyIG5vZGUgPSBpbnNlcnRQYXRoW2xldmVsXSxcbiAgICAgICAgICAgIE0gPSBub2RlLmNoaWxkcmVuLmxlbmd0aCxcbiAgICAgICAgICAgIG0gPSB0aGlzLl9taW5FbnRyaWVzO1xuXG4gICAgICAgIHRoaXMuX2Nob29zZVNwbGl0QXhpcyhub2RlLCBtLCBNKTtcblxuICAgICAgICB2YXIgc3BsaXRJbmRleCA9IHRoaXMuX2Nob29zZVNwbGl0SW5kZXgobm9kZSwgbSwgTSk7XG5cbiAgICAgICAgdmFyIG5ld05vZGUgPSBjcmVhdGVOb2RlKG5vZGUuY2hpbGRyZW4uc3BsaWNlKHNwbGl0SW5kZXgsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoIC0gc3BsaXRJbmRleCkpO1xuICAgICAgICBuZXdOb2RlLmhlaWdodCA9IG5vZGUuaGVpZ2h0O1xuICAgICAgICBuZXdOb2RlLmxlYWYgPSBub2RlLmxlYWY7XG5cbiAgICAgICAgY2FsY0JCb3gobm9kZSwgdGhpcy50b0JCb3gpO1xuICAgICAgICBjYWxjQkJveChuZXdOb2RlLCB0aGlzLnRvQkJveCk7XG5cbiAgICAgICAgaWYgKGxldmVsKSBpbnNlcnRQYXRoW2xldmVsIC0gMV0uY2hpbGRyZW4ucHVzaChuZXdOb2RlKTtcbiAgICAgICAgZWxzZSB0aGlzLl9zcGxpdFJvb3Qobm9kZSwgbmV3Tm9kZSk7XG4gICAgfSxcblxuICAgIF9zcGxpdFJvb3Q6IGZ1bmN0aW9uIChub2RlLCBuZXdOb2RlKSB7XG4gICAgICAgIC8vIHNwbGl0IHJvb3Qgbm9kZVxuICAgICAgICB0aGlzLmRhdGEgPSBjcmVhdGVOb2RlKFtub2RlLCBuZXdOb2RlXSk7XG4gICAgICAgIHRoaXMuZGF0YS5oZWlnaHQgPSBub2RlLmhlaWdodCArIDE7XG4gICAgICAgIHRoaXMuZGF0YS5sZWFmID0gZmFsc2U7XG4gICAgICAgIGNhbGNCQm94KHRoaXMuZGF0YSwgdGhpcy50b0JCb3gpO1xuICAgIH0sXG5cbiAgICBfY2hvb3NlU3BsaXRJbmRleDogZnVuY3Rpb24gKG5vZGUsIG0sIE0pIHtcblxuICAgICAgICB2YXIgaSwgYmJveDEsIGJib3gyLCBvdmVybGFwLCBhcmVhLCBtaW5PdmVybGFwLCBtaW5BcmVhLCBpbmRleDtcblxuICAgICAgICBtaW5PdmVybGFwID0gbWluQXJlYSA9IEluZmluaXR5O1xuXG4gICAgICAgIGZvciAoaSA9IG07IGkgPD0gTSAtIG07IGkrKykge1xuICAgICAgICAgICAgYmJveDEgPSBkaXN0QkJveChub2RlLCAwLCBpLCB0aGlzLnRvQkJveCk7XG4gICAgICAgICAgICBiYm94MiA9IGRpc3RCQm94KG5vZGUsIGksIE0sIHRoaXMudG9CQm94KTtcblxuICAgICAgICAgICAgb3ZlcmxhcCA9IGludGVyc2VjdGlvbkFyZWEoYmJveDEsIGJib3gyKTtcbiAgICAgICAgICAgIGFyZWEgPSBiYm94QXJlYShiYm94MSkgKyBiYm94QXJlYShiYm94Mik7XG5cbiAgICAgICAgICAgIC8vIGNob29zZSBkaXN0cmlidXRpb24gd2l0aCBtaW5pbXVtIG92ZXJsYXBcbiAgICAgICAgICAgIGlmIChvdmVybGFwIDwgbWluT3ZlcmxhcCkge1xuICAgICAgICAgICAgICAgIG1pbk92ZXJsYXAgPSBvdmVybGFwO1xuICAgICAgICAgICAgICAgIGluZGV4ID0gaTtcblxuICAgICAgICAgICAgICAgIG1pbkFyZWEgPSBhcmVhIDwgbWluQXJlYSA/IGFyZWEgOiBtaW5BcmVhO1xuXG4gICAgICAgICAgICB9IGVsc2UgaWYgKG92ZXJsYXAgPT09IG1pbk92ZXJsYXApIHtcbiAgICAgICAgICAgICAgICAvLyBvdGhlcndpc2UgY2hvb3NlIGRpc3RyaWJ1dGlvbiB3aXRoIG1pbmltdW0gYXJlYVxuICAgICAgICAgICAgICAgIGlmIChhcmVhIDwgbWluQXJlYSkge1xuICAgICAgICAgICAgICAgICAgICBtaW5BcmVhID0gYXJlYTtcbiAgICAgICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICB9LFxuXG4gICAgLy8gc29ydHMgbm9kZSBjaGlsZHJlbiBieSB0aGUgYmVzdCBheGlzIGZvciBzcGxpdFxuICAgIF9jaG9vc2VTcGxpdEF4aXM6IGZ1bmN0aW9uIChub2RlLCBtLCBNKSB7XG5cbiAgICAgICAgdmFyIGNvbXBhcmVNaW5YID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWCA6IGNvbXBhcmVOb2RlTWluWCxcbiAgICAgICAgICAgIGNvbXBhcmVNaW5ZID0gbm9kZS5sZWFmID8gdGhpcy5jb21wYXJlTWluWSA6IGNvbXBhcmVOb2RlTWluWSxcbiAgICAgICAgICAgIHhNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5YKSxcbiAgICAgICAgICAgIHlNYXJnaW4gPSB0aGlzLl9hbGxEaXN0TWFyZ2luKG5vZGUsIG0sIE0sIGNvbXBhcmVNaW5ZKTtcblxuICAgICAgICAvLyBpZiB0b3RhbCBkaXN0cmlidXRpb25zIG1hcmdpbiB2YWx1ZSBpcyBtaW5pbWFsIGZvciB4LCBzb3J0IGJ5IG1pblgsXG4gICAgICAgIC8vIG90aGVyd2lzZSBpdCdzIGFscmVhZHkgc29ydGVkIGJ5IG1pbllcbiAgICAgICAgaWYgKHhNYXJnaW4gPCB5TWFyZ2luKSBub2RlLmNoaWxkcmVuLnNvcnQoY29tcGFyZU1pblgpO1xuICAgIH0sXG5cbiAgICAvLyB0b3RhbCBtYXJnaW4gb2YgYWxsIHBvc3NpYmxlIHNwbGl0IGRpc3RyaWJ1dGlvbnMgd2hlcmUgZWFjaCBub2RlIGlzIGF0IGxlYXN0IG0gZnVsbFxuICAgIF9hbGxEaXN0TWFyZ2luOiBmdW5jdGlvbiAobm9kZSwgbSwgTSwgY29tcGFyZSkge1xuXG4gICAgICAgIG5vZGUuY2hpbGRyZW4uc29ydChjb21wYXJlKTtcblxuICAgICAgICB2YXIgdG9CQm94ID0gdGhpcy50b0JCb3gsXG4gICAgICAgICAgICBsZWZ0QkJveCA9IGRpc3RCQm94KG5vZGUsIDAsIG0sIHRvQkJveCksXG4gICAgICAgICAgICByaWdodEJCb3ggPSBkaXN0QkJveChub2RlLCBNIC0gbSwgTSwgdG9CQm94KSxcbiAgICAgICAgICAgIG1hcmdpbiA9IGJib3hNYXJnaW4obGVmdEJCb3gpICsgYmJveE1hcmdpbihyaWdodEJCb3gpLFxuICAgICAgICAgICAgaSwgY2hpbGQ7XG5cbiAgICAgICAgZm9yIChpID0gbTsgaSA8IE0gLSBtOyBpKyspIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChsZWZ0QkJveCwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICAgICAgICAgIG1hcmdpbiArPSBiYm94TWFyZ2luKGxlZnRCQm94KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZvciAoaSA9IE0gLSBtIC0gMTsgaSA+PSBtOyBpLS0pIHtcbiAgICAgICAgICAgIGNoaWxkID0gbm9kZS5jaGlsZHJlbltpXTtcbiAgICAgICAgICAgIGV4dGVuZChyaWdodEJCb3gsIG5vZGUubGVhZiA/IHRvQkJveChjaGlsZCkgOiBjaGlsZCk7XG4gICAgICAgICAgICBtYXJnaW4gKz0gYmJveE1hcmdpbihyaWdodEJCb3gpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIG1hcmdpbjtcbiAgICB9LFxuXG4gICAgX2FkanVzdFBhcmVudEJCb3hlczogZnVuY3Rpb24gKGJib3gsIHBhdGgsIGxldmVsKSB7XG4gICAgICAgIC8vIGFkanVzdCBiYm94ZXMgYWxvbmcgdGhlIGdpdmVuIHRyZWUgcGF0aFxuICAgICAgICBmb3IgKHZhciBpID0gbGV2ZWw7IGkgPj0gMDsgaS0tKSB7XG4gICAgICAgICAgICBleHRlbmQocGF0aFtpXSwgYmJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2NvbmRlbnNlOiBmdW5jdGlvbiAocGF0aCkge1xuICAgICAgICAvLyBnbyB0aHJvdWdoIHRoZSBwYXRoLCByZW1vdmluZyBlbXB0eSBub2RlcyBhbmQgdXBkYXRpbmcgYmJveGVzXG4gICAgICAgIGZvciAodmFyIGkgPSBwYXRoLmxlbmd0aCAtIDEsIHNpYmxpbmdzOyBpID49IDA7IGktLSkge1xuICAgICAgICAgICAgaWYgKHBhdGhbaV0uY2hpbGRyZW4ubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzID0gcGF0aFtpIC0gMV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgICAgIHNpYmxpbmdzLnNwbGljZShzaWJsaW5ncy5pbmRleE9mKHBhdGhbaV0pLCAxKTtcblxuICAgICAgICAgICAgICAgIH0gZWxzZSB0aGlzLmNsZWFyKCk7XG5cbiAgICAgICAgICAgIH0gZWxzZSBjYWxjQkJveChwYXRoW2ldLCB0aGlzLnRvQkJveCk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgX2luaXRGb3JtYXQ6IGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgICAgLy8gZGF0YSBmb3JtYXQgKG1pblgsIG1pblksIG1heFgsIG1heFkgYWNjZXNzb3JzKVxuXG4gICAgICAgIC8vIHVzZXMgZXZhbC10eXBlIGZ1bmN0aW9uIGNvbXBpbGF0aW9uIGluc3RlYWQgb2YganVzdCBhY2NlcHRpbmcgYSB0b0JCb3ggZnVuY3Rpb25cbiAgICAgICAgLy8gYmVjYXVzZSB0aGUgYWxnb3JpdGhtcyBhcmUgdmVyeSBzZW5zaXRpdmUgdG8gc29ydGluZyBmdW5jdGlvbnMgcGVyZm9ybWFuY2UsXG4gICAgICAgIC8vIHNvIHRoZXkgc2hvdWxkIGJlIGRlYWQgc2ltcGxlIGFuZCB3aXRob3V0IGlubmVyIGNhbGxzXG5cbiAgICAgICAgdmFyIGNvbXBhcmVBcnIgPSBbJ3JldHVybiBhJywgJyAtIGInLCAnOyddO1xuXG4gICAgICAgIHRoaXMuY29tcGFyZU1pblggPSBuZXcgRnVuY3Rpb24oJ2EnLCAnYicsIGNvbXBhcmVBcnIuam9pbihmb3JtYXRbMF0pKTtcbiAgICAgICAgdGhpcy5jb21wYXJlTWluWSA9IG5ldyBGdW5jdGlvbignYScsICdiJywgY29tcGFyZUFyci5qb2luKGZvcm1hdFsxXSkpO1xuXG4gICAgICAgIHRoaXMudG9CQm94ID0gbmV3IEZ1bmN0aW9uKCdhJyxcbiAgICAgICAgICAgICdyZXR1cm4ge21pblg6IGEnICsgZm9ybWF0WzBdICtcbiAgICAgICAgICAgICcsIG1pblk6IGEnICsgZm9ybWF0WzFdICtcbiAgICAgICAgICAgICcsIG1heFg6IGEnICsgZm9ybWF0WzJdICtcbiAgICAgICAgICAgICcsIG1heFk6IGEnICsgZm9ybWF0WzNdICsgJ307Jyk7XG4gICAgfVxufTtcblxuZnVuY3Rpb24gZmluZEl0ZW0oaXRlbSwgaXRlbXMsIGVxdWFsc0ZuKSB7XG4gICAgaWYgKCFlcXVhbHNGbikgcmV0dXJuIGl0ZW1zLmluZGV4T2YoaXRlbSk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChlcXVhbHNGbihpdGVtLCBpdGVtc1tpXSkpIHJldHVybiBpO1xuICAgIH1cbiAgICByZXR1cm4gLTE7XG59XG5cbi8vIGNhbGN1bGF0ZSBub2RlJ3MgYmJveCBmcm9tIGJib3hlcyBvZiBpdHMgY2hpbGRyZW5cbmZ1bmN0aW9uIGNhbGNCQm94KG5vZGUsIHRvQkJveCkge1xuICAgIGRpc3RCQm94KG5vZGUsIDAsIG5vZGUuY2hpbGRyZW4ubGVuZ3RoLCB0b0JCb3gsIG5vZGUpO1xufVxuXG4vLyBtaW4gYm91bmRpbmcgcmVjdGFuZ2xlIG9mIG5vZGUgY2hpbGRyZW4gZnJvbSBrIHRvIHAtMVxuZnVuY3Rpb24gZGlzdEJCb3gobm9kZSwgaywgcCwgdG9CQm94LCBkZXN0Tm9kZSkge1xuICAgIGlmICghZGVzdE5vZGUpIGRlc3ROb2RlID0gY3JlYXRlTm9kZShudWxsKTtcbiAgICBkZXN0Tm9kZS5taW5YID0gSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWluWSA9IEluZmluaXR5O1xuICAgIGRlc3ROb2RlLm1heFggPSAtSW5maW5pdHk7XG4gICAgZGVzdE5vZGUubWF4WSA9IC1JbmZpbml0eTtcblxuICAgIGZvciAodmFyIGkgPSBrLCBjaGlsZDsgaSA8IHA7IGkrKykge1xuICAgICAgICBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICAgIGV4dGVuZChkZXN0Tm9kZSwgbm9kZS5sZWFmID8gdG9CQm94KGNoaWxkKSA6IGNoaWxkKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZGVzdE5vZGU7XG59XG5cbmZ1bmN0aW9uIGV4dGVuZChhLCBiKSB7XG4gICAgYS5taW5YID0gTWF0aC5taW4oYS5taW5YLCBiLm1pblgpO1xuICAgIGEubWluWSA9IE1hdGgubWluKGEubWluWSwgYi5taW5ZKTtcbiAgICBhLm1heFggPSBNYXRoLm1heChhLm1heFgsIGIubWF4WCk7XG4gICAgYS5tYXhZID0gTWF0aC5tYXgoYS5tYXhZLCBiLm1heFkpO1xuICAgIHJldHVybiBhO1xufVxuXG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblgoYSwgYikgeyByZXR1cm4gYS5taW5YIC0gYi5taW5YOyB9XG5mdW5jdGlvbiBjb21wYXJlTm9kZU1pblkoYSwgYikgeyByZXR1cm4gYS5taW5ZIC0gYi5taW5ZOyB9XG5cbmZ1bmN0aW9uIGJib3hBcmVhKGEpICAgeyByZXR1cm4gKGEubWF4WCAtIGEubWluWCkgKiAoYS5tYXhZIC0gYS5taW5ZKTsgfVxuZnVuY3Rpb24gYmJveE1hcmdpbihhKSB7IHJldHVybiAoYS5tYXhYIC0gYS5taW5YKSArIChhLm1heFkgLSBhLm1pblkpOyB9XG5cbmZ1bmN0aW9uIGVubGFyZ2VkQXJlYShhLCBiKSB7XG4gICAgcmV0dXJuIChNYXRoLm1heChiLm1heFgsIGEubWF4WCkgLSBNYXRoLm1pbihiLm1pblgsIGEubWluWCkpICpcbiAgICAgICAgICAgKE1hdGgubWF4KGIubWF4WSwgYS5tYXhZKSAtIE1hdGgubWluKGIubWluWSwgYS5taW5ZKSk7XG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdGlvbkFyZWEoYSwgYikge1xuICAgIHZhciBtaW5YID0gTWF0aC5tYXgoYS5taW5YLCBiLm1pblgpLFxuICAgICAgICBtaW5ZID0gTWF0aC5tYXgoYS5taW5ZLCBiLm1pblkpLFxuICAgICAgICBtYXhYID0gTWF0aC5taW4oYS5tYXhYLCBiLm1heFgpLFxuICAgICAgICBtYXhZID0gTWF0aC5taW4oYS5tYXhZLCBiLm1heFkpO1xuXG4gICAgcmV0dXJuIE1hdGgubWF4KDAsIG1heFggLSBtaW5YKSAqXG4gICAgICAgICAgIE1hdGgubWF4KDAsIG1heFkgLSBtaW5ZKTtcbn1cblxuZnVuY3Rpb24gY29udGFpbnMoYSwgYikge1xuICAgIHJldHVybiBhLm1pblggPD0gYi5taW5YICYmXG4gICAgICAgICAgIGEubWluWSA8PSBiLm1pblkgJiZcbiAgICAgICAgICAgYi5tYXhYIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1heFkgPD0gYS5tYXhZO1xufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RzKGEsIGIpIHtcbiAgICByZXR1cm4gYi5taW5YIDw9IGEubWF4WCAmJlxuICAgICAgICAgICBiLm1pblkgPD0gYS5tYXhZICYmXG4gICAgICAgICAgIGIubWF4WCA+PSBhLm1pblggJiZcbiAgICAgICAgICAgYi5tYXhZID49IGEubWluWTtcbn1cblxuZnVuY3Rpb24gY3JlYXRlTm9kZShjaGlsZHJlbikge1xuICAgIHJldHVybiB7XG4gICAgICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICAgICAgaGVpZ2h0OiAxLFxuICAgICAgICBsZWFmOiB0cnVlLFxuICAgICAgICBtaW5YOiBJbmZpbml0eSxcbiAgICAgICAgbWluWTogSW5maW5pdHksXG4gICAgICAgIG1heFg6IC1JbmZpbml0eSxcbiAgICAgICAgbWF4WTogLUluZmluaXR5XG4gICAgfTtcbn1cblxuLy8gc29ydCBhbiBhcnJheSBzbyB0aGF0IGl0ZW1zIGNvbWUgaW4gZ3JvdXBzIG9mIG4gdW5zb3J0ZWQgaXRlbXMsIHdpdGggZ3JvdXBzIHNvcnRlZCBiZXR3ZWVuIGVhY2ggb3RoZXI7XG4vLyBjb21iaW5lcyBzZWxlY3Rpb24gYWxnb3JpdGhtIHdpdGggYmluYXJ5IGRpdmlkZSAmIGNvbnF1ZXIgYXBwcm9hY2hcblxuZnVuY3Rpb24gbXVsdGlTZWxlY3QoYXJyLCBsZWZ0LCByaWdodCwgbiwgY29tcGFyZSkge1xuICAgIHZhciBzdGFjayA9IFtsZWZ0LCByaWdodF0sXG4gICAgICAgIG1pZDtcblxuICAgIHdoaWxlIChzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgcmlnaHQgPSBzdGFjay5wb3AoKTtcbiAgICAgICAgbGVmdCA9IHN0YWNrLnBvcCgpO1xuXG4gICAgICAgIGlmIChyaWdodCAtIGxlZnQgPD0gbikgY29udGludWU7XG5cbiAgICAgICAgbWlkID0gbGVmdCArIE1hdGguY2VpbCgocmlnaHQgLSBsZWZ0KSAvIG4gLyAyKSAqIG47XG4gICAgICAgIHF1aWNrc2VsZWN0KGFyciwgbWlkLCBsZWZ0LCByaWdodCwgY29tcGFyZSk7XG5cbiAgICAgICAgc3RhY2sucHVzaChsZWZ0LCBtaWQsIG1pZCwgcmlnaHQpO1xuICAgIH1cbn1cbiIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgcm9idXN0U3VtID0gcmVxdWlyZShcInJvYnVzdC1zdW1cIilcbnZhciByb2J1c3RTY2FsZSA9IHJlcXVpcmUoXCJyb2J1c3Qtc2NhbGVcIilcbnZhciByb2J1c3RTdWJ0cmFjdCA9IHJlcXVpcmUoXCJyb2J1c3Qtc3VidHJhY3RcIilcblxudmFyIE5VTV9FWFBBTkQgPSA1XG5cbnZhciBFUFNJTE9OICAgICA9IDEuMTEwMjIzMDI0NjI1MTU2NWUtMTZcbnZhciBFUlJCT1VORDMgICA9ICgzLjAgKyAxNi4wICogRVBTSUxPTikgKiBFUFNJTE9OXG52YXIgRVJSQk9VTkQ0ICAgPSAoNy4wICsgNTYuMCAqIEVQU0lMT04pICogRVBTSUxPTlxuXG5mdW5jdGlvbiBjb2ZhY3RvcihtLCBjKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobS5sZW5ndGgtMSlcbiAgZm9yKHZhciBpPTE7IGk8bS5sZW5ndGg7ICsraSkge1xuICAgIHZhciByID0gcmVzdWx0W2ktMV0gPSBuZXcgQXJyYXkobS5sZW5ndGgtMSlcbiAgICBmb3IodmFyIGo9MCxrPTA7IGo8bS5sZW5ndGg7ICsraikge1xuICAgICAgaWYoaiA9PT0gYykge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgcltrKytdID0gbVtpXVtqXVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIG1hdHJpeChuKSB7XG4gIHZhciByZXN1bHQgPSBuZXcgQXJyYXkobilcbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgcmVzdWx0W2ldID0gbmV3IEFycmF5KG4pXG4gICAgZm9yKHZhciBqPTA7IGo8bjsgKytqKSB7XG4gICAgICByZXN1bHRbaV1bal0gPSBbXCJtXCIsIGosIFwiW1wiLCAobi1pLTEpLCBcIl1cIl0uam9pbihcIlwiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0XG59XG5cbmZ1bmN0aW9uIHNpZ24obikge1xuICBpZihuICYgMSkge1xuICAgIHJldHVybiBcIi1cIlxuICB9XG4gIHJldHVybiBcIlwiXG59XG5cbmZ1bmN0aW9uIGdlbmVyYXRlU3VtKGV4cHIpIHtcbiAgaWYoZXhwci5sZW5ndGggPT09IDEpIHtcbiAgICByZXR1cm4gZXhwclswXVxuICB9IGVsc2UgaWYoZXhwci5sZW5ndGggPT09IDIpIHtcbiAgICByZXR1cm4gW1wic3VtKFwiLCBleHByWzBdLCBcIixcIiwgZXhwclsxXSwgXCIpXCJdLmpvaW4oXCJcIilcbiAgfSBlbHNlIHtcbiAgICB2YXIgbSA9IGV4cHIubGVuZ3RoPj4xXG4gICAgcmV0dXJuIFtcInN1bShcIiwgZ2VuZXJhdGVTdW0oZXhwci5zbGljZSgwLCBtKSksIFwiLFwiLCBnZW5lcmF0ZVN1bShleHByLnNsaWNlKG0pKSwgXCIpXCJdLmpvaW4oXCJcIilcbiAgfVxufVxuXG5mdW5jdGlvbiBkZXRlcm1pbmFudChtKSB7XG4gIGlmKG0ubGVuZ3RoID09PSAyKSB7XG4gICAgcmV0dXJuIFtbXCJzdW0ocHJvZChcIiwgbVswXVswXSwgXCIsXCIsIG1bMV1bMV0sIFwiKSxwcm9kKC1cIiwgbVswXVsxXSwgXCIsXCIsIG1bMV1bMF0sIFwiKSlcIl0uam9pbihcIlwiKV1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZXhwciA9IFtdXG4gICAgZm9yKHZhciBpPTA7IGk8bS5sZW5ndGg7ICsraSkge1xuICAgICAgZXhwci5wdXNoKFtcInNjYWxlKFwiLCBnZW5lcmF0ZVN1bShkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpLCBcIixcIiwgc2lnbihpKSwgbVswXVtpXSwgXCIpXCJdLmpvaW4oXCJcIikpXG4gICAgfVxuICAgIHJldHVybiBleHByXG4gIH1cbn1cblxuZnVuY3Rpb24gb3JpZW50YXRpb24obikge1xuICB2YXIgcG9zID0gW11cbiAgdmFyIG5lZyA9IFtdXG4gIHZhciBtID0gbWF0cml4KG4pXG4gIHZhciBhcmdzID0gW11cbiAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgaWYoKGkmMSk9PT0wKSB7XG4gICAgICBwb3MucHVzaC5hcHBseShwb3MsIGRldGVybWluYW50KGNvZmFjdG9yKG0sIGkpKSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmVnLnB1c2guYXBwbHkobmVnLCBkZXRlcm1pbmFudChjb2ZhY3RvcihtLCBpKSkpXG4gICAgfVxuICAgIGFyZ3MucHVzaChcIm1cIiArIGkpXG4gIH1cbiAgdmFyIHBvc0V4cHIgPSBnZW5lcmF0ZVN1bShwb3MpXG4gIHZhciBuZWdFeHByID0gZ2VuZXJhdGVTdW0obmVnKVxuICB2YXIgZnVuY05hbWUgPSBcIm9yaWVudGF0aW9uXCIgKyBuICsgXCJFeGFjdFwiXG4gIHZhciBjb2RlID0gW1wiZnVuY3Rpb24gXCIsIGZ1bmNOYW1lLCBcIihcIiwgYXJncy5qb2luKCksIFwiKXt2YXIgcD1cIiwgcG9zRXhwciwgXCIsbj1cIiwgbmVnRXhwciwgXCIsZD1zdWIocCxuKTtcXFxucmV0dXJuIGRbZC5sZW5ndGgtMV07fTtyZXR1cm4gXCIsIGZ1bmNOYW1lXS5qb2luKFwiXCIpXG4gIHZhciBwcm9jID0gbmV3IEZ1bmN0aW9uKFwic3VtXCIsIFwicHJvZFwiLCBcInNjYWxlXCIsIFwic3ViXCIsIGNvZGUpXG4gIHJldHVybiBwcm9jKHJvYnVzdFN1bSwgdHdvUHJvZHVjdCwgcm9idXN0U2NhbGUsIHJvYnVzdFN1YnRyYWN0KVxufVxuXG52YXIgb3JpZW50YXRpb24zRXhhY3QgPSBvcmllbnRhdGlvbigzKVxudmFyIG9yaWVudGF0aW9uNEV4YWN0ID0gb3JpZW50YXRpb24oNClcblxudmFyIENBQ0hFRCA9IFtcbiAgZnVuY3Rpb24gb3JpZW50YXRpb24wKCkgeyByZXR1cm4gMCB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjEoKSB7IHJldHVybiAwIH0sXG4gIGZ1bmN0aW9uIG9yaWVudGF0aW9uMihhLCBiKSB7IFxuICAgIHJldHVybiBiWzBdIC0gYVswXVxuICB9LFxuICBmdW5jdGlvbiBvcmllbnRhdGlvbjMoYSwgYiwgYykge1xuICAgIHZhciBsID0gKGFbMV0gLSBjWzFdKSAqIChiWzBdIC0gY1swXSlcbiAgICB2YXIgciA9IChhWzBdIC0gY1swXSkgKiAoYlsxXSAtIGNbMV0pXG4gICAgdmFyIGRldCA9IGwgLSByXG4gICAgdmFyIHNcbiAgICBpZihsID4gMCkge1xuICAgICAgaWYociA8PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSBsICsgclxuICAgICAgfVxuICAgIH0gZWxzZSBpZihsIDwgMCkge1xuICAgICAgaWYociA+PSAwKSB7XG4gICAgICAgIHJldHVybiBkZXRcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHMgPSAtKGwgKyByKVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm4gZGV0XG4gICAgfVxuICAgIHZhciB0b2wgPSBFUlJCT1VORDMgKiBzXG4gICAgaWYoZGV0ID49IHRvbCB8fCBkZXQgPD0gLXRvbCkge1xuICAgICAgcmV0dXJuIGRldFxuICAgIH1cbiAgICByZXR1cm4gb3JpZW50YXRpb24zRXhhY3QoYSwgYiwgYylcbiAgfSxcbiAgZnVuY3Rpb24gb3JpZW50YXRpb240KGEsYixjLGQpIHtcbiAgICB2YXIgYWR4ID0gYVswXSAtIGRbMF1cbiAgICB2YXIgYmR4ID0gYlswXSAtIGRbMF1cbiAgICB2YXIgY2R4ID0gY1swXSAtIGRbMF1cbiAgICB2YXIgYWR5ID0gYVsxXSAtIGRbMV1cbiAgICB2YXIgYmR5ID0gYlsxXSAtIGRbMV1cbiAgICB2YXIgY2R5ID0gY1sxXSAtIGRbMV1cbiAgICB2YXIgYWR6ID0gYVsyXSAtIGRbMl1cbiAgICB2YXIgYmR6ID0gYlsyXSAtIGRbMl1cbiAgICB2YXIgY2R6ID0gY1syXSAtIGRbMl1cbiAgICB2YXIgYmR4Y2R5ID0gYmR4ICogY2R5XG4gICAgdmFyIGNkeGJkeSA9IGNkeCAqIGJkeVxuICAgIHZhciBjZHhhZHkgPSBjZHggKiBhZHlcbiAgICB2YXIgYWR4Y2R5ID0gYWR4ICogY2R5XG4gICAgdmFyIGFkeGJkeSA9IGFkeCAqIGJkeVxuICAgIHZhciBiZHhhZHkgPSBiZHggKiBhZHlcbiAgICB2YXIgZGV0ID0gYWR6ICogKGJkeGNkeSAtIGNkeGJkeSkgXG4gICAgICAgICAgICArIGJkeiAqIChjZHhhZHkgLSBhZHhjZHkpXG4gICAgICAgICAgICArIGNkeiAqIChhZHhiZHkgLSBiZHhhZHkpXG4gICAgdmFyIHBlcm1hbmVudCA9IChNYXRoLmFicyhiZHhjZHkpICsgTWF0aC5hYnMoY2R4YmR5KSkgKiBNYXRoLmFicyhhZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhjZHhhZHkpICsgTWF0aC5hYnMoYWR4Y2R5KSkgKiBNYXRoLmFicyhiZHopXG4gICAgICAgICAgICAgICAgICArIChNYXRoLmFicyhhZHhiZHkpICsgTWF0aC5hYnMoYmR4YWR5KSkgKiBNYXRoLmFicyhjZHopXG4gICAgdmFyIHRvbCA9IEVSUkJPVU5ENCAqIHBlcm1hbmVudFxuICAgIGlmICgoZGV0ID4gdG9sKSB8fCAoLWRldCA+IHRvbCkpIHtcbiAgICAgIHJldHVybiBkZXRcbiAgICB9XG4gICAgcmV0dXJuIG9yaWVudGF0aW9uNEV4YWN0KGEsYixjLGQpXG4gIH1cbl1cblxuZnVuY3Rpb24gc2xvd09yaWVudChhcmdzKSB7XG4gIHZhciBwcm9jID0gQ0FDSEVEW2FyZ3MubGVuZ3RoXVxuICBpZighcHJvYykge1xuICAgIHByb2MgPSBDQUNIRURbYXJncy5sZW5ndGhdID0gb3JpZW50YXRpb24oYXJncy5sZW5ndGgpXG4gIH1cbiAgcmV0dXJuIHByb2MuYXBwbHkodW5kZWZpbmVkLCBhcmdzKVxufVxuXG5mdW5jdGlvbiBnZW5lcmF0ZU9yaWVudGF0aW9uUHJvYygpIHtcbiAgd2hpbGUoQ0FDSEVELmxlbmd0aCA8PSBOVU1fRVhQQU5EKSB7XG4gICAgQ0FDSEVELnB1c2gob3JpZW50YXRpb24oQ0FDSEVELmxlbmd0aCkpXG4gIH1cbiAgdmFyIGFyZ3MgPSBbXVxuICB2YXIgcHJvY0FyZ3MgPSBbXCJzbG93XCJdXG4gIGZvcih2YXIgaT0wOyBpPD1OVU1fRVhQQU5EOyArK2kpIHtcbiAgICBhcmdzLnB1c2goXCJhXCIgKyBpKVxuICAgIHByb2NBcmdzLnB1c2goXCJvXCIgKyBpKVxuICB9XG4gIHZhciBjb2RlID0gW1xuICAgIFwiZnVuY3Rpb24gZ2V0T3JpZW50YXRpb24oXCIsIGFyZ3Muam9pbigpLCBcIil7c3dpdGNoKGFyZ3VtZW50cy5sZW5ndGgpe2Nhc2UgMDpjYXNlIDE6cmV0dXJuIDA7XCJcbiAgXVxuICBmb3IodmFyIGk9MjsgaTw9TlVNX0VYUEFORDsgKytpKSB7XG4gICAgY29kZS5wdXNoKFwiY2FzZSBcIiwgaSwgXCI6cmV0dXJuIG9cIiwgaSwgXCIoXCIsIGFyZ3Muc2xpY2UoMCwgaSkuam9pbigpLCBcIik7XCIpXG4gIH1cbiAgY29kZS5wdXNoKFwifXZhciBzPW5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtmb3IodmFyIGk9MDtpPGFyZ3VtZW50cy5sZW5ndGg7KytpKXtzW2ldPWFyZ3VtZW50c1tpXX07cmV0dXJuIHNsb3cocyk7fXJldHVybiBnZXRPcmllbnRhdGlvblwiKVxuICBwcm9jQXJncy5wdXNoKGNvZGUuam9pbihcIlwiKSlcblxuICB2YXIgcHJvYyA9IEZ1bmN0aW9uLmFwcGx5KHVuZGVmaW5lZCwgcHJvY0FyZ3MpXG4gIG1vZHVsZS5leHBvcnRzID0gcHJvYy5hcHBseSh1bmRlZmluZWQsIFtzbG93T3JpZW50XS5jb25jYXQoQ0FDSEVEKSlcbiAgZm9yKHZhciBpPTA7IGk8PU5VTV9FWFBBTkQ7ICsraSkge1xuICAgIG1vZHVsZS5leHBvcnRzW2ldID0gQ0FDSEVEW2ldXG4gIH1cbn1cblxuZ2VuZXJhdGVPcmllbnRhdGlvblByb2MoKSIsIlwidXNlIHN0cmljdFwiXG5cbnZhciB0d29Qcm9kdWN0ID0gcmVxdWlyZShcInR3by1wcm9kdWN0XCIpXG52YXIgdHdvU3VtID0gcmVxdWlyZShcInR3by1zdW1cIilcblxubW9kdWxlLmV4cG9ydHMgPSBzY2FsZUxpbmVhckV4cGFuc2lvblxuXG5mdW5jdGlvbiBzY2FsZUxpbmVhckV4cGFuc2lvbihlLCBzY2FsZSkge1xuICB2YXIgbiA9IGUubGVuZ3RoXG4gIGlmKG4gPT09IDEpIHtcbiAgICB2YXIgdHMgPSB0d29Qcm9kdWN0KGVbMF0sIHNjYWxlKVxuICAgIGlmKHRzWzBdKSB7XG4gICAgICByZXR1cm4gdHNcbiAgICB9XG4gICAgcmV0dXJuIFsgdHNbMV0gXVxuICB9XG4gIHZhciBnID0gbmV3IEFycmF5KDIgKiBuKVxuICB2YXIgcSA9IFswLjEsIDAuMV1cbiAgdmFyIHQgPSBbMC4xLCAwLjFdXG4gIHZhciBjb3VudCA9IDBcbiAgdHdvUHJvZHVjdChlWzBdLCBzY2FsZSwgcSlcbiAgaWYocVswXSkge1xuICAgIGdbY291bnQrK10gPSBxWzBdXG4gIH1cbiAgZm9yKHZhciBpPTE7IGk8bjsgKytpKSB7XG4gICAgdHdvUHJvZHVjdChlW2ldLCBzY2FsZSwgdClcbiAgICB2YXIgcHEgPSBxWzFdXG4gICAgdHdvU3VtKHBxLCB0WzBdLCBxKVxuICAgIGlmKHFbMF0pIHtcbiAgICAgIGdbY291bnQrK10gPSBxWzBdXG4gICAgfVxuICAgIHZhciBhID0gdFsxXVxuICAgIHZhciBiID0gcVsxXVxuICAgIHZhciB4ID0gYSArIGJcbiAgICB2YXIgYnYgPSB4IC0gYVxuICAgIHZhciB5ID0gYiAtIGJ2XG4gICAgcVsxXSA9IHhcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgfVxuICBpZihxWzFdKSB7XG4gICAgZ1tjb3VudCsrXSA9IHFbMV1cbiAgfVxuICBpZihjb3VudCA9PT0gMCkge1xuICAgIGdbY291bnQrK10gPSAwLjBcbiAgfVxuICBnLmxlbmd0aCA9IGNvdW50XG4gIHJldHVybiBnXG59IiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSByb2J1c3RTdWJ0cmFjdFxuXG4vL0Vhc3kgY2FzZTogQWRkIHR3byBzY2FsYXJzXG5mdW5jdGlvbiBzY2FsYXJTY2FsYXIoYSwgYikge1xuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciBhdiA9IHggLSBidlxuICB2YXIgYnIgPSBiIC0gYnZcbiAgdmFyIGFyID0gYSAtIGF2XG4gIHZhciB5ID0gYXIgKyBiclxuICBpZih5KSB7XG4gICAgcmV0dXJuIFt5LCB4XVxuICB9XG4gIHJldHVybiBbeF1cbn1cblxuZnVuY3Rpb24gcm9idXN0U3VidHJhY3QoZSwgZikge1xuICB2YXIgbmUgPSBlLmxlbmd0aHwwXG4gIHZhciBuZiA9IGYubGVuZ3RofDBcbiAgaWYobmUgPT09IDEgJiYgbmYgPT09IDEpIHtcbiAgICByZXR1cm4gc2NhbGFyU2NhbGFyKGVbMF0sIC1mWzBdKVxuICB9XG4gIHZhciBuID0gbmUgKyBuZlxuICB2YXIgZyA9IG5ldyBBcnJheShuKVxuICB2YXIgY291bnQgPSAwXG4gIHZhciBlcHRyID0gMFxuICB2YXIgZnB0ciA9IDBcbiAgdmFyIGFicyA9IE1hdGguYWJzXG4gIHZhciBlaSA9IGVbZXB0cl1cbiAgdmFyIGVhID0gYWJzKGVpKVxuICB2YXIgZmkgPSAtZltmcHRyXVxuICB2YXIgZmEgPSBhYnMoZmkpXG4gIHZhciBhLCBiXG4gIGlmKGVhIDwgZmEpIHtcbiAgICBiID0gZWlcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgZWEgPSBhYnMoZWkpXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGIgPSBmaVxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSAtZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIGlmKChlcHRyIDwgbmUgJiYgZWEgPCBmYSkgfHwgKGZwdHIgPj0gbmYpKSB7XG4gICAgYSA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gLWZbZnB0cl1cbiAgICAgIGZhID0gYWJzKGZpKVxuICAgIH1cbiAgfVxuICB2YXIgeCA9IGEgKyBiXG4gIHZhciBidiA9IHggLSBhXG4gIHZhciB5ID0gYiAtIGJ2XG4gIHZhciBxMCA9IHlcbiAgdmFyIHExID0geFxuICB2YXIgX3gsIF9idiwgX2F2LCBfYnIsIF9hclxuICB3aGlsZShlcHRyIDwgbmUgJiYgZnB0ciA8IG5mKSB7XG4gICAgaWYoZWEgPCBmYSkge1xuICAgICAgYSA9IGVpXG4gICAgICBlcHRyICs9IDFcbiAgICAgIGlmKGVwdHIgPCBuZSkge1xuICAgICAgICBlaSA9IGVbZXB0cl1cbiAgICAgICAgZWEgPSBhYnMoZWkpXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGEgPSBmaVxuICAgICAgZnB0ciArPSAxXG4gICAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgICAgZmkgPSAtZltmcHRyXVxuICAgICAgICBmYSA9IGFicyhmaSlcbiAgICAgIH1cbiAgICB9XG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH1cbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICB9XG4gIHdoaWxlKGVwdHIgPCBuZSkge1xuICAgIGEgPSBlaVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBlcHRyICs9IDFcbiAgICBpZihlcHRyIDwgbmUpIHtcbiAgICAgIGVpID0gZVtlcHRyXVxuICAgIH1cbiAgfVxuICB3aGlsZShmcHRyIDwgbmYpIHtcbiAgICBhID0gZmlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfSBcbiAgICBfeCA9IHExICsgeFxuICAgIF9idiA9IF94IC0gcTFcbiAgICBfYXYgPSBfeCAtIF9idlxuICAgIF9iciA9IHggLSBfYnZcbiAgICBfYXIgPSBxMSAtIF9hdlxuICAgIHEwID0gX2FyICsgX2JyXG4gICAgcTEgPSBfeFxuICAgIGZwdHIgKz0gMVxuICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgZmkgPSAtZltmcHRyXVxuICAgIH1cbiAgfVxuICBpZihxMCkge1xuICAgIGdbY291bnQrK10gPSBxMFxuICB9XG4gIGlmKHExKSB7XG4gICAgZ1tjb3VudCsrXSA9IHExXG4gIH1cbiAgaWYoIWNvdW50KSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMCAgXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiXG5cbm1vZHVsZS5leHBvcnRzID0gbGluZWFyRXhwYW5zaW9uU3VtXG5cbi8vRWFzeSBjYXNlOiBBZGQgdHdvIHNjYWxhcnNcbmZ1bmN0aW9uIHNjYWxhclNjYWxhcihhLCBiKSB7XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIGF2ID0geCAtIGJ2XG4gIHZhciBiciA9IGIgLSBidlxuICB2YXIgYXIgPSBhIC0gYXZcbiAgdmFyIHkgPSBhciArIGJyXG4gIGlmKHkpIHtcbiAgICByZXR1cm4gW3ksIHhdXG4gIH1cbiAgcmV0dXJuIFt4XVxufVxuXG5mdW5jdGlvbiBsaW5lYXJFeHBhbnNpb25TdW0oZSwgZikge1xuICB2YXIgbmUgPSBlLmxlbmd0aHwwXG4gIHZhciBuZiA9IGYubGVuZ3RofDBcbiAgaWYobmUgPT09IDEgJiYgbmYgPT09IDEpIHtcbiAgICByZXR1cm4gc2NhbGFyU2NhbGFyKGVbMF0sIGZbMF0pXG4gIH1cbiAgdmFyIG4gPSBuZSArIG5mXG4gIHZhciBnID0gbmV3IEFycmF5KG4pXG4gIHZhciBjb3VudCA9IDBcbiAgdmFyIGVwdHIgPSAwXG4gIHZhciBmcHRyID0gMFxuICB2YXIgYWJzID0gTWF0aC5hYnNcbiAgdmFyIGVpID0gZVtlcHRyXVxuICB2YXIgZWEgPSBhYnMoZWkpXG4gIHZhciBmaSA9IGZbZnB0cl1cbiAgdmFyIGZhID0gYWJzKGZpKVxuICB2YXIgYSwgYlxuICBpZihlYSA8IGZhKSB7XG4gICAgYiA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBiID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIGlmKChlcHRyIDwgbmUgJiYgZWEgPCBmYSkgfHwgKGZwdHIgPj0gbmYpKSB7XG4gICAgYSA9IGVpXG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICAgIGVhID0gYWJzKGVpKVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBhID0gZmlcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgICAgZmEgPSBhYnMoZmkpXG4gICAgfVxuICB9XG4gIHZhciB4ID0gYSArIGJcbiAgdmFyIGJ2ID0geCAtIGFcbiAgdmFyIHkgPSBiIC0gYnZcbiAgdmFyIHEwID0geVxuICB2YXIgcTEgPSB4XG4gIHZhciBfeCwgX2J2LCBfYXYsIF9iciwgX2FyXG4gIHdoaWxlKGVwdHIgPCBuZSAmJiBmcHRyIDwgbmYpIHtcbiAgICBpZihlYSA8IGZhKSB7XG4gICAgICBhID0gZWlcbiAgICAgIGVwdHIgKz0gMVxuICAgICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICAgIGVpID0gZVtlcHRyXVxuICAgICAgICBlYSA9IGFicyhlaSlcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgYSA9IGZpXG4gICAgICBmcHRyICs9IDFcbiAgICAgIGlmKGZwdHIgPCBuZikge1xuICAgICAgICBmaSA9IGZbZnB0cl1cbiAgICAgICAgZmEgPSBhYnMoZmkpXG4gICAgICB9XG4gICAgfVxuICAgIGIgPSBxMFxuICAgIHggPSBhICsgYlxuICAgIGJ2ID0geCAtIGFcbiAgICB5ID0gYiAtIGJ2XG4gICAgaWYoeSkge1xuICAgICAgZ1tjb3VudCsrXSA9IHlcbiAgICB9XG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgfVxuICB3aGlsZShlcHRyIDwgbmUpIHtcbiAgICBhID0gZWlcbiAgICBiID0gcTBcbiAgICB4ID0gYSArIGJcbiAgICBidiA9IHggLSBhXG4gICAgeSA9IGIgLSBidlxuICAgIGlmKHkpIHtcbiAgICAgIGdbY291bnQrK10gPSB5XG4gICAgfVxuICAgIF94ID0gcTEgKyB4XG4gICAgX2J2ID0gX3ggLSBxMVxuICAgIF9hdiA9IF94IC0gX2J2XG4gICAgX2JyID0geCAtIF9idlxuICAgIF9hciA9IHExIC0gX2F2XG4gICAgcTAgPSBfYXIgKyBfYnJcbiAgICBxMSA9IF94XG4gICAgZXB0ciArPSAxXG4gICAgaWYoZXB0ciA8IG5lKSB7XG4gICAgICBlaSA9IGVbZXB0cl1cbiAgICB9XG4gIH1cbiAgd2hpbGUoZnB0ciA8IG5mKSB7XG4gICAgYSA9IGZpXG4gICAgYiA9IHEwXG4gICAgeCA9IGEgKyBiXG4gICAgYnYgPSB4IC0gYVxuICAgIHkgPSBiIC0gYnZcbiAgICBpZih5KSB7XG4gICAgICBnW2NvdW50KytdID0geVxuICAgIH0gXG4gICAgX3ggPSBxMSArIHhcbiAgICBfYnYgPSBfeCAtIHExXG4gICAgX2F2ID0gX3ggLSBfYnZcbiAgICBfYnIgPSB4IC0gX2J2XG4gICAgX2FyID0gcTEgLSBfYXZcbiAgICBxMCA9IF9hciArIF9iclxuICAgIHExID0gX3hcbiAgICBmcHRyICs9IDFcbiAgICBpZihmcHRyIDwgbmYpIHtcbiAgICAgIGZpID0gZltmcHRyXVxuICAgIH1cbiAgfVxuICBpZihxMCkge1xuICAgIGdbY291bnQrK10gPSBxMFxuICB9XG4gIGlmKHExKSB7XG4gICAgZ1tjb3VudCsrXSA9IHExXG4gIH1cbiAgaWYoIWNvdW50KSB7XG4gICAgZ1tjb3VudCsrXSA9IDAuMCAgXG4gIH1cbiAgZy5sZW5ndGggPSBjb3VudFxuICByZXR1cm4gZ1xufSIsIlwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG52YXIgYml0cyAgICAgID0gcmVxdWlyZShcImJpdC10d2lkZGxlXCIpXG4gICwgVW5pb25GaW5kID0gcmVxdWlyZShcInVuaW9uLWZpbmRcIilcblxuLy9SZXR1cm5zIHRoZSBkaW1lbnNpb24gb2YgYSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIGRpbWVuc2lvbihjZWxscykge1xuICB2YXIgZCA9IDBcbiAgICAsIG1heCA9IE1hdGgubWF4XG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIGQgPSBtYXgoZCwgY2VsbHNbaV0ubGVuZ3RoKVxuICB9XG4gIHJldHVybiBkLTFcbn1cbmV4cG9ydHMuZGltZW5zaW9uID0gZGltZW5zaW9uXG5cbi8vQ291bnRzIHRoZSBudW1iZXIgb2YgdmVydGljZXMgaW4gZmFjZXNcbmZ1bmN0aW9uIGNvdW50VmVydGljZXMoY2VsbHMpIHtcbiAgdmFyIHZjID0gLTFcbiAgICAsIG1heCA9IE1hdGgubWF4XG4gIGZvcih2YXIgaT0wLCBpbD1jZWxscy5sZW5ndGg7IGk8aWw7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MCwgamw9Yy5sZW5ndGg7IGo8amw7ICsraikge1xuICAgICAgdmMgPSBtYXgodmMsIGNbal0pXG4gICAgfVxuICB9XG4gIHJldHVybiB2YysxXG59XG5leHBvcnRzLmNvdW50VmVydGljZXMgPSBjb3VudFZlcnRpY2VzXG5cbi8vUmV0dXJucyBhIGRlZXAgY29weSBvZiBjZWxsc1xuZnVuY3Rpb24gY2xvbmVDZWxscyhjZWxscykge1xuICB2YXIgbmNlbGxzID0gbmV3IEFycmF5KGNlbGxzLmxlbmd0aClcbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgbmNlbGxzW2ldID0gY2VsbHNbaV0uc2xpY2UoMClcbiAgfVxuICByZXR1cm4gbmNlbGxzXG59XG5leHBvcnRzLmNsb25lQ2VsbHMgPSBjbG9uZUNlbGxzXG5cbi8vUmFua3MgYSBwYWlyIG9mIGNlbGxzIHVwIHRvIHBlcm11dGF0aW9uXG5mdW5jdGlvbiBjb21wYXJlQ2VsbHMoYSwgYikge1xuICB2YXIgbiA9IGEubGVuZ3RoXG4gICAgLCB0ID0gYS5sZW5ndGggLSBiLmxlbmd0aFxuICAgICwgbWluID0gTWF0aC5taW5cbiAgaWYodCkge1xuICAgIHJldHVybiB0XG4gIH1cbiAgc3dpdGNoKG4pIHtcbiAgICBjYXNlIDA6XG4gICAgICByZXR1cm4gMDtcbiAgICBjYXNlIDE6XG4gICAgICByZXR1cm4gYVswXSAtIGJbMF07XG4gICAgY2FzZSAyOlxuICAgICAgdmFyIGQgPSBhWzBdK2FbMV0tYlswXS1iWzFdXG4gICAgICBpZihkKSB7XG4gICAgICAgIHJldHVybiBkXG4gICAgICB9XG4gICAgICByZXR1cm4gbWluKGFbMF0sYVsxXSkgLSBtaW4oYlswXSxiWzFdKVxuICAgIGNhc2UgMzpcbiAgICAgIHZhciBsMSA9IGFbMF0rYVsxXVxuICAgICAgICAsIG0xID0gYlswXStiWzFdXG4gICAgICBkID0gbDErYVsyXSAtIChtMStiWzJdKVxuICAgICAgaWYoZCkge1xuICAgICAgICByZXR1cm4gZFxuICAgICAgfVxuICAgICAgdmFyIGwwID0gbWluKGFbMF0sIGFbMV0pXG4gICAgICAgICwgbTAgPSBtaW4oYlswXSwgYlsxXSlcbiAgICAgICAgLCBkICA9IG1pbihsMCwgYVsyXSkgLSBtaW4obTAsIGJbMl0pXG4gICAgICBpZihkKSB7XG4gICAgICAgIHJldHVybiBkXG4gICAgICB9XG4gICAgICByZXR1cm4gbWluKGwwK2FbMl0sIGwxKSAtIG1pbihtMCtiWzJdLCBtMSlcbiAgICBcbiAgICAvL1RPRE86IE1heWJlIG9wdGltaXplIG49NCBhcyB3ZWxsP1xuICAgIFxuICAgIGRlZmF1bHQ6XG4gICAgICB2YXIgYXMgPSBhLnNsaWNlKDApXG4gICAgICBhcy5zb3J0KClcbiAgICAgIHZhciBicyA9IGIuc2xpY2UoMClcbiAgICAgIGJzLnNvcnQoKVxuICAgICAgZm9yKHZhciBpPTA7IGk8bjsgKytpKSB7XG4gICAgICAgIHQgPSBhc1tpXSAtIGJzW2ldXG4gICAgICAgIGlmKHQpIHtcbiAgICAgICAgICByZXR1cm4gdFxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gMFxuICB9XG59XG5leHBvcnRzLmNvbXBhcmVDZWxscyA9IGNvbXBhcmVDZWxsc1xuXG5mdW5jdGlvbiBjb21wYXJlWmlwcGVkKGEsIGIpIHtcbiAgcmV0dXJuIGNvbXBhcmVDZWxscyhhWzBdLCBiWzBdKVxufVxuXG4vL1B1dHMgYSBjZWxsIGNvbXBsZXggaW50byBub3JtYWwgb3JkZXIgZm9yIHRoZSBwdXJwb3NlcyBvZiBmaW5kQ2VsbCBxdWVyaWVzXG5mdW5jdGlvbiBub3JtYWxpemUoY2VsbHMsIGF0dHIpIHtcbiAgaWYoYXR0cikge1xuICAgIHZhciBsZW4gPSBjZWxscy5sZW5ndGhcbiAgICB2YXIgemlwcGVkID0gbmV3IEFycmF5KGxlbilcbiAgICBmb3IodmFyIGk9MDsgaTxsZW47ICsraSkge1xuICAgICAgemlwcGVkW2ldID0gW2NlbGxzW2ldLCBhdHRyW2ldXVxuICAgIH1cbiAgICB6aXBwZWQuc29ydChjb21wYXJlWmlwcGVkKVxuICAgIGZvcih2YXIgaT0wOyBpPGxlbjsgKytpKSB7XG4gICAgICBjZWxsc1tpXSA9IHppcHBlZFtpXVswXVxuICAgICAgYXR0cltpXSA9IHppcHBlZFtpXVsxXVxuICAgIH1cbiAgICByZXR1cm4gY2VsbHNcbiAgfSBlbHNlIHtcbiAgICBjZWxscy5zb3J0KGNvbXBhcmVDZWxscylcbiAgICByZXR1cm4gY2VsbHNcbiAgfVxufVxuZXhwb3J0cy5ub3JtYWxpemUgPSBub3JtYWxpemVcblxuLy9SZW1vdmVzIGFsbCBkdXBsaWNhdGUgY2VsbHMgaW4gdGhlIGNvbXBsZXhcbmZ1bmN0aW9uIHVuaXF1ZShjZWxscykge1xuICBpZihjZWxscy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gW11cbiAgfVxuICB2YXIgcHRyID0gMVxuICAgICwgbGVuID0gY2VsbHMubGVuZ3RoXG4gIGZvcih2YXIgaT0xOyBpPGxlbjsgKytpKSB7XG4gICAgdmFyIGEgPSBjZWxsc1tpXVxuICAgIGlmKGNvbXBhcmVDZWxscyhhLCBjZWxsc1tpLTFdKSkge1xuICAgICAgaWYoaSA9PT0gcHRyKSB7XG4gICAgICAgIHB0cisrXG4gICAgICAgIGNvbnRpbnVlXG4gICAgICB9XG4gICAgICBjZWxsc1twdHIrK10gPSBhXG4gICAgfVxuICB9XG4gIGNlbGxzLmxlbmd0aCA9IHB0clxuICByZXR1cm4gY2VsbHNcbn1cbmV4cG9ydHMudW5pcXVlID0gdW5pcXVlO1xuXG4vL0ZpbmRzIGEgY2VsbCBpbiBhIG5vcm1hbGl6ZWQgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBmaW5kQ2VsbChjZWxscywgYykge1xuICB2YXIgbG8gPSAwXG4gICAgLCBoaSA9IGNlbGxzLmxlbmd0aC0xXG4gICAgLCByICA9IC0xXG4gIHdoaWxlIChsbyA8PSBoaSkge1xuICAgIHZhciBtaWQgPSAobG8gKyBoaSkgPj4gMVxuICAgICAgLCBzICAgPSBjb21wYXJlQ2VsbHMoY2VsbHNbbWlkXSwgYylcbiAgICBpZihzIDw9IDApIHtcbiAgICAgIGlmKHMgPT09IDApIHtcbiAgICAgICAgciA9IG1pZFxuICAgICAgfVxuICAgICAgbG8gPSBtaWQgKyAxXG4gICAgfSBlbHNlIGlmKHMgPiAwKSB7XG4gICAgICBoaSA9IG1pZCAtIDFcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJcbn1cbmV4cG9ydHMuZmluZENlbGwgPSBmaW5kQ2VsbDtcblxuLy9CdWlsZHMgYW4gaW5kZXggZm9yIGFuIG4tY2VsbC4gIFRoaXMgaXMgbW9yZSBnZW5lcmFsIHRoYW4gZHVhbCwgYnV0IGxlc3MgZWZmaWNpZW50XG5mdW5jdGlvbiBpbmNpZGVuY2UoZnJvbV9jZWxscywgdG9fY2VsbHMpIHtcbiAgdmFyIGluZGV4ID0gbmV3IEFycmF5KGZyb21fY2VsbHMubGVuZ3RoKVxuICBmb3IodmFyIGk9MCwgaWw9aW5kZXgubGVuZ3RoOyBpPGlsOyArK2kpIHtcbiAgICBpbmRleFtpXSA9IFtdXG4gIH1cbiAgdmFyIGIgPSBbXVxuICBmb3IodmFyIGk9MCwgbj10b19jZWxscy5sZW5ndGg7IGk8bjsgKytpKSB7XG4gICAgdmFyIGMgPSB0b19jZWxsc1tpXVxuICAgIHZhciBjbCA9IGMubGVuZ3RoXG4gICAgZm9yKHZhciBrPTEsIGtuPSgxPDxjbCk7IGs8a247ICsraykge1xuICAgICAgYi5sZW5ndGggPSBiaXRzLnBvcENvdW50KGspXG4gICAgICB2YXIgbCA9IDBcbiAgICAgIGZvcih2YXIgaj0wOyBqPGNsOyArK2opIHtcbiAgICAgICAgaWYoayAmICgxPDxqKSkge1xuICAgICAgICAgIGJbbCsrXSA9IGNbal1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdmFyIGlkeD1maW5kQ2VsbChmcm9tX2NlbGxzLCBiKVxuICAgICAgaWYoaWR4IDwgMCkge1xuICAgICAgICBjb250aW51ZVxuICAgICAgfVxuICAgICAgd2hpbGUodHJ1ZSkge1xuICAgICAgICBpbmRleFtpZHgrK10ucHVzaChpKVxuICAgICAgICBpZihpZHggPj0gZnJvbV9jZWxscy5sZW5ndGggfHwgY29tcGFyZUNlbGxzKGZyb21fY2VsbHNbaWR4XSwgYikgIT09IDApIHtcbiAgICAgICAgICBicmVha1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBpbmRleFxufVxuZXhwb3J0cy5pbmNpZGVuY2UgPSBpbmNpZGVuY2VcblxuLy9Db21wdXRlcyB0aGUgZHVhbCBvZiB0aGUgbWVzaC4gIFRoaXMgaXMgYmFzaWNhbGx5IGFuIG9wdGltaXplZCB2ZXJzaW9uIG9mIGJ1aWxkSW5kZXggZm9yIHRoZSBzaXR1YXRpb24gd2hlcmUgZnJvbV9jZWxscyBpcyBqdXN0IHRoZSBsaXN0IG9mIHZlcnRpY2VzXG5mdW5jdGlvbiBkdWFsKGNlbGxzLCB2ZXJ0ZXhfY291bnQpIHtcbiAgaWYoIXZlcnRleF9jb3VudCkge1xuICAgIHJldHVybiBpbmNpZGVuY2UodW5pcXVlKHNrZWxldG9uKGNlbGxzLCAwKSksIGNlbGxzLCAwKVxuICB9XG4gIHZhciByZXMgPSBuZXcgQXJyYXkodmVydGV4X2NvdW50KVxuICBmb3IodmFyIGk9MDsgaTx2ZXJ0ZXhfY291bnQ7ICsraSkge1xuICAgIHJlc1tpXSA9IFtdXG4gIH1cbiAgZm9yKHZhciBpPTAsIGxlbj1jZWxscy5sZW5ndGg7IGk8bGVuOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBqPTAsIGNsPWMubGVuZ3RoOyBqPGNsOyArK2opIHtcbiAgICAgIHJlc1tjW2pdXS5wdXNoKGkpXG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cbmV4cG9ydHMuZHVhbCA9IGR1YWxcblxuLy9FbnVtZXJhdGVzIGFsbCBjZWxscyBpbiB0aGUgY29tcGxleFxuZnVuY3Rpb24gZXhwbG9kZShjZWxscykge1xuICB2YXIgcmVzdWx0ID0gW11cbiAgZm9yKHZhciBpPTAsIGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgICAgLCBjbCA9IGMubGVuZ3RofDBcbiAgICBmb3IodmFyIGo9MSwgamw9KDE8PGNsKTsgajxqbDsgKytqKSB7XG4gICAgICB2YXIgYiA9IFtdXG4gICAgICBmb3IodmFyIGs9MDsgazxjbDsgKytrKSB7XG4gICAgICAgIGlmKChqID4+PiBrKSAmIDEpIHtcbiAgICAgICAgICBiLnB1c2goY1trXSlcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzdWx0LnB1c2goYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShyZXN1bHQpXG59XG5leHBvcnRzLmV4cGxvZGUgPSBleHBsb2RlXG5cbi8vRW51bWVyYXRlcyBhbGwgb2YgdGhlIG4tY2VsbHMgb2YgYSBjZWxsIGNvbXBsZXhcbmZ1bmN0aW9uIHNrZWxldG9uKGNlbGxzLCBuKSB7XG4gIGlmKG4gPCAwKSB7XG4gICAgcmV0dXJuIFtdXG4gIH1cbiAgdmFyIHJlc3VsdCA9IFtdXG4gICAgLCBrMCAgICAgPSAoMTw8KG4rMSkpLTFcbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgYyA9IGNlbGxzW2ldXG4gICAgZm9yKHZhciBrPWswOyBrPCgxPDxjLmxlbmd0aCk7IGs9Yml0cy5uZXh0Q29tYmluYXRpb24oaykpIHtcbiAgICAgIHZhciBiID0gbmV3IEFycmF5KG4rMSlcbiAgICAgICAgLCBsID0gMFxuICAgICAgZm9yKHZhciBqPTA7IGo8Yy5sZW5ndGg7ICsraikge1xuICAgICAgICBpZihrICYgKDE8PGopKSB7XG4gICAgICAgICAgYltsKytdID0gY1tqXVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXN1bHQucHVzaChiKVxuICAgIH1cbiAgfVxuICByZXR1cm4gbm9ybWFsaXplKHJlc3VsdClcbn1cbmV4cG9ydHMuc2tlbGV0b24gPSBza2VsZXRvbjtcblxuLy9Db21wdXRlcyB0aGUgYm91bmRhcnkgb2YgYWxsIGNlbGxzLCBkb2VzIG5vdCByZW1vdmUgZHVwbGljYXRlc1xuZnVuY3Rpb24gYm91bmRhcnkoY2VsbHMpIHtcbiAgdmFyIHJlcyA9IFtdXG4gIGZvcih2YXIgaT0wLGlsPWNlbGxzLmxlbmd0aDsgaTxpbDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wLGNsPWMubGVuZ3RoOyBqPGNsOyArK2opIHtcbiAgICAgIHZhciBiID0gbmV3IEFycmF5KGMubGVuZ3RoLTEpXG4gICAgICBmb3IodmFyIGs9MCwgbD0wOyBrPGNsOyArK2spIHtcbiAgICAgICAgaWYoayAhPT0gaikge1xuICAgICAgICAgIGJbbCsrXSA9IGNba11cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmVzLnB1c2goYilcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG5vcm1hbGl6ZShyZXMpXG59XG5leHBvcnRzLmJvdW5kYXJ5ID0gYm91bmRhcnk7XG5cbi8vQ29tcHV0ZXMgY29ubmVjdGVkIGNvbXBvbmVudHMgZm9yIGEgZGVuc2UgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBjb25uZWN0ZWRDb21wb25lbnRzX2RlbnNlKGNlbGxzLCB2ZXJ0ZXhfY291bnQpIHtcbiAgdmFyIGxhYmVscyA9IG5ldyBVbmlvbkZpbmQodmVydGV4X2NvdW50KVxuICBmb3IodmFyIGk9MDsgaTxjZWxscy5sZW5ndGg7ICsraSkge1xuICAgIHZhciBjID0gY2VsbHNbaV1cbiAgICBmb3IodmFyIGo9MDsgajxjLmxlbmd0aDsgKytqKSB7XG4gICAgICBmb3IodmFyIGs9aisxOyBrPGMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgbGFiZWxzLmxpbmsoY1tqXSwgY1trXSlcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdmFyIGNvbXBvbmVudHMgPSBbXVxuICAgICwgY29tcG9uZW50X2xhYmVscyA9IGxhYmVscy5yYW5rc1xuICBmb3IodmFyIGk9MDsgaTxjb21wb25lbnRfbGFiZWxzLmxlbmd0aDsgKytpKSB7XG4gICAgY29tcG9uZW50X2xhYmVsc1tpXSA9IC0xXG4gIH1cbiAgZm9yKHZhciBpPTA7IGk8Y2VsbHMubGVuZ3RoOyArK2kpIHtcbiAgICB2YXIgbCA9IGxhYmVscy5maW5kKGNlbGxzW2ldWzBdKVxuICAgIGlmKGNvbXBvbmVudF9sYWJlbHNbbF0gPCAwKSB7XG4gICAgICBjb21wb25lbnRfbGFiZWxzW2xdID0gY29tcG9uZW50cy5sZW5ndGhcbiAgICAgIGNvbXBvbmVudHMucHVzaChbY2VsbHNbaV0uc2xpY2UoMCldKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudF9sYWJlbHNbbF1dLnB1c2goY2VsbHNbaV0uc2xpY2UoMCkpXG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbi8vQ29tcHV0ZXMgY29ubmVjdGVkIGNvbXBvbmVudHMgZm9yIGEgc3BhcnNlIGdyYXBoXG5mdW5jdGlvbiBjb25uZWN0ZWRDb21wb25lbnRzX3NwYXJzZShjZWxscykge1xuICB2YXIgdmVydGljZXMgID0gdW5pcXVlKG5vcm1hbGl6ZShza2VsZXRvbihjZWxscywgMCkpKVxuICAgICwgbGFiZWxzICAgID0gbmV3IFVuaW9uRmluZCh2ZXJ0aWNlcy5sZW5ndGgpXG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGMgPSBjZWxsc1tpXVxuICAgIGZvcih2YXIgaj0wOyBqPGMubGVuZ3RoOyArK2opIHtcbiAgICAgIHZhciB2aiA9IGZpbmRDZWxsKHZlcnRpY2VzLCBbY1tqXV0pXG4gICAgICBmb3IodmFyIGs9aisxOyBrPGMubGVuZ3RoOyArK2spIHtcbiAgICAgICAgbGFiZWxzLmxpbmsodmosIGZpbmRDZWxsKHZlcnRpY2VzLCBbY1trXV0pKVxuICAgICAgfVxuICAgIH1cbiAgfVxuICB2YXIgY29tcG9uZW50cyAgICAgICAgPSBbXVxuICAgICwgY29tcG9uZW50X2xhYmVscyAgPSBsYWJlbHMucmFua3NcbiAgZm9yKHZhciBpPTA7IGk8Y29tcG9uZW50X2xhYmVscy5sZW5ndGg7ICsraSkge1xuICAgIGNvbXBvbmVudF9sYWJlbHNbaV0gPSAtMVxuICB9XG4gIGZvcih2YXIgaT0wOyBpPGNlbGxzLmxlbmd0aDsgKytpKSB7XG4gICAgdmFyIGwgPSBsYWJlbHMuZmluZChmaW5kQ2VsbCh2ZXJ0aWNlcywgW2NlbGxzW2ldWzBdXSkpO1xuICAgIGlmKGNvbXBvbmVudF9sYWJlbHNbbF0gPCAwKSB7XG4gICAgICBjb21wb25lbnRfbGFiZWxzW2xdID0gY29tcG9uZW50cy5sZW5ndGhcbiAgICAgIGNvbXBvbmVudHMucHVzaChbY2VsbHNbaV0uc2xpY2UoMCldKVxuICAgIH0gZWxzZSB7XG4gICAgICBjb21wb25lbnRzW2NvbXBvbmVudF9sYWJlbHNbbF1dLnB1c2goY2VsbHNbaV0uc2xpY2UoMCkpXG4gICAgfVxuICB9XG4gIHJldHVybiBjb21wb25lbnRzXG59XG5cbi8vQ29tcHV0ZXMgY29ubmVjdGVkIGNvbXBvbmVudHMgZm9yIGEgY2VsbCBjb21wbGV4XG5mdW5jdGlvbiBjb25uZWN0ZWRDb21wb25lbnRzKGNlbGxzLCB2ZXJ0ZXhfY291bnQpIHtcbiAgaWYodmVydGV4X2NvdW50KSB7XG4gICAgcmV0dXJuIGNvbm5lY3RlZENvbXBvbmVudHNfZGVuc2UoY2VsbHMsIHZlcnRleF9jb3VudClcbiAgfVxuICByZXR1cm4gY29ubmVjdGVkQ29tcG9uZW50c19zcGFyc2UoY2VsbHMpXG59XG5leHBvcnRzLmNvbm5lY3RlZENvbXBvbmVudHMgPSBjb25uZWN0ZWRDb21wb25lbnRzXG4iLCIvKlxuIChjKSAyMDE3LCBWbGFkaW1pciBBZ2Fmb25raW5cbiBTaW1wbGlmeS5qcywgYSBoaWdoLXBlcmZvcm1hbmNlIEpTIHBvbHlsaW5lIHNpbXBsaWZpY2F0aW9uIGxpYnJhcnlcbiBtb3VybmVyLmdpdGh1Yi5pby9zaW1wbGlmeS1qc1xuKi9cblxuKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xuXG4vLyB0byBzdWl0IHlvdXIgcG9pbnQgZm9ybWF0LCBydW4gc2VhcmNoL3JlcGxhY2UgZm9yICcueCcgYW5kICcueSc7XG4vLyBmb3IgM0QgdmVyc2lvbiwgc2VlIDNkIGJyYW5jaCAoY29uZmlndXJhYmlsaXR5IHdvdWxkIGRyYXcgc2lnbmlmaWNhbnQgcGVyZm9ybWFuY2Ugb3ZlcmhlYWQpXG5cbi8vIHNxdWFyZSBkaXN0YW5jZSBiZXR3ZWVuIDIgcG9pbnRzXG5mdW5jdGlvbiBnZXRTcURpc3QocDEsIHAyKSB7XG5cbiAgICB2YXIgZHggPSBwMS54IC0gcDIueCxcbiAgICAgICAgZHkgPSBwMS55IC0gcDIueTtcblxuICAgIHJldHVybiBkeCAqIGR4ICsgZHkgKiBkeTtcbn1cblxuLy8gc3F1YXJlIGRpc3RhbmNlIGZyb20gYSBwb2ludCB0byBhIHNlZ21lbnRcbmZ1bmN0aW9uIGdldFNxU2VnRGlzdChwLCBwMSwgcDIpIHtcblxuICAgIHZhciB4ID0gcDEueCxcbiAgICAgICAgeSA9IHAxLnksXG4gICAgICAgIGR4ID0gcDIueCAtIHgsXG4gICAgICAgIGR5ID0gcDIueSAtIHk7XG5cbiAgICBpZiAoZHggIT09IDAgfHwgZHkgIT09IDApIHtcblxuICAgICAgICB2YXIgdCA9ICgocC54IC0geCkgKiBkeCArIChwLnkgLSB5KSAqIGR5KSAvIChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cbiAgICAgICAgaWYgKHQgPiAxKSB7XG4gICAgICAgICAgICB4ID0gcDIueDtcbiAgICAgICAgICAgIHkgPSBwMi55O1xuXG4gICAgICAgIH0gZWxzZSBpZiAodCA+IDApIHtcbiAgICAgICAgICAgIHggKz0gZHggKiB0O1xuICAgICAgICAgICAgeSArPSBkeSAqIHQ7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICBkeCA9IHAueCAtIHg7XG4gICAgZHkgPSBwLnkgLSB5O1xuXG4gICAgcmV0dXJuIGR4ICogZHggKyBkeSAqIGR5O1xufVxuLy8gcmVzdCBvZiB0aGUgY29kZSBkb2Vzbid0IGNhcmUgYWJvdXQgcG9pbnQgZm9ybWF0XG5cbi8vIGJhc2ljIGRpc3RhbmNlLWJhc2VkIHNpbXBsaWZpY2F0aW9uXG5mdW5jdGlvbiBzaW1wbGlmeVJhZGlhbERpc3QocG9pbnRzLCBzcVRvbGVyYW5jZSkge1xuXG4gICAgdmFyIHByZXZQb2ludCA9IHBvaW50c1swXSxcbiAgICAgICAgbmV3UG9pbnRzID0gW3ByZXZQb2ludF0sXG4gICAgICAgIHBvaW50O1xuXG4gICAgZm9yICh2YXIgaSA9IDEsIGxlbiA9IHBvaW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBwb2ludCA9IHBvaW50c1tpXTtcblxuICAgICAgICBpZiAoZ2V0U3FEaXN0KHBvaW50LCBwcmV2UG9pbnQpID4gc3FUb2xlcmFuY2UpIHtcbiAgICAgICAgICAgIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcbiAgICAgICAgICAgIHByZXZQb2ludCA9IHBvaW50O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHByZXZQb2ludCAhPT0gcG9pbnQpIG5ld1BvaW50cy5wdXNoKHBvaW50KTtcblxuICAgIHJldHVybiBuZXdQb2ludHM7XG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5RFBTdGVwKHBvaW50cywgZmlyc3QsIGxhc3QsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKSB7XG4gICAgdmFyIG1heFNxRGlzdCA9IHNxVG9sZXJhbmNlLFxuICAgICAgICBpbmRleDtcblxuICAgIGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcbiAgICAgICAgdmFyIHNxRGlzdCA9IGdldFNxU2VnRGlzdChwb2ludHNbaV0sIHBvaW50c1tmaXJzdF0sIHBvaW50c1tsYXN0XSk7XG5cbiAgICAgICAgaWYgKHNxRGlzdCA+IG1heFNxRGlzdCkge1xuICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgbWF4U3FEaXN0ID0gc3FEaXN0O1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKG1heFNxRGlzdCA+IHNxVG9sZXJhbmNlKSB7XG4gICAgICAgIGlmIChpbmRleCAtIGZpcnN0ID4gMSkgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBmaXJzdCwgaW5kZXgsIHNxVG9sZXJhbmNlLCBzaW1wbGlmaWVkKTtcbiAgICAgICAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tpbmRleF0pO1xuICAgICAgICBpZiAobGFzdCAtIGluZGV4ID4gMSkgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCBpbmRleCwgbGFzdCwgc3FUb2xlcmFuY2UsIHNpbXBsaWZpZWQpO1xuICAgIH1cbn1cblxuLy8gc2ltcGxpZmljYXRpb24gdXNpbmcgUmFtZXItRG91Z2xhcy1QZXVja2VyIGFsZ29yaXRobVxuZnVuY3Rpb24gc2ltcGxpZnlEb3VnbGFzUGV1Y2tlcihwb2ludHMsIHNxVG9sZXJhbmNlKSB7XG4gICAgdmFyIGxhc3QgPSBwb2ludHMubGVuZ3RoIC0gMTtcblxuICAgIHZhciBzaW1wbGlmaWVkID0gW3BvaW50c1swXV07XG4gICAgc2ltcGxpZnlEUFN0ZXAocG9pbnRzLCAwLCBsYXN0LCBzcVRvbGVyYW5jZSwgc2ltcGxpZmllZCk7XG4gICAgc2ltcGxpZmllZC5wdXNoKHBvaW50c1tsYXN0XSk7XG5cbiAgICByZXR1cm4gc2ltcGxpZmllZDtcbn1cblxuLy8gYm90aCBhbGdvcml0aG1zIGNvbWJpbmVkIGZvciBhd2Vzb21lIHBlcmZvcm1hbmNlXG5mdW5jdGlvbiBzaW1wbGlmeShwb2ludHMsIHRvbGVyYW5jZSwgaGlnaGVzdFF1YWxpdHkpIHtcblxuICAgIGlmIChwb2ludHMubGVuZ3RoIDw9IDIpIHJldHVybiBwb2ludHM7XG5cbiAgICB2YXIgc3FUb2xlcmFuY2UgPSB0b2xlcmFuY2UgIT09IHVuZGVmaW5lZCA/IHRvbGVyYW5jZSAqIHRvbGVyYW5jZSA6IDE7XG5cbiAgICBwb2ludHMgPSBoaWdoZXN0UXVhbGl0eSA/IHBvaW50cyA6IHNpbXBsaWZ5UmFkaWFsRGlzdChwb2ludHMsIHNxVG9sZXJhbmNlKTtcbiAgICBwb2ludHMgPSBzaW1wbGlmeURvdWdsYXNQZXVja2VyKHBvaW50cywgc3FUb2xlcmFuY2UpO1xuXG4gICAgcmV0dXJuIHBvaW50cztcbn1cblxuLy8gZXhwb3J0IGFzIEFNRCBtb2R1bGUgLyBOb2RlIG1vZHVsZSAvIGJyb3dzZXIgb3Igd29ya2VyIHZhcmlhYmxlXG5pZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSBkZWZpbmUoZnVuY3Rpb24oKSB7IHJldHVybiBzaW1wbGlmeTsgfSk7XG5lbHNlIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJykge1xuICAgIG1vZHVsZS5leHBvcnRzID0gc2ltcGxpZnk7XG4gICAgbW9kdWxlLmV4cG9ydHMuZGVmYXVsdCA9IHNpbXBsaWZ5O1xufSBlbHNlIGlmICh0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcpIHNlbGYuc2ltcGxpZnkgPSBzaW1wbGlmeTtcbmVsc2Ugd2luZG93LnNpbXBsaWZ5ID0gc2ltcGxpZnk7XG5cbn0pKCk7XG4iLCJ2YXIgbWVhc3VyZURpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG52YXIgYmVhcmluZyA9IHJlcXVpcmUoJ3R1cmYtYmVhcmluZycpO1xudmFyIGRlc3RpbmF0aW9uID0gcmVxdWlyZSgndHVyZi1kZXN0aW5hdGlvbicpO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIExpbmVTdHJpbmd8bGluZX0gYW5kIHJldHVybnMgYSB7QGxpbmsgUG9pbnR8cG9pbnR9IGF0IGEgc3BlY2lmaWVkIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lLlxuICpcbiAqIEBuYW1lIGFsb25nXG4gKiBAcGFyYW0ge0ZlYXR1cmU8TGluZVN0cmluZz59IGxpbmUgaW5wdXQgbGluZVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGRpc3RhbmNlIGFsb25nIHRoZSBsaW5lXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VuaXRzPW1pbGVzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9pbnQ+fSBQb2ludCBgZGlzdGFuY2VgIGB1bml0c2AgYWxvbmcgdGhlIGxpbmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzcuMDMxNjY5LCAzOC44Nzg2MDVdLFxuICogICAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgICBbLTc3LjAyMDMzOSwgMzguODg0MDg0XSxcbiAqICAgICAgIFstNzcuMDI1NjYxLCAzOC44ODU4MjFdLFxuICogICAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgICBbLTc3LjAxOTgyNCwgMzguODkyMzY4XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgYWxvbmcgPSB0dXJmLmFsb25nKGxpbmUsIDEsICdtaWxlcycpO1xuICpcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW2xpbmUsIGFsb25nXVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobGluZSwgZGlzdGFuY2UsIHVuaXRzKSB7XG4gICAgdmFyIGNvb3JkcztcbiAgICBpZiAobGluZS50eXBlID09PSAnRmVhdHVyZScpIGNvb3JkcyA9IGxpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgZWxzZSBpZiAobGluZS50eXBlID09PSAnTGluZVN0cmluZycpIGNvb3JkcyA9IGxpbmUuY29vcmRpbmF0ZXM7XG4gICAgZWxzZSB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBMaW5lU3RyaW5nIEZlYXR1cmUgb3IgR2VvbWV0cnknKTtcblxuICAgIHZhciB0cmF2ZWxsZWQgPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY29vcmRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChkaXN0YW5jZSA+PSB0cmF2ZWxsZWQgJiYgaSA9PT0gY29vcmRzLmxlbmd0aCAtIDEpIGJyZWFrO1xuICAgICAgICBlbHNlIGlmICh0cmF2ZWxsZWQgPj0gZGlzdGFuY2UpIHtcbiAgICAgICAgICAgIHZhciBvdmVyc2hvdCA9IGRpc3RhbmNlIC0gdHJhdmVsbGVkO1xuICAgICAgICAgICAgaWYgKCFvdmVyc2hvdCkgcmV0dXJuIHBvaW50KGNvb3Jkc1tpXSk7XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gYmVhcmluZyhjb29yZHNbaV0sIGNvb3Jkc1tpIC0gMV0pIC0gMTgwO1xuICAgICAgICAgICAgICAgIHZhciBpbnRlcnBvbGF0ZWQgPSBkZXN0aW5hdGlvbihjb29yZHNbaV0sIG92ZXJzaG90LCBkaXJlY3Rpb24sIHVuaXRzKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gaW50ZXJwb2xhdGVkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdHJhdmVsbGVkICs9IG1lYXN1cmVEaXN0YW5jZShjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0sIHVuaXRzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9pbnQoY29vcmRzW2Nvb3Jkcy5sZW5ndGggLSAxXSk7XG59O1xuIiwidmFyIGdlb21ldHJ5QXJlYSA9IHJlcXVpcmUoJ2dlb2pzb24tYXJlYScpLmdlb21ldHJ5O1xuXG4vKipcbiAqIFRha2VzIGEgb25lIG9yIG1vcmUgZmVhdHVyZXMgYW5kIHJldHVybnMgdGhlaXIgYXJlYVxuICogaW4gc3F1YXJlIG1ldGVycy5cbiAqXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gaW5wdXQgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm4ge051bWJlcn0gYXJlYSBpbiBzcXVhcmUgbWV0ZXJzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb25zID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9seWdvblwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICAgICAgWy02Ny4wMzEwMjEsIDEwLjQ1ODEwMl0sXG4gKiAgICAgICAgICAgWy02Ny4wMzEwMjEsIDEwLjUzMzcyXSxcbiAqICAgICAgICAgICBbLTY2LjkyOTM5NywgMTAuNTMzNzJdLFxuICogICAgICAgICAgIFstNjYuOTI5Mzk3LCAxMC40NTgxMDJdLFxuICogICAgICAgICAgIFstNjcuMDMxMDIxLCAxMC40NTgxMDJdXG4gKiAgICAgICAgIF1dXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgICAgIFstNjYuOTE5Nzg0LCAxMC4zOTczMjVdLFxuICogICAgICAgICAgIFstNjYuOTE5Nzg0LCAxMC41MTM0NjddLFxuICogICAgICAgICAgIFstNjYuODA1MTE0LCAxMC41MTM0NjddLFxuICogICAgICAgICAgIFstNjYuODA1MTE0LCAxMC4zOTczMjVdLFxuICogICAgICAgICAgIFstNjYuOTE5Nzg0LCAxMC4zOTczMjVdXG4gKiAgICAgICAgIF1dXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBhcmVhID0gdHVyZi5hcmVhKHBvbHlnb25zKTtcbiAqXG4gKiAvLz1hcmVhXG4gKi9cbmZ1bmN0aW9uIGFyZWEoaW5wdXQpIHtcbiAgICBpZiAoaW5wdXQudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICBmb3IgKHZhciBpID0gMCwgc3VtID0gMDsgaSA8IGlucHV0LmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoaW5wdXQuZmVhdHVyZXNbaV0uZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgICAgICBzdW0gKz0gZ2VvbWV0cnlBcmVhKGlucHV0LmZlYXR1cmVzW2ldLmdlb21ldHJ5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3VtO1xuICAgIH0gZWxzZSBpZiAoaW5wdXQudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeUFyZWEoaW5wdXQuZ2VvbWV0cnkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBnZW9tZXRyeUFyZWEoaW5wdXQpO1xuICAgIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gYXJlYTtcbiIsInZhciBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcblxuLyoqXG4gKiBUYWtlcyBhIGJib3ggYW5kIHJldHVybnMgYW4gZXF1aXZhbGVudCB7QGxpbmsgUG9seWdvbnxwb2x5Z29ufS5cbiAqXG4gKiBAbmFtZSBiYm94UG9seWdvblxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGFuIEFycmF5IG9mIGJvdW5kaW5nIGJveCBjb29yZGluYXRlcyBpbiB0aGUgZm9ybTogYGBgW3hMb3csIHlMb3csIHhIaWdoLCB5SGlnaF1gYGBcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9seWdvbj59IGEgUG9seWdvbiByZXByZXNlbnRhdGlvbiBvZiB0aGUgYm91bmRpbmcgYm94XG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbMCwgMCwgMTAsIDEwXTtcbiAqXG4gKiB2YXIgcG9seSA9IHR1cmYuYmJveFBvbHlnb24oYmJveCk7XG4gKlxuICogLy89cG9seVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICB2YXIgbG93TGVmdCA9IFtiYm94WzBdLCBiYm94WzFdXTtcbiAgICB2YXIgdG9wTGVmdCA9IFtiYm94WzBdLCBiYm94WzNdXTtcbiAgICB2YXIgdG9wUmlnaHQgPSBbYmJveFsyXSwgYmJveFszXV07XG4gICAgdmFyIGxvd1JpZ2h0ID0gW2Jib3hbMl0sIGJib3hbMV1dO1xuXG4gICAgcmV0dXJuIHBvbHlnb24oW1tcbiAgICAgICAgbG93TGVmdCxcbiAgICAgICAgbG93UmlnaHQsXG4gICAgICAgIHRvcFJpZ2h0LFxuICAgICAgICB0b3BMZWZ0LFxuICAgICAgICBsb3dMZWZ0XG4gICAgXV0pO1xufTtcbiIsInZhciBlYWNoID0gcmVxdWlyZSgndHVyZi1tZXRhJykuY29vcmRFYWNoO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIGZlYXR1cmVzLCBjYWxjdWxhdGVzIHRoZSBiYm94IG9mIGFsbCBpbnB1dCBmZWF0dXJlcywgYW5kIHJldHVybnMgYSBib3VuZGluZyBib3guXG4gKlxuICogQG5hbWUgYmJveFxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGdlb2pzb24gaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0FycmF5PG51bWJlcj59IHRoZSBib3VuZGluZyBib3ggb2YgYGlucHV0YCBnaXZlblxuICogYXMgYW4gYXJyYXkgaW4gV1NFTiBvcmRlciAod2VzdCwgc291dGgsIGVhc3QsIG5vcnRoKVxuICogQGV4YW1wbGVcbiAqIHZhciBpbnB1dCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4xNzUzMjksIDIyLjI1MjRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzExNC4xNzAwMDcsIDIyLjI2Nzk2OV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTE0LjIwMDY0OSwgMjIuMjc0NjQxXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMTQuMTg2NzQ0LCAyMi4yNjU3NDVdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBiYm94ID0gdHVyZi5iYm94KGlucHV0KTtcbiAqXG4gKiB2YXIgYmJveFBvbHlnb24gPSB0dXJmLmJib3hQb2x5Z29uKGJib3gpO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGlucHV0LmZlYXR1cmVzLmNvbmNhdChiYm94UG9seWdvbik7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgdmFyIGJib3ggPSBbSW5maW5pdHksIEluZmluaXR5LCAtSW5maW5pdHksIC1JbmZpbml0eV07XG4gICAgZWFjaChnZW9qc29uLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgaWYgKGJib3hbMF0gPiBjb29yZFswXSkgYmJveFswXSA9IGNvb3JkWzBdO1xuICAgICAgICBpZiAoYmJveFsxXSA+IGNvb3JkWzFdKSBiYm94WzFdID0gY29vcmRbMV07XG4gICAgICAgIGlmIChiYm94WzJdIDwgY29vcmRbMF0pIGJib3hbMl0gPSBjb29yZFswXTtcbiAgICAgICAgaWYgKGJib3hbM10gPCBjb29yZFsxXSkgYmJveFszXSA9IGNvb3JkWzFdO1xuICAgIH0pO1xuICAgIHJldHVybiBiYm94O1xufTtcbiIsInZhciBnZXRDb29yZCA9IHJlcXVpcmUoJ3R1cmYtaW52YXJpYW50JykuZ2V0Q29vcmQ7XG4vL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGFcbi8vaHR0cDovL3d3dy5tb3ZhYmxlLXR5cGUuY28udWsvc2NyaXB0cy9sYXRsb25nLmh0bWxcblxuLyoqXG4gKiBUYWtlcyB0d28ge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIGZpbmRzIHRoZSBnZW9ncmFwaGljIGJlYXJpbmcgYmV0d2VlbiB0aGVtLlxuICpcbiAqIEBuYW1lIGJlYXJpbmdcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHN0YXJ0IHN0YXJ0aW5nIFBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBlbmQgZW5kaW5nIFBvaW50XG4gKiBAcmV0dXJucyB7TnVtYmVyfSBiZWFyaW5nIGluIGRlY2ltYWwgZGVncmVlc1xuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludDEgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICBcIm1hcmtlci1jb2xvclwiOiAnI2YwMCdcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzQzLCAzOS45ODRdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcG9pbnQyID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogJyMwZjAnXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjUzNCwgMzkuMTIzXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBwb2ludHMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW3BvaW50MSwgcG9pbnQyXVxuICogfTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiB2YXIgYmVhcmluZyA9IHR1cmYuYmVhcmluZyhwb2ludDEsIHBvaW50Mik7XG4gKlxuICogLy89YmVhcmluZ1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChzdGFydCwgZW5kKSB7XG4gICAgdmFyIGRlZ3JlZXMycmFkaWFucyA9IE1hdGguUEkgLyAxODA7XG4gICAgdmFyIHJhZGlhbnMyZGVncmVlcyA9IDE4MCAvIE1hdGguUEk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMSA9IGdldENvb3JkKHN0YXJ0KTtcbiAgICB2YXIgY29vcmRpbmF0ZXMyID0gZ2V0Q29vcmQoZW5kKTtcblxuICAgIHZhciBsb24xID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMxWzBdO1xuICAgIHZhciBsb24yID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMyWzBdO1xuICAgIHZhciBsYXQxID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMxWzFdO1xuICAgIHZhciBsYXQyID0gZGVncmVlczJyYWRpYW5zICogY29vcmRpbmF0ZXMyWzFdO1xuICAgIHZhciBhID0gTWF0aC5zaW4obG9uMiAtIGxvbjEpICogTWF0aC5jb3MobGF0Mik7XG4gICAgdmFyIGIgPSBNYXRoLmNvcyhsYXQxKSAqIE1hdGguc2luKGxhdDIpIC1cbiAgICAgICAgTWF0aC5zaW4obGF0MSkgKiBNYXRoLmNvcyhsYXQyKSAqIE1hdGguY29zKGxvbjIgLSBsb24xKTtcblxuICAgIHZhciBiZWFyaW5nID0gcmFkaWFuczJkZWdyZWVzICogTWF0aC5hdGFuMihhLCBiKTtcblxuICAgIHJldHVybiBiZWFyaW5nO1xufTtcbiIsInZhciBsaW5lc3RyaW5nID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykubGluZVN0cmluZztcbnZhciBTcGxpbmUgPSByZXF1aXJlKCcuL3NwbGluZS5qcycpO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIExpbmVTdHJpbmd8bGluZX0gYW5kIHJldHVybnMgYSBjdXJ2ZWQgdmVyc2lvblxuICogYnkgYXBwbHlpbmcgYSBbQmV6aWVyIHNwbGluZV0oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9CJUMzJUE5emllcl9zcGxpbmUpXG4gKiBhbGdvcml0aG0uXG4gKlxuICogVGhlIGJlemllciBzcGxpbmUgaW1wbGVtZW50YXRpb24gaXMgYnkgW0xlc3playBSeWJpY2tpXShodHRwOi8vbGVzemVrLnJ5Ymlja2kuY2MvKS5cbiAqXG4gKiBAbmFtZSBiZXppZXJcbiAqIEBwYXJhbSB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gbGluZSBpbnB1dCBMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge051bWJlcn0gW3Jlc29sdXRpb249MTAwMDBdIHRpbWUgaW4gbWlsbGlzZWNvbmRzIGJldHdlZW4gcG9pbnRzXG4gKiBAcGFyYW0ge051bWJlcn0gW3NoYXJwbmVzcz0wLjg1XSBhIG1lYXN1cmUgb2YgaG93IGN1cnZ5IHRoZSBwYXRoIHNob3VsZCBiZSBiZXR3ZWVuIHNwbGluZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBjdXJ2ZWQgbGluZVxuICogQGV4YW1wbGVcbiAqIHZhciBsaW5lID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJzdHJva2VcIjogXCIjZjAwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiTGluZVN0cmluZ1wiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogW1xuICogICAgICAgWy03Ni4wOTEzMDgsIDE4LjQyNzUwMV0sXG4gKiAgICAgICBbLTc2LjY5NTU1NiwgMTguNzI5NTAxXSxcbiAqICAgICAgIFstNzYuNTUyNzM0LCAxOS40MDQ0M10sXG4gKiAgICAgICBbLTc0LjYxOTE0LCAxOS4xMzQ3ODldLFxuICogICAgICAgWy03My42NTIzNDMsIDIwLjA3NjU3XSxcbiAqICAgICAgIFstNzMuMTU3OTU4LCAyMC4yMTA2NTZdXG4gKiAgICAgXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBjdXJ2ZWQgPSB0dXJmLmJlemllcihsaW5lKTtcbiAqIGN1cnZlZC5wcm9wZXJ0aWVzID0geyBzdHJva2U6ICcjMGYwJyB9O1xuICpcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW2xpbmUsIGN1cnZlZF1cbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpbmUsIHJlc29sdXRpb24sIHNoYXJwbmVzcykge1xuICAgIHZhciBsaW5lT3V0ID0gbGluZXN0cmluZyhbXSk7XG5cbiAgICBsaW5lT3V0LnByb3BlcnRpZXMgPSBsaW5lLnByb3BlcnRpZXM7XG5cbiAgICB2YXIgc3BsaW5lID0gbmV3IFNwbGluZSh7XG4gICAgICAgIHBvaW50czogbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgICAgICByZXR1cm4ge3g6IHB0WzBdLCB5OiBwdFsxXX07XG4gICAgICAgIH0pLFxuICAgICAgICBkdXJhdGlvbjogcmVzb2x1dGlvbixcbiAgICAgICAgc2hhcnBuZXNzOiBzaGFycG5lc3NcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3BsaW5lLmR1cmF0aW9uOyBpICs9IDEwKSB7XG4gICAgICAgIHZhciBwb3MgPSBzcGxpbmUucG9zKGkpO1xuICAgICAgICBpZiAoTWF0aC5mbG9vcihpIC8gMTAwKSAlIDIgPT09IDApIHtcbiAgICAgICAgICAgIGxpbmVPdXQuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucHVzaChbcG9zLngsIHBvcy55XSk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gbGluZU91dDtcbn07XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSAqL1xuXG4gLyoqXG4gICAqIEJlemllclNwbGluZVxuICAgKiBodHRwczovL2dpdGh1Yi5jb20vbGVzemVrci9iZXppZXItc3BsaW5lLWpzXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBjb3B5cmlnaHRcbiAgICogQ29weXJpZ2h0IChjKSAyMDEzIExlc3playBSeWJpY2tpXG4gICAqXG4gICAqIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhIGNvcHlcbiAgICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICAgKiBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzXG4gICAqIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCwgZGlzdHJpYnV0ZSwgc3VibGljZW5zZSwgYW5kL29yIHNlbGxcbiAgICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gICAqIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGUgZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4gICAqXG4gICAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICAgKiBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuICAgKlxuICAgKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gICAqIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICAgKiBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSBBTkQgTk9OSU5GUklOR0VNRU5ULiBJTiBOTyBFVkVOVCBTSEFMTCBUSEVcbiAgICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICAgKiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuICAgKiBPVVQgT0YgT1IgSU4gQ09OTkVDVElPTiBXSVRIIFRIRSBTT0ZUV0FSRSBPUiBUSEUgVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRVxuICAgKiBTT0ZUV0FSRS5cbiAgICovXG52YXIgU3BsaW5lID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB0aGlzLnBvaW50cyA9IG9wdGlvbnMucG9pbnRzIHx8IFtdO1xuICAgIHRoaXMuZHVyYXRpb24gPSBvcHRpb25zLmR1cmF0aW9uIHx8IDEwMDAwO1xuICAgIHRoaXMuc2hhcnBuZXNzID0gb3B0aW9ucy5zaGFycG5lc3MgfHwgMC44NTtcbiAgICB0aGlzLmNlbnRlcnMgPSBbXTtcbiAgICB0aGlzLmNvbnRyb2xzID0gW107XG4gICAgdGhpcy5zdGVwTGVuZ3RoID0gb3B0aW9ucy5zdGVwTGVuZ3RoIHx8IDYwO1xuICAgIHRoaXMubGVuZ3RoID0gdGhpcy5wb2ludHMubGVuZ3RoO1xuICAgIHRoaXMuZGVsYXkgPSAwO1xuICAgIC8vIHRoaXMgaXMgdG8gZW5zdXJlIGNvbXBhdGliaWxpdHkgd2l0aCB0aGUgMmQgdmVyc2lvblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykgdGhpcy5wb2ludHNbaV0ueiA9IHRoaXMucG9pbnRzW2ldLnogfHwgMDtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBwMSA9IHRoaXMucG9pbnRzW2ldO1xuICAgICAgICB2YXIgcDIgPSB0aGlzLnBvaW50c1tpICsgMV07XG4gICAgICAgIHRoaXMuY2VudGVycy5wdXNoKHtcbiAgICAgICAgICAgIHg6IChwMS54ICsgcDIueCkgLyAyLFxuICAgICAgICAgICAgeTogKHAxLnkgKyBwMi55KSAvIDIsXG4gICAgICAgICAgICB6OiAocDEueiArIHAyLnopIC8gMlxuICAgICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9scy5wdXNoKFt0aGlzLnBvaW50c1swXSwgdGhpcy5wb2ludHNbMF1dKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2VudGVycy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgICAgdmFyIHAxID0gdGhpcy5jZW50ZXJzW2ldO1xuICAgICAgICB2YXIgcDIgPSB0aGlzLmNlbnRlcnNbaSArIDFdO1xuICAgICAgICB2YXIgZHggPSB0aGlzLnBvaW50c1tpICsgMV0ueCAtICh0aGlzLmNlbnRlcnNbaV0ueCArIHRoaXMuY2VudGVyc1tpICsgMV0ueCkgLyAyO1xuICAgICAgICB2YXIgZHkgPSB0aGlzLnBvaW50c1tpICsgMV0ueSAtICh0aGlzLmNlbnRlcnNbaV0ueSArIHRoaXMuY2VudGVyc1tpICsgMV0ueSkgLyAyO1xuICAgICAgICB2YXIgZHogPSB0aGlzLnBvaW50c1tpICsgMV0ueiAtICh0aGlzLmNlbnRlcnNbaV0ueSArIHRoaXMuY2VudGVyc1tpICsgMV0ueikgLyAyO1xuICAgICAgICB0aGlzLmNvbnRyb2xzLnB1c2goW3tcbiAgICAgICAgICAgIHg6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueCArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpXS54ICsgZHgpLFxuICAgICAgICAgICAgeTogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS55ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2ldLnkgKyBkeSksXG4gICAgICAgICAgICB6OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnogKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaV0ueiArIGR6KX0sXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgeDogKDEuMCAtIHRoaXMuc2hhcnBuZXNzKSAqIHRoaXMucG9pbnRzW2kgKyAxXS54ICsgdGhpcy5zaGFycG5lc3MgKiAodGhpcy5jZW50ZXJzW2kgKyAxXS54ICsgZHgpLFxuICAgICAgICAgICAgICAgIHk6ICgxLjAgLSB0aGlzLnNoYXJwbmVzcykgKiB0aGlzLnBvaW50c1tpICsgMV0ueSArIHRoaXMuc2hhcnBuZXNzICogKHRoaXMuY2VudGVyc1tpICsgMV0ueSArIGR5KSxcbiAgICAgICAgICAgICAgICB6OiAoMS4wIC0gdGhpcy5zaGFycG5lc3MpICogdGhpcy5wb2ludHNbaSArIDFdLnogKyB0aGlzLnNoYXJwbmVzcyAqICh0aGlzLmNlbnRlcnNbaSArIDFdLnogKyBkeil9XSk7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbHMucHVzaChbdGhpcy5wb2ludHNbdGhpcy5sZW5ndGggLSAxXSwgdGhpcy5wb2ludHNbdGhpcy5sZW5ndGggLSAxXV0pO1xuICAgIHRoaXMuc3RlcHMgPSB0aGlzLmNhY2hlU3RlcHModGhpcy5zdGVwTGVuZ3RoKTtcbiAgICByZXR1cm4gdGhpcztcbn07XG5cbiAgLypcbiAgICBDYWNoZXMgYW4gYXJyYXkgb2YgZXF1aWRpc3RhbnQgKG1vcmUgb3IgbGVzcykgcG9pbnRzIG9uIHRoZSBjdXJ2ZS5cbiAgKi9cblNwbGluZS5wcm90b3R5cGUuY2FjaGVTdGVwcyA9IGZ1bmN0aW9uIChtaW5kaXN0KSB7XG4gICAgdmFyIHN0ZXBzID0gW107XG4gICAgdmFyIGxhc3RzdGVwID0gdGhpcy5wb3MoMCk7XG4gICAgc3RlcHMucHVzaCgwKTtcbiAgICBmb3IgKHZhciB0ID0gMDsgdCA8IHRoaXMuZHVyYXRpb247IHQgKz0gMTApIHtcbiAgICAgICAgdmFyIHN0ZXAgPSB0aGlzLnBvcyh0KTtcbiAgICAgICAgdmFyIGRpc3QgPSBNYXRoLnNxcnQoKHN0ZXAueCAtIGxhc3RzdGVwLngpICogKHN0ZXAueCAtIGxhc3RzdGVwLngpICsgKHN0ZXAueSAtIGxhc3RzdGVwLnkpICogKHN0ZXAueSAtIGxhc3RzdGVwLnkpICsgKHN0ZXAueiAtIGxhc3RzdGVwLnopICogKHN0ZXAueiAtIGxhc3RzdGVwLnopKTtcbiAgICAgICAgaWYgKGRpc3QgPiBtaW5kaXN0KSB7XG4gICAgICAgICAgICBzdGVwcy5wdXNoKHQpO1xuICAgICAgICAgICAgbGFzdHN0ZXAgPSBzdGVwO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzdGVwcztcbn07XG5cbiAgLypcbiAgICByZXR1cm5zIGFuZ2xlIGFuZCBzcGVlZCBpbiB0aGUgZ2l2ZW4gcG9pbnQgaW4gdGhlIGN1cnZlXG4gICovXG5TcGxpbmUucHJvdG90eXBlLnZlY3RvciA9IGZ1bmN0aW9uICh0KSB7XG4gICAgdmFyIHAxID0gdGhpcy5wb3ModCArIDEwKTtcbiAgICB2YXIgcDIgPSB0aGlzLnBvcyh0IC0gMTApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFuZ2xlOjE4MCAqIE1hdGguYXRhbjIocDEueSAtIHAyLnksIHAxLnggLSBwMi54KSAvIDMuMTQsXG4gICAgICAgIHNwZWVkOk1hdGguc3FydCgocDIueCAtIHAxLngpICogKHAyLnggLSBwMS54KSArIChwMi55IC0gcDEueSkgKiAocDIueSAtIHAxLnkpICsgKHAyLnogLSBwMS56KSAqIChwMi56IC0gcDEueikpXG4gICAgfTtcbn07XG5cbiAgLypcbiAgICBHZXRzIHRoZSBwb3NpdGlvbiBvZiB0aGUgcG9pbnQsIGdpdmVuIHRpbWUuXG5cbiAgICBXQVJOSU5HOiBUaGUgc3BlZWQgaXMgbm90IGNvbnN0YW50LiBUaGUgdGltZSBpdCB0YWtlcyBiZXR3ZWVuIGNvbnRyb2wgcG9pbnRzIGlzIGNvbnN0YW50LlxuXG4gICAgRm9yIGNvbnN0YW50IHNwZWVkLCB1c2UgU3BsaW5lLnN0ZXBzW2ldO1xuICAqL1xuU3BsaW5lLnByb3RvdHlwZS5wb3MgPSBmdW5jdGlvbiAodGltZSkge1xuXG4gICAgZnVuY3Rpb24gYmV6aWVyKHQsIHAxLCBjMSwgYzIsIHAyKSB7XG4gICAgICAgIHZhciBCID0gZnVuY3Rpb24gKHQpIHtcbiAgICAgICAgICAgIHZhciB0MiA9IHQgKiB0LCB0MyA9IHQyICogdDtcbiAgICAgICAgICAgIHJldHVybiBbKHQzKSwgKDMgKiB0MiAqICgxIC0gdCkpLCAoMyAqIHQgKiAoMSAtIHQpICogKDEgLSB0KSksICgoMSAtIHQpICogKDEgLSB0KSAqICgxIC0gdCkpXTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGIgPSBCKHQpO1xuICAgICAgICB2YXIgcG9zID0ge1xuICAgICAgICAgICAgeCA6IHAyLnggKiBiWzBdICsgYzIueCAqIGJbMV0gKyBjMS54ICogYlsyXSArIHAxLnggKiBiWzNdLFxuICAgICAgICAgICAgeSA6IHAyLnkgKiBiWzBdICsgYzIueSAqIGJbMV0gKyBjMS55ICogYlsyXSArIHAxLnkgKiBiWzNdLFxuICAgICAgICAgICAgeiA6IHAyLnogKiBiWzBdICsgYzIueiAqIGJbMV0gKyBjMS56ICogYlsyXSArIHAxLnogKiBiWzNdXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBwb3M7XG4gICAgfVxuICAgIHZhciB0ID0gdGltZSAtIHRoaXMuZGVsYXk7XG4gICAgaWYgKHQgPCAwKSB0ID0gMDtcbiAgICBpZiAodCA+IHRoaXMuZHVyYXRpb24pIHQgPSB0aGlzLmR1cmF0aW9uIC0gMTtcbiAgICAvL3QgPSB0LXRoaXMuZGVsYXk7XG4gICAgdmFyIHQyID0gKHQpIC8gdGhpcy5kdXJhdGlvbjtcbiAgICBpZiAodDIgPj0gMSkgcmV0dXJuIHRoaXMucG9pbnRzW3RoaXMubGVuZ3RoIC0gMV07XG5cbiAgICB2YXIgbiA9IE1hdGguZmxvb3IoKHRoaXMucG9pbnRzLmxlbmd0aCAtIDEpICogdDIpO1xuICAgIHZhciB0MSA9ICh0aGlzLmxlbmd0aCAtIDEpICogdDIgLSBuO1xuICAgIHJldHVybiBiZXppZXIodDEsIHRoaXMucG9pbnRzW25dLCB0aGlzLmNvbnRyb2xzW25dWzFdLCB0aGlzLmNvbnRyb2xzW24gKyAxXVswXSwgdGhpcy5wb2ludHNbbiArIDFdKTtcbn07XG5cbm1vZHVsZS5leHBvcnRzID0gU3BsaW5lO1xuIiwiLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy84Mzk4OTkvaG93LWRvLWktY2FsY3VsYXRlLWEtcG9pbnQtb24tYS1jaXJjbGVzLWNpcmN1bWZlcmVuY2Vcbi8vIHJhZGlhbnMgPSBkZWdyZWVzICogKHBpLzE4MClcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvYnVmZmVyLmh0bWxcblxudmFyIGhlbHBlcnMgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKTtcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IGhlbHBlcnMuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIganN0cyA9IHJlcXVpcmUoJ2pzdHMnKTtcbnZhciBub3JtYWxpemUgPSByZXF1aXJlKCdnZW9qc29uLW5vcm1hbGl6ZScpO1xuXG4vKipcbiAqIENhbGN1bGF0ZXMgYSBidWZmZXIgZm9yIGlucHV0IGZlYXR1cmVzIGZvciBhIGdpdmVuIHJhZGl1cy4gVW5pdHMgc3VwcG9ydGVkIGFyZSBtaWxlcywga2lsb21ldGVycywgYW5kIGRlZ3JlZXMuXG4gKlxuICogQG5hbWUgYnVmZmVyXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZmVhdHVyZSBpbnB1dCB0byBiZSBidWZmZXJlZFxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGRpc3RhbmNlIHRvIGRyYXcgdGhlIGJ1ZmZlclxuICogQHBhcmFtIHtzdHJpbmd9IHVuaXQgYW55IG9mIHRoZSBvcHRpb25zIHN1cHBvcnRlZCBieSB0dXJmIHVuaXRzXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPnxGZWF0dXJlQ29sbGVjdGlvbjxNdWx0aVBvbHlnb24+fFBvbHlnb258TXVsdGlQb2x5Z29ufSBidWZmZXJlZCBmZWF0dXJlc1xuICpcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy05MC41NDg2MzAsIDE0LjYxNjU5OV1cbiAqICAgfVxuICogfTtcbiAqIHZhciB1bml0ID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgYnVmZmVyZWQgPSB0dXJmLmJ1ZmZlcihwdCwgNTAwLCB1bml0KTtcbiAqIHZhciByZXN1bHQgPSB0dXJmLmZlYXR1cmVjb2xsZWN0aW9uKFtidWZmZXJlZCwgcHRdKTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmZWF0dXJlLCByYWRpdXMsIHVuaXRzKSB7XG5cbiAgICB2YXIgZGVncmVlcyA9IGhlbHBlcnMuZGlzdGFuY2VUb0RlZ3JlZXMocmFkaXVzLCB1bml0cyk7XG4gICAgdmFyIGZjID0gbm9ybWFsaXplKGZlYXR1cmUpO1xuICAgIHZhciBidWZmZXJlZCA9IG5vcm1hbGl6ZShmZWF0dXJlQ29sbGVjdGlvbihmYy5mZWF0dXJlcy5tYXAoZnVuY3Rpb24gKGYpIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlck9wKGYsIGRlZ3JlZXMpO1xuICAgIH0pKSk7XG5cbiAgICBpZiAoYnVmZmVyZWQuZmVhdHVyZXMubGVuZ3RoID4gMSkgcmV0dXJuIGJ1ZmZlcmVkO1xuICAgIGVsc2UgaWYgKGJ1ZmZlcmVkLmZlYXR1cmVzLmxlbmd0aCA9PT0gMSkgcmV0dXJuIGJ1ZmZlcmVkLmZlYXR1cmVzWzBdO1xufTtcblxuZnVuY3Rpb24gYnVmZmVyT3AoZmVhdHVyZSwgcmFkaXVzKSB7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgZ2VvbSA9IHJlYWRlci5yZWFkKGZlYXR1cmUuZ2VvbWV0cnkpO1xuICAgIHZhciBidWZmZXJlZCA9IGdlb20uYnVmZmVyKHJhZGl1cyk7XG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcbiAgICBidWZmZXJlZCA9IHdyaXRlci53cml0ZShidWZmZXJlZCk7XG5cbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBidWZmZXJlZCxcbiAgICAgICAgcHJvcGVydGllczoge31cbiAgICB9O1xufVxuIiwidmFyIGJib3ggPSByZXF1aXJlKCd0dXJmLWJib3gnKSxcbiAgICBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBhbmQgcmV0dXJucyB0aGUgYWJzb2x1dGUgY2VudGVyIHBvaW50IG9mIGFsbCBmZWF0dXJlcy5cbiAqXG4gKiBAbmFtZSBjZW50ZXJcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb259IGZlYXR1cmVzIGlucHV0IGZlYXR1cmVzXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gYSBQb2ludCBmZWF0dXJlIGF0IHRoZVxuICogYWJzb2x1dGUgY2VudGVyIHBvaW50IG9mIGFsbCBpbnB1dCBmZWF0dXJlc1xuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlcyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MjIyNTksIDM1LjQ2OTFdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MDI3NTQsIDM1LjQ2MzQ1NV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUwODI2OSwgMzUuNDYzMjQ1XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE2ODA5LCAzNS40NjU3NzldXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTUzNzIsIDM1LjQ2NzA3Ml1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUwOTM2MywgMzUuNDYzMDUzXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTExMTIzLCAzNS40NjY2MDFdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MTg1NDcsIDM1LjQ2OTMyN11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxOTcwNiwgMzUuNDY5NjU5XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstOTcuNTE3ODM5LCAzNS40NjY5OThdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy05Ny41MDg2NzgsIDM1LjQ2NDk0Ml1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTk3LjUxNDkxNCwgMzUuNDYzNDUzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgY2VudGVyUHQgPSB0dXJmLmNlbnRlcihmZWF0dXJlcyk7XG4gKiBjZW50ZXJQdC5wcm9wZXJ0aWVzWydtYXJrZXItc2l6ZSddID0gJ2xhcmdlJztcbiAqIGNlbnRlclB0LnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyMwMDAnO1xuICpcbiAqIHZhciByZXN1bHRGZWF0dXJlcyA9IGZlYXR1cmVzLmZlYXR1cmVzLmNvbmNhdChjZW50ZXJQdCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxheWVyKSB7XG4gICAgdmFyIGV4dCA9IGJib3gobGF5ZXIpO1xuICAgIHZhciB4ID0gKGV4dFswXSArIGV4dFsyXSkgLyAyO1xuICAgIHZhciB5ID0gKGV4dFsxXSArIGV4dFszXSkgLyAyO1xuICAgIHJldHVybiBwb2ludChbeCwgeV0pO1xufTtcbiIsInZhciBlYWNoID0gcmVxdWlyZSgndHVyZi1tZXRhJykuY29vcmRFYWNoO1xudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG5cbi8qKlxuICogVGFrZXMgb25lIG9yIG1vcmUgZmVhdHVyZXMgYW5kIGNhbGN1bGF0ZXMgdGhlIGNlbnRyb2lkIHVzaW5nXG4gKiB0aGUgbWVhbiBvZiBhbGwgdmVydGljZXMuXG4gKiBUaGlzIGxlc3NlbnMgdGhlIGVmZmVjdCBvZiBzbWFsbCBpc2xhbmRzIGFuZCBhcnRpZmFjdHMgd2hlbiBjYWxjdWxhdGluZ1xuICogdGhlIGNlbnRyb2lkIG9mIGEgc2V0IG9mIHBvbHlnb25zLlxuICpcbiAqIEBuYW1lIGNlbnRyb2lkXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZmVhdHVyZXMgaW5wdXQgZmVhdHVyZXNcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9pbnQ+fSB0aGUgY2VudHJvaWQgb2YgdGhlIGlucHV0IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWzEwNS44MTg5MzksMjEuMDA0NzE0XSxcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjA2MTc1NF0sXG4gKiAgICAgICBbMTA1Ljg5MDAwNywyMS4wNjE3NTRdLFxuICogICAgICAgWzEwNS44OTAwMDcsMjEuMDA0NzE0XSxcbiAqICAgICAgIFsxMDUuODE4OTM5LDIxLjAwNDcxNF1cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBjZW50cm9pZFB0ID0gdHVyZi5jZW50cm9pZChwb2x5KTtcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2x5LCBjZW50cm9pZFB0XVxuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZXMpIHtcbiAgICB2YXIgeFN1bSA9IDAsIHlTdW0gPSAwLCBsZW4gPSAwO1xuICAgIGVhY2goZmVhdHVyZXMsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICB4U3VtICs9IGNvb3JkWzBdO1xuICAgICAgICB5U3VtICs9IGNvb3JkWzFdO1xuICAgICAgICBsZW4rKztcbiAgICB9LCB0cnVlKTtcbiAgICByZXR1cm4gcG9pbnQoW3hTdW0gLyBsZW4sIHlTdW0gLyBsZW5dKTtcbn07XG4iLCJ2YXIgaW5zaWRlID0gcmVxdWlyZSgndHVyZi1pbnNpZGUnKTtcblxuLyoqXG4gKiBKb2lucyBhdHRyaWJ1dGVzIEZlYXR1cmVDb2xsZWN0aW9uIG9mIHBvbHlnb25zIHdpdGggYSBGZWF0dXJlQ29sbGVjdGlvbiBvZlxuICogcG9pbnRzLiBHaXZlbiBhbiBgaW5Qcm9wZXJ0eWAgb24gcG9pbnRzIGFuZCBhbiBgb3V0UHJvcGVydHlgIGZvciBwb2x5Z29ucyxcbiAqIHRoaXMgZmluZHMgZXZlcnkgcG9pbnQgdGhhdCBsaWVzIHdpdGhpbiBlYWNoIHBvbHlnb24sIGNvbGxlY3RzIHRoZSBgaW5Qcm9wZXJ0eWBcbiAqIHZhbHVlcyBmcm9tIHRob3NlIHBvaW50cywgYW5kIGFkZHMgdGhlbSBhcyBhbiBhcnJheSB0byBgb3V0UHJvcGVydHlgIG9uIHRoZVxuICogcG9seWdvbi5cbiAqXG4gKiBAbmFtZSBjb2xsZWN0XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyBwb2x5Z29ucyB3aXRoIHZhbHVlcyBvbiB3aGljaCB0byBhZ2dyZWdhdGVcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgcG9pbnRzIHRvIGJlIGFnZ3JlZ2F0ZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBpblByb3BlcnR5IHByb3BlcnR5IHRvIGJlIG5lc3RlZCBmcm9tXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0UHJvcGVydHkgcHJvcGVydHkgdG8gYmUgbmVzdGVkIGludG9cbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBwb2x5Z29ucyB3aXRoIHByb3BlcnRpZXMgbGlzdGVkIGJhc2VkIG9uIGBvdXRGaWVsZGBcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seTEgPSBwb2x5Z29uKFtbWzAsMF0sWzEwLDBdLFsxMCwxMF0sWzAsMTBdLFswLDBdXV0pO1xuICogdmFyIHBvbHkyID0gcG9seWdvbihbW1sxMCwwXSxbMjAsMTBdLFsyMCwyMF0sWzIwLDBdLFsxMCwwXV1dKTtcbiAqIHZhciBwb2x5RkMgPSBmZWF0dXJlY29sbGVjdGlvbihbcG9seTEsIHBvbHkyXSk7XG4gKiB2YXIgcHQxID0gcG9pbnQoWzUsNV0sIHtwb3B1bGF0aW9uOiAyMDB9KTtcbiAqIHZhciBwdDIgPSBwb2ludChbMSwzXSwge3BvcHVsYXRpb246IDYwMH0pO1xuICogdmFyIHB0MyA9IHBvaW50KFsxNCwyXSwge3BvcHVsYXRpb246IDEwMH0pO1xuICogdmFyIHB0NCA9IHBvaW50KFsxMywxXSwge3BvcHVsYXRpb246IDIwMH0pO1xuICogdmFyIHB0NSA9IHBvaW50KFsxOSw3XSwge3BvcHVsYXRpb246IDMwMH0pO1xuICogdmFyIHB0RkMgPSBmZWF0dXJlY29sbGVjdGlvbihbcHQxLCBwdDIsIHB0MywgcHQ0LCBwdDVdKTtcbiAqIHZhciBhZ2dyZWdhdGVkID0gYWdncmVnYXRlKHBvbHlGQywgcHRGQywgJ3BvcHVsYXRpb24nLCAndmFsdWVzJyk7XG4gKlxuICogYWdncmVnYXRlZC5mZWF0dXJlc1swXS5wcm9wZXJ0aWVzLnZhbHVlcyAvLyA9PiBbMjAwLCA2MDBdKTtcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjb2xsZWN0KHBvbHlnb25zLCBwb2ludHMsIGluUHJvcGVydHksIG91dFByb3BlcnR5KSB7XG4gICAgcG9seWdvbnMuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAocG9seSkge1xuICAgICAgICB2YXIgdmFsdWVzID0gcG9pbnRzLmZlYXR1cmVzLmZpbHRlcihmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgICAgIHJldHVybiBpbnNpZGUocHQsIHBvbHkpO1xuICAgICAgICB9KS5tYXAoZnVuY3Rpb24gKHB0KSB7XG4gICAgICAgICAgICByZXR1cm4gcHQucHJvcGVydGllc1tpblByb3BlcnR5XTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgaWYgKCFwb2x5LnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgIHBvbHkucHJvcGVydGllcyA9IHt9O1xuICAgICAgICB9XG5cbiAgICAgICAgcG9seS5wcm9wZXJ0aWVzW291dFByb3BlcnR5XSA9IHZhbHVlcztcbiAgICB9KTtcblxuICAgIHJldHVybiBwb2x5Z29ucztcbn07XG4iLCJ2YXIgbWV0YSA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpO1xuXG4vKipcbiAqIENvbWJpbmVzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBvZiB7QGxpbmsgUG9pbnR9LFxuICoge0BsaW5rIExpbmVTdHJpbmd9LCBvciB7QGxpbmsgUG9seWdvbn0gZmVhdHVyZXNcbiAqIGludG8ge0BsaW5rIE11bHRpUG9pbnR9LCB7QGxpbmsgTXVsdGlMaW5lU3RyaW5nfSwgb3JcbiAqIHtAbGluayBNdWx0aVBvbHlnb259IGZlYXR1cmVzLlxuICpcbiAqIEBuYW1lIGNvbWJpbmVcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248KFBvaW50fExpbmVTdHJpbmd8UG9seWdvbik+fSBmYyBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGFueSB0eXBlXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjwoTXVsdGlQb2ludHxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29uKT59IGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgY29ycmVzcG9uZGluZyB0eXBlIHRvIGlucHV0XG4gKiBAZXhhbXBsZVxuICogdmFyIGZjID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTkuMDI2NDMyLCA0Ny40OTEzNF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTkuMDc0NDk3LCA0Ny41MDk1NDhdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBjb21iaW5lZCA9IHR1cmYuY29tYmluZShmYyk7XG4gKlxuICogLy89Y29tYmluZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmYykge1xuICAgIHZhciBncm91cHMgPSB7XG4gICAgICAgIE11bHRpUG9pbnQ6IHtjb29yZGluYXRlczogW10sIHByb3BlcnRpZXM6IFtdfSxcbiAgICAgICAgTXVsdGlMaW5lU3RyaW5nOiB7Y29vcmRpbmF0ZXM6IFtdLCBwcm9wZXJ0aWVzOiBbXX0sXG4gICAgICAgIE11bHRpUG9seWdvbjoge2Nvb3JkaW5hdGVzOiBbXSwgcHJvcGVydGllczogW119XG4gICAgfTtcblxuICAgIHZhciBtdWx0aU1hcHBpbmcgPSBPYmplY3Qua2V5cyhncm91cHMpLnJlZHVjZShmdW5jdGlvbiAobWVtbywgaXRlbSkge1xuICAgICAgICBtZW1vW2l0ZW0ucmVwbGFjZSgnTXVsdGknLCAnJyldID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfSwge30pO1xuXG4gICAgZnVuY3Rpb24gYWRkVG9Hcm91cChmZWF0dXJlLCBrZXksIG11bHRpKSB7XG4gICAgICAgIGlmICghbXVsdGkpIHtcbiAgICAgICAgICAgIGdyb3Vwc1trZXldLmNvb3JkaW5hdGVzLnB1c2goZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBncm91cHNba2V5XS5jb29yZGluYXRlcyA9IGdyb3Vwc1trZXldLmNvb3JkaW5hdGVzLmNvbmNhdChmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICAgICAgfVxuICAgICAgICBncm91cHNba2V5XS5wcm9wZXJ0aWVzLnB1c2goZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICB9XG5cbiAgICBtZXRhLmZlYXR1cmVFYWNoKGZjLCBmdW5jdGlvbiAoZmVhdHVyZSkge1xuICAgICAgICBpZiAoIWZlYXR1cmUuZ2VvbWV0cnkpIHJldHVybjtcbiAgICAgICAgaWYgKGdyb3Vwc1tmZWF0dXJlLmdlb21ldHJ5LnR5cGVdKSB7XG4gICAgICAgICAgICBhZGRUb0dyb3VwKGZlYXR1cmUsIGZlYXR1cmUuZ2VvbWV0cnkudHlwZSwgdHJ1ZSk7XG4gICAgICAgIH0gZWxzZSBpZiAobXVsdGlNYXBwaW5nW2ZlYXR1cmUuZ2VvbWV0cnkudHlwZV0pIHtcbiAgICAgICAgICAgIGFkZFRvR3JvdXAoZmVhdHVyZSwgbXVsdGlNYXBwaW5nW2ZlYXR1cmUuZ2VvbWV0cnkudHlwZV0sIGZhbHNlKTtcbiAgICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IE9iamVjdC5rZXlzKGdyb3VwcylcbiAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBncm91cHNba2V5XS5jb29yZGluYXRlcy5sZW5ndGg7XG4gICAgICAgICAgICB9KVxuICAgICAgICAgICAgLnNvcnQoKVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb2xsZWN0ZWRQcm9wZXJ0aWVzOiBncm91cHNba2V5XS5wcm9wZXJ0aWVzXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBrZXksXG4gICAgICAgICAgICAgICAgICAgICAgICBjb29yZGluYXRlczogZ3JvdXBzW2tleV0uY29vcmRpbmF0ZXNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9KVxuICAgIH07XG59O1xuIiwiLy8gMS4gcnVuIHRpbiBvbiBwb2ludHNcbi8vIDIuIGNhbGN1bGF0ZSBsZW50aCBvZiBhbGwgZWRnZXMgYW5kIGFyZWEgb2YgYWxsIHRyaWFuZ2xlc1xuLy8gMy4gcmVtb3ZlIHRyaWFuZ2xlcyB0aGF0IGZhaWwgdGhlIG1heCBsZW5ndGggdGVzdFxuLy8gNC4gYnVmZmVyIHRoZSByZXN1bHRzIHNsaWdodGx5XG4vLyA1LiBtZXJnZSB0aGUgcmVzdWx0c1xudmFyIHRpbiA9IHJlcXVpcmUoJ3R1cmYtdGluJyk7XG52YXIgdW5pb24gPSByZXF1aXJlKCd0dXJmLXVuaW9uJyk7XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIHJldHVybnMgYSBjb25jYXZlIGh1bGwgcG9seWdvbi5cbiAqXG4gKiBJbnRlcm5hbGx5LCB0aGlzIHVzZXMgW3R1cmYtdGluXShodHRwczovL2dpdGh1Yi5jb20vVHVyZmpzL3R1cmYtdGluKSB0byBnZW5lcmF0ZSBnZW9tZXRyaWVzLlxuICpcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9pbnQ+fSBwb2ludHMgaW5wdXQgcG9pbnRzXG4gKiBAcGFyYW0ge251bWJlcn0gbWF4RWRnZSB0aGUgc2l6ZSBvZiBhbiBlZGdlIG5lY2Vzc2FyeSBmb3IgcGFydCBvZiB0aGVcbiAqIGh1bGwgdG8gYmVjb21lIGNvbmNhdmUgKGluIG1pbGVzKVxuICogQHBhcmFtIHtzdHJpbmd9IHVuaXRzIHVzZWQgZm9yIG1heEVkZ2UgZGlzdGFuY2UgKG1pbGVzIG9yIGtpbG9tZXRlcnMpXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gYSBjb25jYXZlIGh1bGxcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBtYXhFZGdlIHBhcmFtZXRlciBpcyBtaXNzaW5nXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgdW5pdHMgcGFyYW1ldGVyIGlzIG1pc3NpbmdcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtcbiAqICAgICB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjYwMTIyNiwgNDQuNjQyNjQzXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNjMuNTkxNDQyLCA0NC42NTE0MzZdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy02My41ODA3OTksIDQ0LjY0ODc0OV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU3MzU4OSwgNDQuNjQxNzg4XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNjMuNTg3NjY1LCA0NC42NDUzM11cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTYzLjU5NTIxOCwgNDQuNjQ3NjVdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBodWxsID0gdHVyZi5jb25jYXZlKHBvaW50cywgMSwgJ21pbGVzJyk7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gcG9pbnRzLmZlYXR1cmVzLmNvbmNhdChodWxsKTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGNvbmNhdmUocG9pbnRzLCBtYXhFZGdlLCB1bml0cykge1xuICAgIGlmICh0eXBlb2YgbWF4RWRnZSAhPT0gJ251bWJlcicpIHRocm93IG5ldyBFcnJvcignbWF4RWRnZSBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcbiAgICBpZiAodHlwZW9mIHVuaXRzICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IEVycm9yKCd1bml0cyBwYXJhbWV0ZXIgaXMgcmVxdWlyZWQnKTtcblxuICAgIHZhciB0aW5Qb2x5cyA9IHRpbihwb2ludHMpO1xuICAgIHZhciBmaWx0ZXJlZFBvbHlzID0gdGluUG9seXMuZmVhdHVyZXMuZmlsdGVyKGZpbHRlclRyaWFuZ2xlcyk7XG4gICAgdGluUG9seXMuZmVhdHVyZXMgPSBmaWx0ZXJlZFBvbHlzO1xuXG4gICAgZnVuY3Rpb24gZmlsdGVyVHJpYW5nbGVzKHRyaWFuZ2xlKSB7XG4gICAgICAgIHZhciBwdDEgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVswXTtcbiAgICAgICAgdmFyIHB0MiA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzFdO1xuICAgICAgICB2YXIgcHQzID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMl07XG4gICAgICAgIHZhciBkaXN0MSA9IGRpc3RhbmNlKHB0MSwgcHQyLCB1bml0cyk7XG4gICAgICAgIHZhciBkaXN0MiA9IGRpc3RhbmNlKHB0MiwgcHQzLCB1bml0cyk7XG4gICAgICAgIHZhciBkaXN0MyA9IGRpc3RhbmNlKHB0MSwgcHQzLCB1bml0cyk7XG4gICAgICAgIHJldHVybiAoZGlzdDEgPD0gbWF4RWRnZSAmJiBkaXN0MiA8PSBtYXhFZGdlICYmIGRpc3QzIDw9IG1heEVkZ2UpO1xuICAgIH1cblxuICAgIHJldHVybiBtZXJnZSh0aW5Qb2x5cyk7XG59XG5cbmZ1bmN0aW9uIG1lcmdlKHBvbHlnb25zKSB7XG4gICAgdmFyIG1lcmdlZCA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocG9seWdvbnMuZmVhdHVyZXNbMF0pKSxcbiAgICAgICAgZmVhdHVyZXMgPSBwb2x5Z29ucy5mZWF0dXJlcztcblxuICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmZWF0dXJlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICB2YXIgcG9seSA9IGZlYXR1cmVzW2ldO1xuICAgICAgICBpZiAocG9seS5nZW9tZXRyeSkge1xuICAgICAgICAgICAgbWVyZ2VkID0gdW5pb24obWVyZ2VkLCBwb2x5KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gbWVyZ2VkO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNvbmNhdmU7XG4iLCJ2YXIgZWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaCxcbiAgICBjb252ZXhIdWxsID0gcmVxdWlyZSgnY29udmV4LWh1bGwnKSxcbiAgICBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcblxuLyoqXG4gKiBUYWtlcyBhIHNldCBvZiB7QGxpbmsgUG9pbnR8cG9pbnRzfSBhbmQgcmV0dXJucyBhXG4gKiBbY29udmV4IGh1bGxdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ29udmV4X2h1bGwpIHBvbHlnb24uXG4gKlxuICogSW50ZXJuYWxseSB0aGlzIHVzZXNcbiAqIHRoZSBbY29udmV4LWh1bGxdKGh0dHBzOi8vZ2l0aHViLmNvbS9taWtvbGFseXNlbmtvL2NvbnZleC1odWxsKSBtb2R1bGUgdGhhdFxuICogaW1wbGVtZW50cyBhIFttb25vdG9uZSBjaGFpbiBodWxsXShodHRwOi8vZW4ud2lraWJvb2tzLm9yZy93aWtpL0FsZ29yaXRobV9JbXBsZW1lbnRhdGlvbi9HZW9tZXRyeS9Db252ZXhfaHVsbC9Nb25vdG9uZV9jaGFpbikuXG4gKlxuICogQG5hbWUgY29udmV4XG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gZmVhdHVyZWNvbGxlY3Rpb24gaW5wdXQgcG9pbnRzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2x5Z29uPn0gYSBjb252ZXggaHVsbFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludHMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC4xOTUzMTIsIDQzLjc1NTIyNV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuNDA0MDUyLCA0My44NDI0NTExXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMC41Nzk4MzMsIDQzLjY1OTkyNF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMTAuMzYwMTA3LCA0My41MTY2ODhdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjE0MDM4LCA0My41ODgzNDhdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzEwLjE5NTMxMiwgNDMuNzU1MjI1XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgaHVsbCA9IHR1cmYuY29udmV4KHBvaW50cyk7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gcG9pbnRzLmZlYXR1cmVzLmNvbmNhdChodWxsKTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVjb2xsZWN0aW9uKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGVhY2goZmVhdHVyZWNvbGxlY3Rpb24sIGZ1bmN0aW9uIChjb29yZCkgeyBwb2ludHMucHVzaChjb29yZCk7IH0pO1xuICAgIHZhciBodWxsID0gY29udmV4SHVsbChwb2ludHMpO1xuICAgIGlmIChodWxsLmxlbmd0aCA+IDApIHtcbiAgICAgICAgdmFyIHJpbmcgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBodWxsLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICByaW5nLnB1c2gocG9pbnRzW2h1bGxbaV1bMF1dKTtcbiAgICAgICAgfVxuICAgICAgICByaW5nLnB1c2gocG9pbnRzW2h1bGxbaHVsbC5sZW5ndGggLSAxXVsxXV0pO1xuICAgICAgICByZXR1cm4gcG9seWdvbihbcmluZ10pO1xuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufTtcbiIsIi8vaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9IYXZlcnNpbmVfZm9ybXVsYVxuLy9odHRwOi8vd3d3Lm1vdmFibGUtdHlwZS5jby51ay9zY3JpcHRzL2xhdGxvbmcuaHRtbFxudmFyIGdldENvb3JkID0gcmVxdWlyZSgndHVyZi1pbnZhcmlhbnQnKS5nZXRDb29yZDtcbnZhciBoZWxwZXJzID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJyk7XG52YXIgcG9pbnQgPSBoZWxwZXJzLnBvaW50O1xudmFyIGRpc3RhbmNlVG9SYWRpYW5zID0gaGVscGVycy5kaXN0YW5jZVRvUmFkaWFucztcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBQb2ludH0gYW5kIGNhbGN1bGF0ZXMgdGhlIGxvY2F0aW9uIG9mIGEgZGVzdGluYXRpb24gcG9pbnQgZ2l2ZW4gYSBkaXN0YW5jZSBpbiBkZWdyZWVzLCByYWRpYW5zLCBtaWxlcywgb3Iga2lsb21ldGVyczsgYW5kIGJlYXJpbmcgaW4gZGVncmVlcy4gVGhpcyB1c2VzIHRoZSBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpIHRvIGFjY291bnQgZm9yIGdsb2JhbCBjdXJ2YXR1cmUuXG4gKlxuICogQG5hbWUgZGVzdGluYXRpb25cbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IGZyb20gc3RhcnRpbmcgcG9pbnRcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBkaXN0YW5jZSBmcm9tIHRoZSBzdGFydGluZyBwb2ludFxuICogQHBhcmFtIHtudW1iZXJ9IGJlYXJpbmcgcmFuZ2luZyBmcm9tIC0xODAgdG8gMTgwXG4gKiBAcGFyYW0ge1N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIG1pbGVzLCBraWxvbWV0ZXJzLCBkZWdyZWVzLCBvciByYWRpYW5zXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxQb2ludD59IGRlc3RpbmF0aW9uIHBvaW50XG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjMGYwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzQzLCAzOS45ODRdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgZGlzdGFuY2UgPSA1MDtcbiAqIHZhciBiZWFyaW5nID0gOTA7XG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciBkZXN0aW5hdGlvbiA9IHR1cmYuZGVzdGluYXRpb24ocG9pbnQsIGRpc3RhbmNlLCBiZWFyaW5nLCB1bml0cyk7XG4gKiBkZXN0aW5hdGlvbi5wcm9wZXJ0aWVzWydtYXJrZXItY29sb3InXSA9ICcjZjAwJztcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2ludCwgZGVzdGluYXRpb25dXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tLCBkaXN0YW5jZSwgYmVhcmluZywgdW5pdHMpIHtcbiAgICB2YXIgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgcmFkaWFuczJkZWdyZWVzID0gMTgwIC8gTWF0aC5QSTtcbiAgICB2YXIgY29vcmRpbmF0ZXMxID0gZ2V0Q29vcmQoZnJvbSk7XG4gICAgdmFyIGxvbmdpdHVkZTEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMF07XG4gICAgdmFyIGxhdGl0dWRlMSA9IGRlZ3JlZXMycmFkaWFucyAqIGNvb3JkaW5hdGVzMVsxXTtcbiAgICB2YXIgYmVhcmluZ19yYWQgPSBkZWdyZWVzMnJhZGlhbnMgKiBiZWFyaW5nO1xuXG4gICAgdmFyIHJhZGlhbnMgPSBkaXN0YW5jZVRvUmFkaWFucyhkaXN0YW5jZSwgdW5pdHMpO1xuXG4gICAgdmFyIGxhdGl0dWRlMiA9IE1hdGguYXNpbihNYXRoLnNpbihsYXRpdHVkZTEpICogTWF0aC5jb3MocmFkaWFucykgK1xuICAgICAgICBNYXRoLmNvcyhsYXRpdHVkZTEpICogTWF0aC5zaW4ocmFkaWFucykgKiBNYXRoLmNvcyhiZWFyaW5nX3JhZCkpO1xuICAgIHZhciBsb25naXR1ZGUyID0gbG9uZ2l0dWRlMSArIE1hdGguYXRhbjIoTWF0aC5zaW4oYmVhcmluZ19yYWQpICpcbiAgICAgICAgTWF0aC5zaW4ocmFkaWFucykgKiBNYXRoLmNvcyhsYXRpdHVkZTEpLFxuICAgICAgICBNYXRoLmNvcyhyYWRpYW5zKSAtIE1hdGguc2luKGxhdGl0dWRlMSkgKiBNYXRoLnNpbihsYXRpdHVkZTIpKTtcblxuICAgIHJldHVybiBwb2ludChbcmFkaWFuczJkZWdyZWVzICogbG9uZ2l0dWRlMiwgcmFkaWFuczJkZWdyZWVzICogbGF0aXR1ZGUyXSk7XG59O1xuIiwiLy8gZGVwZW5kIG9uIGpzdHMgZm9yIG5vdyBodHRwczovL2dpdGh1Yi5jb20vYmpvcm5oYXJydGVsbC9qc3RzL2Jsb2IvbWFzdGVyL2V4YW1wbGVzL292ZXJsYXkuaHRtbFxudmFyIGpzdHMgPSByZXF1aXJlKCdqc3RzJyk7XG5cbi8qKlxuICogRmluZHMgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0d28ge0BsaW5rIFBvbHlnb258cG9seWdvbnN9IGJ5IGNsaXBwaW5nIHRoZSBzZWNvbmRcbiAqIHBvbHlnb24gZnJvbSB0aGUgZmlyc3QuXG4gKlxuICogQG5hbWUgZGlmZmVyZW5jZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5MSBpbnB1dCBQb2x5Z29uIGZlYXVyZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5MiBQb2x5Z29uIGZlYXR1cmUgdG8gZGlmZmVyZW5jZSBmcm9tIGBwb2x5MWBcbiAqIEByZXR1cm4ge0ZlYXR1cmU8UG9seWdvbj59IGEgUG9seWdvbiBmZWF0dXJlIHNob3dpbmcgdGhlIGFyZWEgb2YgYHBvbHkxYCBleGNsdWRpbmcgdGhlIGFyZWEgb2YgYHBvbHkyYFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy41OTY3MTFdLFxuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy40NTgyMDddLFxuICogICAgICAgWy00Ni41NjAwNTgsIC0yMy40NTgyMDddLFxuICogICAgICAgWy00Ni41NjAwNTgsIC0yMy41OTY3MTFdLFxuICogICAgICAgWy00Ni43Mzg1ODYsIC0yMy41OTY3MTFdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwMGZcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy00Ni42NTAwMDksIC0yMy42MzEzMTRdLFxuICogICAgICAgWy00Ni42NTAwMDksIC0yMy41MjM3XSxcbiAqICAgICAgIFstNDYuNTA5MjQ2LCAtMjMuNTIzN10sXG4gKiAgICAgICBbLTQ2LjUwOTI0NiwgLTIzLjYzMTMxNF0sXG4gKiAgICAgICBbLTQ2LjY1MDAwOSwgLTIzLjYzMTMxNF1cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBkaWZmZXJlbmNlZCA9IHR1cmYuZGlmZmVyZW5jZShwb2x5MSwgcG9seTIpO1xuICogZGlmZmVyZW5jZWQucHJvcGVydGllcy5maWxsID0gJyNmMDAnO1xuICpcbiAqIHZhciBwb2x5Z29ucyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbcG9seTEsIHBvbHkyXVxuICogfTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICpcbiAqIC8vPWRpZmZlcmVuY2VkXG4gKi9cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgdmFyIHBvbHkxID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwMSkpO1xuICAgIHZhciBwb2x5MiA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocDIpKTtcbiAgICBpZiAocG9seTEudHlwZSAhPT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHBvbHkxID0ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgcHJvcGVydGllczoge30sXG4gICAgICAgICAgICBnZW9tZXRyeTogcG9seTFcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHBvbHkyLnR5cGUgIT09ICdGZWF0dXJlJykge1xuICAgICAgICBwb2x5MiA9IHtcbiAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICAgICAgZ2VvbWV0cnk6IHBvbHkyXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgYSA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KHBvbHkxLmdlb21ldHJ5KSk7XG4gICAgdmFyIGIgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShwb2x5Mi5nZW9tZXRyeSkpO1xuICAgIHZhciBkaWZmZXJlbmNlZCA9IGEuZGlmZmVyZW5jZShiKTtcblxuICAgIGlmIChkaWZmZXJlbmNlZC5pc0VtcHR5KCkpIHJldHVybiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgd3JpdGVyID0gbmV3IGpzdHMuaW8uR2VvSlNPTldyaXRlcigpO1xuICAgIHZhciBnZW9qc29uR2VvbWV0cnkgPSB3cml0ZXIud3JpdGUoZGlmZmVyZW5jZWQpO1xuXG4gICAgcG9seTEuZ2VvbWV0cnkgPSBkaWZmZXJlbmNlZDtcblxuICAgIHJldHVybiB7XG4gICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgcHJvcGVydGllczogcG9seTEucHJvcGVydGllcyxcbiAgICAgICAgZ2VvbWV0cnk6IGdlb2pzb25HZW9tZXRyeVxuICAgIH07XG59O1xuIiwidmFyIGdldENvb3JkID0gcmVxdWlyZSgndHVyZi1pbnZhcmlhbnQnKS5nZXRDb29yZDtcbnZhciByYWRpYW5zVG9EaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnJhZGlhbnNUb0Rpc3RhbmNlO1xuLy9odHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0hhdmVyc2luZV9mb3JtdWxhXG4vL2h0dHA6Ly93d3cubW92YWJsZS10eXBlLmNvLnVrL3NjcmlwdHMvbGF0bG9uZy5odG1sXG5cbi8qKlxuICogQ2FsY3VsYXRlcyB0aGUgZGlzdGFuY2UgYmV0d2VlbiB0d28ge0BsaW5rIFBvaW50fHBvaW50c30gaW4gZGVncmVlcywgcmFkaWFucyxcbiAqIG1pbGVzLCBvciBraWxvbWV0ZXJzLiBUaGlzIHVzZXMgdGhlXG4gKiBbSGF2ZXJzaW5lIGZvcm11bGFdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSGF2ZXJzaW5lX2Zvcm11bGEpXG4gKiB0byBhY2NvdW50IGZvciBnbG9iYWwgY3VydmF0dXJlLlxuICpcbiAqIEBuYW1lIGRpc3RhbmNlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBmcm9tIG9yaWdpbiBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gdG8gZGVzdGluYXRpb24gcG9pbnRcbiAqIEBwYXJhbSB7U3RyaW5nfSBbdW5pdHM9a2lsb21ldGVyc10gY2FuIGJlIGRlZ3JlZXMsIHJhZGlhbnMsIG1pbGVzLCBvciBraWxvbWV0ZXJzXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IGRpc3RhbmNlIGJldHdlZW4gdGhlIHR3byBwb2ludHNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZnJvbSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjM0MywgMzkuOTg0XVxuICogICB9XG4gKiB9O1xuICogdmFyIHRvID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuNTM0LCAzOS4xMjNdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgdW5pdHMgPSBcIm1pbGVzXCI7XG4gKlxuICogdmFyIHBvaW50cyA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbZnJvbSwgdG9dXG4gKiB9O1xuICpcbiAqIC8vPXBvaW50c1xuICpcbiAqIHZhciBkaXN0YW5jZSA9IHR1cmYuZGlzdGFuY2UoZnJvbSwgdG8sIHVuaXRzKTtcbiAqXG4gKiAvLz1kaXN0YW5jZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmcm9tLCB0bywgdW5pdHMpIHtcbiAgICB2YXIgZGVncmVlczJyYWRpYW5zID0gTWF0aC5QSSAvIDE4MDtcbiAgICB2YXIgY29vcmRpbmF0ZXMxID0gZ2V0Q29vcmQoZnJvbSk7XG4gICAgdmFyIGNvb3JkaW5hdGVzMiA9IGdldENvb3JkKHRvKTtcbiAgICB2YXIgZExhdCA9IGRlZ3JlZXMycmFkaWFucyAqIChjb29yZGluYXRlczJbMV0gLSBjb29yZGluYXRlczFbMV0pO1xuICAgIHZhciBkTG9uID0gZGVncmVlczJyYWRpYW5zICogKGNvb3JkaW5hdGVzMlswXSAtIGNvb3JkaW5hdGVzMVswXSk7XG4gICAgdmFyIGxhdDEgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczFbMV07XG4gICAgdmFyIGxhdDIgPSBkZWdyZWVzMnJhZGlhbnMgKiBjb29yZGluYXRlczJbMV07XG5cbiAgICB2YXIgYSA9IE1hdGgucG93KE1hdGguc2luKGRMYXQgLyAyKSwgMikgK1xuICAgICAgICAgIE1hdGgucG93KE1hdGguc2luKGRMb24gLyAyKSwgMikgKiBNYXRoLmNvcyhsYXQxKSAqIE1hdGguY29zKGxhdDIpO1xuXG4gICAgcmV0dXJuIHJhZGlhbnNUb0Rpc3RhbmNlKDIgKiBNYXRoLmF0YW4yKE1hdGguc3FydChhKSwgTWF0aC5zcXJ0KDEgLSBhKSksIHVuaXRzKTtcbn07XG4iLCJ2YXIgYmJveCA9IHJlcXVpcmUoJ3R1cmYtYmJveCcpO1xudmFyIGJib3hQb2x5Z29uID0gcmVxdWlyZSgndHVyZi1iYm94LXBvbHlnb24nKTtcblxuLyoqXG4gKiBUYWtlcyBhbnkgbnVtYmVyIG9mIGZlYXR1cmVzIGFuZCByZXR1cm5zIGEgcmVjdGFuZ3VsYXIge0BsaW5rIFBvbHlnb259IHRoYXQgZW5jb21wYXNzZXMgYWxsIHZlcnRpY2VzLlxuICpcbiAqIEBuYW1lIGVudmVsb3BlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufSBmYyBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybiB7RmVhdHVyZTxQb2x5Z29uPn0gYSByZWN0YW5ndWxhciBQb2x5Z29uIGZlYXR1cmUgdGhhdCBlbmNvbXBhc3NlcyBhbGwgdmVydGljZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZmMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgICAgIFwibmFtZVwiOiBcIkxvY2F0aW9uIEFcIlxuICogICAgICAgfSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNzUuMzQzLCAzOS45ODRdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHtcbiAqICAgICAgICAgXCJuYW1lXCI6IFwiTG9jYXRpb24gQlwiXG4gKiAgICAgICB9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy03NS44MzMsIDM5LjI4NF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge1xuICogICAgICAgICBcIm5hbWVcIjogXCJMb2NhdGlvbiBDXCJcbiAqICAgICAgIH0sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjUzNCwgMzkuMTIzXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgZW52ZWxvcGVkID0gdHVyZi5lbnZlbG9wZShmYyk7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gZmMuZmVhdHVyZXMuY29uY2F0KGVudmVsb3BlZCk7XG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIGJib3hQb2x5Z29uKGJib3goZmVhdHVyZXMpKTtcbn07XG4iLCJ2YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBlYWNoID0gcmVxdWlyZSgndHVyZi1tZXRhJykuY29vcmRFYWNoO1xudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG5cbi8qKlxuICogVGFrZXMgYSBmZWF0dXJlIG9yIHNldCBvZiBmZWF0dXJlcyBhbmQgcmV0dXJucyBhbGwgcG9zaXRpb25zIGFzXG4gKiB7QGxpbmsgUG9pbnR8cG9pbnRzfS5cbiAqXG4gKiBAbmFtZSBleHBsb2RlXG4gKiBAcGFyYW0geyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gZ2VvanNvbiBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248cG9pbnQ+fSBwb2ludHMgcmVwcmVzZW50aW5nIHRoZSBleHBsb2RlZCBpbnB1dCBmZWF0dXJlc1xuICogQHRocm93cyB7RXJyb3J9IGlmIGl0IGVuY291bnRlcnMgYW4gdW5rbm93biBnZW9tZXRyeSB0eXBlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWzE3Ny40MzQ2OTIsIC0xNy43NzUxN10sXG4gKiAgICAgICBbMTc3LjQwMjA3NiwgLTE3Ljc3OTA5M10sXG4gKiAgICAgICBbMTc3LjM4MDc5LCAtMTcuODAzOTM3XSxcbiAqICAgICAgIFsxNzcuNDAyNDIsIC0xNy44MjYxNjRdLFxuICogICAgICAgWzE3Ny40Mzg0NjgsIC0xNy44MjQ4NTddLFxuICogICAgICAgWzE3Ny40NTQ5NDgsIC0xNy43OTY3NDZdLFxuICogICAgICAgWzE3Ny40MzQ2OTIsIC0xNy43NzUxN11cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBwb2ludHMgPSB0dXJmLmV4cGxvZGUocG9seSk7XG4gKlxuICogLy89cG9seVxuICpcbiAqIC8vPXBvaW50c1xuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChnZW9qc29uKSB7XG4gICAgdmFyIHBvaW50cyA9IFtdO1xuICAgIGVhY2goZ2VvanNvbiwgZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgIHBvaW50cy5wdXNoKHBvaW50KGNvb3JkKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIGZlYXR1cmVDb2xsZWN0aW9uKHBvaW50cyk7XG59O1xuIiwidmFyIGNvb3JkRWFjaCA9IHJlcXVpcmUoJ3R1cmYtbWV0YScpLmNvb3JkRWFjaDtcblxuLyoqXG4gKiBUYWtlcyBpbnB1dCBmZWF0dXJlcyBhbmQgZmxpcHMgYWxsIG9mIHRoZWlyIGNvb3JkaW5hdGVzXG4gKiBmcm9tIGBbeCwgeV1gIHRvIGBbeSwgeF1gLlxuICpcbiAqIEBuYW1lIGZsaXBcbiAqIEBwYXJhbSB7KEZlYXR1cmV8RmVhdHVyZUNvbGxlY3Rpb24pfSBpbnB1dCBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybnMgeyhGZWF0dXJlfEZlYXR1cmVDb2xsZWN0aW9uKX0gYSBmZWF0dXJlIG9yIHNldCBvZiBmZWF0dXJlcyBvZiB0aGUgc2FtZSB0eXBlIGFzIGBpbnB1dGAgd2l0aCBmbGlwcGVkIGNvb3JkaW5hdGVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHNlcmJpYSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbMjAuNTY2NDA2LCA0My40MjEwMDhdXG4gKiAgIH1cbiAqIH07XG4gKlxuICogLy89c2VyYmlhXG4gKlxuICogdmFyIHNhdWRpQXJhYmlhID0gdHVyZi5mbGlwKHNlcmJpYSk7XG4gKlxuICogLy89c2F1ZGlBcmFiaWFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBmbGlwKGlucHV0KSB7XG4gICAgLy8gZW5zdXJlIHRoYXQgd2UgZG9uJ3QgbW9kaWZ5IGZlYXR1cmVzIGluLXBsYWNlIGFuZCBjaGFuZ2VzIHRvIHRoZVxuICAgIC8vIG91dHB1dCBkbyBub3QgY2hhbmdlIHRoZSBwcmV2aW91cyBmZWF0dXJlLCBpbmNsdWRpbmcgY2hhbmdlcyB0byBuZXN0ZWRcbiAgICAvLyBwcm9wZXJ0aWVzLlxuICAgIGlucHV0ID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShpbnB1dCkpO1xuXG4gICAgY29vcmRFYWNoKGlucHV0LCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgY29vcmQucmV2ZXJzZSgpO1xuICAgIH0pO1xuICAgIHJldHVybiBpbnB1dDtcbn07XG4iLCJ2YXIgcG9pbnQgPSByZXF1aXJlKCd0dXJmLXBvaW50Jyk7XG5cbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGEgY2VsbCBkZXB0aCBhbmQgcmV0dXJucyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gb2Yge0BsaW5rIFBvaW50fSBmZWF0dXJlcyBpbiBhIGdyaWQuXG4gKlxuICogQG1vZHVsZSB0dXJmL2dyaWRcbiAqIEBjYXRlZ29yeSBpbnRlcnBvbGF0aW9uXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGV4dGVudCBleHRlbnQgaW4gW21pblgsIG1pblksIG1heFgsIG1heFldIG9yZGVyXG4gKiBAcGFyYW0ge051bWJlcn0gZGVwdGggaG93IG1hbnkgY2VsbHMgdG8gb3V0cHV0XG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbn0gZ3JpZCBhcyBGZWF0dXJlQ29sbGVjdGlvbiB3aXRoIHtAbGluayBQb2ludH0gZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZXh0ZW50ID0gWy03MC44MjMzNjQsIC0zMy41NTM5ODQsIC03MC40NzMxNzUsIC0zMy4zMDI5ODZdO1xuICogdmFyIGRlcHRoID0gMTA7XG4gKlxuICogdmFyIGdyaWQgPSB0dXJmLmdyaWQoZXh0ZW50LCBkZXB0aCk7XG4gKlxuICogLy89Z3JpZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGV4dGVudHMsIGRlcHRoKSB7XG4gIHZhciB4bWluID0gZXh0ZW50c1swXTtcbiAgdmFyIHltaW4gPSBleHRlbnRzWzFdO1xuICB2YXIgeG1heCA9IGV4dGVudHNbMl07XG4gIHZhciB5bWF4ID0gZXh0ZW50c1szXTtcbiAgdmFyIGludGVydmFsID0gKHhtYXggLSB4bWluKSAvIGRlcHRoO1xuICB2YXIgY29vcmRzID0gW107XG4gIHZhciBmYyA9IHtcbiAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgIGZlYXR1cmVzOiBbXVxuICB9O1xuXG4gIGZvciAodmFyIHg9MDsgeDw9ZGVwdGg7IHgrKyl7XG4gICAgZm9yICh2YXIgeT0wO3k8PWRlcHRoOyB5Kyspe1xuICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2ludChbKHggKiBpbnRlcnZhbCkgKyB4bWluLCAoeSAqIGludGVydmFsKSArIHltaW5dKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBmYztcbn1cbiIsIi8qKlxuICogV3JhcHMgYSBHZW9KU09OIHtAbGluayBHZW9tZXRyeX0gaW4gYSBHZW9KU09OIHtAbGluayBGZWF0dXJlfS5cbiAqXG4gKiBAbmFtZSBmZWF0dXJlXG4gKiBAcGFyYW0ge0dlb21ldHJ5fSBnZW9tZXRyeSBpbnB1dCBnZW9tZXRyeVxuICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGlucHV0IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGdlb21ldHJ5ID0ge1xuICogICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgICA2Ny41LFxuICogICAgICAgIDMyLjg0MjY3MzYzMTk1NDMxXG4gKiAgICAgIF1cbiAqICAgIH1cbiAqXG4gKiB2YXIgZmVhdHVyZSA9IHR1cmYuZmVhdHVyZShnZW9tZXRyeSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICovXG5mdW5jdGlvbiBmZWF0dXJlKGdlb21ldHJ5LCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzIHx8IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvbWV0cnlcbiAgICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cy5mZWF0dXJlID0gZmVhdHVyZTtcblxuLyoqXG4gKiBUYWtlcyBjb29yZGluYXRlcyBhbmQgcHJvcGVydGllcyAob3B0aW9uYWwpIGFuZCByZXR1cm5zIGEgbmV3IHtAbGluayBQb2ludH0gZmVhdHVyZS5cbiAqXG4gKiBAbmFtZSBwb2ludFxuICogQHBhcmFtIHtudW1iZXJbXX0gY29vcmRpbmF0ZXMgbG9uZ2l0dWRlLCBsYXRpdHVkZSBwb3NpdGlvbiAoZWFjaCBpbiBkZWNpbWFsIGRlZ3JlZXMpXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IHRoYXQgaXMgdXNlZCBhcyB0aGUge0BsaW5rIEZlYXR1cmV9J3NcbiAqIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvaW50Pn0gYSBQb2ludCBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0MSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXB0MVxuICovXG5tb2R1bGUuZXhwb3J0cy5wb2ludCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShjb29yZGluYXRlcykpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICAgIGlmIChjb29yZGluYXRlcy5sZW5ndGggPCAyKSB0aHJvdyBuZXcgRXJyb3IoJ0Nvb3JkaW5hdGVzIG11c3QgYmUgYXQgbGVhc3QgMiBudW1iZXJzIGxvbmcnKTtcbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlcy5zbGljZSgpXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIFRha2VzIGFuIGFycmF5IG9mIExpbmVhclJpbmdzIGFuZCBvcHRpb25hbGx5IGFuIHtAbGluayBPYmplY3R9IHdpdGggcHJvcGVydGllcyBhbmQgcmV0dXJucyBhIHtAbGluayBQb2x5Z29ufSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHBvbHlnb25cbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8QXJyYXk8bnVtYmVyPj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBMaW5lYXJSaW5nc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGEgcHJvcGVydGllcyBvYmplY3RcbiAqIEByZXR1cm5zIHtGZWF0dXJlPFBvbHlnb24+fSBhIFBvbHlnb24gZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IHRocm93IGFuIGVycm9yIGlmIGEgTGluZWFyUmluZyBvZiB0aGUgcG9seWdvbiBoYXMgdG9vIGZldyBwb3NpdGlvbnNcbiAqIG9yIGlmIGEgTGluZWFyUmluZyBvZiB0aGUgUG9seWdvbiBkb2VzIG5vdCBoYXZlIG1hdGNoaW5nIFBvc2l0aW9ucyBhdCB0aGVcbiAqIGJlZ2lubmluZyAmIGVuZC5cbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucG9seWdvbihbW1xuICogIFstMi4yNzU1NDMsIDUzLjQ2NDU0N10sXG4gKiAgWy0yLjI3NTU0MywgNTMuNDg5MjcxXSxcbiAqICBbLTIuMjE1MTE4LCA1My40ODkyNzFdLFxuICogIFstMi4yMTUxMTgsIDUzLjQ2NDU0N10sXG4gKiAgWy0yLjI3NTU0MywgNTMuNDY0NTQ3XVxuICogXV0sIHsgbmFtZTogJ3BvbHkxJywgcG9wdWxhdGlvbjogNDAwfSk7XG4gKlxuICogLy89cG9seWdvblxuICovXG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG5cbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcmluZyA9IGNvb3JkaW5hdGVzW2ldO1xuICAgICAgICBpZiAocmluZy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VhY2ggTGluZWFyUmluZyBvZiBhIFBvbHlnb24gbXVzdCBoYXZlIDQgb3IgbW9yZSBQb3NpdGlvbnMuJyk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCByaW5nW3JpbmcubGVuZ3RoIC0gMV0ubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgICAgIGlmIChyaW5nW3JpbmcubGVuZ3RoIC0gMV1bal0gIT09IHJpbmdbMF1bal0pIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZpcnN0IGFuZCBsYXN0IFBvc2l0aW9uIGFyZSBub3QgZXF1aXZhbGVudC4nKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICBjb29yZGluYXRlczogY29vcmRpbmF0ZXNcbiAgICB9LCBwcm9wZXJ0aWVzKTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBMaW5lU3RyaW5nfSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGxpbmVTdHJpbmdcbiAqIEBwYXJhbSB7QXJyYXk8QXJyYXk8bnVtYmVyPj59IGNvb3JkaW5hdGVzIGFuIGFycmF5IG9mIFBvc2l0aW9uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBhIExpbmVTdHJpbmcgZmVhdHVyZVxuICogQHRocm93cyB7RXJyb3J9IGlmIG5vIGNvb3JkaW5hdGVzIGFyZSBwYXNzZWRcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZXN0cmluZzEgPSB0dXJmLmxpbmVTdHJpbmcoW1xuICpcdFstMjEuOTY0NDE2LCA2NC4xNDgyMDNdLFxuICpcdFstMjEuOTU2MTc2LCA2NC4xNDEzMTZdLFxuICpcdFstMjEuOTM5MDEsIDY0LjEzNTkyNF0sXG4gKlx0Wy0yMS45MjczMzcsIDY0LjEzNjY3M11cbiAqIF0pO1xuICogdmFyIGxpbmVzdHJpbmcyID0gdHVyZi5saW5lU3RyaW5nKFtcbiAqXHRbLTIxLjkyOTA1NCwgNjQuMTI3OTg1XSxcbiAqXHRbLTIxLjkxMjkxOCwgNjQuMTM0NzI2XSxcbiAqXHRbLTIxLjkxNjAwNywgNjQuMTQxMDE2XSxcbiAqIFx0Wy0yMS45MzAwODQsIDY0LjE0NDQ2XVxuICogXSwge25hbWU6ICdsaW5lIDEnLCBkaXN0YW5jZTogMTQ1fSk7XG4gKlxuICogLy89bGluZXN0cmluZzFcbiAqXG4gKiAvLz1saW5lc3RyaW5nMlxuICovXG5tb2R1bGUuZXhwb3J0cy5saW5lU3RyaW5nID0gZnVuY3Rpb24gKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgaWYgKCFjb29yZGluYXRlcykge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIGNvb3JkaW5hdGVzIHBhc3NlZCcpO1xuICAgIH1cbiAgICByZXR1cm4gZmVhdHVyZSh7XG4gICAgICAgIHR5cGU6ICdMaW5lU3RyaW5nJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIFRha2VzIG9uZSBvciBtb3JlIHtAbGluayBGZWF0dXJlfEZlYXR1cmVzfSBhbmQgY3JlYXRlcyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0uXG4gKlxuICogQG5hbWUgZmVhdHVyZUNvbGxlY3Rpb25cbiAqIEBwYXJhbSB7RmVhdHVyZVtdfSBmZWF0dXJlcyBpbnB1dCBmZWF0dXJlc1xuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9ufSBhIEZlYXR1cmVDb2xsZWN0aW9uIG9mIGlucHV0IGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIGZlYXR1cmVzID0gW1xuICogIHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0sIHtuYW1lOiAnTG9jYXRpb24gQSd9KSxcbiAqICB0dXJmLnBvaW50KFstNzUuODMzLCAzOS4yODRdLCB7bmFtZTogJ0xvY2F0aW9uIEInfSksXG4gKiAgdHVyZi5wb2ludChbLTc1LjUzNCwgMzkuMTIzXSwge25hbWU6ICdMb2NhdGlvbiBDJ30pXG4gKiBdO1xuICpcbiAqIHZhciBmYyA9IHR1cmYuZmVhdHVyZUNvbGxlY3Rpb24oZmVhdHVyZXMpO1xuICpcbiAqIC8vPWZjXG4gKi9cbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVDb2xsZWN0aW9uID0gZnVuY3Rpb24gKGZlYXR1cmVzKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgZmVhdHVyZXM6IGZlYXR1cmVzXG4gICAgfTtcbn07XG5cbi8qKlxuICogQ3JlYXRlcyBhIHtAbGluayBGZWF0dXJlPE11bHRpTGluZVN0cmluZz59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlMaW5lU3RyaW5nXG4gKiBAcGFyYW0ge0FycmF5PEFycmF5PEFycmF5PG51bWJlcj4+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgTGluZVN0cmluZ3NcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxNdWx0aUxpbmVTdHJpbmc+fSBhIE11bHRpTGluZVN0cmluZyBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aUxpbmUgPSB0dXJmLm11bHRpTGluZVN0cmluZyhbW1swLDBdLFsxMCwxMF1dXSk7XG4gKlxuICogLy89bXVsdGlMaW5lXG4gKlxuICovXG5tb2R1bGUuZXhwb3J0cy5tdWx0aUxpbmVTdHJpbmcgPSBmdW5jdGlvbiAoY29vcmRpbmF0ZXMsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoIWNvb3JkaW5hdGVzKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTm8gY29vcmRpbmF0ZXMgcGFzc2VkJyk7XG4gICAgfVxuICAgIHJldHVybiBmZWF0dXJlKHtcbiAgICAgICAgdHlwZTogJ011bHRpTGluZVN0cmluZycsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuLyoqXG4gKiBDcmVhdGVzIGEge0BsaW5rIEZlYXR1cmU8TXVsdGlQb2ludD59IGJhc2VkIG9uIGFcbiAqIGNvb3JkaW5hdGUgYXJyYXkuIFByb3BlcnRpZXMgY2FuIGJlIGFkZGVkIG9wdGlvbmFsbHkuXG4gKlxuICogQG5hbWUgbXVsdGlQb2ludFxuICogQHBhcmFtIHtBcnJheTxBcnJheTxudW1iZXI+Pn0gY29vcmRpbmF0ZXMgYW4gYXJyYXkgb2YgUG9zaXRpb25zXG4gKiBAcGFyYW0ge09iamVjdD19IHByb3BlcnRpZXMgYW4gT2JqZWN0IG9mIGtleS12YWx1ZSBwYWlycyB0byBhZGQgYXMgcHJvcGVydGllc1xuICogQHJldHVybnMge0ZlYXR1cmU8TXVsdGlQb2ludD59IGEgTXVsdGlQb2ludCBmZWF0dXJlXG4gKiBAdGhyb3dzIHtFcnJvcn0gaWYgbm8gY29vcmRpbmF0ZXMgYXJlIHBhc3NlZFxuICogQGV4YW1wbGVcbiAqIHZhciBtdWx0aVB0ID0gdHVyZi5tdWx0aVBvaW50KFtbMCwwXSxbMTAsMTBdXSk7XG4gKlxuICogLy89bXVsdGlQdFxuICpcbiAqL1xubW9kdWxlLmV4cG9ydHMubXVsdGlQb2ludCA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnTXVsdGlQb2ludCcsXG4gICAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxNdWx0aVBvbHlnb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIG11bHRpUG9seWdvblxuICogQHBhcmFtIHtBcnJheTxBcnJheTxBcnJheTxBcnJheTxudW1iZXI+Pj4+fSBjb29yZGluYXRlcyBhbiBhcnJheSBvZiBQb2x5Z29uc1xuICogQHBhcmFtIHtPYmplY3Q9fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCBvZiBrZXktdmFsdWUgcGFpcnMgdG8gYWRkIGFzIHByb3BlcnRpZXNcbiAqIEByZXR1cm5zIHtGZWF0dXJlPE11bHRpUG9seWdvbj59IGEgbXVsdGlwb2x5Z29uIGZlYXR1cmVcbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiBubyBjb29yZGluYXRlcyBhcmUgcGFzc2VkXG4gKiBAZXhhbXBsZVxuICogdmFyIG11bHRpUG9seSA9IHR1cmYubXVsdGlQb2x5Z29uKFtbW1swLDBdLFswLDEwXSxbMTAsMTBdLFsxMCwwXSxbMCwwXV1dKTtcbiAqXG4gKiAvLz1tdWx0aVBvbHlcbiAqXG4gKi9cbm1vZHVsZS5leHBvcnRzLm11bHRpUG9seWdvbiA9IGZ1bmN0aW9uIChjb29yZGluYXRlcywgcHJvcGVydGllcykge1xuICAgIGlmICghY29vcmRpbmF0ZXMpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdObyBjb29yZGluYXRlcyBwYXNzZWQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnTXVsdGlQb2x5Z29uJyxcbiAgICAgICAgY29vcmRpbmF0ZXM6IGNvb3JkaW5hdGVzXG4gICAgfSwgcHJvcGVydGllcyk7XG59O1xuXG4vKipcbiAqIENyZWF0ZXMgYSB7QGxpbmsgRmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBiYXNlZCBvbiBhXG4gKiBjb29yZGluYXRlIGFycmF5LiBQcm9wZXJ0aWVzIGNhbiBiZSBhZGRlZCBvcHRpb25hbGx5LlxuICpcbiAqIEBuYW1lIGdlb21ldHJ5Q29sbGVjdGlvblxuICogQHBhcmFtIHtBcnJheTx7R2VvbWV0cnl9Pn0gZ2VvbWV0cmllcyBhbiBhcnJheSBvZiBHZW9KU09OIEdlb21ldHJpZXNcbiAqIEBwYXJhbSB7T2JqZWN0PX0gcHJvcGVydGllcyBhbiBPYmplY3Qgb2Yga2V5LXZhbHVlIHBhaXJzIHRvIGFkZCBhcyBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJucyB7RmVhdHVyZTxHZW9tZXRyeUNvbGxlY3Rpb24+fSBhIGdlb21ldHJ5Y29sbGVjdGlvbiBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0ID0ge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsxMDAsIDBdXG4gKiAgICAgfTtcbiAqIHZhciBsaW5lID0ge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsgWzEwMSwgMF0sIFsxMDIsIDFdIF1cbiAqICAgfTtcbiAqIHZhciBjb2xsZWN0aW9uID0gdHVyZi5nZW9tZXRyeWNvbGxlY3Rpb24oW1swLDBdLFsxMCwxMF1dKTtcbiAqXG4gKiAvLz1jb2xsZWN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5Q29sbGVjdGlvbiA9IGZ1bmN0aW9uIChnZW9tZXRyaWVzLCBwcm9wZXJ0aWVzKSB7XG4gICAgcmV0dXJuIGZlYXR1cmUoe1xuICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgZ2VvbWV0cmllczogZ2VvbWV0cmllc1xuICAgIH0sIHByb3BlcnRpZXMpO1xufTtcblxudmFyIGZhY3RvcnMgPSB7XG4gICAgbWlsZXM6IDM5NjAsXG4gICAgbmF1dGljYWxtaWxlczogMzQ0MS4xNDUsXG4gICAgZGVncmVlczogNTcuMjk1Nzc5NSxcbiAgICByYWRpYW5zOiAxLFxuICAgIGluY2hlczogMjUwOTA1NjAwLFxuICAgIHlhcmRzOiA2OTY5NjAwLFxuICAgIG1ldGVyczogNjM3MzAwMCxcbiAgICBtZXRyZXM6IDYzNzMwMDAsXG4gICAga2lsb21ldGVyczogNjM3MyxcbiAgICBraWxvbWV0cmVzOiA2MzczXG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gcmFkaWFucyB0byBhIG1vcmUgZnJpZW5kbHkgdW5pdC5cbiAqXG4gKiBAbmFtZSByYWRpYW5zVG9EaXN0YW5jZVxuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJhZGlhbnMgYWNyb3NzIHRoZSBzcGhlcmVcbiAqIEBwYXJhbSB7c3RyaW5nPWtpbG9tZXRlcnN9IHVuaXRzOiBvbmUgb2YgbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGRlZ3JlZXMsIHJhZGlhbnMsXG4gKiBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRpc3RhbmNlXG4gKi9cbm1vZHVsZS5leHBvcnRzLnJhZGlhbnNUb0Rpc3RhbmNlID0gZnVuY3Rpb24gKHJhZGlhbnMsIHVuaXRzKSB7XG4gICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHMgfHwgJ2tpbG9tZXRlcnMnXTtcbiAgICBpZiAoZmFjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuaXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIHJhZGlhbnMgKiBmYWN0b3I7XG59O1xuXG4vKlxuICogQ29udmVydCBhIGRpc3RhbmNlIG1lYXN1cmVtZW50IGZyb20gYSByZWFsLXdvcmxkIHVuaXQgaW50byByYWRpYW5zXG4gKlxuICogQG5hbWUgZGlzdGFuY2VUb1JhZGlhbnNcbiAqIEBwYXJhbSB7bnVtYmVyfSBkaXN0YW5jZSBpbiByZWFsIHVuaXRzXG4gKiBAcGFyYW0ge3N0cmluZz1raWxvbWV0ZXJzfSB1bml0czogb25lIG9mIG1pbGVzLCBuYXV0aWNhbG1pbGVzLCBkZWdyZWVzLCByYWRpYW5zLFxuICogaW5jaGVzLCB5YXJkcywgbWV0cmVzLCBtZXRlcnMsIGtpbG9tZXRyZXMsIGtpbG9tZXRlcnMuXG4gKiBAcmV0dXJucyB7bnVtYmVyfSByYWRpYW5zXG4gKi9cbm1vZHVsZS5leHBvcnRzLmRpc3RhbmNlVG9SYWRpYW5zID0gZnVuY3Rpb24gKGRpc3RhbmNlLCB1bml0cykge1xuICAgIHZhciBmYWN0b3IgPSBmYWN0b3JzW3VuaXRzIHx8ICdraWxvbWV0ZXJzJ107XG4gICAgaWYgKGZhY3RvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCB1bml0Jyk7XG4gICAgfVxuICAgIHJldHVybiBkaXN0YW5jZSAvIGZhY3Rvcjtcbn07XG5cbi8qXG4gKiBDb252ZXJ0IGEgZGlzdGFuY2UgbWVhc3VyZW1lbnQgZnJvbSBhIHJlYWwtd29ybGQgdW5pdCBpbnRvIGRlZ3JlZXNcbiAqXG4gKiBAbmFtZSBkaXN0YW5jZVRvUmFkaWFuc1xuICogQHBhcmFtIHtudW1iZXJ9IGRpc3RhbmNlIGluIHJlYWwgdW5pdHNcbiAqIEBwYXJhbSB7c3RyaW5nPWtpbG9tZXRlcnN9IHVuaXRzOiBvbmUgb2YgbWlsZXMsIG5hdXRpY2FsbWlsZXMsIGRlZ3JlZXMsIHJhZGlhbnMsXG4gKiBpbmNoZXMsIHlhcmRzLCBtZXRyZXMsIG1ldGVycywga2lsb21ldHJlcywga2lsb21ldGVycy5cbiAqIEByZXR1cm5zIHtudW1iZXJ9IGRlZ3JlZXNcbiAqL1xubW9kdWxlLmV4cG9ydHMuZGlzdGFuY2VUb0RlZ3JlZXMgPSBmdW5jdGlvbiAoZGlzdGFuY2UsIHVuaXRzKSB7XG4gICAgdmFyIGZhY3RvciA9IGZhY3RvcnNbdW5pdHMgfHwgJ2tpbG9tZXRlcnMnXTtcbiAgICBpZiAoZmFjdG9yID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHVuaXQnKTtcbiAgICB9XG4gICAgcmV0dXJuIChkaXN0YW5jZSAvIGZhY3RvcikgKiA1Ny4yOTU4O1xufTtcbiIsInZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xudmFyIHBvbHlnb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2x5Z29uO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xudmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG5cbi8vUHJlY29tcHV0ZSBjb3NpbmVzIGFuZCBzaW5lcyBvZiBhbmdsZXMgdXNlZCBpbiBoZXhhZ29uIGNyZWF0aW9uXG4vLyBmb3IgcGVyZm9ybWFuY2UgZ2FpblxudmFyIGNvc2luZXMgPSBbXTtcbnZhciBzaW5lcyA9IFtdO1xuZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICB2YXIgYW5nbGUgPSAyICogTWF0aC5QSSAvIDYgKiBpO1xuICAgIGNvc2luZXMucHVzaChNYXRoLmNvcyhhbmdsZSkpO1xuICAgIHNpbmVzLnB1c2goTWF0aC5zaW4oYW5nbGUpKTtcbn1cblxuLyoqXG4gKiBUYWtlcyBhIGJvdW5kaW5nIGJveCBhbmQgYSBjZWxsIHNpemUgaW4gZGVncmVlcyBhbmQgcmV0dXJucyBhIHtAbGluayBGZWF0dXJlQ29sbGVjdGlvbn0gb2YgZmxhdC10b3BwZWRcbiAqIGhleGFnb25zICh7QGxpbmsgUG9seWdvbn0gZmVhdHVyZXMpIGFsaWduZWQgaW4gYW4gXCJvZGQtcVwiIHZlcnRpY2FsIGdyaWQgYXNcbiAqIGRlc2NyaWJlZCBpbiBbSGV4YWdvbmFsIEdyaWRzXShodHRwOi8vd3d3LnJlZGJsb2JnYW1lcy5jb20vZ3JpZHMvaGV4YWdvbnMvKS5cbiAqXG4gKiBAbmFtZSBoZXhHcmlkXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggYm91bmRpbmcgYm94IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIGRpbWVuc2lvbiBvZiBjZWxsIGluIHNwZWNpZmllZCB1bml0c1xuICogQHBhcmFtIHtzdHJpbmd9IHVuaXRzIHVzZWQgaW4gY2FsY3VsYXRpbmcgY2VsbFdpZHRoICgnbWlsZXMnIG9yICdraWxvbWV0ZXJzJylcbiAqIEBwYXJhbSB7Ym9vbGVhbn0gdHJpYW5nbGVzIHdoZXRoZXIgdG8gcmV0dXJuIGFzIHRyaWFuZ2xlcyBpbnN0ZWFkIG9mIGhleGFnb25zXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2x5Z29uPn0gYSBoZXhhZ29uYWwgZ3JpZFxuICogQGV4YW1wbGVcbiAqIHZhciBiYm94ID0gWy05NiwzMSwtODQsNDBdO1xuICogdmFyIGNlbGxXaWR0aCA9IDUwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgaGV4Z3JpZCA9IHR1cmYuaGV4R3JpZChiYm94LCBjZWxsV2lkdGgsIHVuaXRzKTtcbiAqXG4gKiAvLz1oZXhncmlkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaGV4R3JpZChiYm94LCBjZWxsU2l6ZSwgdW5pdHMsIHRyaWFuZ2xlcykge1xuICAgIHZhciB4RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShwb2ludChbYmJveFswXSwgYmJveFsxXV0pLCBwb2ludChbYmJveFsyXSwgYmJveFsxXV0pLCB1bml0cykpO1xuICAgIHZhciBjZWxsV2lkdGggPSB4RnJhY3Rpb24gKiAoYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIHZhciB5RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShwb2ludChbYmJveFswXSwgYmJveFsxXV0pLCBwb2ludChbYmJveFswXSwgYmJveFszXV0pLCB1bml0cykpO1xuICAgIHZhciBjZWxsSGVpZ2h0ID0geUZyYWN0aW9uICogKGJib3hbM10gLSBiYm94WzFdKTtcbiAgICB2YXIgcmFkaXVzID0gY2VsbFdpZHRoIC8gMjtcblxuICAgIHZhciBoZXhfd2lkdGggPSByYWRpdXMgKiAyO1xuICAgIHZhciBoZXhfaGVpZ2h0ID0gTWF0aC5zcXJ0KDMpIC8gMiAqIGNlbGxIZWlnaHQ7XG5cbiAgICB2YXIgYm94X3dpZHRoID0gYmJveFsyXSAtIGJib3hbMF07XG4gICAgdmFyIGJveF9oZWlnaHQgPSBiYm94WzNdIC0gYmJveFsxXTtcblxuICAgIHZhciB4X2ludGVydmFsID0gMyAvIDQgKiBoZXhfd2lkdGg7XG4gICAgdmFyIHlfaW50ZXJ2YWwgPSBoZXhfaGVpZ2h0O1xuXG4gICAgdmFyIHhfc3BhbiA9IGJveF93aWR0aCAvIChoZXhfd2lkdGggLSByYWRpdXMgLyAyKTtcbiAgICB2YXIgeF9jb3VudCA9IE1hdGguY2VpbCh4X3NwYW4pO1xuICAgIGlmIChNYXRoLnJvdW5kKHhfc3BhbikgPT09IHhfY291bnQpIHtcbiAgICAgICAgeF9jb3VudCsrO1xuICAgIH1cblxuICAgIHZhciB4X2FkanVzdCA9ICgoeF9jb3VudCAqIHhfaW50ZXJ2YWwgLSByYWRpdXMgLyAyKSAtIGJveF93aWR0aCkgLyAyIC0gcmFkaXVzIC8gMjtcblxuICAgIHZhciB5X2NvdW50ID0gTWF0aC5jZWlsKGJveF9oZWlnaHQgLyBoZXhfaGVpZ2h0KTtcblxuICAgIHZhciB5X2FkanVzdCA9IChib3hfaGVpZ2h0IC0geV9jb3VudCAqIGhleF9oZWlnaHQpIC8gMjtcblxuICAgIHZhciBoYXNPZmZzZXRZID0geV9jb3VudCAqIGhleF9oZWlnaHQgLSBib3hfaGVpZ2h0ID4gaGV4X2hlaWdodCAvIDI7XG4gICAgaWYgKGhhc09mZnNldFkpIHtcbiAgICAgICAgeV9hZGp1c3QgLT0gaGV4X2hlaWdodCAvIDQ7XG4gICAgfVxuXG4gICAgdmFyIGZjID0gZmVhdHVyZWNvbGxlY3Rpb24oW10pO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgeF9jb3VudDsgeCsrKSB7XG4gICAgICAgIGZvciAodmFyIHkgPSAwOyB5IDw9IHlfY291bnQ7IHkrKykge1xuXG4gICAgICAgICAgICB2YXIgaXNPZGQgPSB4ICUgMiA9PT0gMTtcbiAgICAgICAgICAgIGlmICh5ID09PSAwICYmIGlzT2RkKSB7XG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICh5ID09PSAwICYmIGhhc09mZnNldFkpIHtcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgdmFyIGNlbnRlcl94ID0geCAqIHhfaW50ZXJ2YWwgKyBiYm94WzBdIC0geF9hZGp1c3Q7XG4gICAgICAgICAgICB2YXIgY2VudGVyX3kgPSB5ICogeV9pbnRlcnZhbCArIGJib3hbMV0gKyB5X2FkanVzdDtcblxuICAgICAgICAgICAgaWYgKGlzT2RkKSB7XG4gICAgICAgICAgICAgICAgY2VudGVyX3kgLT0gaGV4X2hlaWdodCAvIDI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHJpYW5nbGVzKSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaC5hcHBseShmYy5mZWF0dXJlcywgaGV4VHJpYW5nbGVzKFtjZW50ZXJfeCwgY2VudGVyX3ldLCBjZWxsV2lkdGggLyAyLCBjZWxsSGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKGhleGFnb24oW2NlbnRlcl94LCBjZW50ZXJfeV0sIGNlbGxXaWR0aCAvIDIsIGNlbGxIZWlnaHQgLyAyKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gZmM7XG59O1xuXG4vL0NlbnRlciBzaG91bGQgYmUgW3gsIHldXG5mdW5jdGlvbiBoZXhhZ29uKGNlbnRlciwgcngsIHJ5KSB7XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcbiAgICAgICAgdmFyIHggPSBjZW50ZXJbMF0gKyByeCAqIGNvc2luZXNbaV07XG4gICAgICAgIHZhciB5ID0gY2VudGVyWzFdICsgcnkgKiBzaW5lc1tpXTtcbiAgICAgICAgdmVydGljZXMucHVzaChbeCwgeV0pO1xuICAgIH1cbiAgICAvL2ZpcnN0IGFuZCBsYXN0IHZlcnRleCBtdXN0IGJlIHRoZSBzYW1lXG4gICAgdmVydGljZXMucHVzaCh2ZXJ0aWNlc1swXSk7XG4gICAgcmV0dXJuIHBvbHlnb24oW3ZlcnRpY2VzXSk7XG59XG5cbi8vQ2VudGVyIHNob3VsZCBiZSBbeCwgeV1cbmZ1bmN0aW9uIGhleFRyaWFuZ2xlcyhjZW50ZXIsIHJ4LCByeSkge1xuICAgIHZhciB0cmlhbmdsZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IDY7IGkrKykge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBbXTtcbiAgICAgICAgdmVydGljZXMucHVzaChjZW50ZXIpO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKFtcbiAgICAgICAgICAgIGNlbnRlclswXSArIHJ4ICogY29zaW5lc1tpXSxcbiAgICAgICAgICAgIGNlbnRlclsxXSArIHJ5ICogc2luZXNbaV1cbiAgICAgICAgXSk7XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW1xuICAgICAgICAgICAgY2VudGVyWzBdICsgcnggKiBjb3NpbmVzWyhpICsgMSkgJSA2XSxcbiAgICAgICAgICAgIGNlbnRlclsxXSArIHJ5ICogc2luZXNbKGkgKyAxKSAlIDZdXG4gICAgICAgIF0pO1xuICAgICAgICB2ZXJ0aWNlcy5wdXNoKGNlbnRlcik7XG4gICAgICAgIHRyaWFuZ2xlcy5wdXNoKHBvbHlnb24oW3ZlcnRpY2VzXSkpO1xuICAgIH1cbiAgICByZXR1cm4gdHJpYW5nbGVzO1xufVxuIiwidmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ3R1cmYtaW52YXJpYW50Jyk7XG5cbi8vIGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRXZlbiVFMiU4MCU5M29kZF9ydWxlXG4vLyBtb2RpZmllZCBmcm9tOiBodHRwczovL2dpdGh1Yi5jb20vc3Vic3RhY2svcG9pbnQtaW4tcG9seWdvbi9ibG9iL21hc3Rlci9pbmRleC5qc1xuLy8gd2hpY2ggd2FzIG1vZGlmaWVkIGZyb20gaHR0cDovL3d3dy5lY3NlLnJwaS5lZHUvSG9tZXBhZ2VzL3dyZi9SZXNlYXJjaC9TaG9ydF9Ob3Rlcy9wbnBvbHkuaHRtbFxuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIFBvaW50fSBhbmQgYSB7QGxpbmsgUG9seWdvbn0gb3Ige0BsaW5rIE11bHRpUG9seWdvbn0gYW5kIGRldGVybWluZXMgaWYgdGhlIHBvaW50IHJlc2lkZXMgaW5zaWRlIHRoZSBwb2x5Z29uLiBUaGUgcG9seWdvbiBjYW5cbiAqIGJlIGNvbnZleCBvciBjb25jYXZlLiBUaGUgZnVuY3Rpb24gYWNjb3VudHMgZm9yIGhvbGVzLlxuICpcbiAqIEBuYW1lIGluc2lkZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgaW5wdXQgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTwoUG9seWdvbnxNdWx0aVBvbHlnb24pPn0gcG9seWdvbiBpbnB1dCBwb2x5Z29uIG9yIG11bHRpcG9seWdvblxuICogQHJldHVybiB7Qm9vbGVhbn0gYHRydWVgIGlmIHRoZSBQb2ludCBpcyBpbnNpZGUgdGhlIFBvbHlnb247IGBmYWxzZWAgaWYgdGhlIFBvaW50IGlzIG5vdCBpbnNpZGUgdGhlIFBvbHlnb25cbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjZjAwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstMTExLjQ2NzI4NSwgNDAuNzU3NjZdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgcHQyID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJtYXJrZXItY29sb3JcIjogXCIjMGYwXCJcbiAqICAgfSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFstMTExLjg3Mzc3OSwgNDAuNjQ3MzAzXVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvbHkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy0xMTIuMDc0Mjc5LCA0MC41MjIxNV0sXG4gKiAgICAgICBbLTExMi4wNzQyNzksIDQwLjg1MzI5M10sXG4gKiAgICAgICBbLTExMS42MTAxMDcsIDQwLjg1MzI5M10sXG4gKiAgICAgICBbLTExMS42MTAxMDcsIDQwLjUyMjE1XSxcbiAqICAgICAgIFstMTEyLjA3NDI3OSwgNDAuNTIyMTVdXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW3B0MSwgcHQyLCBwb2x5XVxuICogfTtcbiAqXG4gKiAvLz1mZWF0dXJlc1xuICpcbiAqIHZhciBpc0luc2lkZTEgPSB0dXJmLmluc2lkZShwdDEsIHBvbHkpO1xuICogLy89aXNJbnNpZGUxXG4gKlxuICogdmFyIGlzSW5zaWRlMiA9IHR1cmYuaW5zaWRlKHB0MiwgcG9seSk7XG4gKiAvLz1pc0luc2lkZTJcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnB1dChwb2ludCwgcG9seWdvbikge1xuICAgIHZhciBwdCA9IGludmFyaWFudC5nZXRDb29yZChwb2ludCk7XG4gICAgdmFyIHBvbHlzID0gcG9seWdvbi5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICAvLyBub3JtYWxpemUgdG8gbXVsdGlwb2x5Z29uXG4gICAgaWYgKHBvbHlnb24uZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSBwb2x5cyA9IFtwb2x5c107XG5cbiAgICBmb3IgKHZhciBpID0gMCwgaW5zaWRlUG9seSA9IGZhbHNlOyBpIDwgcG9seXMubGVuZ3RoICYmICFpbnNpZGVQb2x5OyBpKyspIHtcbiAgICAgICAgLy8gY2hlY2sgaWYgaXQgaXMgaW4gdGhlIG91dGVyIHJpbmcgZmlyc3RcbiAgICAgICAgaWYgKGluUmluZyhwdCwgcG9seXNbaV1bMF0pKSB7XG4gICAgICAgICAgICB2YXIgaW5Ib2xlID0gZmFsc2U7XG4gICAgICAgICAgICB2YXIgayA9IDE7XG4gICAgICAgICAgICAvLyBjaGVjayBmb3IgdGhlIHBvaW50IGluIGFueSBvZiB0aGUgaG9sZXNcbiAgICAgICAgICAgIHdoaWxlIChrIDwgcG9seXNbaV0ubGVuZ3RoICYmICFpbkhvbGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoaW5SaW5nKHB0LCBwb2x5c1tpXVtrXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaW5Ib2xlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaysrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbkhvbGUpIGluc2lkZVBvbHkgPSB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnNpZGVQb2x5O1xufTtcblxuLy8gcHQgaXMgW3gseV0gYW5kIHJpbmcgaXMgW1t4LHldLCBbeCx5XSwuLl1cbmZ1bmN0aW9uIGluUmluZyhwdCwgcmluZykge1xuICAgIHZhciBpc0luc2lkZSA9IGZhbHNlO1xuICAgIGZvciAodmFyIGkgPSAwLCBqID0gcmluZy5sZW5ndGggLSAxOyBpIDwgcmluZy5sZW5ndGg7IGogPSBpKyspIHtcbiAgICAgICAgdmFyIHhpID0gcmluZ1tpXVswXSwgeWkgPSByaW5nW2ldWzFdO1xuICAgICAgICB2YXIgeGogPSByaW5nW2pdWzBdLCB5aiA9IHJpbmdbal1bMV07XG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSAoKHlpID4gcHRbMV0pICE9PSAoeWogPiBwdFsxXSkpICYmXG4gICAgICAgIChwdFswXSA8ICh4aiAtIHhpKSAqIChwdFsxXSAtIHlpKSAvICh5aiAtIHlpKSArIHhpKTtcbiAgICAgICAgaWYgKGludGVyc2VjdCkgaXNJbnNpZGUgPSAhaXNJbnNpZGU7XG4gICAgfVxuICAgIHJldHVybiBpc0luc2lkZTtcbn1cbiIsIi8vIGRlcGVuZCBvbiBqc3RzIGZvciBub3cgaHR0cHM6Ly9naXRodWIuY29tL2Jqb3JuaGFycnRlbGwvanN0cy9ibG9iL21hc3Rlci9leGFtcGxlcy9vdmVybGF5Lmh0bWxcbnZhciBqc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG4vKipcbiAqIFRha2VzIHR3byB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gYW5kIGZpbmRzIHRoZWlyIGludGVyc2VjdGlvbi4gSWYgdGhleSBzaGFyZSBhIGJvcmRlciwgcmV0dXJucyB0aGUgYm9yZGVyOyBpZiB0aGV5IGRvbid0IGludGVyc2VjdCwgcmV0dXJucyB1bmRlZmluZWQuXG4gKlxuICogQG5hbWUgaW50ZXJzZWN0XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHBvbHkxIHRoZSBmaXJzdCBwb2x5Z29uXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHBvbHkyIHRoZSBzZWNvbmQgcG9seWdvblxuICogQHJldHVybiB7KEZlYXR1cmU8UG9seWdvbj58dW5kZWZpbmVkfEZlYXR1cmU8TXVsdGlMaW5lU3RyaW5nPil9IGlmIGBwb2x5MWAgYW5kIGBwb2x5MmAgb3ZlcmxhcCwgcmV0dXJucyBhIFBvbHlnb24gZmVhdHVyZSByZXByZXNlbnRpbmcgdGhlIGFyZWEgdGhleSBvdmVybGFwOyBpZiBgcG9seTFgIGFuZCBgcG9seTJgIGRvIG5vdCBvdmVybGFwLCByZXR1cm5zIGB1bmRlZmluZWRgOyBpZiBgcG9seTFgIGFuZCBgcG9seTJgIHNoYXJlIGEgYm9yZGVyLCBhIE11bHRpTGluZVN0cmluZyBvZiB0aGUgbG9jYXRpb25zIHdoZXJlIHRoZWlyIGJvcmRlcnMgYXJlIHNoYXJlZFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2x5MSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwZjBcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy0xMjIuODAxNzQyLCA0NS40ODU2NV0sXG4gKiAgICAgICBbLTEyMi44MDE3NDIsIDQ1LjYwNDkxXSxcbiAqICAgICAgIFstMTIyLjU4NDc2MiwgNDUuNjA0OTFdLFxuICogICAgICAgWy0xMjIuNTg0NzYyLCA0NS40ODU2NV0sXG4gKiAgICAgICBbLTEyMi44MDE3NDIsIDQ1LjQ4NTY1XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH1cbiAqIHZhciBwb2x5MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwMGZcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy0xMjIuNTIwMjE3LCA0NS41MzU2OTNdLFxuICogICAgICAgWy0xMjIuNjQwMzgsIDQ1LjU1Mzk2N10sXG4gKiAgICAgICBbLTEyMi43MjAwMzEsIDQ1LjUyNjU1NF0sXG4gKiAgICAgICBbLTEyMi42Njk5MDYsIDQ1LjUwNzMwOV0sXG4gKiAgICAgICBbLTEyMi43MjM0NjQsIDQ1LjQ0NjY0M10sXG4gKiAgICAgICBbLTEyMi41MzI1NzcsIDQ1LjQwODU3NF0sXG4gKiAgICAgICBbLTEyMi40ODcyNTgsIDQ1LjQ3NzQ2Nl0sXG4gKiAgICAgICBbLTEyMi41MjAyMTcsIDQ1LjUzNTY5M11cbiAqICAgICBdXVxuICogICB9XG4gKiB9XG4gKlxuICogdmFyIHBvbHlnb25zID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2x5MSwgcG9seTJdXG4gKiB9O1xuICpcbiAqIHZhciBpbnRlcnNlY3Rpb24gPSB0dXJmLmludGVyc2VjdChwb2x5MSwgcG9seTIpO1xuICpcbiAqIC8vPXBvbHlnb25zXG4gKlxuICogLy89aW50ZXJzZWN0aW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW50ZXJzZWN0KHBvbHkxLCBwb2x5Mikge1xuICAgIHZhciBnZW9tMSwgZ2VvbTI7XG4gICAgaWYgKHBvbHkxLnR5cGUgPT09ICdGZWF0dXJlJykgZ2VvbTEgPSBwb2x5MS5nZW9tZXRyeTtcbiAgICBlbHNlIGdlb20xID0gcG9seTE7XG4gICAgaWYgKHBvbHkyLnR5cGUgPT09ICdGZWF0dXJlJykgZ2VvbTIgPSBwb2x5Mi5nZW9tZXRyeTtcbiAgICBlbHNlIGdlb20yID0gcG9seTI7XG4gICAgdmFyIHJlYWRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05SZWFkZXIoKTtcbiAgICB2YXIgYSA9IHJlYWRlci5yZWFkKEpTT04uc3RyaW5naWZ5KGdlb20xKSk7XG4gICAgdmFyIGIgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShnZW9tMikpO1xuICAgIHZhciBpbnRlcnNlY3Rpb24gPSBhLmludGVyc2VjdGlvbihiKTtcblxuICAgIGlmIChpbnRlcnNlY3Rpb24uaXNFbXB0eSgpKSB7XG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgdmFyIHdyaXRlciA9IG5ldyBqc3RzLmlvLkdlb0pTT05Xcml0ZXIoKTtcblxuICAgIHZhciBnZW9qc29uR2VvbWV0cnkgPSB3cml0ZXIud3JpdGUoaW50ZXJzZWN0aW9uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIHByb3BlcnRpZXM6IHt9LFxuICAgICAgICBnZW9tZXRyeTogZ2VvanNvbkdlb21ldHJ5XG4gICAgfTtcbn07XG4iLCIvKipcbiAqIFVud3JhcCBhIGNvb3JkaW5hdGUgZnJvbSBhIEZlYXR1cmUgd2l0aCBhIFBvaW50IGdlb21ldHJ5LCBhIFBvaW50XG4gKiBnZW9tZXRyeSwgb3IgYSBzaW5nbGUgY29vcmRpbmF0ZS5cbiAqXG4gKiBAcGFyYW0geyp9IG9iaiBhbnkgdmFsdWVcbiAqIEByZXR1cm5zIHtBcnJheTxudW1iZXI+fSBhIGNvb3JkaW5hdGVcbiAqL1xuZnVuY3Rpb24gZ2V0Q29vcmQob2JqKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob2JqKSAmJlxuICAgICAgICB0eXBlb2Ygb2JqWzBdID09PSAnbnVtYmVyJyAmJlxuICAgICAgICB0eXBlb2Ygb2JqWzFdID09PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gb2JqO1xuICAgIH0gZWxzZSBpZiAob2JqKSB7XG4gICAgICAgIGlmIChvYmoudHlwZSA9PT0gJ0ZlYXR1cmUnICYmXG4gICAgICAgICAgICBvYmouZ2VvbWV0cnkgJiZcbiAgICAgICAgICAgIG9iai5nZW9tZXRyeS50eXBlID09PSAnUG9pbnQnICYmXG4gICAgICAgICAgICBBcnJheS5pc0FycmF5KG9iai5nZW9tZXRyeS5jb29yZGluYXRlcykpIHtcbiAgICAgICAgICAgIHJldHVybiBvYmouZ2VvbWV0cnkuY29vcmRpbmF0ZXM7XG4gICAgICAgIH0gZWxzZSBpZiAob2JqLnR5cGUgPT09ICdQb2ludCcgJiZcbiAgICAgICAgICAgIEFycmF5LmlzQXJyYXkob2JqLmNvb3JkaW5hdGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG9iai5jb29yZGluYXRlcztcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ0EgY29vcmRpbmF0ZSwgZmVhdHVyZSwgb3IgcG9pbnQgZ2VvbWV0cnkgaXMgcmVxdWlyZWQnKTtcbn1cblxuLyoqXG4gKiBFbmZvcmNlIGV4cGVjdGF0aW9ucyBhYm91dCB0eXBlcyBvZiBHZW9KU09OIG9iamVjdHMgZm9yIFR1cmYuXG4gKlxuICogQGFsaWFzIGdlb2pzb25UeXBlXG4gKiBAcGFyYW0ge0dlb0pTT059IHZhbHVlIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtzdHJpbmd9IHR5cGUgZXhwZWN0ZWQgR2VvSlNPTiB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gbmFtZSBuYW1lIG9mIGNhbGxpbmcgZnVuY3Rpb25cbiAqIEB0aHJvd3Mge0Vycm9yfSBpZiB2YWx1ZSBpcyBub3QgdGhlIGV4cGVjdGVkIHR5cGUuXG4gKi9cbmZ1bmN0aW9uIGdlb2pzb25UeXBlKHZhbHVlLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCF0eXBlIHx8ICFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJ3R5cGUgYW5kIG5hbWUgcmVxdWlyZWQnKTtcblxuICAgIGlmICghdmFsdWUgfHwgdmFsdWUudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnOiBtdXN0IGJlIGEgJyArIHR5cGUgKyAnLCBnaXZlbiAnICsgdmFsdWUudHlwZSk7XG4gICAgfVxufVxuXG4vKipcbiAqIEVuZm9yY2UgZXhwZWN0YXRpb25zIGFib3V0IHR5cGVzIG9mIHtAbGluayBGZWF0dXJlfSBpbnB1dHMgZm9yIFR1cmYuXG4gKiBJbnRlcm5hbGx5IHRoaXMgdXNlcyB7QGxpbmsgZ2VvanNvblR5cGV9IHRvIGp1ZGdlIGdlb21ldHJ5IHR5cGVzLlxuICpcbiAqIEBhbGlhcyBmZWF0dXJlT2ZcbiAqIEBwYXJhbSB7RmVhdHVyZX0gZmVhdHVyZSBhIGZlYXR1cmUgd2l0aCBhbiBleHBlY3RlZCBnZW9tZXRyeSB0eXBlXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBleHBlY3RlZCBHZW9KU09OIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxuICogQHRocm93cyB7RXJyb3J9IGVycm9yIGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gZmVhdHVyZU9mKGZlYXR1cmUsIHR5cGUsIG5hbWUpIHtcbiAgICBpZiAoIW5hbWUpIHRocm93IG5ldyBFcnJvcignLmZlYXR1cmVPZigpIHJlcXVpcmVzIGEgbmFtZScpO1xuICAgIGlmICghZmVhdHVyZSB8fCBmZWF0dXJlLnR5cGUgIT09ICdGZWF0dXJlJyB8fCAhZmVhdHVyZS5nZW9tZXRyeSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnLCBGZWF0dXJlIHdpdGggZ2VvbWV0cnkgcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgaWYgKCFmZWF0dXJlLmdlb21ldHJ5IHx8IGZlYXR1cmUuZ2VvbWV0cnkudHlwZSAhPT0gdHlwZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgaW5wdXQgdG8gJyArIG5hbWUgKyAnOiBtdXN0IGJlIGEgJyArIHR5cGUgKyAnLCBnaXZlbiAnICsgZmVhdHVyZS5nZW9tZXRyeS50eXBlKTtcbiAgICB9XG59XG5cbi8qKlxuICogRW5mb3JjZSBleHBlY3RhdGlvbnMgYWJvdXQgdHlwZXMgb2Yge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBpbnB1dHMgZm9yIFR1cmYuXG4gKiBJbnRlcm5hbGx5IHRoaXMgdXNlcyB7QGxpbmsgZ2VvanNvblR5cGV9IHRvIGp1ZGdlIGdlb21ldHJ5IHR5cGVzLlxuICpcbiAqIEBhbGlhcyBjb2xsZWN0aW9uT2ZcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb259IGZlYXR1cmVjb2xsZWN0aW9uIGEgZmVhdHVyZWNvbGxlY3Rpb24gZm9yIHdoaWNoIGZlYXR1cmVzIHdpbGwgYmUganVkZ2VkXG4gKiBAcGFyYW0ge3N0cmluZ30gdHlwZSBleHBlY3RlZCBHZW9KU09OIHR5cGVcbiAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIG5hbWUgb2YgY2FsbGluZyBmdW5jdGlvblxuICogQHRocm93cyB7RXJyb3J9IGlmIHZhbHVlIGlzIG5vdCB0aGUgZXhwZWN0ZWQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gY29sbGVjdGlvbk9mKGZlYXR1cmVjb2xsZWN0aW9uLCB0eXBlLCBuYW1lKSB7XG4gICAgaWYgKCFuYW1lKSB0aHJvdyBuZXcgRXJyb3IoJy5jb2xsZWN0aW9uT2YoKSByZXF1aXJlcyBhIG5hbWUnKTtcbiAgICBpZiAoIWZlYXR1cmVjb2xsZWN0aW9uIHx8IGZlYXR1cmVjb2xsZWN0aW9uLnR5cGUgIT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGlucHV0IHRvICcgKyBuYW1lICsgJywgRmVhdHVyZUNvbGxlY3Rpb24gcmVxdWlyZWQnKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBmZWF0dXJlY29sbGVjdGlvbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZmVhdHVyZSA9IGZlYXR1cmVjb2xsZWN0aW9uLmZlYXR1cmVzW2ldO1xuICAgICAgICBpZiAoIWZlYXR1cmUgfHwgZmVhdHVyZS50eXBlICE9PSAnRmVhdHVyZScgfHwgIWZlYXR1cmUuZ2VvbWV0cnkpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICcsIEZlYXR1cmUgd2l0aCBnZW9tZXRyeSByZXF1aXJlZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghZmVhdHVyZS5nZW9tZXRyeSB8fCBmZWF0dXJlLmdlb21ldHJ5LnR5cGUgIT09IHR5cGUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBpbnB1dCB0byAnICsgbmFtZSArICc6IG11c3QgYmUgYSAnICsgdHlwZSArICcsIGdpdmVuICcgKyBmZWF0dXJlLmdlb21ldHJ5LnR5cGUpO1xuICAgICAgICB9XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5nZW9qc29uVHlwZSA9IGdlb2pzb25UeXBlO1xubW9kdWxlLmV4cG9ydHMuY29sbGVjdGlvbk9mID0gY29sbGVjdGlvbk9mO1xubW9kdWxlLmV4cG9ydHMuZmVhdHVyZU9mID0gZmVhdHVyZU9mO1xubW9kdWxlLmV4cG9ydHMuZ2V0Q29vcmQgPSBnZXRDb29yZDtcbiIsIi8qIGVzbGludC1kaXNhYmxlICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAsIEphc29uIERhdmllcy5cbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLiAgVGhpcyBjb2RlIGlzIGJhc2VkIG9uIEJyYWRsZXkgV2hpdGUncyBKYXZhIHZlcnNpb24sXG4gKiB3aGljaCBpcyBpbiB0dXJuIGJhc2VkIG9uIE5pY2hvbGFzIFl1ZSdzIEMrKyB2ZXJzaW9uLCB3aGljaCBpbiB0dXJuIGlzIGJhc2VkXG4gKiBvbiBQYXVsIEQuIEJvdXJrZSdzIG9yaWdpbmFsIEZvcnRyYW4gdmVyc2lvbi4gIFNlZSBiZWxvdyBmb3IgdGhlIHJlc3BlY3RpdmVcbiAqIGNvcHlyaWdodCBub3RpY2VzLlxuICpcbiAqIFNlZSBodHRwOi8vbG9jYWwud2FzcC51d2EuZWR1LmF1L35wYm91cmtlL3BhcGVycy9jb25yZWMvIGZvciB0aGUgb3JpZ2luYWxcbiAqIHBhcGVyIGJ5IFBhdWwgRC4gQm91cmtlLlxuICpcbiAqIFRoZSB2ZWN0b3IgY29udmVyc2lvbiBjb2RlIGlzIGJhc2VkIG9uIGh0dHA6Ly9hcHB0cmVlLm5ldC9jb25yZWMuaHRtIGJ5XG4gKiBHcmFoYW0gQ294LlxuICpcbiAqIFJlZGlzdHJpYnV0aW9uIGFuZCB1c2UgaW4gc291cmNlIGFuZCBiaW5hcnkgZm9ybXMsIHdpdGggb3Igd2l0aG91dFxuICogbW9kaWZpY2F0aW9uLCBhcmUgcGVybWl0dGVkIHByb3ZpZGVkIHRoYXQgdGhlIGZvbGxvd2luZyBjb25kaXRpb25zIGFyZSBtZXQ6XG4gKiAgICAgKiBSZWRpc3RyaWJ1dGlvbnMgb2Ygc291cmNlIGNvZGUgbXVzdCByZXRhaW4gdGhlIGFib3ZlIGNvcHlyaWdodFxuICogICAgICAgbm90aWNlLCB0aGlzIGxpc3Qgb2YgY29uZGl0aW9ucyBhbmQgdGhlIGZvbGxvd2luZyBkaXNjbGFpbWVyLlxuICogICAgICogUmVkaXN0cmlidXRpb25zIGluIGJpbmFyeSBmb3JtIG11c3QgcmVwcm9kdWNlIHRoZSBhYm92ZSBjb3B5cmlnaHRcbiAqICAgICAgIG5vdGljZSwgdGhpcyBsaXN0IG9mIGNvbmRpdGlvbnMgYW5kIHRoZSBmb2xsb3dpbmcgZGlzY2xhaW1lciBpbiB0aGVcbiAqICAgICAgIGRvY3VtZW50YXRpb24gYW5kL29yIG90aGVyIG1hdGVyaWFscyBwcm92aWRlZCB3aXRoIHRoZSBkaXN0cmlidXRpb24uXG4gKiAgICAgKiBOZWl0aGVyIHRoZSBuYW1lIG9mIHRoZSA8b3JnYW5pemF0aW9uPiBub3IgdGhlXG4gKiAgICAgICBuYW1lcyBvZiBpdHMgY29udHJpYnV0b3JzIG1heSBiZSB1c2VkIHRvIGVuZG9yc2Ugb3IgcHJvbW90ZSBwcm9kdWN0c1xuICogICAgICAgZGVyaXZlZCBmcm9tIHRoaXMgc29mdHdhcmUgd2l0aG91dCBzcGVjaWZpYyBwcmlvciB3cml0dGVuIHBlcm1pc3Npb24uXG4gKlxuICogVEhJUyBTT0ZUV0FSRSBJUyBQUk9WSURFRCBCWSBUSEUgQ09QWVJJR0hUIEhPTERFUlMgQU5EIENPTlRSSUJVVE9SUyBcIkFTIElTXCJcbiAqIEFORCBBTlkgRVhQUkVTUyBPUiBJTVBMSUVEIFdBUlJBTlRJRVMsIElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBUSEVcbiAqIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFkgQU5EIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFXG4gKiBBUkUgRElTQ0xBSU1FRC4gSU4gTk8gRVZFTlQgU0hBTEwgPENPUFlSSUdIVCBIT0xERVI+IEJFIExJQUJMRSBGT1IgQU5ZXG4gKiBESVJFQ1QsIElORElSRUNULCBJTkNJREVOVEFMLCBTUEVDSUFMLCBFWEVNUExBUlksIE9SIENPTlNFUVVFTlRJQUwgREFNQUdFU1xuICogKElOQ0xVRElORywgQlVUIE5PVCBMSU1JVEVEIFRPLCBQUk9DVVJFTUVOVCBPRiBTVUJTVElUVVRFIEdPT0RTIE9SIFNFUlZJQ0VTO1xuICogTE9TUyBPRiBVU0UsIERBVEEsIE9SIFBST0ZJVFM7IE9SIEJVU0lORVNTIElOVEVSUlVQVElPTikgSE9XRVZFUiBDQVVTRUQgQU5EXG4gKiBPTiBBTlkgVEhFT1JZIE9GIExJQUJJTElUWSwgV0hFVEhFUiBJTiBDT05UUkFDVCwgU1RSSUNUIExJQUJJTElUWSwgT1IgVE9SVFxuICogKElOQ0xVRElORyBORUdMSUdFTkNFIE9SIE9USEVSV0lTRSkgQVJJU0lORyBJTiBBTlkgV0FZIE9VVCBPRiBUSEUgVVNFIE9GXG4gKiBUSElTIFNPRlRXQVJFLCBFVkVOIElGIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICovXG5cbi8qXG4gKiBDb3B5cmlnaHQgKGMpIDE5OTYtMTk5NyBOaWNob2xhcyBZdWVcbiAqXG4gKiBUaGlzIHNvZnR3YXJlIGlzIGNvcHlyaWdodGVkIGJ5IE5pY2hvbGFzIFl1ZS4gVGhpcyBjb2RlIGlzIGJhc2VkIG9uIFBhdWwgRC5cbiAqIEJvdXJrZSdzIENPTlJFQy5GIHJvdXRpbmUuXG4gKlxuICogVGhlIGF1dGhvcnMgaGVyZWJ5IGdyYW50IHBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBhbmQgZGlzdHJpYnV0ZSB0aGlzXG4gKiBzb2Z0d2FyZSBhbmQgaXRzIGRvY3VtZW50YXRpb24gZm9yIGFueSBwdXJwb3NlLCBwcm92aWRlZCB0aGF0IGV4aXN0aW5nXG4gKiBjb3B5cmlnaHQgbm90aWNlcyBhcmUgcmV0YWluZWQgaW4gYWxsIGNvcGllcyBhbmQgdGhhdCB0aGlzIG5vdGljZSBpc1xuICogaW5jbHVkZWQgdmVyYmF0aW0gaW4gYW55IGRpc3RyaWJ1dGlvbnMuIEFkZGl0aW9uYWxseSwgdGhlIGF1dGhvcnMgZ3JhbnRcbiAqIHBlcm1pc3Npb24gdG8gbW9kaWZ5IHRoaXMgc29mdHdhcmUgYW5kIGl0cyBkb2N1bWVudGF0aW9uIGZvciBhbnkgcHVycG9zZSxcbiAqIHByb3ZpZGVkIHRoYXQgc3VjaCBtb2RpZmljYXRpb25zIGFyZSBub3QgZGlzdHJpYnV0ZWQgd2l0aG91dCB0aGUgZXhwbGljaXRcbiAqIGNvbnNlbnQgb2YgdGhlIGF1dGhvcnMgYW5kIHRoYXQgZXhpc3RpbmcgY29weXJpZ2h0IG5vdGljZXMgYXJlIHJldGFpbmVkIGluXG4gKiBhbGwgY29waWVzLiBTb21lIG9mIHRoZSBhbGdvcml0aG1zIGltcGxlbWVudGVkIGJ5IHRoaXMgc29mdHdhcmUgYXJlXG4gKiBwYXRlbnRlZCwgb2JzZXJ2ZSBhbGwgYXBwbGljYWJsZSBwYXRlbnQgbGF3LlxuICpcbiAqIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIERJU1RSSUJVVE9SUyBCRSBMSUFCTEUgVE8gQU5ZIFBBUlRZIEZPUlxuICogRElSRUNULCBJTkRJUkVDVCwgU1BFQ0lBTCwgSU5DSURFTlRBTCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIEFSSVNJTkcgT1VUXG4gKiBPRiBUSEUgVVNFIE9GIFRISVMgU09GVFdBUkUsIElUUyBET0NVTUVOVEFUSU9OLCBPUiBBTlkgREVSSVZBVElWRVMgVEhFUkVPRixcbiAqIEVWRU4gSUYgVEhFIEFVVEhPUlMgSEFWRSBCRUVOIEFEVklTRUQgT0YgVEhFIFBPU1NJQklMSVRZIE9GIFNVQ0ggREFNQUdFLlxuICpcbiAqIFRIRSBBVVRIT1JTIEFORCBESVNUUklCVVRPUlMgU1BFQ0lGSUNBTExZIERJU0NMQUlNIEFOWSBXQVJSQU5USUVTLFxuICogSU5DTFVESU5HLCBCVVQgTk9UIExJTUlURUQgVE8sIFRIRSBJTVBMSUVEIFdBUlJBTlRJRVMgT0YgTUVSQ0hBTlRBQklMSVRZLFxuICogRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UsIEFORCBOT04tSU5GUklOR0VNRU5ULiAgVEhJUyBTT0ZUV0FSRSBJU1xuICogUFJPVklERUQgT04gQU4gXCJBUyBJU1wiIEJBU0lTLCBBTkQgVEhFIEFVVEhPUlMgQU5EIERJU1RSSUJVVE9SUyBIQVZFIE5PXG4gKiBPQkxJR0FUSU9OIFRPIFBST1ZJREUgTUFJTlRFTkFOQ0UsIFNVUFBPUlQsIFVQREFURVMsIEVOSEFOQ0VNRU5UUywgT1JcbiAqIE1PRElGSUNBVElPTlMuXG4gKi9cblxuXG4gIG1vZHVsZS5leHBvcnRzID0gQ29ucmVjO1xuXG4gIHZhciBFUFNJTE9OID0gMWUtMTA7XG5cbiAgZnVuY3Rpb24gcG9pbnRzRXF1YWwoYSwgYikge1xuICAgICAgdmFyIHggPSBhLnggLSBiLngsIHkgPSBhLnkgLSBiLnk7XG4gICAgICByZXR1cm4geCAqIHggKyB5ICogeSA8IEVQU0lMT047XG4gIH1cblxuICBmdW5jdGlvbiByZXZlcnNlTGlzdChsaXN0KSB7XG4gICAgICB2YXIgcHAgPSBsaXN0LmhlYWQ7XG5cbiAgICAgIHdoaWxlIChwcCkge1xuICAgICAgLy8gc3dhcCBwcmV2L25leHQgcG9pbnRlcnNcbiAgICAgICAgICB2YXIgdGVtcCA9IHBwLm5leHQ7XG4gICAgICAgICAgcHAubmV4dCA9IHBwLnByZXY7XG4gICAgICAgICAgcHAucHJldiA9IHRlbXA7XG5cbiAgICAgIC8vIGNvbnRpbnVlIHRocm91Z2ggdGhlIGxpc3RcbiAgICAgICAgICBwcCA9IHRlbXA7XG4gICAgICB9XG5cbiAgICAvLyBzd2FwIGhlYWQvdGFpbCBwb2ludGVyc1xuICAgICAgdmFyIHRlbXAgPSBsaXN0LmhlYWQ7XG4gICAgICBsaXN0LmhlYWQgPSBsaXN0LnRhaWw7XG4gICAgICBsaXN0LnRhaWwgPSB0ZW1wO1xuICB9XG5cbiAgZnVuY3Rpb24gQ29udG91ckJ1aWxkZXIobGV2ZWwpIHtcbiAgICAgIHRoaXMubGV2ZWwgPSBsZXZlbDtcbiAgICAgIHRoaXMucyA9IG51bGw7XG4gICAgICB0aGlzLmNvdW50ID0gMDtcbiAgfVxuICBDb250b3VyQnVpbGRlci5wcm90b3R5cGUucmVtb3ZlX3NlcSA9IGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgLy8gaWYgbGlzdCBpcyB0aGUgZmlyc3QgaXRlbSwgc3RhdGljIHB0ciBzIGlzIHVwZGF0ZWRcbiAgICAgIGlmIChsaXN0LnByZXYpIHtcbiAgICAgICAgICBsaXN0LnByZXYubmV4dCA9IGxpc3QubmV4dDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zID0gbGlzdC5uZXh0O1xuICAgICAgfVxuXG4gICAgICBpZiAobGlzdC5uZXh0KSB7XG4gICAgICAgICAgbGlzdC5uZXh0LnByZXYgPSBsaXN0LnByZXY7XG4gICAgICB9XG4gICAgICAtLXRoaXMuY291bnQ7XG4gIH07XG4gIENvbnRvdXJCdWlsZGVyLnByb3RvdHlwZS5hZGRTZWdtZW50ID0gZnVuY3Rpb24gKGEsIGIpIHtcbiAgICAgIHZhciBzcyA9IHRoaXMucztcbiAgICAgIHZhciBtYSA9IG51bGw7XG4gICAgICB2YXIgbWIgPSBudWxsO1xuICAgICAgdmFyIHByZXBlbmRBID0gZmFsc2U7XG4gICAgICB2YXIgcHJlcGVuZEIgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKHNzKSB7XG4gICAgICAgICAgaWYgKG1hID09IG51bGwpIHtcbiAgICAgICAgLy8gbm8gbWF0Y2ggZm9yIGEgeWV0XG4gICAgICAgICAgICAgIGlmIChwb2ludHNFcXVhbChhLCBzcy5oZWFkLnApKSB7XG4gICAgICAgICAgICAgICAgICBtYSA9IHNzO1xuICAgICAgICAgICAgICAgICAgcHJlcGVuZEEgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50c0VxdWFsKGEsIHNzLnRhaWwucCkpIHtcbiAgICAgICAgICAgICAgICAgIG1hID0gc3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1iID09IG51bGwpIHtcbiAgICAgICAgLy8gbm8gbWF0Y2ggZm9yIGIgeWV0XG4gICAgICAgICAgICAgIGlmIChwb2ludHNFcXVhbChiLCBzcy5oZWFkLnApKSB7XG4gICAgICAgICAgICAgICAgICBtYiA9IHNzO1xuICAgICAgICAgICAgICAgICAgcHJlcGVuZEIgPSB0cnVlO1xuICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBvaW50c0VxdWFsKGIsIHNzLnRhaWwucCkpIHtcbiAgICAgICAgICAgICAgICAgIG1iID0gc3M7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAvLyBpZiB3ZSBtYXRjaGVkIGJvdGggbm8gbmVlZCB0byBjb250aW51ZSBzZWFyY2hpbmdcbiAgICAgICAgICBpZiAobWIgIT0gbnVsbCAmJiBtYSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHNzID0gc3MubmV4dDtcbiAgICAgICAgICB9XG4gICAgICB9XG5cbiAgICAvLyBjIGlzIHRoZSBjYXNlIHNlbGVjdG9yIGJhc2VkIG9uIHdoaWNoIG9mIG1hIGFuZC9vciBtYiBhcmUgc2V0XG4gICAgICB2YXIgYyA9ICgobWEgIT0gbnVsbCkgPyAxIDogMCkgfCAoKG1iICE9IG51bGwpID8gMiA6IDApO1xuXG4gICAgICBzd2l0Y2ggKGMpIHtcbiAgICAgIGNhc2UgMDogICAvLyBib3RoIHVubWF0Y2hlZCwgYWRkIGFzIG5ldyBzZXF1ZW5jZVxuICAgICAgICAgIHZhciBhYSA9IHtwOiBhLCBwcmV2OiBudWxsfTtcbiAgICAgICAgICB2YXIgYmIgPSB7cDogYiwgbmV4dDogbnVsbH07XG4gICAgICAgICAgYWEubmV4dCA9IGJiO1xuICAgICAgICAgIGJiLnByZXYgPSBhYTtcblxuICAgICAgICAvLyBjcmVhdGUgc2VxdWVuY2UgZWxlbWVudCBhbmQgcHVzaCBvbnRvIGhlYWQgb2YgbWFpbiBsaXN0LiBUaGUgb3JkZXJcbiAgICAgICAgLy8gb2YgaXRlbXMgaW4gdGhpcyBsaXN0IGlzIHVuaW1wb3J0YW50XG4gICAgICAgICAgbWEgPSB7aGVhZDogYWEsIHRhaWw6IGJiLCBuZXh0OiB0aGlzLnMsIHByZXY6IG51bGwsIGNsb3NlZDogZmFsc2V9O1xuICAgICAgICAgIGlmICh0aGlzLnMpIHtcbiAgICAgICAgICAgICAgdGhpcy5zLnByZXYgPSBtYTtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhpcy5zID0gbWE7XG5cbiAgICAgICAgICArK3RoaXMuY291bnQ7ICAgIC8vIG5vdCBlc3NlbnRpYWwgLSB0cmFja3MgbnVtYmVyIG9mIHVubWVyZ2VkIHNlcXVlbmNlc1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIDE6ICAgLy8gYSBtYXRjaGVkLCBiIGRpZCBub3QgLSB0aHVzIGIgZXh0ZW5kcyBzZXF1ZW5jZSBtYVxuICAgICAgICAgIHZhciBwcCA9IHtwOiBifTtcblxuICAgICAgICAgIGlmIChwcmVwZW5kQSkge1xuICAgICAgICAgICAgICBwcC5uZXh0ID0gbWEuaGVhZDtcbiAgICAgICAgICAgICAgcHAucHJldiA9IG51bGw7XG4gICAgICAgICAgICAgIG1hLmhlYWQucHJldiA9IHBwO1xuICAgICAgICAgICAgICBtYS5oZWFkID0gcHA7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcHAubmV4dCA9IG51bGw7XG4gICAgICAgICAgICAgIHBwLnByZXYgPSBtYS50YWlsO1xuICAgICAgICAgICAgICBtYS50YWlsLm5leHQgPSBwcDtcbiAgICAgICAgICAgICAgbWEudGFpbCA9IHBwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcblxuICAgICAgY2FzZSAyOiAgIC8vIGIgbWF0Y2hlZCwgYSBkaWQgbm90IC0gdGh1cyBhIGV4dGVuZHMgc2VxdWVuY2UgbWJcbiAgICAgICAgICB2YXIgcHAgPSB7cDogYX07XG5cbiAgICAgICAgICBpZiAocHJlcGVuZEIpIHtcbiAgICAgICAgICAgICAgcHAubmV4dCA9IG1iLmhlYWQ7XG4gICAgICAgICAgICAgIHBwLnByZXYgPSBudWxsO1xuICAgICAgICAgICAgICBtYi5oZWFkLnByZXYgPSBwcDtcbiAgICAgICAgICAgICAgbWIuaGVhZCA9IHBwO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHBwLm5leHQgPSBudWxsO1xuICAgICAgICAgICAgICBwcC5wcmV2ID0gbWIudGFpbDtcbiAgICAgICAgICAgICAgbWIudGFpbC5uZXh0ID0gcHA7XG4gICAgICAgICAgICAgIG1iLnRhaWwgPSBwcDtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG5cbiAgICAgIGNhc2UgMzogICAvLyBib3RoIG1hdGNoZWQsIGNhbiBtZXJnZSBzZXF1ZW5jZXNcbiAgICAgICAgLy8gaWYgdGhlIHNlcXVlbmNlcyBhcmUgdGhlIHNhbWUsIGRvIG5vdGhpbmcsIGFzIHdlIGFyZSBzaW1wbHkgY2xvc2luZyB0aGlzIHBhdGggKGNvdWxkIHNldCBhIGZsYWcpXG5cbiAgICAgICAgICBpZiAobWEgPT09IG1iKSB7XG4gICAgICAgICAgICAgIHZhciBwcCA9IHtwOiBtYS50YWlsLnAsIG5leHQ6IG1hLmhlYWQsIHByZXY6IG51bGx9O1xuICAgICAgICAgICAgICBtYS5oZWFkLnByZXYgPSBwcDtcbiAgICAgICAgICAgICAgbWEuaGVhZCA9IHBwO1xuICAgICAgICAgICAgICBtYS5jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG5cbiAgICAgICAgLy8gdGhlcmUgYXJlIDQgd2F5cyB0aGUgc2VxdWVuY2UgcGFpciBjYW4gYmUgam9pbmVkLiBUaGUgY3VycmVudCBzZXR0aW5nIG9mIHByZXBlbmRBIGFuZFxuICAgICAgICAvLyBwcmVwZW5kQiB3aWxsIHRlbGwgdXMgd2hpY2ggdHlwZSBvZiBqb2luIGlzIG5lZWRlZC4gRm9yIGhlYWQvaGVhZCBhbmQgdGFpbC90YWlsIGpvaW5zXG4gICAgICAgIC8vIG9uZSBzZXF1ZW5jZSBuZWVkcyB0byBiZSByZXZlcnNlZFxuICAgICAgICAgIHN3aXRjaCAoKHByZXBlbmRBID8gMSA6IDApIHwgKHByZXBlbmRCID8gMiA6IDApKSB7XG4gICAgICAgICAgY2FzZSAwOiAgIC8vIHRhaWwtdGFpbFxuICAgICAgICAgICAgLy8gcmV2ZXJzZSBtYSBhbmQgYXBwZW5kIHRvIG1iXG4gICAgICAgICAgICAgIHJldmVyc2VMaXN0KG1hKTtcbiAgICAgICAgICAgIC8vIGZhbGwgdGhyb3VnaCB0byBoZWFkL3RhaWwgY2FzZVxuICAgICAgICAgIGNhc2UgMTogICAvLyBoZWFkLXRhaWxcbiAgICAgICAgICAgIC8vIG1hIGlzIGFwcGVuZGVkIHRvIG1iIGFuZCBtYSBkaXNjYXJkZWRcbiAgICAgICAgICAgICAgbWIudGFpbC5uZXh0ID0gbWEuaGVhZDtcbiAgICAgICAgICAgICAgbWEuaGVhZC5wcmV2ID0gbWIudGFpbDtcbiAgICAgICAgICAgICAgbWIudGFpbCA9IG1hLnRhaWw7XG5cbiAgICAgICAgICAgIC8vZGlzY2FyZCBtYSBzZXF1ZW5jZSByZWNvcmRcbiAgICAgICAgICAgICAgdGhpcy5yZW1vdmVfc2VxKG1hKTtcbiAgICAgICAgICAgICAgYnJlYWs7XG5cbiAgICAgICAgICBjYXNlIDM6ICAgLy8gaGVhZC1oZWFkXG4gICAgICAgICAgICAvLyByZXZlcnNlIG1hIGFuZCBhcHBlbmQgbWIgdG8gaXRcbiAgICAgICAgICAgICAgcmV2ZXJzZUxpc3QobWEpO1xuICAgICAgICAgICAgLy8gZmFsbCB0aHJvdWdoIHRvIHRhaWwvaGVhZCBjYXNlXG4gICAgICAgICAgY2FzZSAyOiAgIC8vIHRhaWwtaGVhZFxuICAgICAgICAgICAgLy8gbWIgaXMgYXBwZW5kZWQgdG8gbWEgYW5kIG1iIGlzIGRpc2NhcmRlZFxuICAgICAgICAgICAgICBtYS50YWlsLm5leHQgPSBtYi5oZWFkO1xuICAgICAgICAgICAgICBtYi5oZWFkLnByZXYgPSBtYS50YWlsO1xuICAgICAgICAgICAgICBtYS50YWlsID0gbWIudGFpbDtcblxuICAgICAgICAgICAgLy9kaXNjYXJkIG1iIHNlcXVlbmNlIHJlY29yZFxuICAgICAgICAgICAgICB0aGlzLnJlbW92ZV9zZXEobWIpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH07XG5cbiAgLypcbiAgICogSW1wbGVtZW50cyBDT05SRUMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb259IGRyYXdDb250b3VyIGZ1bmN0aW9uIGZvciBkcmF3aW5nIGNvbnRvdXIuICBEZWZhdWx0cyB0byBhXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGN1c3RvbSBcImNvbnRvdXIgYnVpbGRlclwiLCB3aGljaCBwb3B1bGF0ZXMgdGhlXG4gICAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRvdXJzIHByb3BlcnR5LlxuICAgKi9cbiAgZnVuY3Rpb24gQ29ucmVjKGRyYXdDb250b3VyKSB7XG4gICAgICBpZiAoIWRyYXdDb250b3VyKSB7XG4gICAgICAgICAgdmFyIGMgPSB0aGlzO1xuICAgICAgICAgIGMuY29udG91cnMgPSB7fTtcbiAgICAgIC8qKlxuICAgICAgICogZHJhd0NvbnRvdXIgLSBpbnRlcmZhY2UgZm9yIGltcGxlbWVudGluZyB0aGUgdXNlciBzdXBwbGllZCBtZXRob2QgdG9cbiAgICAgICAqIHJlbmRlciB0aGUgY291bnRvdXJzLlxuICAgICAgICpcbiAgICAgICAqIERyYXdzIGEgbGluZSBiZXR3ZWVuIHRoZSBzdGFydCBhbmQgZW5kIGNvb3JkaW5hdGVzLlxuICAgICAgICpcbiAgICAgICAqIEBwcml2YXRlXG4gICAgICAgKiBAcGFyYW0gc3RhcnRYICAgIC0gc3RhcnQgY29vcmRpbmF0ZSBmb3IgWFxuICAgICAgICogQHBhcmFtIHN0YXJ0WSAgICAtIHN0YXJ0IGNvb3JkaW5hdGUgZm9yIFlcbiAgICAgICAqIEBwYXJhbSBlbmRYICAgICAgLSBlbmQgY29vcmRpbmF0ZSBmb3IgWFxuICAgICAgICogQHBhcmFtIGVuZFkgICAgICAtIGVuZCBjb29yZGluYXRlIGZvciBZXG4gICAgICAgKiBAcGFyYW0gY29udG91ckxldmVsIC0gQ29udG91ciBsZXZlbCBmb3IgbGluZS5cbiAgICAgICAqL1xuICAgICAgICAgIHRoaXMuZHJhd0NvbnRvdXIgPSBmdW5jdGlvbiAoc3RhcnRYLCBzdGFydFksIGVuZFgsIGVuZFksIGNvbnRvdXJMZXZlbCwgaykge1xuICAgICAgICAgICAgICB2YXIgY2IgPSBjLmNvbnRvdXJzW2tdO1xuICAgICAgICAgICAgICBpZiAoIWNiKSB7XG4gICAgICAgICAgICAgICAgICBjYiA9IGMuY29udG91cnNba10gPSBuZXcgQ29udG91ckJ1aWxkZXIoY29udG91ckxldmVsKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYi5hZGRTZWdtZW50KHt4OiBzdGFydFgsIHk6IHN0YXJ0WX0sIHt4OiBlbmRYLCB5OiBlbmRZfSk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICB0aGlzLmNvbnRvdXJMaXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICB2YXIgbCA9IFtdO1xuICAgICAgICAgICAgICB2YXIgYSA9IGMuY29udG91cnM7XG4gICAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYSkge1xuICAgICAgICAgICAgICAgICAgdmFyIHMgPSBhW2tdLnM7XG4gICAgICAgICAgICAgICAgICB2YXIgbGV2ZWwgPSBhW2tdLmxldmVsO1xuICAgICAgICAgICAgICAgICAgd2hpbGUgKHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgaCA9IHMuaGVhZDtcbiAgICAgICAgICAgICAgICAgICAgICB2YXIgbDIgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICBsMi5sZXZlbCA9IGxldmVsO1xuICAgICAgICAgICAgICAgICAgICAgIGwyLmsgPSBrO1xuICAgICAgICAgICAgICAgICAgICAgIHdoaWxlIChoICYmIGgucCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBsMi5wdXNoKGgucCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGggPSBoLm5leHQ7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIGwucHVzaChsMik7XG4gICAgICAgICAgICAgICAgICAgICAgcyA9IHMubmV4dDtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBsLnNvcnQoZnVuY3Rpb24gKGEsIGIpIHsgcmV0dXJuIGEuayAtIGIuazsgfSk7XG4gICAgICAgICAgICAgIHJldHVybiBsO1xuICAgICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMuZHJhd0NvbnRvdXIgPSBkcmF3Q29udG91cjtcbiAgICAgIH1cbiAgICAgIHRoaXMuaCAgPSBuZXcgQXJyYXkoNSk7XG4gICAgICB0aGlzLnNoID0gbmV3IEFycmF5KDUpO1xuICAgICAgdGhpcy54aCA9IG5ldyBBcnJheSg1KTtcbiAgICAgIHRoaXMueWggPSBuZXcgQXJyYXkoNSk7XG4gIH1cblxuICAvKlxuICAgKiBjb250b3VyIGlzIGEgY29udG91cmluZyBzdWJyb3V0aW5lIGZvciByZWN0YW5ndWxhcmlseSBzcGFjZWQgZGF0YVxuICAgKlxuICAgKiBJdCBlbWl0cyBjYWxscyB0byBhIGxpbmUgZHJhd2luZyBzdWJyb3V0aW5lIHN1cHBsaWVkIGJ5IHRoZSB1c2VyIHdoaWNoXG4gICAqIGRyYXdzIGEgY29udG91ciBtYXAgY29ycmVzcG9uZGluZyB0byByZWFsKjRkYXRhIG9uIGEgcmFuZG9tbHkgc3BhY2VkXG4gICAqIHJlY3Rhbmd1bGFyIGdyaWQuIFRoZSBjb29yZGluYXRlcyBlbWl0dGVkIGFyZSBpbiB0aGUgc2FtZSB1bml0cyBnaXZlbiBpblxuICAgKiB0aGUgeCgpIGFuZCB5KCkgYXJyYXlzLlxuICAgKlxuICAgKiBBbnkgbnVtYmVyIG9mIGNvbnRvdXIgbGV2ZWxzIG1heSBiZSBzcGVjaWZpZWQgYnV0IHRoZXkgbXVzdCBiZSBpbiBvcmRlciBvZlxuICAgKiBpbmNyZWFzaW5nIHZhbHVlLlxuICAgKlxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcltdW119IGQgLSBtYXRyaXggb2YgZGF0YSB0byBjb250b3VyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbGIsaXViLGpsYixqdWIgLSBpbmRleCBib3VuZHMgb2YgZGF0YSBtYXRyaXhcbiAgICpcbiAgICogICAgICAgICAgICAgVGhlIGZvbGxvd2luZyB0d28sIG9uZSBkaW1lbnNpb25hbCBhcnJheXMgKHggYW5kIHkpIGNvbnRhaW5cbiAgICogICAgICAgICAgICAgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGNvb3JkaW5hdGVzIG9mIGVhY2ggc2FtcGxlIHBvaW50cy5cbiAgICogQHBhcmFtIHtudW1iZXJbXX0geCAgLSBkYXRhIG1hdHJpeCBjb2x1bW4gY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtudW1iZXJbXX0geSAgLSBkYXRhIG1hdHJpeCByb3cgY29vcmRpbmF0ZXNcbiAgICogQHBhcmFtIHtudW1iZXJ9IG5jICAgLSBudW1iZXIgb2YgY29udG91ciBsZXZlbHNcbiAgICogQHBhcmFtIHtudW1iZXJbXX0geiAgLSBjb250b3VyIGxldmVscyBpbiBpbmNyZWFzaW5nIG9yZGVyLlxuICAgKi9cbiAgQ29ucmVjLnByb3RvdHlwZS5jb250b3VyID0gZnVuY3Rpb24gKGQsIGlsYiwgaXViLCBqbGIsIGp1YiwgeCwgeSwgbmMsIHopIHtcbiAgICAgIHZhciBoID0gdGhpcy5oLCBzaCA9IHRoaXMuc2gsIHhoID0gdGhpcy54aCwgeWggPSB0aGlzLnloO1xuICAgICAgdmFyIGRyYXdDb250b3VyID0gdGhpcy5kcmF3Q29udG91cjtcbiAgICAgIHRoaXMuY29udG91cnMgPSB7fTtcblxuICAgICAgdmFyIHhzZWN0ID0gZnVuY3Rpb24gKHAxLCBwMikge1xuICAgICAgICAgIHJldHVybiAoaFtwMl0gKiB4aFtwMV0gLSBoW3AxXSAqIHhoW3AyXSkgLyAoaFtwMl0gLSBoW3AxXSk7XG4gICAgICB9O1xuXG4gICAgICB2YXIgeXNlY3QgPSBmdW5jdGlvbiAocDEsIHAyKSB7XG4gICAgICAgICAgcmV0dXJuIChoW3AyXSAqIHloW3AxXSAtIGhbcDFdICogeWhbcDJdKSAvIChoW3AyXSAtIGhbcDFdKTtcbiAgICAgIH07XG4gICAgICB2YXIgbTE7XG4gICAgICB2YXIgbTI7XG4gICAgICB2YXIgbTM7XG4gICAgICB2YXIgY2FzZV92YWx1ZTtcbiAgICAgIHZhciBkbWluO1xuICAgICAgdmFyIGRtYXg7XG4gICAgICB2YXIgeDEgPSAwLjA7XG4gICAgICB2YXIgeDIgPSAwLjA7XG4gICAgICB2YXIgeTEgPSAwLjA7XG4gICAgICB2YXIgeTIgPSAwLjA7XG5cbiAgICAvLyBUaGUgaW5kZXhpbmcgb2YgaW0gYW5kIGptIHNob3VsZCBiZSBub3RlZCBhcyBpdCBoYXMgdG8gc3RhcnQgZnJvbSB6ZXJvXG4gICAgLy8gdW5saWtlIHRoZSBmb3J0cmFuIGNvdW50ZXIgcGFydFxuICAgICAgdmFyIGltID0gWzAsIDEsIDEsIDBdO1xuICAgICAgdmFyIGptID0gWzAsIDAsIDEsIDFdO1xuXG4gICAgLy8gTm90ZSB0aGF0IGNhc3RhYiBpcyBhcnJhbmdlZCBkaWZmZXJlbnRseSBmcm9tIHRoZSBGT1JUUkFOIGNvZGUgYmVjYXVzZVxuICAgIC8vIEZvcnRyYW4gYW5kIEMvQysrIGFycmF5cyBhcmUgdHJhbnNwb3NlZCBvZiBlYWNoIG90aGVyLCBpbiB0aGlzIGNhc2VcbiAgICAvLyBpdCBpcyBtb3JlIHRyaWNreSBhcyBjYXN0YWIgaXMgaW4gMyBkaW1lbnNpb25zXG4gICAgICB2YXIgY2FzdGFiID0gW1xuICAgICAgICAgIFtcbiAgICAgICAgWzAsIDAsIDhdLCBbMCwgMiwgNV0sIFs3LCA2LCA5XVxuICAgICAgICAgIF0sXG4gICAgICAgICAgW1xuICAgICAgICBbMCwgMywgNF0sIFsxLCAzLCAxXSwgWzQsIDMsIDBdXG4gICAgICAgICAgXSxcbiAgICAgICAgICBbXG4gICAgICAgIFs5LCA2LCA3XSwgWzUsIDIsIDBdLCBbOCwgMCwgMF1cbiAgICAgICAgICBdXG4gICAgICBdO1xuXG4gICAgICBmb3IgKHZhciBqID0gKGp1YiAtIDEpOyBqID49IGpsYjsgai0tKSB7XG4gICAgICAgICAgZm9yICh2YXIgaSA9IGlsYjsgaSA8PSBpdWIgLSAxOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFyIHRlbXAxLCB0ZW1wMjtcbiAgICAgICAgICAgICAgdGVtcDEgPSBNYXRoLm1pbihkW2ldW2pdLCBkW2ldW2ogKyAxXSk7XG4gICAgICAgICAgICAgIHRlbXAyID0gTWF0aC5taW4oZFtpICsgMV1bal0sIGRbaSArIDFdW2ogKyAxXSk7XG4gICAgICAgICAgICAgIGRtaW4gID0gTWF0aC5taW4odGVtcDEsIHRlbXAyKTtcbiAgICAgICAgICAgICAgdGVtcDEgPSBNYXRoLm1heChkW2ldW2pdLCBkW2ldW2ogKyAxXSk7XG4gICAgICAgICAgICAgIHRlbXAyID0gTWF0aC5tYXgoZFtpICsgMV1bal0sIGRbaSArIDFdW2ogKyAxXSk7XG4gICAgICAgICAgICAgIGRtYXggID0gTWF0aC5tYXgodGVtcDEsIHRlbXAyKTtcblxuICAgICAgICAgICAgICBpZiAoZG1heCA+PSB6WzBdICYmIGRtaW4gPD0geltuYyAtIDFdKSB7XG4gICAgICAgICAgICAgICAgICBmb3IgKHZhciBrID0gMDsgayA8IG5jOyBrKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoeltrXSA+PSBkbWluICYmIHpba10gPD0gZG1heCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBtID0gNDsgbSA+PSAwOyBtLS0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobSA+IDApIHtcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSBpbmRleGluZyBvZiBpbSBhbmQgam0gc2hvdWxkIGJlIG5vdGVkIGFzIGl0IGhhcyB0b1xuICAgICAgICAgICAgICAgICAgLy8gc3RhcnQgZnJvbSB6ZXJvXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoW21dID0gZFtpICsgaW1bbSAtIDFdXVtqICsgam1bbSAtIDFdXSAtIHpba107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4aFttXSA9IHhbaSArIGltW20gLSAxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aFttXSA9IHlbaiArIGptW20gLSAxXV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBoWzBdID0gMC4yNSAqIChoWzFdICsgaFsyXSArIGhbM10gKyBoWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHhoWzBdID0gMC41ICogKHhbaV0gKyB4W2kgKyAxXSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5aFswXSA9IDAuNSAqICh5W2pdICsgeVtqICsgMV0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhbbV0gPiBFUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaFttXSA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaFttXSA8IC1FUFNJTE9OKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hbbV0gPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZVxuICAgICAgICAgICAgICAgICAgc2hbbV0gPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAvL1xuICAgICAgICAgICAgICAvLyBOb3RlOiBhdCB0aGlzIHN0YWdlIHRoZSByZWxhdGl2ZSBoZWlnaHRzIG9mIHRoZSBjb3JuZXJzIGFuZCB0aGVcbiAgICAgICAgICAgICAgLy8gY2VudHJlIGFyZSBpbiB0aGUgaCBhcnJheSwgYW5kIHRoZSBjb3JyZXNwb25kaW5nIGNvb3JkaW5hdGVzIGFyZVxuICAgICAgICAgICAgICAvLyBpbiB0aGUgeGggYW5kIHloIGFycmF5cy4gVGhlIGNlbnRyZSBvZiB0aGUgYm94IGlzIGluZGV4ZWQgYnkgMFxuICAgICAgICAgICAgICAvLyBhbmQgdGhlIDQgY29ybmVycyBieSAxIHRvIDQgYXMgc2hvd24gYmVsb3cuXG4gICAgICAgICAgICAgIC8vIEVhY2ggdHJpYW5nbGUgaXMgdGhlbiBpbmRleGVkIGJ5IHRoZSBwYXJhbWV0ZXIgbSwgYW5kIHRoZSAzXG4gICAgICAgICAgICAgIC8vIHZlcnRpY2VzIG9mIGVhY2ggdHJpYW5nbGUgYXJlIGluZGV4ZWQgYnkgcGFyYW1ldGVycyBtMSxtMixhbmRcbiAgICAgICAgICAgICAgLy8gbTMuXG4gICAgICAgICAgICAgIC8vIEl0IGlzIGFzc3VtZWQgdGhhdCB0aGUgY2VudHJlIG9mIHRoZSBib3ggaXMgYWx3YXlzIHZlcnRleCAyXG4gICAgICAgICAgICAgIC8vIHRob3VnaCB0aGlzIGlzaW1wb3J0YW50IG9ubHkgd2hlbiBhbGwgMyB2ZXJ0aWNlcyBsaWUgZXhhY3RseSBvblxuICAgICAgICAgICAgICAvLyB0aGUgc2FtZSBjb250b3VyIGxldmVsLCBpbiB3aGljaCBjYXNlIG9ubHkgdGhlIHNpZGUgb2YgdGhlIGJveFxuICAgICAgICAgICAgICAvLyBpcyBkcmF3bi5cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgLy8gICAgICB2ZXJ0ZXggNCArLS0tLS0tLS0tLS0tLS0tLS0tLSsgdmVydGV4IDNcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8IFxcICAgICAgICAgICAgICAgLyB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgIFxcICAgIG0tMyAgICAvICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICAgIFxcICAgICAgIC8gICAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgICAgIFxcICAgLyAgICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgbT0yICAgIFggICBtPTIgICB8ICAgICAgIHRoZSBjZW50cmUgaXMgdmVydGV4IDBcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8ICAgICAgIC8gICBcXCAgICAgICB8XG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgfCAgICAgLyAgICAgICBcXCAgICAgfFxuICAgICAgICAgICAgICAvLyAgICAgICAgICAgICAgIHwgICAvICAgIG09MSAgICBcXCAgIHxcbiAgICAgICAgICAgICAgLy8gICAgICAgICAgICAgICB8IC8gICAgICAgICAgICAgICBcXCB8XG4gICAgICAgICAgICAgIC8vICAgICAgdmVydGV4IDEgKy0tLS0tLS0tLS0tLS0tLS0tLS0rIHZlcnRleCAyXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vXG4gICAgICAgICAgICAgIC8vICAgICAgICAgICAgICAgU2NhbiBlYWNoIHRyaWFuZ2xlIGluIHRoZSBib3hcbiAgICAgICAgICAgICAgLy9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChtID0gMTsgbSA8PSA0OyBtKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMSA9IG07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbTIgPSAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChtICE9IDQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG0zID0gbSArIDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtMyA9IDE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlX3ZhbHVlID0gY2FzdGFiW3NoW20xXSArIDFdW3NoW20yXSArIDFdW3NoW20zXSArIDFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYXNlX3ZhbHVlICE9IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoY2FzZV92YWx1ZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTogLy8gTGluZSBiZXR3ZWVuIHZlcnRpY2VzIDEgYW5kIDJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTFdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhoW20yXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMjogLy8gTGluZSBiZXR3ZWVuIHZlcnRpY2VzIDIgYW5kIDNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhoW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMzogLy8gTGluZSBiZXR3ZWVuIHZlcnRpY2VzIDMgYW5kIDFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTNdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhoW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDogLy8gTGluZSBiZXR3ZWVuIHZlcnRleCAxIGFuZCBzaWRlIDItM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20xXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttMV07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IC8vIExpbmUgYmV0d2VlbiB2ZXJ0ZXggMiBhbmQgc2lkZSAzLTFcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4aFttMl07XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geWhbbTJdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA2OiAvLyAgTGluZSBiZXR3ZWVuIHZlcnRleCAzIGFuZCBzaWRlIDEtMlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhoW20zXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5aFttM107XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDc6IC8vIExpbmUgYmV0d2VlbiBzaWRlcyAxLTIgYW5kIDItM1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MSA9IHhzZWN0KG0xLCBtMik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkxID0geXNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDIgPSB4c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MiA9IHlzZWN0KG0yLCBtMyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgODogLy8gTGluZSBiZXR3ZWVuIHNpZGVzIDItMyBhbmQgMy0xXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgxID0geHNlY3QobTIsIG0zKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTEgPSB5c2VjdChtMiwgbTMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB4MiA9IHhzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHkyID0geXNlY3QobTMsIG0xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA5OiAvLyBMaW5lIGJldHdlZW4gc2lkZXMgMy0xIGFuZCAxLTJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeDEgPSB4c2VjdChtMywgbTEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB5MSA9IHlzZWN0KG0zLCBtMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHgyID0geHNlY3QobTEsIG0yKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeTIgPSB5c2VjdChtMSwgbTIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAvLyBQdXQgeW91ciBwcm9jZXNzaW5nIGNvZGUgaGVyZSBhbmQgY29tbWVudCBvdXQgdGhlIHByaW50ZlxuICAgICAgICAgICAgICAgICAgLy9wcmludGYoXCIlZiAlZiAlZiAlZiAlZlxcblwiLHgxLHkxLHgyLHkyLHpba10pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZHJhd0NvbnRvdXIoeDEsIHkxLCB4MiwgeTIsIHpba10sIGspO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgfVxuICB9O1xuIiwiLy9odHRwczovL2dpdGh1Yi5jb20vamFzb25kYXZpZXMvY29ucmVjLmpzXG4vL2h0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMjYzMzA1L2RyYXdpbmctYS10b3BvZ3JhcGhpY2FsLW1hcFxudmFyIHRpbiA9IHJlcXVpcmUoJ3R1cmYtdGluJyk7XG52YXIgaW5zaWRlID0gcmVxdWlyZSgndHVyZi1pbnNpZGUnKTtcbnZhciBncmlkID0gcmVxdWlyZSgndHVyZi1ncmlkJyk7XG52YXIgYmJveCA9IHJlcXVpcmUoJ3R1cmYtYmJveCcpO1xudmFyIHBsYW5lcG9pbnQgPSByZXF1aXJlKCd0dXJmLXBsYW5lcG9pbnQnKTtcbnZhciBmZWF0dXJlY29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xudmFyIGxpbmVzdHJpbmcgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5saW5lU3RyaW5nO1xudmFyIHNxdWFyZSA9IHJlcXVpcmUoJ3R1cmYtc3F1YXJlJyk7XG52YXIgQ29ucmVjID0gcmVxdWlyZSgnLi9jb25yZWMnKTtcblxuLyoqXG4gKiBUYWtlcyB7QGxpbmsgUG9pbnR8cG9pbnRzfSB3aXRoIHotdmFsdWVzIGFuZCBhbiBhcnJheSBvZlxuICogdmFsdWUgYnJlYWtzIGFuZCBnZW5lcmF0ZXMgW2lzb2xpbmVzXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0lzb2xpbmUpLlxuICpcbiAqIEBuYW1lIGlzb2xpbmVzXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gcG9pbnRzIGlucHV0IHBvaW50c1xuICogQHBhcmFtIHtzdHJpbmd9IHogdGhlIHByb3BlcnR5IG5hbWUgaW4gYHBvaW50c2AgZnJvbSB3aGljaCB6LXZhbHVlcyB3aWxsIGJlIHB1bGxlZFxuICogQHBhcmFtIHtudW1iZXJ9IHJlc29sdXRpb24gcmVzb2x1dGlvbiBvZiB0aGUgdW5kZXJseWluZyBncmlkXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJyZWFrcyB3aGVyZSB0byBkcmF3IGNvbnRvdXJzXG4gKiBAcmV0dXJucyB7RmVhdHVyZUNvbGxlY3Rpb248TGluZVN0cmluZz59IGlzb2xpbmVzXG4gKiBAZXhhbXBsZVxuICogLy8gY3JlYXRlIHJhbmRvbSBwb2ludHMgd2l0aCByYW5kb21cbiAqIC8vIHotdmFsdWVzIGluIHRoZWlyIHByb3BlcnRpZXNcbiAqIHZhciBwb2ludHMgPSB0dXJmLnJhbmRvbSgncG9pbnQnLCAxMDAsIHtcbiAqICAgYmJveDogWzAsIDMwLCAyMCwgNTBdXG4gKiB9KTtcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gKiAgIHBvaW50cy5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLnogPSBNYXRoLnJhbmRvbSgpICogMTA7XG4gKiB9XG4gKiB2YXIgYnJlYWtzID0gWzAsIDEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXTtcbiAqIHZhciBpc29saW5lZCA9IHR1cmYuaXNvbGluZXMocG9pbnRzLCAneicsIDE1LCBicmVha3MpO1xuICogLy89aXNvbGluZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAocG9pbnRzLCB6LCByZXNvbHV0aW9uLCBicmVha3MpIHtcbiAgICB2YXIgdGluUmVzdWx0ID0gdGluKHBvaW50cywgeik7XG4gICAgdmFyIGJib3hCQm94ID0gYmJveChwb2ludHMpO1xuICAgIHZhciBzcXVhcmVCQm94ID0gc3F1YXJlKGJib3hCQm94KTtcbiAgICB2YXIgZ3JpZFJlc3VsdCA9IGdyaWQoc3F1YXJlQkJveCwgcmVzb2x1dGlvbik7XG4gICAgdmFyIGRhdGEgPSBbXTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZ3JpZFJlc3VsdC5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgcHQgPSBncmlkUmVzdWx0LmZlYXR1cmVzW2ldO1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpblJlc3VsdC5mZWF0dXJlcy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgdmFyIHRyaWFuZ2xlID0gdGluUmVzdWx0LmZlYXR1cmVzW2pdO1xuICAgICAgICAgICAgaWYgKGluc2lkZShwdCwgdHJpYW5nbGUpKSB7XG4gICAgICAgICAgICAgICAgcHQucHJvcGVydGllcyA9IHt9O1xuICAgICAgICAgICAgICAgIHB0LnByb3BlcnRpZXNbel0gPSBwbGFuZXBvaW50KHB0LCB0cmlhbmdsZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgZGVwdGggPSBNYXRoLnNxcnQoZ3JpZFJlc3VsdC5mZWF0dXJlcy5sZW5ndGgpO1xuICAgIGZvciAodmFyIHggPSAwOyB4IDwgZGVwdGg7IHgrKykge1xuICAgICAgICB2YXIgeEdyb3VwID0gZ3JpZFJlc3VsdC5mZWF0dXJlcy5zbGljZSh4ICogZGVwdGgsICh4ICsgMSkgKiBkZXB0aCk7XG4gICAgICAgIHZhciB4RmxhdCA9IFtdO1xuXG4gICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgeEdyb3VwLmxlbmd0aDsgZysrKSB7XG4gICAgICAgICAgICBpZiAoeEdyb3VwW2ddLnByb3BlcnRpZXMpIHtcbiAgICAgICAgICAgICAgICB4RmxhdC5wdXNoKHhHcm91cFtnXS5wcm9wZXJ0aWVzW3pdKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgeEZsYXQucHVzaCgwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBkYXRhLnB1c2goeEZsYXQpO1xuICAgIH1cbiAgICB2YXIgaW50ZXJ2YWwgPSAoc3F1YXJlQkJveFsyXSAtIHNxdWFyZUJCb3hbMF0pIC8gZGVwdGg7XG4gICAgdmFyIHhDb29yZGluYXRlcyA9IFtdO1xuICAgIHZhciB5Q29vcmRpbmF0ZXMgPSBbXTtcbiAgICBmb3IgKHZhciBkID0gMDsgZCA8IGRlcHRoOyBkKyspIHtcbiAgICAgICAgeENvb3JkaW5hdGVzLnB1c2goZCAqIGludGVydmFsICsgc3F1YXJlQkJveFswXSk7XG4gICAgICAgIHlDb29yZGluYXRlcy5wdXNoKGQgKiBpbnRlcnZhbCArIHNxdWFyZUJCb3hbMV0pO1xuICAgIH1cblxuICAgIHZhciBjID0gbmV3IENvbnJlYygpO1xuICAgIGMuY29udG91cihkYXRhLCAwLCByZXNvbHV0aW9uLCAwLCByZXNvbHV0aW9uLCB4Q29vcmRpbmF0ZXMsIHlDb29yZGluYXRlcywgYnJlYWtzLmxlbmd0aCwgYnJlYWtzKTtcbiAgICB2YXIgY29udG91ckxpc3QgPSBjLmNvbnRvdXJMaXN0KCk7XG5cbiAgICB2YXIgZmMgPSBmZWF0dXJlY29sbGVjdGlvbihbXSk7XG4gICAgY29udG91ckxpc3QuZm9yRWFjaChmdW5jdGlvbiAoYykge1xuICAgICAgICBpZiAoYy5sZW5ndGggPiAyKSB7XG4gICAgICAgICAgICB2YXIgcG9seUNvb3JkaW5hdGVzID0gW107XG4gICAgICAgICAgICBjLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkKSB7XG4gICAgICAgICAgICAgICAgcG9seUNvb3JkaW5hdGVzLnB1c2goW2Nvb3JkLngsIGNvb3JkLnldKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdmFyIHBvbHkgPSBsaW5lc3RyaW5nKHBvbHlDb29yZGluYXRlcyk7XG4gICAgICAgICAgICBwb2x5LnByb3BlcnRpZXMgPSB7fTtcbiAgICAgICAgICAgIHBvbHkucHJvcGVydGllc1t6XSA9IGMubGV2ZWw7XG5cbiAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seSk7XG4gICAgICAgIH1cbiAgICB9KTtcblxuICAgIHJldHVybiBmYztcbn07XG4iLCIvKipcbiAqIFRha2VzIGEge0BsaW5rIFBvbHlnb258cG9seWdvbn0gYW5kIHJldHVybnMge0BsaW5rIFBvaW50fHBvaW50c30gYXQgYWxsIHNlbGYtaW50ZXJzZWN0aW9ucy5cbiAqXG4gKiBAbmFtZSBraW5rc1xuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fFBvbHlnb259IHBvbHlnb24gaW5wdXQgcG9seWdvblxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gc2VsZi1pbnRlcnNlY3Rpb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy0xMi4wMzQ4MzUsIDguOTAxMTgzXSxcbiAqICAgICAgIFstMTIuMDYwNDEzLCA4Ljg5OTgyNl0sXG4gKiAgICAgICBbLTEyLjAzNjM4LCA4Ljg3MzE5OV0sXG4gKiAgICAgICBbLTEyLjA1OTM4MywgOC44NzE0MThdLFxuICogICAgICAgWy0xMi4wMzQ4MzUsIDguOTAxMTgzXVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGtpbmtzID0gdHVyZi5raW5rcyhwb2x5KTtcbiAqXG4gKiB2YXIgcmVzdWx0RmVhdHVyZXMgPSBraW5rcy5pbnRlcnNlY3Rpb25zLmZlYXR1cmVzLmNvbmNhdChwb2x5KTtcbiAqIHZhciByZXN1bHQgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogcmVzdWx0RmVhdHVyZXNcbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cblxudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvbHlJbikge1xuICAgIHZhciBwb2x5O1xuICAgIHZhciByZXN1bHRzID0ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZUNvbGxlY3Rpb24nLFxuICAgICAgICBmZWF0dXJlczogW11cbiAgICB9O1xuICAgIGlmIChwb2x5SW4udHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIHBvbHkgPSBwb2x5SW4uZ2VvbWV0cnk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcG9seSA9IHBvbHlJbjtcbiAgICB9XG4gICAgcG9seS5jb29yZGluYXRlcy5mb3JFYWNoKGZ1bmN0aW9uIChyaW5nMSkge1xuICAgICAgICBwb2x5LmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKHJpbmcyKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJpbmcxLmxlbmd0aCAtIDE7IGkrKykge1xuICAgICAgICAgICAgICAgIGZvciAodmFyIGsgPSAwOyBrIDwgcmluZzIubGVuZ3RoIC0gMTsgaysrKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGRvbid0IGNoZWNrIGFkamFjZW50IHNpZGVzIG9mIGEgZ2l2ZW4gcmluZywgc2luY2Ugb2YgY291cnNlIHRoZXkgaW50ZXJzZWN0IGluIGEgdmVydGV4LlxuICAgICAgICAgICAgICAgICAgICBpZiAocmluZzEgPT09IHJpbmcyICYmIChNYXRoLmFicyhpIC0gaykgPT09IDEgfHwgTWF0aC5hYnMoaSAtIGspID09PSByaW5nMS5sZW5ndGggLSAyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB2YXIgaW50ZXJzZWN0aW9uID0gbGluZUludGVyc2VjdHMocmluZzFbaV1bMF0sIHJpbmcxW2ldWzFdLCByaW5nMVtpICsgMV1bMF0sIHJpbmcxW2kgKyAxXVsxXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHJpbmcyW2tdWzBdLCByaW5nMltrXVsxXSwgcmluZzJbayArIDFdWzBdLCByaW5nMltrICsgMV1bMV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW50ZXJzZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzLmZlYXR1cmVzLnB1c2gocG9pbnQoW2ludGVyc2VjdGlvblswXSwgaW50ZXJzZWN0aW9uWzFdXSkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbn07XG5cblxuLy8gbW9kaWZpZWQgZnJvbSBodHRwOi8vanNmaWRkbGUubmV0L2p1c3Rpbl9jX3JvdW5kcy9HZDJTMi9saWdodC9cbmZ1bmN0aW9uIGxpbmVJbnRlcnNlY3RzKGxpbmUxU3RhcnRYLCBsaW5lMVN0YXJ0WSwgbGluZTFFbmRYLCBsaW5lMUVuZFksIGxpbmUyU3RhcnRYLCBsaW5lMlN0YXJ0WSwgbGluZTJFbmRYLCBsaW5lMkVuZFkpIHtcbiAgICAvLyBpZiB0aGUgbGluZXMgaW50ZXJzZWN0LCB0aGUgcmVzdWx0IGNvbnRhaW5zIHRoZSB4IGFuZCB5IG9mIHRoZSBpbnRlcnNlY3Rpb24gKHRyZWF0aW5nIHRoZSBsaW5lcyBhcyBpbmZpbml0ZSkgYW5kIGJvb2xlYW5zIGZvciB3aGV0aGVyIGxpbmUgc2VnbWVudCAxIG9yIGxpbmUgc2VnbWVudCAyIGNvbnRhaW4gdGhlIHBvaW50XG4gICAgdmFyIGRlbm9taW5hdG9yLCBhLCBiLCBudW1lcmF0b3IxLCBudW1lcmF0b3IyLFxuICAgICAgICByZXN1bHQgPSB7XG4gICAgICAgICAgICB4OiBudWxsLFxuICAgICAgICAgICAgeTogbnVsbCxcbiAgICAgICAgICAgIG9uTGluZTE6IGZhbHNlLFxuICAgICAgICAgICAgb25MaW5lMjogZmFsc2VcbiAgICAgICAgfTtcbiAgICBkZW5vbWluYXRvciA9ICgobGluZTJFbmRZIC0gbGluZTJTdGFydFkpICogKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSkgLSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICBpZiAocmVzdWx0LnggIT09IG51bGwgJiYgcmVzdWx0LnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYSA9IGxpbmUxU3RhcnRZIC0gbGluZTJTdGFydFk7XG4gICAgYiA9IGxpbmUxU3RhcnRYIC0gbGluZTJTdGFydFg7XG4gICAgbnVtZXJhdG9yMSA9ICgobGluZTJFbmRYIC0gbGluZTJTdGFydFgpICogYSkgLSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIGIpO1xuICAgIG51bWVyYXRvcjIgPSAoKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSAqIGEpIC0gKChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkgKiBiKTtcbiAgICBhID0gbnVtZXJhdG9yMSAvIGRlbm9taW5hdG9yO1xuICAgIGIgPSBudW1lcmF0b3IyIC8gZGVub21pbmF0b3I7XG5cbiAgICAvLyBpZiB3ZSBjYXN0IHRoZXNlIGxpbmVzIGluZmluaXRlbHkgaW4gYm90aCBkaXJlY3Rpb25zLCB0aGV5IGludGVyc2VjdCBoZXJlOlxuICAgIHJlc3VsdC54ID0gbGluZTFTdGFydFggKyAoYSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpO1xuICAgIHJlc3VsdC55ID0gbGluZTFTdGFydFkgKyAoYSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuXG4gICAgLy8gaWYgbGluZTEgaXMgYSBzZWdtZW50IGFuZCBsaW5lMiBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGEgPj0gMCAmJiBhIDw9IDEpIHtcbiAgICAgICAgcmVzdWx0Lm9uTGluZTEgPSB0cnVlO1xuICAgIH1cbiAgICAvLyBpZiBsaW5lMiBpcyBhIHNlZ21lbnQgYW5kIGxpbmUxIGlzIGluZmluaXRlLCB0aGV5IGludGVyc2VjdCBpZjpcbiAgICBpZiAoYiA+PSAwICYmIGIgPD0gMSkge1xuICAgICAgICByZXN1bHQub25MaW5lMiA9IHRydWU7XG4gICAgfVxuICAgIC8vIGlmIGxpbmUxIGFuZCBsaW5lMiBhcmUgc2VnbWVudHMsIHRoZXkgaW50ZXJzZWN0IGlmIGJvdGggb2YgdGhlIGFib3ZlIGFyZSB0cnVlXG4gICAgaWYgKHJlc3VsdC5vbkxpbmUxICYmIHJlc3VsdC5vbkxpbmUyKSB7XG4gICAgICAgIHJldHVybiBbcmVzdWx0LngsIHJlc3VsdC55XTtcbiAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuIiwidmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xudmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgTGluZVN0cmluZ3xsaW5lfSBhbmQgbWVhc3VyZXMgaXRzIGxlbmd0aCBpbiB0aGUgc3BlY2lmaWVkIHVuaXRzLlxuICpcbiAqIEBuYW1lIGxpbmVEaXN0YW5jZVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGxpbmUgdG8gbWVhc3VyZVxuICogQHBhcmFtIHtTdHJpbmd9IFt1bml0cz1raWxvbWV0ZXJzXSBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm4ge051bWJlcn0gbGVuZ3RoIG9mIHRoZSBpbnB1dCBsaW5lXG4gKiBAZXhhbXBsZVxuICogdmFyIGxpbmUgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJMaW5lU3RyaW5nXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbXG4gKiAgICAgICBbLTc3LjAzMTY2OSwgMzguODc4NjA1XSxcbiAqICAgICAgIFstNzcuMDI5NjA5LCAzOC44ODE5NDZdLFxuICogICAgICAgWy03Ny4wMjAzMzksIDM4Ljg4NDA4NF0sXG4gKiAgICAgICBbLTc3LjAyNTY2MSwgMzguODg1ODIxXSxcbiAqICAgICAgIFstNzcuMDIxODg0LCAzOC44ODk1NjNdLFxuICogICAgICAgWy03Ny4wMTk4MjQsIDM4Ljg5MjM2OF1cbiAqICAgICBdXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGxlbmd0aCA9IHR1cmYubGluZURpc3RhbmNlKGxpbmUsICdtaWxlcycpO1xuICpcbiAqIC8vPWxpbmVcbiAqXG4gKiAvLz1sZW5ndGhcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBsaW5lRGlzdGFuY2UobGluZSwgdW5pdHMpIHtcbiAgICBpZiAobGluZS50eXBlID09PSAnRmVhdHVyZUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiBsaW5lLmZlYXR1cmVzLnJlZHVjZShmdW5jdGlvbiAobWVtbywgZmVhdHVyZSkge1xuICAgICAgICAgICAgcmV0dXJuIG1lbW8gKyBsaW5lRGlzdGFuY2UoZmVhdHVyZSwgdW5pdHMpO1xuICAgICAgICB9LCAwKTtcbiAgICB9XG5cbiAgICB2YXIgZ2VvbWV0cnkgPSBsaW5lLnR5cGUgPT09ICdGZWF0dXJlJyA/IGxpbmUuZ2VvbWV0cnkgOiBsaW5lO1xuICAgIHZhciBkLCBpO1xuXG4gICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICByZXR1cm4gbGVuZ3RoKGdlb21ldHJ5LmNvb3JkaW5hdGVzLCB1bml0cyk7XG4gICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpTGluZVN0cmluZycpIHtcbiAgICAgICAgZCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZCArPSBsZW5ndGgoZ2VvbWV0cnkuY29vcmRpbmF0ZXNbaV0sIHVuaXRzKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZDtcbiAgICB9IGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgZCA9IDA7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBnZW9tZXRyeS5jb29yZGluYXRlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPCBnZW9tZXRyeS5jb29yZGluYXRlc1tpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgIGQgKz0gbGVuZ3RoKGdlb21ldHJ5LmNvb3JkaW5hdGVzW2ldW2pdLCB1bml0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGQ7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZywgTXVsdGlMaW5lU3RyaW5nLCAnICtcbiAgICAgICAgICAgICdQb2x5Z29uLCBvciBNdWx0aVBvbHlnb24gRmVhdHVyZSBvciBHZW9tZXRyeSAob3IgYSBGZWF0dXJlQ29sbGVjdGlvbiAnICtcbiAgICAgICAgICAgICdjb250YWluaW5nIG9ubHkgdGhvc2UgdHlwZXMpJyk7XG4gICAgfVxuXG59O1xuXG5mdW5jdGlvbiBsZW5ndGgoY29vcmRzLCB1bml0cykge1xuICAgIHZhciB0cmF2ZWxsZWQgPSAwO1xuICAgIHZhciBwcmV2Q29vcmRzID0gcG9pbnQoY29vcmRzWzBdKTtcbiAgICB2YXIgY3VyQ29vcmRzID0gcG9pbnQoY29vcmRzWzBdKTtcbiAgICB2YXIgdGVtcDtcbiAgICBmb3IgKHZhciBpID0gMTsgaSA8IGNvb3Jkcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjdXJDb29yZHMuZ2VvbWV0cnkuY29vcmRpbmF0ZXMgPSBjb29yZHNbaV07XG4gICAgICAgIHRyYXZlbGxlZCArPSBkaXN0YW5jZShwcmV2Q29vcmRzLCBjdXJDb29yZHMsIHVuaXRzKTtcbiAgICAgICAgdGVtcCA9IHByZXZDb29yZHM7XG4gICAgICAgIHByZXZDb29yZHMgPSBjdXJDb29yZHM7XG4gICAgICAgIGN1ckNvb3JkcyA9IHRlbXA7XG4gICAgfVxuICAgIHJldHVybiB0cmF2ZWxsZWQ7XG59XG4iLCJ2YXIgbGluZXN0cmluZyA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmxpbmVTdHJpbmc7XG52YXIgcG9pbnRPbkxpbmUgPSByZXF1aXJlKCd0dXJmLXBvaW50LW9uLWxpbmUnKTtcblxuLyoqXG4gKiBUYWtlcyBhIHtAbGluayBMaW5lU3RyaW5nfGxpbmV9LCBhIHN0YXJ0IHtAbGluayBQb2ludH0sIGFuZCBhIHN0b3AgcG9pbnRcbiAqIGFuZCByZXR1cm5zIGEgc3Vic2VjdGlvbiBvZiB0aGUgbGluZSBpbi1iZXR3ZWVuIHRob3NlIHBvaW50cy5cbiAqIFRoZSBzdGFydCAmIHN0b3AgcG9pbnRzIGRvbid0IG5lZWQgdG8gZmFsbCBleGFjdGx5IG9uIHRoZSBsaW5lLlxuICpcbiAqIFRoaXMgY2FuIGJlIHVzZWZ1bCBmb3IgZXh0cmFjdGluZyBvbmx5IHRoZSBwYXJ0IG9mIGEgcm91dGUgYmV0d2VlbiB3YXlwb2ludHMuXG4gKlxuICogQG5hbWUgbGluZVNsaWNlXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBwb2ludDEgc3RhcnRpbmcgcG9pbnRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2ludD59IHBvaW50MiBzdG9wcGluZyBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fExpbmVTdHJpbmd9IGxpbmUgbGluZSB0byBzbGljZVxuICogQHJldHVybiB7RmVhdHVyZTxMaW5lU3RyaW5nPn0gc2xpY2VkIGxpbmVcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzcuMDMxNjY5LCAzOC44Nzg2MDVdLFxuICogICAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgICBbLTc3LjAyMDMzOSwgMzguODg0MDg0XSxcbiAqICAgICAgIFstNzcuMDI1NjYxLCAzOC44ODU4MjFdLFxuICogICAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgICBbLTc3LjAxOTgyNCwgMzguODkyMzY4XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqIHZhciBzdGFydCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc3LjAyOTYwOSwgMzguODgxOTQ2XVxuICogICB9XG4gKiB9O1xuICogdmFyIHN0b3AgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgIFwiY29vcmRpbmF0ZXNcIjogWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M11cbiAqICAgfVxuICogfTtcbiAqXG4gKiB2YXIgc2xpY2VkID0gdHVyZi5saW5lU2xpY2Uoc3RhcnQsIHN0b3AsIGxpbmUpO1xuICpcbiAqIC8vPWxpbmVcbiAqXG4gKiAvLz1zbGljZWRcbiAqL1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGxpbmVTbGljZShzdGFydFB0LCBzdG9wUHQsIGxpbmUpIHtcbiAgICB2YXIgY29vcmRzO1xuICAgIGlmIChsaW5lLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICBjb29yZHMgPSBsaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzO1xuICAgIH0gZWxzZSBpZiAobGluZS50eXBlID09PSAnTGluZVN0cmluZycpIHtcbiAgICAgICAgY29vcmRzID0gbGluZS5jb29yZGluYXRlcztcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2lucHV0IG11c3QgYmUgYSBMaW5lU3RyaW5nIEZlYXR1cmUgb3IgR2VvbWV0cnknKTtcbiAgICB9XG5cbiAgICB2YXIgc3RhcnRWZXJ0ZXggPSBwb2ludE9uTGluZShsaW5lLCBzdGFydFB0KTtcbiAgICB2YXIgc3RvcFZlcnRleCA9IHBvaW50T25MaW5lKGxpbmUsIHN0b3BQdCk7XG4gICAgdmFyIGVuZHM7XG4gICAgaWYgKHN0YXJ0VmVydGV4LnByb3BlcnRpZXMuaW5kZXggPD0gc3RvcFZlcnRleC5wcm9wZXJ0aWVzLmluZGV4KSB7XG4gICAgICAgIGVuZHMgPSBbc3RhcnRWZXJ0ZXgsIHN0b3BWZXJ0ZXhdO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZHMgPSBbc3RvcFZlcnRleCwgc3RhcnRWZXJ0ZXhdO1xuICAgIH1cbiAgICB2YXIgY2xpcExpbmUgPSBsaW5lc3RyaW5nKFtlbmRzWzBdLmdlb21ldHJ5LmNvb3JkaW5hdGVzXSwge30pO1xuICAgIGZvciAodmFyIGkgPSBlbmRzWzBdLnByb3BlcnRpZXMuaW5kZXggKyAxOyBpIDwgZW5kc1sxXS5wcm9wZXJ0aWVzLmluZGV4ICsgMTsgaSsrKSB7XG4gICAgICAgIGNsaXBMaW5lLmdlb21ldHJ5LmNvb3JkaW5hdGVzLnB1c2goY29vcmRzW2ldKTtcbiAgICB9XG4gICAgY2xpcExpbmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMucHVzaChlbmRzWzFdLmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICByZXR1cm4gY2xpcExpbmU7XG59O1xuIiwiLyoqXG4gKiBJdGVyYXRlIG92ZXIgY29vcmRpbmF0ZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHZhbHVlKVxuICogQHBhcmFtIHtib29sZWFuPX0gZXhjbHVkZVdyYXBDb29yZCB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0geyB0eXBlOiAnUG9pbnQnLCBjb29yZGluYXRlczogWzAsIDBdIH07XG4gKiBjb29yZEVhY2gocG9pbnQsIGZ1bmN0aW9uKGNvb3Jkcykge1xuICogICAvLyBjb29yZHMgaXMgZXF1YWwgdG8gWzAsIDBdXG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gY29vcmRFYWNoKGxheWVyLCBjYWxsYmFjaywgZXhjbHVkZVdyYXBDb29yZCkge1xuICAgIHZhciBpLCBqLCBrLCBnLCBsLCBnZW9tZXRyeSwgc3RvcEcsIGNvb3JkcyxcbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24sXG4gICAgICAgIHdyYXBTaHJpbmsgPSAwLFxuICAgICAgICBpc0dlb21ldHJ5Q29sbGVjdGlvbixcbiAgICAgICAgaXNGZWF0dXJlQ29sbGVjdGlvbiA9IGxheWVyLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicsXG4gICAgICAgIGlzRmVhdHVyZSA9IGxheWVyLnR5cGUgPT09ICdGZWF0dXJlJyxcbiAgICAgICAgc3RvcCA9IGlzRmVhdHVyZUNvbGxlY3Rpb24gPyBsYXllci5mZWF0dXJlcy5sZW5ndGggOiAxO1xuXG4gIC8vIFRoaXMgbG9naWMgbWF5IGxvb2sgYSBsaXR0bGUgd2VpcmQuIFRoZSByZWFzb24gd2h5IGl0IGlzIHRoYXQgd2F5XG4gIC8vIGlzIGJlY2F1c2UgaXQncyB0cnlpbmcgdG8gYmUgZmFzdC4gR2VvSlNPTiBzdXBwb3J0cyBtdWx0aXBsZSBraW5kc1xuICAvLyBvZiBvYmplY3RzIGF0IGl0cyByb290OiBGZWF0dXJlQ29sbGVjdGlvbiwgRmVhdHVyZXMsIEdlb21ldHJpZXMuXG4gIC8vIFRoaXMgZnVuY3Rpb24gaGFzIHRoZSByZXNwb25zaWJpbGl0eSBvZiBoYW5kbGluZyBhbGwgb2YgdGhlbSwgYW5kIHRoYXRcbiAgLy8gbWVhbnMgdGhhdCBzb21lIG9mIHRoZSBgZm9yYCBsb29wcyB5b3Ugc2VlIGJlbG93IGFjdHVhbGx5IGp1c3QgZG9uJ3QgYXBwbHlcbiAgLy8gdG8gY2VydGFpbiBpbnB1dHMuIEZvciBpbnN0YW5jZSwgaWYgeW91IGdpdmUgdGhpcyBqdXN0IGFcbiAgLy8gUG9pbnQgZ2VvbWV0cnksIHRoZW4gYm90aCBsb29wcyBhcmUgc2hvcnQtY2lyY3VpdGVkIGFuZCBhbGwgd2UgZG9cbiAgLy8gaXMgZ3JhZHVhbGx5IHJlbmFtZSB0aGUgaW5wdXQgdW50aWwgaXQncyBjYWxsZWQgJ2dlb21ldHJ5Jy5cbiAgLy9cbiAgLy8gVGhpcyBhbHNvIGFpbXMgdG8gYWxsb2NhdGUgYXMgZmV3IHJlc291cmNlcyBhcyBwb3NzaWJsZToganVzdCBhXG4gIC8vIGZldyBudW1iZXJzIGFuZCBib29sZWFucywgcmF0aGVyIHRoYW4gYW55IHRlbXBvcmFyeSBhcnJheXMgYXMgd291bGRcbiAgLy8gYmUgcmVxdWlyZWQgd2l0aCB0aGUgbm9ybWFsaXphdGlvbiBhcHByb2FjaC5cbiAgICBmb3IgKGkgPSAwOyBpIDwgc3RvcDsgaSsrKSB7XG5cbiAgICAgICAgZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb24gPSAoaXNGZWF0dXJlQ29sbGVjdGlvbiA/IGxheWVyLmZlYXR1cmVzW2ldLmdlb21ldHJ5IDpcbiAgICAgICAgKGlzRmVhdHVyZSA/IGxheWVyLmdlb21ldHJ5IDogbGF5ZXIpKTtcbiAgICAgICAgaXNHZW9tZXRyeUNvbGxlY3Rpb24gPSBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi50eXBlID09PSAnR2VvbWV0cnlDb2xsZWN0aW9uJztcbiAgICAgICAgc3RvcEcgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/IGdlb21ldHJ5TWF5YmVDb2xsZWN0aW9uLmdlb21ldHJpZXMubGVuZ3RoIDogMTtcblxuICAgICAgICBmb3IgKGcgPSAwOyBnIDwgc3RvcEc7IGcrKykge1xuICAgICAgICAgICAgZ2VvbWV0cnkgPSBpc0dlb21ldHJ5Q29sbGVjdGlvbiA/XG4gICAgICAgICAgICBnZW9tZXRyeU1heWJlQ29sbGVjdGlvbi5nZW9tZXRyaWVzW2ddIDogZ2VvbWV0cnlNYXliZUNvbGxlY3Rpb247XG4gICAgICAgICAgICBjb29yZHMgPSBnZW9tZXRyeS5jb29yZGluYXRlcztcblxuICAgICAgICAgICAgd3JhcFNocmluayA9IChleGNsdWRlV3JhcENvb3JkICYmXG4gICAgICAgICAgICAgICAgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJyB8fCBnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykpID9cbiAgICAgICAgICAgICAgICAxIDogMDtcblxuICAgICAgICAgICAgaWYgKGdlb21ldHJ5LnR5cGUgPT09ICdQb2ludCcpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHMpO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTGluZVN0cmluZycgfHwgZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9pbnQnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKykgY2FsbGJhY2soY29vcmRzW2pdKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgZm9yIChqID0gMDsgaiA8IGNvb3Jkcy5sZW5ndGg7IGorKylcbiAgICAgICAgICAgICAgICAgICAgZm9yIChrID0gMDsgayA8IGNvb3Jkc1tqXS5sZW5ndGggLSB3cmFwU2hyaW5rOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHNbal1ba10pO1xuICAgICAgICAgICAgfSBlbHNlIGlmIChnZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICAgICAgICAgIGZvciAoaiA9IDA7IGogPCBjb29yZHMubGVuZ3RoOyBqKyspXG4gICAgICAgICAgICAgICAgICAgIGZvciAoayA9IDA7IGsgPCBjb29yZHNbal0ubGVuZ3RoOyBrKyspXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGwgPSAwOyBsIDwgY29vcmRzW2pdW2tdLmxlbmd0aCAtIHdyYXBTaHJpbms7IGwrKylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhjb29yZHNbal1ba11bbF0pO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gR2VvbWV0cnkgVHlwZScpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMuY29vcmRFYWNoID0gY29vcmRFYWNoO1xuXG4vKipcbiAqIFJlZHVjZSBjb29yZGluYXRlcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZSxcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBjb29yZGluYXRlcyBpcyB1bm5lY2Vzc2FyeS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gbGF5ZXIgYW55IEdlb0pTT04gb2JqZWN0XG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBhIG1ldGhvZCB0aGF0IHRha2VzIChtZW1vLCB2YWx1ZSkgYW5kIHJldHVybnNcbiAqIGEgbmV3IG1lbW9cbiAqIEBwYXJhbSB7Kn0gbWVtbyB0aGUgc3RhcnRpbmcgdmFsdWUgb2YgbWVtbzogY2FuIGJlIGFueSB0eXBlLlxuICogQHBhcmFtIHtib29sZWFuPX0gZXhjbHVkZVdyYXBDb29yZCB3aGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXG4gKiB0aGUgZmluYWwgY29vcmRpbmF0ZSBvZiBMaW5lYXJSaW5ncyB0aGF0IHdyYXBzIHRoZSByaW5nIGluIGl0cyBpdGVyYXRpb24uXG4gKiBAcmV0dXJuIHsqfSBjb21iaW5lZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBjb29yZFJlZHVjZShsYXllciwgY2FsbGJhY2ssIG1lbW8sIGV4Y2x1ZGVXcmFwQ29vcmQpIHtcbiAgICBjb29yZEVhY2gobGF5ZXIsIGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgY29vcmQpO1xuICAgIH0sIGV4Y2x1ZGVXcmFwQ29vcmQpO1xuICAgIHJldHVybiBtZW1vO1xufVxubW9kdWxlLmV4cG9ydHMuY29vcmRSZWR1Y2UgPSBjb29yZFJlZHVjZTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgcHJvcGVydHkgb2JqZWN0cyBpbiBhbnkgR2VvSlNPTiBvYmplY3QsIHNpbWlsYXIgdG9cbiAqIEFycmF5LmZvckVhY2guXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgYSBtZXRob2QgdGhhdCB0YWtlcyAodmFsdWUpXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50ID0geyB0eXBlOiAnRmVhdHVyZScsIGdlb21ldHJ5OiBudWxsLCBwcm9wZXJ0aWVzOiB7IGZvbzogMSB9IH07XG4gKiBwcm9wRWFjaChwb2ludCwgZnVuY3Rpb24ocHJvcHMpIHtcbiAqICAgLy8gcHJvcHMgaXMgZXF1YWwgdG8geyBmb286IDF9XG4gKiB9KTtcbiAqL1xuZnVuY3Rpb24gcHJvcEVhY2gobGF5ZXIsIGNhbGxiYWNrKSB7XG4gICAgdmFyIGk7XG4gICAgc3dpdGNoIChsYXllci50eXBlKSB7XG4gICAgY2FzZSAnRmVhdHVyZUNvbGxlY3Rpb24nOlxuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbGF5ZXIuZmVhdHVyZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGxheWVyLmZlYXR1cmVzW2ldLnByb3BlcnRpZXMpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ0ZlYXR1cmUnOlxuICAgICAgICBjYWxsYmFjayhsYXllci5wcm9wZXJ0aWVzKTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMucHJvcEVhY2ggPSBwcm9wRWFjaDtcblxuLyoqXG4gKiBSZWR1Y2UgcHJvcGVydGllcyBpbiBhbnkgR2VvSlNPTiBvYmplY3QgaW50byBhIHNpbmdsZSB2YWx1ZSxcbiAqIHNpbWlsYXIgdG8gaG93IEFycmF5LnJlZHVjZSB3b3Jrcy4gSG93ZXZlciwgaW4gdGhpcyBjYXNlIHdlIGxhemlseSBydW5cbiAqIHRoZSByZWR1Y3Rpb24sIHNvIGFuIGFycmF5IG9mIGFsbCBwcm9wZXJ0aWVzIGlzIHVubmVjZXNzYXJ5LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKG1lbW8sIGNvb3JkKSBhbmQgcmV0dXJuc1xuICogYSBuZXcgbWVtb1xuICogQHBhcmFtIHsqfSBtZW1vIHRoZSBzdGFydGluZyB2YWx1ZSBvZiBtZW1vOiBjYW4gYmUgYW55IHR5cGUuXG4gKiBAcmV0dXJuIHsqfSBjb21iaW5lZCB2YWx1ZVxuICovXG5mdW5jdGlvbiBwcm9wUmVkdWNlKGxheWVyLCBjYWxsYmFjaywgbWVtbykge1xuICAgIHByb3BFYWNoKGxheWVyLCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICBtZW1vID0gY2FsbGJhY2sobWVtbywgcHJvcCk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1lbW87XG59XG5tb2R1bGUuZXhwb3J0cy5wcm9wUmVkdWNlID0gcHJvcFJlZHVjZTtcblxuLyoqXG4gKiBJdGVyYXRlIG92ZXIgZmVhdHVyZXMgaW4gYW55IEdlb0pTT04gb2JqZWN0LCBzaW1pbGFyIHRvXG4gKiBBcnJheS5mb3JFYWNoLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciBhbnkgR2VvSlNPTiBvYmplY3RcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIGEgbWV0aG9kIHRoYXQgdGFrZXMgKHZhbHVlKVxuICogQGV4YW1wbGVcbiAqIHZhciBmZWF0dXJlID0geyB0eXBlOiAnRmVhdHVyZScsIGdlb21ldHJ5OiBudWxsLCBwcm9wZXJ0aWVzOiB7fSB9O1xuICogZmVhdHVyZUVhY2goZmVhdHVyZSwgZnVuY3Rpb24oZmVhdHVyZSkge1xuICogICAvLyBmZWF0dXJlID09IGZlYXR1cmVcbiAqIH0pO1xuICovXG5mdW5jdGlvbiBmZWF0dXJlRWFjaChsYXllciwgY2FsbGJhY2spIHtcbiAgICBpZiAobGF5ZXIudHlwZSA9PT0gJ0ZlYXR1cmUnKSB7XG4gICAgICAgIGNhbGxiYWNrKGxheWVyKTtcbiAgICB9IGVsc2UgaWYgKGxheWVyLnR5cGUgPT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsYXllci5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY2FsbGJhY2sobGF5ZXIuZmVhdHVyZXNbaV0pO1xuICAgICAgICB9XG4gICAgfVxufVxubW9kdWxlLmV4cG9ydHMuZmVhdHVyZUVhY2ggPSBmZWF0dXJlRWFjaDtcblxuLyoqXG4gKiBHZXQgYWxsIGNvb3JkaW5hdGVzIGZyb20gYW55IEdlb0pTT04gb2JqZWN0LCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY29vcmRpbmF0ZVxuICogYXJyYXlzLlxuICogQHBhcmFtIHtPYmplY3R9IGxheWVyIGFueSBHZW9KU09OIG9iamVjdFxuICogQHJldHVybiB7QXJyYXk8QXJyYXk8TnVtYmVyPj59IGNvb3JkaW5hdGUgcG9zaXRpb24gYXJyYXlcbiAqL1xuZnVuY3Rpb24gY29vcmRBbGwobGF5ZXIpIHtcbiAgICB2YXIgY29vcmRzID0gW107XG4gICAgY29vcmRFYWNoKGxheWVyLCBmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgY29vcmRzLnB1c2goY29vcmQpO1xuICAgIH0pO1xuICAgIHJldHVybiBjb29yZHM7XG59XG5tb2R1bGUuZXhwb3J0cy5jb29yZEFsbCA9IGNvb3JkQWxsO1xuIiwidmFyIGJlYXJpbmcgPSByZXF1aXJlKCd0dXJmLWJlYXJpbmcnKTtcbnZhciBkZXN0aW5hdGlvbiA9IHJlcXVpcmUoJ3R1cmYtZGVzdGluYXRpb24nKTtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcblxuLyoqXG4gKiBUYWtlcyB0d28ge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIHJldHVybnMgYSBwb2ludCBtaWR3YXkgYmV0d2VlbiB0aGVtLlxuICogVGhlIG1pZHBvaW50IGlzIGNhbGN1bGF0ZWQgZ2VvZGVzaWNhbGx5LCBtZWFuaW5nIHRoZSBjdXJ2YXR1cmUgb2YgdGhlIGVhcnRoIGlzIHRha2VuIGludG8gYWNjb3VudC5cbiAqXG4gKiBAbmFtZSBtaWRwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gZnJvbSBmaXJzdCBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gdG8gc2Vjb25kIHBvaW50XG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gYSBwb2ludCBtaWR3YXkgYmV0d2VlbiBgcHQxYCBhbmQgYHB0MmBcbiAqIEBleGFtcGxlXG4gKiB2YXIgcHQxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFsxNDQuODM0ODIzLCAtMzcuNzcxMjU3XVxuICogICB9XG4gKiB9O1xuICogdmFyIHB0MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbMTQ1LjE0MjQ0LCAtMzcuODMwOTM3XVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBtaWRwb2ludGVkID0gdHVyZi5taWRwb2ludChwdDEsIHB0Mik7XG4gKiBtaWRwb2ludGVkLnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyNmMDAnO1xuICpcbiAqXG4gKiB2YXIgcmVzdWx0ID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwdDEsIHB0MiwgbWlkcG9pbnRlZF1cbiAqIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGZyb20sIHRvKSB7XG4gICAgdmFyIGRpc3QgPSBkaXN0YW5jZShmcm9tLCB0bywgJ21pbGVzJyk7XG4gICAgdmFyIGhlYWRpbmcgPSBiZWFyaW5nKGZyb20sIHRvKTtcbiAgICB2YXIgbWlkcG9pbnQgPSBkZXN0aW5hdGlvbihmcm9tLCBkaXN0IC8gMiwgaGVhZGluZywgJ21pbGVzJyk7XG5cbiAgICByZXR1cm4gbWlkcG9pbnQ7XG59O1xuIiwidmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgcmVmZXJlbmNlIHtAbGluayBQb2ludHxwb2ludH0gYW5kIGEgRmVhdHVyZUNvbGxlY3Rpb24gb2YgRmVhdHVyZXNcbiAqIHdpdGggUG9pbnQgZ2VvbWV0cmllcyBhbmQgcmV0dXJucyB0aGVcbiAqIHBvaW50IGZyb20gdGhlIEZlYXR1cmVDb2xsZWN0aW9uIGNsb3Nlc3QgdG8gdGhlIHJlZmVyZW5jZS4gVGhpcyBjYWxjdWxhdGlvblxuICogaXMgZ2VvZGVzaWMuXG4gKlxuICogQG5hbWUgbmVhcmVzdFxuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gdGFyZ2V0UG9pbnQgdGhlIHJlZmVyZW5jZSBwb2ludFxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBhZ2FpbnN0IGlucHV0IHBvaW50IHNldFxuICogQHJldHVybiB7RmVhdHVyZTxQb2ludD59IHRoZSBjbG9zZXN0IHBvaW50IGluIHRoZSBzZXQgdG8gdGhlIHJlZmVyZW5jZSBwb2ludFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwibWFya2VyLWNvbG9yXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbMjguOTY1Nzk3LCA0MS4wMTAwODZdXG4gKiAgIH1cbiAqIH07XG4gKiB2YXIgYWdhaW5zdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWzI4Ljk3Mzg2NSwgNDEuMDExMTIyXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFsyOC45NDg0NTksIDQxLjAyNDIwNF1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbMjguOTM4Njc0LCA0MS4wMTMzMjRdXG4gKiAgICAgICB9XG4gKiAgICAgfVxuICogICBdXG4gKiB9O1xuICpcbiAqIHZhciBuZWFyZXN0ID0gdHVyZi5uZWFyZXN0KHBvaW50LCBhZ2FpbnN0KTtcbiAqIG5lYXJlc3QucHJvcGVydGllc1snbWFya2VyLWNvbG9yJ10gPSAnI2YwMCc7XG4gKlxuICogdmFyIHJlc3VsdEZlYXR1cmVzID0gYWdhaW5zdC5mZWF0dXJlcy5jb25jYXQocG9pbnQpO1xuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiByZXN1bHRGZWF0dXJlc1xuICogfTtcbiAqXG4gKiAvLz1yZXN1bHRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodGFyZ2V0UG9pbnQsIHBvaW50cykge1xuICAgIHZhciBuZWFyZXN0UG9pbnQsIG1pbkRpc3QgPSBJbmZpbml0eTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvaW50cy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgZGlzdGFuY2VUb1BvaW50ID0gZGlzdGFuY2UodGFyZ2V0UG9pbnQsIHBvaW50cy5mZWF0dXJlc1tpXSwgJ21pbGVzJyk7XG4gICAgICAgIGlmIChkaXN0YW5jZVRvUG9pbnQgPCBtaW5EaXN0KSB7XG4gICAgICAgICAgICBuZWFyZXN0UG9pbnQgPSBwb2ludHMuZmVhdHVyZXNbaV07XG4gICAgICAgICAgICBtaW5EaXN0ID0gZGlzdGFuY2VUb1BvaW50O1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBuZWFyZXN0UG9pbnQ7XG59O1xuIiwiLyoqXG4gKiBUYWtlcyBhIHRyaWFuZ3VsYXIgcGxhbmUgYXMgYSB7QGxpbmsgUG9seWdvbn1cbiAqIGFuZCBhIHtAbGluayBQb2ludH0gd2l0aGluIHRoYXQgdHJpYW5nbGUgYW5kIHJldHVybnMgdGhlIHotdmFsdWVcbiAqIGF0IHRoYXQgcG9pbnQuIFRoZSBQb2x5Z29uIG5lZWRzIHRvIGhhdmUgcHJvcGVydGllcyBgYWAsIGBiYCwgYW5kIGBjYFxuICogdGhhdCBkZWZpbmUgdGhlIHZhbHVlcyBhdCBpdHMgdGhyZWUgY29ybmVycy5cbiAqXG4gKiBAbmFtZSBwbGFuZXBvaW50XG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9pbnQ+fSBwb2ludCB0aGUgUG9pbnQgZm9yIHdoaWNoIGEgei12YWx1ZSB3aWxsIGJlIGNhbGN1bGF0ZWRcbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gdHJpYW5nbGUgYSBQb2x5Z29uIGZlYXR1cmUgd2l0aCB0aHJlZSB2ZXJ0aWNlc1xuICogQHJldHVybiB7TnVtYmVyfSB0aGUgei12YWx1ZSBmb3IgYGludGVycG9sYXRlZFBvaW50YFxuICogQGV4YW1wbGVcbiAqIHZhciBwb2ludCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc1LjMyMjEsIDM5LjUyOV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2ludCA9IHR1cmYucG9pbnQoWy03NS4zMjIxLCAzOS41MjldKTtcbiAqIC8vIHRyaWFuZ2xlIGlzIGEgcG9seWdvbiB3aXRoIFwiYVwiLCBcImJcIixcbiAqIC8vIGFuZCBcImNcIiB2YWx1ZXMgcmVwcmVzZW50aW5nXG4gKiAvLyB0aGUgdmFsdWVzIG9mIHRoZSBjb29yZGluYXRlcyBpbiBvcmRlci5cbiAqIHZhciB0cmlhbmdsZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiYVwiOiAxMSxcbiAqICAgICBcImJcIjogMTIyLFxuICogICAgIFwiY1wiOiA0NFxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy03NS4xMjIxLCAzOS41N10sXG4gKiAgICAgICBbLTc1LjU4LCAzOS4xOF0sXG4gKiAgICAgICBbLTc1Ljk3LCAzOS44Nl0sXG4gKiAgICAgICBbLTc1LjEyMjEsIDM5LjU3XVxuICogICAgIF1dXG4gKiAgIH1cbiAqIH07XG4gKlxuICogdmFyIGZlYXR1cmVzID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFt0cmlhbmdsZSwgcG9pbnRdXG4gKiB9O1xuICpcbiAqIHZhciB6VmFsdWUgPSB0dXJmLnBsYW5lcG9pbnQocG9pbnQsIHRyaWFuZ2xlKTtcbiAqXG4gKiAvLz1mZWF0dXJlc1xuICpcbiAqIC8vPXpWYWx1ZVxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludCwgdHJpYW5nbGUpIHtcbiAgICB2YXIgeCA9IHBvaW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICB5ID0gcG9pbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV0sXG4gICAgICAgIHgxID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF1bMF0sXG4gICAgICAgIHkxID0gdHJpYW5nbGUuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF1bMF1bMV0sXG4gICAgICAgIHoxID0gdHJpYW5nbGUucHJvcGVydGllcy5hLFxuICAgICAgICB4MiA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzFdWzBdLFxuICAgICAgICB5MiA9IHRyaWFuZ2xlLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdWzFdWzFdLFxuICAgICAgICB6MiA9IHRyaWFuZ2xlLnByb3BlcnRpZXMuYixcbiAgICAgICAgeDMgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsyXVswXSxcbiAgICAgICAgeTMgPSB0cmlhbmdsZS5nZW9tZXRyeS5jb29yZGluYXRlc1swXVsyXVsxXSxcbiAgICAgICAgejMgPSB0cmlhbmdsZS5wcm9wZXJ0aWVzLmM7XG5cbiAgICB2YXIgeiA9ICh6MyAqICh4IC0geDEpICogKHkgLSB5MikgKyB6MSAqICh4IC0geDIpICogKHkgLSB5MykgKyB6MiAqICh4IC0geDMpICogKHkgLSB5MSkgLVxuICAgICAgejIgKiAoeCAtIHgxKSAqICh5IC0geTMpIC0gejMgKiAoeCAtIHgyKSAqICh5IC0geTEpIC0gejEgKiAoeCAtIHgzKSAqICh5IC0geTIpKSAvXG4gICAgICAoKHggLSB4MSkgKiAoeSAtIHkyKSArICh4IC0geDIpICogKHkgLSB5MykgKyAoeCAtIHgzKSAqICh5IC0geTEpIC1cbiAgICAgICAoeCAtIHgxKSAqICh5IC0geTMpIC0gKHggLSB4MikgKiAoeSAtIHkxKSAtICh4IC0geDMpICogKHkgLSB5MikpO1xuXG4gICAgcmV0dXJuIHo7XG59O1xuIiwidmFyIHBvaW50ID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9pbnQ7XG52YXIgZmVhdHVyZWNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBkaXN0YW5jZSA9IHJlcXVpcmUoJ3R1cmYtZGlzdGFuY2UnKTtcbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGEgY2VsbCBkZXB0aCBhbmQgcmV0dXJucyBhIHNldCBvZiB7QGxpbmsgUG9pbnR8cG9pbnRzfSBpbiBhIGdyaWQuXG4gKlxuICogQG5hbWUgcG9pbnRHcmlkXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIHRoZSBkaXN0YW5jZSBhY3Jvc3MgZWFjaCBjZWxsXG4gKiBAcGFyYW0ge3N0cmluZ30gW3VuaXRzPWtpbG9tZXRlcnNdIHVzZWQgaW4gY2FsY3VsYXRpbmcgY2VsbFdpZHRoLCBjYW4gYmUgZGVncmVlcywgcmFkaWFucywgbWlsZXMsIG9yIGtpbG9tZXRlcnNcbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9uPFBvaW50Pn0gZ3JpZCBvZiBwb2ludHNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZXh0ZW50ID0gWy03MC44MjMzNjQsIC0zMy41NTM5ODQsIC03MC40NzMxNzUsIC0zMy4zMDI5ODZdO1xuICogdmFyIGNlbGxXaWR0aCA9IDM7XG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciBncmlkID0gdHVyZi5wb2ludEdyaWQoZXh0ZW50LCBjZWxsV2lkdGgsIHVuaXRzKTtcbiAqXG4gKiAvLz1ncmlkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gcG9pbnRHcmlkKGJib3gsIGNlbGxTaXplLCB1bml0cykge1xuICAgIHZhciBmYyA9IGZlYXR1cmVjb2xsZWN0aW9uKFtdKTtcbiAgICB2YXIgeEZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMl0sIGJib3hbMV1dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbFdpZHRoID0geEZyYWN0aW9uICogKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMF0sIGJib3hbM11dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IHlGcmFjdGlvbiAqIChiYm94WzNdIC0gYmJveFsxXSk7XG5cbiAgICB2YXIgY3VycmVudFggPSBiYm94WzBdO1xuICAgIHdoaWxlIChjdXJyZW50WCA8PSBiYm94WzJdKSB7XG4gICAgICAgIHZhciBjdXJyZW50WSA9IGJib3hbMV07XG4gICAgICAgIHdoaWxlIChjdXJyZW50WSA8PSBiYm94WzNdKSB7XG4gICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvaW50KFtjdXJyZW50WCwgY3VycmVudFldKSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRZICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFggKz0gY2VsbFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBmYztcbn07XG4iLCJ2YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG52YXIgcG9pbnQgPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2ludDtcbnZhciBiZWFyaW5nID0gcmVxdWlyZSgndHVyZi1iZWFyaW5nJyk7XG52YXIgZGVzdGluYXRpb24gPSByZXF1aXJlKCd0dXJmLWRlc3RpbmF0aW9uJyk7XG5cbi8qKlxuICogVGFrZXMgYSB7QGxpbmsgUG9pbnR9IGFuZCBhIHtAbGluayBMaW5lU3RyaW5nfSBhbmQgY2FsY3VsYXRlcyB0aGUgY2xvc2VzdCBQb2ludCBvbiB0aGUgTGluZVN0cmluZy5cbiAqXG4gKiBAbmFtZSBwb2ludE9uTGluZVxuICogQHBhcmFtIHtGZWF0dXJlPExpbmVTdHJpbmc+fSBsaW5lIGxpbmUgdG8gc25hcCB0b1xuICogQHBhcmFtIHtGZWF0dXJlPFBvaW50Pn0gcG9pbnQgcG9pbnQgdG8gc25hcCBmcm9tXG4gKiBAcmV0dXJuIHtGZWF0dXJlPFBvaW50Pn0gY2xvc2VzdCBwb2ludCBvbiB0aGUgYGxpbmVgIHRvIGBwb2ludGBcbiAqIEBleGFtcGxlXG4gKiB2YXIgbGluZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIkxpbmVTdHJpbmdcIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtcbiAqICAgICAgIFstNzcuMDMxNjY5LCAzOC44Nzg2MDVdLFxuICogICAgICAgWy03Ny4wMjk2MDksIDM4Ljg4MTk0Nl0sXG4gKiAgICAgICBbLTc3LjAyMDMzOSwgMzguODg0MDg0XSxcbiAqICAgICAgIFstNzcuMDI1NjYxLCAzOC44ODU4MjFdLFxuICogICAgICAgWy03Ny4wMjE4ODQsIDM4Ljg4OTU2M10sXG4gKiAgICAgICBbLTc3LjAxOTgyNCwgMzguODkyMzY4XVxuICogICAgIF1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbLTc3LjAzNzA3NiwgMzguODg0MDE3XVxuICogICB9XG4gKiB9O1xuICpcbiAqIHZhciBzbmFwcGVkID0gdHVyZi5wb2ludE9uTGluZShsaW5lLCBwdCk7XG4gKiBzbmFwcGVkLnByb3BlcnRpZXNbJ21hcmtlci1jb2xvciddID0gJyMwMGYnXG4gKlxuICogdmFyIHJlc3VsdCA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbbGluZSwgcHQsIHNuYXBwZWRdXG4gKiB9O1xuICpcbiAqIC8vPXJlc3VsdFxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGxpbmUsIHB0KSB7XG4gICAgdmFyIGNvb3JkcztcbiAgICBpZiAobGluZS50eXBlID09PSAnRmVhdHVyZScpIHtcbiAgICAgICAgY29vcmRzID0gbGluZS5nZW9tZXRyeS5jb29yZGluYXRlcztcbiAgICB9IGVsc2UgaWYgKGxpbmUudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIGNvb3JkcyA9IGxpbmUuY29vcmRpbmF0ZXM7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnB1dCBtdXN0IGJlIGEgTGluZVN0cmluZyBGZWF0dXJlIG9yIEdlb21ldHJ5Jyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHBvaW50T25MaW5lKHB0LCBjb29yZHMpO1xufTtcblxuZnVuY3Rpb24gcG9pbnRPbkxpbmUocHQsIGNvb3Jkcykge1xuICAgIHZhciB1bml0cyA9ICdtaWxlcyc7XG4gICAgdmFyIGNsb3Nlc3RQdCA9IHBvaW50KFtJbmZpbml0eSwgSW5maW5pdHldLCB7XG4gICAgICAgIGRpc3Q6IEluZmluaXR5XG4gICAgfSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb29yZHMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgICAgIHZhciBzdGFydCA9IHBvaW50KGNvb3Jkc1tpXSk7XG4gICAgICAgIHZhciBzdG9wID0gcG9pbnQoY29vcmRzW2kgKyAxXSk7XG4gICAgICAgIC8vc3RhcnRcbiAgICAgICAgc3RhcnQucHJvcGVydGllcy5kaXN0ID0gZGlzdGFuY2UocHQsIHN0YXJ0LCB1bml0cyk7XG4gICAgICAgIC8vc3RvcFxuICAgICAgICBzdG9wLnByb3BlcnRpZXMuZGlzdCA9IGRpc3RhbmNlKHB0LCBzdG9wLCB1bml0cyk7XG4gICAgICAgIC8vcGVycGVuZGljdWxhclxuICAgICAgICB2YXIgaGVpZ2h0RGlzdGFuY2UgPSBNYXRoLm1heChzdGFydC5wcm9wZXJ0aWVzLmRpc3QsIHN0b3AucHJvcGVydGllcy5kaXN0KTtcbiAgICAgICAgdmFyIGRpcmVjdGlvbiA9IGJlYXJpbmcoc3RhcnQsIHN0b3ApO1xuICAgICAgICB2YXIgcGVycGVuZGljdWxhclB0MSA9IGRlc3RpbmF0aW9uKHB0LCBoZWlnaHREaXN0YW5jZSwgZGlyZWN0aW9uICsgOTAsIHVuaXRzKTtcbiAgICAgICAgdmFyIHBlcnBlbmRpY3VsYXJQdDIgPSBkZXN0aW5hdGlvbihwdCwgaGVpZ2h0RGlzdGFuY2UsIGRpcmVjdGlvbiAtIDkwLCB1bml0cyk7XG4gICAgICAgIHZhciBpbnRlcnNlY3QgPSBsaW5lSW50ZXJzZWN0cyhcbiAgICAgICAgcGVycGVuZGljdWxhclB0MS5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgcGVycGVuZGljdWxhclB0MS5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgcGVycGVuZGljdWxhclB0Mi5nZW9tZXRyeS5jb29yZGluYXRlc1swXSxcbiAgICAgICAgcGVycGVuZGljdWxhclB0Mi5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSxcbiAgICAgICAgc3RhcnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0sXG4gICAgICAgIHN0YXJ0Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdLFxuICAgICAgICBzdG9wLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICBzdG9wLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdXG4gICAgICAgICk7XG4gICAgICAgIHZhciBpbnRlcnNlY3RQdDtcbiAgICAgICAgaWYgKGludGVyc2VjdCkge1xuICAgICAgICAgICAgaW50ZXJzZWN0UHQgPSBwb2ludChpbnRlcnNlY3QpO1xuICAgICAgICAgICAgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0ID0gZGlzdGFuY2UocHQsIGludGVyc2VjdFB0LCB1bml0cyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc3RhcnQucHJvcGVydGllcy5kaXN0IDwgY2xvc2VzdFB0LnByb3BlcnRpZXMuZGlzdCkge1xuICAgICAgICAgICAgY2xvc2VzdFB0ID0gc3RhcnQ7XG4gICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0b3AucHJvcGVydGllcy5kaXN0IDwgY2xvc2VzdFB0LnByb3BlcnRpZXMuZGlzdCkge1xuICAgICAgICAgICAgY2xvc2VzdFB0ID0gc3RvcDtcbiAgICAgICAgICAgIGNsb3Nlc3RQdC5wcm9wZXJ0aWVzLmluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJzZWN0UHQgJiYgaW50ZXJzZWN0UHQucHJvcGVydGllcy5kaXN0IDwgY2xvc2VzdFB0LnByb3BlcnRpZXMuZGlzdCkge1xuICAgICAgICAgICAgY2xvc2VzdFB0ID0gaW50ZXJzZWN0UHQ7XG4gICAgICAgICAgICBjbG9zZXN0UHQucHJvcGVydGllcy5pbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gY2xvc2VzdFB0O1xufVxuXG4vLyBtb2RpZmllZCBmcm9tIGh0dHA6Ly9qc2ZpZGRsZS5uZXQvanVzdGluX2Nfcm91bmRzL0dkMlMyL2xpZ2h0L1xuZnVuY3Rpb24gbGluZUludGVyc2VjdHMobGluZTFTdGFydFgsIGxpbmUxU3RhcnRZLCBsaW5lMUVuZFgsIGxpbmUxRW5kWSwgbGluZTJTdGFydFgsIGxpbmUyU3RhcnRZLCBsaW5lMkVuZFgsIGxpbmUyRW5kWSkge1xuICAgIC8vIGlmIHRoZSBsaW5lcyBpbnRlcnNlY3QsIHRoZSByZXN1bHQgY29udGFpbnMgdGhlIHggYW5kIHkgb2YgdGhlIGludGVyc2VjdGlvbiAodHJlYXRpbmcgdGhlIGxpbmVzIGFzIGluZmluaXRlKSBhbmQgYm9vbGVhbnMgZm9yIHdoZXRoZXIgbGluZSBzZWdtZW50IDEgb3IgbGluZSBzZWdtZW50IDIgY29udGFpbiB0aGUgcG9pbnRcbiAgICB2YXIgZGVub21pbmF0b3IsIGEsIGIsIG51bWVyYXRvcjEsIG51bWVyYXRvcjI7XG4gICAgdmFyIHJlc3VsdCA9IHtcbiAgICAgICAgeDogbnVsbCxcbiAgICAgICAgeTogbnVsbCxcbiAgICAgICAgb25MaW5lMTogZmFsc2UsXG4gICAgICAgIG9uTGluZTI6IGZhbHNlXG4gICAgfTtcbiAgICBkZW5vbWluYXRvciA9ICgobGluZTJFbmRZIC0gbGluZTJTdGFydFkpICogKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSkgLSAoKGxpbmUyRW5kWCAtIGxpbmUyU3RhcnRYKSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuICAgIGlmIChkZW5vbWluYXRvciA9PT0gMCkge1xuICAgICAgICBpZiAocmVzdWx0LnggIT09IG51bGwgJiYgcmVzdWx0LnkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYSA9IGxpbmUxU3RhcnRZIC0gbGluZTJTdGFydFk7XG4gICAgYiA9IGxpbmUxU3RhcnRYIC0gbGluZTJTdGFydFg7XG4gICAgbnVtZXJhdG9yMSA9ICgobGluZTJFbmRYIC0gbGluZTJTdGFydFgpICogYSkgLSAoKGxpbmUyRW5kWSAtIGxpbmUyU3RhcnRZKSAqIGIpO1xuICAgIG51bWVyYXRvcjIgPSAoKGxpbmUxRW5kWCAtIGxpbmUxU3RhcnRYKSAqIGEpIC0gKChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkgKiBiKTtcbiAgICBhID0gbnVtZXJhdG9yMSAvIGRlbm9taW5hdG9yO1xuICAgIGIgPSBudW1lcmF0b3IyIC8gZGVub21pbmF0b3I7XG5cbiAgICAvLyBpZiB3ZSBjYXN0IHRoZXNlIGxpbmVzIGluZmluaXRlbHkgaW4gYm90aCBkaXJlY3Rpb25zLCB0aGV5IGludGVyc2VjdCBoZXJlOlxuICAgIHJlc3VsdC54ID0gbGluZTFTdGFydFggKyAoYSAqIChsaW5lMUVuZFggLSBsaW5lMVN0YXJ0WCkpO1xuICAgIHJlc3VsdC55ID0gbGluZTFTdGFydFkgKyAoYSAqIChsaW5lMUVuZFkgLSBsaW5lMVN0YXJ0WSkpO1xuXG4gICAgLy8gaWYgbGluZTEgaXMgYSBzZWdtZW50IGFuZCBsaW5lMiBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGEgPiAwICYmIGEgPCAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUxID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTIgaXMgYSBzZWdtZW50IGFuZCBsaW5lMSBpcyBpbmZpbml0ZSwgdGhleSBpbnRlcnNlY3QgaWY6XG4gICAgaWYgKGIgPiAwICYmIGIgPCAxKSB7XG4gICAgICAgIHJlc3VsdC5vbkxpbmUyID0gdHJ1ZTtcbiAgICB9XG4gICAgLy8gaWYgbGluZTEgYW5kIGxpbmUyIGFyZSBzZWdtZW50cywgdGhleSBpbnRlcnNlY3QgaWYgYm90aCBvZiB0aGUgYWJvdmUgYXJlIHRydWVcbiAgICBpZiAocmVzdWx0Lm9uTGluZTEgJiYgcmVzdWx0Lm9uTGluZTIpIHtcbiAgICAgICAgcmV0dXJuIFtyZXN1bHQueCwgcmVzdWx0LnldO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG59XG4iLCJ2YXIgZmVhdHVyZUNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBjZW50cm9pZCA9IHJlcXVpcmUoJ3R1cmYtY2VudGVyJyk7XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG52YXIgaW5zaWRlID0gcmVxdWlyZSgndHVyZi1pbnNpZGUnKTtcbnZhciBleHBsb2RlID0gcmVxdWlyZSgndHVyZi1leHBsb2RlJyk7XG5cbi8qKlxuICogVGFrZXMgYSBmZWF0dXJlIGFuZCByZXR1cm5zIGEge0BsaW5rIFBvaW50fSBndWFyYW50ZWVkIHRvIGJlIG9uIHRoZSBzdXJmYWNlIG9mIHRoZSBmZWF0dXJlLlxuICpcbiAqICogR2l2ZW4gYSB7QGxpbmsgUG9seWdvbn0sIHRoZSBwb2ludCB3aWxsIGJlIGluIHRoZSBhcmVhIG9mIHRoZSBwb2x5Z29uXG4gKiAqIEdpdmVuIGEge0BsaW5rIExpbmVTdHJpbmd9LCB0aGUgcG9pbnQgd2lsbCBiZSBhbG9uZyB0aGUgc3RyaW5nXG4gKiAqIEdpdmVuIGEge0BsaW5rIFBvaW50fSwgdGhlIHBvaW50IHdpbGwgdGhlIHNhbWUgYXMgdGhlIGlucHV0XG4gKlxuICogQHBhcmFtIHsoRmVhdHVyZXxGZWF0dXJlQ29sbGVjdGlvbil9IGZjIGFueSBmZWF0dXJlIG9yIHNldCBvZiBmZWF0dXJlc1xuICogQHJldHVybnMge0ZlYXR1cmV9IGEgcG9pbnQgb24gdGhlIHN1cmZhY2Ugb2YgYGlucHV0YFxuICogQGV4YW1wbGVcbiAqIC8vIGNyZWF0ZSBhIHJhbmRvbSBwb2x5Z29uXG4gKiB2YXIgcG9seWdvbiA9IHR1cmYucmFuZG9tKCdwb2x5Z29uJyk7XG4gKlxuICogLy89cG9seWdvblxuICpcbiAqIHZhciBwb2ludE9uUG9seWdvbiA9IHR1cmYucG9pbnRPblN1cmZhY2UocG9seWdvbik7XG4gKlxuKiB2YXIgcmVzdWx0RmVhdHVyZXMgPSBwb2x5Z29uLmZlYXR1cmVzLmNvbmNhdChwb2ludE9uUG9seWdvbik7XG4qIHZhciByZXN1bHQgPSB7XG4qICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiogICBcImZlYXR1cmVzXCI6IHJlc3VsdEZlYXR1cmVzXG4qIH07XG4gKlxuICogLy89cmVzdWx0XG4gKi9cbmZ1bmN0aW9uIHBvaW50T25TdXJmYWNlKGZjKSB7XG4gICAgLy8gbm9ybWFsaXplXG4gICAgaWYgKGZjLnR5cGUgIT09ICdGZWF0dXJlQ29sbGVjdGlvbicpIHtcbiAgICAgICAgaWYgKGZjLnR5cGUgIT09ICdGZWF0dXJlJykge1xuICAgICAgICAgICAgZmMgPSB7XG4gICAgICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBmYyxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBmYyA9IGZlYXR1cmVDb2xsZWN0aW9uKFtmY10pO1xuICAgIH1cblxuICAgIC8vZ2V0IGNlbnRyb2lkXG4gICAgdmFyIGNlbnQgPSBjZW50cm9pZChmYyk7XG5cbiAgICAvLyBjaGVjayB0byBzZWUgaWYgY2VudHJvaWQgaXMgb24gc3VyZmFjZVxuICAgIHZhciBvblN1cmZhY2UgPSBmYWxzZTtcbiAgICB2YXIgaSA9IDA7XG4gICAgd2hpbGUgKCFvblN1cmZhY2UgJiYgaSA8IGZjLmZlYXR1cmVzLmxlbmd0aCkge1xuICAgICAgICB2YXIgZ2VvbSA9IGZjLmZlYXR1cmVzW2ldLmdlb21ldHJ5O1xuICAgICAgICB2YXIgeCwgeSwgeDEsIHkxLCB4MiwgeTIsIGs7XG4gICAgICAgIHZhciBvbkxpbmUgPSBmYWxzZTtcbiAgICAgICAgaWYgKGdlb20udHlwZSA9PT0gJ1BvaW50Jykge1xuICAgICAgICAgICAgaWYgKGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0gPT09IGdlb20uY29vcmRpbmF0ZXNbMF0gJiZcbiAgICAgICAgY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXSA9PT0gZ2VvbS5jb29yZGluYXRlc1sxXSkge1xuICAgICAgICAgICAgICAgIG9uU3VyZmFjZSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTXVsdGlQb2ludCcpIHtcbiAgICAgICAgICAgIHZhciBvbk11bHRpUG9pbnQgPSBmYWxzZTtcbiAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgd2hpbGUgKCFvbk11bHRpUG9pbnQgJiYgayA8IGdlb20uY29vcmRpbmF0ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF0gPT09IGdlb20uY29vcmRpbmF0ZXNba11bMF0gJiZcbiAgICAgICAgICBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzFdID09PSBnZW9tLmNvb3JkaW5hdGVzW2tdWzFdKSB7XG4gICAgICAgICAgICAgICAgICAgIG9uU3VyZmFjZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIG9uTXVsdGlQb2ludCA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChnZW9tLnR5cGUgPT09ICdMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgayA9IDA7XG4gICAgICAgICAgICB3aGlsZSAoIW9uTGluZSAmJiBrIDwgZ2VvbS5jb29yZGluYXRlcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgeCA9IGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMF07XG4gICAgICAgICAgICAgICAgeSA9IGNlbnQuZ2VvbWV0cnkuY29vcmRpbmF0ZXNbMV07XG4gICAgICAgICAgICAgICAgeDEgPSBnZW9tLmNvb3JkaW5hdGVzW2tdWzBdO1xuICAgICAgICAgICAgICAgIHkxID0gZ2VvbS5jb29yZGluYXRlc1trXVsxXTtcbiAgICAgICAgICAgICAgICB4MiA9IGdlb20uY29vcmRpbmF0ZXNbayArIDFdWzBdO1xuICAgICAgICAgICAgICAgIHkyID0gZ2VvbS5jb29yZGluYXRlc1trICsgMV1bMV07XG4gICAgICAgICAgICAgICAgaWYgKHBvaW50T25TZWdtZW50KHgsIHksIHgxLCB5MSwgeDIsIHkyKSkge1xuICAgICAgICAgICAgICAgICAgICBvbkxpbmUgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvblN1cmZhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBrKys7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSBpZiAoZ2VvbS50eXBlID09PSAnTXVsdGlMaW5lU3RyaW5nJykge1xuICAgICAgICAgICAgdmFyIGogPSAwO1xuICAgICAgICAgICAgd2hpbGUgKGogPCBnZW9tLmNvb3JkaW5hdGVzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG9uTGluZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIGsgPSAwO1xuICAgICAgICAgICAgICAgIHZhciBsaW5lID0gZ2VvbS5jb29yZGluYXRlc1tqXTtcbiAgICAgICAgICAgICAgICB3aGlsZSAoIW9uTGluZSAmJiBrIDwgbGluZS5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICAgICAgICAgIHggPSBjZW50Lmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICB5ID0gY2VudC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXTtcbiAgICAgICAgICAgICAgICAgICAgeDEgPSBsaW5lW2tdWzBdO1xuICAgICAgICAgICAgICAgICAgICB5MSA9IGxpbmVba11bMV07XG4gICAgICAgICAgICAgICAgICAgIHgyID0gbGluZVtrICsgMV1bMF07XG4gICAgICAgICAgICAgICAgICAgIHkyID0gbGluZVtrICsgMV1bMV07XG4gICAgICAgICAgICAgICAgICAgIGlmIChwb2ludE9uU2VnbWVudCh4LCB5LCB4MSwgeTEsIHgyLCB5MikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uTGluZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvblN1cmZhY2UgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGsrKztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaisrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGdlb20udHlwZSA9PT0gJ1BvbHlnb24nIHx8IGdlb20udHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgICAgIHZhciBmID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICBnZW9tZXRyeTogZ2VvbSxcbiAgICAgICAgICAgICAgICBwcm9wZXJ0aWVzOiB7fVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChpbnNpZGUoY2VudCwgZikpIHtcbiAgICAgICAgICAgICAgICBvblN1cmZhY2UgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgaWYgKG9uU3VyZmFjZSkge1xuICAgICAgICByZXR1cm4gY2VudDtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgdmVydGljZXMgPSBmZWF0dXJlQ29sbGVjdGlvbihbXSk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBmYy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmVydGljZXMuZmVhdHVyZXMgPSB2ZXJ0aWNlcy5mZWF0dXJlcy5jb25jYXQoZXhwbG9kZShmYy5mZWF0dXJlc1tpXSkuZmVhdHVyZXMpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjbG9zZXN0VmVydGV4O1xuICAgICAgICB2YXIgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB2ZXJ0aWNlcy5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdmFyIGRpc3QgPSBkaXN0YW5jZShjZW50LCB2ZXJ0aWNlcy5mZWF0dXJlc1tpXSwgJ21pbGVzJyk7XG4gICAgICAgICAgICBpZiAoZGlzdCA8IGNsb3Nlc3REaXN0YW5jZSkge1xuICAgICAgICAgICAgICAgIGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG4gICAgICAgICAgICAgICAgY2xvc2VzdFZlcnRleCA9IHZlcnRpY2VzLmZlYXR1cmVzW2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbG9zZXN0VmVydGV4O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gcG9pbnRPblNlZ21lbnQoeCwgeSwgeDEsIHkxLCB4MiwgeTIpIHtcbiAgICB2YXIgYWIgPSBNYXRoLnNxcnQoKHgyIC0geDEpICogKHgyIC0geDEpICsgKHkyIC0geTEpICogKHkyIC0geTEpKTtcbiAgICB2YXIgYXAgPSBNYXRoLnNxcnQoKHggLSB4MSkgKiAoeCAtIHgxKSArICh5IC0geTEpICogKHkgLSB5MSkpO1xuICAgIHZhciBwYiA9IE1hdGguc3FydCgoeDIgLSB4KSAqICh4MiAtIHgpICsgKHkyIC0geSkgKiAoeTIgLSB5KSk7XG4gICAgaWYgKGFiID09PSBhcCArIHBiKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBwb2ludE9uU3VyZmFjZTtcbiIsIi8qKlxuICogVGFrZXMgY29vcmRpbmF0ZXMgYW5kIHByb3BlcnRpZXMgKG9wdGlvbmFsKSBhbmQgcmV0dXJucyBhIG5ldyB7QGxpbmsgUG9pbnR9IGZlYXR1cmUuXG4gKlxuICogQG1vZHVsZSB0dXJmL3BvaW50XG4gKiBAY2F0ZWdvcnkgaGVscGVyXG4gKiBAcGFyYW0ge251bWJlcn0gbG9uZ2l0dWRlIHBvc2l0aW9uIHdlc3QgdG8gZWFzdCBpbiBkZWNpbWFsIGRlZ3JlZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBsYXRpdHVkZSBwb3NpdGlvbiBzb3V0aCB0byBub3J0aCBpbiBkZWNpbWFsIGRlZ3JlZXNcbiAqIEBwYXJhbSB7T2JqZWN0fSBwcm9wZXJ0aWVzIGFuIE9iamVjdCB0aGF0IGlzIHVzZWQgYXMgdGhlIHtAbGluayBGZWF0dXJlfSdzXG4gKiBwcm9wZXJ0aWVzXG4gKiBAcmV0dXJuIHtQb2ludH0gYSBQb2ludCBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHB0MSA9IHR1cmYucG9pbnQoWy03NS4zNDMsIDM5Ljk4NF0pO1xuICpcbiAqIC8vPXB0MVxuICovXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHwgZnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoYXJnKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uKGNvb3JkaW5hdGVzLCBwcm9wZXJ0aWVzKSB7XG4gIGlmICghaXNBcnJheShjb29yZGluYXRlcykpIHRocm93IG5ldyBFcnJvcignQ29vcmRpbmF0ZXMgbXVzdCBiZSBhbiBhcnJheScpO1xuICBpZiAoY29vcmRpbmF0ZXMubGVuZ3RoIDwgMikgdGhyb3cgbmV3IEVycm9yKCdDb29yZGluYXRlcyBtdXN0IGJlIGF0IGxlYXN0IDIgbnVtYmVycyBsb25nJyk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJGZWF0dXJlXCIsXG4gICAgZ2VvbWV0cnk6IHtcbiAgICAgIHR5cGU6IFwiUG9pbnRcIixcbiAgICAgIGNvb3JkaW5hdGVzOiBjb29yZGluYXRlc1xuICAgIH0sXG4gICAgcHJvcGVydGllczogcHJvcGVydGllcyB8fCB7fVxuICB9O1xufTtcbiIsInZhciByYW5kb20gPSByZXF1aXJlKCdnZW9qc29uLXJhbmRvbScpO1xuXG4vKipcbiAqIEdlbmVyYXRlcyByYW5kb20ge0BsaW5rIEdlb0pTT059IGRhdGEsIGluY2x1ZGluZyB7QGxpbmsgUG9pbnR8UG9pbnRzfSBhbmQge0BsaW5rIFBvbHlnb258UG9seWdvbnN9LCBmb3IgdGVzdGluZ1xuICogYW5kIGV4cGVyaW1lbnRhdGlvbi5cbiAqXG4gKiBAbmFtZSByYW5kb21cbiAqIEBwYXJhbSB7U3RyaW5nfSBbdHlwZT0ncG9pbnQnXSB0eXBlIG9mIGZlYXR1cmVzIGRlc2lyZWQ6ICdwb2ludHMnIG9yICdwb2x5Z29ucydcbiAqIEBwYXJhbSB7TnVtYmVyfSBbY291bnQ9MV0gaG93IG1hbnkgZ2VvbWV0cmllcyBzaG91bGQgYmUgZ2VuZXJhdGVkLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgb3B0aW9ucyByZWxldmFudCB0byB0aGUgZmVhdHVyZSBkZXNpcmVkLiBDYW4gaW5jbHVkZTpcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gb3B0aW9ucy5iYm94IGEgYm91bmRpbmcgYm94IGluc2lkZSBvZiB3aGljaCBnZW9tZXRyaWVzXG4gKiBhcmUgcGxhY2VkLiBJbiB0aGUgY2FzZSBvZiB7QGxpbmsgUG9pbnR9IGZlYXR1cmVzLCB0aGV5IGFyZSBndWFyYW50ZWVkIHRvIGJlIHdpdGhpbiB0aGlzIGJvdW5kcyxcbiAqIHdoaWxlIHtAbGluayBQb2x5Z29ufSBmZWF0dXJlcyBoYXZlIHRoZWlyIGNlbnRyb2lkIHdpdGhpbiB0aGUgYm91bmRzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm51bV92ZXJ0aWNlcz0xMF0gb3B0aW9ucy52ZXJ0aWNlcyB0aGUgbnVtYmVyIG9mIHZlcnRpY2VzIGFkZGVkXG4gKiB0byBwb2x5Z29uIGZlYXR1cmVzLlxuICogQHBhcmFtIHtOdW1iZXJ9IFtvcHRpb25zLm1heF9yYWRpYWxfbGVuZ3RoPTEwXSB0aGUgdG90YWwgbnVtYmVyIG9mIGRlY2ltYWxcbiAqIGRlZ3JlZXMgbG9uZ2l0dWRlIG9yIGxhdGl0dWRlIHRoYXQgYSBwb2x5Z29uIGNhbiBleHRlbnQgb3V0d2FyZHMgdG9cbiAqIGZyb20gaXRzIGNlbnRlci5cbiAqIEByZXR1cm4ge0ZlYXR1cmVDb2xsZWN0aW9ufSBnZW5lcmF0ZWQgcmFuZG9tIGZlYXR1cmVzXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludHMnLCAxMDAsIHtcbiAqICAgYmJveDogWy03MCwgNDAsIC02MCwgNjBdXG4gKiB9KTtcbiAqXG4gKiAvLz1wb2ludHNcbiAqXG4gKiB2YXIgcG9seWdvbnMgPSB0dXJmLnJhbmRvbSgncG9seWdvbnMnLCA0LCB7XG4gKiAgIGJib3g6IFstNzAsIDQwLCAtNjAsIDYwXVxuICogfSk7XG4gKlxuICogLy89cG9seWdvbnNcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAodHlwZSwgY291bnQsIG9wdGlvbnMpIHtcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBjb3VudCA9IGNvdW50IHx8IDE7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAncG9pbnQnOlxuICAgIGNhc2UgJ3BvaW50cyc6XG4gICAgY2FzZSB1bmRlZmluZWQ6XG4gICAgICAgIHJldHVybiByYW5kb20ucG9pbnQoY291bnQsIG9wdGlvbnMuYmJveCk7XG4gICAgY2FzZSAncG9seWdvbic6XG4gICAgY2FzZSAncG9seWdvbnMnOlxuICAgICAgICByZXR1cm4gcmFuZG9tLnBvbHlnb24oXG4gICAgICAgICAgICAgICAgY291bnQsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5udW1fdmVydGljZXMsXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5tYXhfcmFkaWFsX2xlbmd0aCxcbiAgICAgICAgICAgICAgICBvcHRpb25zLmJib3gpO1xuICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biB0eXBlIGdpdmVuOiB2YWxpZCBvcHRpb25zIGFyZSBwb2ludHMgYW5kIHBvbHlnb25zJyk7XG4gICAgfVxufTtcbiIsIi8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9xdWVzdGlvbnMvMTE5MzUxNzUvc2FtcGxpbmctYS1yYW5kb20tc3Vic2V0LWZyb20tYW4tYXJyYXlcbnZhciBmZWF0dXJlQ29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIEZlYXR1cmVDb2xsZWN0aW9ufSBhbmQgcmV0dXJucyBhIEZlYXR1cmVDb2xsZWN0aW9uIHdpdGggZ2l2ZW4gbnVtYmVyIG9mIHtAbGluayBGZWF0dXJlfGZlYXR1cmVzfSBhdCByYW5kb20uXG4gKlxuICogQG5hbWUgc2FtcGxlXG4gKiBAcGFyYW0ge0ZlYXR1cmVDb2xsZWN0aW9ufSBmZWF0dXJlY29sbGVjdGlvbiBzZXQgb2YgaW5wdXQgZmVhdHVyZXNcbiAqIEBwYXJhbSB7bnVtYmVyfSBudW0gbnVtYmVyIG9mIGZlYXR1cmVzIHRvIHNlbGVjdFxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb259IGEgRmVhdHVyZUNvbGxlY3Rpb24gd2l0aCBgbmAgZmVhdHVyZXNcbiAqIEBleGFtcGxlXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5yYW5kb20oJ3BvaW50cycsIDEwMDApO1xuICpcbiAqIC8vPXBvaW50c1xuICpcbiAqIHZhciBzYW1wbGUgPSB0dXJmLnNhbXBsZShwb2ludHMsIDEwKTtcbiAqXG4gKiAvLz1zYW1wbGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZWNvbGxlY3Rpb24sIG51bSkge1xuICAgIHZhciBvdXRGQyA9IGZlYXR1cmVDb2xsZWN0aW9uKGdldFJhbmRvbVN1YmFycmF5KGZlYXR1cmVjb2xsZWN0aW9uLmZlYXR1cmVzLCBudW0pKTtcbiAgICByZXR1cm4gb3V0RkM7XG59O1xuXG5mdW5jdGlvbiBnZXRSYW5kb21TdWJhcnJheShhcnIsIHNpemUpIHtcbiAgICB2YXIgc2h1ZmZsZWQgPSBhcnIuc2xpY2UoMCksIGkgPSBhcnIubGVuZ3RoLCBtaW4gPSBpIC0gc2l6ZSwgdGVtcCwgaW5kZXg7XG4gICAgd2hpbGUgKGktLSA+IG1pbikge1xuICAgICAgICBpbmRleCA9IE1hdGguZmxvb3IoKGkgKyAxKSAqIE1hdGgucmFuZG9tKCkpO1xuICAgICAgICB0ZW1wID0gc2h1ZmZsZWRbaW5kZXhdO1xuICAgICAgICBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtpXTtcbiAgICAgICAgc2h1ZmZsZWRbaV0gPSB0ZW1wO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQuc2xpY2UobWluKTtcbn1cbiIsInZhciBzaW1wbGlmeSA9IHJlcXVpcmUoJ3NpbXBsaWZ5LWpzJyk7XG5cbi8vIHN1cHBvcnRlZCBHZW9KU09OIGdlb21ldHJpZXMsIHVzZWQgdG8gY2hlY2sgd2hldGhlciB0byB3cmFwIGluIHNpbXBsZUZlYXR1cmUoKVxudmFyIHN1cHBvcnRlZFR5cGVzID0gWydMaW5lU3RyaW5nJywgJ011bHRpTGluZVN0cmluZycsICdQb2x5Z29uJywgJ011bHRpUG9seWdvbiddO1xuXG4vKipcbiAqIFRha2VzIGEge0BsaW5rIExpbmVTdHJpbmd9IG9yIHtAbGluayBQb2x5Z29ufSBhbmQgcmV0dXJucyBhIHNpbXBsaWZpZWQgdmVyc2lvbi4gSW50ZXJuYWxseSB1c2VzIFtzaW1wbGlmeS1qc10oaHR0cDovL21vdXJuZXIuZ2l0aHViLmlvL3NpbXBsaWZ5LWpzLykgdG8gcGVyZm9ybSBzaW1wbGlmaWNhdGlvbi5cbiAqXG4gKiBAbmFtZSBzaW1wbGlmeVxuICogQHBhcmFtIHtGZWF0dXJlPChMaW5lU3RyaW5nfFBvbHlnb258TXVsdGlMaW5lU3RyaW5nfE11bHRpUG9seWdvbik+fEZlYXR1cmVDb2xsZWN0aW9ufEdlb21ldHJ5Q29sbGVjdGlvbn0gZmVhdHVyZSBmZWF0dXJlIHRvIGJlIHNpbXBsaWZpZWRcbiAqIEBwYXJhbSB7bnVtYmVyfSB0b2xlcmFuY2Ugc2ltcGxpZmljYXRpb24gdG9sZXJhbmNlXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGhpZ2hRdWFsaXR5IHdoZXRoZXIgb3Igbm90IHRvIHNwZW5kIG1vcmUgdGltZSB0byBjcmVhdGVcbiAqIGEgaGlnaGVyLXF1YWxpdHkgc2ltcGxpZmljYXRpb24gd2l0aCBhIGRpZmZlcmVudCBhbGdvcml0aG1cbiAqIEByZXR1cm4ge0ZlYXR1cmU8KExpbmVTdHJpbmd8UG9seWdvbnxNdWx0aUxpbmVTdHJpbmd8TXVsdGlQb2x5Z29uKT58RmVhdHVyZUNvbGxlY3Rpb258R2VvbWV0cnlDb2xsZWN0aW9ufSBhIHNpbXBsaWZpZWQgZmVhdHVyZVxuICogQGV4YW1wbGVcbiAgKiB2YXIgZmVhdHVyZSA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbLTcwLjYwMzYzNywgLTMzLjM5OTkxOF0sXG4gKiAgICAgICBbLTcwLjYxNDYyNCwgLTMzLjM5NTMzMl0sXG4gKiAgICAgICBbLTcwLjYzOTM0MywgLTMzLjM5MjQ2Nl0sXG4gKiAgICAgICBbLTcwLjY1OTk0MiwgLTMzLjM5NDc1OV0sXG4gKiAgICAgICBbLTcwLjY4Mzk3NSwgLTMzLjQwNDUwNF0sXG4gKiAgICAgICBbLTcwLjY5NzAyMSwgLTMzLjQxOTQwNl0sXG4gKiAgICAgICBbLTcwLjcwMTE0MSwgLTMzLjQzNDMwNl0sXG4gKiAgICAgICBbLTcwLjcwMDQ1NCwgLTMzLjQ0NjMzOV0sXG4gKiAgICAgICBbLTcwLjY5NDI3NCwgLTMzLjQ1ODM2OV0sXG4gKiAgICAgICBbLTcwLjY4MjYwMSwgLTMzLjQ2NTgxNl0sXG4gKiAgICAgICBbLTcwLjY2ODg2OSwgLTMzLjQ3MjExN10sXG4gKiAgICAgICBbLTcwLjY0NjIwOSwgLTMzLjQ3MzgzNV0sXG4gKiAgICAgICBbLTcwLjYyNDkyMywgLTMzLjQ3MjExN10sXG4gKiAgICAgICBbLTcwLjYwOTgxNywgLTMzLjQ2ODEwN10sXG4gKiAgICAgICBbLTcwLjU5NTM5NywgLTMzLjQ1ODM2OV0sXG4gKiAgICAgICBbLTcwLjU4NzE1OCwgLTMzLjQ0MjkwMV0sXG4gKiAgICAgICBbLTcwLjU4NzE1OCwgLTMzLjQyNjI4M10sXG4gKiAgICAgICBbLTcwLjU5MDU5MSwgLTMzLjQxNDI0OF0sXG4gKiAgICAgICBbLTcwLjU5NDcxMSwgLTMzLjQwNjIyNF0sXG4gKiAgICAgICBbLTcwLjYwMzYzNywgLTMzLjM5OTkxOF1cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuXG4gKiB2YXIgdG9sZXJhbmNlID0gMC4wMTtcbiAqXG4gKiB2YXIgc2ltcGxpZmllZCA9IHR1cmYuc2ltcGxpZnkoXG4gKiAgZmVhdHVyZSwgdG9sZXJhbmNlLCBmYWxzZSk7XG4gKlxuICogLy89ZmVhdHVyZVxuICpcbiAqIC8vPXNpbXBsaWZpZWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZmVhdHVyZSwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkge1xuICAgIGlmIChmZWF0dXJlLnR5cGUgPT09ICdGZWF0dXJlJykge1xuICAgICAgICByZXR1cm4gc2ltcGxlRmVhdHVyZShcbiAgICAgICAgICAgIHNpbXBsaWZ5SGVscGVyKGZlYXR1cmUsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpLFxuICAgICAgICAgICAgZmVhdHVyZS5wcm9wZXJ0aWVzKTtcbiAgICB9IGVsc2UgaWYgKGZlYXR1cmUudHlwZSA9PT0gJ0ZlYXR1cmVDb2xsZWN0aW9uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ0ZlYXR1cmVDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGZlYXR1cmVzOiBmZWF0dXJlLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAoZikge1xuICAgICAgICAgICAgICAgIHZhciBzaW1wbGlmaWVkID0gc2ltcGxpZnlIZWxwZXIoZiwgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSk7XG5cbiAgICAgICAgICAgICAgICAvLyB3ZSBjcmVhdGUgc2ltcGxlRmVhdHVyZSBoZXJlIGJlY2F1c2UgaXQgZG9lc24ndCBhcHBseSB0byBHZW9tZXRyeUNvbGxlY3Rpb25cbiAgICAgICAgICAgICAgICAvLyBzbyB3ZSBjYW4ndCBjcmVhdGUgaXQgYXQgc2ltcGxpZnlIZWxwZXIoKVxuICAgICAgICAgICAgICAgIGlmIChzdXBwb3J0ZWRUeXBlcy5pbmRleE9mKHNpbXBsaWZpZWQudHlwZSkgPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxlRmVhdHVyZShzaW1wbGlmaWVkLCBmLnByb3BlcnRpZXMpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBzaW1wbGlmaWVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLnR5cGUgPT09ICdHZW9tZXRyeUNvbGxlY3Rpb24nKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnR2VvbWV0cnlDb2xsZWN0aW9uJyxcbiAgICAgICAgICAgIGdlb21ldHJpZXM6IGZlYXR1cmUuZ2VvbWV0cmllcy5tYXAoZnVuY3Rpb24gKGcpIHtcbiAgICAgICAgICAgICAgICBpZiAoc3VwcG9ydGVkVHlwZXMuaW5kZXhPZihnLnR5cGUpID4gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5SGVscGVyKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdGZWF0dXJlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgIGdlb21ldHJ5OiBnXG4gICAgICAgICAgICAgICAgICAgIH0sIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gZztcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxufTtcblxuXG5mdW5jdGlvbiBzaW1wbGlmeUhlbHBlcihmZWF0dXJlLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KSB7XG4gICAgaWYgKGZlYXR1cmUuZ2VvbWV0cnkudHlwZSA9PT0gJ0xpbmVTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTGluZVN0cmluZycsXG4gICAgICAgICAgICBjb29yZGluYXRlczogc2ltcGxpZnlMaW5lKGZlYXR1cmUuZ2VvbWV0cnkuY29vcmRpbmF0ZXMsIHRvbGVyYW5jZSwgaGlnaFF1YWxpdHkpXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdNdWx0aUxpbmVTdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiAnTXVsdGlMaW5lU3RyaW5nJyxcbiAgICAgICAgICAgIGNvb3JkaW5hdGVzOiBmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAobGluZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gc2ltcGxpZnlMaW5lKGxpbmVzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KTtcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgfSBlbHNlIGlmIChmZWF0dXJlLmdlb21ldHJ5LnR5cGUgPT09ICdQb2x5Z29uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ1BvbHlnb24nLFxuICAgICAgICAgICAgY29vcmRpbmF0ZXM6IHNpbXBsaWZ5UG9seWdvbihmZWF0dXJlLmdlb21ldHJ5LmNvb3JkaW5hdGVzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSBpZiAoZmVhdHVyZS5nZW9tZXRyeS50eXBlID09PSAnTXVsdGlQb2x5Z29uJykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZTogJ011bHRpUG9seWdvbicsXG4gICAgICAgICAgICBjb29yZGluYXRlczogZmVhdHVyZS5nZW9tZXRyeS5jb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKHJpbmdzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHNpbXBsaWZ5UG9seWdvbihyaW5ncywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSk7XG4gICAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIHVuc3VwcG9ydGVkIGdlb21ldHJ5IHR5cGUgc3VwcGxpZWRcbiAgICAgICAgcmV0dXJuIGZlYXR1cmU7XG4gICAgfVxufVxuXG4vKlxuKiByZXR1cm5zIHRydWUgaWYgcmluZydzIGZpcnN0IGNvb3JkaW5hdGUgaXMgdGhlIHNhbWUgYXMgaXRzIGxhc3RcbiovXG5mdW5jdGlvbiBjaGVja1ZhbGlkaXR5KHJpbmcpIHtcbiAgICBpZiAocmluZy5sZW5ndGggPCAzKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvL2lmIHRoZSBsYXN0IHBvaW50IGlzIHRoZSBzYW1lIGFzIHRoZSBmaXJzdCwgaXQncyBub3QgYSB0cmlhbmdsZVxuICAgIH0gZWxzZSBpZiAocmluZy5sZW5ndGggPT09IDMgJiZcbiAgICAgICgocmluZ1syXVswXSA9PT0gcmluZ1swXVswXSkgJiYgKHJpbmdbMl1bMV0gPT09IHJpbmdbMF1bMV0pKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBzaW1wbGVGZWF0dXJlKGdlb20sIHByb3BlcnRpZXMpIHtcbiAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiAnRmVhdHVyZScsXG4gICAgICAgIGdlb21ldHJ5OiBnZW9tLFxuICAgICAgICBwcm9wZXJ0aWVzOiBwcm9wZXJ0aWVzXG4gICAgfTtcbn1cblxuZnVuY3Rpb24gc2ltcGxpZnlMaW5lKGNvb3JkaW5hdGVzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KSB7XG4gICAgcmV0dXJuIHNpbXBsaWZ5KGNvb3JkaW5hdGVzLm1hcChmdW5jdGlvbiAoY29vcmQpIHtcbiAgICAgICAgcmV0dXJuIHt4OiBjb29yZFswXSwgeTogY29vcmRbMV19O1xuICAgIH0pLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KS5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICByZXR1cm4gW2Nvb3Jkcy54LCBjb29yZHMueV07XG4gICAgfSk7XG59XG5cbmZ1bmN0aW9uIHNpbXBsaWZ5UG9seWdvbihjb29yZGluYXRlcywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkge1xuICAgIHJldHVybiBjb29yZGluYXRlcy5tYXAoZnVuY3Rpb24gKHJpbmcpIHtcbiAgICAgICAgdmFyIHB0cyA9IHJpbmcubWFwKGZ1bmN0aW9uIChjb29yZCkge1xuICAgICAgICAgICAgcmV0dXJuIHt4OiBjb29yZFswXSwgeTogY29vcmRbMV19O1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHB0cy5sZW5ndGggPCA0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgcG9seWdvbicpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzaW1wbGVSaW5nID0gc2ltcGxpZnkocHRzLCB0b2xlcmFuY2UsIGhpZ2hRdWFsaXR5KS5tYXAoZnVuY3Rpb24gKGNvb3Jkcykge1xuICAgICAgICAgICAgcmV0dXJuIFtjb29yZHMueCwgY29vcmRzLnldO1xuICAgICAgICB9KTtcbiAgICAgICAgLy9yZW1vdmUgMSBwZXJjZW50IG9mIHRvbGVyYW5jZSB1bnRpbCBlbm91Z2ggcG9pbnRzIHRvIG1ha2UgYSB0cmlhbmdsZVxuICAgICAgICB3aGlsZSAoIWNoZWNrVmFsaWRpdHkoc2ltcGxlUmluZykpIHtcbiAgICAgICAgICAgIHRvbGVyYW5jZSAtPSB0b2xlcmFuY2UgKiAwLjAxO1xuICAgICAgICAgICAgc2ltcGxlUmluZyA9IHNpbXBsaWZ5KHB0cywgdG9sZXJhbmNlLCBoaWdoUXVhbGl0eSkubWFwKGZ1bmN0aW9uIChjb29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gW2Nvb3Jkcy54LCBjb29yZHMueV07XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXG4gICAgICAgICAgICAoc2ltcGxlUmluZ1tzaW1wbGVSaW5nLmxlbmd0aCAtIDFdWzBdICE9PSBzaW1wbGVSaW5nWzBdWzBdKSB8fFxuICAgICAgICAgICAgICAgIChzaW1wbGVSaW5nW3NpbXBsZVJpbmcubGVuZ3RoIC0gMV1bMV0gIT09IHNpbXBsZVJpbmdbMF1bMV0pKSB7XG4gICAgICAgICAgICBzaW1wbGVSaW5nLnB1c2goc2ltcGxlUmluZ1swXSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNpbXBsZVJpbmc7XG4gICAgfSk7XG59XG4iLCJ2YXIgZmVhdHVyZWNvbGxlY3Rpb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5mZWF0dXJlQ29sbGVjdGlvbjtcbnZhciBwb2ludCA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvaW50O1xudmFyIHBvbHlnb24gPSByZXF1aXJlKCd0dXJmLWhlbHBlcnMnKS5wb2x5Z29uO1xudmFyIGRpc3RhbmNlID0gcmVxdWlyZSgndHVyZi1kaXN0YW5jZScpO1xuXG4vKipcbiAqIFRha2VzIGEgYm91bmRpbmcgYm94IGFuZCBhIGNlbGwgZGVwdGggYW5kIHJldHVybnMgYSBzZXQgb2Ygc3F1YXJlIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBpbiBhIGdyaWQuXG4gKlxuICogQG5hbWUgc3F1YXJlR3JpZFxuICogQHBhcmFtIHtBcnJheTxudW1iZXI+fSBiYm94IGV4dGVudCBpbiBbbWluWCwgbWluWSwgbWF4WCwgbWF4WV0gb3JkZXJcbiAqIEBwYXJhbSB7bnVtYmVyfSBjZWxsU2l6ZSB3aWR0aCBvZiBlYWNoIGNlbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0cyB1bml0cyB0byB1c2UgZm9yIGNlbGxXaWR0aFxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGdyaWQgYSBncmlkIG9mIHBvbHlnb25zXG4gKiBAZXhhbXBsZVxuICogdmFyIGV4dGVudCA9IFstNzcuMzg3Njk1MzEyNSwzOC43MTk4MDQ3NDI2NDIzOSwtNzYuOTQ4MjQyMTg3NSwzOS4wMjc3MTg4NDAyMTE2MDVdO1xuICogdmFyIGNlbGxXaWR0aCA9IDEwO1xuICogdmFyIHVuaXRzID0gJ21pbGVzJztcbiAqXG4gKiB2YXIgc3F1YXJlR3JpZCA9IHR1cmYuc3F1YXJlR3JpZChleHRlbnQsIGNlbGxXaWR0aCwgdW5pdHMpO1xuICpcbiAqIC8vPXNxdWFyZUdyaWRcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcXVhcmVHcmlkKGJib3gsIGNlbGxTaXplLCB1bml0cykge1xuICAgIHZhciBmYyA9IGZlYXR1cmVjb2xsZWN0aW9uKFtdKTtcbiAgICB2YXIgeEZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMl0sIGJib3hbMV1dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbFdpZHRoID0geEZyYWN0aW9uICogKGJib3hbMl0gLSBiYm94WzBdKTtcbiAgICB2YXIgeUZyYWN0aW9uID0gY2VsbFNpemUgLyAoZGlzdGFuY2UocG9pbnQoW2Jib3hbMF0sIGJib3hbMV1dKSwgcG9pbnQoW2Jib3hbMF0sIGJib3hbM11dKSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IHlGcmFjdGlvbiAqIChiYm94WzNdIC0gYmJveFsxXSk7XG5cbiAgICB2YXIgY3VycmVudFggPSBiYm94WzBdO1xuICAgIHdoaWxlIChjdXJyZW50WCA8PSBiYm94WzJdKSB7XG4gICAgICAgIHZhciBjdXJyZW50WSA9IGJib3hbMV07XG4gICAgICAgIHdoaWxlIChjdXJyZW50WSA8PSBiYm94WzNdKSB7XG4gICAgICAgICAgICB2YXIgY2VsbFBvbHkgPSBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgXV0pO1xuICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChjZWxsUG9seSk7XG5cbiAgICAgICAgICAgIGN1cnJlbnRZICs9IGNlbGxIZWlnaHQ7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudFggKz0gY2VsbFdpZHRoO1xuICAgIH1cblxuICAgIHJldHVybiBmYztcbn07XG4iLCJ2YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG5cbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGNhbGN1bGF0ZXMgdGhlIG1pbmltdW0gc3F1YXJlIGJvdW5kaW5nIGJveCB0aGF0XG4gKiB3b3VsZCBjb250YWluIHRoZSBpbnB1dC5cbiAqXG4gKiBAbmFtZSBzcXVhcmVcbiAqIEBwYXJhbSB7QXJyYXk8bnVtYmVyPn0gYmJveCBhIGJvdW5kaW5nIGJveFxuICogQHJldHVybiB7QXJyYXk8bnVtYmVyPn0gYSBzcXVhcmUgc3Vycm91bmRpbmcgYGJib3hgXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbLTIwLC0yMCwtMTUsMF07XG4gKlxuICogdmFyIHNxdWFyZWQgPSB0dXJmLnNxdWFyZShiYm94KTtcbiAqXG4gKiB2YXIgZmVhdHVyZXMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHR1cmYuYmJveFBvbHlnb24oYmJveCksXG4gKiAgICAgdHVyZi5iYm94UG9seWdvbihzcXVhcmVkKVxuICogICBdXG4gKiB9O1xuICpcbiAqIC8vPWZlYXR1cmVzXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGJib3gpIHtcbiAgICB2YXIgaG9yaXpvbnRhbERpc3RhbmNlID0gZGlzdGFuY2UoYmJveC5zbGljZSgwLCAyKSwgW2Jib3hbMl0sIGJib3hbMV1dLCAnbWlsZXMnKTtcbiAgICB2YXIgdmVydGljYWxEaXN0YW5jZSA9IGRpc3RhbmNlKGJib3guc2xpY2UoMCwgMiksIFtiYm94WzBdLCBiYm94WzNdXSwgJ21pbGVzJyk7XG4gICAgaWYgKGhvcml6b250YWxEaXN0YW5jZSA+PSB2ZXJ0aWNhbERpc3RhbmNlKSB7XG4gICAgICAgIHZhciB2ZXJ0aWNhbE1pZHBvaW50ID0gKGJib3hbMV0gKyBiYm94WzNdKSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBiYm94WzBdLFxuICAgICAgICAgICAgdmVydGljYWxNaWRwb2ludCAtICgoYmJveFsyXSAtIGJib3hbMF0pIC8gMiksXG4gICAgICAgICAgICBiYm94WzJdLFxuICAgICAgICAgICAgdmVydGljYWxNaWRwb2ludCArICgoYmJveFsyXSAtIGJib3hbMF0pIC8gMilcbiAgICAgICAgXTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgaG9yaXpvbnRhbE1pZHBvaW50ID0gKGJib3hbMF0gKyBiYm94WzJdKSAvIDI7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBob3Jpem9udGFsTWlkcG9pbnQgLSAoKGJib3hbM10gLSBiYm94WzFdKSAvIDIpLFxuICAgICAgICAgICAgYmJveFsxXSxcbiAgICAgICAgICAgIGhvcml6b250YWxNaWRwb2ludCArICgoYmJveFszXSAtIGJib3hbMV0pIC8gMiksXG4gICAgICAgICAgICBiYm94WzNdXG4gICAgICAgIF07XG4gICAgfVxufTtcbiIsInZhciBpbnNpZGUgPSByZXF1aXJlKCd0dXJmLWluc2lkZScpO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCBhIHNldCBvZiB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gYW5kIHBlcmZvcm1zIGEgc3BhdGlhbCBqb2luLlxuICpcbiAqIEBuYW1lIHRhZ1xuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25zIGlucHV0IHBvbHlnb25zXG4gKiBAcGFyYW0ge3N0cmluZ30gZmllbGQgcHJvcGVydHkgaW4gYHBvbHlnb25zYCB0byBhZGQgdG8gam9pbmVkIFBvaW50IGZlYXR1cmVzXG4gKiBAcGFyYW0ge3N0cmluZ30gb3V0RmllbGQgcHJvcGVydHkgaW4gYHBvaW50c2AgaW4gd2hpY2ggdG8gc3RvcmUgam9pbmVkIHByb3BlcnR5IGZyb20gYHBvbHlnb25zXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyB3aXRoIGBjb250YWluaW5nUG9seUlkYCBwcm9wZXJ0eSBjb250YWluaW5nIHZhbHVlcyBmcm9tIGBwb2x5SWRgXG4gKiBAZXhhbXBsZVxuICogdmFyIGJib3ggPSBbMCwgMCwgMTAsIDEwXTtcbiAqIC8vIGNyZWF0ZSBhIHRyaWFuZ3VsYXIgZ3JpZCBvZiBwb2x5Z29uc1xuICogdmFyIHRyaWFuZ2xlR3JpZCA9IHR1cmYudHJpYW5nbGVHcmlkKGJib3gsIDUwLCAnbWlsZXMnKTtcbiAqIHRyaWFuZ2xlR3JpZC5mZWF0dXJlcy5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAqICAgZi5wcm9wZXJ0aWVzLmZpbGwgPSAnIycgK1xuICogICAgICh+fihNYXRoLnJhbmRvbSgpICogMTYpKS50b1N0cmluZygxNikgK1xuICogICAgICh+fihNYXRoLnJhbmRvbSgpICogMTYpKS50b1N0cmluZygxNikgK1xuICogICAgICh+fihNYXRoLnJhbmRvbSgpICogMTYpKS50b1N0cmluZygxNik7XG4gKiAgIGYucHJvcGVydGllcy5zdHJva2UgPSAwO1xuICogICBmLnByb3BlcnRpZXNbJ2ZpbGwtb3BhY2l0eSddID0gMTtcbiAqIH0pO1xuICogdmFyIHJhbmRvbVBvaW50cyA9IHR1cmYucmFuZG9tKCdwb2ludCcsIDMwLCB7XG4gKiAgIGJib3g6IGJib3hcbiAqIH0pO1xuICogdmFyIGJvdGggPSB0dXJmLmZlYXR1cmVjb2xsZWN0aW9uKFxuICogICB0cmlhbmdsZUdyaWQuZmVhdHVyZXMuY29uY2F0KHJhbmRvbVBvaW50cy5mZWF0dXJlcykpO1xuICpcbiAqIC8vPWJvdGhcbiAqXG4gKiB2YXIgdGFnZ2VkID0gdHVyZi50YWcocmFuZG9tUG9pbnRzLCB0cmlhbmdsZUdyaWQsXG4gKiAgICAgICAgICAgICAgICAgICAgICAgJ2ZpbGwnLCAnbWFya2VyLWNvbG9yJyk7XG4gKlxuICogLy89dGFnZ2VkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgcG9seWdvbnMsIGZpZWxkLCBvdXRGaWVsZCkge1xuICAgIC8vIHByZXZlbnQgbXV0YXRpb25zXG4gICAgcG9pbnRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShwb2ludHMpKTtcbiAgICBwb2x5Z29ucyA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkocG9seWdvbnMpKTtcbiAgICBwb2ludHMuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAocHQpIHtcbiAgICAgICAgaWYgKCFwdC5wcm9wZXJ0aWVzKSB7XG4gICAgICAgICAgICBwdC5wcm9wZXJ0aWVzID0ge307XG4gICAgICAgIH1cbiAgICAgICAgcG9seWdvbnMuZmVhdHVyZXMuZm9yRWFjaChmdW5jdGlvbiAocG9seSkge1xuICAgICAgICAgICAgaWYgKHB0LnByb3BlcnRpZXNbb3V0RmllbGRdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB2YXIgaXNJbnNpZGUgPSBpbnNpZGUocHQsIHBvbHkpO1xuICAgICAgICAgICAgICAgIGlmIChpc0luc2lkZSkge1xuICAgICAgICAgICAgICAgICAgICBwdC5wcm9wZXJ0aWVzW291dEZpZWxkXSA9IHBvbHkucHJvcGVydGllc1tmaWVsZF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9KTtcbiAgICByZXR1cm4gcG9pbnRzO1xufTtcbiIsInZhciBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcbnZhciBlYXJjdXQgPSByZXF1aXJlKCdlYXJjdXQnKTtcblxuLyoqXG4gKiBUZXNzZWxhdGVzIGEge0BsaW5rIEZlYXR1cmU8UG9seWdvbj59IGludG8gYSB7QGxpbmsgRmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IG9mIHRyaWFuZ2xlc1xuICogdXNpbmcgW2VhcmN1dF0oaHR0cHM6Ly9naXRodWIuY29tL21hcGJveC9lYXJjdXQpLlxuICpcbiAqIEBuYW1lIHRlc3NlbGF0ZVxuICogQHBhcmFtIHtGZWF0dXJlPFBvbHlnb24+fSBwb2x5Z29uIHRoZSBwb2x5Z29uIHRvIHRlc3NlbGF0ZVxuICogQHJldHVybnMge0ZlYXR1cmVDb2xsZWN0aW9uPFBvbHlnb24+fSBhIGdlb21ldHJ5Y29sbGVjdGlvbiBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHlnb24gPSB7XCJ0eXBlXCI6XCJGZWF0dXJlXCIsXCJpZFwiOlwiVVNBLUNBXCIsXCJwcm9wZXJ0aWVzXCI6e1wibmFtZVwiOlwiQ2FsaWZvcm5pYVwifSxcImdlb21ldHJ5XCI6e1widHlwZVwiOlwiUG9seWdvblwiLFwiY29vcmRpbmF0ZXNcIjpbW1stMTIzLjIzMzI1Niw0Mi4wMDYxODZdLFstMTIyLjM3ODg1Myw0Mi4wMTE2NjNdLFstMTIxLjAzNzAwMyw0MS45OTUyMzJdLFstMTIwLjAwMTg2MSw0MS45OTUyMzJdLFstMTE5Ljk5NjM4NCw0MC4yNjQ1MTldLFstMTIwLjAwMTg2MSwzOC45OTkzNDZdLFstMTE4LjcxNDc4LDM4LjEwMTEyOF0sWy0xMTcuNDk4ODk5LDM3LjIxOTM0XSxbLTExNi41NDA0MzUsMzYuNTAxODYxXSxbLTExNS44NTAzNCwzNS45NzA1OThdLFstMTE0LjYzNDQ1OSwzNS4wMDExOF0sWy0xMTQuNjM0NDU5LDM0Ljg3NTIxXSxbLTExNC40NzAxNTEsMzQuNzEwOTAyXSxbLTExNC4zMzMyMjgsMzQuNDQ4MDA5XSxbLTExNC4xMzYwNTgsMzQuMzA1NjA4XSxbLTExNC4yNTY1NTEsMzQuMTc0MTYyXSxbLTExNC40MTUzODIsMzQuMTA4NDM4XSxbLTExNC41MzU4NzQsMzMuOTMzMTc2XSxbLTExNC40OTc1MzYsMzMuNjk3NjY4XSxbLTExNC41MjQ5MjEsMzMuNTQ5NzldLFstMTE0LjcyNzU2NywzMy40MDczOV0sWy0xMTQuNjYxODQ0LDMzLjAzNDk1OF0sWy0xMTQuNTI0OTIxLDMzLjAyOTQ4MV0sWy0xMTQuNDcwMTUxLDMyLjg0MzI2NV0sWy0xMTQuNTI0OTIxLDMyLjc1NTYzNF0sWy0xMTQuNzIyMDksMzIuNzE3Mjk1XSxbLTExNi4wNDc1MSwzMi42MjQxODddLFstMTE3LjEyNjQ2NywzMi41MzY1NTZdLFstMTE3LjI0Njk2LDMyLjY2ODAwM10sWy0xMTcuMjUyNDM3LDMyLjg3NjEyN10sWy0xMTcuMzI5MTE0LDMzLjEyMjU4OV0sWy0xMTcuNDcxNTE1LDMzLjI5Nzg1MV0sWy0xMTcuNzgzNywzMy41Mzg4MzZdLFstMTE4LjE4MzUxNywzMy43NjMzOTFdLFstMTE4LjI2MDE5NCwzMy43MDMxNDVdLFstMTE4LjQxMzU0OCwzMy43NDE0ODNdLFstMTE4LjM5MTY0MSwzMy44NDAwNjhdLFstMTE4LjU2NjkwMywzNC4wNDI3MTVdLFstMTE4LjgwMjQxMSwzMy45OTg4OTldLFstMTE5LjIxODY1OSwzNC4xNDY3NzddLFstMTE5LjI3ODkwNSwzNC4yNjcyN10sWy0xMTkuNTU4MjI5LDM0LjQxNTE0N10sWy0xMTkuODc1ODkxLDM0LjQwOTY3XSxbLTEyMC4xMzg3ODQsMzQuNDc1MzkzXSxbLTEyMC40NzI4NzgsMzQuNDQ4MDA5XSxbLTEyMC42NDgxNCwzNC41Nzk0NTVdLFstMTIwLjYwOTgwMSwzNC44NTg3NzldLFstMTIwLjY3MDA0OCwzNC45MDI1OTVdLFstMTIwLjYzMTcwOSwzNS4wOTk3NjRdLFstMTIwLjg5NDYwMiwzNS4yNDc2NDJdLFstMTIwLjkwNTU1NiwzNS40NTAyODldLFstMTIxLjAwNDE0MSwzNS40NjEyNDNdLFstMTIxLjE2ODQ0OSwzNS42MzY1MDVdLFstMTIxLjI4MzQ2NSwzNS42NzQ4NDNdLFstMTIxLjMzMjc1NywzNS43ODQzODJdLFstMTIxLjcxNjE0MywzNi4xOTUxNTNdLFstMTIxLjg5Njg4MiwzNi4zMTU2NDVdLFstMTIxLjkzNTIyMSwzNi42Mzg3ODVdLFstMTIxLjg1ODU0NCwzNi42MTE0XSxbLTEyMS43ODczNDQsMzYuODAzMDkzXSxbLTEyMS45Mjk3NDQsMzYuOTc4MzU1XSxbLTEyMi4xMDUwMDYsMzYuOTU2NDQ3XSxbLTEyMi4zMzUwMzgsMzcuMTE1Mjc5XSxbLTEyMi40MTcxOTIsMzcuMjQxMjQ4XSxbLTEyMi40MDA3NjEsMzcuMzYxNzQxXSxbLTEyMi41MTU3NzcsMzcuNTIwNTcyXSxbLTEyMi41MTU3NzcsMzcuNzgzNDY1XSxbLTEyMi4zMjk1NjEsMzcuNzgzNDY1XSxbLTEyMi40MDYyMzgsMzguMTUwNDJdLFstMTIyLjQ4ODM5MiwzOC4xMTIwODJdLFstMTIyLjUwNDgyMywzNy45MzEzNDNdLFstMTIyLjcwMTk5MywzNy44OTMwMDRdLFstMTIyLjkzNzUwMSwzOC4wMjk5MjhdLFstMTIyLjk3NTg0LDM4LjI2NTQzNl0sWy0xMjMuMTI5MTk0LDM4LjQ1MTY1Ml0sWy0xMjMuMzMxODQxLDM4LjU2NjY2OF0sWy0xMjMuNDQxMzgsMzguNjk4MTE0XSxbLTEyMy43MzcxMzQsMzguOTU1NTNdLFstMTIzLjY4Nzg0MiwzOS4wMzIyMDhdLFstMTIzLjgyNDc2NSwzOS4zNjYzMDFdLFstMTIzLjc2NDUxOSwzOS41NTI1MTddLFstMTIzLjg1MjE1LDM5LjgzMTg0MV0sWy0xMjQuMTA5NTY2LDQwLjEwNTY4OF0sWy0xMjQuMzYxNTA2LDQwLjI1OTA0Ml0sWy0xMjQuNDEwNzk4LDQwLjQzOTc4MV0sWy0xMjQuMTU4ODU5LDQwLjg3NzkzN10sWy0xMjQuMTA5NTY2LDQxLjAyNTgxNF0sWy0xMjQuMTU4ODU5LDQxLjE0MDgzXSxbLTEyNC4wNjU3NTEsNDEuNDQyMDYxXSxbLTEyNC4xNDc5MDUsNDEuNzE1OTA4XSxbLTEyNC4yNTc0NDQsNDEuNzgxNjMyXSxbLTEyNC4yMTM2MjgsNDIuMDAwNzA5XSxbLTEyMy4yMzMyNTYsNDIuMDA2MTg2XV1dfX07XG4gKlxuICogdmFyIHRyaWFuZ2xlcyA9IHR1cmYudGVzc2VsYXRlKHBvbHlnb24pO1xuICpcbiAqIC8vPXRyaWFuZ2xlc1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvbHkpIHtcbiAgICBpZiAoIXBvbHkuZ2VvbWV0cnkgfHwgKHBvbHkuZ2VvbWV0cnkudHlwZSAhPT0gJ1BvbHlnb24nICYmIHBvbHkuZ2VvbWV0cnkudHlwZSAhPT0gJ011bHRpUG9seWdvbicpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignaW5wdXQgbXVzdCBiZSBhIFBvbHlnb24gb3IgTXVsdGlQb2x5Z29uJyk7XG4gICAgfVxuXG4gICAgdmFyIGZjID0ge3R5cGU6ICdGZWF0dXJlQ29sbGVjdGlvbicsIGZlYXR1cmVzOiBbXX07XG5cbiAgICBpZiAocG9seS5nZW9tZXRyeS50eXBlID09PSAnUG9seWdvbicpIHtcbiAgICAgICAgZmMuZmVhdHVyZXMgPSBwcm9jZXNzUG9seWdvbihwb2x5Lmdlb21ldHJ5LmNvb3JkaW5hdGVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBwb2x5Lmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goZnVuY3Rpb24gKGNvb3JkaW5hdGVzKSB7XG4gICAgICAgICAgICBmYy5mZWF0dXJlcyA9IGZjLmZlYXR1cmVzLmNvbmNhdChwcm9jZXNzUG9seWdvbihjb29yZGluYXRlcykpO1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmM7XG59O1xuXG5mdW5jdGlvbiBwcm9jZXNzUG9seWdvbihjb29yZGluYXRlcykge1xuICAgIHZhciBkYXRhID0gZmxhdHRlbkNvb3Jkcyhjb29yZGluYXRlcyk7XG4gICAgdmFyIGRpbSA9IDI7XG4gICAgdmFyIHJlc3VsdCA9IGVhcmN1dChkYXRhLnZlcnRpY2VzLCBkYXRhLmhvbGVzLCBkaW0pO1xuXG4gICAgdmFyIGZlYXR1cmVzID0gW107XG4gICAgdmFyIHZlcnRpY2VzID0gW107XG5cbiAgICByZXN1bHQuZm9yRWFjaChmdW5jdGlvbiAodmVydCwgaSkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHRbaV07XG4gICAgICAgIHZlcnRpY2VzLnB1c2goW2RhdGEudmVydGljZXNbaW5kZXggKiBkaW1dLCBkYXRhLnZlcnRpY2VzW2luZGV4ICogZGltICsgMV1dKTtcbiAgICB9KTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmVydGljZXMubGVuZ3RoOyBpICs9IDMpIHtcbiAgICAgICAgdmFyIGNvb3JkcyA9IHZlcnRpY2VzLnNsaWNlKGksIGkgKyAzKTtcbiAgICAgICAgY29vcmRzLnB1c2godmVydGljZXNbaV0pO1xuICAgICAgICBmZWF0dXJlcy5wdXNoKHBvbHlnb24oW2Nvb3Jkc10pKTtcbiAgICB9XG5cbiAgICByZXR1cm4gZmVhdHVyZXM7XG59XG5cbmZ1bmN0aW9uIGZsYXR0ZW5Db29yZHMoZGF0YSkge1xuICAgIHZhciBkaW0gPSBkYXRhWzBdWzBdLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0ge3ZlcnRpY2VzOiBbXSwgaG9sZXM6IFtdLCBkaW1lbnNpb25zOiBkaW19LFxuICAgICAgICBob2xlSW5kZXggPSAwO1xuXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBkYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZGF0YVtpXS5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgZm9yICh2YXIgZCA9IDA7IGQgPCBkaW07IGQrKykgcmVzdWx0LnZlcnRpY2VzLnB1c2goZGF0YVtpXVtqXVtkXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGkgPiAwKSB7XG4gICAgICAgICAgICBob2xlSW5kZXggKz0gZGF0YVtpIC0gMV0ubGVuZ3RoO1xuICAgICAgICAgICAgcmVzdWx0LmhvbGVzLnB1c2goaG9sZUluZGV4KTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByZXN1bHQ7XG59XG4iLCIvL2h0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRGVsYXVuYXlfdHJpYW5ndWxhdGlvblxuLy9odHRwczovL2dpdGh1Yi5jb20vaXJvbndhbGxhYnkvZGVsYXVuYXlcbnZhciBwb2x5Z29uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykucG9seWdvbjtcbnZhciBmZWF0dXJlY29sbGVjdGlvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLmZlYXR1cmVDb2xsZWN0aW9uO1xuXG4vKipcbiAqIFRha2VzIGEgc2V0IG9mIHtAbGluayBQb2ludHxwb2ludHN9IGFuZCB0aGUgbmFtZSBvZiBhIHotdmFsdWUgcHJvcGVydHkgYW5kXG4gKiBjcmVhdGVzIGEgW1RyaWFuZ3VsYXRlZCBJcnJlZ3VsYXIgTmV0d29ya10oaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Ucmlhbmd1bGF0ZWRfaXJyZWd1bGFyX25ldHdvcmspLFxuICogb3IgYSBUSU4gZm9yIHNob3J0LCByZXR1cm5lZCBhcyBhIGNvbGxlY3Rpb24gb2YgUG9seWdvbnMuIFRoZXNlIGFyZSBvZnRlbiB1c2VkXG4gKiBmb3IgZGV2ZWxvcGluZyBlbGV2YXRpb24gY29udG91ciBtYXBzIG9yIHN0ZXBwZWQgaGVhdCB2aXN1YWxpemF0aW9ucy5cbiAqXG4gKiBUaGlzIHRyaWFuZ3VsYXRlcyB0aGUgcG9pbnRzLCBhcyB3ZWxsIGFzIGFkZHMgcHJvcGVydGllcyBjYWxsZWQgYGFgLCBgYmAsXG4gKiBhbmQgYGNgIHJlcHJlc2VudGluZyB0aGUgdmFsdWUgb2YgdGhlIGdpdmVuIGBwcm9wZXJ0eU5hbWVgIGF0IGVhY2ggb2ZcbiAqIHRoZSBwb2ludHMgdGhhdCByZXByZXNlbnQgdGhlIGNvcm5lcnMgb2YgdGhlIHRyaWFuZ2xlLlxuICpcbiAqIEBuYW1lIHRpblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7U3RyaW5nPX0geiBuYW1lIG9mIHRoZSBwcm9wZXJ0eSBmcm9tIHdoaWNoIHRvIHB1bGwgeiB2YWx1ZXNcbiAqIFRoaXMgaXMgb3B0aW9uYWw6IGlmIG5vdCBnaXZlbiwgdGhlbiB0aGVyZSB3aWxsIGJlIG5vIGV4dHJhIGRhdGEgYWRkZWQgdG8gdGhlIGRlcml2ZWQgdHJpYW5nbGVzLlxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IFRJTiBvdXRwdXRcbiAqIEBleGFtcGxlXG4gKiAvLyBnZW5lcmF0ZSBzb21lIHJhbmRvbSBwb2ludCBkYXRhXG4gKiB2YXIgcG9pbnRzID0gdHVyZi5yYW5kb20oJ3BvaW50cycsIDMwLCB7XG4gKiAgIGJib3g6IFs1MCwgMzAsIDcwLCA1MF1cbiAqIH0pO1xuICogLy89cG9pbnRzXG4gKiAvLyBhZGQgYSByYW5kb20gcHJvcGVydHkgdG8gZWFjaCBwb2ludCBiZXR3ZWVuIDAgYW5kIDlcbiAqIGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gKiAgIHBvaW50cy5mZWF0dXJlc1tpXS5wcm9wZXJ0aWVzLnogPSB+fihNYXRoLnJhbmRvbSgpICogOSk7XG4gKiB9XG4gKiB2YXIgdGluID0gdHVyZi50aW4ocG9pbnRzLCAneicpXG4gKiBmb3IgKHZhciBpID0gMDsgaSA8IHRpbi5mZWF0dXJlcy5sZW5ndGg7IGkrKykge1xuICogICB2YXIgcHJvcGVydGllcyAgPSB0aW4uZmVhdHVyZXNbaV0ucHJvcGVydGllcztcbiAqICAgLy8gcm91Z2hseSB0dXJuIHRoZSBwcm9wZXJ0aWVzIG9mIGVhY2hcbiAqICAgLy8gdHJpYW5nbGUgaW50byBhIGZpbGwgY29sb3JcbiAqICAgLy8gc28gd2UgY2FuIHZpc3VhbGl6ZSB0aGUgcmVzdWx0XG4gKiAgIHByb3BlcnRpZXMuZmlsbCA9ICcjJyArIHByb3BlcnRpZXMuYSArXG4gKiAgICAgcHJvcGVydGllcy5iICsgcHJvcGVydGllcy5jO1xuICogfVxuICogLy89dGluXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvaW50cywgeikge1xuICAgIC8vYnJlYWsgZG93biBwb2ludHNcbiAgICByZXR1cm4gZmVhdHVyZWNvbGxlY3Rpb24odHJpYW5ndWxhdGUocG9pbnRzLmZlYXR1cmVzLm1hcChmdW5jdGlvbiAocCkge1xuICAgICAgICB2YXIgcG9pbnQgPSB7XG4gICAgICAgICAgICB4OiBwLmdlb21ldHJ5LmNvb3JkaW5hdGVzWzBdLFxuICAgICAgICAgICAgeTogcC5nZW9tZXRyeS5jb29yZGluYXRlc1sxXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoeikgcG9pbnQueiA9IHAucHJvcGVydGllc1t6XTtcbiAgICAgICAgcmV0dXJuIHBvaW50O1xuICAgIH0pKS5tYXAoZnVuY3Rpb24gKHRyaWFuZ2xlKSB7XG4gICAgICAgIHJldHVybiBwb2x5Z29uKFtbXG4gICAgICAgIFt0cmlhbmdsZS5hLngsIHRyaWFuZ2xlLmEueV0sXG4gICAgICAgIFt0cmlhbmdsZS5iLngsIHRyaWFuZ2xlLmIueV0sXG4gICAgICAgIFt0cmlhbmdsZS5jLngsIHRyaWFuZ2xlLmMueV0sXG4gICAgICAgIFt0cmlhbmdsZS5hLngsIHRyaWFuZ2xlLmEueV1cbiAgICAgICAgXV0sIHtcbiAgICAgICAgICAgIGE6IHRyaWFuZ2xlLmEueixcbiAgICAgICAgICAgIGI6IHRyaWFuZ2xlLmIueixcbiAgICAgICAgICAgIGM6IHRyaWFuZ2xlLmMuelxuICAgICAgICB9KTtcbiAgICB9KSk7XG59O1xuXG5mdW5jdGlvbiBUcmlhbmdsZShhLCBiLCBjKSB7XG4gICAgdGhpcy5hID0gYTtcbiAgICB0aGlzLmIgPSBiO1xuICAgIHRoaXMuYyA9IGM7XG5cbiAgICB2YXIgQSA9IGIueCAtIGEueCxcbiAgICAgICAgQiA9IGIueSAtIGEueSxcbiAgICAgICAgQyA9IGMueCAtIGEueCxcbiAgICAgICAgRCA9IGMueSAtIGEueSxcbiAgICAgICAgRSA9IEEgKiAoYS54ICsgYi54KSArIEIgKiAoYS55ICsgYi55KSxcbiAgICAgICAgRiA9IEMgKiAoYS54ICsgYy54KSArIEQgKiAoYS55ICsgYy55KSxcbiAgICAgICAgRyA9IDIgKiAoQSAqIChjLnkgLSBiLnkpIC0gQiAqIChjLnggLSBiLngpKSxcbiAgICAgICAgbWlueCwgbWlueSwgZHgsIGR5O1xuXG4gICAgLy8gSWYgdGhlIHBvaW50cyBvZiB0aGUgdHJpYW5nbGUgYXJlIGNvbGxpbmVhciwgdGhlbiBqdXN0IGZpbmQgdGhlXG4gICAgLy8gZXh0cmVtZXMgYW5kIHVzZSB0aGUgbWlkcG9pbnQgYXMgdGhlIGNlbnRlciBvZiB0aGUgY2lyY3VtY2lyY2xlLlxuICAgIGlmIChNYXRoLmFicyhHKSA8IDAuMDAwMDAxKSB7XG4gICAgICAgIG1pbnggPSBNYXRoLm1pbihhLngsIGIueCwgYy54KTtcbiAgICAgICAgbWlueSA9IE1hdGgubWluKGEueSwgYi55LCBjLnkpO1xuICAgICAgICBkeCA9IChNYXRoLm1heChhLngsIGIueCwgYy54KSAtIG1pbngpICogMC41O1xuICAgICAgICBkeSA9IChNYXRoLm1heChhLnksIGIueSwgYy55KSAtIG1pbnkpICogMC41O1xuXG4gICAgICAgIHRoaXMueCA9IG1pbnggKyBkeDtcbiAgICAgICAgdGhpcy55ID0gbWlueSArIGR5O1xuICAgICAgICB0aGlzLnIgPSBkeCAqIGR4ICsgZHkgKiBkeTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnggPSAoRCAqIEUgLSBCICogRikgLyBHO1xuICAgICAgICB0aGlzLnkgPSAoQSAqIEYgLSBDICogRSkgLyBHO1xuICAgICAgICBkeCA9IHRoaXMueCAtIGEueDtcbiAgICAgICAgZHkgPSB0aGlzLnkgLSBhLnk7XG4gICAgICAgIHRoaXMuciA9IGR4ICogZHggKyBkeSAqIGR5O1xuICAgIH1cbn1cblxuZnVuY3Rpb24gYnlYKGEsIGIpIHtcbiAgICByZXR1cm4gYi54IC0gYS54O1xufVxuXG5mdW5jdGlvbiBkZWR1cChlZGdlcykge1xuICAgIHZhciBqID0gZWRnZXMubGVuZ3RoLFxuICAgICAgICBhLCBiLCBpLCBtLCBuO1xuXG4gICAgb3V0ZXI6XG4gIHdoaWxlIChqKSB7XG4gICAgICBiID0gZWRnZXNbLS1qXTtcbiAgICAgIGEgPSBlZGdlc1stLWpdO1xuICAgICAgaSA9IGo7XG4gICAgICB3aGlsZSAoaSkge1xuICAgICAgICAgIG4gPSBlZGdlc1stLWldO1xuICAgICAgICAgIG0gPSBlZGdlc1stLWldO1xuICAgICAgICAgIGlmICgoYSA9PT0gbSAmJiBiID09PSBuKSB8fCAoYSA9PT0gbiAmJiBiID09PSBtKSkge1xuICAgICAgICAgICAgICBlZGdlcy5zcGxpY2UoaiwgMik7XG4gICAgICAgICAgICAgIGVkZ2VzLnNwbGljZShpLCAyKTtcbiAgICAgICAgICAgICAgaiAtPSAyO1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdHJpYW5ndWxhdGUodmVydGljZXMpIHtcbiAgICAvLyBCYWlsIGlmIHRoZXJlIGFyZW4ndCBlbm91Z2ggdmVydGljZXMgdG8gZm9ybSBhbnkgdHJpYW5nbGVzLlxuICAgIGlmICh2ZXJ0aWNlcy5sZW5ndGggPCAzKVxuICAgICAgICByZXR1cm4gW107XG5cbiAgICAvLyBFbnN1cmUgdGhlIHZlcnRleCBhcnJheSBpcyBpbiBvcmRlciBvZiBkZXNjZW5kaW5nIFggY29vcmRpbmF0ZVxuICAgIC8vICh3aGljaCBpcyBuZWVkZWQgdG8gZW5zdXJlIGEgc3VicXVhZHJhdGljIHJ1bnRpbWUpLCBhbmQgdGhlbiBmaW5kXG4gICAgLy8gdGhlIGJvdW5kaW5nIGJveCBhcm91bmQgdGhlIHBvaW50cy5cbiAgICB2ZXJ0aWNlcy5zb3J0KGJ5WCk7XG5cbiAgICB2YXIgaSA9IHZlcnRpY2VzLmxlbmd0aCAtIDEsXG4gICAgICAgIHhtaW4gPSB2ZXJ0aWNlc1tpXS54LFxuICAgICAgICB4bWF4ID0gdmVydGljZXNbMF0ueCxcbiAgICAgICAgeW1pbiA9IHZlcnRpY2VzW2ldLnksXG4gICAgICAgIHltYXggPSB5bWluO1xuXG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgICBpZiAodmVydGljZXNbaV0ueSA8IHltaW4pXG4gICAgICAgICAgICB5bWluID0gdmVydGljZXNbaV0ueTtcbiAgICAgICAgaWYgKHZlcnRpY2VzW2ldLnkgPiB5bWF4KVxuICAgICAgICAgICAgeW1heCA9IHZlcnRpY2VzW2ldLnk7XG4gICAgfVxuXG4gICAgLy9GaW5kIGEgc3VwZXJ0cmlhbmdsZSwgd2hpY2ggaXMgYSB0cmlhbmdsZSB0aGF0IHN1cnJvdW5kcyBhbGwgdGhlXG4gICAgLy92ZXJ0aWNlcy4gVGhpcyBpcyB1c2VkIGxpa2Ugc29tZXRoaW5nIG9mIGEgc2VudGluZWwgdmFsdWUgdG8gcmVtb3ZlXG4gICAgLy9jYXNlcyBpbiB0aGUgbWFpbiBhbGdvcml0aG0sIGFuZCBpcyByZW1vdmVkIGJlZm9yZSB3ZSByZXR1cm4gYW55XG4gICAgLy8gcmVzdWx0cy5cblxuICAgIC8vIE9uY2UgZm91bmQsIHB1dCBpdCBpbiB0aGUgXCJvcGVuXCIgbGlzdC4gKFRoZSBcIm9wZW5cIiBsaXN0IGlzIGZvclxuICAgIC8vIHRyaWFuZ2xlcyB3aG8gbWF5IHN0aWxsIG5lZWQgdG8gYmUgY29uc2lkZXJlZDsgdGhlIFwiY2xvc2VkXCIgbGlzdCBpc1xuICAgIC8vIGZvciB0cmlhbmdsZXMgd2hpY2ggZG8gbm90LilcbiAgICB2YXIgZHggPSB4bWF4IC0geG1pbixcbiAgICAgICAgZHkgPSB5bWF4IC0geW1pbixcbiAgICAgICAgZG1heCA9IChkeCA+IGR5KSA/IGR4IDogZHksXG4gICAgICAgIHhtaWQgPSAoeG1heCArIHhtaW4pICogMC41LFxuICAgICAgICB5bWlkID0gKHltYXggKyB5bWluKSAqIDAuNSxcbiAgICAgICAgb3BlbiA9IFtcbiAgICAgICAgICAgIG5ldyBUcmlhbmdsZSh7XG4gICAgICAgICAgICAgICAgeDogeG1pZCAtIDIwICogZG1heCxcbiAgICAgICAgICAgICAgICB5OiB5bWlkIC0gZG1heCxcbiAgICAgICAgICAgICAgICBfX3NlbnRpbmVsOiB0cnVlXG4gICAgICAgICAgICB9LCB7XG4gICAgICAgICAgICAgICAgeDogeG1pZCxcbiAgICAgICAgICAgICAgICB5OiB5bWlkICsgMjAgKiBkbWF4LFxuICAgICAgICAgICAgICAgIF9fc2VudGluZWw6IHRydWVcbiAgICAgICAgICAgIH0sIHtcbiAgICAgICAgICAgICAgICB4OiB4bWlkICsgMjAgKiBkbWF4LFxuICAgICAgICAgICAgICAgIHk6IHltaWQgLSBkbWF4LFxuICAgICAgICAgICAgICAgIF9fc2VudGluZWw6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgKV0sXG4gICAgICAgIGNsb3NlZCA9IFtdLFxuICAgICAgICBlZGdlcyA9IFtdLFxuICAgICAgICBqLCBhLCBiO1xuXG4gICAgLy8gSW5jcmVtZW50YWxseSBhZGQgZWFjaCB2ZXJ0ZXggdG8gdGhlIG1lc2guXG4gICAgaSA9IHZlcnRpY2VzLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKSB7XG4gICAgICAgIC8vIEZvciBlYWNoIG9wZW4gdHJpYW5nbGUsIGNoZWNrIHRvIHNlZSBpZiB0aGUgY3VycmVudCBwb2ludCBpc1xuICAgICAgICAvLyBpbnNpZGUgaXQncyBjaXJjdW1jaXJjbGUuIElmIGl0IGlzLCByZW1vdmUgdGhlIHRyaWFuZ2xlIGFuZCBhZGRcbiAgICAgICAgLy8gaXQncyBlZGdlcyB0byBhbiBlZGdlIGxpc3QuXG4gICAgICAgIGVkZ2VzLmxlbmd0aCA9IDA7XG4gICAgICAgIGogPSBvcGVuLmxlbmd0aDtcbiAgICAgICAgd2hpbGUgKGotLSkge1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBwb2ludCBpcyB0byB0aGUgcmlnaHQgb2YgdGhpcyB0cmlhbmdsZSdzIGNpcmN1bWNpcmNsZSxcbiAgICAgICAgICAgIC8vIHRoZW4gdGhpcyB0cmlhbmdsZSBzaG91bGQgbmV2ZXIgZ2V0IGNoZWNrZWQgYWdhaW4uIFJlbW92ZSBpdFxuICAgICAgICAgICAgLy8gZnJvbSB0aGUgb3BlbiBsaXN0LCBhZGQgaXQgdG8gdGhlIGNsb3NlZCBsaXN0LCBhbmQgc2tpcC5cbiAgICAgICAgICAgIGR4ID0gdmVydGljZXNbaV0ueCAtIG9wZW5bal0ueDtcbiAgICAgICAgICAgIGlmIChkeCA+IDAgJiYgZHggKiBkeCA+IG9wZW5bal0ucikge1xuICAgICAgICAgICAgICAgIGNsb3NlZC5wdXNoKG9wZW5bal0pO1xuICAgICAgICAgICAgICAgIG9wZW4uc3BsaWNlKGosIDEpO1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBJZiBub3QsIHNraXAgdGhpcyB0cmlhbmdsZS5cbiAgICAgICAgICAgIGR5ID0gdmVydGljZXNbaV0ueSAtIG9wZW5bal0ueTtcbiAgICAgICAgICAgIGlmIChkeCAqIGR4ICsgZHkgKiBkeSA+IG9wZW5bal0ucilcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcblxuICAgICAgICAgICAgLy8gUmVtb3ZlIHRoZSB0cmlhbmdsZSBhbmQgYWRkIGl0J3MgZWRnZXMgdG8gdGhlIGVkZ2UgbGlzdC5cbiAgICAgICAgICAgIGVkZ2VzLnB1c2goXG4gICAgICAgIG9wZW5bal0uYSwgb3BlbltqXS5iLFxuICAgICAgICBvcGVuW2pdLmIsIG9wZW5bal0uYyxcbiAgICAgICAgb3BlbltqXS5jLCBvcGVuW2pdLmFcbiAgICAgICk7XG4gICAgICAgICAgICBvcGVuLnNwbGljZShqLCAxKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlbW92ZSBhbnkgZG91YmxlZCBlZGdlcy5cbiAgICAgICAgZGVkdXAoZWRnZXMpO1xuXG4gICAgICAgIC8vIEFkZCBhIG5ldyB0cmlhbmdsZSBmb3IgZWFjaCBlZGdlLlxuICAgICAgICBqID0gZWRnZXMubGVuZ3RoO1xuICAgICAgICB3aGlsZSAoaikge1xuICAgICAgICAgICAgYiA9IGVkZ2VzWy0tal07XG4gICAgICAgICAgICBhID0gZWRnZXNbLS1qXTtcbiAgICAgICAgICAgIG9wZW4ucHVzaChuZXcgVHJpYW5nbGUoYSwgYiwgdmVydGljZXNbaV0pKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIC8vIENvcHkgYW55IHJlbWFpbmluZyBvcGVuIHRyaWFuZ2xlcyB0byB0aGUgY2xvc2VkIGxpc3QsIGFuZCB0aGVuXG4gICAgLy8gcmVtb3ZlIGFueSB0cmlhbmdsZXMgdGhhdCBzaGFyZSBhIHZlcnRleCB3aXRoIHRoZSBzdXBlcnRyaWFuZ2xlLlxuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGNsb3NlZCwgb3Blbik7XG5cbiAgICBpID0gY2xvc2VkLmxlbmd0aDtcbiAgICB3aGlsZSAoaS0tKVxuICAgICAgICBpZiAoY2xvc2VkW2ldLmEuX19zZW50aW5lbCB8fFxuICAgICAgY2xvc2VkW2ldLmIuX19zZW50aW5lbCB8fFxuICAgICAgY2xvc2VkW2ldLmMuX19zZW50aW5lbClcbiAgICAgICAgICAgIGNsb3NlZC5zcGxpY2UoaSwgMSk7XG5cbiAgICByZXR1cm4gY2xvc2VkO1xufVxuIiwidmFyIGZlYXR1cmVjb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG52YXIgcG9seWdvbiA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpLnBvbHlnb247XG52YXIgZGlzdGFuY2UgPSByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyk7XG5cbi8qKlxuICogVGFrZXMgYSBib3VuZGluZyBib3ggYW5kIGEgY2VsbCBkZXB0aCBhbmQgcmV0dXJucyBhIHNldCBvZiB0cmlhbmd1bGFyIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBpbiBhIGdyaWQuXG4gKlxuICogQG5hbWUgdHJpYW5nbGVHcmlkXG4gKiBAcGFyYW0ge0FycmF5PG51bWJlcj59IGJib3ggZXh0ZW50IGluIFttaW5YLCBtaW5ZLCBtYXhYLCBtYXhZXSBvcmRlclxuICogQHBhcmFtIHtudW1iZXJ9IGNlbGxTaXplIGRpbWVuc2lvbiBvZiBlYWNoIGNlbGxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1bml0cyB1bml0cyB0byB1c2UgZm9yIGNlbGxXaWR0aFxuICogQHJldHVybiB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IGdyaWQgb2YgcG9seWdvbnNcbiAqIEBleGFtcGxlXG4gKiB2YXIgZXh0ZW50ID0gWy03Ny4zODc2OTUzMTI1LDM4LjcxOTgwNDc0MjY0MjM5LC03Ni45NDgyNDIxODc1LDM5LjAyNzcxODg0MDIxMTYwNV07XG4gKiB2YXIgY2VsbFdpZHRoID0gMTA7XG4gKiB2YXIgdW5pdHMgPSAnbWlsZXMnO1xuICpcbiAqIHZhciB0cmlhbmdsZUdyaWQgPSB0dXJmLnRyaWFuZ2xlR3JpZChleHRlbnQsIGNlbGxXaWR0aCwgdW5pdHMpO1xuICpcbiAqIC8vPXRyaWFuZ2xlR3JpZFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiYm94LCBjZWxsU2l6ZSwgdW5pdHMpIHtcbiAgICB2YXIgZmMgPSBmZWF0dXJlY29sbGVjdGlvbihbXSk7XG4gICAgdmFyIHhGcmFjdGlvbiA9IGNlbGxTaXplIC8gKGRpc3RhbmNlKFtiYm94WzBdLCBiYm94WzFdXSwgW2Jib3hbMl0sIGJib3hbMV1dLCB1bml0cykpO1xuICAgIHZhciBjZWxsV2lkdGggPSB4RnJhY3Rpb24gKiAoYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIHZhciB5RnJhY3Rpb24gPSBjZWxsU2l6ZSAvIChkaXN0YW5jZShbYmJveFswXSwgYmJveFsxXV0sIFtiYm94WzBdLCBiYm94WzNdXSwgdW5pdHMpKTtcbiAgICB2YXIgY2VsbEhlaWdodCA9IHlGcmFjdGlvbiAqIChiYm94WzNdIC0gYmJveFsxXSk7XG5cbiAgICB2YXIgeGkgPSAwO1xuICAgIHZhciBjdXJyZW50WCA9IGJib3hbMF07XG4gICAgd2hpbGUgKGN1cnJlbnRYIDw9IGJib3hbMl0pIHtcbiAgICAgICAgdmFyIHlpID0gMDtcbiAgICAgICAgdmFyIGN1cnJlbnRZID0gYmJveFsxXTtcbiAgICAgICAgd2hpbGUgKGN1cnJlbnRZIDw9IGJib3hbM10pIHtcbiAgICAgICAgICAgIGlmICh4aSAlIDIgPT09IDAgJiYgeWkgJSAyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXVxuICAgICAgICAgICAgICAgIF1dKSwgcG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XVxuICAgICAgICAgICAgICAgIF1dKSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKHhpICUgMiA9PT0gMCAmJiB5aSAlIDIgPT09IDEpIHtcbiAgICAgICAgICAgICAgICBmYy5mZWF0dXJlcy5wdXNoKHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pLCBwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICBdXSkpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh5aSAlIDIgPT09IDAgJiYgeGkgJSAyID09PSAxKSB7XG4gICAgICAgICAgICAgICAgZmMuZmVhdHVyZXMucHVzaChwb2x5Z29uKFtbXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICBdXSksIHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFkgKyBjZWxsSGVpZ2h0XSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYICsgY2VsbFdpZHRoLCBjdXJyZW50WV0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCwgY3VycmVudFldXG4gICAgICAgICAgICAgICAgXV0pKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAoeWkgJSAyID09PSAxICYmIHhpICUgMiA9PT0gMSkge1xuICAgICAgICAgICAgICAgIGZjLmZlYXR1cmVzLnB1c2gocG9seWdvbihbW1xuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZXSxcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WV1cbiAgICAgICAgICAgICAgICBdXSksIHBvbHlnb24oW1tcbiAgICAgICAgICAgICAgICAgICAgW2N1cnJlbnRYLCBjdXJyZW50WSArIGNlbGxIZWlnaHRdLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFggKyBjZWxsV2lkdGgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF0sXG4gICAgICAgICAgICAgICAgICAgIFtjdXJyZW50WCArIGNlbGxXaWR0aCwgY3VycmVudFldLFxuICAgICAgICAgICAgICAgICAgICBbY3VycmVudFgsIGN1cnJlbnRZICsgY2VsbEhlaWdodF1cbiAgICAgICAgICAgICAgICBdXSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY3VycmVudFkgKz0gY2VsbEhlaWdodDtcbiAgICAgICAgICAgIHlpKys7XG4gICAgICAgIH1cbiAgICAgICAgeGkrKztcbiAgICAgICAgY3VycmVudFggKz0gY2VsbFdpZHRoO1xuICAgIH1cbiAgICByZXR1cm4gZmM7XG59O1xuXG4iLCIvLyBsb29rIGhlcmUgZm9yIGhlbHAgaHR0cDovL3N2bi5vc2dlby5vcmcvZ3Jhc3MvZ3Jhc3MvYnJhbmNoZXMvcmVsZWFzZWJyYW5jaF82XzQvdmVjdG9yL3Yub3ZlcmxheS9tYWluLmNcbi8vbXVzdCBiZSBhcnJheSBvZiBwb2x5Z29uc1xuXG4vLyBkZXBlbmQgb24ganN0cyBmb3Igbm93IGh0dHBzOi8vZ2l0aHViLmNvbS9iam9ybmhhcnJ0ZWxsL2pzdHMvYmxvYi9tYXN0ZXIvZXhhbXBsZXMvb3ZlcmxheS5odG1sXG5cbnZhciBqc3RzID0gcmVxdWlyZSgnanN0cycpO1xuXG4vKipcbiAqIFRha2VzIHR3byB7QGxpbmsgUG9seWdvbnxwb2x5Z29uc30gYW5kIHJldHVybnMgYSBjb21iaW5lZCBwb2x5Z29uLiBJZiB0aGUgaW5wdXQgcG9seWdvbnMgYXJlIG5vdCBjb250aWd1b3VzLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgYSB7QGxpbmsgTXVsdGlQb2x5Z29ufSBmZWF0dXJlLlxuICpcbiAqIEBuYW1lIHVuaW9uXG4gKiBAcGFyYW0ge0ZlYXR1cmU8UG9seWdvbj59IHBvbHkxIGlucHV0IHBvbHlnb25cbiAqIEBwYXJhbSB7RmVhdHVyZTxQb2x5Z29uPn0gcG9seTIgYW5vdGhlciBpbnB1dCBwb2x5Z29uXG4gKiBAcmV0dXJuIHtGZWF0dXJlPChQb2x5Z29ufE11bHRpUG9seWdvbik+fSBhIGNvbWJpbmVkIHtAbGluayBQb2x5Z29ufSBvciB7QGxpbmsgTXVsdGlQb2x5Z29ufSBmZWF0dXJlXG4gKiBAZXhhbXBsZVxuICogdmFyIHBvbHkxID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgIFwicHJvcGVydGllc1wiOiB7XG4gKiAgICAgXCJmaWxsXCI6IFwiIzBmMFwiXG4gKiAgIH0sXG4gKiAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICBcImNvb3JkaW5hdGVzXCI6IFtbXG4gKiAgICAgICBbLTgyLjU3NDc4NywgMzUuNTk0MDg3XSxcbiAqICAgICAgIFstODIuNTc0Nzg3LCAzNS42MTU1ODFdLFxuICogICAgICAgWy04Mi41NDUyNjEsIDM1LjYxNTU4MV0sXG4gKiAgICAgICBbLTgyLjU0NTI2MSwgMzUuNTk0MDg3XSxcbiAqICAgICAgIFstODIuNTc0Nzg3LCAzNS41OTQwODddXG4gKiAgICAgXV1cbiAqICAgfVxuICogfTtcbiAqIHZhciBwb2x5MiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICBcInByb3BlcnRpZXNcIjoge1xuICogICAgIFwiZmlsbFwiOiBcIiMwMGZcIlxuICogICB9LFxuICogICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICBcInR5cGVcIjogXCJQb2x5Z29uXCIsXG4gKiAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgWy04Mi41NjAwMjQsIDM1LjU4NTE1M10sXG4gKiAgICAgICBbLTgyLjU2MDAyNCwgMzUuNjAyNjAyXSxcbiAqICAgICAgIFstODIuNTI5NjQsIDM1LjYwMjYwMl0sXG4gKiAgICAgICBbLTgyLjUyOTY0LCAzNS41ODUxNTNdLFxuICogICAgICAgWy04Mi41NjAwMjQsIDM1LjU4NTE1M11cbiAqICAgICBdXVxuICogICB9XG4gKiB9O1xuICogdmFyIHBvbHlnb25zID0ge1xuICogICBcInR5cGVcIjogXCJGZWF0dXJlQ29sbGVjdGlvblwiLFxuICogICBcImZlYXR1cmVzXCI6IFtwb2x5MSwgcG9seTJdXG4gKiB9O1xuICpcbiAqIHZhciB1bmlvbiA9IHR1cmYudW5pb24ocG9seTEsIHBvbHkyKTtcbiAqXG4gKiAvLz1wb2x5Z29uc1xuICpcbiAqIC8vPXVuaW9uXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHBvbHkxLCBwb2x5Mikge1xuICAgIHZhciByZWFkZXIgPSBuZXcganN0cy5pby5HZW9KU09OUmVhZGVyKCk7XG4gICAgdmFyIGEgPSByZWFkZXIucmVhZChKU09OLnN0cmluZ2lmeShwb2x5MS5nZW9tZXRyeSkpO1xuICAgIHZhciBiID0gcmVhZGVyLnJlYWQoSlNPTi5zdHJpbmdpZnkocG9seTIuZ2VvbWV0cnkpKTtcbiAgICB2YXIgdW5pb24gPSBhLnVuaW9uKGIpO1xuICAgIHZhciB3cml0ZXIgPSBuZXcganN0cy5pby5HZW9KU09OV3JpdGVyKCk7XG5cbiAgICB1bmlvbiA9IHdyaXRlci53cml0ZSh1bmlvbik7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogJ0ZlYXR1cmUnLFxuICAgICAgICBnZW9tZXRyeTogdW5pb24sXG4gICAgICAgIHByb3BlcnRpZXM6IHBvbHkxLnByb3BlcnRpZXNcbiAgICB9O1xufTtcbiIsInZhciBpbnNpZGUgPSByZXF1aXJlKCd0dXJmLWluc2lkZScpO1xudmFyIGZlYXR1cmVDb2xsZWN0aW9uID0gcmVxdWlyZSgndHVyZi1oZWxwZXJzJykuZmVhdHVyZUNvbGxlY3Rpb247XG5cbi8qKlxuICogVGFrZXMgYSBzZXQgb2Yge0BsaW5rIFBvaW50fHBvaW50c30gYW5kIGEgc2V0IG9mIHtAbGluayBQb2x5Z29ufHBvbHlnb25zfSBhbmQgcmV0dXJucyB0aGUgcG9pbnRzIHRoYXQgZmFsbCB3aXRoaW4gdGhlIHBvbHlnb25zLlxuICpcbiAqIEBuYW1lIHdpdGhpblxuICogQHBhcmFtIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyBpbnB1dCBwb2ludHNcbiAqIEBwYXJhbSB7RmVhdHVyZUNvbGxlY3Rpb248UG9seWdvbj59IHBvbHlnb25zIGlucHV0IHBvbHlnb25zXG4gKiBAcmV0dXJuIHtGZWF0dXJlQ29sbGVjdGlvbjxQb2ludD59IHBvaW50cyB0aGF0IGxhbmQgd2l0aGluIGF0IGxlYXN0IG9uZSBwb2x5Z29uXG4gKiBAZXhhbXBsZVxuICogdmFyIHNlYXJjaFdpdGhpbiA9IHtcbiAqICAgXCJ0eXBlXCI6IFwiRmVhdHVyZUNvbGxlY3Rpb25cIixcbiAqICAgXCJmZWF0dXJlc1wiOiBbXG4gKiAgICAge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvbHlnb25cIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbW1xuICogICAgICAgICAgIFstNDYuNjUzLC0yMy41NDNdLFxuICogICAgICAgICAgIFstNDYuNjM0LC0yMy41MzQ2XSxcbiAqICAgICAgICAgICBbLTQ2LjYxMywtMjMuNTQzXSxcbiAqICAgICAgICAgICBbLTQ2LjYxNCwtMjMuNTU5XSxcbiAqICAgICAgICAgICBbLTQ2LjYzMSwtMjMuNTY3XSxcbiAqICAgICAgICAgICBbLTQ2LjY1MywtMjMuNTYwXSxcbiAqICAgICAgICAgICBbLTQ2LjY1MywtMjMuNTQzXVxuICogICAgICAgICBdXVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqIHZhciBwb2ludHMgPSB7XG4gKiAgIFwidHlwZVwiOiBcIkZlYXR1cmVDb2xsZWN0aW9uXCIsXG4gKiAgIFwiZmVhdHVyZXNcIjogW1xuICogICAgIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNDYuNjMxOCwgLTIzLjU1MjNdXG4gKiAgICAgICB9XG4gKiAgICAgfSwge1xuICogICAgICAgXCJ0eXBlXCI6IFwiRmVhdHVyZVwiLFxuICogICAgICAgXCJwcm9wZXJ0aWVzXCI6IHt9LFxuICogICAgICAgXCJnZW9tZXRyeVwiOiB7XG4gKiAgICAgICAgIFwidHlwZVwiOiBcIlBvaW50XCIsXG4gKiAgICAgICAgIFwiY29vcmRpbmF0ZXNcIjogWy00Ni42MjQ2LCAtMjMuNTMyNV1cbiAqICAgICAgIH1cbiAqICAgICB9LCB7XG4gKiAgICAgICBcInR5cGVcIjogXCJGZWF0dXJlXCIsXG4gKiAgICAgICBcInByb3BlcnRpZXNcIjoge30sXG4gKiAgICAgICBcImdlb21ldHJ5XCI6IHtcbiAqICAgICAgICAgXCJ0eXBlXCI6IFwiUG9pbnRcIixcbiAqICAgICAgICAgXCJjb29yZGluYXRlc1wiOiBbLTQ2LjYwNjIsIC0yMy41NTEzXVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNDYuNjYzLCAtMjMuNTU0XVxuICogICAgICAgfVxuICogICAgIH0sIHtcbiAqICAgICAgIFwidHlwZVwiOiBcIkZlYXR1cmVcIixcbiAqICAgICAgIFwicHJvcGVydGllc1wiOiB7fSxcbiAqICAgICAgIFwiZ2VvbWV0cnlcIjoge1xuICogICAgICAgICBcInR5cGVcIjogXCJQb2ludFwiLFxuICogICAgICAgICBcImNvb3JkaW5hdGVzXCI6IFstNDYuNjQzLCAtMjMuNTU3XVxuICogICAgICAgfVxuICogICAgIH1cbiAqICAgXVxuICogfTtcbiAqXG4gKiB2YXIgcHRzV2l0aGluID0gdHVyZi53aXRoaW4ocG9pbnRzLCBzZWFyY2hXaXRoaW4pO1xuICpcbiAqIC8vPXBvaW50c1xuICpcbiAqIC8vPXNlYXJjaFdpdGhpblxuICpcbiAqIC8vPXB0c1dpdGhpblxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwb2ludHMsIHBvbHlnb25zKSB7XG4gICAgdmFyIHBvaW50c1dpdGhpbiA9IGZlYXR1cmVDb2xsZWN0aW9uKFtdKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBvbHlnb25zLmZlYXR1cmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgcG9pbnRzLmZlYXR1cmVzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICB2YXIgaXNJbnNpZGUgPSBpbnNpZGUocG9pbnRzLmZlYXR1cmVzW2pdLCBwb2x5Z29ucy5mZWF0dXJlc1tpXSk7XG4gICAgICAgICAgICBpZiAoaXNJbnNpZGUpIHtcbiAgICAgICAgICAgICAgICBwb2ludHNXaXRoaW4uZmVhdHVyZXMucHVzaChwb2ludHMuZmVhdHVyZXNbal0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwb2ludHNXaXRoaW47XG59O1xuIiwiLyplc2xpbnQgZ2xvYmFsLXJlcXVpcmU6IDAqL1xuXG4vKipcbiAqIFR1cmYgaXMgYSBtb2R1bGFyIGdlb3NwYXRpYWwgYW5hbHlzaXMgZW5naW5lIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdC4gSXQgcGVyZm9ybXMgZ2Vvc3BhdGlhbFxuICogcHJvY2Vzc2luZyB0YXNrcyB3aXRoIEdlb0pTT04gZGF0YSBhbmQgY2FuIGJlIHJ1biBvbiBhIHNlcnZlciBvciBpbiBhIGJyb3dzZXIuXG4gKlxuICogQG1vZHVsZSB0dXJmXG4gKiBAc3VtbWFyeSBHZW9zcGF0aWFsIGFuYWx5c2lzIGZvciBKYXZhU2NyaXB0XG4gKi9cbm1vZHVsZS5leHBvcnRzID0ge1xuICAgIGlzb2xpbmVzOiByZXF1aXJlKCd0dXJmLWlzb2xpbmVzJyksXG4gICAgY29udmV4OiByZXF1aXJlKCd0dXJmLWNvbnZleCcpLFxuICAgIHdpdGhpbjogcmVxdWlyZSgndHVyZi13aXRoaW4nKSxcbiAgICBjb25jYXZlOiByZXF1aXJlKCd0dXJmLWNvbmNhdmUnKSxcbiAgICBkaWZmZXJlbmNlOiByZXF1aXJlKCd0dXJmLWRpZmZlcmVuY2UnKSxcbiAgICBjb2xsZWN0OiByZXF1aXJlKCd0dXJmLWNvbGxlY3QnKSxcbiAgICBmbGlwOiByZXF1aXJlKCd0dXJmLWZsaXAnKSxcbiAgICBzaW1wbGlmeTogcmVxdWlyZSgndHVyZi1zaW1wbGlmeScpLFxuICAgIGJlemllcjogcmVxdWlyZSgndHVyZi1iZXppZXInKSxcbiAgICB0YWc6IHJlcXVpcmUoJ3R1cmYtdGFnJyksXG4gICAgc2FtcGxlOiByZXF1aXJlKCd0dXJmLXNhbXBsZScpLFxuICAgIGVudmVsb3BlOiByZXF1aXJlKCd0dXJmLWVudmVsb3BlJyksXG4gICAgc3F1YXJlOiByZXF1aXJlKCd0dXJmLXNxdWFyZScpLFxuICAgIG1pZHBvaW50OiByZXF1aXJlKCd0dXJmLW1pZHBvaW50JyksXG4gICAgYnVmZmVyOiByZXF1aXJlKCd0dXJmLWJ1ZmZlcicpLFxuICAgIGNlbnRlcjogcmVxdWlyZSgndHVyZi1jZW50ZXInKSxcbiAgICBjZW50cm9pZDogcmVxdWlyZSgndHVyZi1jZW50cm9pZCcpLFxuICAgIGNvbWJpbmU6IHJlcXVpcmUoJ3R1cmYtY29tYmluZScpLFxuICAgIGRpc3RhbmNlOiByZXF1aXJlKCd0dXJmLWRpc3RhbmNlJyksXG4gICAgZXhwbG9kZTogcmVxdWlyZSgndHVyZi1leHBsb2RlJyksXG4gICAgYmJveDogcmVxdWlyZSgndHVyZi1iYm94JyksXG4gICAgdGVzc2VsYXRlOiByZXF1aXJlKCd0dXJmLXRlc3NlbGF0ZScpLFxuICAgIGJib3hQb2x5Z29uOiByZXF1aXJlKCd0dXJmLWJib3gtcG9seWdvbicpLFxuICAgIGluc2lkZTogcmVxdWlyZSgndHVyZi1pbnNpZGUnKSxcbiAgICBpbnRlcnNlY3Q6IHJlcXVpcmUoJ3R1cmYtaW50ZXJzZWN0JyksXG4gICAgbmVhcmVzdDogcmVxdWlyZSgndHVyZi1uZWFyZXN0JyksXG4gICAgcGxhbmVwb2ludDogcmVxdWlyZSgndHVyZi1wbGFuZXBvaW50JyksXG4gICAgcmFuZG9tOiByZXF1aXJlKCd0dXJmLXJhbmRvbScpLFxuICAgIHRpbjogcmVxdWlyZSgndHVyZi10aW4nKSxcbiAgICB1bmlvbjogcmVxdWlyZSgndHVyZi11bmlvbicpLFxuICAgIGJlYXJpbmc6IHJlcXVpcmUoJ3R1cmYtYmVhcmluZycpLFxuICAgIGRlc3RpbmF0aW9uOiByZXF1aXJlKCd0dXJmLWRlc3RpbmF0aW9uJyksXG4gICAga2lua3M6IHJlcXVpcmUoJ3R1cmYta2lua3MnKSxcbiAgICBwb2ludE9uU3VyZmFjZTogcmVxdWlyZSgndHVyZi1wb2ludC1vbi1zdXJmYWNlJyksXG4gICAgYXJlYTogcmVxdWlyZSgndHVyZi1hcmVhJyksXG4gICAgYWxvbmc6IHJlcXVpcmUoJ3R1cmYtYWxvbmcnKSxcbiAgICBsaW5lRGlzdGFuY2U6IHJlcXVpcmUoJ3R1cmYtbGluZS1kaXN0YW5jZScpLFxuICAgIGxpbmVTbGljZTogcmVxdWlyZSgndHVyZi1saW5lLXNsaWNlJyksXG4gICAgcG9pbnRPbkxpbmU6IHJlcXVpcmUoJ3R1cmYtcG9pbnQtb24tbGluZScpLFxuICAgIHBvaW50R3JpZDogcmVxdWlyZSgndHVyZi1wb2ludC1ncmlkJyksXG4gICAgc3F1YXJlR3JpZDogcmVxdWlyZSgndHVyZi1zcXVhcmUtZ3JpZCcpLFxuICAgIHRyaWFuZ2xlR3JpZDogcmVxdWlyZSgndHVyZi10cmlhbmdsZS1ncmlkJyksXG4gICAgaGV4R3JpZDogcmVxdWlyZSgndHVyZi1oZXgtZ3JpZCcpXG59O1xuXG52YXIgaGVscGVycyA9IHJlcXVpcmUoJ3R1cmYtaGVscGVycycpO1xuXG5tb2R1bGUuZXhwb3J0cy5wb2ludCA9IGhlbHBlcnMucG9pbnQ7XG5tb2R1bGUuZXhwb3J0cy5wb2x5Z29uID0gaGVscGVycy5wb2x5Z29uO1xubW9kdWxlLmV4cG9ydHMubGluZVN0cmluZyA9IGhlbHBlcnMubGluZVN0cmluZztcbm1vZHVsZS5leHBvcnRzLm11bHRpUG9pbnQgPSBoZWxwZXJzLm11bHRpUG9pbnQ7XG5tb2R1bGUuZXhwb3J0cy5tdWx0aVBvbHlnb24gPSBoZWxwZXJzLm11bHRpUG9seWdvbjtcbm1vZHVsZS5leHBvcnRzLm11bHRpTGluZVN0cmluZyA9IGhlbHBlcnMubXVsdGlMaW5lU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMuZmVhdHVyZSA9IGhlbHBlcnMuZmVhdHVyZTtcbm1vZHVsZS5leHBvcnRzLmZlYXR1cmVDb2xsZWN0aW9uID0gaGVscGVycy5mZWF0dXJlQ29sbGVjdGlvbjtcbm1vZHVsZS5leHBvcnRzLmdlb21ldHJ5Q29sbGVjdGlvbiA9IGhlbHBlcnMuZ2VvbWV0cnlDb2xsZWN0aW9uO1xuIiwiXCJ1c2Ugc3RyaWN0XCJcblxubW9kdWxlLmV4cG9ydHMgPSB0d29Qcm9kdWN0XG5cbnZhciBTUExJVFRFUiA9ICsoTWF0aC5wb3coMiwgMjcpICsgMS4wKVxuXG5mdW5jdGlvbiB0d29Qcm9kdWN0KGEsIGIsIHJlc3VsdCkge1xuICB2YXIgeCA9IGEgKiBiXG5cbiAgdmFyIGMgPSBTUExJVFRFUiAqIGFcbiAgdmFyIGFiaWcgPSBjIC0gYVxuICB2YXIgYWhpID0gYyAtIGFiaWdcbiAgdmFyIGFsbyA9IGEgLSBhaGlcblxuICB2YXIgZCA9IFNQTElUVEVSICogYlxuICB2YXIgYmJpZyA9IGQgLSBiXG4gIHZhciBiaGkgPSBkIC0gYmJpZ1xuICB2YXIgYmxvID0gYiAtIGJoaVxuXG4gIHZhciBlcnIxID0geCAtIChhaGkgKiBiaGkpXG4gIHZhciBlcnIyID0gZXJyMSAtIChhbG8gKiBiaGkpXG4gIHZhciBlcnIzID0gZXJyMiAtIChhaGkgKiBibG8pXG5cbiAgdmFyIHkgPSBhbG8gKiBibG8gLSBlcnIzXG5cbiAgaWYocmVzdWx0KSB7XG4gICAgcmVzdWx0WzBdID0geVxuICAgIHJlc3VsdFsxXSA9IHhcbiAgICByZXR1cm4gcmVzdWx0XG4gIH1cblxuICByZXR1cm4gWyB5LCB4IF1cbn0iLCJcInVzZSBzdHJpY3RcIlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZhc3RUd29TdW1cblxuZnVuY3Rpb24gZmFzdFR3b1N1bShhLCBiLCByZXN1bHQpIHtcblx0dmFyIHggPSBhICsgYlxuXHR2YXIgYnYgPSB4IC0gYVxuXHR2YXIgYXYgPSB4IC0gYnZcblx0dmFyIGJyID0gYiAtIGJ2XG5cdHZhciBhciA9IGEgLSBhdlxuXHRpZihyZXN1bHQpIHtcblx0XHRyZXN1bHRbMF0gPSBhciArIGJyXG5cdFx0cmVzdWx0WzFdID0geFxuXHRcdHJldHVybiByZXN1bHRcblx0fVxuXHRyZXR1cm4gW2FyK2JyLCB4XVxufSIsIlwidXNlIHN0cmljdFwiOyBcInVzZSByZXN0cmljdFwiO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVuaW9uRmluZDtcblxuZnVuY3Rpb24gVW5pb25GaW5kKGNvdW50KSB7XG4gIHRoaXMucm9vdHMgPSBuZXcgQXJyYXkoY291bnQpO1xuICB0aGlzLnJhbmtzID0gbmV3IEFycmF5KGNvdW50KTtcbiAgXG4gIGZvcih2YXIgaT0wOyBpPGNvdW50OyArK2kpIHtcbiAgICB0aGlzLnJvb3RzW2ldID0gaTtcbiAgICB0aGlzLnJhbmtzW2ldID0gMDtcbiAgfVxufVxuXG52YXIgcHJvdG8gPSBVbmlvbkZpbmQucHJvdG90eXBlXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm90bywgXCJsZW5ndGhcIiwge1xuICBcImdldFwiOiBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5yb290cy5sZW5ndGhcbiAgfVxufSlcblxucHJvdG8ubWFrZVNldCA9IGZ1bmN0aW9uKCkge1xuICB2YXIgbiA9IHRoaXMucm9vdHMubGVuZ3RoO1xuICB0aGlzLnJvb3RzLnB1c2gobik7XG4gIHRoaXMucmFua3MucHVzaCgwKTtcbiAgcmV0dXJuIG47XG59XG5cbnByb3RvLmZpbmQgPSBmdW5jdGlvbih4KSB7XG4gIHZhciB4MCA9IHhcbiAgdmFyIHJvb3RzID0gdGhpcy5yb290cztcbiAgd2hpbGUocm9vdHNbeF0gIT09IHgpIHtcbiAgICB4ID0gcm9vdHNbeF1cbiAgfVxuICB3aGlsZShyb290c1t4MF0gIT09IHgpIHtcbiAgICB2YXIgeSA9IHJvb3RzW3gwXVxuICAgIHJvb3RzW3gwXSA9IHhcbiAgICB4MCA9IHlcbiAgfVxuICByZXR1cm4geDtcbn1cblxucHJvdG8ubGluayA9IGZ1bmN0aW9uKHgsIHkpIHtcbiAgdmFyIHhyID0gdGhpcy5maW5kKHgpXG4gICAgLCB5ciA9IHRoaXMuZmluZCh5KTtcbiAgaWYoeHIgPT09IHlyKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciByYW5rcyA9IHRoaXMucmFua3NcbiAgICAsIHJvb3RzID0gdGhpcy5yb290c1xuICAgICwgeGQgICAgPSByYW5rc1t4cl1cbiAgICAsIHlkICAgID0gcmFua3NbeXJdO1xuICBpZih4ZCA8IHlkKSB7XG4gICAgcm9vdHNbeHJdID0geXI7XG4gIH0gZWxzZSBpZih5ZCA8IHhkKSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gIH0gZWxzZSB7XG4gICAgcm9vdHNbeXJdID0geHI7XG4gICAgKytyYW5rc1t4cl07XG4gIH1cbn0iLCIvKipcbiAqIENvbnZlcnQgYXJyYXkgb2YgMTYgYnl0ZSB2YWx1ZXMgdG8gVVVJRCBzdHJpbmcgZm9ybWF0IG9mIHRoZSBmb3JtOlxuICogWFhYWFhYWFgtWFhYWC1YWFhYLVhYWFgtWFhYWFhYWFhYWFhYXG4gKi9cbnZhciBieXRlVG9IZXggPSBbXTtcbmZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcbiAgYnl0ZVRvSGV4W2ldID0gKGkgKyAweDEwMCkudG9TdHJpbmcoMTYpLnN1YnN0cigxKTtcbn1cblxuZnVuY3Rpb24gYnl0ZXNUb1V1aWQoYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBvZmZzZXQgfHwgMDtcbiAgdmFyIGJ0aCA9IGJ5dGVUb0hleDtcbiAgLy8gam9pbiB1c2VkIHRvIGZpeCBtZW1vcnkgaXNzdWUgY2F1c2VkIGJ5IGNvbmNhdGVuYXRpb246IGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMxNzUjYzRcbiAgcmV0dXJuIChbXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSwgJy0nLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV0sICctJyxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLCAnLScsXG4gICAgYnRoW2J1ZltpKytdXSwgYnRoW2J1ZltpKytdXSxcbiAgICBidGhbYnVmW2krK11dLCBidGhbYnVmW2krK11dLFxuICAgIGJ0aFtidWZbaSsrXV0sIGJ0aFtidWZbaSsrXV1cbiAgXSkuam9pbignJyk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnl0ZXNUb1V1aWQ7XG4iLCIvLyBVbmlxdWUgSUQgY3JlYXRpb24gcmVxdWlyZXMgYSBoaWdoIHF1YWxpdHkgcmFuZG9tICMgZ2VuZXJhdG9yLiAgSW4gdGhlXG4vLyBicm93c2VyIHRoaXMgaXMgYSBsaXR0bGUgY29tcGxpY2F0ZWQgZHVlIHRvIHVua25vd24gcXVhbGl0eSBvZiBNYXRoLnJhbmRvbSgpXG4vLyBhbmQgaW5jb25zaXN0ZW50IHN1cHBvcnQgZm9yIHRoZSBgY3J5cHRvYCBBUEkuICBXZSBkbyB0aGUgYmVzdCB3ZSBjYW4gdmlhXG4vLyBmZWF0dXJlLWRldGVjdGlvblxuXG4vLyBnZXRSYW5kb21WYWx1ZXMgbmVlZHMgdG8gYmUgaW52b2tlZCBpbiBhIGNvbnRleHQgd2hlcmUgXCJ0aGlzXCIgaXMgYSBDcnlwdG9cbi8vIGltcGxlbWVudGF0aW9uLiBBbHNvLCBmaW5kIHRoZSBjb21wbGV0ZSBpbXBsZW1lbnRhdGlvbiBvZiBjcnlwdG8gb24gSUUxMS5cbnZhciBnZXRSYW5kb21WYWx1ZXMgPSAodHlwZW9mKGNyeXB0bykgIT0gJ3VuZGVmaW5lZCcgJiYgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyAmJiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzLmJpbmQoY3J5cHRvKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAodHlwZW9mKG1zQ3J5cHRvKSAhPSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygd2luZG93Lm1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PSAnZnVuY3Rpb24nICYmIG1zQ3J5cHRvLmdldFJhbmRvbVZhbHVlcy5iaW5kKG1zQ3J5cHRvKSk7XG5cbmlmIChnZXRSYW5kb21WYWx1ZXMpIHtcbiAgLy8gV0hBVFdHIGNyeXB0byBSTkcgLSBodHRwOi8vd2lraS53aGF0d2cub3JnL3dpa2kvQ3J5cHRvXG4gIHZhciBybmRzOCA9IG5ldyBVaW50OEFycmF5KDE2KTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby11bmRlZlxuXG4gIG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gd2hhdHdnUk5HKCkge1xuICAgIGdldFJhbmRvbVZhbHVlcyhybmRzOCk7XG4gICAgcmV0dXJuIHJuZHM4O1xuICB9O1xufSBlbHNlIHtcbiAgLy8gTWF0aC5yYW5kb20oKS1iYXNlZCAoUk5HKVxuICAvL1xuICAvLyBJZiBhbGwgZWxzZSBmYWlscywgdXNlIE1hdGgucmFuZG9tKCkuICBJdCdzIGZhc3QsIGJ1dCBpcyBvZiB1bnNwZWNpZmllZFxuICAvLyBxdWFsaXR5LlxuICB2YXIgcm5kcyA9IG5ldyBBcnJheSgxNik7XG5cbiAgbW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBtYXRoUk5HKCkge1xuICAgIGZvciAodmFyIGkgPSAwLCByOyBpIDwgMTY7IGkrKykge1xuICAgICAgaWYgKChpICYgMHgwMykgPT09IDApIHIgPSBNYXRoLnJhbmRvbSgpICogMHgxMDAwMDAwMDA7XG4gICAgICBybmRzW2ldID0gciA+Pj4gKChpICYgMHgwMykgPDwgMykgJiAweGZmO1xuICAgIH1cblxuICAgIHJldHVybiBybmRzO1xuICB9O1xufVxuIiwidmFyIHJuZyA9IHJlcXVpcmUoJy4vbGliL3JuZycpO1xudmFyIGJ5dGVzVG9VdWlkID0gcmVxdWlyZSgnLi9saWIvYnl0ZXNUb1V1aWQnKTtcblxuLy8gKipgdjEoKWAgLSBHZW5lcmF0ZSB0aW1lLWJhc2VkIFVVSUQqKlxuLy9cbi8vIEluc3BpcmVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9MaW9zSy9VVUlELmpzXG4vLyBhbmQgaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L3V1aWQuaHRtbFxuXG52YXIgX25vZGVJZDtcbnZhciBfY2xvY2tzZXE7XG5cbi8vIFByZXZpb3VzIHV1aWQgY3JlYXRpb24gdGltZVxudmFyIF9sYXN0TVNlY3MgPSAwO1xudmFyIF9sYXN0TlNlY3MgPSAwO1xuXG4vLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL3V1aWRqcy91dWlkIGZvciBBUEkgZGV0YWlsc1xuZnVuY3Rpb24gdjEob3B0aW9ucywgYnVmLCBvZmZzZXQpIHtcbiAgdmFyIGkgPSBidWYgJiYgb2Zmc2V0IHx8IDA7XG4gIHZhciBiID0gYnVmIHx8IFtdO1xuXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgbm9kZSA9IG9wdGlvbnMubm9kZSB8fCBfbm9kZUlkO1xuICB2YXIgY2xvY2tzZXEgPSBvcHRpb25zLmNsb2Nrc2VxICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmNsb2Nrc2VxIDogX2Nsb2Nrc2VxO1xuXG4gIC8vIG5vZGUgYW5kIGNsb2Nrc2VxIG5lZWQgdG8gYmUgaW5pdGlhbGl6ZWQgdG8gcmFuZG9tIHZhbHVlcyBpZiB0aGV5J3JlIG5vdFxuICAvLyBzcGVjaWZpZWQuICBXZSBkbyB0aGlzIGxhemlseSB0byBtaW5pbWl6ZSBpc3N1ZXMgcmVsYXRlZCB0byBpbnN1ZmZpY2llbnRcbiAgLy8gc3lzdGVtIGVudHJvcHkuICBTZWUgIzE4OVxuICBpZiAobm9kZSA9PSBudWxsIHx8IGNsb2Nrc2VxID09IG51bGwpIHtcbiAgICB2YXIgc2VlZEJ5dGVzID0gcm5nKCk7XG4gICAgaWYgKG5vZGUgPT0gbnVsbCkge1xuICAgICAgLy8gUGVyIDQuNSwgY3JlYXRlIGFuZCA0OC1iaXQgbm9kZSBpZCwgKDQ3IHJhbmRvbSBiaXRzICsgbXVsdGljYXN0IGJpdCA9IDEpXG4gICAgICBub2RlID0gX25vZGVJZCA9IFtcbiAgICAgICAgc2VlZEJ5dGVzWzBdIHwgMHgwMSxcbiAgICAgICAgc2VlZEJ5dGVzWzFdLCBzZWVkQnl0ZXNbMl0sIHNlZWRCeXRlc1szXSwgc2VlZEJ5dGVzWzRdLCBzZWVkQnl0ZXNbNV1cbiAgICAgIF07XG4gICAgfVxuICAgIGlmIChjbG9ja3NlcSA9PSBudWxsKSB7XG4gICAgICAvLyBQZXIgNC4yLjIsIHJhbmRvbWl6ZSAoMTQgYml0KSBjbG9ja3NlcVxuICAgICAgY2xvY2tzZXEgPSBfY2xvY2tzZXEgPSAoc2VlZEJ5dGVzWzZdIDw8IDggfCBzZWVkQnl0ZXNbN10pICYgMHgzZmZmO1xuICAgIH1cbiAgfVxuXG4gIC8vIFVVSUQgdGltZXN0YW1wcyBhcmUgMTAwIG5hbm8tc2Vjb25kIHVuaXRzIHNpbmNlIHRoZSBHcmVnb3JpYW4gZXBvY2gsXG4gIC8vICgxNTgyLTEwLTE1IDAwOjAwKS4gIEpTTnVtYmVycyBhcmVuJ3QgcHJlY2lzZSBlbm91Z2ggZm9yIHRoaXMsIHNvXG4gIC8vIHRpbWUgaXMgaGFuZGxlZCBpbnRlcm5hbGx5IGFzICdtc2VjcycgKGludGVnZXIgbWlsbGlzZWNvbmRzKSBhbmQgJ25zZWNzJ1xuICAvLyAoMTAwLW5hbm9zZWNvbmRzIG9mZnNldCBmcm9tIG1zZWNzKSBzaW5jZSB1bml4IGVwb2NoLCAxOTcwLTAxLTAxIDAwOjAwLlxuICB2YXIgbXNlY3MgPSBvcHRpb25zLm1zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm1zZWNzIDogbmV3IERhdGUoKS5nZXRUaW1lKCk7XG5cbiAgLy8gUGVyIDQuMi4xLjIsIHVzZSBjb3VudCBvZiB1dWlkJ3MgZ2VuZXJhdGVkIGR1cmluZyB0aGUgY3VycmVudCBjbG9ja1xuICAvLyBjeWNsZSB0byBzaW11bGF0ZSBoaWdoZXIgcmVzb2x1dGlvbiBjbG9ja1xuICB2YXIgbnNlY3MgPSBvcHRpb25zLm5zZWNzICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLm5zZWNzIDogX2xhc3ROU2VjcyArIDE7XG5cbiAgLy8gVGltZSBzaW5jZSBsYXN0IHV1aWQgY3JlYXRpb24gKGluIG1zZWNzKVxuICB2YXIgZHQgPSAobXNlY3MgLSBfbGFzdE1TZWNzKSArIChuc2VjcyAtIF9sYXN0TlNlY3MpLzEwMDAwO1xuXG4gIC8vIFBlciA0LjIuMS4yLCBCdW1wIGNsb2Nrc2VxIG9uIGNsb2NrIHJlZ3Jlc3Npb25cbiAgaWYgKGR0IDwgMCAmJiBvcHRpb25zLmNsb2Nrc2VxID09PSB1bmRlZmluZWQpIHtcbiAgICBjbG9ja3NlcSA9IGNsb2Nrc2VxICsgMSAmIDB4M2ZmZjtcbiAgfVxuXG4gIC8vIFJlc2V0IG5zZWNzIGlmIGNsb2NrIHJlZ3Jlc3NlcyAobmV3IGNsb2Nrc2VxKSBvciB3ZSd2ZSBtb3ZlZCBvbnRvIGEgbmV3XG4gIC8vIHRpbWUgaW50ZXJ2YWxcbiAgaWYgKChkdCA8IDAgfHwgbXNlY3MgPiBfbGFzdE1TZWNzKSAmJiBvcHRpb25zLm5zZWNzID09PSB1bmRlZmluZWQpIHtcbiAgICBuc2VjcyA9IDA7XG4gIH1cblxuICAvLyBQZXIgNC4yLjEuMiBUaHJvdyBlcnJvciBpZiB0b28gbWFueSB1dWlkcyBhcmUgcmVxdWVzdGVkXG4gIGlmIChuc2VjcyA+PSAxMDAwMCkge1xuICAgIHRocm93IG5ldyBFcnJvcigndXVpZC52MSgpOiBDYW5cXCd0IGNyZWF0ZSBtb3JlIHRoYW4gMTBNIHV1aWRzL3NlYycpO1xuICB9XG5cbiAgX2xhc3RNU2VjcyA9IG1zZWNzO1xuICBfbGFzdE5TZWNzID0gbnNlY3M7XG4gIF9jbG9ja3NlcSA9IGNsb2Nrc2VxO1xuXG4gIC8vIFBlciA0LjEuNCAtIENvbnZlcnQgZnJvbSB1bml4IGVwb2NoIHRvIEdyZWdvcmlhbiBlcG9jaFxuICBtc2VjcyArPSAxMjIxOTI5MjgwMDAwMDtcblxuICAvLyBgdGltZV9sb3dgXG4gIHZhciB0bCA9ICgobXNlY3MgJiAweGZmZmZmZmYpICogMTAwMDAgKyBuc2VjcykgJSAweDEwMDAwMDAwMDtcbiAgYltpKytdID0gdGwgPj4+IDI0ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDE2ICYgMHhmZjtcbiAgYltpKytdID0gdGwgPj4+IDggJiAweGZmO1xuICBiW2krK10gPSB0bCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfbWlkYFxuICB2YXIgdG1oID0gKG1zZWNzIC8gMHgxMDAwMDAwMDAgKiAxMDAwMCkgJiAweGZmZmZmZmY7XG4gIGJbaSsrXSA9IHRtaCA+Pj4gOCAmIDB4ZmY7XG4gIGJbaSsrXSA9IHRtaCAmIDB4ZmY7XG5cbiAgLy8gYHRpbWVfaGlnaF9hbmRfdmVyc2lvbmBcbiAgYltpKytdID0gdG1oID4+PiAyNCAmIDB4ZiB8IDB4MTA7IC8vIGluY2x1ZGUgdmVyc2lvblxuICBiW2krK10gPSB0bWggPj4+IDE2ICYgMHhmZjtcblxuICAvLyBgY2xvY2tfc2VxX2hpX2FuZF9yZXNlcnZlZGAgKFBlciA0LjIuMiAtIGluY2x1ZGUgdmFyaWFudClcbiAgYltpKytdID0gY2xvY2tzZXEgPj4+IDggfCAweDgwO1xuXG4gIC8vIGBjbG9ja19zZXFfbG93YFxuICBiW2krK10gPSBjbG9ja3NlcSAmIDB4ZmY7XG5cbiAgLy8gYG5vZGVgXG4gIGZvciAodmFyIG4gPSAwOyBuIDwgNjsgKytuKSB7XG4gICAgYltpICsgbl0gPSBub2RlW25dO1xuICB9XG5cbiAgcmV0dXJuIGJ1ZiA/IGJ1ZiA6IGJ5dGVzVG9VdWlkKGIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHYxO1xuIiwibW9kdWxlLmV4cG9ydHMuUkFESVVTID0gNjM3ODEzNztcbm1vZHVsZS5leHBvcnRzLkZMQVRURU5JTkcgPSAxLzI5OC4yNTcyMjM1NjM7XG5tb2R1bGUuZXhwb3J0cy5QT0xBUl9SQURJVVMgPSA2MzU2NzUyLjMxNDI7XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cbmltcG9ydCBFbmdpbmUgZnJvbSAnLi4vZW5naW5lL0VuZ2luZSc7XG5pbXBvcnQgSFRNTDVDYW52YXNLZXlib2FyZEFkYXB0ZXIgZnJvbSAnLi4vaHRtbDUtY2FudmFzL0hUTUw1Q2FudmFzS2V5Ym9hcmRBZGFwdG9yJztcbmltcG9ydCBIVE1MNUNhbnZhc01vdXNlQWRhcHRvciBmcm9tICcuLi9odG1sNS1jYW52YXMvSFRNTDVDYW52YXNNb3VzZUFkYXB0b3InO1xuaW1wb3J0IEhUTUw1Q2FudmFzVmlld3BvcnRBZGFwdG9yIGZyb20gJy4uL2h0bWw1LWNhbnZhcy9IVE1MNUNhbnZhc1ZpZXdwb3J0QWRhcHRvcic7XG5pbXBvcnQgSUFkYXB0ZWRLZXlib2FyZEV2ZW50IGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lBZGFwdGVkS2V5Ym9hcmRFdmVudCc7XG5pbXBvcnQgSUFkYXB0ZWRNb3VzZUV2ZW50IGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lBZGFwdGVkTW91c2VFdmVudCc7XG5pbXBvcnQgSUVuZ2luZSBmcm9tICcuLi9lbmdpbmUvaW50ZXJmYWNlcy9JRW5naW5lJztcbmltcG9ydCBJS2V5Ym9hcmRBZGFwdG9yIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lLZXlib2FyZEFkYXB0b3InO1xuaW1wb3J0IElNb3VzZUFkYXB0b3IgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSU1vdXNlQWRhcHRvcic7XG5pbXBvcnQgSVZpZXdwb3J0QWRhcHRvciBmcm9tICcuLi9lbmdpbmUvaW50ZXJmYWNlcy9JVmlld3BvcnRBZGFwdG9yJztcbmltcG9ydCB7IERpY3QgfSBmcm9tICdmb3VuZGF0aW9uL3R5cGVzJztcbmltcG9ydCBJRW50aXR5IGZyb20gJ2VuZ2luZS9pbnRlcmZhY2VzL0lFbnRpdHknO1xuaW1wb3J0IHsgRXRvciB9IGZyb20gJ2VuZ2luZS90eXBlcyc7XG5pbXBvcnQgU3R5bGVTeXN0ZW0gZnJvbSAnZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9zeXN0ZW1zL1N0eWxlU3lzdGVtJztcbmltcG9ydCBJbWFnZVN5c3RlbSBmcm9tICdmcmFtZXdvcmsvcHJlc2VudGF0aW9uL3N5c3RlbXMvSW1hZ2VTeXN0ZW0nO1xuaW1wb3J0IExhYmVsU3lzdGVtIGZyb20gJ2ZyYW1ld29yay9wcmVzZW50YXRpb24vc3lzdGVtcy9MYWJlbFN5c3RlbSc7XG5pbXBvcnQgQW5pbWF0ZWRJbWFnZVN5c3RlbSBmcm9tICdmcmFtZXdvcmsvcHJlc2VudGF0aW9uL3N5c3RlbXMvQW5pbWF0ZWRJbWFnZVN5c3RlbSc7XG5pbXBvcnQgSW50ZXJhY3RpdmVTeXN0ZW0gZnJvbSAnZnJhbWV3b3JrL2ludGVyYWN0aXZlL0ludGVyYWN0aXZlU3lzdGVtJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgQXBwIHtcblxuICAgIHByaXZhdGUgX192aWV3cG9ydDogSVZpZXdwb3J0QWRhcHRvcjxDYW52YXNJbWFnZVNvdXJjZT47XG4gICAgcHJpdmF0ZSBfX21vdXNlOiBJTW91c2VBZGFwdG9yO1xuICAgIHByaXZhdGUgX19rZXlib2FyZDogSUtleWJvYXJkQWRhcHRvcjtcbiAgICBwcml2YXRlIF9fZW5naW5lOiBJRW5naW5lO1xuXG4gICAgY29uc3RydWN0b3IoeyBjYW52YXMgfTogeyBjYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ICYgRGljdDxhbnk+IH0pIHtcbiAgICAgICAgdGhpcy5fX3ZpZXdwb3J0ID0gbmV3IEhUTUw1Q2FudmFzVmlld3BvcnRBZGFwdG9yKGNhbnZhcyk7XG4gICAgICAgIHRoaXMuX19tb3VzZSA9IG5ldyBIVE1MNUNhbnZhc01vdXNlQWRhcHRvcihjYW52YXMpO1xuICAgICAgICB0aGlzLl9fa2V5Ym9hcmQgPSBuZXcgSFRNTDVDYW52YXNLZXlib2FyZEFkYXB0ZXIoY2FudmFzKTtcbiAgICAgICAgdGhpcy5fX2VuZ2luZSA9IG5ldyBFbmdpbmUodGhpcy5fX3ZpZXdwb3J0KTtcbiAgICAgICAgdGhpcy5fX2luaXRTeXN0ZW1zKCk7XG4gICAgICAgIHRoaXMuX19pbml0SW5wdXRzSGFuZGxlcnMoKTtcbiAgICB9XG5cbiAgICBwdWJsaWMgbG9hZChzcmM6IHN0cmluZyk6IENhbnZhc0ltYWdlU291cmNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX192aWV3cG9ydC5sb2FkKHNyYyk7XG4gICAgfVxuXG4gICAgcHVibGljIGNyZWF0ZTxUIGV4dGVuZHMgSUVudGl0eSwgVEFyZz4oRW50aXR5Q29uc3RydWN0b3I6IEV0b3I8VCwgVEFyZz4sIGRhdGE/OiBUQXJnKTogVCB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZW5naW5lLmVudGl0aWVzLmNyZWF0ZShFbnRpdHlDb25zdHJ1Y3RvciwgZGF0YSk7XG4gICAgfVxuXG4gICAgcHVibGljIHN0YXJ0KCk6IHZvaWQge1xuICAgICAgICBzZXRJbnRlcnZhbCh0aGlzLl9fb25jZS5iaW5kKHRoaXMpLCAxMDAwIC8gMjQwKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9fb25jZSgpOiB2b2lkIHtcbiAgICAgICAgdGhpcy5fX21vdXNlLm9uY2UoKTtcbiAgICAgICAgdGhpcy5fX2tleWJvYXJkLm9uY2UoKTtcbiAgICAgICAgdGhpcy5fX2VuZ2luZS5vbmNlKCk7XG4gICAgICAgIHRoaXMuX192aWV3cG9ydC5yZWZyZXNoKCk7XG4gICAgICAgIHRoaXMuX19lbmdpbmUuZHJhdygpO1xuICAgIH1cblxuICAgIHByaXZhdGUgX19pbml0SW5wdXRzSGFuZGxlcnMoKTogdm9pZCB7XG4gICAgICAgIGNvbnN0IHByb3BhZ2F0ZU1vdXNlSW5wdXQgPSAobW91c2VFdmVudDogSUFkYXB0ZWRNb3VzZUV2ZW50KSA9PiB0aGlzLl9fZW5naW5lLm1vdXNlID0gbW91c2VFdmVudDtcbiAgICAgICAgdGhpcy5fX21vdXNlLmhhbmRsZXIoe1xuICAgICAgICAgICAgbW91c2VlbnRlcjogcHJvcGFnYXRlTW91c2VJbnB1dCxcbiAgICAgICAgICAgIG1vdXNlbW92ZTogcHJvcGFnYXRlTW91c2VJbnB1dCxcbiAgICAgICAgICAgIG1vdXNlbGVhdmU6IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXG4gICAgICAgICAgICBtb3VzZWRvd246IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXG4gICAgICAgICAgICBtb3VzZXVwOiBwcm9wYWdhdGVNb3VzZUlucHV0LFxuICAgICAgICAgICAgY2xpY2s6IHByb3BhZ2F0ZU1vdXNlSW5wdXQsXG4gICAgICAgICAgICBub25lOiBwcm9wYWdhdGVNb3VzZUlucHV0LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgcHJvcGFnYXRlS2V5Ym9hcmRJbnB1dCA9IChrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQpID0+IHRoaXMuX19lbmdpbmUua2V5Ym9hcmQgPSBrZXlib2FyZEV2ZW50O1xuICAgICAgICB0aGlzLl9fa2V5Ym9hcmQuaGFuZGxlcih7XG4gICAgICAgICAgICBrZXlkb3duOiBwcm9wYWdhdGVLZXlib2FyZElucHV0LFxuICAgICAgICAgICAga2V5cHJlc3M6IHByb3BhZ2F0ZUtleWJvYXJkSW5wdXQsXG4gICAgICAgICAgICBrZXl1cDogcHJvcGFnYXRlS2V5Ym9hcmRJbnB1dCxcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfX2luaXRTeXN0ZW1zKCk6IHZvaWQge1xuICAgICAgICBbXG4gICAgICAgICAgICAvLyBJbnRlcmFjdGl2ZVN5c3RlbSxcbiAgICAgICAgICAgIFN0eWxlU3lzdGVtLFxuICAgICAgICAgICAgSW1hZ2VTeXN0ZW0sXG4gICAgICAgICAgICBMYWJlbFN5c3RlbSxcbiAgICAgICAgICAgIEFuaW1hdGVkSW1hZ2VTeXN0ZW0sXG4gICAgICAgIF0uZm9yRWFjaCgoU3lzdGVtQ2xhc3MpID0+IHRoaXMuX19lbmdpbmUuYWRkKFN5c3RlbUNsYXNzKSk7XG4gICAgfVxufVxuIiwiaW1wb3J0IElucHV0VGVybWluYWwgZnJvbSAnLi4vLi4vZGlnaXRhbC1sb2dpYy9lbnRpdGllcy9JbnB1dFRlcm1pbmFsJztcbmltcG9ydCBPdXRwdXRUZXJtaW5hbCBmcm9tICcuLi8uLi9kaWdpdGFsLWxvZ2ljL2VudGl0aWVzL091dHB1dFRlcm1pbmFsJztcbmltcG9ydCBVSUVudGl0eSBmcm9tICcuLi8uLi91aS9hYnN0cmFjdHMvVUlFbnRpdHknO1xuXG5leHBvcnQgZGVmYXVsdCBhYnN0cmFjdCBjbGFzcyBDb250cmFwdGlvbiBleHRlbmRzIFVJRW50aXR5IHtcblxuICBwdWJsaWMgaW5wdXRzOiBJbnB1dFRlcm1pbmFsW10gPSBbXTtcbiAgcHVibGljIG91dHB1dHM6IE91dHB1dFRlcm1pbmFsW10gPSBbXTtcblxuICBwdWJsaWMgYWJzdHJhY3Qgb25jZSgpOiB2b2lkO1xuICBwdWJsaWMgYWJzdHJhY3Qgb2ZmKCk6IHZvaWQ7XG4gIHB1YmxpYyBhYnN0cmFjdCByZXNldCgpOiB2b2lkO1xuXG4gIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcbiAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgIHRoaXMuaW5wdXRzLmZvckVhY2goKGlucHV0KSA9PiBpbnB1dC4kZGVzdHJveSgpKTtcbiAgICB0aGlzLm91dHB1dHMuZm9yRWFjaCgob3V0cHV0KSA9PiBvdXRwdXQuJGRlc3Ryb3koKSk7XG4gIH1cbn1cbiIsImltcG9ydCBJbnB1dFRlcm1pbmFsIGZyb20gJy4uLy4uL2RpZ2l0YWwtbG9naWMvZW50aXRpZXMvSW5wdXRUZXJtaW5hbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFjdHVhdG9yIGV4dGVuZHMgSW5wdXRUZXJtaW5hbCB7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHt9OiB7IGxhYmVsVGV4dDogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgeDogMCwgeTogMCB9LCBhcmd1bWVudHNbMF0pKTtcbiAgfVxufVxuIiwiaW1wb3J0IEFjdHVhdG9yIGZyb20gJy4vQWN0dWF0b3InO1xuaW1wb3J0IENvbnRyYXB0aW9uIGZyb20gJy4uL2Fic3RyYWN0cy9Db250cmFwdGlvbic7XG5pbXBvcnQgSG9yaXpvbnRhbFRocmVhZGVkQXhsZSBmcm9tICcuL0hvcml6b250YWxUaHJlYWRlZEF4bGUnO1xuaW1wb3J0IElQb3NlSW5jcmVtZW50IGZyb20gJy4uL2ludGVyZmFjZXMvSVBvc2VJbmNyZW1lbnQnO1xuaW1wb3J0IE1hY2hpbmVQYXJ0IGZyb20gJy4vYWJzdHJhY3RzL01hY2hpbmVQYXJ0JztcbmltcG9ydCBQb3NlQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuaW1wb3J0IFN0eWxlQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2ZyYW1ld29yay9wcmVzZW50YXRpb24vY29tcG9uZW50cy9TdHlsZUNvbXBvbmVudCc7XG5pbXBvcnQgVG91Y2hBY3RpdmF0b3IgZnJvbSAnLi9Ub3VjaEFjdGl2YXRvcic7XG5pbXBvcnQgVG91Y2hTZW5zb3IgZnJvbSAnLi9Ub3VjaFNlbnNvcic7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIENsYXcgZXh0ZW5kcyBDb250cmFwdGlvbiB7XG5cbiAgcHJpdmF0ZSBfX3dyaXN0OiBNYWNoaW5lUGFydDtcbiAgcHJpdmF0ZSBfX3BhbG06IFRvdWNoQWN0aXZhdG9yO1xuICBwcml2YXRlIF9fbGVmdEh1YjogVG91Y2hTZW5zb3I7XG4gIHByaXZhdGUgX19yaWdodEh1YjogTWFjaGluZVBhcnQ7XG4gIHByaXZhdGUgX19sZWZ0VGhyZWFkOiBIb3Jpem9udGFsVGhyZWFkZWRBeGxlO1xuICBwcml2YXRlIF9fcmlnaHRUaHJlYWQ6IEhvcml6b250YWxUaHJlYWRlZEF4bGU7XG4gIHByaXZhdGUgX19sZWZ0VG9vdGg6IFRvdWNoQWN0aXZhdG9yO1xuICBwcml2YXRlIF9fcmlnaHRUb290aDogVG91Y2hTZW5zb3I7XG4gIHByaXZhdGUgX19vcGVuTW90b3I6IEFjdHVhdG9yO1xuICBwcml2YXRlIF9fY2xvc2VNb3RvcjogQWN0dWF0b3I7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSB9OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pIHtcbiAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xuICAgIHRoaXMuX193cmlzdCA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKE1hY2hpbmVQYXJ0LCB7XG4gICAgICB4LCB5OiB5IC0gMTUsXG4gICAgICBzaGFwZToge1xuICAgICAgICB2ZXJ0aWNlczogW1xuICAgICAgICAgIHsgeDogMTAsIHk6IDUgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogNSB9LFxuICAgICAgICAgIHsgeDogLTIwLCB5OiAtNSB9LFxuICAgICAgICAgIHsgeDogMjAsIHk6IC01IH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuX19wYWxtID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoVG91Y2hBY3RpdmF0b3IsIHtcbiAgICAgIHgsIHk6IHkgKyAxMCxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHZlcnRpY2VzOiBbXG4gICAgICAgICAgeyB4OiAxMCwgeTogMTAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogMTAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXG4gICAgICAgICAgeyB4OiAxMCwgeTogLTIwIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuX19sZWZ0SHViID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcbiAgICAgIHg6IHggLSA1MiwgeTogeSArIDEwLFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IDIsIHk6IDEwIH0sXG4gICAgICAgICAgeyB4OiAtMiwgeTogMTAgfSxcbiAgICAgICAgICB7IHg6IC0yLCB5OiAtMTAgfSxcbiAgICAgICAgICB7IHg6IDIsIHk6IC0xMCB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dDogJ29wZW4tc2Vuc29yJyxcbiAgICB9KTtcbiAgICB0aGlzLl9fcmlnaHRIdWIgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShNYWNoaW5lUGFydCwge1xuICAgICAgeDogeCArIDUyLCB5OiB5ICsgMTAsIHNoYXBlOiB7XG4gICAgICAgIHZlcnRpY2VzOiBbXG4gICAgICAgICAgeyB4OiAyLCB5OiAxMCB9LFxuICAgICAgICAgIHsgeDogLTIsIHk6IDEwIH0sXG4gICAgICAgICAgeyB4OiAtMiwgeTogLTEwIH0sXG4gICAgICAgICAgeyB4OiAyLCB5OiAtMTAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgfSk7XG4gICAgdGhpcy5fX2xlZnRUaHJlYWQgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShIb3Jpem9udGFsVGhyZWFkZWRBeGxlLCB7XG4gICAgICB4OiB4IC0gMzAsIHk6IHkgKyAxMCwgd2lkdGg6IDQwLCBoZWlnaHQ6IDIwLFxuICAgIH0pO1xuICAgIHRoaXMuX19yaWdodFRocmVhZCA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKEhvcml6b250YWxUaHJlYWRlZEF4bGUsIHtcbiAgICAgIHg6IHggKyAzMCwgeTogeSArIDEwLCB3aWR0aDogNDAsIGhlaWdodDogMjAsXG4gICAgfSk7XG4gICAgdGhpcy5fX2xlZnRUb290aCA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKFRvdWNoQWN0aXZhdG9yLCB7XG4gICAgICB4OiB4IC0gNDAsIHk6IHkgKyAxMCwgc2hhcGU6IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IDEwLCB5OiA2MCB9LFxuICAgICAgICAgIHsgeDogLTAsIHk6IDYwIH0sXG4gICAgICAgICAgeyB4OiAtMCwgeTogMjAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogMjAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXG4gICAgICAgICAgeyB4OiAxMCwgeTogLTIwIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuX19sZWZ0VG9vdGguJHBhdGNoKFN0eWxlQ29tcG9uZW50KSh7IHpJbmRleDogMSB9KTtcbiAgICB0aGlzLl9fcmlnaHRUb290aCA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKFRvdWNoU2Vuc29yLCB7XG4gICAgICB4OiB4ICsgNDAsIHk6IHkgKyAxMCwgc2hhcGU6IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IDAsIHk6IDIwIH0sXG4gICAgICAgICAgeyB4OiAwLCB5OiA2MCB9LFxuICAgICAgICAgIHsgeDogLTEwLCB5OiA2MCB9LFxuICAgICAgICAgIHsgeDogLTEwLCB5OiAtMjAgfSxcbiAgICAgICAgICB7IHg6IDEwLCB5OiAtMjAgfSxcbiAgICAgICAgICB7IHg6IDEwLCB5OiAyMCB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dDogJ2Nsb3NlZC1zZW5zb3InLFxuICAgIH0pO1xuICAgIHRoaXMuX19yaWdodFRvb3RoLiRwYXRjaChTdHlsZUNvbXBvbmVudCkoeyB6SW5kZXg6IDEgfSk7XG4gICAgdGhpcy5fX29wZW5Nb3RvciA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKEFjdHVhdG9yLCB7XG4gICAgICBsYWJlbFRleHQ6ICdvcGVuJyxcbiAgICB9KTtcbiAgICB0aGlzLl9fY2xvc2VNb3RvciA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKEFjdHVhdG9yLCB7XG4gICAgICBsYWJlbFRleHQ6ICdjbG9zZScsXG4gICAgfSk7XG4gICAgdGhpcy5pbnB1dHMgPSBbdGhpcy5fX29wZW5Nb3RvciwgdGhpcy5fX2Nsb3NlTW90b3JdO1xuICAgIHRoaXMub3V0cHV0cyA9IFt0aGlzLl9fbGVmdEh1Yi5vdXRwdXQsIHRoaXMuX19yaWdodFRvb3RoLm91dHB1dF07XG4gIH1cblxuICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fX3JpZ2h0VG9vdGguaXNIaWdoICYmIHRoaXMuX19jbG9zZU1vdG9yLmlzSGlnaCkge1xuICAgICAgcmV0dXJuIHRoaXMub2ZmKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fbGVmdEh1Yi5pc0hpZ2ggJiYgdGhpcy5fX29wZW5Nb3Rvci5pc0hpZ2gpIHtcbiAgICAgIHJldHVybiB0aGlzLm9mZigpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX29wZW5Nb3Rvci5pc0hpZ2ggJiYgdGhpcy5fX2Nsb3NlTW90b3IuaXNIaWdoKSB7XG4gICAgICByZXR1cm4gdGhpcy5vZmYoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX19jbG9zZU1vdG9yLmlzSGlnaCkge1xuICAgICAgdGhpcy5fX2xlZnRUaHJlYWQucmlnaHQoKTtcbiAgICAgIHRoaXMuX19yaWdodFRocmVhZC5sZWZ0KCk7XG4gICAgICBjb25zdCBsZWZ0VG9vdGhQb3NlID0gdGhpcy5fX2xlZnRUb290aC4kY29weShQb3NlQ29tcG9uZW50KTtcbiAgICAgIGNvbnN0IHJpZ2h0VG9vdGhQb3NlID0gdGhpcy5fX3JpZ2h0VG9vdGguJGNvcHkoUG9zZUNvbXBvbmVudCk7XG4gICAgICB0aGlzLl9fbGVmdFRvb3RoLiRwYXRjaChQb3NlQ29tcG9uZW50KSh7XG4gICAgICAgIHg6IGxlZnRUb290aFBvc2UueCArIDEsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19yaWdodFRvb3RoLiRwYXRjaChQb3NlQ29tcG9uZW50KSh7XG4gICAgICAgIHg6IHJpZ2h0VG9vdGhQb3NlLnggLSAxLFxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fb3Blbk1vdG9yLmlzSGlnaCkge1xuICAgICAgdGhpcy5fX2xlZnRUaHJlYWQubGVmdCgpO1xuICAgICAgdGhpcy5fX3JpZ2h0VGhyZWFkLnJpZ2h0KCk7XG4gICAgICBjb25zdCBsZWZ0VG9vdGhQb3NlID0gdGhpcy5fX2xlZnRUb290aC4kY29weShQb3NlQ29tcG9uZW50KTtcbiAgICAgIGNvbnN0IHJpZ2h0VG9vdGhQb3NlID0gdGhpcy5fX3JpZ2h0VG9vdGguJGNvcHkoUG9zZUNvbXBvbmVudCk7XG4gICAgICB0aGlzLl9fbGVmdFRvb3RoLiRwYXRjaChQb3NlQ29tcG9uZW50KSh7XG4gICAgICAgIHg6IGxlZnRUb290aFBvc2UueCAtIDEsXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX19yaWdodFRvb3RoLiRwYXRjaChQb3NlQ29tcG9uZW50KSh7XG4gICAgICAgIHg6IHJpZ2h0VG9vdGhQb3NlLnggKyAxLFxuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgcHVibGljIG9mZigpOiB2b2lkIHtcbiAgICB0aGlzLl9fbGVmdFRocmVhZC5vZmYoKTtcbiAgICB0aGlzLl9fcmlnaHRUaHJlYWQub2ZmKCk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy5fX3dyaXN0LnJlc2V0KCk7XG4gICAgdGhpcy5fX3BhbG0ucmVzZXQoKTtcbiAgICB0aGlzLl9fbGVmdEh1Yi5yZXNldCgpO1xuICAgIHRoaXMuX19yaWdodEh1Yi5yZXNldCgpO1xuICAgIHRoaXMuX19sZWZ0VGhyZWFkLnJlc2V0KCk7XG4gICAgdGhpcy5fX3JpZ2h0VGhyZWFkLnJlc2V0KCk7XG4gICAgdGhpcy5fX2xlZnRUb290aC5yZXNldCgpO1xuICAgIHRoaXMuX19sZWZ0VG9vdGgucmVzZXQoKTtcbiAgICB0aGlzLl9fcmlnaHRUb290aC5yZXNldCgpO1xuICB9XG5cbiAgcHVibGljIHN0ZXAocG9zZVN0ZXA6IElQb3NlSW5jcmVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5fX3dyaXN0LnN0ZXAocG9zZVN0ZXApO1xuICAgIHRoaXMuX19wYWxtLnN0ZXAocG9zZVN0ZXApO1xuICAgIHRoaXMuX19sZWZ0SHViLnN0ZXAocG9zZVN0ZXApO1xuICAgIHRoaXMuX19yaWdodEh1Yi5zdGVwKHBvc2VTdGVwKTtcbiAgICB0aGlzLl9fbGVmdFRocmVhZC5zdGVwKHBvc2VTdGVwKTtcbiAgICB0aGlzLl9fcmlnaHRUaHJlYWQuc3RlcChwb3NlU3RlcCk7XG4gICAgdGhpcy5fX2xlZnRUb290aC5zdGVwKHBvc2VTdGVwKTtcbiAgICB0aGlzLl9fcmlnaHRUb290aC5zdGVwKHBvc2VTdGVwKTtcbiAgfVxuXG4gIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcbiAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgIHRoaXMuX193cmlzdC4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19wYWxtLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2xlZnRIdWIuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fcmlnaHRIdWIuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fbGVmdFRocmVhZC4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19yaWdodFRocmVhZC4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19sZWZ0VG9vdGguJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fcmlnaHRUb290aC4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19vcGVuTW90b3IuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fY2xvc2VNb3Rvci4kZGVzdHJveSgpO1xuICB9XG59XG4iLCJpbXBvcnQgSVBvc2VJbmNyZW1lbnQgZnJvbSAnLi4vaW50ZXJmYWNlcy9JUG9zZUluY3JlbWVudCc7XG5pbXBvcnQgTWFjaGluZVBhcnQgZnJvbSAnLi9hYnN0cmFjdHMvTWFjaGluZVBhcnQnO1xuaW1wb3J0IEFuaW1hdGVkSW1hZ2VDb21wb25lbnQgZnJvbSAnZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9jb21wb25lbnRzL0FuaW1hdGlvbkNvbXBvbmVudCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhvcml6b250YWxUaHJlYWRlZEF4bGUgZXh0ZW5kcyBNYWNoaW5lUGFydCB7XG5cbiAgcHJpdmF0ZSBfX3RocmVhZHM6IE1hY2hpbmVQYXJ0W10gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH06IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pIHtcbiAgICBzdXBlcih7IHgsIHkgfSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIEwgPSB3aWR0aCAvIDEwOyBpIDwgTDsgaSsrKSB7XG4gICAgICBjb25zdCB0aHJlYWQgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShNYWNoaW5lUGFydCwge1xuICAgICAgICAgIHg6IHggLSB3aWR0aCAvIDIgKyBpICogMTAgKyA1LFxuICAgICAgICAgIHk6IHksXG4gICAgICB9KTtcbiAgICAgIHRocmVhZC4kYWRkKEFuaW1hdGVkSW1hZ2VDb21wb25lbnQpKHtcbiAgICAgICAgaW1hZ2VzOiBbXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS0xLnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS0yLnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS0zLnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS00LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS01LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS02LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS03LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS04LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS05LnBuZycsXG4gICAgICAgICAgJy4vdGhyZWFkZWQtYXhsZS0xMC5wbmcnLFxuICAgICAgICBdLm1hcCgoc3JjKSA9PiAoeyBzcmMsIHdpZHRoOiAxMCwgaGVpZ2h0LCBvcGFjaXR5OiAxLCB6SW5kZXg6IDAgfSkpLFxuICAgICAgICBmcmFtZTogMCxcbiAgICAgICAgc3BlZWQ6IDEsXG4gICAgICAgIGNvb2xkb3duOiAwLFxuICAgICAgICBpc1BhdXNlZDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX3RocmVhZHMucHVzaCh0aHJlYWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBsZWZ0KCk6IHZvaWQge1xuICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgICAgdGhyZWFkLiRwYXRjaChBbmltYXRlZEltYWdlQ29tcG9uZW50KSh7XG4gICAgICAgIGlzUGF1c2VkOiBmYWxzZSxcbiAgICAgICAgaXNSZXZlcnNlZDogZmFsc2UsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyByaWdodCgpOiB2b2lkIHtcbiAgICB0aGlzLl9fdGhyZWFkcy5mb3JFYWNoKCh0aHJlYWQpID0+IHtcbiAgICAgIHRocmVhZC4kcGF0Y2goQW5pbWF0ZWRJbWFnZUNvbXBvbmVudCkoe1xuICAgICAgICBpc1BhdXNlZDogZmFsc2UsXG4gICAgICAgIGlzUmV2ZXJzZWQ6IHRydWUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBvZmYoKTogdm9pZCB7XG4gICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XG4gICAgICB0aHJlYWQuJHBhdGNoKEFuaW1hdGVkSW1hZ2VDb21wb25lbnQpKHtcbiAgICAgICAgaXNQYXVzZWQ6IHRydWUsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyBzdGVwKHBvc2VTdGVwOiBJUG9zZUluY3JlbWVudCk6IHZvaWQge1xuICAgIHN1cGVyLnN0ZXAocG9zZVN0ZXApO1xuICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgICAgdGhyZWFkLnN0ZXAocG9zZVN0ZXApO1xuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHN1cGVyLnJlc2V0KCk7XG4gICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiB7XG4gICAgICB0aHJlYWQucmVzZXQoKTtcbiAgICB9KTtcbiAgfVxuXG4gIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcbiAgICBzdXBlci4kZGVzdHJveSgpO1xuICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4ge1xuICAgICAgdGhyZWFkLiRkZXN0cm95KCk7XG4gICAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBNYWNoaW5lUGFydCBmcm9tICcuL2Fic3RyYWN0cy9NYWNoaW5lUGFydCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoQWN0aXZhdG9yIGV4dGVuZHMgTWFjaGluZVBhcnQge1xuXG59XG4iLCJpbXBvcnQgTWFjaGluZVBhcnQgZnJvbSAnLi9hYnN0cmFjdHMvTWFjaGluZVBhcnQnO1xuaW1wb3J0IE91dHB1dFRlcm1pbmFsIGZyb20gJy4uLy4uL2RpZ2l0YWwtbG9naWMvZW50aXRpZXMvT3V0cHV0VGVybWluYWwnO1xuaW1wb3J0IFRvdWNoQWN0aXZhdG9yIGZyb20gJy4vVG91Y2hBY3RpdmF0b3InO1xuaW1wb3J0IHsgZW50aXRpZXNUb3VjaCB9IGZyb20gJy4uLy4uLy4uL2ZyYW1ld29yay9oZWxwZXJzL2VudGl0aWVzJztcbmltcG9ydCBJRW50aXR5VGVtcGxhdGUgZnJvbSAnYXBwL0lFbnRpdHlUZW1wbGF0ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFRvdWNoU2Vuc29yIGV4dGVuZHMgTWFjaGluZVBhcnQge1xuXG4gIHB1YmxpYyBvdXRwdXQ6IE91dHB1dFRlcm1pbmFsO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih7IGxhYmVsVGV4dCB9OiBJRW50aXR5VGVtcGxhdGUgJiB7IGxhYmVsVGV4dDogc3RyaW5nIH0pIHtcbiAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xuICAgIHRoaXMub3V0cHV0ID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoT3V0cHV0VGVybWluYWwsIHsgeDogMCwgeTogMCwgbGFiZWxUZXh0IH0pO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0hpZ2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmlzSGlnaDtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNMb3coKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0LmlzTG93O1xuICB9XG5cbiAgcHVibGljIGdldCBpc09mZigpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5vdXRwdXQuaXNPZmY7XG4gIH1cblxuICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcbiAgICBjb25zdCB0YXJnZXQgPSB0aGlzLl8kbWFzdGVyLmZpbmQoVG91Y2hBY3RpdmF0b3IpKChhY3RpdmF0b3IpID0+IHtcbiAgICAgIHJldHVybiBlbnRpdGllc1RvdWNoKHRoaXMsIGFjdGl2YXRvcik7XG4gICAgfSk7XG4gICAgaWYgKHRhcmdldCkge1xuICAgICAgdGhpcy5vdXRwdXQuaGlnaCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm91dHB1dC5sb3coKTtcbiAgICB9XG4gIH1cblxuICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XG4gICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICB0aGlzLm91dHB1dC4kZGVzdHJveSgpO1xuICB9XG59XG4iLCJpbXBvcnQgQW5pbWF0ZWRJbWFnZUNvbXBvbmVudCwgeyBJQW5pbWF0ZWRJbWFnZSB9IGZyb20gJy4uLy4uLy4uL2ZyYW1ld29yay9wcmVzZW50YXRpb24vY29tcG9uZW50cy9BbmltYXRpb25Db21wb25lbnQnO1xuaW1wb3J0IElQb3NlSW5jcmVtZW50IGZyb20gJy4uL2ludGVyZmFjZXMvSVBvc2VJbmNyZW1lbnQnO1xuaW1wb3J0IE1hY2hpbmVQYXJ0IGZyb20gJy4vYWJzdHJhY3RzL01hY2hpbmVQYXJ0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgVmVydGljYWxUaHJlYWRlZEF4bGUgZXh0ZW5kcyBNYWNoaW5lUGFydCB7XG5cbiAgcHJpdmF0ZSBfX3RocmVhZHM6IE1hY2hpbmVQYXJ0W10gPSBbXTtcblxuICBwdWJsaWMgY29uc3RydWN0b3IoeyB4LCB5LCB3aWR0aCwgaGVpZ2h0IH06IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHdpZHRoOiBudW1iZXI7IGhlaWdodDogbnVtYmVyIH0pIHtcbiAgICBzdXBlcih7IHgsIHkgfSk7XG4gICAgZm9yIChsZXQgaSA9IDAsIEwgPSBoZWlnaHQgLyAxMDsgaSA8IEw7IGkrKykge1xuICAgICAgY29uc3QgdGhyZWFkID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoTWFjaGluZVBhcnQsIHtcbiAgICAgICAgeCxcbiAgICAgICAgeTogeSAtIGhlaWdodCAvIDIgKyBpICogMTAgKyA1LFxuICAgICAgfSk7XG4gICAgICB0aHJlYWQuJGFkZChBbmltYXRlZEltYWdlQ29tcG9uZW50KSh7XG4gICAgICAgIGltYWdlczogW1xuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMS5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMi5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMy5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNC5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNS5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNi5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtNy5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtOC5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtOS5wbmcnLFxuICAgICAgICAgICcuL3RocmVhZGVkLWF4bGUtMTAucG5nJyxcbiAgICAgICAgXS5tYXAoKHNyYykgPT4gKHsgc3JjLCB3aWR0aDogMTAsIGhlaWdodDogd2lkdGgsIHJvdGF0ZTogLU1hdGguUEkgLyAyLCBvcGFjaXR5OiAxLCB6SW5kZXg6IDAgfSkpLFxuICAgICAgICBmcmFtZTogMCxcbiAgICAgICAgc3BlZWQ6IDEsXG4gICAgICAgIGNvb2xkb3duOiAwLFxuICAgICAgICBpc1BhdXNlZDogdHJ1ZSxcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fX3RocmVhZHMucHVzaCh0aHJlYWQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyB1cCgpOiB2b2lkIHtcbiAgICB0aGlzLl9fYW5pbWF0ZSh7IGlzUGF1c2VkOiBmYWxzZSwgaXNSZXZlcnNlZDogdHJ1ZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkb3duKCk6IHZvaWQge1xuICAgIHRoaXMuX19hbmltYXRlKHsgaXNQYXVzZWQ6IGZhbHNlLGlzUmV2ZXJzZWQ6IGZhbHNlIH0pO1xuICB9XG5cbiAgcHVibGljIG9mZigpOiB2b2lkIHtcbiAgICB0aGlzLl9fYW5pbWF0ZSh7IGlzUGF1c2VkOiB0cnVlIH0pO1xuICB9XG5cbiAgcHVibGljIHN0ZXAocG9zZVN0ZXA6IElQb3NlSW5jcmVtZW50KTogdm9pZCB7XG4gICAgdGhpcy5fX2FsbCh0aGlzLnN0ZXAubmFtZSwgcG9zZVN0ZXApO1xuICB9XG5cbiAgcHVibGljIHJlc2V0KCk6IHZvaWQge1xuICAgIHRoaXMuX19hbGwodGhpcy5yZXNldC5uYW1lKTtcbiAgfVxuXG4gIHB1YmxpYyAkZGVzdHJveSgpOiB2b2lkIHtcbiAgICB0aGlzLl9fYWxsKHRoaXMuJGRlc3Ryb3kubmFtZSk7XG4gIH1cblxuICBwcml2YXRlIF9fYW5pbWF0ZShzZXR0aW5nczogSUFuaW1hdGVkSW1hZ2UgfCB7fSk6IHZvaWQge1xuICAgIHRoaXMuX190aHJlYWRzLmZvckVhY2goKHRocmVhZCkgPT4gdGhyZWFkLiRwYXRjaChBbmltYXRlZEltYWdlQ29tcG9uZW50KShzZXR0aW5ncykpO1xuICB9XG5cbiAgcHJpdmF0ZSBfX2FsbChtZXRob2ROYW1lOiBzdHJpbmcsIGFyZz86IGFueSk6IHZvaWQge1xuICAgIChNYWNoaW5lUGFydC5wcm90b3R5cGUgYXMgYW55KVttZXRob2ROYW1lXS5jYWxsKHRoaXMsIGFyZyk7XG4gICAgdGhpcy5fX3RocmVhZHMuZm9yRWFjaCgodGhyZWFkKSA9PiAodGhyZWFkIGFzIGFueSlbbWV0aG9kTmFtZV0oYXJnKSk7XG4gIH1cbn1cbiIsImltcG9ydCBJUG9zZUluY3JlbWVudCBmcm9tICcuLi8uLi9pbnRlcmZhY2VzL0lQb3NlSW5jcmVtZW50JztcbmltcG9ydCBQb3NlQ29tcG9uZW50LCB7IElQb3NlIH0gZnJvbSAnLi4vLi4vLi4vLi4vZnJhbWV3b3JrL2dlb21ldHJ5L2NvbXBvbmVudHMvUG9zZUNvbXBvbmVudCc7XG5pbXBvcnQgVUlFbnRpdHkgZnJvbSAnYXBwL3VpL2Fic3RyYWN0cy9VSUVudGl0eSc7XG5pbXBvcnQgSUVudGl0eVRlbXBsYXRlIGZyb20gJ2FwcC9JRW50aXR5VGVtcGxhdGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNYWNoaW5lUGFydCBleHRlbmRzIFVJRW50aXR5IHtcblxuICBwcml2YXRlIF9faW5pdGlhbFBvc2U6IElQb3NlO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZTogSUVudGl0eVRlbXBsYXRlKSB7XG4gICAgc3VwZXIodGVtcGxhdGUpO1xuICAgIHRoaXMuX19pbml0aWFsUG9zZSA9IHRoaXMuJGNvcHkoUG9zZUNvbXBvbmVudCk7XG4gIH1cblxuICBwdWJsaWMgcmVzZXQoKTogdm9pZCB7XG4gICAgdGhpcy4kbXV0YXRlKFBvc2VDb21wb25lbnQpKHRoaXMuX19pbml0aWFsUG9zZSk7XG4gIH1cblxuICBwdWJsaWMgc3RlcChwb3NlU3RlcDogSVBvc2VJbmNyZW1lbnQpOiB2b2lkIHtcbiAgICBjb25zdCBwb3NlID0gdGhpcy4kY29weShQb3NlQ29tcG9uZW50KTtcbiAgICBwb3NlLnggKz0gcG9zZVN0ZXAueCB8fCAwO1xuICAgIHBvc2UueSArPSBwb3NlU3RlcC55IHx8IDA7XG4gICAgcG9zZS5hICs9IHBvc2VTdGVwLmEgfHwgMDtcbiAgICB0aGlzLiRtdXRhdGUoUG9zZUNvbXBvbmVudCkocG9zZSk7XG4gIH1cbn1cbiIsImltcG9ydCB7IElTaGFwZSB9IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1NoYXBlQ29tcG9uZW50JztcbmltcG9ydCBNYWNoaW5lUGFydCBmcm9tICcuL01hY2hpbmVQYXJ0JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTWFjaGluZVRhcmdldCBleHRlbmRzIE1hY2hpbmVQYXJ0IHtcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioe306IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHNoYXBlOiBJU2hhcGUgfSkge1xuICAgIHN1cGVyKGFyZ3VtZW50c1swXSk7XG4gIH1cbn1cbiIsImltcG9ydCBBY3R1YXRvciBmcm9tICcuLi9wYXJ0cy9BY3R1YXRvcic7XG5pbXBvcnQgQ2xhdyBmcm9tICcuLi9wYXJ0cy9DbGF3JztcbmltcG9ydCBDb250cmFwdGlvbiBmcm9tICcuLi9hYnN0cmFjdHMvQ29udHJhcHRpb24nO1xuaW1wb3J0IEhvcml6b250YWxUaHJlYWRlZEF4bGUgZnJvbSAnLi4vcGFydHMvSG9yaXpvbnRhbFRocmVhZGVkQXhsZSc7XG5pbXBvcnQgTWFjaGluZVRhcmdldCBmcm9tICcuLi9wYXJ0cy9hYnN0cmFjdHMvUHJpemUnO1xuaW1wb3J0IFRvdWNoQWN0aXZhdG9yIGZyb20gJy4uL3BhcnRzL1RvdWNoQWN0aXZhdG9yJztcbmltcG9ydCBUb3VjaFNlbnNvciBmcm9tICcuLi9wYXJ0cy9Ub3VjaFNlbnNvcic7XG5pbXBvcnQgVmVydGljYWxUaHJlYWRlZEF4bGUgZnJvbSAnLi4vcGFydHMvVmVydGljYWxUaHJlYWRlZEF4bGUnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUaGVDbGF3IGV4dGVuZHMgQ29udHJhcHRpb24ge1xuXG4gIHByaXZhdGUgX19ob3Jpem9udGFsUmFpbDogSG9yaXpvbnRhbFRocmVhZGVkQXhsZTtcbiAgcHJpdmF0ZSBfX3ZlcnRpY2FsUmFpbDogVmVydGljYWxUaHJlYWRlZEF4bGU7XG4gIHByaXZhdGUgX19jYXJyaWFnZTogVG91Y2hBY3RpdmF0b3I7XG5cbiAgcHJpdmF0ZSBfX2xlZnRNb3RvcjogQWN0dWF0b3I7XG4gIHByaXZhdGUgX19yaWdodE1vdG9yOiBBY3R1YXRvcjtcbiAgcHJpdmF0ZSBfX3RvcE1vdG9yOiBBY3R1YXRvcjtcbiAgcHJpdmF0ZSBfX2JvdHRvbU1vdG9yOiBBY3R1YXRvcjtcblxuICBwcml2YXRlIF9fbGVmdFNlbnNvcjogVG91Y2hTZW5zb3I7XG4gIHByaXZhdGUgX19yaWdodFNlbnNvcjogVG91Y2hTZW5zb3I7XG4gIHByaXZhdGUgX190b3BTZW5zb3I6IFRvdWNoU2Vuc29yO1xuICBwcml2YXRlIF9fYm90dG9tU2Vuc29yOiBUb3VjaFNlbnNvcjtcblxuICBwcml2YXRlIF9fY2xhdzogQ2xhdztcblxuICBwcml2YXRlIF9fcHJpemU6IE1hY2hpbmVUYXJnZXQ7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHsgeCwgeSB9OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pIHtcbiAgICBzdXBlcihhcmd1bWVudHNbMF0pO1xuICAgIHRoaXMuX19ob3Jpem9udGFsUmFpbCA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKEhvcml6b250YWxUaHJlYWRlZEF4bGUsIHsgeCwgeSwgd2lkdGg6IDMwMCwgaGVpZ2h0OiAyMCB9KTtcbiAgICB0aGlzLl9fY2FycmlhZ2UgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShUb3VjaEFjdGl2YXRvciwge1xuICAgICAgeDogeCAtIDEzMCwgeSxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHZlcnRpY2VzOiBbXG4gICAgICAgICAgeyB4OiAyMCwgeTogMzAgfSxcbiAgICAgICAgICB7IHg6IC0yMCwgeTogMzAgfSxcbiAgICAgICAgICB7IHg6IC0yMCwgeTogLTMwIH0sXG4gICAgICAgICAgeyB4OiAyMCwgeTogLTMwIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgICAgc3R5bGU6IHsgY29sb3VyOiAnV0hJVEUnLCBvcGFjaXR5OiAxLCBmaWxsOiAncmdiYSgwLDAsMCwwKScsIHpJbmRleDogMSB9LFxuICAgIH0pO1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShWZXJ0aWNhbFRocmVhZGVkQXhsZSwge1xuICAgICAgeDogeCAtIDEzMCwgeSwgd2lkdGg6IDIwLCBoZWlnaHQ6IDIwMCxcbiAgICB9KTtcbiAgICB0aGlzLl9fbGVmdFNlbnNvciA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKFRvdWNoU2Vuc29yLCB7XG4gICAgICB4OiB4IC0gMTcwLCB5LFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IDIwLCB5OiAyMCB9LFxuICAgICAgICAgIHsgeDogLTIwLCB5OiAyMCB9LFxuICAgICAgICAgIHsgeDogLTIwLCB5OiAtMjAgfSxcbiAgICAgICAgICB7IHg6IDIwLCB5OiAtMjAgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHQ6ICdsZWZ0LXNlbnNvcicsXG4gICAgfSk7XG4gICAgdGhpcy5fX3JpZ2h0U2Vuc29yID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoVG91Y2hTZW5zb3IsIHtcbiAgICAgIHg6IHggKyAxNzAsIHksXG4gICAgICBzaGFwZToge1xuICAgICAgICB2ZXJ0aWNlczogW1xuICAgICAgICAgIHsgeDogMjAsIHk6IDIwIH0sXG4gICAgICAgICAgeyB4OiAtMjAsIHk6IDIwIH0sXG4gICAgICAgICAgeyB4OiAtMjAsIHk6IC0yMCB9LFxuICAgICAgICAgIHsgeDogMjAsIHk6IC0yMCB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dDogJ3JpZ2h0LXNlbnNvcicsXG4gICAgfSk7XG4gICAgdGhpcy5fX3RvcFNlbnNvciA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKFRvdWNoU2Vuc29yLCB7XG4gICAgICB4OiB4IC0gMTMwLCB5OiB5IC0gMTA1LFxuICAgICAgc2hhcGU6IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IDIwLCB5OiA1IH0sXG4gICAgICAgICAgeyB4OiAtMjAsIHk6IDUgfSxcbiAgICAgICAgICB7IHg6IC0yMCwgeTogLTUgfSxcbiAgICAgICAgICB7IHg6IDIwLCB5OiAtNSB9LFxuICAgICAgICBdLFxuICAgICAgfSxcbiAgICAgIGxhYmVsVGV4dDogJ3RvcC1zZW5zb3InLFxuICAgIH0pO1xuICAgIHRoaXMuX19ib3R0b21TZW5zb3IgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShUb3VjaFNlbnNvciwge1xuICAgICAgeDogeCAtIDEzMCwgeTogeSArIDEwNSxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHZlcnRpY2VzOiBbXG4gICAgICAgICAgeyB4OiAyMCwgeTogNSB9LFxuICAgICAgICAgIHsgeDogLTIwLCB5OiA1IH0sXG4gICAgICAgICAgeyB4OiAtMjAsIHk6IC01IH0sXG4gICAgICAgICAgeyB4OiAyMCwgeTogLTUgfSxcbiAgICAgICAgXSxcbiAgICAgIH0sXG4gICAgICBsYWJlbFRleHQ6ICdib3R0b20tc2Vuc29yJyxcbiAgICB9KTtcbiAgICB0aGlzLl9fbGVmdE1vdG9yID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoQWN0dWF0b3IsIHtcbiAgICAgIGxhYmVsVGV4dDogJ21vdmUtbGVmdCcsXG4gICAgfSk7XG4gICAgdGhpcy5fX3JpZ2h0TW90b3IgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShBY3R1YXRvciwge1xuICAgICAgbGFiZWxUZXh0OiAnbW92ZS1yaWdodCcsXG4gICAgfSk7XG4gICAgdGhpcy5fX3RvcE1vdG9yID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoQWN0dWF0b3IsIHtcbiAgICAgIGxhYmVsVGV4dDogJ21vdmUtdXAnLFxuICAgIH0pO1xuICAgIHRoaXMuX19ib3R0b21Nb3RvciA9IHRoaXMuXyRtYXN0ZXIuY3JlYXRlKEFjdHVhdG9yLCB7XG4gICAgICBsYWJlbFRleHQ6ICdtb3ZlLWRvd24nLFxuICAgIH0pO1xuICAgIHRoaXMuX19jbGF3ID0gdGhpcy5fJG1hc3Rlci5jcmVhdGUoQ2xhdywge1xuICAgICAgeDogeCAtIDEzMCwgeTogeSArIDEzMCxcbiAgICB9KTtcbiAgICB0aGlzLl9fcHJpemUgPSB0aGlzLl8kbWFzdGVyLmNyZWF0ZShNYWNoaW5lVGFyZ2V0LCB7XG4gICAgICB4OiB4ICsgMTMwLFxuICAgICAgeTogeSArIDI1MCxcbiAgICAgIHNoYXBlOiB7XG4gICAgICAgIHZlcnRpY2VzOiBbXG4gICAgICAgICAgeyB4OiAxMCwgeTogMjAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogMjAgfSxcbiAgICAgICAgICB7IHg6IC0xMCwgeTogLTIwIH0sXG4gICAgICAgICAgeyB4OiAxMCwgeTogLTIwIH0sXG4gICAgICAgIF0sXG4gICAgICB9LFxuICAgIH0pO1xuICAgIHRoaXMuaW5wdXRzID0gW1xuICAgICAgdGhpcy5fX2xlZnRNb3RvcixcbiAgICAgIHRoaXMuX190b3BNb3RvcixcbiAgICAgIHRoaXMuX19jbGF3LmlucHV0c1swXSxcbiAgICAgIHRoaXMuX19yaWdodE1vdG9yLFxuICAgICAgdGhpcy5fX2JvdHRvbU1vdG9yLFxuICAgICAgdGhpcy5fX2NsYXcuaW5wdXRzWzFdLFxuICAgIF07XG4gICAgdGhpcy5vdXRwdXRzID0gW1xuICAgICAgdGhpcy5fX2xlZnRTZW5zb3Iub3V0cHV0LFxuICAgICAgdGhpcy5fX2JvdHRvbVNlbnNvci5vdXRwdXQsXG4gICAgICB0aGlzLl9fY2xhdy5vdXRwdXRzWzFdLFxuICAgICAgdGhpcy5fX3JpZ2h0U2Vuc29yLm91dHB1dCxcbiAgICAgIHRoaXMuX190b3BTZW5zb3Iub3V0cHV0LFxuICAgICAgdGhpcy5fX2NsYXcub3V0cHV0c1swXSxcbiAgICBdO1xuICB9XG5cbiAgcHVibGljIG9uY2UoKTogdm9pZCB7XG4gICAgdGhpcy5fX3VwZGF0ZUhvcml6b250YWxTdGF0ZSgpO1xuICAgIHRoaXMuX191cGRhdGVWZXJ0aWNhbFN0YXRlKCk7XG4gIH1cblxuICBwdWJsaWMgb2ZmKCk6IHZvaWQge1xuICAgIHRoaXMuX19vZmZYKCk7XG4gICAgdGhpcy5fX29mZlkoKTtcbiAgfVxuXG4gIHB1YmxpYyByZXNldCgpOiB2b2lkIHtcbiAgICB0aGlzLl9faG9yaXpvbnRhbFJhaWwucmVzZXQoKTtcbiAgICB0aGlzLl9fY2FycmlhZ2UucmVzZXQoKTtcbiAgICB0aGlzLl9fdmVydGljYWxSYWlsLnJlc2V0KCk7XG4gICAgdGhpcy5fX2xlZnRTZW5zb3IucmVzZXQoKTtcbiAgICB0aGlzLl9fcmlnaHRTZW5zb3IucmVzZXQoKTtcbiAgICB0aGlzLl9fdG9wU2Vuc29yLnJlc2V0KCk7XG4gICAgdGhpcy5fX2JvdHRvbVNlbnNvci5yZXNldCgpO1xuICAgIHRoaXMuX19jbGF3LnJlc2V0KCk7XG4gIH1cblxuICBwdWJsaWMgJGRlc3Ryb3koKTogdm9pZCB7XG4gICAgc3VwZXIuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9faG9yaXpvbnRhbFJhaWwuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fdmVydGljYWxSYWlsLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2NhcnJpYWdlLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2xlZnRNb3Rvci4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19yaWdodE1vdG9yLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX3RvcE1vdG9yLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2JvdHRvbU1vdG9yLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2xlZnRTZW5zb3IuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fcmlnaHRTZW5zb3IuJGRlc3Ryb3koKTtcbiAgICB0aGlzLl9fdG9wU2Vuc29yLiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX2JvdHRvbVNlbnNvci4kZGVzdHJveSgpO1xuICAgIHRoaXMuX19jbGF3LiRkZXN0cm95KCk7XG4gICAgdGhpcy5fX3ByaXplLiRkZXN0cm95KCk7XG4gIH1cblxuICBwcml2YXRlIF9fdXBkYXRlSG9yaXpvbnRhbFN0YXRlKCk6IHZvaWQge1xuICAgIGlmICh0aGlzLl9fbGVmdE1vdG9yLmlzSGlnaCAmJiB0aGlzLl9fcmlnaHRNb3Rvci5pc0hpZ2gpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fb2ZmWCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2xlZnRNb3Rvci5pc0xvdyAmJiB0aGlzLl9fcmlnaHRNb3Rvci5pc0xvdykge1xuICAgICAgcmV0dXJuIHRoaXMuX19vZmZYKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9fbGVmdE1vdG9yLmlzSGlnaCkge1xuICAgICAgaWYgKHRoaXMuX19sZWZ0U2Vuc29yLmlzSGlnaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29mZlgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fbGVmdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX3JpZ2h0TW90b3IuaXNIaWdoKSB7XG4gICAgICBpZiAodGhpcy5fX3JpZ2h0U2Vuc29yLmlzSGlnaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fX29mZlgoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLl9fcmlnaHQoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX19vZmZYKCk7XG4gIH1cblxuICBwcml2YXRlIF9fdXBkYXRlVmVydGljYWxTdGF0ZSgpOiB2b2lkIHtcbiAgICBpZiAodGhpcy5fX3RvcE1vdG9yLmlzSGlnaCAmJiB0aGlzLl9fYm90dG9tTW90b3IuaXNIaWdoKSB7XG4gICAgICByZXR1cm4gdGhpcy5fX29mZlkoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX190b3BNb3Rvci5pc0xvdyAmJiB0aGlzLl9fYm90dG9tTW90b3IuaXNMb3cpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX3RvcE1vdG9yLmlzSGlnaCkge1xuICAgICAgaWYgKHRoaXMuX19ib3R0b21TZW5zb3IuaXNIaWdoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX191cCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5fX2JvdHRvbU1vdG9yLmlzSGlnaCkge1xuICAgICAgaWYgKHRoaXMuX190b3BTZW5zb3IuaXNIaWdoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuX19kb3duKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fb2ZmWSgpO1xuICB9XG5cbiAgcHJpdmF0ZSBfX2xlZnQoKTogdm9pZCB7XG4gICAgdGhpcy5fX2NhcnJpYWdlLnN0ZXAoeyB4OiAtMSB9KTtcbiAgICB0aGlzLl9fdmVydGljYWxSYWlsLnN0ZXAoeyB4OiAtMSB9KTtcbiAgICB0aGlzLl9fdG9wU2Vuc29yLnN0ZXAoeyB4OiAtMSB9KTtcbiAgICB0aGlzLl9fYm90dG9tU2Vuc29yLnN0ZXAoeyB4OiAtMSB9KTtcbiAgICB0aGlzLl9faG9yaXpvbnRhbFJhaWwubGVmdCgpO1xuICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB4OiAtMSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX19yaWdodCgpOiB2b2lkIHtcbiAgICB0aGlzLl9fY2FycmlhZ2Uuc3RlcCh7IHg6IDEgfSk7XG4gICAgdGhpcy5fX3ZlcnRpY2FsUmFpbC5zdGVwKHsgeDogMSB9KTtcbiAgICB0aGlzLl9fdG9wU2Vuc29yLnN0ZXAoeyB4OiAxIH0pO1xuICAgIHRoaXMuX19ib3R0b21TZW5zb3Iuc3RlcCh7IHg6IDEgfSk7XG4gICAgdGhpcy5fX2hvcml6b250YWxSYWlsLnJpZ2h0KCk7XG4gICAgdGhpcy5fX2NsYXcuc3RlcCh7IHg6IDEgfSk7XG4gIH1cblxuICBwcml2YXRlIF9fdXAoKTogdm9pZCB7XG4gICAgdGhpcy5fX3ZlcnRpY2FsUmFpbC5zdGVwKHsgeTogLTEgfSk7XG4gICAgdGhpcy5fX3RvcFNlbnNvci5zdGVwKHsgeTogLTEgfSk7XG4gICAgdGhpcy5fX2JvdHRvbVNlbnNvci5zdGVwKHsgeTogLTEgfSk7XG4gICAgdGhpcy5fX3ZlcnRpY2FsUmFpbC51cCgpO1xuICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB5OiAtMSB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX19kb3duKCk6IHZvaWQge1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuc3RlcCh7IHk6IDEgfSk7XG4gICAgdGhpcy5fX3RvcFNlbnNvci5zdGVwKHsgeTogMSB9KTtcbiAgICB0aGlzLl9fYm90dG9tU2Vuc29yLnN0ZXAoeyB5OiAxIH0pO1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuZG93bigpO1xuICAgIHRoaXMuX19jbGF3LnN0ZXAoeyB5OiAxIH0pO1xuICB9XG5cbiAgcHJpdmF0ZSBfX29mZlgoKTogdm9pZCB7XG4gICAgdGhpcy5fX2NhcnJpYWdlLnN0ZXAoeyB4OiAwIH0pO1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuc3RlcCh7IHg6IDAgfSk7XG4gICAgdGhpcy5fX3RvcFNlbnNvci5zdGVwKHsgeDogMCB9KTtcbiAgICB0aGlzLl9fYm90dG9tU2Vuc29yLnN0ZXAoeyB4OiAwIH0pO1xuICAgIHRoaXMuX19ob3Jpem9udGFsUmFpbC5vZmYoKTtcbiAgICB0aGlzLl9fY2xhdy5zdGVwKHsgeDogMCB9KTtcbiAgfVxuXG4gIHByaXZhdGUgX19vZmZZKCk6IHZvaWQge1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwuc3RlcCh7IHk6IDAgfSk7XG4gICAgdGhpcy5fX3RvcFNlbnNvci5zdGVwKHsgeTogMCB9KTtcbiAgICB0aGlzLl9fYm90dG9tU2Vuc29yLnN0ZXAoeyB5OiAwIH0pO1xuICAgIHRoaXMuX192ZXJ0aWNhbFJhaWwub2ZmKCk7XG4gICAgdGhpcy5fX2NsYXcuc3RlcCh7IHk6IDAgfSk7XG4gIH1cbn1cbiIsImltcG9ydCBUZXJtaW5hbCBmcm9tICcuL2Fic3RyYWN0cy9UZXJtaW5hbCc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIElucHV0VGVybWluYWwgZXh0ZW5kcyBUZXJtaW5hbCB7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKHt9OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH0pIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHsgc3JjOiAnLi9UZXJtaW5hbF9pbi5wbmcnIH0sIGFyZ3VtZW50c1swXSkpO1xuICB9XG59XG4iLCJpbXBvcnQgVGVybWluYWwgZnJvbSAnLi9hYnN0cmFjdHMvVGVybWluYWwnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBPdXRwdXRUZXJtaW5hbCBleHRlbmRzIFRlcm1pbmFsIHtcblxuICBwdWJsaWMgY29uc3RydWN0b3Ioe306IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IGxhYmVsVGV4dD86IHN0cmluZyB9KSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbih7IHNyYzogJy4vVGVybWluYWxfb3V0LnBuZycgfSwgYXJndW1lbnRzWzBdKSk7XG4gIH1cbn1cbiIsImltcG9ydCBJbWFnZUNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi8uLi9mcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvSW1hZ2VDb21wb25lbnQnO1xuaW1wb3J0IExhYmVsQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uLy4uL2ZyYW1ld29yay9wcmVzZW50YXRpb24vY29tcG9uZW50cy9MYWJlbENvbXBvbmVudCc7XG5pbXBvcnQgeyBTVEFURSB9IGZyb20gJy4uLy4uL2VudW1zL1NUQVRFJztcbmltcG9ydCBVSUVudGl0eSBmcm9tICcuLi8uLi8uLi91aS9hYnN0cmFjdHMvVUlFbnRpdHknO1xuXG5jb25zdCBMQUJFTF9DT0xPVVJfTUFQID0ge1xuICBbU1RBVEUuSElHSF06ICdHUkVFTicsXG4gIFtTVEFURS5MT1ddOiAnUkVEJyxcbiAgW1NUQVRFLk9GRl06ICdXSElURScsXG59O1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBUZXJtaW5hbCBleHRlbmRzIFVJRW50aXR5IHtcblxuICBwcml2YXRlIF9fczogU1RBVEUgPSBTVEFURS5PRkY7XG4gIHByaXZhdGUgX19zcmM6IHN0cmluZztcblxuICBjb25zdHJ1Y3Rvcih7IHgsIHksIHNyYywgbGFiZWxUZXh0IH06IHsgeDogbnVtYmVyOyB5OiBudW1iZXI7IHNyYzogc3RyaW5nOyBsYWJlbFRleHQ/OiBzdHJpbmcgfSkge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oe1xuICAgICAgcG9zZTogeyB4LCB5LCBhOiAwIH0sXG4gICAgICB3aWR0aDogMjAsXG4gICAgICBoZWlnaHQ6IDIwLFxuICAgICAgbGFiZWw6IGxhYmVsVGV4dCA/IHtcbiAgICAgICAgdGV4dDogbGFiZWxUZXh0LFxuICAgICAgICBmb250U2l6ZTogMjAsXG4gICAgICAgIG9mZnNldDogeyB4OiAxNSwgeTogNyB9LFxuICAgICAgICBjb2xvdXI6ICdXSElURScsXG4gICAgICAgIGZpbGw6ICdyZ2JhKDAsMCwwLDApJyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgekluZGV4OiAwLFxuICAgICAgfSA6IHVuZGVmaW5lZCxcbiAgICAgIGltYWdlOiB7XG4gICAgICAgIHNyYyxcbiAgICAgICAgb3BhY2l0eTogMSxcbiAgICAgICAgekluZGV4OiAwLFxuICAgICAgfSxcbiAgICB9LCBhcmd1bWVudHNbMF0pKTtcbiAgICB0aGlzLl9fc3JjID0gc3JjO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0hpZ2goKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX19zID09PSBTVEFURS5ISUdIO1xuICB9XG5cbiAgcHVibGljIGdldCBpc0xvdygpOiBib29sZWFuIHtcbiAgICByZXR1cm4gdGhpcy5fX3MgPT09IFNUQVRFLkxPVztcbiAgfVxuXG4gIHB1YmxpYyBnZXQgaXNPZmYoKTogYm9vbGVhbiB7XG4gICAgcmV0dXJuIHRoaXMuX19zID09PSBTVEFURS5PRkY7XG4gIH1cblxuICBwcml2YXRlIGdldCBfX3N0YXRlKCk6IFNUQVRFIHtcbiAgICByZXR1cm4gdGhpcy5fX3M7XG4gIH1cblxuICBwcml2YXRlIHNldCBfX3N0YXRlKHN0YXRlOiBTVEFURSkge1xuICAgIHRoaXMuX19zID0gc3RhdGU7XG4gICAgdGhpcy4kcGF0Y2goTGFiZWxDb21wb25lbnQpKHtcbiAgICAgIGNvbG91cjogTEFCRUxfQ09MT1VSX01BUFtzdGF0ZV0sXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgaGlnaCgpOiB2b2lkIHtcbiAgICB0aGlzLl9fc3RhdGUgPSBTVEFURS5ISUdIO1xuICB9XG5cbiAgcHVibGljIGxvdygpOiB2b2lkIHtcbiAgICB0aGlzLl9fc3RhdGUgPSBTVEFURS5MT1c7XG4gIH1cblxuICBwdWJsaWMgb2ZmKCk6IHZvaWQge1xuICAgIHRoaXMuX19zdGF0ZSA9IFNUQVRFLk9GRjtcbiAgfVxuXG4gIHB1YmxpYyAkbW91c2VlbnRlcigpOiB2b2lkIHtcbiAgICB0aGlzLiRwYXRjaChJbWFnZUNvbXBvbmVudCkoeyBzcmM6ICcuL1Rlcm1pbmFsX2hvdmVyZWQucG5nJyB9KTtcbiAgfVxuXG4gIHB1YmxpYyAkbW91c2VsZWF2ZSgpOiB2b2lkIHtcbiAgICB0aGlzLiRwYXRjaChJbWFnZUNvbXBvbmVudCkoeyBzcmM6IHRoaXMuX19zcmMgfSk7XG4gIH1cblxuICBwdWJsaWMgJG1vdXNlbW92ZSgpOiB2b2lkIHtcbiAgICAvL1xuICB9XG5cbiAgcHVibGljICRtb3VzZWRvd24oKTogdm9pZCB7XG4gICAgLy9cbiAgfVxuXG4gIHB1YmxpYyAkbW91c2V1cCgpOiB2b2lkIHtcbiAgICAvL1xuICB9XG5cbiAgcHVibGljICRjbGljaygpOiB2b2lkIHtcbiAgICAvL1xuICB9XG5cbn1cbiIsIlxuZXhwb3J0IGVudW0gU1RBVEUge1xuICBISUdILFxuICBMT1csXG4gIE9GRixcbn1cbiIsIi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuaW1wb3J0IEFwcCBmcm9tICcuL0FwcCc7XG5pbXBvcnQgRWRpdG9yVmlldyBmcm9tICcuL3ZpZXdzL0VkaXRvclZpZXcnO1xuaW1wb3J0IFRoZUNsYXcgZnJvbSAnLi9jb250cmFwdGlvbnMvdGhlLWNsYXcvVGhlQ2xhdyc7XG5pbXBvcnQgJCBmcm9tICdqcXVlcnknO1xuaW1wb3J0IEhvcml6b250YWxUaHJlYWRlZEF4bGUgZnJvbSAnLi9jb250cmFwdGlvbnMvcGFydHMvSG9yaXpvbnRhbFRocmVhZGVkQXhsZSc7XG5cbmNvbnN0IGNhbnZhcyA9ICQoJyNhcHAtdGFyZ2V0JykuZ2V0KDApIGFzIEhUTUxDYW52YXNFbGVtZW50ICYgYW55O1xuY2FudmFzLmZvY3VzKCk7XG5jYW52YXMud2lkdGggPSAxMjgwO1xuY2FudmFzLmhlaWdodCA9IDY4MDtcblxuY29uc3QgYXBwID0gbmV3IEFwcCh7IGNhbnZhcyB9KTtcblxuW1xuICAnLi90aHJlYWRlZC1heGxlLTEucG5nJyxcbiAgJy4vdGhyZWFkZWQtYXhsZS0yLnBuZycsXG4gICcuL3RocmVhZGVkLWF4bGUtMy5wbmcnLFxuICAnLi90aHJlYWRlZC1heGxlLTQucG5nJyxcbiAgJy4vdGhyZWFkZWQtYXhsZS01LnBuZycsXG4gICcuL3RocmVhZGVkLWF4bGUtNi5wbmcnLFxuICAnLi90aHJlYWRlZC1heGxlLTcucG5nJyxcbiAgJy4vdGhyZWFkZWQtYXhsZS04LnBuZycsXG4gICcuL3RocmVhZGVkLWF4bGUtOS5wbmcnLFxuICAnLi90aHJlYWRlZC1heGxlLTEwLnBuZycsXG5dLmZvckVhY2goKHNyYykgPT4gYXBwLmxvYWQoc3JjKSk7XG5cbi8vIGFwcC5jcmVhdGUoSG9yaXpvbnRhbFRocmVhZGVkQXhsZSwgeyB4OiAxMDQwLCB5OiAzNDAsIHdpZHRoOiAzMDAsIGhlaWdodDogMjAgfSk7XG5jb25zdCBjbGF3ID0gYXBwLmNyZWF0ZShUaGVDbGF3LCB7IHg6IDEwNDAsIHk6IDM0MCB9KTtcbi8vIGFwcC5jcmVhdGUoRWRpdG9yVmlldywgeyBjb250cmFwdGlvbjogY2xhdyB9KTtcbmFwcC5zdGFydCgpO1xuXG5cbiIsImltcG9ydCBJbWFnZUNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9mcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvSW1hZ2VDb21wb25lbnQnO1xuaW1wb3J0IFNoYXBlQ29tcG9uZW50IGZyb20gJy4uLy4uLy4uL2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1NoYXBlQ29tcG9uZW50JztcbmltcG9ydCBTdHlsZUNvbXBvbmVudCBmcm9tICcuLi8uLi8uLi9mcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvU3R5bGVDb21wb25lbnQnO1xuaW1wb3J0IElFbnRpdHlUZW1wbGF0ZSBmcm9tICdhcHAvSUVudGl0eVRlbXBsYXRlJztcbmltcG9ydCBJQWRhcHRlZE1vdXNlRXZlbnQgZnJvbSAnZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRNb3VzZUV2ZW50JztcbmltcG9ydCBJQ29tcG9uZW50IGZyb20gJ2VuZ2luZS9pbnRlcmZhY2VzL0lDb21wb25lbnQnO1xuaW1wb3J0IElFbnRpdHkgZnJvbSAnZW5naW5lL2ludGVyZmFjZXMvSUVudGl0eSc7XG5pbXBvcnQgeyBDdG9yIH0gZnJvbSAnZW5naW5lL3R5cGVzJztcbmltcG9ydCB7IERpY3QgYXMgRGljdCB9IGZyb20gJ2ZvdW5kYXRpb24vdHlwZXMnO1xuaW1wb3J0IFBvc2VDb21wb25lbnQgZnJvbSAnZnJhbWV3b3JrL2dlb21ldHJ5L2NvbXBvbmVudHMvUG9zZUNvbXBvbmVudCc7XG5pbXBvcnQgSW50ZXJhY3RpdmVFbnRpdHkgZnJvbSAnZnJhbWV3b3JrL2ludGVyYWN0aXZlL0ludGVyYWN0aXZlRW50aXR5JztcbmltcG9ydCBMYWJlbENvbXBvbmVudCBmcm9tICdmcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvTGFiZWxDb21wb25lbnQnO1xuaW1wb3J0IElVSUVudGl0eSBmcm9tICcuLi9pbnRlcmZhY2VzL0lVSUVudGl0eSc7XG5cbmNvbnN0IGNvbXBvbmVudEtleU1hcDogRGljdDxDdG9yPElDb21wb25lbnQ8YW55PiwgYW55Pj4gPSB7XG4gIHBvc2U6IFBvc2VDb21wb25lbnQsXG4gIHNoYXBlOiBTaGFwZUNvbXBvbmVudCxcbiAgc3R5bGU6IFN0eWxlQ29tcG9uZW50LFxuICBsYWJlbDogTGFiZWxDb21wb25lbnQsXG4gIGltYWdlOiBJbWFnZUNvbXBvbmVudCxcbn07XG5cbmNvbnN0IGFwcGx5RW50aXR5VGVtcGxhdGVUb0VudGl0eSA9ICh0ZW1wbGF0ZTogSUVudGl0eVRlbXBsYXRlLCBlbnRpdHk6IElFbnRpdHkpOiB2b2lkID0+IHtcbiAgT2JqZWN0LmtleXMoY29tcG9uZW50S2V5TWFwKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICBjb25zdCBkYXRhID0gKHRlbXBsYXRlIGFzIERpY3Q8YW55Pilba2V5XTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZW50aXR5LiRhZGQoY29tcG9uZW50S2V5TWFwW2tleV0pKGRhdGEpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFVJRW50aXR5IGV4dGVuZHMgSW50ZXJhY3RpdmVFbnRpdHkgaW1wbGVtZW50cyBJVUlFbnRpdHkge1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3Rvcih0ZW1wbGF0ZTogSUVudGl0eVRlbXBsYXRlKSB7XG4gICAgc3VwZXIoKTtcbiAgICAodGVtcGxhdGUgYXMgRGljdDxhbnk+KS5wb3NlID0geyB4OiB0ZW1wbGF0ZS54LCB5OiB0ZW1wbGF0ZS55LCBhOiAwIH07XG4gICAgaWYgKCh0ZW1wbGF0ZS53aWR0aCAmJiB0ZW1wbGF0ZS5oZWlnaHQpKSB7XG4gICAgICB0ZW1wbGF0ZS5zaGFwZSA9IHtcbiAgICAgICAgdmVydGljZXM6IFtcbiAgICAgICAgICB7IHg6IHRlbXBsYXRlLndpZHRoIC8gMiwgeTogdGVtcGxhdGUuaGVpZ2h0IC8gMn0sXG4gICAgICAgICAgeyB4OiAtdGVtcGxhdGUud2lkdGggLyAyLCB5OiB0ZW1wbGF0ZS5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7IHg6IC10ZW1wbGF0ZS53aWR0aCAvIDIsIHk6IC10ZW1wbGF0ZS5oZWlnaHQgLyAyfSxcbiAgICAgICAgICB7IHg6IHRlbXBsYXRlLndpZHRoIC8gMiwgeTogLXRlbXBsYXRlLmhlaWdodCAvIDJ9LFxuICAgICAgICBdLFxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRlbXBsYXRlLnNoYXBlKSB7XG4gICAgICB0ZW1wbGF0ZS5zdHlsZSA9IHsgY29sb3VyOiAnV0hJVEUnLCBvcGFjaXR5OiAxLCBmaWxsOiAncmdiYSgwLDAsMCwwKScsIHpJbmRleDogMCB9O1xuICAgIH1cbiAgICBhcHBseUVudGl0eVRlbXBsYXRlVG9FbnRpdHkodGVtcGxhdGUsIHRoaXMpO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gIHB1YmxpYyAkbW91c2Vtb3ZlKGU6IElBZGFwdGVkTW91c2VFdmVudCk6IHZvaWQge1xuICAgIC8vXG4gIH1cblxuICBwdWJsaWMgJG1vdXNlZW50ZXIoZTogSUFkYXB0ZWRNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLy9cbiAgfVxuXG4gIHB1YmxpYyAkbW91c2VsZWF2ZShlOiBJQWRhcHRlZE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvL1xuICB9XG5cbiAgcHVibGljICRtb3VzZWRvd24oZTogSUFkYXB0ZWRNb3VzZUV2ZW50KTogdm9pZCB7XG4gICAgLy9cbiAgfVxuXG4gIHB1YmxpYyAkbW91c2V1cChlOiBJQWRhcHRlZE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvL1xuICB9XG5cbiAgcHVibGljICRjbGljayhlOiBJQWRhcHRlZE1vdXNlRXZlbnQpOiB2b2lkIHtcbiAgICAvL1xuICB9XG4gIC8qIGVzbGludC1lbmFibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG5cbn1cbiIsImltcG9ydCBJQ29tcG9uZW50IGZyb20gJy4vaW50ZXJmYWNlcy9JQ29tcG9uZW50JztcbmltcG9ydCBJQ29tcG9uZW50TWFzdGVyIGZyb20gJy4vaW50ZXJmYWNlcy9JQ29tcG9uZW50TWFzdGVyJztcbmltcG9ydCBJRW50aXR5IGZyb20gJy4vaW50ZXJmYWNlcy9JRW50aXR5JztcbmltcG9ydCBEaWN0aW9uYXJ5IGZyb20gJ2ZvdW5kYXRpb24vY29uY3JldGVzL0RpY3Rpb25hcnknO1xuaW1wb3J0IElEaWN0aW9uYXJ5IGZyb20gJ2ZvdW5kYXRpb24vaW50ZXJmYWNlcy9JRGljdGlvbmFyeSc7XG5pbXBvcnQgeyBDb21wb25lbnRDbGFzcywgQ3RvciB9IGZyb20gJy4vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb25lbnRNYXN0ZXIgaW1wbGVtZW50cyBJQ29tcG9uZW50TWFzdGVyIHtcblxuICBwcml2YXRlIF9fY29tcG9uZW50TWFwOiBJRGljdGlvbmFyeTxJRGljdGlvbmFyeTxJQ29tcG9uZW50PGFueT4+PiA9IG5ldyBEaWN0aW9uYXJ5KCk7XG5cbiAgcHVibGljIGNyZWF0ZTxUIGV4dGVuZHMgSUNvbXBvbmVudDxUQXJnPiwgVEFyZz4oZW50aXR5OiBJRW50aXR5LCBDb21wb25lbnRDb25zdHJ1Y3RvcjogQ3RvcjxULCBUQXJnPiwgZGF0YTogVEFyZyk6IFQge1xuICAgIGxldCBjb2xsZWN0aW9uID0gdGhpcy5fX2NvbXBvbmVudE1hcC5yZWFkKENvbXBvbmVudENvbnN0cnVjdG9yLm5hbWUpO1xuICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgY29sbGVjdGlvbiA9IG5ldyBEaWN0aW9uYXJ5KCk7XG4gICAgICB0aGlzLl9fY29tcG9uZW50TWFwLndyaXRlKHtcbiAgICAgICAga2V5OiBDb21wb25lbnRDb25zdHJ1Y3Rvci5uYW1lLFxuICAgICAgICB2YWx1ZTogY29sbGVjdGlvbixcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBjb21wb25lbnQgPSBuZXcgQ29tcG9uZW50Q29uc3RydWN0b3IoeyBkYXRhLCBlbnRpdHkgfSk7XG4gICAgY29sbGVjdGlvbi53cml0ZSh7XG4gICAgICBrZXk6IGNvbXBvbmVudC5pZCxcbiAgICAgIHZhbHVlOiBjb21wb25lbnQsXG4gICAgfSk7XG4gICAgcmV0dXJuIGNvbXBvbmVudDtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KGNvbXBvbmVudDogSUNvbXBvbmVudDxhbnk+KTogdm9pZCB7XG4gICAgaWYgKCF0aGlzLl9fY29tcG9uZW50TWFwLnJlYWQoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9fY29tcG9uZW50TWFwLnJlYWQoY29tcG9uZW50LmNvbnN0cnVjdG9yLm5hbWUpIS5kZWxldGUoY29tcG9uZW50LmlkKTtcbiAgfVxuXG4gIHB1YmxpYyBmb3JFdmVyeTxUIGV4dGVuZHMgSUNvbXBvbmVudDxUQXJnPiwgVEFyZz4oQ29tcG9uZW50Q2xzOiBDb21wb25lbnRDbGFzczxULCBUQXJnPik6XG4gIChmbjogKGNvbXBvbmVudDogVCkgPT4gdm9pZCkgPT4gdm9pZFxuICB7XG4gICAgY29uc3QgY29sbGVjdGlvbiA9IHRoaXMuX19jb21wb25lbnRNYXAucmVhZChDb21wb25lbnRDbHMubmFtZSk7XG4gICAgcmV0dXJuIGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmZvckVhY2guYmluZChjb2xsZWN0aW9uKSA6ICgpID0+IHVuZGVmaW5lZDtcbiAgfVxuXG59XG4iLCJpbXBvcnQgRW50aXR5TWFzdGVyIGZyb20gJy4vRW50aXR5TWFzdGVyJztcbmltcG9ydCBJQWRhcHRlZEtleWJvYXJkRXZlbnQgZnJvbSAnLi9pbnRlcmZhY2VzL0lBZGFwdGVkS2V5Ym9hcmRFdmVudCc7XG5pbXBvcnQgSUFkYXB0ZWRNb3VzZUV2ZW50IGZyb20gJy4vaW50ZXJmYWNlcy9JQWRhcHRlZE1vdXNlRXZlbnQnO1xuaW1wb3J0IElDb21wb25lbnRNYXN0ZXIgZnJvbSAnLi9pbnRlcmZhY2VzL0lDb21wb25lbnRNYXN0ZXInO1xuaW1wb3J0IElFbmdpbmUgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbmdpbmUnO1xuaW1wb3J0IElFbnRpdHlNYXN0ZXIgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbnRpdHlNYXN0ZXInO1xuaW1wb3J0IElTeXN0ZW0gZnJvbSAnLi9pbnRlcmZhY2VzL0lTeXN0ZW0nO1xuaW1wb3J0IElWaWV3cG9ydEFkYXB0b3IgZnJvbSAnLi9pbnRlcmZhY2VzL0lWaWV3cG9ydEFkYXB0b3InO1xuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSAnZm91bmRhdGlvbi9jb25jcmV0ZXMvRGljdGlvbmFyeSc7XG5pbXBvcnQgSURpY3Rpb25hcnkgZnJvbSAnZm91bmRhdGlvbi9pbnRlcmZhY2VzL0lEaWN0aW9uYXJ5JztcbmltcG9ydCB7IFN0b3IgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW5naW5lIGltcGxlbWVudHMgSUVuZ2luZSB7XG5cbiAgcHVibGljIHZpZXdwb3J0OiBJVmlld3BvcnRBZGFwdG9yPGFueT47XG4gIHB1YmxpYyBlbnRpdGllczogSUVudGl0eU1hc3RlcjtcblxuICBwdWJsaWMgbW91c2U6IElBZGFwdGVkTW91c2VFdmVudDtcbiAgcHVibGljIGtleWJvYXJkOiBJQWRhcHRlZEtleWJvYXJkRXZlbnQ7XG5cbiAgcHVibGljIGRlbHRhOiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfX3Q6IERhdGU7XG4gIHByaXZhdGUgX19zeXN0ZW1zOiBJRGljdGlvbmFyeTxJU3lzdGVtPjtcblxuICBjb25zdHJ1Y3Rvcih2aWV3cG9ydDogSVZpZXdwb3J0QWRhcHRvcjxhbnk+KSB7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuZW50aXRpZXMgPSBuZXcgRW50aXR5TWFzdGVyKCk7XG4gICAgdGhpcy5fX3N5c3RlbXMgPSBuZXcgRGljdGlvbmFyeSgpO1xuICAgIHRoaXMuX190ID0gbmV3IERhdGUoKTtcbiAgfVxuXG4gIHB1YmxpYyBnZXQgY29tcG9uZW50cygpOiBJQ29tcG9uZW50TWFzdGVyIHtcbiAgICByZXR1cm4gdGhpcy5lbnRpdGllcy5jb21wb25lbnRNYXN0ZXI7XG4gIH1cblxuICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcbiAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgIHRoaXMuZGVsdGEgPSBub3cuZ2V0VGltZSgpIC0gdGhpcy5fX3QuZ2V0VGltZSgpO1xuICAgIHRoaXMuX190ID0gbm93O1xuICAgIHRoaXMuX19zeXN0ZW1zLmZvckVhY2goKHN5c3RlbTogSVN5c3RlbSkgPT4gc3lzdGVtLm9uY2UoKSk7XG4gICAgdGhpcy5lbnRpdGllcy5vbmNlKCk7XG4gIH1cblxuICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcbiAgICB0aGlzLl9fc3lzdGVtcy5mb3JFYWNoKChzeXN0ZW06IElTeXN0ZW0pID0+IHN5c3RlbS5kcmF3KCkpO1xuICAgIHRoaXMudmlld3BvcnQub25jZSgpO1xuICB9XG5cbiAgcHVibGljIGFkZDxUIGV4dGVuZHMgSVN5c3RlbT4oU3lzdGVtQ2xhc3M6IFN0b3I8VD4pOiB2b2lkIHtcbiAgICB0aGlzLl9fc3lzdGVtcy53cml0ZSh7XG4gICAgICBrZXk6IFN5c3RlbUNsYXNzLm5hbWUsXG4gICAgICB2YWx1ZTogbmV3IFN5c3RlbUNsYXNzKHRoaXMpLFxuICAgIH0pO1xuICB9XG5cbiAgcHVibGljIHJlbW92ZTxUIGV4dGVuZHMgSVN5c3RlbT4oU3lzdGVtQ2xhc3M6IFN0b3I8VD4pOiB2b2lkIHtcbiAgICB0aGlzLl9fc3lzdGVtcy5kZWxldGUoU3lzdGVtQ2xhc3MubmFtZSk7XG4gIH1cblxufVxuIiwiaW1wb3J0IElDb21wb25lbnQgZnJvbSAnLi9pbnRlcmZhY2VzL0lDb21wb25lbnQnO1xuaW1wb3J0IElFbnRpdHkgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbnRpdHknO1xuaW1wb3J0IElFbnRpdHlNYXN0ZXIgZnJvbSAnLi9pbnRlcmZhY2VzL0lFbnRpdHlNYXN0ZXInO1xuaW1wb3J0IFVuaXF1ZSBmcm9tICdmb3VuZGF0aW9uL2Fic3RyYWN0cy9VbmlxdWUnO1xuaW1wb3J0IERpY3Rpb25hcnkgZnJvbSAnZm91bmRhdGlvbi9jb25jcmV0ZXMvRGljdGlvbmFyeSc7XG5pbXBvcnQgSURpY3Rpb25hcnkgZnJvbSAnZm91bmRhdGlvbi9pbnRlcmZhY2VzL0lEaWN0aW9uYXJ5JztcbmltcG9ydCB7IEN0b3IgfSBmcm9tICcuL3R5cGVzJztcblxuZXhwb3J0IGNvbnN0IElPQzogeyBtYXN0ZXI/OiBJRW50aXR5TWFzdGVyIH0gPSB7XG4gIG1hc3RlcjogdW5kZWZpbmVkLFxufTtcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5IGV4dGVuZHMgVW5pcXVlIGltcGxlbWVudHMgSUVudGl0eSB7XG5cbiAgcHJpdmF0ZSBfX21hc3RlcjogSUVudGl0eU1hc3RlcjtcblxuICBwcml2YXRlIF9fY29tcG9uZW50czogSURpY3Rpb25hcnk8SUNvbXBvbmVudDxhbnk+PiA9IG5ldyBEaWN0aW9uYXJ5KCk7XG5cbiAgcHVibGljIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fX21hc3Rlcl9fKElPQy5tYXN0ZXIhKTtcbiAgfVxuXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbmFtaW5nLWNvbnZlbnRpb25cbiAgcHJpdmF0ZSBfX21hc3Rlcl9fKG1hc3RlcjogSUVudGl0eU1hc3Rlcik6IHZvaWQge1xuICAgIHRoaXMuX19tYXN0ZXIgPSBtYXN0ZXI7XG4gIH1cblxuICBwcm90ZWN0ZWQgZ2V0IF8kbWFzdGVyKCk6IElFbnRpdHlNYXN0ZXIge1xuICAgIHJldHVybiB0aGlzLl9fbWFzdGVyO1xuICB9XG5cbiAgcHVibGljICRkZXN0cm95KCk6IHZvaWQge1xuICAgIHJldHVybiB0aGlzLl8kbWFzdGVyLmRlc3Ryb3kodGhpcyk7XG4gIH1cblxuICBwdWJsaWMgJGFkZDxUIGV4dGVuZHMgSUNvbXBvbmVudDxUQXJnPiwgVEFyZz4oQ29tcG9uZW50Q2xhc3M6IEN0b3I8VCwgVEFyZz4pOiAoZGF0YTogVEFyZykgPT4gdm9pZCB7XG4gICAgcmV0dXJuIChkYXRhOiBUQXJnKSA9PiB7XG4gICAgICBpZiAoIXRoaXMuX19jb21wb25lbnRzLnJlYWQoQ29tcG9uZW50Q2xhc3MubmFtZSkpIHtcbiAgICAgICAgdGhpcy5fX2NvbXBvbmVudHMud3JpdGUoe1xuICAgICAgICAgIGtleTogQ29tcG9uZW50Q2xhc3MubmFtZSxcbiAgICAgICAgICB2YWx1ZTogdGhpcy5fJG1hc3Rlci5jb21wb25lbnRNYXN0ZXIuY3JlYXRlKHRoaXMsIENvbXBvbmVudENsYXNzLCBkYXRhKSxcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIHB1YmxpYyAkcmVtb3ZlPFQgZXh0ZW5kcyBJQ29tcG9uZW50PFRBcmc+LCBUQXJnPihDb21wb25lbnRDbGFzczogQ3RvcjxULCBUQXJnPik6IHZvaWQge1xuICAgIGlmICghdGhpcy5fX2NvbXBvbmVudHMucmVhZChDb21wb25lbnRDbGFzcy5uYW1lKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl8kbWFzdGVyLmNvbXBvbmVudE1hc3Rlci5kZXN0cm95KHRoaXMuX19jb21wb25lbnRzLnJlYWQoQ29tcG9uZW50Q2xhc3MubmFtZSkhKTtcbiAgICB0aGlzLl9fY29tcG9uZW50cy5kZWxldGUoQ29tcG9uZW50Q2xhc3MubmFtZSk7XG4gIH1cblxuICBwdWJsaWMgJGNvcHk8VCBleHRlbmRzIElDb21wb25lbnQ8VEFyZz4sIFRBcmc+KENvbXBvbmVudENsYXNzOiBDdG9yPFQsIFRBcmc+KTogVEFyZyB7XG4gICAgcmV0dXJuIHRoaXMuX19jb21wb25lbnRzLnJlYWQoQ29tcG9uZW50Q2xhc3MubmFtZSkhLmNvcHkoKTtcbiAgfVxuXG4gIHB1YmxpYyAkbXV0YXRlPFQgZXh0ZW5kcyBJQ29tcG9uZW50PFRBcmc+LCBUQXJnPihDb21wb25lbnRDbGFzczogQ3RvcjxULCBUQXJnPik6ICgoZGF0YTogVEFyZykgPT4gdm9pZCkge1xuICAgIHJldHVybiAoZGF0YTogVEFyZykgPT4gdGhpcy5fX2NvbXBvbmVudHMucmVhZChDb21wb25lbnRDbGFzcy5uYW1lKSEubXV0YXRlKGRhdGEpO1xuICB9XG5cbiAgcHVibGljICRwYXRjaDxUIGV4dGVuZHMgSUNvbXBvbmVudDxUQXJnPiwgVEFyZz4oQ29tcG9uZW50Q2xhc3M6IEN0b3I8VCwgVEFyZz4pOiAoKGRhdGE6IFRBcmcgfCB7fSkgPT4gdm9pZCkge1xuICAgIHJldHVybiAoZGF0YToge30pID0+IHRoaXMuX19jb21wb25lbnRzLnJlYWQoQ29tcG9uZW50Q2xhc3MubmFtZSkhLnBhdGNoKGRhdGEpO1xuICB9XG5cbiAgcHVibGljICRmb3JFYWNoKGZuOiAoY29tcG9uZW50OiBJQ29tcG9uZW50PGFueT4pID0+IHZvaWQpOiB2b2lkIHtcbiAgICByZXR1cm4gdGhpcy5fX2NvbXBvbmVudHMuZm9yRWFjaChmbik7XG4gIH1cblxufVxuIiwiaW1wb3J0IENvbXBvbmVudE1hc3RlciBmcm9tICcuL0NvbXBvbmVudE1hc3Rlcic7XG5pbXBvcnQgSUNvbXBvbmVudE1hc3RlciBmcm9tICcuL2ludGVyZmFjZXMvSUNvbXBvbmVudE1hc3Rlcic7XG5pbXBvcnQgSUVudGl0eSBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eSc7XG5pbXBvcnQgSUVudGl0eU1hc3RlciBmcm9tICcuL2ludGVyZmFjZXMvSUVudGl0eU1hc3Rlcic7XG5pbXBvcnQgRGljdGlvbmFyeSBmcm9tICdmb3VuZGF0aW9uL2NvbmNyZXRlcy9EaWN0aW9uYXJ5JztcbmltcG9ydCBJRGljdGlvbmFyeSBmcm9tICdmb3VuZGF0aW9uL2ludGVyZmFjZXMvSURpY3Rpb25hcnknO1xuaW1wb3J0IHsgRGljdCB9IGZyb20gJ2ZvdW5kYXRpb24vdHlwZXMnO1xuaW1wb3J0IHsgRW50aXR5Q2xhc3MsIEV0b3IgfSBmcm9tICcuL3R5cGVzJztcbmltcG9ydCB7IElPQyB9IGZyb20gJy4vRW50aXR5JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgRW50aXR5TWFzdGVyIGltcGxlbWVudHMgSUVudGl0eU1hc3RlciB7XG5cbiAgcHVibGljIGNvbXBvbmVudE1hc3RlcjogSUNvbXBvbmVudE1hc3RlciA9IG5ldyBDb21wb25lbnRNYXN0ZXIoKTtcblxuICBwcml2YXRlIF9fZW50aXR5TWFwOiBJRGljdGlvbmFyeTxJRGljdGlvbmFyeTxJRW50aXR5Pj4gPSBuZXcgRGljdGlvbmFyeSgpO1xuICBwcml2YXRlIF9fY1RhcmdldHM6IElFbnRpdHlbXSA9IFtdO1xuICBwcml2YXRlIF9fZFRhcmdldHM6IElFbnRpdHlbXSA9IFtdO1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBJT0MubWFzdGVyID0gdGhpcztcbiAgfVxuXG4gIHB1YmxpYyBjcmVhdGU8VCBleHRlbmRzIElFbnRpdHksIFRBcmc+KEVudGl0eUNvbnN0cnVjdG9yOiBFdG9yPFQsIFRBcmc+LCBkYXRhOiBUQXJnKTogVCB7XG4gICAgY29uc3QgaW5zdGFuY2UgPSBuZXcgRW50aXR5Q29uc3RydWN0b3IoZGF0YSk7XG4gICAgdGhpcy5fX2NUYXJnZXRzLnB1c2goaW5zdGFuY2UpO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfVxuXG4gIHB1YmxpYyBkZXN0cm95KGVudGl0eTogSUVudGl0eSk6IHZvaWQge1xuICAgIHRoaXMuX19kVGFyZ2V0cy5wdXNoKGVudGl0eSk7XG4gIH1cblxuICBwdWJsaWMgZm9yRXZlcnk8VCBleHRlbmRzIElFbnRpdHk+KEVudGl0eUNsczogRW50aXR5Q2xhc3M8VD4pOiAoZm46IChlbnRpdHk6IFQpID0+IHZvaWQpID0+IHZvaWQge1xuICAgIGNvbnN0IGNvbGxlY3Rpb24gPSB0aGlzLl9fZW50aXR5TWFwLnJlYWQoRW50aXR5Q2xzLm5hbWUpO1xuICAgIHJldHVybiBjb2xsZWN0aW9uID8gY29sbGVjdGlvbi5mb3JFYWNoLmJpbmQoY29sbGVjdGlvbikgOiAoKTogdm9pZCA9PiB1bmRlZmluZWQ7XG4gIH1cblxuICBwdWJsaWMgZmluZDxUIGV4dGVuZHMgSUVudGl0eT4oRW50aXR5Q2xzOiBFbnRpdHlDbGFzczxUPik6IChmbjogKGVudGl0eTogVCkgPT4gYm9vbGVhbikgPT4gVCB8IHVuZGVmaW5lZCB7XG4gICAgcmV0dXJuIChmbjogKChlbnRpdHk6IFQpID0+IGJvb2xlYW4pKTogVCB8IHVuZGVmaW5lZCA9PiB7XG4gICAgICBjb25zdCByZXN1bHQgPSB0aGlzLl9fZW50aXR5TWFwLnJlYWQoRW50aXR5Q2xzLm5hbWUpIS5maW5kKGZuKTtcbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCBhcyBUO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9O1xuICB9XG5cbiAgcHVibGljIG9uY2UoKTogdm9pZCB7XG4gICAgdGhpcy5fX2NyZWF0ZVRhcmdldHMoKTtcbiAgICB0aGlzLl9fZGVzdHJveVRhcmdldHMoKTtcbiAgfVxuXG4gIHByaXZhdGUgX19jcmVhdGVUYXJnZXRzKCk6IHZvaWQge1xuICAgIHdoaWxlICh0aGlzLl9fY1RhcmdldHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBpbnN0YW5jZSA9IHRoaXMuX19jVGFyZ2V0cy5zaGlmdCgpITtcbiAgICAgIGxldCB0YXJnZXQ6IGFueSA9IGluc3RhbmNlO1xuICAgICAgd2hpbGUgKHRhcmdldCkge1xuICAgICAgICBsZXQgY29sbGVjdGlvbiA9IHRoaXMuX19lbnRpdHlNYXAucmVhZCh0YXJnZXQuY29uc3RydWN0b3IubmFtZSk7XG4gICAgICAgIGlmICghY29sbGVjdGlvbikge1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBuZXcgRGljdGlvbmFyeSgpO1xuICAgICAgICAgIHRoaXMuX19lbnRpdHlNYXAud3JpdGUoe1xuICAgICAgICAgICAga2V5OiB0YXJnZXQuY29uc3RydWN0b3IubmFtZSxcbiAgICAgICAgICAgIHZhbHVlOiBjb2xsZWN0aW9uLFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbGxlY3Rpb24ud3JpdGUoeyBrZXk6IGluc3RhbmNlLmlkLCB2YWx1ZTogaW5zdGFuY2UgfSk7XG4gICAgICAgIHRhcmdldCA9IHRhcmdldC5fX3Byb3RvX187XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSBfX2Rlc3Ryb3lUYXJnZXRzKCk6IHZvaWQge1xuICAgIHdoaWxlICh0aGlzLl9fZFRhcmdldHMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBlbnRpdHkgPSB0aGlzLl9fZFRhcmdldHMuc2hpZnQoKSE7XG4gICAgICBlbnRpdHkuJGZvckVhY2goKGNvbXBvbmVudCkgPT4ge1xuICAgICAgICB0aGlzLmNvbXBvbmVudE1hc3Rlci5kZXN0cm95KGNvbXBvbmVudCk7XG4gICAgICB9KTtcbiAgICAgIGxldCB0YXJnZXQ6IElFbnRpdHkgPSBlbnRpdHk7XG4gICAgICB3aGlsZSAodGFyZ2V0KSB7XG4gICAgICAgIHRoaXMuX19lbnRpdHlNYXAucmVhZCh0YXJnZXQuY29uc3RydWN0b3IubmFtZSkhLmRlbGV0ZShlbnRpdHkuaWQpO1xuICAgICAgICB0YXJnZXQgPSAodGFyZ2V0IGFzIERpY3Q8YW55PikuX19wcm90b19fO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG59XG4iLCJpbXBvcnQgSUFkYXB0ZWRLZXlib2FyZEV2ZW50IGZyb20gJy4vaW50ZXJmYWNlcy9JQWRhcHRlZEtleWJvYXJkRXZlbnQnO1xuaW1wb3J0IElLZXlib2FyZEhhbmRsZXIgZnJvbSAnLi9pbnRlcmZhY2VzL0lLZXlib2FyZEhhbmRsZXInO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBLZXlib2FyZEhhbmRsZXIgaW1wbGVtZW50cyBJS2V5Ym9hcmRIYW5kbGVyIHtcblxuICBba2V5OiBzdHJpbmddOiAoa2V5Ym9hcmRFdmVudDogSUFkYXB0ZWRLZXlib2FyZEV2ZW50KSA9PiB2b2lkXG5cbiAgLy8gY29uc3RydWN0b3IoKSB7XG4gICAgLy8gICB0aGlzLmtleWRvd25zID0ge307XG4gICAgLy8gICB0aGlzLmtleXByZXNzZXMgPSB7fTtcbiAgICAvLyAgIHRoaXMua2V5dXBzID0ge307XG4gICAgLy8gfVxuXG4gIC8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuICBwdWJsaWMga2V5ZG93bihrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAvLyB0aGlzLl9faGFuZGxlKGtleWJvYXJkRXZlbnQsIHRoaXMua2V5ZG93bnMpO1xuICB9XG5cbiAgcHVibGljIGtleXByZXNzKGtleWJvYXJkRXZlbnQ6IElBZGFwdGVkS2V5Ym9hcmRFdmVudCk6IHZvaWQge1xuICAgIC8vIHRoaXMuX19oYW5kbGUoa2V5Ym9hcmRFdmVudCwgdGhpcy5rZXlwcmVzc2VzKTtcbiAgfVxuXG4gIHB1YmxpYyBrZXl1cChrZXlib2FyZEV2ZW50OiBJQWRhcHRlZEtleWJvYXJkRXZlbnQpOiB2b2lkIHtcbiAgICAvLyB0aGlzLl9faGFuZGxlKGtleWJvYXJkRXZlbnQsIHRoaXMua2V5dXBzKTtcbiAgfVxuICAvKiBlc2xpbnQtZW5hYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuXG4gIC8vIHByaXZhdGUgX19oYW5kbGUoXG4gIC8vICAga2V5Ym9hcmRFdmVudDogSUFkYXB0ZWRLZXlib2FyZEV2ZW50LFxuICAvLyAgIGtleXM6IHsgW2tleTogc3RyaW5nXTogKGtleWJvYXJkRXZlbnQ6IElBZGFwdGVkS2V5Ym9hcmRFdmVudCkgPT4gdm9pZCB9LFxuICAvLyApOiB2b2lkIHtcbiAgLy8gICBpZiAoa2V5c1trZXlib2FyZEV2ZW50LmtleV0pIHtcbiAgLy8gICAgIGtleXNba2V5Ym9hcmRFdmVudC5rZXldKGtleWJvYXJkRXZlbnQpO1xuICAvLyAgIH1cbiAgLy8gfVxuXG59XG4iLCJpbXBvcnQgSUNvbXBvbmVudCBmcm9tICcuLi9pbnRlcmZhY2VzL0lDb21wb25lbnQnO1xuaW1wb3J0IElFbnRpdHkgZnJvbSAnLi4vaW50ZXJmYWNlcy9JRW50aXR5JztcbmltcG9ydCBVbmlxdWUgZnJvbSAnZm91bmRhdGlvbi9hYnN0cmFjdHMvVW5pcXVlJztcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgQ29tcG9uZW50PFQgZXh0ZW5kcyB7fT4gZXh0ZW5kcyBVbmlxdWUgaW1wbGVtZW50cyBJQ29tcG9uZW50PFQ+IHtcblxuICBwdWJsaWMgJGVudGl0eTogSUVudGl0eTtcblxuICBwcml2YXRlIF9fZGF0YTogVDtcblxuICBjb25zdHJ1Y3Rvcih7IGRhdGEsIGVudGl0eSB9OiB7IGRhdGE6IFQ7IGVudGl0eTogSUVudGl0eSB9KSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiRlbnRpdHkgPSBlbnRpdHk7XG4gICAgdGhpcy5tdXRhdGUoZGF0YSk7XG4gIH1cblxuICBwdWJsaWMgY29weSgpOiBUIHtcbiAgICByZXR1cm4gdGhpcy5fX2Nsb25lKHRoaXMuX19kYXRhKTtcbiAgfVxuXG4gIHB1YmxpYyBtdXRhdGUoZGF0YTogVCk6IHZvaWQge1xuICAgIHRoaXMuX19kYXRhID0gdGhpcy5fX2Nsb25lKGRhdGEpO1xuICB9XG5cbiAgcHVibGljIHBhdGNoKGRhdGE6IHt9KTogdm9pZCB7XG4gICAgdGhpcy5tdXRhdGUoT2JqZWN0LmFzc2lnbih0aGlzLmNvcHkoKSwgZGF0YSkpO1xuICB9XG5cbiAgcHJpdmF0ZSBfX2Nsb25lKGRhdGE6IFQpOiBUIHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG4gIH1cblxufVxuIiwiaW1wb3J0IElFbmdpbmUgZnJvbSAnLi4vaW50ZXJmYWNlcy9JRW5naW5lJztcbmltcG9ydCBJU3lzdGVtIGZyb20gJy4uL2ludGVyZmFjZXMvSVN5c3RlbSc7XG5pbXBvcnQgVW5pcXVlIGZyb20gJ2ZvdW5kYXRpb24vYWJzdHJhY3RzL1VuaXF1ZSc7XG5cbmV4cG9ydCBkZWZhdWx0IGFic3RyYWN0IGNsYXNzIFN5c3RlbSBleHRlbmRzIFVuaXF1ZSBpbXBsZW1lbnRzIElTeXN0ZW0ge1xuXG4gIGNvbnN0cnVjdG9yKHB1YmxpYyAkZW5naW5lOiBJRW5naW5lKSB7XG4gICAgc3VwZXIoKTtcbiAgfVxuXG4gIHB1YmxpYyBvbmNlKCk6IHZvaWQgeyByZXR1cm47IH1cblxuICBwdWJsaWMgZHJhdygpOiB2b2lkIHsgcmV0dXJuOyB9XG5cbn1cbiIsImltcG9ydCBJVW5pcXVlIGZyb20gJy4uL2ludGVyZmFjZXMvSVVuaXF1ZSc7XG5cbmNvbnN0IHV1aWR2MSA9IHJlcXVpcmUoJ3V1aWQvdjEnKTtcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgVW5pcXVlIGltcGxlbWVudHMgSVVuaXF1ZSB7XG5cblxuICAgIHB1YmxpYyBzdGF0aWMgZ2VuZXJhdGVVdWlkKCk6IHN0cmluZyB7XG4gICAgICAgIHJldHVybiB1dWlkdjEoKTtcbiAgICB9XG5cbiAgICBwcml2YXRlIF9faWQ6IHN0cmluZztcblxuICAgIHB1YmxpYyBnZXQgaWQoKTogc3RyaW5nIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX19pZDtcbiAgICB9XG5cbiAgICBwdWJsaWMgY29uc3RydWN0b3IoaWQ/OiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5fX2lkX18oaWQgfHwgVW5pcXVlLmdlbmVyYXRlVXVpZCgpKTtcbiAgICB9XG5cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25hbWluZy1jb252ZW50aW9uXG4gICAgcHJpdmF0ZSBfX2lkX18oaWQ6IHN0cmluZyk6IHZvaWQge1xuICAgICAgICB0aGlzLl9faWQgPSBpZDtcbiAgICB9XG5cbn1cbiIsImltcG9ydCBJRGljdGlvbmFyeSBmcm9tICcuLi9pbnRlcmZhY2VzL0lEaWN0aW9uYXJ5JztcbmltcG9ydCB7IERpY3QgfSBmcm9tICcuLi90eXBlcyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIERpY3Rpb25hcnk8VCBleHRlbmRzIHt9PiBpbXBsZW1lbnRzIElEaWN0aW9uYXJ5PFQ+IHtcblxuICBwcml2YXRlIF9fZGF0YTogRGljdDxUPiA9IHt9O1xuXG4gIHB1YmxpYyBnZXQgbGVuZ3RoKCk6IG51bWJlciB7XG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuX19kYXRhKS5sZW5ndGg7XG4gIH1cblxuICBwdWJsaWMgcmVhZChrZXk6IHN0cmluZyk6IFQgfCB1bmRlZmluZWQge1xuICAgIHJldHVybiB0aGlzLl9fZGF0YVtrZXldO1xuICB9XG5cbiAgcHVibGljIHdyaXRlKHsga2V5LCB2YWx1ZSB9OiB7IGtleTogc3RyaW5nOyB2YWx1ZTogVCB9KTogdm9pZCB7XG4gICAgdGhpcy5fX2RhdGFba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcHVibGljIGRlbGV0ZShrZXk6IHN0cmluZyk6IHZvaWQge1xuICAgIGRlbGV0ZSB0aGlzLl9fZGF0YVtrZXldO1xuICB9XG5cbiAgcHVibGljIGZpbmQoZm46ICh2YWx1ZTogVCkgPT4gYm9vbGVhbik6IFQgfCB1bmRlZmluZWQge1xuICAgIGNvbnN0IGtleTogc3RyaW5nIHwgdW5kZWZpbmVkID0gT2JqZWN0LmtleXModGhpcy5fX2RhdGEpLmZpbmQoKGspID0+IGZuKHRoaXMuX19kYXRhW2tdKSk7XG4gICAgcmV0dXJuIHRoaXMuX19kYXRhW2tleSB8fCAtMV07XG4gIH1cblxuICBwdWJsaWMgZm9yRWFjaChmbjogKHZhbHVlOiBUKSA9PiB2b2lkKTogdm9pZCB7XG4gICAgT2JqZWN0LmtleXModGhpcy5fX2RhdGEpLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgaWYgKHRoaXMuX19kYXRhW2tleV0pIHtcbiAgICAgICAgZm4odGhpcy5fX2RhdGFba2V5XSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgdG9BcnJheSgpOiBUW10ge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLl9fZGF0YSkubWFwKChrZXkpID0+IHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YVtrZXldO1xuICAgIH0pLmZpbHRlcigodGFyZ2V0KSA9PiAhIXRhcmdldCk7XG4gIH1cblxufVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICdlbmdpbmUvYWJzdHJhY3RzL0NvbXBvbmVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVBvaW50IHsgeDogbnVtYmVyOyB5OiBudW1iZXIgfVxuZXhwb3J0IGludGVyZmFjZSBJUG9zZSBleHRlbmRzIElQb2ludCB7IGE6IG51bWJlciB9XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBQb3NlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50PElQb3NlPiB7IH1cbiIsImltcG9ydCB7IElQb2ludCB9IGZyb20gJy4vUG9zZUNvbXBvbmVudCc7XG5pbXBvcnQgQ29tcG9uZW50IGZyb20gJ2VuZ2luZS9hYnN0cmFjdHMvQ29tcG9uZW50JztcblxuZXhwb3J0IGludGVyZmFjZSBJU2hhcGUgeyB2ZXJ0aWNlczogSVBvaW50W10gfVxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2hhcGVDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQ8SVNoYXBlPiB7IH1cbiIsImltcG9ydCBib29sZWFuQ29udGFpbnMgZnJvbSAnQHR1cmYvYm9vbGVhbi1jb250YWlucyc7XG5pbXBvcnQgYm9vbGVhblBvaW50SW5Qb2x5Z29uIGZyb20gJ0B0dXJmL2Jvb2xlYW4tcG9pbnQtaW4tcG9seWdvbic7XG5pbXBvcnQgUG9zZUNvbXBvbmVudCwgeyBJUG9pbnQgfSBmcm9tICcuLi9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuaW1wb3J0IFNoYXBlQ29tcG9uZW50IGZyb20gJy4uL2dlb21ldHJ5L2NvbXBvbmVudHMvU2hhcGVDb21wb25lbnQnO1xuaW1wb3J0IElFbnRpdHkgZnJvbSAnZW5naW5lL2ludGVyZmFjZXMvSUVudGl0eSc7XG5pbXBvcnQgeyBmcm9tUG9pbnRzVG9HZW9KU09OLCBmcm9tU2hhcGVUb0dlb0pTT04sIHRyYW5zZm9ybVNoYXBlIH0gZnJvbSAnLi9nZW9tZXRyeSc7XG5pbXBvcnQgdHVyZiBmcm9tICd0dXJmJztcbmNvbnN0IGJvb2xlYW5PdmVybGFwcyA9IHJlcXVpcmUoJ0B0dXJmL2Jvb2xlYW4tb3ZlcmxhcCcpLmRlZmF1bHQ7XG5jb25zdCBsaW5lSW50ZXJzZWN0ID0gcmVxdWlyZSgnQHR1cmYvbGluZS1pbnRlcnNlY3QnKS5kZWZhdWx0O1xuXG5leHBvcnQgY29uc3QgZW50aXR5Q29udGFpbnNQb2ludCA9IChlbnRpdHk6IElFbnRpdHksIHBvaW50OiBJUG9pbnQpOiBib29sZWFuID0+IHtcbiAgICBjb25zdCBzaGFwZSA9IHRyYW5zZm9ybVNoYXBlKGVudGl0eS4kY29weShTaGFwZUNvbXBvbmVudCksIGVudGl0eS4kY29weShQb3NlQ29tcG9uZW50KSk7XG4gICAgcmV0dXJuIGJvb2xlYW5Qb2ludEluUG9seWdvbih0dXJmLnBvaW50KFtwb2ludC54LCBwb2ludC55XSksIGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVudGl0aWVzVG91Y2ggPSAoZW50aXR5MTogSUVudGl0eSwgZW50aXR5MjogSUVudGl0eSk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHNoYXBlMSA9IHRyYW5zZm9ybVNoYXBlKGVudGl0eTEuJGNvcHkoU2hhcGVDb21wb25lbnQpLCBlbnRpdHkxLiRjb3B5KFBvc2VDb21wb25lbnQpKTtcbiAgICBjb25zdCBzaGFwZTIgPSB0cmFuc2Zvcm1TaGFwZShlbnRpdHkyLiRjb3B5KFNoYXBlQ29tcG9uZW50KSwgZW50aXR5Mi4kY29weShQb3NlQ29tcG9uZW50KSk7XG4gICAgY29uc3QgZ2VvSlNPTjEgPSBmcm9tU2hhcGVUb0dlb0pTT04oc2hhcGUxKTtcbiAgICBjb25zdCBnZW9KU09OMiA9IGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZTIpO1xuICAgIHJldHVybiBib29sZWFuQ29udGFpbnMoZ2VvSlNPTjEsIGdlb0pTT04yKSB8fFxuICAgICAgICBib29sZWFuQ29udGFpbnMoZ2VvSlNPTjIsIGdlb0pTT04xKSB8fFxuICAgICAgICBib29sZWFuT3ZlcmxhcHMoZ2VvSlNPTjEsIGdlb0pTT04yKSB8fFxuICAgICAgICBib29sZWFuT3ZlcmxhcHMoZ2VvSlNPTjIsIGdlb0pTT04xKTtcbn07XG5cbmV4cG9ydCBjb25zdCBlbnRpdHlDb250YWluc0VudGl0eSA9IChlbnRpdHkxOiBJRW50aXR5LCBlbnRpdHkyOiBJRW50aXR5KTogYm9vbGVhbiA9PiB7XG4gICAgY29uc3Qgc2hhcGUxID0gdHJhbnNmb3JtU2hhcGUoZW50aXR5MS4kY29weShTaGFwZUNvbXBvbmVudCksIGVudGl0eTEuJGNvcHkoUG9zZUNvbXBvbmVudCkpO1xuICAgIGNvbnN0IHNoYXBlMiA9IHRyYW5zZm9ybVNoYXBlKGVudGl0eTIuJGNvcHkoU2hhcGVDb21wb25lbnQpLCBlbnRpdHkyLiRjb3B5KFBvc2VDb21wb25lbnQpKTtcbiAgICBjb25zdCBnZW9KU09OMSA9IGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZTEpO1xuICAgIGNvbnN0IGdlb0pTT04yID0gZnJvbVNoYXBlVG9HZW9KU09OKHNoYXBlMik7XG4gICAgcmV0dXJuIGJvb2xlYW5Db250YWlucyhnZW9KU09OMSwgZ2VvSlNPTjIpIHx8IGJvb2xlYW5Db250YWlucyhnZW9KU09OMiwgZ2VvSlNPTjEpO1xufTtcblxuZXhwb3J0IGNvbnN0IGVudGl0eVRvdWNoZXNMaW5lID0gKGVudGl0eTogSUVudGl0eSwgcG9pbnRzOiBJUG9pbnRbXSk6IGJvb2xlYW4gPT4ge1xuICAgIGNvbnN0IHNoYXBlID0gdHJhbnNmb3JtU2hhcGUoZW50aXR5LiRjb3B5KFNoYXBlQ29tcG9uZW50KSwgZW50aXR5LiRjb3B5KFBvc2VDb21wb25lbnQpKTtcbiAgICBjb25zdCBwb2x5Z29uID0gZnJvbVNoYXBlVG9HZW9KU09OKHNoYXBlKTtcbiAgICBjb25zdCBsaW5lID0gZnJvbVBvaW50c1RvR2VvSlNPTihwb2ludHMpO1xuICAgIHJldHVybiBsaW5lSW50ZXJzZWN0KHBvbHlnb24sIGxpbmUpLmZlYXR1cmVzLmxlbmd0aCA+IDA7XG59O1xuIiwiaW1wb3J0IHsgSVBvaW50LCBJUG9zZSB9IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuaW1wb3J0IHsgSVNoYXBlIH0gZnJvbSAnZnJhbWV3b3JrL2dlb21ldHJ5L2NvbXBvbmVudHMvU2hhcGVDb21wb25lbnQnO1xuaW1wb3J0IHsgRmVhdHVyZSwgR2VvSnNvblByb3BlcnRpZXMsIE11bHRpUG9seWdvbiwgUG9seWdvbiwgTGluZVN0cmluZyB9IGZyb20gJ2dlb2pzb24nO1xuaW1wb3J0IHR1cmYgZnJvbSAndHVyZic7XG5cbmV4cG9ydCBjb25zdCByb3RhdGVQb2ludEFib3V0T3JpZ2luID0gKHsgcG9pbnQsIG9yaWVudGF0aW9uIH06IHtcbiAgICBwb2ludDogSVBvaW50OyBvcmllbnRhdGlvbjogbnVtYmVyO1xufSk6IElQb2ludCA9PiB7XG4gICAgY29uc3QgcyA9IE1hdGguc2luKG9yaWVudGF0aW9uKTtcbiAgICBjb25zdCBjID0gTWF0aC5jb3Mob3JpZW50YXRpb24pO1xuICAgIHJldHVybiB7XG4gICAgICAgIHg6IHBvaW50LnggKiBjIC0gcG9pbnQueSAqIHMsXG4gICAgICAgIHk6IHBvaW50LnggKiBzICsgcG9pbnQueSAqIGMsXG4gICAgfTtcbn07XG5cbmV4cG9ydCBjb25zdCB0cmFuc2Zvcm1TaGFwZSA9IChzaGFwZTogSVNoYXBlLCBwb3NlOiBJUG9zZSk6IElTaGFwZSA9PiB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgdmVydGljZXM6IHNoYXBlLnZlcnRpY2VzLm1hcCgocCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgcG9pbnQgPSByb3RhdGVQb2ludEFib3V0T3JpZ2luKHsgcG9pbnQ6IHAsIG9yaWVudGF0aW9uOiBwb3NlLmEgfSk7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHg6IHBvaW50LnggKyBwb3NlLngsXG4gICAgICAgICAgICAgICAgeTogcG9pbnQueSArIHBvc2UueSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH0pLFxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3QgZnJvbVBvaW50c1RvR2VvSlNPTiA9IChwb2ludHM6IElQb2ludFtdKTogRmVhdHVyZTxMaW5lU3RyaW5nLCBHZW9Kc29uUHJvcGVydGllcz4gPT4ge1xuICAgIHJldHVybiB0dXJmLmxpbmVTdHJpbmcocG9pbnRzLm1hcCgocG9pbnQpID0+IFtwb2ludC54LCBwb2ludC55XSkpO1xufTtcblxuZXhwb3J0IGNvbnN0IGZyb21TaGFwZVRvR2VvSlNPTiA9IChzaGFwZTogSVNoYXBlKTogRmVhdHVyZTxQb2x5Z29uLCBHZW9Kc29uUHJvcGVydGllcz4gPT4ge1xuICAgIHJldHVybiB0dXJmLnBvbHlnb24oW1xuICAgICAgICBzaGFwZS52ZXJ0aWNlcy5tYXAoKHZlcnRleCkgPT4gW3ZlcnRleC54LCB2ZXJ0ZXgueSBdKS5jb25jYXQoW1tzaGFwZS52ZXJ0aWNlc1swXS54LCBzaGFwZS52ZXJ0aWNlc1swXS55XV0pLFxuICAgIF0pO1xufTtcblxuZXhwb3J0IGNvbnN0IGZyb21HZW9KU09OQ29vcmRpbmF0ZXNUb1NoYXBlcyA9IChnZW9KU09OOiBGZWF0dXJlPFBvbHlnb258TXVsdGlQb2x5Z29uLCBHZW9Kc29uUHJvcGVydGllcz4pOiBJU2hhcGVbXSA9PiB7XG4gICAgaWYgKCFnZW9KU09OKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGdlb0pTT04uZ2VvbWV0cnkudHlwZSA9PT0gJ1BvbHlnb24nKSB7XG4gICAgICAgIHJldHVybiBnZW9KU09OLmdlb21ldHJ5LmNvb3JkaW5hdGVzLm1hcCgodmVydGljZXM6IG51bWJlcltdW10pID0+IHtcbiAgICAgICAgICAgIHJldHVybiB7IHZlcnRpY2VzOiB2ZXJ0aWNlcy5tYXAoKHZlcnRleDogbnVtYmVyW10pID0+ICh7IHg6IHZlcnRleFswXSwgeTogdmVydGV4WzFdIH0pKSB9O1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGdlb0pTT04uZ2VvbWV0cnkudHlwZSA9PT0gJ011bHRpUG9seWdvbicpIHtcbiAgICAgICAgY29uc3Qgc2hhcGVzOiBJU2hhcGVbXSA9IFtdO1xuICAgICAgICBnZW9KU09OLmdlb21ldHJ5LmNvb3JkaW5hdGVzLmZvckVhY2goKHBvbHlnb24pID0+IHtcbiAgICAgICAgICAgIHNoYXBlcy5wdXNoKHBvbHlnb24ubWFwKCh2ZXJ0aWNlczogbnVtYmVyW11bXSkgPT4ge1xuICAgICAgICAgICAgICAgIHJldHVybiB7IHZlcnRpY2VzOiB2ZXJ0aWNlcy5tYXAoKHZlcnRleDogbnVtYmVyW10pID0+ICh7IHg6IHZlcnRleFswXSwgeTogdmVydGV4WzFdIH0pKSB9O1xuICAgICAgICAgICAgfSlbMF0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHNoYXBlcztcbiAgICB9XG4gICAgcmV0dXJuIFtdO1xufTtcblxuZXhwb3J0IGludGVyZmFjZSBJQm91bmRhcnkgeyBtaW5YOiBudW1iZXI7IG1heFg6IG51bWJlcjsgbWluWTogbnVtYmVyOyBtYXhZOiBudW1iZXIgfVxuZXhwb3J0IGNvbnN0IGZyb21TaGFwZVRvQm91bmRhcnkgPSAoc2hhcGU6IElTaGFwZSk6IElCb3VuZGFyeSA9PiB7XG4gICAgY29uc3QgZ2VvanNvbiA9IGZyb21TaGFwZVRvR2VvSlNPTihzaGFwZSk7XG4gICAgY29uc3QgYmJveCA9IHR1cmYuYmJveChnZW9qc29uKTtcbiAgICByZXR1cm4ge1xuICAgICAgICBtaW5YOiBiYm94WzBdLFxuICAgICAgICBtaW5ZOiBiYm94WzFdLFxuICAgICAgICBtYXhYOiBiYm94WzJdLFxuICAgICAgICBtYXhZOiBiYm94WzNdLFxuICAgIH07XG59O1xuXG5leHBvcnQgY29uc3QgZ2V0RXVjbGlkZWFuRGlzdGFuY2VCZXR3ZWVuUG9pbnRzID0gKHAxOiBJUG9pbnQsIHAyOiBJUG9pbnQpOiBudW1iZXIgPT4ge1xuICAgIHJldHVybiBNYXRoLnNxcnQoTWF0aC5wb3coKHAyLnggLSBwMS54KSwgMikgKyBNYXRoLnBvdyhwMi55IC0gcDEueSwgMikpO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldEFuZ2xlQmV0d2VlblBvaW50cyA9IChwMTogSVBvaW50LCBwMjogSVBvaW50KTogbnVtYmVyID0+IHtcbiAgICByZXR1cm4gTWF0aC5hdGFuMihwMi55IC0gcDEueSwgcDIueCAtIHAxLngpO1xufTtcblxuZXhwb3J0IGNvbnN0IHBvdzIgPSAodGFyZ2V0OiBudW1iZXIpOiBudW1iZXIgPT4ge1xuICAgIHJldHVybiBNYXRoLnBvdyh0YXJnZXQsIDIpO1xufTtcbiIsImltcG9ydCBDb21wb25lbnQgZnJvbSAnZW5naW5lL2Fic3RyYWN0cy9Db21wb25lbnQnO1xuaW1wb3J0IElBZGFwdGVkTW91c2VFdmVudCBmcm9tICdlbmdpbmUvaW50ZXJmYWNlcy9JQWRhcHRlZE1vdXNlRXZlbnQnO1xuXG50eXBlIEFkYXB0ZWRNb3VzZUV2ZW50Q2FsbGJhY2sgPSAoZTogSUFkYXB0ZWRNb3VzZUV2ZW50KSA9PiB2b2lkO1xuXG5leHBvcnQgaW50ZXJmYWNlIElJbnRlcmFjdGl2ZSB7XG4gIGlzRW5hYmxlZDogYm9vbGVhbjtcbiAgaXNIb3ZlcmVkOiBib29sZWFuO1xuICBtb3VzZWVudGVyOiBBZGFwdGVkTW91c2VFdmVudENhbGxiYWNrO1xuICBtb3VzZWxlYXZlOiBBZGFwdGVkTW91c2VFdmVudENhbGxiYWNrO1xuICBtb3VzZW1vdmU6IEFkYXB0ZWRNb3VzZUV2ZW50Q2FsbGJhY2s7XG4gIG1vdXNlZG93bjogQWRhcHRlZE1vdXNlRXZlbnRDYWxsYmFjaztcbiAgbW91c2V1cDogQWRhcHRlZE1vdXNlRXZlbnRDYWxsYmFjaztcbiAgY2xpY2s6IEFkYXB0ZWRNb3VzZUV2ZW50Q2FsbGJhY2s7XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBJbnRlcmFjdGl2ZUNvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudDxJSW50ZXJhY3RpdmU+IHsgfVxuIiwiaW1wb3J0IEludGVyYWN0aXZlQ29tcG9uZW50IGZyb20gJy4vSW50ZXJhY3RpdmVDb21wb25lbnQnO1xuaW1wb3J0IEVudGl0eSBmcm9tICdlbmdpbmUvRW50aXR5JztcbmltcG9ydCBJQWRhcHRlZE1vdXNlRXZlbnQgZnJvbSAnZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRNb3VzZUV2ZW50JztcblxuZXhwb3J0IGRlZmF1bHQgYWJzdHJhY3QgY2xhc3MgSW50ZXJhY3RpdmVFbnRpdHkgZXh0ZW5kcyBFbnRpdHkge1xuXG4gIHB1YmxpYyBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuJGFkZChJbnRlcmFjdGl2ZUNvbXBvbmVudCkoe1xuICAgICAgaXNFbmFibGVkOiB0cnVlLFxuICAgICAgaXNIb3ZlcmVkOiBmYWxzZSxcbiAgICAgIG1vdXNlZW50ZXI6IHRoaXMuJG1vdXNlZW50ZXIsXG4gICAgICBtb3VzZWxlYXZlOiB0aGlzLiRtb3VzZWxlYXZlLFxuICAgICAgbW91c2Vtb3ZlOiB0aGlzLiRtb3VzZW1vdmUsXG4gICAgICBtb3VzZWRvd246IHRoaXMuJG1vdXNlZG93bixcbiAgICAgIG1vdXNldXA6IHRoaXMuJG1vdXNldXAsXG4gICAgICBjbGljazogdGhpcy4kY2xpY2ssXG4gICAgfSk7XG4gIH1cblxuICBwdWJsaWMgJGVuYWJsZSgpOiB2b2lkIHtcbiAgICB0aGlzLiRwYXRjaChJbnRlcmFjdGl2ZUNvbXBvbmVudCkoeyBpc0VuYWJsZWQ6IHRydWUgfSk7XG4gIH1cblxuICBwdWJsaWMgJGRpc2FibGUoKTogdm9pZCB7XG4gICAgdGhpcy4kcGF0Y2goSW50ZXJhY3RpdmVDb21wb25lbnQpKHsgaXNFbmFibGVkOiBmYWxzZSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBhYnN0cmFjdCAkbW91c2VlbnRlcihlOiBJQWRhcHRlZE1vdXNlRXZlbnQpOiB2b2lkO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCAkbW91c2VsZWF2ZShlOiBJQWRhcHRlZE1vdXNlRXZlbnQpOiB2b2lkO1xuXG4gIHB1YmxpYyBhYnN0cmFjdCAkbW91c2Vtb3ZlKGU6IElBZGFwdGVkTW91c2VFdmVudCk6IHZvaWQ7XG5cbiAgcHVibGljIGFic3RyYWN0ICRtb3VzZWRvd24oZTogSUFkYXB0ZWRNb3VzZUV2ZW50KTogdm9pZDtcblxuICBwdWJsaWMgYWJzdHJhY3QgJG1vdXNldXAoZTogSUFkYXB0ZWRNb3VzZUV2ZW50KTogdm9pZDtcblxuICBwdWJsaWMgYWJzdHJhY3QgJGNsaWNrKGU6IElBZGFwdGVkTW91c2VFdmVudCk6IHZvaWQ7XG59XG4iLCJpbXBvcnQgeyBJSW1hZ2UgfSBmcm9tICcuL0ltYWdlQ29tcG9uZW50JztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnZW5naW5lL2Fic3RyYWN0cy9Db21wb25lbnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElBbmltYXRlZEltYWdlIHtcbiAgaW1hZ2VzOiBJSW1hZ2VbXTtcbiAgZnJhbWU6IG51bWJlcjtcbiAgc3BlZWQ6IG51bWJlcjtcbiAgY29vbGRvd246IG51bWJlcjtcbiAgaXNQYXVzZWQ/OiBib29sZWFuO1xuICBpc1JldmVyc2VkPzogYm9vbGVhbjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEFuaW1hdGVkSW1hZ2VDb21wb25lbnQgZXh0ZW5kcyBDb21wb25lbnQ8SUFuaW1hdGVkSW1hZ2U+IHsgfVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICdlbmdpbmUvYWJzdHJhY3RzL0NvbXBvbmVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSUltYWdlIHtcbiAgc3JjOiBzdHJpbmc7XG4gIG9wYWNpdHk6IG51bWJlcjtcbiAgekluZGV4OiBudW1iZXI7XG4gIHdpZHRoPzogbnVtYmVyO1xuICBoZWlnaHQ/OiBudW1iZXI7XG4gIHJvdGF0ZT86IG51bWJlcjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEltYWdlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50PElJbWFnZT4geyB9XG4iLCJpbXBvcnQgeyBJU3R5bGUgfSBmcm9tICcuL1N0eWxlQ29tcG9uZW50JztcbmltcG9ydCBDb21wb25lbnQgZnJvbSAnZW5naW5lL2Fic3RyYWN0cy9Db21wb25lbnQnO1xuXG5leHBvcnQgaW50ZXJmYWNlIElMYWJlbCBleHRlbmRzIElTdHlsZSB7XG4gIHRleHQ6IHN0cmluZztcbiAgZm9udFNpemU6IG51bWJlcjtcbiAgb2Zmc2V0OiB7IHg6IG51bWJlcjsgeTogbnVtYmVyIH07XG59XG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbENvbXBvbmVudCBleHRlbmRzIENvbXBvbmVudDxJTGFiZWw+IHsgfVxuIiwiaW1wb3J0IENvbXBvbmVudCBmcm9tICdlbmdpbmUvYWJzdHJhY3RzL0NvbXBvbmVudCc7XG5cbmV4cG9ydCBpbnRlcmZhY2UgSVN0eWxlIHtcbiAgY29sb3VyOiBzdHJpbmc7XG4gIGZpbGw6IHN0cmluZztcbiAgb3BhY2l0eTogbnVtYmVyO1xuICB6SW5kZXg6IG51bWJlcjtcbn1cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlQ29tcG9uZW50IGV4dGVuZHMgQ29tcG9uZW50PElTdHlsZT4geyB9XG4iLCJpbXBvcnQgQW5pbWF0ZWRJbWFnZUNvbXBvbmVudCBmcm9tICcuLi9jb21wb25lbnRzL0FuaW1hdGlvbkNvbXBvbmVudCc7XG5pbXBvcnQgU3lzdGVtIGZyb20gJy4uLy4uLy4uL2VuZ2luZS9hYnN0cmFjdHMvU3lzdGVtJztcbmltcG9ydCBQb3NlQ29tcG9uZW50IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBBbmltYXRlZEltYWdlU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcblxuICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcbiAgICB0aGlzLiRlbmdpbmUuY29tcG9uZW50cy5mb3JFdmVyeShBbmltYXRlZEltYWdlQ29tcG9uZW50KSgoYW5pbWF0aW9uKSA9PiB7XG4gICAgICBjb25zdCBkYXRhID0gYW5pbWF0aW9uLmNvcHkoKTtcbiAgICAgIGlmIChkYXRhLmNvb2xkb3duID09PSBkYXRhLnNwZWVkKSB7XG4gICAgICAgIGRhdGEuY29vbGRvd24gPSAwO1xuICAgICAgICBpZiAoZGF0YS5pc1JldmVyc2VkKSB7XG4gICAgICAgICAgZGF0YS5mcmFtZS0tO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGRhdGEuZnJhbWUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mcmFtZSA+IGRhdGEuaW1hZ2VzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICBkYXRhLmZyYW1lID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YS5mcmFtZSA8IDApIHtcbiAgICAgICAgICBkYXRhLmZyYW1lID0gZGF0YS5pbWFnZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghZGF0YS5pc1BhdXNlZCkge1xuICAgICAgICBkYXRhLmNvb2xkb3duKys7XG4gICAgICB9XG4gICAgICBhbmltYXRpb24ubXV0YXRlKGRhdGEpO1xuICAgICAgdGhpcy4kZW5naW5lLnZpZXdwb3J0LmRyYXdJbWFnZSh7XG4gICAgICAgIHBvc2U6IGFuaW1hdGlvbi4kZW50aXR5LiRjb3B5KFBvc2VDb21wb25lbnQpIHx8IHsgeDogMCwgeTogMCwgYTogMCB9LFxuICAgICAgICBpbWFnZTogZGF0YS5pbWFnZXNbZGF0YS5mcmFtZV0sXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuIiwiaW1wb3J0IEltYWdlQ29tcG9uZW50IGZyb20gJy4uL2NvbXBvbmVudHMvSW1hZ2VDb21wb25lbnQnO1xuaW1wb3J0IFN5c3RlbSBmcm9tICcuLi8uLi8uLi9lbmdpbmUvYWJzdHJhY3RzL1N5c3RlbSc7XG5pbXBvcnQgUG9zZUNvbXBvbmVudCBmcm9tICdmcmFtZXdvcmsvZ2VvbWV0cnkvY29tcG9uZW50cy9Qb3NlQ29tcG9uZW50JztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSW1hZ2VTeXN0ZW0gZXh0ZW5kcyBTeXN0ZW0ge1xuXG4gICAgcHVibGljIGRyYXcoKTogdm9pZCB7XG4gICAgICAgIHRoaXMuJGVuZ2luZS5jb21wb25lbnRzLmZvckV2ZXJ5KEltYWdlQ29tcG9uZW50KSgoaW1hZ2UpID0+IHtcbiAgICAgICAgICAgIGlmICghaW1hZ2UuY29weSgpLnNyYykge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3SW1hZ2Uoe1xuICAgICAgICAgICAgICAgIHBvc2U6IGltYWdlLiRlbnRpdHkuJGNvcHkoUG9zZUNvbXBvbmVudCkgfHwgeyB4OiAwLCB5OiAwLCBhOiAwIH0sXG4gICAgICAgICAgICAgICAgaW1hZ2U6IGltYWdlLmNvcHkoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgTGFiZWxDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9MYWJlbENvbXBvbmVudCc7XG5pbXBvcnQgU3lzdGVtIGZyb20gJy4uLy4uLy4uL2VuZ2luZS9hYnN0cmFjdHMvU3lzdGVtJztcbmltcG9ydCBQb3NlQ29tcG9uZW50IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBMYWJlbFN5c3RlbSBleHRlbmRzIFN5c3RlbSB7XG5cbiAgICBwdWJsaWMgZHJhdygpOiB2b2lkIHtcbiAgICAgICAgdGhpcy4kZW5naW5lLmNvbXBvbmVudHMuZm9yRXZlcnkoTGFiZWxDb21wb25lbnQpKChsYWJlbCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFsYWJlbC5jb3B5KCkudGV4dCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3TGFiZWwoe1xuICAgICAgICAgICAgICAgIHBvc2U6IGxhYmVsLiRlbnRpdHkuJGNvcHkoUG9zZUNvbXBvbmVudCksXG4gICAgICAgICAgICAgICAgbGFiZWw6IGxhYmVsLmNvcHkoKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG59XG4iLCJpbXBvcnQgU3R5bGVDb21wb25lbnQgZnJvbSAnLi4vY29tcG9uZW50cy9TdHlsZUNvbXBvbmVudCc7XG5pbXBvcnQgU3lzdGVtIGZyb20gJy4uLy4uLy4uL2VuZ2luZS9hYnN0cmFjdHMvU3lzdGVtJztcbmltcG9ydCBQb3NlQ29tcG9uZW50IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1Bvc2VDb21wb25lbnQnO1xuaW1wb3J0IFNoYXBlQ29tcG9uZW50IGZyb20gJ2ZyYW1ld29yay9nZW9tZXRyeS9jb21wb25lbnRzL1NoYXBlQ29tcG9uZW50JztcbmltcG9ydCB7IHRyYW5zZm9ybVNoYXBlIH0gZnJvbSAnLi4vLi4vaGVscGVycy9nZW9tZXRyeSc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFN0eWxlU3lzdGVtIGV4dGVuZHMgU3lzdGVtIHtcblxuICAgIHB1YmxpYyBkcmF3KCk6IHZvaWQge1xuICAgICAgICB0aGlzLiRlbmdpbmUuY29tcG9uZW50cy5mb3JFdmVyeShTdHlsZUNvbXBvbmVudCkoKHN0eWxlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBwb3NlID0gc3R5bGUuJGVudGl0eS4kY29weShQb3NlQ29tcG9uZW50KTtcbiAgICAgICAgICAgIHRoaXMuJGVuZ2luZS52aWV3cG9ydC5kcmF3U2hhcGUoe1xuICAgICAgICAgICAgICAgIHBhdGg6IHRyYW5zZm9ybVNoYXBlKHN0eWxlLiRlbnRpdHkuJGNvcHkoU2hhcGVDb21wb25lbnQpLCBwb3NlKS52ZXJ0aWNlcyxcbiAgICAgICAgICAgICAgICBzdHlsZTogc3R5bGUuY29weSgpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbiIsImltcG9ydCBJQWRhcHRlZEtleWJvYXJkRXZlbnQgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRLZXlib2FyZEV2ZW50JztcbmltcG9ydCBJS2V5Ym9hcmRBZGFwdG9yIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lLZXlib2FyZEFkYXB0b3InO1xuaW1wb3J0IElLZXlib2FyZEhhbmRsZXIgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUtleWJvYXJkSGFuZGxlcic7XG5pbXBvcnQgS2V5Ym9hcmRIYW5kbGVyIGZyb20gJy4uL2VuZ2luZS9LZXlib2FyZEhhbmRsZXInO1xuaW1wb3J0IHsgRGljdCB9IGZyb20gJ2ZvdW5kYXRpb24vdHlwZXMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBIVE1MNUNhbnZhc0tleWJvYXJkQWRhcHRlciBpbXBsZW1lbnRzIElLZXlib2FyZEFkYXB0b3Ige1xuXG4gIHByaXZhdGUgX19jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ICYgRGljdDwoa2U6IEtleWJvYXJkRXZlbnQpID0+IHZvaWQ+O1xuICBwcml2YXRlIF9fYnVmZmVyOiBJQWRhcHRlZEtleWJvYXJkRXZlbnRbXTtcbiAgcHJpdmF0ZSBfX2hhbmRsZXI6IElLZXlib2FyZEhhbmRsZXI7XG5cbiAgY29uc3RydWN0b3IoY2FudmFzOiBIVE1MQ2FudmFzRWxlbWVudCAmIERpY3Q8KGtlOiBLZXlib2FyZEV2ZW50KSA9PiB2b2lkPikge1xuICAgIHRoaXMuX19jYW52YXMgPSBjYW52YXM7XG4gICAgdGhpcy5fX2J1ZmZlciA9IFtdO1xuICAgIHRoaXMuX19oYW5kbGVyID0gbmV3IEtleWJvYXJkSGFuZGxlcigpO1xuICAgIHRoaXMuX19iaW5kS2V5Ym9hcmRFdmVudHMoKTtcbiAgfVxuXG4gIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xuICAgIGNvbnN0IGlucHV0ID0gdGhpcy5fX2J1ZmZlci5zaGlmdCgpO1xuICAgIGlmIChpbnB1dCkge1xuICAgICAgdGhpcy5fX2hhbmRsZXJbaW5wdXQubmFtZV0oaW5wdXQpO1xuICAgIH1cbiAgfVxuXG4gIHB1YmxpYyBoYW5kbGVyKGhhbmRsZXI6IElLZXlib2FyZEhhbmRsZXIpOiB2b2lkIHtcbiAgICB0aGlzLl9faGFuZGxlciA9IGhhbmRsZXI7XG4gIH1cblxuICBwcml2YXRlIF9fYmluZEtleWJvYXJkRXZlbnRzKCk6IHZvaWQge1xuICAgIFtcbiAgICAgICdrZXlkb3duJyxcbiAgICAgICdrZXlwcmVzcycsXG4gICAgICAna2V5dXAnLFxuICAgIF1cbiAgICAgIC5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgdGhpcy5fX2NhbnZhc1tgb24ke2tleX1gXSA9IChrZTogS2V5Ym9hcmRFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgIHRoaXMuX19idWZmZXIucHVzaCh7XG4gICAgICAgICAgICBuYW1lOiBrZXksXG4gICAgICAgICAgICBrZXk6IGtlLmtleSxcbiAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgIH0pO1xuICB9XG5cbn1cbiIsImltcG9ydCBJQWRhcHRlZE1vdXNlRXZlbnQgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSUFkYXB0ZWRNb3VzZUV2ZW50JztcbmltcG9ydCBJTW91c2VBZGFwdG9yIGZyb20gJy4uL2VuZ2luZS9pbnRlcmZhY2VzL0lNb3VzZUFkYXB0b3InO1xuaW1wb3J0IElNb3VzZUhhbmRsZXIgZnJvbSAnLi4vZW5naW5lL2ludGVyZmFjZXMvSU1vdXNlSGFuZGxlcic7XG5cbi8qIGVzbGludC1kaXNhYmxlIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFycyAqL1xuY29uc3QgZGVmYXVsdEhhbmRsZXIgPSB7XG4gICAgbW91c2VlbnRlcjogKCkgPT4gdW5kZWZpbmVkLFxuICAgIG1vdXNlbW92ZTogKG1vdXNlRXZlbnQ6IElBZGFwdGVkTW91c2VFdmVudCkgPT4gdW5kZWZpbmVkLFxuICAgIG1vdXNlbGVhdmU6ICgpID0+IHVuZGVmaW5lZCxcbiAgICBtb3VzZWRvd246IChtb3VzZUV2ZW50OiBJQWRhcHRlZE1vdXNlRXZlbnQpID0+IHVuZGVmaW5lZCxcbiAgICBtb3VzZXVwOiAobW91c2VFdmVudDogSUFkYXB0ZWRNb3VzZUV2ZW50KSA9PiB1bmRlZmluZWQsXG4gICAgY2xpY2s6IChtb3VzZUV2ZW50OiBJQWRhcHRlZE1vdXNlRXZlbnQpID0+IHVuZGVmaW5lZCxcbiAgICBub25lOiAoKSA9PiB1bmRlZmluZWQsXG59O1xuLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgSFRNTDVDYW52YXNNb3VzZUFkYXB0b3IgaW1wbGVtZW50cyBJTW91c2VBZGFwdG9yIHtcblxuICAgIHByaXZhdGUgX19jYW52YXM6IEhUTUxDYW52YXNFbGVtZW50ICYgeyBba2V5OiBzdHJpbmddOiAobWU6IE1vdXNlRXZlbnQpID0+IHZvaWQgfTtcbiAgICBwcml2YXRlIF9fYnVmZmVyOiBJQWRhcHRlZE1vdXNlRXZlbnRbXTtcbiAgICBwcml2YXRlIF9faGFuZGxlcjogSU1vdXNlSGFuZGxlcjtcblxuICAgIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQgJiB7IFtrZXk6IHN0cmluZ106IChtZTogTW91c2VFdmVudCkgPT4gdm9pZCB9KSB7XG4gICAgICAgIHRoaXMuX19jYW52YXMgPSBjYW52YXM7XG4gICAgICAgIHRoaXMuX19idWZmZXIgPSBbXTtcbiAgICAgICAgdGhpcy5fX2hhbmRsZXIgPSBkZWZhdWx0SGFuZGxlcjtcbiAgICAgICAgdGhpcy5fX2JpbmRNb3VzZUV2ZW50cygpO1xuICAgIH1cblxuICAgIHB1YmxpYyBvbmNlKCk6IHZvaWQge1xuICAgICAgICBjb25zdCBldmVudCA9IHRoaXMuX19idWZmZXIuc2hpZnQoKTtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB0aGlzLl9faGFuZGxlcltldmVudC5uYW1lXShldmVudCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9faGFuZGxlci5ub25lKHtcbiAgICAgICAgICAgICAgICBuYW1lOiAnbm9uZScsXG4gICAgICAgICAgICAgICAgeDogMCxcbiAgICAgICAgICAgICAgICB5OiAwLFxuICAgICAgICAgICAgICAgIGlzQ3RybERvd246IGZhbHNlLFxuICAgICAgICAgICAgICAgIGlzU2hpZnREb3duOiBmYWxzZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgcHVibGljIGhhbmRsZXIoaGFuZGxlcjogSU1vdXNlSGFuZGxlcik6IHZvaWQge1xuICAgICAgICB0aGlzLl9faGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfVxuXG4gICAgcHJpdmF0ZSBfX2JpbmRNb3VzZUV2ZW50cygpOiB2b2lkIHtcbiAgICAgICAgW1xuICAgICAgICAgICAgJ21vdXNlZW50ZXInLFxuICAgICAgICAgICAgJ21vdXNlbW92ZScsXG4gICAgICAgICAgICAnbW91c2VsZWF2ZScsXG4gICAgICAgICAgICAnbW91c2Vkb3duJyxcbiAgICAgICAgICAgICdtb3VzZXVwJyxcbiAgICAgICAgICAgICdjbGljaycsXG4gICAgICAgIF1cbiAgICAgICAgLmZvckVhY2goKGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fX2NhbnZhc1tgb24ke2tleX1gXSA9IChldjogTW91c2VFdmVudCk6IHZvaWQgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGJvdW5kaW5nQ2xpZW50UmVjdCA9IHRoaXMuX19jYW52YXMuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5fX2J1ZmZlci5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZTogZXYudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgeDogZXYuY2xpZW50WCAtIGJvdW5kaW5nQ2xpZW50UmVjdC5sZWZ0LFxuICAgICAgICAgICAgICAgICAgICB5OiBldi5jbGllbnRZIC0gYm91bmRpbmdDbGllbnRSZWN0LnRvcCxcbiAgICAgICAgICAgICAgICAgICAgaXNDdHJsRG93bjogZXYuY3RybEtleSxcbiAgICAgICAgICAgICAgICAgICAgaXNTaGlmdERvd246IGV2LnNoaWZ0S2V5LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuXG59XG4iLCJpbXBvcnQgSVZpZXdwb3J0QWRhcHRvciBmcm9tICcuLi9lbmdpbmUvaW50ZXJmYWNlcy9JVmlld3BvcnRBZGFwdG9yJztcbmltcG9ydCB7IERpY3QgfSBmcm9tICdmb3VuZGF0aW9uL3R5cGVzJztcbmltcG9ydCB7IElQb2ludCwgSVBvc2UgfSBmcm9tICdmcmFtZXdvcmsvZ2VvbWV0cnkvY29tcG9uZW50cy9Qb3NlQ29tcG9uZW50JztcbmltcG9ydCB7IElJbWFnZSB9IGZyb20gJ2ZyYW1ld29yay9wcmVzZW50YXRpb24vY29tcG9uZW50cy9JbWFnZUNvbXBvbmVudCc7XG5pbXBvcnQgeyBJTGFiZWwgfSBmcm9tICdmcmFtZXdvcmsvcHJlc2VudGF0aW9uL2NvbXBvbmVudHMvTGFiZWxDb21wb25lbnQnO1xuaW1wb3J0IHsgSVN0eWxlIH0gZnJvbSAnZnJhbWV3b3JrL3ByZXNlbnRhdGlvbi9jb21wb25lbnRzL1N0eWxlQ29tcG9uZW50JztcblxuZnVuY3Rpb24gYXRvbWljKHRhcmdldDogSFRNTDVDYW52YXNWaWV3cG9ydEFkYXB0b3IsIGtleTogc3RyaW5nLCBkZXNjcmlwdG9yOiBQcm9wZXJ0eURlc2NyaXB0b3IpOiB2b2lkIHtcbiAgY29uc3QgZm4gPSBkZXNjcmlwdG9yLnZhbHVlO1xuICBkZXNjcmlwdG9yLnZhbHVlID0gZnVuY3Rpb24oKTogdm9pZCB7XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIGZuLmNhbGwodGhpcywgLi4uYXJndW1lbnRzKTtcbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gIH07XG59XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIEhUTUw1Q2FudmFzVmlld3BvcnRBZGFwdG9yIGltcGxlbWVudHMgSVZpZXdwb3J0QWRhcHRvcjxDYW52YXNJbWFnZVNvdXJjZT4ge1xuXG4gIFtrZXk6IHN0cmluZ106IGFueTtcblxuICBwdWJsaWMgY3R4OiBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkQ7XG4gIHB1YmxpYyB3aWR0aDogbnVtYmVyO1xuICBwdWJsaWMgaGVpZ2h0OiBudW1iZXI7XG5cbiAgcHJpdmF0ZSBfX2ltYWdlQnVmZmVyOiBEaWN0PEhUTUxJbWFnZUVsZW1lbnQ+ID0ge307XG5cbiAgcHJpdmF0ZSBfX3pCdWZmZXI6IEFycmF5PHsgbWV0aG9kOiBzdHJpbmc7IHBheWxvYWQ6IGFueSB9PiA9IFtdO1xuXG4gIGNvbnN0cnVjdG9yKGNhbnZhczogSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICB0aGlzLmN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpIGFzIENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICB0aGlzLndpZHRoID0gY2FudmFzLmNsaWVudFdpZHRoO1xuICAgIHRoaXMuaGVpZ2h0ID0gY2FudmFzLmNsaWVudEhlaWdodDtcbiAgfVxuXG4gIHB1YmxpYyBsb2FkKHNyYzogc3RyaW5nKTogQ2FudmFzSW1hZ2VTb3VyY2Uge1xuICAgIGlmICghdGhpcy5fX2ltYWdlQnVmZmVyW3NyY10pIHtcbiAgICAgIHRoaXMuX19pbWFnZUJ1ZmZlcltzcmNdID0gbmV3IEltYWdlKCk7XG4gICAgICB0aGlzLl9faW1hZ2VCdWZmZXJbc3JjXS5zcmMgPSBzcmM7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9faW1hZ2VCdWZmZXJbc3JjXTtcbiAgfVxuXG4gIHB1YmxpYyByZWZyZXNoKCk6IHZvaWQge1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG4gIH1cblxuICBwdWJsaWMgb25jZSgpOiB2b2lkIHtcbiAgICBjb25zdCB6QnVmZmVyID0gdGhpcy5fX3pCdWZmZXIubWFwKCh0YXJnZXQpID0+IHtcbiAgICAgIGlmICghdGFyZ2V0LnBheWxvYWQuc3R5bGUpIHtcbiAgICAgICAgdGFyZ2V0LnBheWxvYWQuc3R5bGUgPSB7IHpJbmRleDogMCB9O1xuICAgICAgICByZXR1cm4gdGFyZ2V0O1xuICAgICAgfVxuICAgICAgaWYgKCF0YXJnZXQucGF5bG9hZC5zdHlsZS56SW5kZXgpIHtcbiAgICAgICAgdGFyZ2V0LnBheWxvYWQuc3R5bGUuekluZGV4ID0gMDtcbiAgICAgICAgcmV0dXJuIHRhcmdldDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0YXJnZXQ7XG4gICAgfSk7XG4gICAgY29uc3Qgek9yZGVyZWQgPSB6QnVmZmVyLnNvcnQoKGEsIGIpID0+IGEucGF5bG9hZC5zdHlsZS56SW5kZXggLSBiLnBheWxvYWQuc3R5bGUuekluZGV4KTtcbiAgICB6T3JkZXJlZC5mb3JFYWNoKCh0YXJnZXQpID0+IHtcbiAgICAgIHRoaXNbYF9fJHt0YXJnZXQubWV0aG9kfWBdKHRhcmdldC5wYXlsb2FkKTtcbiAgICB9KTtcbiAgICB0aGlzLl9fekJ1ZmZlciA9IFtdO1xuICB9XG5cbiAgLyogZXNsaW50LWRpc2FibGUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzICovXG4gIHB1YmxpYyBkcmF3SW1hZ2UoeyBwb3NlLCBpbWFnZSB9OiB7IHBvc2U6IElQb3NlOyBpbWFnZTogSUltYWdlIH0pOiB2b2lkIHtcbiAgICB0aGlzLl9fekJ1ZmZlci5wdXNoKHsgbWV0aG9kOiAnZHJhd0ltYWdlJywgcGF5bG9hZDogYXJndW1lbnRzWzBdIH0pO1xuICB9XG5cbiAgcHVibGljIGRyYXdTaGFwZSh7IHBhdGgsIHN0eWxlIH06IHsgcGF0aDogSVBvaW50W107IHN0eWxlOiBJU3R5bGUgfSk6IHZvaWQge1xuICAgIHRoaXMuX196QnVmZmVyLnB1c2goeyBtZXRob2Q6ICdkcmF3U2hhcGUnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG4gIH1cblxuICBwdWJsaWMgZHJhd0xpbmUoeyBwYXRoLCBzdHlsZSB9OiB7IHBhdGg6IElQb2ludFtdOyBzdHlsZTogSVN0eWxlIH0pOiB2b2lkIHtcbiAgICB0aGlzLl9fekJ1ZmZlci5wdXNoKHsgbWV0aG9kOiAnZHJhd0xpbmUnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG4gIH1cblxuICBwdWJsaWMgZHJhd0xhYmVsKHsgcG9zZSwgbGFiZWwgfTogeyBwb3NlOiBJUG9zZTsgbGFiZWw6IElMYWJlbCB9KTogdm9pZCB7XG4gICAgdGhpcy5fX3pCdWZmZXIucHVzaCh7IG1ldGhvZDogJ2RyYXdMYWJlbCcsIHBheWxvYWQ6IGFyZ3VtZW50c1swXSB9KTtcbiAgfVxuXG4gIHB1YmxpYyBkcmF3Q2lyY2xlKHsgcG9zaXRpb24sIHJhZGl1cywgc3R5bGUgfToge1xuICAgIHBvc2l0aW9uOiBJUG9pbnQ7IHJhZGl1czogbnVtYmVyOyBzdHlsZTogSVN0eWxlO1xuICB9KTogdm9pZCB7XG4gICAgdGhpcy5fX3pCdWZmZXIucHVzaCh7IG1ldGhvZDogJ2RyYXdDaXJjbGUnLCBwYXlsb2FkOiBhcmd1bWVudHNbMF0gfSk7XG4gIH1cbiAgLyogZXNsaW50LWVuYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnMgKi9cblxuICBAYXRvbWljXG4gIHByaXZhdGUgX19kcmF3SW1hZ2UoeyBwb3NlLCBpbWFnZSB9OiB7IHBvc2U6IElQb3NlOyBpbWFnZTogSUltYWdlIH0pOiB2b2lkIHtcbiAgICBjb25zdCBhc3NldCA9IHRoaXMubG9hZChpbWFnZS5zcmMgfHwgJy4vZmF2aWNvbi5pY28nKTtcbiAgICB0aGlzLmN0eC50cmFuc2xhdGUocG9zZS54LCBwb3NlLnkpO1xuICAgIHRoaXMuY3R4LnJvdGF0ZShpbWFnZS5yb3RhdGUgfHwgMCk7XG4gICAgdGhpcy5jdHguZHJhd0ltYWdlKFxuICAgICAgYXNzZXQsXG4gICAgICAtKGltYWdlLndpZHRoIHx8IGFzc2V0LndpZHRoIGFzIG51bWJlcikgLyAyLFxuICAgICAgLShpbWFnZS5oZWlnaHQgfHwgYXNzZXQuaGVpZ2h0IGFzIG51bWJlcikgLyAyLFxuICAgICAgaW1hZ2Uud2lkdGggfHwgYXNzZXQud2lkdGggYXMgbnVtYmVyLFxuICAgICAgaW1hZ2UuaGVpZ2h0IHx8IGFzc2V0LmhlaWdodCBhcyBudW1iZXIsXG4gICAgKTtcbiAgfVxuXG4gIEBhdG9taWNcbiAgcHJpdmF0ZSBfX2RyYXdTaGFwZSh7IHBhdGgsIHN0eWxlIH06IHsgcGF0aDogSVBvaW50W107IHN0eWxlOiBJU3R5bGUgfSk6IHZvaWQge1xuICAgIHRoaXMuY3R4Lmdsb2JhbEFscGhhID0gc3R5bGUub3BhY2l0eTtcbiAgICB0aGlzLmN0eC5zdHJva2VTdHlsZSA9IHN0eWxlLmNvbG91cjtcbiAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICBwYXRoLmZvckVhY2goKHA6IElQb2ludCkgPT4ge1xuICAgICAgdGhpcy5jdHgubGluZVRvKHAueCwgcC55KTtcbiAgICB9KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzdHlsZS5maWxsO1xuICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICB0aGlzLmN0eC5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgfVxuXG4gIEBhdG9taWNcbiAgcHJpdmF0ZSBfX2RyYXdMaW5lKHsgcG9pbnRzLCBzdHlsZSB9OiB7IHBvaW50czogSVBvaW50W107IHN0eWxlOiBJU3R5bGUgfSk6IHZvaWQge1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3VyO1xuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIHBvaW50cy5mb3JFYWNoKChwOiBJUG9pbnQpID0+IHtcbiAgICAgIHRoaXMuY3R4LmxpbmVUbyhwLngsIHAueSk7XG4gICAgfSk7XG4gICAgdGhpcy5jdHguc3Ryb2tlKCk7XG4gIH1cblxuICBAYXRvbWljXG4gIHByaXZhdGUgX19kcmF3TGFiZWwoeyBwb3NlLCBsYWJlbCB9OiB7IHBvc2U6IElQb3NlOyBsYWJlbDogSUxhYmVsIH0pOiB2b2lkIHtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBsYWJlbC5jb2xvdXI7XG4gICAgdGhpcy5jdHguZm9udCA9IGAke2xhYmVsLmZvbnRTaXplfXB4IEFyaWFsYDtcbiAgICB0aGlzLmN0eC5maWxsVGV4dChsYWJlbC50ZXh0LCBwb3NlLnggKyBsYWJlbC5vZmZzZXQueCwgcG9zZS55ICsgbGFiZWwub2Zmc2V0LnkpO1xuICB9XG5cbiAgQGF0b21pY1xuICBwcml2YXRlIF9fZHJhd0NpcmNsZSh7IHBvc2l0aW9uLCByYWRpdXMsIHN0eWxlIH06IHtcbiAgICBwb3NpdGlvbjogSVBvaW50OyByYWRpdXM6IG51bWJlcjsgc3R5bGU6IElTdHlsZTtcbiAgfSk6IHZvaWQge1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gc3R5bGUuY29sb3VyO1xuICAgIHRoaXMuY3R4LmJlZ2luUGF0aCgpO1xuICAgIHRoaXMuY3R4LmFyYyhwb3NpdGlvbi54LCBwb3NpdGlvbi55LCByYWRpdXMsIDAsIDIgKiBNYXRoLlBJKTtcbiAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgfVxuXG59XG4iXSwic291cmNlUm9vdCI6IiJ9